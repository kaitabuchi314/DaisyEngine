#include <include/GL/glew.h>
#include <stb_image.h>
#include <iostream>
#include <glm.hpp>
#include <gtc/matrix_transform.hpp>
#include <gtc/type_ptr.hpp>
#include <Model.h>
#include <Texture.h>
#include <ShaderProgram.h>
#include <TextureFragmentShader.h>
#include <DfVertexShader.h>
#include <glfw3.h>
#include <Window.h>
#include <Camera.h>

void DrawBox(glm::vec3 position, glm::vec3 scale, float angle, Daisy::Model* mesh, Daisy::Texture* texture, Daisy::ShaderProgram* shaderProgram, glm::mat4 projection, glm::mat4 view)
{
    mesh->Bind();

    glm::mat4 model = glm::rotate(glm::mat4(1.0f), glm::radians(angle), glm::vec3(1.0f, 0.5f, 0.0f));

    model = glm::translate(model, position);
    model = glm::scale(model, scale);

    shaderProgram->Bind();

    glUniformMatrix4fv(glGetUniformLocation(shaderProgram->id, "model"), 1, GL_FALSE, glm::value_ptr(model));
    glUniformMatrix4fv(glGetUniformLocation(shaderProgram->id, "view"), 1, GL_FALSE, glm::value_ptr(view));
    glUniformMatrix4fv(glGetUniformLocation(shaderProgram->id, "projection"), 1, GL_FALSE, glm::value_ptr(projection));

    texture->Bind();

    glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, 0);

    texture->Unbind();

    mesh->Unbind();

    shaderProgram->Unbind();
}

float vertices[] =
{

    -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
     0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
     0.5f,  0.5f,  0.5f,  1.0f, 1.0f,
    -0.5f,  0.5f,  0.5f,  0.0f, 1.0f,

    -0.5f, -0.5f, -0.5f,  1.0f, 0.0f,
     0.5f, -0.5f, -0.5f,  0.0f, 0.0f,
     0.5f,  0.5f, -0.5f,  0.0f, 1.0f,
    -0.5f,  0.5f, -0.5f,  1.0f, 1.0f,

    -0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
    -0.5f,  0.5f, -0.5f,  0.0f, 0.0f,
    -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
    -0.5f, -0.5f,  0.5f,  1.0f, 1.0f,

     0.5f,  0.5f,  0.5f,  0.0f, 0.0f,
     0.5f,  0.5f, -0.5f,  1.0f, 0.0f,
     0.5f, -0.5f, -0.5f,  1.0f, 1.0f,
     0.5f, -0.5f,  0.5f,  0.0f, 1.0f,

     -0.5f,  0.5f,  0.5f,   0.0f, 1.0f,
      0.5f,  0.5f,  0.5f,   1.0f, 1.0f,
      0.5f,  0.5f, -0.5f,   1.0f, 0.0f,
     -0.5f,  0.5f, -0.5f,   0.0f, 0.0f,

     -0.5f, -0.5f,  0.5f,   1.0f, 1.0f,
      0.5f, -0.5f,  0.5f,   0.0f, 1.0f,
      0.5f, -0.5f, -0.5f,   0.0f, 0.0f,
     -0.5f, -0.5f, -0.5f,   1.0f, 0.0f
};

unsigned int indices[] =
{
    0,  1,  2,  2,  3,  0,
    4,  5,  6,  6,  7,  4,
    8,  9, 10, 10, 11,  8,
    12, 13, 14, 14, 15, 12,
    16, 17, 18, 18, 19, 16,
    20, 21, 22, 22, 23, 20
};


int main()
{
    Daisy::Window window = Daisy::Window("My Window", 800, 700);

    Daisy::ShaderProgram shaderProgram = Daisy::ShaderProgram(Daisy::dfvertexShaderSource, Daisy::textureFragmentShaderSource);

    Daisy::Texture texture = Daisy::Texture("box.png");

    

    Daisy::Model model = Daisy::Model(vertices, indices, sizeof(vertices), sizeof(indices));

    glm::vec2 ws = window.GetSize();

    Daisy::Camera camera = Daisy::Camera(ws);

    float cameraSpeed = 0.0008f;
    float cameraRotSpeed = 0.025f;

    while (!window.ShouldClose())
    {
        if (glfwGetKey(window.window, GLFW_KEY_W) == GLFW_PRESS)
            camera.cameraPos += cameraSpeed * cameraFront;
        if (glfwGetKey(window.window, GLFW_KEY_S) == GLFW_PRESS)
            cameraPos -= cameraSpeed * cameraFront;
        if (glfwGetKey(window.window, GLFW_KEY_Q) == GLFW_PRESS)
            cameraPos += cameraSpeed * cameraUp;
        if (glfwGetKey(window.window, GLFW_KEY_E) == GLFW_PRESS)
            cameraPos -= cameraSpeed * cameraUp;
        if (glfwGetKey(window.window, GLFW_KEY_A) == GLFW_PRESS)
            cameraPos -= glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;
        if (glfwGetKey(window.window, GLFW_KEY_D) == GLFW_PRESS)
            cameraPos += glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;

        if (glfwGetKey(window.window, GLFW_KEY_LEFT) == GLFW_PRESS)
            cameraFront = glm::mat3(glm::rotate(glm::mat4(1.0f), glm::radians(cameraRotSpeed), cameraUp)) * cameraFront;
        if (glfwGetKey(window.window, GLFW_KEY_RIGHT) == GLFW_PRESS)
            cameraFront = glm::mat3(glm::rotate(glm::mat4(1.0f), glm::radians(-cameraRotSpeed), cameraUp)) * cameraFront;
        if (glfwGetKey(window.window, GLFW_KEY_UP) == GLFW_PRESS)
            cameraFront = glm::mat3(glm::rotate(glm::mat4(1.0f), glm::radians(cameraRotSpeed), glm::normalize(glm::cross(cameraFront, cameraUp)))) * cameraFront;
        if (glfwGetKey(window.window, GLFW_KEY_DOWN) == GLFW_PRESS)
            cameraFront = glm::mat3(glm::rotate(glm::mat4(1.0f), glm::radians(-cameraRotSpeed), glm::normalize(glm::cross(cameraFront, cameraUp)))) * cameraFront;

        

        glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

        DrawBox(glm::vec3(0, 0, 0), glm::vec3(1, 1, 1), 100, &model, &texture, &shaderProgram, projection, view);

        glfwSwapBuffers(window.window);
        glfwPollEvents();
    }

    model.Flush();
    texture.Flush();
    shaderProgram.Flush();
    
    window.Terminate();
    return 0;
}