#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\src\\Model.cpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\src\\Model.h"
#pragma once
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"





















































































#line 87 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"


#line 90 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"


#line 93 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"


#line 96 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"


#line 99 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"


#line 102 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"



















 













#line 136 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"


#line 139 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"


#line 142 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"
#line 143 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"



#line 147 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"
#line 148 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"
 




#line 154 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

#line 156 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

#line 158 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"
#line 159 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"
 



#line 164 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"
 



#line 169 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"
 



#line 174 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

#line 176 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"
#line 177 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"


typedef __int64 ptrdiff_t;


#line 183 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"


#line 186 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"




#line 191 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

#line 193 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"
#line 194 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"













#line 208 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"
#line 209 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"















































#line 257 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"













extern "C" {
#line 272 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef unsigned int GLenum;
typedef unsigned int GLbitfield;
typedef unsigned int GLuint;
typedef int GLint;
typedef int GLsizei;
typedef unsigned char GLboolean;
typedef signed char GLbyte;
typedef short GLshort;
typedef unsigned char GLubyte;
typedef unsigned short GLushort;
typedef unsigned long GLulong;
typedef float GLfloat;
typedef float GLclampf;
typedef double GLdouble;
typedef double GLclampd;
typedef void GLvoid;



#line 298 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"
typedef signed long long GLint64EXT;
typedef unsigned long long GLuint64EXT;






#line 307 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"
typedef GLint64EXT  GLint64;
typedef GLuint64EXT GLuint64;
typedef struct __GLsync *GLsync;

typedef char GLchar;
























































































































































































































































































































































































































































































































































__declspec(dllimport) void __stdcall glAccum (GLenum op, GLfloat value);
__declspec(dllimport) void __stdcall glAlphaFunc (GLenum func, GLclampf ref);
__declspec(dllimport) GLboolean __stdcall glAreTexturesResident (GLsizei n, const GLuint *textures, GLboolean *residences);
__declspec(dllimport) void __stdcall glArrayElement (GLint i);
__declspec(dllimport) void __stdcall glBegin (GLenum mode);
__declspec(dllimport) void __stdcall glBindTexture (GLenum target, GLuint texture);
__declspec(dllimport) void __stdcall glBitmap (GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap);
__declspec(dllimport) void __stdcall glBlendFunc (GLenum sfactor, GLenum dfactor);
__declspec(dllimport) void __stdcall glCallList (GLuint list);
__declspec(dllimport) void __stdcall glCallLists (GLsizei n, GLenum type, const void *lists);
__declspec(dllimport) void __stdcall glClear (GLbitfield mask);
__declspec(dllimport) void __stdcall glClearAccum (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
__declspec(dllimport) void __stdcall glClearColor (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
__declspec(dllimport) void __stdcall glClearDepth (GLclampd depth);
__declspec(dllimport) void __stdcall glClearIndex (GLfloat c);
__declspec(dllimport) void __stdcall glClearStencil (GLint s);
__declspec(dllimport) void __stdcall glClipPlane (GLenum plane, const GLdouble *equation);
__declspec(dllimport) void __stdcall glColor3b (GLbyte red, GLbyte green, GLbyte blue);
__declspec(dllimport) void __stdcall glColor3bv (const GLbyte *v);
__declspec(dllimport) void __stdcall glColor3d (GLdouble red, GLdouble green, GLdouble blue);
__declspec(dllimport) void __stdcall glColor3dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glColor3f (GLfloat red, GLfloat green, GLfloat blue);
__declspec(dllimport) void __stdcall glColor3fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glColor3i (GLint red, GLint green, GLint blue);
__declspec(dllimport) void __stdcall glColor3iv (const GLint *v);
__declspec(dllimport) void __stdcall glColor3s (GLshort red, GLshort green, GLshort blue);
__declspec(dllimport) void __stdcall glColor3sv (const GLshort *v);
__declspec(dllimport) void __stdcall glColor3ub (GLubyte red, GLubyte green, GLubyte blue);
__declspec(dllimport) void __stdcall glColor3ubv (const GLubyte *v);
__declspec(dllimport) void __stdcall glColor3ui (GLuint red, GLuint green, GLuint blue);
__declspec(dllimport) void __stdcall glColor3uiv (const GLuint *v);
__declspec(dllimport) void __stdcall glColor3us (GLushort red, GLushort green, GLushort blue);
__declspec(dllimport) void __stdcall glColor3usv (const GLushort *v);
__declspec(dllimport) void __stdcall glColor4b (GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha);
__declspec(dllimport) void __stdcall glColor4bv (const GLbyte *v);
__declspec(dllimport) void __stdcall glColor4d (GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha);
__declspec(dllimport) void __stdcall glColor4dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glColor4f (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
__declspec(dllimport) void __stdcall glColor4fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glColor4i (GLint red, GLint green, GLint blue, GLint alpha);
__declspec(dllimport) void __stdcall glColor4iv (const GLint *v);
__declspec(dllimport) void __stdcall glColor4s (GLshort red, GLshort green, GLshort blue, GLshort alpha);
__declspec(dllimport) void __stdcall glColor4sv (const GLshort *v);
__declspec(dllimport) void __stdcall glColor4ub (GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);
__declspec(dllimport) void __stdcall glColor4ubv (const GLubyte *v);
__declspec(dllimport) void __stdcall glColor4ui (GLuint red, GLuint green, GLuint blue, GLuint alpha);
__declspec(dllimport) void __stdcall glColor4uiv (const GLuint *v);
__declspec(dllimport) void __stdcall glColor4us (GLushort red, GLushort green, GLushort blue, GLushort alpha);
__declspec(dllimport) void __stdcall glColor4usv (const GLushort *v);
__declspec(dllimport) void __stdcall glColorMask (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
__declspec(dllimport) void __stdcall glColorMaterial (GLenum face, GLenum mode);
__declspec(dllimport) void __stdcall glColorPointer (GLint size, GLenum type, GLsizei stride, const void *pointer);
__declspec(dllimport) void __stdcall glCopyPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum type);
__declspec(dllimport) void __stdcall glCopyTexImage1D (GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLint border);
__declspec(dllimport) void __stdcall glCopyTexImage2D (GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
__declspec(dllimport) void __stdcall glCopyTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
__declspec(dllimport) void __stdcall glCopyTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
__declspec(dllimport) void __stdcall glCullFace (GLenum mode);
__declspec(dllimport) void __stdcall glDeleteLists (GLuint list, GLsizei range);
__declspec(dllimport) void __stdcall glDeleteTextures (GLsizei n, const GLuint *textures);
__declspec(dllimport) void __stdcall glDepthFunc (GLenum func);
__declspec(dllimport) void __stdcall glDepthMask (GLboolean flag);
__declspec(dllimport) void __stdcall glDepthRange (GLclampd zNear, GLclampd zFar);
__declspec(dllimport) void __stdcall glDisable (GLenum cap);
__declspec(dllimport) void __stdcall glDisableClientState (GLenum array);
__declspec(dllimport) void __stdcall glDrawArrays (GLenum mode, GLint first, GLsizei count);
__declspec(dllimport) void __stdcall glDrawBuffer (GLenum mode);
__declspec(dllimport) void __stdcall glDrawElements (GLenum mode, GLsizei count, GLenum type, const void *indices);
__declspec(dllimport) void __stdcall glDrawPixels (GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
__declspec(dllimport) void __stdcall glEdgeFlag (GLboolean flag);
__declspec(dllimport) void __stdcall glEdgeFlagPointer (GLsizei stride, const void *pointer);
__declspec(dllimport) void __stdcall glEdgeFlagv (const GLboolean *flag);
__declspec(dllimport) void __stdcall glEnable (GLenum cap);
__declspec(dllimport) void __stdcall glEnableClientState (GLenum array);
__declspec(dllimport) void __stdcall glEnd (void);
__declspec(dllimport) void __stdcall glEndList (void);
__declspec(dllimport) void __stdcall glEvalCoord1d (GLdouble u);
__declspec(dllimport) void __stdcall glEvalCoord1dv (const GLdouble *u);
__declspec(dllimport) void __stdcall glEvalCoord1f (GLfloat u);
__declspec(dllimport) void __stdcall glEvalCoord1fv (const GLfloat *u);
__declspec(dllimport) void __stdcall glEvalCoord2d (GLdouble u, GLdouble v);
__declspec(dllimport) void __stdcall glEvalCoord2dv (const GLdouble *u);
__declspec(dllimport) void __stdcall glEvalCoord2f (GLfloat u, GLfloat v);
__declspec(dllimport) void __stdcall glEvalCoord2fv (const GLfloat *u);
__declspec(dllimport) void __stdcall glEvalMesh1 (GLenum mode, GLint i1, GLint i2);
__declspec(dllimport) void __stdcall glEvalMesh2 (GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2);
__declspec(dllimport) void __stdcall glEvalPoint1 (GLint i);
__declspec(dllimport) void __stdcall glEvalPoint2 (GLint i, GLint j);
__declspec(dllimport) void __stdcall glFeedbackBuffer (GLsizei size, GLenum type, GLfloat *buffer);
__declspec(dllimport) void __stdcall glFinish (void);
__declspec(dllimport) void __stdcall glFlush (void);
__declspec(dllimport) void __stdcall glFogf (GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glFogfv (GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glFogi (GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glFogiv (GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glFrontFace (GLenum mode);
__declspec(dllimport) void __stdcall glFrustum (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
__declspec(dllimport) GLuint __stdcall glGenLists (GLsizei range);
__declspec(dllimport) void __stdcall glGenTextures (GLsizei n, GLuint *textures);
__declspec(dllimport) void __stdcall glGetBooleanv (GLenum pname, GLboolean *params);
__declspec(dllimport) void __stdcall glGetClipPlane (GLenum plane, GLdouble *equation);
__declspec(dllimport) void __stdcall glGetDoublev (GLenum pname, GLdouble *params);
__declspec(dllimport) GLenum __stdcall glGetError (void);
__declspec(dllimport) void __stdcall glGetFloatv (GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetIntegerv (GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glGetLightfv (GLenum light, GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetLightiv (GLenum light, GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glGetMapdv (GLenum target, GLenum query, GLdouble *v);
__declspec(dllimport) void __stdcall glGetMapfv (GLenum target, GLenum query, GLfloat *v);
__declspec(dllimport) void __stdcall glGetMapiv (GLenum target, GLenum query, GLint *v);
__declspec(dllimport) void __stdcall glGetMaterialfv (GLenum face, GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetMaterialiv (GLenum face, GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glGetPixelMapfv (GLenum map, GLfloat *values);
__declspec(dllimport) void __stdcall glGetPixelMapuiv (GLenum map, GLuint *values);
__declspec(dllimport) void __stdcall glGetPixelMapusv (GLenum map, GLushort *values);
__declspec(dllimport) void __stdcall glGetPointerv (GLenum pname, void* *params);
__declspec(dllimport) void __stdcall glGetPolygonStipple (GLubyte *mask);
__declspec(dllimport) const GLubyte * __stdcall glGetString (GLenum name);
__declspec(dllimport) void __stdcall glGetTexEnvfv (GLenum target, GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetTexEnviv (GLenum target, GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glGetTexGendv (GLenum coord, GLenum pname, GLdouble *params);
__declspec(dllimport) void __stdcall glGetTexGenfv (GLenum coord, GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetTexGeniv (GLenum coord, GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glGetTexImage (GLenum target, GLint level, GLenum format, GLenum type, void *pixels);
__declspec(dllimport) void __stdcall glGetTexLevelParameterfv (GLenum target, GLint level, GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetTexLevelParameteriv (GLenum target, GLint level, GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glGetTexParameterfv (GLenum target, GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetTexParameteriv (GLenum target, GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glHint (GLenum target, GLenum mode);
__declspec(dllimport) void __stdcall glIndexMask (GLuint mask);
__declspec(dllimport) void __stdcall glIndexPointer (GLenum type, GLsizei stride, const void *pointer);
__declspec(dllimport) void __stdcall glIndexd (GLdouble c);
__declspec(dllimport) void __stdcall glIndexdv (const GLdouble *c);
__declspec(dllimport) void __stdcall glIndexf (GLfloat c);
__declspec(dllimport) void __stdcall glIndexfv (const GLfloat *c);
__declspec(dllimport) void __stdcall glIndexi (GLint c);
__declspec(dllimport) void __stdcall glIndexiv (const GLint *c);
__declspec(dllimport) void __stdcall glIndexs (GLshort c);
__declspec(dllimport) void __stdcall glIndexsv (const GLshort *c);
__declspec(dllimport) void __stdcall glIndexub (GLubyte c);
__declspec(dllimport) void __stdcall glIndexubv (const GLubyte *c);
__declspec(dllimport) void __stdcall glInitNames (void);
__declspec(dllimport) void __stdcall glInterleavedArrays (GLenum format, GLsizei stride, const void *pointer);
__declspec(dllimport) GLboolean __stdcall glIsEnabled (GLenum cap);
__declspec(dllimport) GLboolean __stdcall glIsList (GLuint list);
__declspec(dllimport) GLboolean __stdcall glIsTexture (GLuint texture);
__declspec(dllimport) void __stdcall glLightModelf (GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glLightModelfv (GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glLightModeli (GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glLightModeliv (GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glLightf (GLenum light, GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glLightfv (GLenum light, GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glLighti (GLenum light, GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glLightiv (GLenum light, GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glLineStipple (GLint factor, GLushort pattern);
__declspec(dllimport) void __stdcall glLineWidth (GLfloat width);
__declspec(dllimport) void __stdcall glListBase (GLuint base);
__declspec(dllimport) void __stdcall glLoadIdentity (void);
__declspec(dllimport) void __stdcall glLoadMatrixd (const GLdouble *m);
__declspec(dllimport) void __stdcall glLoadMatrixf (const GLfloat *m);
__declspec(dllimport) void __stdcall glLoadName (GLuint name);
__declspec(dllimport) void __stdcall glLogicOp (GLenum opcode);
__declspec(dllimport) void __stdcall glMap1d (GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points);
__declspec(dllimport) void __stdcall glMap1f (GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points);
__declspec(dllimport) void __stdcall glMap2d (GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points);
__declspec(dllimport) void __stdcall glMap2f (GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points);
__declspec(dllimport) void __stdcall glMapGrid1d (GLint un, GLdouble u1, GLdouble u2);
__declspec(dllimport) void __stdcall glMapGrid1f (GLint un, GLfloat u1, GLfloat u2);
__declspec(dllimport) void __stdcall glMapGrid2d (GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2);
__declspec(dllimport) void __stdcall glMapGrid2f (GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2);
__declspec(dllimport) void __stdcall glMaterialf (GLenum face, GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glMaterialfv (GLenum face, GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glMateriali (GLenum face, GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glMaterialiv (GLenum face, GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glMatrixMode (GLenum mode);
__declspec(dllimport) void __stdcall glMultMatrixd (const GLdouble *m);
__declspec(dllimport) void __stdcall glMultMatrixf (const GLfloat *m);
__declspec(dllimport) void __stdcall glNewList (GLuint list, GLenum mode);
__declspec(dllimport) void __stdcall glNormal3b (GLbyte nx, GLbyte ny, GLbyte nz);
__declspec(dllimport) void __stdcall glNormal3bv (const GLbyte *v);
__declspec(dllimport) void __stdcall glNormal3d (GLdouble nx, GLdouble ny, GLdouble nz);
__declspec(dllimport) void __stdcall glNormal3dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glNormal3f (GLfloat nx, GLfloat ny, GLfloat nz);
__declspec(dllimport) void __stdcall glNormal3fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glNormal3i (GLint nx, GLint ny, GLint nz);
__declspec(dllimport) void __stdcall glNormal3iv (const GLint *v);
__declspec(dllimport) void __stdcall glNormal3s (GLshort nx, GLshort ny, GLshort nz);
__declspec(dllimport) void __stdcall glNormal3sv (const GLshort *v);
__declspec(dllimport) void __stdcall glNormalPointer (GLenum type, GLsizei stride, const void *pointer);
__declspec(dllimport) void __stdcall glOrtho (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
__declspec(dllimport) void __stdcall glPassThrough (GLfloat token);
__declspec(dllimport) void __stdcall glPixelMapfv (GLenum map, GLsizei mapsize, const GLfloat *values);
__declspec(dllimport) void __stdcall glPixelMapuiv (GLenum map, GLsizei mapsize, const GLuint *values);
__declspec(dllimport) void __stdcall glPixelMapusv (GLenum map, GLsizei mapsize, const GLushort *values);
__declspec(dllimport) void __stdcall glPixelStoref (GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glPixelStorei (GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glPixelTransferf (GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glPixelTransferi (GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glPixelZoom (GLfloat xfactor, GLfloat yfactor);
__declspec(dllimport) void __stdcall glPointSize (GLfloat size);
__declspec(dllimport) void __stdcall glPolygonMode (GLenum face, GLenum mode);
__declspec(dllimport) void __stdcall glPolygonOffset (GLfloat factor, GLfloat units);
__declspec(dllimport) void __stdcall glPolygonStipple (const GLubyte *mask);
__declspec(dllimport) void __stdcall glPopAttrib (void);
__declspec(dllimport) void __stdcall glPopClientAttrib (void);
__declspec(dllimport) void __stdcall glPopMatrix (void);
__declspec(dllimport) void __stdcall glPopName (void);
__declspec(dllimport) void __stdcall glPrioritizeTextures (GLsizei n, const GLuint *textures, const GLclampf *priorities);
__declspec(dllimport) void __stdcall glPushAttrib (GLbitfield mask);
__declspec(dllimport) void __stdcall glPushClientAttrib (GLbitfield mask);
__declspec(dllimport) void __stdcall glPushMatrix (void);
__declspec(dllimport) void __stdcall glPushName (GLuint name);
__declspec(dllimport) void __stdcall glRasterPos2d (GLdouble x, GLdouble y);
__declspec(dllimport) void __stdcall glRasterPos2dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glRasterPos2f (GLfloat x, GLfloat y);
__declspec(dllimport) void __stdcall glRasterPos2fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glRasterPos2i (GLint x, GLint y);
__declspec(dllimport) void __stdcall glRasterPos2iv (const GLint *v);
__declspec(dllimport) void __stdcall glRasterPos2s (GLshort x, GLshort y);
__declspec(dllimport) void __stdcall glRasterPos2sv (const GLshort *v);
__declspec(dllimport) void __stdcall glRasterPos3d (GLdouble x, GLdouble y, GLdouble z);
__declspec(dllimport) void __stdcall glRasterPos3dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glRasterPos3f (GLfloat x, GLfloat y, GLfloat z);
__declspec(dllimport) void __stdcall glRasterPos3fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glRasterPos3i (GLint x, GLint y, GLint z);
__declspec(dllimport) void __stdcall glRasterPos3iv (const GLint *v);
__declspec(dllimport) void __stdcall glRasterPos3s (GLshort x, GLshort y, GLshort z);
__declspec(dllimport) void __stdcall glRasterPos3sv (const GLshort *v);
__declspec(dllimport) void __stdcall glRasterPos4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
__declspec(dllimport) void __stdcall glRasterPos4dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glRasterPos4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
__declspec(dllimport) void __stdcall glRasterPos4fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glRasterPos4i (GLint x, GLint y, GLint z, GLint w);
__declspec(dllimport) void __stdcall glRasterPos4iv (const GLint *v);
__declspec(dllimport) void __stdcall glRasterPos4s (GLshort x, GLshort y, GLshort z, GLshort w);
__declspec(dllimport) void __stdcall glRasterPos4sv (const GLshort *v);
__declspec(dllimport) void __stdcall glReadBuffer (GLenum mode);
__declspec(dllimport) void __stdcall glReadPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void *pixels);
__declspec(dllimport) void __stdcall glRectd (GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2);
__declspec(dllimport) void __stdcall glRectdv (const GLdouble *v1, const GLdouble *v2);
__declspec(dllimport) void __stdcall glRectf (GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2);
__declspec(dllimport) void __stdcall glRectfv (const GLfloat *v1, const GLfloat *v2);
__declspec(dllimport) void __stdcall glRecti (GLint x1, GLint y1, GLint x2, GLint y2);
__declspec(dllimport) void __stdcall glRectiv (const GLint *v1, const GLint *v2);
__declspec(dllimport) void __stdcall glRects (GLshort x1, GLshort y1, GLshort x2, GLshort y2);
__declspec(dllimport) void __stdcall glRectsv (const GLshort *v1, const GLshort *v2);
__declspec(dllimport) GLint __stdcall glRenderMode (GLenum mode);
__declspec(dllimport) void __stdcall glRotated (GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
__declspec(dllimport) void __stdcall glRotatef (GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
__declspec(dllimport) void __stdcall glScaled (GLdouble x, GLdouble y, GLdouble z);
__declspec(dllimport) void __stdcall glScalef (GLfloat x, GLfloat y, GLfloat z);
__declspec(dllimport) void __stdcall glScissor (GLint x, GLint y, GLsizei width, GLsizei height);
__declspec(dllimport) void __stdcall glSelectBuffer (GLsizei size, GLuint *buffer);
__declspec(dllimport) void __stdcall glShadeModel (GLenum mode);
__declspec(dllimport) void __stdcall glStencilFunc (GLenum func, GLint ref, GLuint mask);
__declspec(dllimport) void __stdcall glStencilMask (GLuint mask);
__declspec(dllimport) void __stdcall glStencilOp (GLenum fail, GLenum zfail, GLenum zpass);
__declspec(dllimport) void __stdcall glTexCoord1d (GLdouble s);
__declspec(dllimport) void __stdcall glTexCoord1dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glTexCoord1f (GLfloat s);
__declspec(dllimport) void __stdcall glTexCoord1fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glTexCoord1i (GLint s);
__declspec(dllimport) void __stdcall glTexCoord1iv (const GLint *v);
__declspec(dllimport) void __stdcall glTexCoord1s (GLshort s);
__declspec(dllimport) void __stdcall glTexCoord1sv (const GLshort *v);
__declspec(dllimport) void __stdcall glTexCoord2d (GLdouble s, GLdouble t);
__declspec(dllimport) void __stdcall glTexCoord2dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glTexCoord2f (GLfloat s, GLfloat t);
__declspec(dllimport) void __stdcall glTexCoord2fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glTexCoord2i (GLint s, GLint t);
__declspec(dllimport) void __stdcall glTexCoord2iv (const GLint *v);
__declspec(dllimport) void __stdcall glTexCoord2s (GLshort s, GLshort t);
__declspec(dllimport) void __stdcall glTexCoord2sv (const GLshort *v);
__declspec(dllimport) void __stdcall glTexCoord3d (GLdouble s, GLdouble t, GLdouble r);
__declspec(dllimport) void __stdcall glTexCoord3dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glTexCoord3f (GLfloat s, GLfloat t, GLfloat r);
__declspec(dllimport) void __stdcall glTexCoord3fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glTexCoord3i (GLint s, GLint t, GLint r);
__declspec(dllimport) void __stdcall glTexCoord3iv (const GLint *v);
__declspec(dllimport) void __stdcall glTexCoord3s (GLshort s, GLshort t, GLshort r);
__declspec(dllimport) void __stdcall glTexCoord3sv (const GLshort *v);
__declspec(dllimport) void __stdcall glTexCoord4d (GLdouble s, GLdouble t, GLdouble r, GLdouble q);
__declspec(dllimport) void __stdcall glTexCoord4dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glTexCoord4f (GLfloat s, GLfloat t, GLfloat r, GLfloat q);
__declspec(dllimport) void __stdcall glTexCoord4fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glTexCoord4i (GLint s, GLint t, GLint r, GLint q);
__declspec(dllimport) void __stdcall glTexCoord4iv (const GLint *v);
__declspec(dllimport) void __stdcall glTexCoord4s (GLshort s, GLshort t, GLshort r, GLshort q);
__declspec(dllimport) void __stdcall glTexCoord4sv (const GLshort *v);
__declspec(dllimport) void __stdcall glTexCoordPointer (GLint size, GLenum type, GLsizei stride, const void *pointer);
__declspec(dllimport) void __stdcall glTexEnvf (GLenum target, GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glTexEnvfv (GLenum target, GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glTexEnvi (GLenum target, GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glTexEnviv (GLenum target, GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glTexGend (GLenum coord, GLenum pname, GLdouble param);
__declspec(dllimport) void __stdcall glTexGendv (GLenum coord, GLenum pname, const GLdouble *params);
__declspec(dllimport) void __stdcall glTexGenf (GLenum coord, GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glTexGenfv (GLenum coord, GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glTexGeni (GLenum coord, GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glTexGeniv (GLenum coord, GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glTexImage1D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *pixels);
__declspec(dllimport) void __stdcall glTexImage2D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels);
__declspec(dllimport) void __stdcall glTexParameterf (GLenum target, GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glTexParameterfv (GLenum target, GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glTexParameteri (GLenum target, GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glTexParameteriv (GLenum target, GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
__declspec(dllimport) void __stdcall glTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
__declspec(dllimport) void __stdcall glTranslated (GLdouble x, GLdouble y, GLdouble z);
__declspec(dllimport) void __stdcall glTranslatef (GLfloat x, GLfloat y, GLfloat z);
__declspec(dllimport) void __stdcall glVertex2d (GLdouble x, GLdouble y);
__declspec(dllimport) void __stdcall glVertex2dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glVertex2f (GLfloat x, GLfloat y);
__declspec(dllimport) void __stdcall glVertex2fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glVertex2i (GLint x, GLint y);
__declspec(dllimport) void __stdcall glVertex2iv (const GLint *v);
__declspec(dllimport) void __stdcall glVertex2s (GLshort x, GLshort y);
__declspec(dllimport) void __stdcall glVertex2sv (const GLshort *v);
__declspec(dllimport) void __stdcall glVertex3d (GLdouble x, GLdouble y, GLdouble z);
__declspec(dllimport) void __stdcall glVertex3dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glVertex3f (GLfloat x, GLfloat y, GLfloat z);
__declspec(dllimport) void __stdcall glVertex3fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glVertex3i (GLint x, GLint y, GLint z);
__declspec(dllimport) void __stdcall glVertex3iv (const GLint *v);
__declspec(dllimport) void __stdcall glVertex3s (GLshort x, GLshort y, GLshort z);
__declspec(dllimport) void __stdcall glVertex3sv (const GLshort *v);
__declspec(dllimport) void __stdcall glVertex4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
__declspec(dllimport) void __stdcall glVertex4dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glVertex4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
__declspec(dllimport) void __stdcall glVertex4fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glVertex4i (GLint x, GLint y, GLint z, GLint w);
__declspec(dllimport) void __stdcall glVertex4iv (const GLint *v);
__declspec(dllimport) void __stdcall glVertex4s (GLshort x, GLshort y, GLshort z, GLshort w);
__declspec(dllimport) void __stdcall glVertex4sv (const GLshort *v);
__declspec(dllimport) void __stdcall glVertexPointer (GLint size, GLenum type, GLsizei stride, const void *pointer);
__declspec(dllimport) void __stdcall glViewport (GLint x, GLint y, GLsizei width, GLsizei height);



#line 1188 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 1199 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"


 


#line 1205 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\um\\GL\\glu.h"





















#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared\\winapifamily.h"



















#pragma warning(push)
#pragma warning(disable:4001) 
#line 23 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared\\winapifamily.h"
#pragma once
#line 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared\\winapifamily.h"

#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared\\winpackagefamily.h"



















#pragma warning(push)
#pragma warning(disable:4001) 
#line 23 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared\\winpackagefamily.h"
#pragma once
#line 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared\\winpackagefamily.h"



#line 29 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared\\winpackagefamily.h"


























































#pragma warning(pop)
#line 89 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared\\winpackagefamily.h"
#line 90 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared\\winpackagefamily.h"

#line 92 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared\\winpackagefamily.h"
#pragma external_header(pop)
#line 27 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared\\winapifamily.h"















































 
 














#line 91 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared\\winapifamily.h"



















































#line 148 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared\\winapifamily.h"



#line 152 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared\\winapifamily.h"






#line 159 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared\\winapifamily.h"





#line 165 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared\\winapifamily.h"



#line 169 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared\\winapifamily.h"





#line 175 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared\\winapifamily.h"











#line 187 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared\\winapifamily.h"






































 

















#line 244 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared\\winapifamily.h"



#pragma warning(pop)
#line 249 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared\\winapifamily.h"
#line 250 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared\\winapifamily.h"

#line 252 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared\\winapifamily.h"
#pragma external_header(pop)
#line 23 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\um\\GL\\glu.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\um\\GL\\gl.h"






























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#pragma external_header(pop)
#line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\um\\GL\\glu.h"


extern "C" {
#line 28 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\um\\GL\\glu.h"


















#pragma region Desktop Family















#line 63 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\um\\GL\\glu.h"

const GLubyte* __stdcall gluErrorString (
    GLenum   errCode);

const wchar_t* __stdcall gluErrorUnicodeStringEXT (
    GLenum   errCode);

const GLubyte* __stdcall gluGetString (
    GLenum   name);

void __stdcall gluOrtho2D (
    GLdouble left, 
    GLdouble right, 
    GLdouble bottom, 
    GLdouble top);

void __stdcall gluPerspective (
    GLdouble fovy, 
    GLdouble aspect, 
    GLdouble zNear, 
    GLdouble zFar);

void __stdcall gluPickMatrix (
    GLdouble x, 
    GLdouble y, 
    GLdouble width, 
    GLdouble height, 
    GLint    viewport[4]);

void __stdcall gluLookAt (
    GLdouble eyex, 
    GLdouble eyey, 
    GLdouble eyez, 
    GLdouble centerx, 
    GLdouble centery, 
    GLdouble centerz, 
    GLdouble upx, 
    GLdouble upy, 
    GLdouble upz);

int __stdcall gluProject (
    GLdouble        objx, 
    GLdouble        objy, 
    GLdouble        objz,  
    const GLdouble  modelMatrix[16], 
    const GLdouble  projMatrix[16], 
    const GLint     viewport[4], 
    GLdouble        *winx, 
    GLdouble        *winy, 
    GLdouble        *winz);

int __stdcall gluUnProject (
    GLdouble       winx, 
    GLdouble       winy, 
    GLdouble       winz, 
    const GLdouble modelMatrix[16], 
    const GLdouble projMatrix[16], 
    const GLint    viewport[4], 
    GLdouble       *objx, 
    GLdouble       *objy, 
    GLdouble       *objz);


int __stdcall gluScaleImage (
    GLenum      format, 
    GLint       widthin, 
    GLint       heightin, 
    GLenum      typein, 
    const void  *datain, 
    GLint       widthout, 
    GLint       heightout, 
    GLenum      typeout, 
    void        *dataout);


int __stdcall gluBuild1DMipmaps (
    GLenum      target, 
    GLint       components, 
    GLint       width, 
    GLenum      format, 
    GLenum      type, 
    const void  *data);

int __stdcall gluBuild2DMipmaps (
    GLenum      target, 
    GLint       components, 
    GLint       width, 
    GLint       height, 
    GLenum      format, 
    GLenum      type, 
    const void  *data);



class GLUnurbs;
class GLUquadric;
class GLUtesselator;

 
typedef class GLUnurbs GLUnurbsObj;
typedef class GLUquadric GLUquadricObj;
typedef class GLUtesselator GLUtesselatorObj;
typedef class GLUtesselator GLUtriangulatorObj;













#line 180 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\um\\GL\\glu.h"


GLUquadric* __stdcall gluNewQuadric (void);
void __stdcall gluDeleteQuadric (
    GLUquadric          *state);

void __stdcall gluQuadricNormals (
    GLUquadric          *quadObject, 
    GLenum              normals);

void __stdcall gluQuadricTexture (
    GLUquadric          *quadObject, 
    GLboolean           textureCoords);

void __stdcall gluQuadricOrientation (
    GLUquadric          *quadObject, 
    GLenum              orientation);

void __stdcall gluQuadricDrawStyle (
    GLUquadric          *quadObject, 
    GLenum              drawStyle);

void __stdcall gluCylinder (
    GLUquadric          *qobj, 
    GLdouble            baseRadius, 
    GLdouble            topRadius, 
    GLdouble            height, 
    GLint               slices, 
    GLint               stacks);

void __stdcall gluDisk (
    GLUquadric          *qobj, 
    GLdouble            innerRadius, 
    GLdouble            outerRadius, 
    GLint               slices, 
    GLint               loops);

void __stdcall gluPartialDisk (
    GLUquadric          *qobj, 
    GLdouble            innerRadius, 
    GLdouble            outerRadius, 
    GLint               slices, 
    GLint               loops, 
    GLdouble            startAngle, 
    GLdouble            sweepAngle);

void __stdcall gluSphere (
    GLUquadric          *qobj, 
    GLdouble            radius, 
    GLint               slices, 
    GLint               stacks);

void __stdcall gluQuadricCallback (
    GLUquadric          *qobj, 
    GLenum              which, 
    void                ( * fn)());

GLUtesselator* __stdcall  gluNewTess(          
    void );

void __stdcall  gluDeleteTess(       
    GLUtesselator       *tess );

void __stdcall  gluTessBeginPolygon( 
    GLUtesselator       *tess,
    void                *polygon_data );

void __stdcall  gluTessBeginContour( 
    GLUtesselator       *tess );

void __stdcall  gluTessVertex(       
    GLUtesselator       *tess,
    GLdouble            coords[3], 
    void                *data );

void __stdcall  gluTessEndContour(   
    GLUtesselator       *tess );

void __stdcall  gluTessEndPolygon(   
    GLUtesselator       *tess );

void __stdcall  gluTessProperty(     
    GLUtesselator       *tess,
    GLenum              which, 
    GLdouble            value );
 
void __stdcall  gluTessNormal(       
    GLUtesselator       *tess, 
    GLdouble            x,
    GLdouble            y, 
    GLdouble            z );

void __stdcall  gluTessCallback(     
    GLUtesselator       *tess,
    GLenum              which, 
    void                ( *fn)());

void __stdcall  gluGetTessProperty(  
    GLUtesselator       *tess,
    GLenum              which, 
    GLdouble            *value );
 
GLUnurbs* __stdcall gluNewNurbsRenderer (void);

void __stdcall gluDeleteNurbsRenderer (
    GLUnurbs            *nobj);

void __stdcall gluBeginSurface (
    GLUnurbs            *nobj);

void __stdcall gluBeginCurve (
    GLUnurbs            *nobj);

void __stdcall gluEndCurve (
    GLUnurbs            *nobj);

void __stdcall gluEndSurface (
    GLUnurbs            *nobj);

void __stdcall gluBeginTrim (
    GLUnurbs            *nobj);

void __stdcall gluEndTrim (
    GLUnurbs            *nobj);

void __stdcall gluPwlCurve (
    GLUnurbs            *nobj, 
    GLint               count, 
    GLfloat             *array, 
    GLint               stride, 
    GLenum              type);

void __stdcall gluNurbsCurve (
    GLUnurbs            *nobj, 
    GLint               nknots, 
    GLfloat             *knot, 
    GLint               stride, 
    GLfloat             *ctlarray, 
    GLint               order, 
    GLenum              type);

void __stdcall 
gluNurbsSurface(     
    GLUnurbs            *nobj, 
    GLint               sknot_count, 
    float               *sknot, 
    GLint               tknot_count, 
    GLfloat             *tknot, 
    GLint               s_stride, 
    GLint               t_stride, 
    GLfloat             *ctlarray, 
    GLint               sorder, 
    GLint               torder, 
    GLenum              type);

void __stdcall 
gluLoadSamplingMatrices (
    GLUnurbs            *nobj, 
    const GLfloat       modelMatrix[16], 
    const GLfloat       projMatrix[16], 
    const GLint         viewport[4] );

void __stdcall 
gluNurbsProperty (
    GLUnurbs            *nobj, 
    GLenum              property, 
    GLfloat             value );

void __stdcall 
gluGetNurbsProperty (
    GLUnurbs            *nobj, 
    GLenum              property, 
    GLfloat             *value );

void __stdcall 
gluNurbsCallback (
    GLUnurbs            *nobj, 
    GLenum              which, 
    void                ( * fn)() );


 

 
typedef void ( * GLUquadricErrorProc) (GLenum);

 
typedef void ( * GLUtessBeginProc)        (GLenum);
typedef void ( * GLUtessEdgeFlagProc)     (GLboolean);
typedef void ( * GLUtessVertexProc)       (void *);
typedef void ( * GLUtessEndProc)          (void);
typedef void ( * GLUtessErrorProc)        (GLenum);
typedef void ( * GLUtessCombineProc)      (GLdouble[3],
                                                  void*[4], 
                                                  GLfloat[4],
                                                  void** );
typedef void ( * GLUtessBeginDataProc)    (GLenum, void *);
typedef void ( * GLUtessEdgeFlagDataProc) (GLboolean, void *);
typedef void ( * GLUtessVertexDataProc)   (void *, void *);
typedef void ( * GLUtessEndDataProc)      (void *);
typedef void ( * GLUtessErrorDataProc)    (GLenum, void *);
typedef void ( * GLUtessCombineDataProc)  (GLdouble[3],
                                                  void*[4], 
                                                  GLfloat[4],
                                                  void**,
                                                  void* );

 
typedef void ( * GLUnurbsErrorProc)   (GLenum);


 

 



 





 



 




 

 




 





 



 
 


 



 




 






 
























 
















 

 









 





 



 
 



 
 

 






































 

void __stdcall   gluBeginPolygon( GLUtesselator *tess );

void __stdcall   gluNextContour(  GLUtesselator *tess, 
                                 GLenum        type );

void __stdcall   gluEndPolygon(   GLUtesselator *tess );

 






 






#line 584 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\um\\GL\\glu.h"
#pragma endregion


}
#line 589 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\um\\GL\\glu.h"

#line 591 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\um\\GL\\glu.h"
#line 592 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\um\\GL\\glu.h"
#pragma external_header(pop)
#line 1206 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"
#line 1207 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"
#line 1208 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 













































typedef void (__stdcall * PFNGLCOPYTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLDRAWRANGEELEMENTSPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices);
typedef void (__stdcall * PFNGLTEXIMAGE3DPROC) (GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);








#line 1268 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 1277 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 





































































































typedef void (__stdcall * PFNGLACTIVETEXTUREPROC) (GLenum texture);
typedef void (__stdcall * PFNGLCLIENTACTIVETEXTUREPROC) (GLenum texture);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXIMAGE1DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXIMAGE2DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXIMAGE3DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLGETCOMPRESSEDTEXIMAGEPROC) (GLenum target, GLint lod, void *img);
typedef void (__stdcall * PFNGLLOADTRANSPOSEMATRIXDPROC) (const GLdouble m[16]);
typedef void (__stdcall * PFNGLLOADTRANSPOSEMATRIXFPROC) (const GLfloat m[16]);
typedef void (__stdcall * PFNGLMULTTRANSPOSEMATRIXDPROC) (const GLdouble m[16]);
typedef void (__stdcall * PFNGLMULTTRANSPOSEMATRIXFPROC) (const GLfloat m[16]);
typedef void (__stdcall * PFNGLMULTITEXCOORD1DPROC) (GLenum target, GLdouble s);
typedef void (__stdcall * PFNGLMULTITEXCOORD1DVPROC) (GLenum target, const GLdouble *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD1FPROC) (GLenum target, GLfloat s);
typedef void (__stdcall * PFNGLMULTITEXCOORD1FVPROC) (GLenum target, const GLfloat *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD1IPROC) (GLenum target, GLint s);
typedef void (__stdcall * PFNGLMULTITEXCOORD1IVPROC) (GLenum target, const GLint *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD1SPROC) (GLenum target, GLshort s);
typedef void (__stdcall * PFNGLMULTITEXCOORD1SVPROC) (GLenum target, const GLshort *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD2DPROC) (GLenum target, GLdouble s, GLdouble t);
typedef void (__stdcall * PFNGLMULTITEXCOORD2DVPROC) (GLenum target, const GLdouble *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD2FPROC) (GLenum target, GLfloat s, GLfloat t);
typedef void (__stdcall * PFNGLMULTITEXCOORD2FVPROC) (GLenum target, const GLfloat *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD2IPROC) (GLenum target, GLint s, GLint t);
typedef void (__stdcall * PFNGLMULTITEXCOORD2IVPROC) (GLenum target, const GLint *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD2SPROC) (GLenum target, GLshort s, GLshort t);
typedef void (__stdcall * PFNGLMULTITEXCOORD2SVPROC) (GLenum target, const GLshort *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD3DPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r);
typedef void (__stdcall * PFNGLMULTITEXCOORD3DVPROC) (GLenum target, const GLdouble *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD3FPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r);
typedef void (__stdcall * PFNGLMULTITEXCOORD3FVPROC) (GLenum target, const GLfloat *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD3IPROC) (GLenum target, GLint s, GLint t, GLint r);
typedef void (__stdcall * PFNGLMULTITEXCOORD3IVPROC) (GLenum target, const GLint *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD3SPROC) (GLenum target, GLshort s, GLshort t, GLshort r);
typedef void (__stdcall * PFNGLMULTITEXCOORD3SVPROC) (GLenum target, const GLshort *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD4DPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
typedef void (__stdcall * PFNGLMULTITEXCOORD4DVPROC) (GLenum target, const GLdouble *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD4FPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
typedef void (__stdcall * PFNGLMULTITEXCOORD4FVPROC) (GLenum target, const GLfloat *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD4IPROC) (GLenum target, GLint s, GLint t, GLint r, GLint q);
typedef void (__stdcall * PFNGLMULTITEXCOORD4IVPROC) (GLenum target, const GLint *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD4SPROC) (GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
typedef void (__stdcall * PFNGLMULTITEXCOORD4SVPROC) (GLenum target, const GLshort *v);
typedef void (__stdcall * PFNGLSAMPLECOVERAGEPROC) (GLclampf value, GLboolean invert);


















































#line 1477 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 












































typedef void (__stdcall * PFNGLBLENDCOLORPROC) (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
typedef void (__stdcall * PFNGLBLENDEQUATIONPROC) (GLenum mode);
typedef void (__stdcall * PFNGLBLENDFUNCSEPARATEPROC) (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
typedef void (__stdcall * PFNGLFOGCOORDPOINTERPROC) (GLenum type, GLsizei stride, const void *pointer);
typedef void (__stdcall * PFNGLFOGCOORDDPROC) (GLdouble coord);
typedef void (__stdcall * PFNGLFOGCOORDDVPROC) (const GLdouble *coord);
typedef void (__stdcall * PFNGLFOGCOORDFPROC) (GLfloat coord);
typedef void (__stdcall * PFNGLFOGCOORDFVPROC) (const GLfloat *coord);
typedef void (__stdcall * PFNGLMULTIDRAWARRAYSPROC) (GLenum mode, const GLint *first, const GLsizei *count, GLsizei drawcount);
typedef void (__stdcall * PFNGLMULTIDRAWELEMENTSPROC) (GLenum mode, const GLsizei *count, GLenum type, const void *const* indices, GLsizei drawcount);
typedef void (__stdcall * PFNGLPOINTPARAMETERFPROC) (GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLPOINTPARAMETERFVPROC) (GLenum pname, const GLfloat *params);
typedef void (__stdcall * PFNGLPOINTPARAMETERIPROC) (GLenum pname, GLint param);
typedef void (__stdcall * PFNGLPOINTPARAMETERIVPROC) (GLenum pname, const GLint *params);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3BPROC) (GLbyte red, GLbyte green, GLbyte blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3BVPROC) (const GLbyte *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3DPROC) (GLdouble red, GLdouble green, GLdouble blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3DVPROC) (const GLdouble *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3FPROC) (GLfloat red, GLfloat green, GLfloat blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3FVPROC) (const GLfloat *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3IPROC) (GLint red, GLint green, GLint blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3IVPROC) (const GLint *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3SPROC) (GLshort red, GLshort green, GLshort blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3SVPROC) (const GLshort *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3UBPROC) (GLubyte red, GLubyte green, GLubyte blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3UBVPROC) (const GLubyte *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3UIPROC) (GLuint red, GLuint green, GLuint blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3UIVPROC) (const GLuint *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3USPROC) (GLushort red, GLushort green, GLushort blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3USVPROC) (const GLushort *v);
typedef void (__stdcall * PFNGLSECONDARYCOLORPOINTERPROC) (GLint size, GLenum type, GLsizei stride, const void *pointer);
typedef void (__stdcall * PFNGLWINDOWPOS2DPROC) (GLdouble x, GLdouble y);
typedef void (__stdcall * PFNGLWINDOWPOS2DVPROC) (const GLdouble *p);
typedef void (__stdcall * PFNGLWINDOWPOS2FPROC) (GLfloat x, GLfloat y);
typedef void (__stdcall * PFNGLWINDOWPOS2FVPROC) (const GLfloat *p);
typedef void (__stdcall * PFNGLWINDOWPOS2IPROC) (GLint x, GLint y);
typedef void (__stdcall * PFNGLWINDOWPOS2IVPROC) (const GLint *p);
typedef void (__stdcall * PFNGLWINDOWPOS2SPROC) (GLshort x, GLshort y);
typedef void (__stdcall * PFNGLWINDOWPOS2SVPROC) (const GLshort *p);
typedef void (__stdcall * PFNGLWINDOWPOS3DPROC) (GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLWINDOWPOS3DVPROC) (const GLdouble *p);
typedef void (__stdcall * PFNGLWINDOWPOS3FPROC) (GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLWINDOWPOS3FVPROC) (const GLfloat *p);
typedef void (__stdcall * PFNGLWINDOWPOS3IPROC) (GLint x, GLint y, GLint z);
typedef void (__stdcall * PFNGLWINDOWPOS3IVPROC) (const GLint *p);
typedef void (__stdcall * PFNGLWINDOWPOS3SPROC) (GLshort x, GLshort y, GLshort z);
typedef void (__stdcall * PFNGLWINDOWPOS3SVPROC) (const GLshort *p);



















































#line 1622 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 























































typedef ptrdiff_t GLintptr;
typedef ptrdiff_t GLsizeiptr;

typedef void (__stdcall * PFNGLBEGINQUERYPROC) (GLenum target, GLuint id);
typedef void (__stdcall * PFNGLBINDBUFFERPROC) (GLenum target, GLuint buffer);
typedef void (__stdcall * PFNGLBUFFERDATAPROC) (GLenum target, GLsizeiptr size, const void* data, GLenum usage);
typedef void (__stdcall * PFNGLBUFFERSUBDATAPROC) (GLenum target, GLintptr offset, GLsizeiptr size, const void* data);
typedef void (__stdcall * PFNGLDELETEBUFFERSPROC) (GLsizei n, const GLuint* buffers);
typedef void (__stdcall * PFNGLDELETEQUERIESPROC) (GLsizei n, const GLuint* ids);
typedef void (__stdcall * PFNGLENDQUERYPROC) (GLenum target);
typedef void (__stdcall * PFNGLGENBUFFERSPROC) (GLsizei n, GLuint* buffers);
typedef void (__stdcall * PFNGLGENQUERIESPROC) (GLsizei n, GLuint* ids);
typedef void (__stdcall * PFNGLGETBUFFERPARAMETERIVPROC) (GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETBUFFERPOINTERVPROC) (GLenum target, GLenum pname, void** params);
typedef void (__stdcall * PFNGLGETBUFFERSUBDATAPROC) (GLenum target, GLintptr offset, GLsizeiptr size, void* data);
typedef void (__stdcall * PFNGLGETQUERYOBJECTIVPROC) (GLuint id, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETQUERYOBJECTUIVPROC) (GLuint id, GLenum pname, GLuint* params);
typedef void (__stdcall * PFNGLGETQUERYIVPROC) (GLenum target, GLenum pname, GLint* params);
typedef GLboolean (__stdcall * PFNGLISBUFFERPROC) (GLuint buffer);
typedef GLboolean (__stdcall * PFNGLISQUERYPROC) (GLuint id);
typedef void* (__stdcall * PFNGLMAPBUFFERPROC) (GLenum target, GLenum access);
typedef GLboolean (__stdcall * PFNGLUNMAPBUFFERPROC) (GLenum target);























#line 1725 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 

























































































typedef void (__stdcall * PFNGLATTACHSHADERPROC) (GLuint program, GLuint shader);
typedef void (__stdcall * PFNGLBINDATTRIBLOCATIONPROC) (GLuint program, GLuint index, const GLchar* name);
typedef void (__stdcall * PFNGLBLENDEQUATIONSEPARATEPROC) (GLenum modeRGB, GLenum modeAlpha);
typedef void (__stdcall * PFNGLCOMPILESHADERPROC) (GLuint shader);
typedef GLuint (__stdcall * PFNGLCREATEPROGRAMPROC) (void);
typedef GLuint (__stdcall * PFNGLCREATESHADERPROC) (GLenum type);
typedef void (__stdcall * PFNGLDELETEPROGRAMPROC) (GLuint program);
typedef void (__stdcall * PFNGLDELETESHADERPROC) (GLuint shader);
typedef void (__stdcall * PFNGLDETACHSHADERPROC) (GLuint program, GLuint shader);
typedef void (__stdcall * PFNGLDISABLEVERTEXATTRIBARRAYPROC) (GLuint index);
typedef void (__stdcall * PFNGLDRAWBUFFERSPROC) (GLsizei n, const GLenum* bufs);
typedef void (__stdcall * PFNGLENABLEVERTEXATTRIBARRAYPROC) (GLuint index);
typedef void (__stdcall * PFNGLGETACTIVEATTRIBPROC) (GLuint program, GLuint index, GLsizei maxLength, GLsizei* length, GLint* size, GLenum* type, GLchar* name);
typedef void (__stdcall * PFNGLGETACTIVEUNIFORMPROC) (GLuint program, GLuint index, GLsizei maxLength, GLsizei* length, GLint* size, GLenum* type, GLchar* name);
typedef void (__stdcall * PFNGLGETATTACHEDSHADERSPROC) (GLuint program, GLsizei maxCount, GLsizei* count, GLuint* shaders);
typedef GLint (__stdcall * PFNGLGETATTRIBLOCATIONPROC) (GLuint program, const GLchar* name);
typedef void (__stdcall * PFNGLGETPROGRAMINFOLOGPROC) (GLuint program, GLsizei bufSize, GLsizei* length, GLchar* infoLog);
typedef void (__stdcall * PFNGLGETPROGRAMIVPROC) (GLuint program, GLenum pname, GLint* param);
typedef void (__stdcall * PFNGLGETSHADERINFOLOGPROC) (GLuint shader, GLsizei bufSize, GLsizei* length, GLchar* infoLog);
typedef void (__stdcall * PFNGLGETSHADERSOURCEPROC) (GLuint obj, GLsizei maxLength, GLsizei* length, GLchar* source);
typedef void (__stdcall * PFNGLGETSHADERIVPROC) (GLuint shader, GLenum pname, GLint* param);
typedef GLint (__stdcall * PFNGLGETUNIFORMLOCATIONPROC) (GLuint program, const GLchar* name);
typedef void (__stdcall * PFNGLGETUNIFORMFVPROC) (GLuint program, GLint location, GLfloat* params);
typedef void (__stdcall * PFNGLGETUNIFORMIVPROC) (GLuint program, GLint location, GLint* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBPOINTERVPROC) (GLuint index, GLenum pname, void** pointer);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBDVPROC) (GLuint index, GLenum pname, GLdouble* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBFVPROC) (GLuint index, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBIVPROC) (GLuint index, GLenum pname, GLint* params);
typedef GLboolean (__stdcall * PFNGLISPROGRAMPROC) (GLuint program);
typedef GLboolean (__stdcall * PFNGLISSHADERPROC) (GLuint shader);
typedef void (__stdcall * PFNGLLINKPROGRAMPROC) (GLuint program);
typedef void (__stdcall * PFNGLSHADERSOURCEPROC) (GLuint shader, GLsizei count, const GLchar *const* string, const GLint* length);
typedef void (__stdcall * PFNGLSTENCILFUNCSEPARATEPROC) (GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask);
typedef void (__stdcall * PFNGLSTENCILMASKSEPARATEPROC) (GLenum face, GLuint mask);
typedef void (__stdcall * PFNGLSTENCILOPSEPARATEPROC) (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
typedef void (__stdcall * PFNGLUNIFORM1FPROC) (GLint location, GLfloat v0);
typedef void (__stdcall * PFNGLUNIFORM1FVPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORM1IPROC) (GLint location, GLint v0);
typedef void (__stdcall * PFNGLUNIFORM1IVPROC) (GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLUNIFORM2FPROC) (GLint location, GLfloat v0, GLfloat v1);
typedef void (__stdcall * PFNGLUNIFORM2FVPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORM2IPROC) (GLint location, GLint v0, GLint v1);
typedef void (__stdcall * PFNGLUNIFORM2IVPROC) (GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLUNIFORM3FPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void (__stdcall * PFNGLUNIFORM3FVPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORM3IPROC) (GLint location, GLint v0, GLint v1, GLint v2);
typedef void (__stdcall * PFNGLUNIFORM3IVPROC) (GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLUNIFORM4FPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void (__stdcall * PFNGLUNIFORM4FVPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORM4IPROC) (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void (__stdcall * PFNGLUNIFORM4IVPROC) (GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLUSEPROGRAMPROC) (GLuint program);
typedef void (__stdcall * PFNGLVALIDATEPROGRAMPROC) (GLuint program);
typedef void (__stdcall * PFNGLVERTEXATTRIB1DPROC) (GLuint index, GLdouble x);
typedef void (__stdcall * PFNGLVERTEXATTRIB1DVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB1FPROC) (GLuint index, GLfloat x);
typedef void (__stdcall * PFNGLVERTEXATTRIB1FVPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB1SPROC) (GLuint index, GLshort x);
typedef void (__stdcall * PFNGLVERTEXATTRIB1SVPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB2DPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void (__stdcall * PFNGLVERTEXATTRIB2DVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB2FPROC) (GLuint index, GLfloat x, GLfloat y);
typedef void (__stdcall * PFNGLVERTEXATTRIB2FVPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB2SPROC) (GLuint index, GLshort x, GLshort y);
typedef void (__stdcall * PFNGLVERTEXATTRIB2SVPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB3DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLVERTEXATTRIB3DVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB3FPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLVERTEXATTRIB3FVPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB3SPROC) (GLuint index, GLshort x, GLshort y, GLshort z);
typedef void (__stdcall * PFNGLVERTEXATTRIB3SVPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NBVPROC) (GLuint index, const GLbyte* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NIVPROC) (GLuint index, const GLint* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NSVPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NUBPROC) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NUBVPROC) (GLuint index, const GLubyte* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NUIVPROC) (GLuint index, const GLuint* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NUSVPROC) (GLuint index, const GLushort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4BVPROC) (GLuint index, const GLbyte* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4DVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4FPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4FVPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4IVPROC) (GLuint index, const GLint* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4SPROC) (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4SVPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4UBVPROC) (GLuint index, const GLubyte* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4UIVPROC) (GLuint index, const GLuint* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4USVPROC) (GLuint index, const GLushort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBPOINTERPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void* pointer);

































































































#line 2007 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




























typedef void (__stdcall * PFNGLUNIFORMMATRIX2X3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX2X4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX3X2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX3X4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX4X2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX4X3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);










#line 2054 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 














































































































typedef void (__stdcall * PFNGLBEGINCONDITIONALRENDERPROC) (GLuint id, GLenum mode);
typedef void (__stdcall * PFNGLBEGINTRANSFORMFEEDBACKPROC) (GLenum primitiveMode);
typedef void (__stdcall * PFNGLBINDFRAGDATALOCATIONPROC) (GLuint program, GLuint colorNumber, const GLchar* name);
typedef void (__stdcall * PFNGLCLAMPCOLORPROC) (GLenum target, GLenum clamp);
typedef void (__stdcall * PFNGLCLEARBUFFERFIPROC) (GLenum buffer, GLint drawBuffer, GLfloat depth, GLint stencil);
typedef void (__stdcall * PFNGLCLEARBUFFERFVPROC) (GLenum buffer, GLint drawBuffer, const GLfloat* value);
typedef void (__stdcall * PFNGLCLEARBUFFERIVPROC) (GLenum buffer, GLint drawBuffer, const GLint* value);
typedef void (__stdcall * PFNGLCLEARBUFFERUIVPROC) (GLenum buffer, GLint drawBuffer, const GLuint* value);
typedef void (__stdcall * PFNGLCOLORMASKIPROC) (GLuint buf, GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
typedef void (__stdcall * PFNGLDISABLEIPROC) (GLenum cap, GLuint index);
typedef void (__stdcall * PFNGLENABLEIPROC) (GLenum cap, GLuint index);
typedef void (__stdcall * PFNGLENDCONDITIONALRENDERPROC) (void);
typedef void (__stdcall * PFNGLENDTRANSFORMFEEDBACKPROC) (void);
typedef void (__stdcall * PFNGLGETBOOLEANI_VPROC) (GLenum pname, GLuint index, GLboolean* data);
typedef GLint (__stdcall * PFNGLGETFRAGDATALOCATIONPROC) (GLuint program, const GLchar* name);
typedef const GLubyte* (__stdcall * PFNGLGETSTRINGIPROC) (GLenum name, GLuint index);
typedef void (__stdcall * PFNGLGETTEXPARAMETERIIVPROC) (GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETTEXPARAMETERIUIVPROC) (GLenum target, GLenum pname, GLuint* params);
typedef void (__stdcall * PFNGLGETTRANSFORMFEEDBACKVARYINGPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name);
typedef void (__stdcall * PFNGLGETUNIFORMUIVPROC) (GLuint program, GLint location, GLuint* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBIIVPROC) (GLuint index, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBIUIVPROC) (GLuint index, GLenum pname, GLuint* params);
typedef GLboolean (__stdcall * PFNGLISENABLEDIPROC) (GLenum cap, GLuint index);
typedef void (__stdcall * PFNGLTEXPARAMETERIIVPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLTEXPARAMETERIUIVPROC) (GLenum target, GLenum pname, const GLuint* params);
typedef void (__stdcall * PFNGLTRANSFORMFEEDBACKVARYINGSPROC) (GLuint program, GLsizei count, const GLchar *const* varyings, GLenum bufferMode);
typedef void (__stdcall * PFNGLUNIFORM1UIPROC) (GLint location, GLuint v0);
typedef void (__stdcall * PFNGLUNIFORM1UIVPROC) (GLint location, GLsizei count, const GLuint* value);
typedef void (__stdcall * PFNGLUNIFORM2UIPROC) (GLint location, GLuint v0, GLuint v1);
typedef void (__stdcall * PFNGLUNIFORM2UIVPROC) (GLint location, GLsizei count, const GLuint* value);
typedef void (__stdcall * PFNGLUNIFORM3UIPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2);
typedef void (__stdcall * PFNGLUNIFORM3UIVPROC) (GLint location, GLsizei count, const GLuint* value);
typedef void (__stdcall * PFNGLUNIFORM4UIPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void (__stdcall * PFNGLUNIFORM4UIVPROC) (GLint location, GLsizei count, const GLuint* value);
typedef void (__stdcall * PFNGLVERTEXATTRIBI1IPROC) (GLuint index, GLint v0);
typedef void (__stdcall * PFNGLVERTEXATTRIBI1IVPROC) (GLuint index, const GLint* v0);
typedef void (__stdcall * PFNGLVERTEXATTRIBI1UIPROC) (GLuint index, GLuint v0);
typedef void (__stdcall * PFNGLVERTEXATTRIBI1UIVPROC) (GLuint index, const GLuint* v0);
typedef void (__stdcall * PFNGLVERTEXATTRIBI2IPROC) (GLuint index, GLint v0, GLint v1);
typedef void (__stdcall * PFNGLVERTEXATTRIBI2IVPROC) (GLuint index, const GLint* v0);
typedef void (__stdcall * PFNGLVERTEXATTRIBI2UIPROC) (GLuint index, GLuint v0, GLuint v1);
typedef void (__stdcall * PFNGLVERTEXATTRIBI2UIVPROC) (GLuint index, const GLuint* v0);
typedef void (__stdcall * PFNGLVERTEXATTRIBI3IPROC) (GLuint index, GLint v0, GLint v1, GLint v2);
typedef void (__stdcall * PFNGLVERTEXATTRIBI3IVPROC) (GLuint index, const GLint* v0);
typedef void (__stdcall * PFNGLVERTEXATTRIBI3UIPROC) (GLuint index, GLuint v0, GLuint v1, GLuint v2);
typedef void (__stdcall * PFNGLVERTEXATTRIBI3UIVPROC) (GLuint index, const GLuint* v0);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4BVPROC) (GLuint index, const GLbyte* v0);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4IPROC) (GLuint index, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4IVPROC) (GLuint index, const GLint* v0);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4SVPROC) (GLuint index, const GLshort* v0);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4UBVPROC) (GLuint index, const GLubyte* v0);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4UIPROC) (GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4UIVPROC) (GLuint index, const GLuint* v0);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4USVPROC) (GLuint index, const GLushort* v0);
typedef void (__stdcall * PFNGLVERTEXATTRIBIPOINTERPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const void*pointer);



























































#line 2281 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 







































typedef void (__stdcall * PFNGLDRAWARRAYSINSTANCEDPROC) (GLenum mode, GLint first, GLsizei count, GLsizei primcount);
typedef void (__stdcall * PFNGLDRAWELEMENTSINSTANCEDPROC) (GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei primcount);
typedef void (__stdcall * PFNGLPRIMITIVERESTARTINDEXPROC) (GLuint buffer);
typedef void (__stdcall * PFNGLTEXBUFFERPROC) (GLenum target, GLenum internalFormat, GLuint buffer);








#line 2335 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 



























typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTUREPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level);
typedef void (__stdcall * PFNGLGETBUFFERPARAMETERI64VPROC) (GLenum target, GLenum value, GLint64 * data);
typedef void (__stdcall * PFNGLGETINTEGER64I_VPROC) (GLenum pname, GLuint index, GLint64 * data);







#line 2375 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 







typedef void (__stdcall * PFNGLVERTEXATTRIBDIVISORPROC) (GLuint index, GLuint divisor);





#line 2391 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 

















typedef void (__stdcall * PFNGLBLENDEQUATIONSEPARATEIPROC) (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
typedef void (__stdcall * PFNGLBLENDEQUATIONIPROC) (GLuint buf, GLenum mode);
typedef void (__stdcall * PFNGLBLENDFUNCSEPARATEIPROC) (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
typedef void (__stdcall * PFNGLBLENDFUNCIPROC) (GLuint buf, GLenum src, GLenum dst);
typedef void (__stdcall * PFNGLMINSAMPLESHADINGPROC) (GLclampf value);









#line 2425 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 2434 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 















#line 2452 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 2464 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 










#line 2477 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






typedef GLenum (__stdcall * PFNGLGETGRAPHICSRESETSTATUSPROC) (void);
typedef void (__stdcall * PFNGLGETNCOMPRESSEDTEXIMAGEPROC) (GLenum target, GLint lod, GLsizei bufSize, GLvoid *pixels);
typedef void (__stdcall * PFNGLGETNTEXIMAGEPROC) (GLenum tex, GLint level, GLenum format, GLenum type, GLsizei bufSize, GLvoid *pixels);
typedef void (__stdcall * PFNGLGETNUNIFORMDVPROC) (GLuint program, GLint location, GLsizei bufSize, GLdouble *params);








#line 2498 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 



























typedef void (__stdcall * PFNGLMULTIDRAWARRAYSINDIRECTCOUNTPROC) (GLenum mode, const GLvoid *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
typedef void (__stdcall * PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTPROC) (GLenum mode, GLenum type, const GLvoid *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
typedef void (__stdcall * PFNGLSPECIALIZESHADERPROC) (GLuint shader, const GLchar *pEntryPoint, GLuint numSpecializationConstants, const GLuint *pConstantIndex, const GLuint *pConstantValue);







#line 2538 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











#line 2552 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLTBUFFERMASK3DFXPROC) (GLuint mask);





#line 2565 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 2577 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 2589 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 2601 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 










#line 2614 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 2623 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 



















typedef void (__stdcall *GLDEBUGPROCAMD)(GLuint id, GLenum category, GLenum severity, GLsizei length, const GLchar* message, void* userParam);

typedef void (__stdcall * PFNGLDEBUGMESSAGECALLBACKAMDPROC) (GLDEBUGPROCAMD callback, void *userParam);
typedef void (__stdcall * PFNGLDEBUGMESSAGEENABLEAMDPROC) (GLenum category, GLenum severity, GLsizei count, const GLuint* ids, GLboolean enabled);
typedef void (__stdcall * PFNGLDEBUGMESSAGEINSERTAMDPROC) (GLenum category, GLenum severity, GLuint id, GLsizei length, const GLchar* buf);
typedef GLuint (__stdcall * PFNGLGETDEBUGMESSAGELOGAMDPROC) (GLuint count, GLsizei bufsize, GLenum* categories, GLuint* severities, GLuint* ids, GLsizei* lengths, GLchar* message);








#line 2659 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 2671 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLBLENDEQUATIONINDEXEDAMDPROC) (GLuint buf, GLenum mode);
typedef void (__stdcall * PFNGLBLENDEQUATIONSEPARATEINDEXEDAMDPROC) (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
typedef void (__stdcall * PFNGLBLENDFUNCINDEXEDAMDPROC) (GLuint buf, GLenum src, GLenum dst);
typedef void (__stdcall * PFNGLBLENDFUNCSEPARATEINDEXEDAMDPROC) (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);








#line 2690 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









typedef void (__stdcall * PFNGLFRAMEBUFFERSAMPLEPOSITIONSFVAMDPROC) (GLenum target, GLuint numsamples, GLuint pixelindex, const GLfloat* values);
typedef void (__stdcall * PFNGLGETFRAMEBUFFERPARAMETERFVAMDPROC) (GLenum target, GLenum pname, GLuint numsamples, GLuint pixelindex, GLsizei size, GLfloat* values);
typedef void (__stdcall * PFNGLGETNAMEDFRAMEBUFFERPARAMETERFVAMDPROC) (GLuint framebuffer, GLenum pname, GLuint numsamples, GLuint pixelindex, GLsizei size, GLfloat* values);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERSAMPLEPOSITIONSFVAMDPROC) (GLuint framebuffer, GLuint numsamples, GLuint pixelindex, const GLfloat* values);








#line 2714 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 2723 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




















#line 2746 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 2755 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 2764 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 














typedef void (__stdcall * PFNGLVERTEXATTRIBPARAMETERIAMDPROC) (GLuint index, GLenum pname, GLint param);





#line 2787 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLMULTIDRAWARRAYSINDIRECTAMDPROC) (GLenum mode, const void *indirect, GLsizei primcount, GLsizei stride);
typedef void (__stdcall * PFNGLMULTIDRAWELEMENTSINDIRECTAMDPROC) (GLenum mode, GLenum type, const void *indirect, GLsizei primcount, GLsizei stride);






#line 2802 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 










typedef void (__stdcall * PFNGLDELETENAMESAMDPROC) (GLenum identifier, GLuint num, const GLuint* names);
typedef void (__stdcall * PFNGLGENNAMESAMDPROC) (GLenum identifier, GLuint num, GLuint* names);
typedef GLboolean (__stdcall * PFNGLISNAMEAMDPROC) (GLenum identifier, GLuint name);







#line 2825 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











typedef void (__stdcall * PFNGLQUERYOBJECTPARAMETERUIAMDPROC) (GLenum target, GLuint id, GLenum pname, GLuint param);





#line 2845 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 












typedef void (__stdcall * PFNGLBEGINPERFMONITORAMDPROC) (GLuint monitor);
typedef void (__stdcall * PFNGLDELETEPERFMONITORSAMDPROC) (GLsizei n, GLuint* monitors);
typedef void (__stdcall * PFNGLENDPERFMONITORAMDPROC) (GLuint monitor);
typedef void (__stdcall * PFNGLGENPERFMONITORSAMDPROC) (GLsizei n, GLuint* monitors);
typedef void (__stdcall * PFNGLGETPERFMONITORCOUNTERDATAAMDPROC) (GLuint monitor, GLenum pname, GLsizei dataSize, GLuint* data, GLint *bytesWritten);
typedef void (__stdcall * PFNGLGETPERFMONITORCOUNTERINFOAMDPROC) (GLuint group, GLuint counter, GLenum pname, void *data);
typedef void (__stdcall * PFNGLGETPERFMONITORCOUNTERSTRINGAMDPROC) (GLuint group, GLuint counter, GLsizei bufSize, GLsizei* length, GLchar *counterString);
typedef void (__stdcall * PFNGLGETPERFMONITORCOUNTERSAMDPROC) (GLuint group, GLint* numCounters, GLint *maxActiveCounters, GLsizei countersSize, GLuint *counters);
typedef void (__stdcall * PFNGLGETPERFMONITORGROUPSTRINGAMDPROC) (GLuint group, GLsizei bufSize, GLsizei* length, GLchar *groupString);
typedef void (__stdcall * PFNGLGETPERFMONITORGROUPSAMDPROC) (GLint* numGroups, GLsizei groupsSize, GLuint *groups);
typedef void (__stdcall * PFNGLSELECTPERFMONITORCOUNTERSAMDPROC) (GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint* counterList);















#line 2886 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 2897 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 2908 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 










#line 2921 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






typedef void (__stdcall * PFNGLSETMULTISAMPLEFVAMDPROC) (GLenum pname, GLuint index, const GLfloat* val);





#line 2936 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 2947 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 2956 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 2965 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 2974 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 2983 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 2992 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 3001 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 














typedef void (__stdcall * PFNGLTEXSTORAGESPARSEAMDPROC) (GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags);
typedef void (__stdcall * PFNGLTEXTURESTORAGESPARSEAMDPROC) (GLuint texture, GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags);






#line 3026 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









typedef void (__stdcall * PFNGLSTENCILOPVALUEAMDPROC) (GLenum face, GLuint value);





#line 3044 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 3053 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 3062 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 3071 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 3082 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 3091 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 












typedef void (__stdcall * PFNGLTESSELLATIONFACTORAMDPROC) (GLfloat factor);
typedef void (__stdcall * PFNGLTESSELLATIONMODEAMDPROC) (GLenum mode);






#line 3114 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 3123 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 3132 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 3141 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









typedef void (__stdcall * PFNGLBLITFRAMEBUFFERANGLEPROC) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);





#line 3159 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








typedef void (__stdcall * PFNGLRENDERBUFFERSTORAGEMULTISAMPLEANGLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);





#line 3176 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






typedef void (__stdcall * PFNGLDRAWARRAYSINSTANCEDANGLEPROC) (GLenum mode, GLint first, GLsizei count, GLsizei primcount);
typedef void (__stdcall * PFNGLDRAWELEMENTSINSTANCEDANGLEPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount);
typedef void (__stdcall * PFNGLVERTEXATTRIBDIVISORANGLEPROC) (GLuint index, GLuint divisor);







#line 3195 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 3206 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 3217 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











#line 3231 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











#line 3245 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











#line 3259 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 3271 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











typedef void (__stdcall * PFNGLBEGINQUERYANGLEPROC) (GLenum target, GLuint id);
typedef void (__stdcall * PFNGLDELETEQUERIESANGLEPROC) (GLsizei n, const GLuint* ids);
typedef void (__stdcall * PFNGLENDQUERYANGLEPROC) (GLenum target);
typedef void (__stdcall * PFNGLGENQUERIESANGLEPROC) (GLsizei n, GLuint* ids);
typedef void (__stdcall * PFNGLGETQUERYOBJECTI64VANGLEPROC) (GLuint id, GLenum pname, GLint64* params);
typedef void (__stdcall * PFNGLGETQUERYOBJECTIVANGLEPROC) (GLuint id, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETQUERYOBJECTUI64VANGLEPROC) (GLuint id, GLenum pname, GLuint64* params);
typedef void (__stdcall * PFNGLGETQUERYOBJECTUIVANGLEPROC) (GLuint id, GLenum pname, GLuint* params);
typedef void (__stdcall * PFNGLGETQUERYIVANGLEPROC) (GLenum target, GLenum pname, GLint* params);
typedef GLboolean (__stdcall * PFNGLISQUERYANGLEPROC) (GLuint id);
typedef void (__stdcall * PFNGLQUERYCOUNTERANGLEPROC) (GLuint id, GLenum target);















#line 3311 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






typedef void (__stdcall * PFNGLGETTRANSLATEDSHADERSOURCEANGLEPROC) (GLuint shader, GLsizei bufsize, GLsizei* length, GLchar* source);





#line 3326 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 3337 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 3348 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 
















#line 3367 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 3376 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLCOPYTEXTURELEVELSAPPLEPROC) (GLuint destinationTexture, GLuint sourceTexture, GLint sourceBaseLevel, GLsizei sourceLevelCount);





#line 3389 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








typedef void (__stdcall * PFNGLDRAWELEMENTARRAYAPPLEPROC) (GLenum mode, GLint first, GLsizei count);
typedef void (__stdcall * PFNGLDRAWRANGEELEMENTARRAYAPPLEPROC) (GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count);
typedef void (__stdcall * PFNGLELEMENTPOINTERAPPLEPROC) (GLenum type, const void *pointer);
typedef void (__stdcall * PFNGLMULTIDRAWELEMENTARRAYAPPLEPROC) (GLenum mode, const GLint* first, const GLsizei *count, GLsizei primcount);
typedef void (__stdcall * PFNGLMULTIDRAWRANGEELEMENTARRAYAPPLEPROC) (GLenum mode, GLuint start, GLuint end, const GLint* first, const GLsizei *count, GLsizei primcount);









#line 3414 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 







typedef void (__stdcall * PFNGLDELETEFENCESAPPLEPROC) (GLsizei n, const GLuint* fences);
typedef void (__stdcall * PFNGLFINISHFENCEAPPLEPROC) (GLuint fence);
typedef void (__stdcall * PFNGLFINISHOBJECTAPPLEPROC) (GLenum object, GLint name);
typedef void (__stdcall * PFNGLGENFENCESAPPLEPROC) (GLsizei n, GLuint* fences);
typedef GLboolean (__stdcall * PFNGLISFENCEAPPLEPROC) (GLuint fence);
typedef void (__stdcall * PFNGLSETFENCEAPPLEPROC) (GLuint fence);
typedef GLboolean (__stdcall * PFNGLTESTFENCEAPPLEPROC) (GLuint fence);
typedef GLboolean (__stdcall * PFNGLTESTOBJECTAPPLEPROC) (GLenum object, GLuint name);












#line 3444 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 





















#line 3468 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 







typedef void (__stdcall * PFNGLBUFFERPARAMETERIAPPLEPROC) (GLenum target, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLFLUSHMAPPEDBUFFERRANGEAPPLEPROC) (GLenum target, GLintptr offset, GLsizeiptr size);






#line 3486 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 












typedef void (__stdcall * PFNGLRENDERBUFFERSTORAGEMULTISAMPLEAPPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLRESOLVEMULTISAMPLEFRAMEBUFFERAPPLEPROC) (void);






#line 3509 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











typedef void (__stdcall * PFNGLGETOBJECTPARAMETERIVAPPLEPROC) (GLenum objectType, GLuint name, GLenum pname, GLint* params);
typedef GLenum (__stdcall * PFNGLOBJECTPURGEABLEAPPLEPROC) (GLenum objectType, GLuint name, GLenum option);
typedef GLenum (__stdcall * PFNGLOBJECTUNPURGEABLEAPPLEPROC) (GLenum objectType, GLuint name, GLenum option);







#line 3533 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 3544 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











#line 3558 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 3570 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 3581 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 





















typedef GLenum (__stdcall * PFNGLCLIENTWAITSYNCAPPLEPROC) (GLsync GLsync, GLbitfield flags, GLuint64 timeout);
typedef void (__stdcall * PFNGLDELETESYNCAPPLEPROC) (GLsync GLsync);
typedef GLsync (__stdcall * PFNGLFENCESYNCAPPLEPROC) (GLenum condition, GLbitfield flags);
typedef void (__stdcall * PFNGLGETINTEGER64VAPPLEPROC) (GLenum pname, GLint64* params);
typedef void (__stdcall * PFNGLGETSYNCIVAPPLEPROC) (GLsync GLsync, GLenum pname, GLsizei bufSize, GLsizei* length, GLint *values);
typedef GLboolean (__stdcall * PFNGLISSYNCAPPLEPROC) (GLsync GLsync);
typedef void (__stdcall * PFNGLWAITSYNCAPPLEPROC) (GLsync GLsync, GLbitfield flags, GLuint64 timeout);











#line 3623 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 3632 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 3644 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 3655 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











#line 3669 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











typedef void (__stdcall * PFNGLGETTEXPARAMETERPOINTERVAPPLEPROC) (GLenum target, GLenum pname, void **params);
typedef void (__stdcall * PFNGLTEXTURERANGEAPPLEPROC) (GLenum target, GLsizei length, void *pointer);






#line 3691 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 3702 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






typedef void (__stdcall * PFNGLBINDVERTEXARRAYAPPLEPROC) (GLuint array);
typedef void (__stdcall * PFNGLDELETEVERTEXARRAYSAPPLEPROC) (GLsizei n, const GLuint* arrays);
typedef void (__stdcall * PFNGLGENVERTEXARRAYSAPPLEPROC) (GLsizei n, const GLuint* arrays);
typedef GLboolean (__stdcall * PFNGLISVERTEXARRAYAPPLEPROC) (GLuint array);








#line 3723 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 













typedef void (__stdcall * PFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC) (GLsizei length, void *pointer);
typedef void (__stdcall * PFNGLVERTEXARRAYPARAMETERIAPPLEPROC) (GLenum pname, GLint param);
typedef void (__stdcall * PFNGLVERTEXARRAYRANGEAPPLEPROC) (GLsizei length, void *pointer);







#line 3749 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 















typedef void (__stdcall * PFNGLDISABLEVERTEXATTRIBAPPLEPROC) (GLuint index, GLenum pname);
typedef void (__stdcall * PFNGLENABLEVERTEXATTRIBAPPLEPROC) (GLuint index, GLenum pname);
typedef GLboolean (__stdcall * PFNGLISVERTEXATTRIBENABLEDAPPLEPROC) (GLuint index, GLenum pname);
typedef void (__stdcall * PFNGLMAPVERTEXATTRIB1DAPPLEPROC) (GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble* points);
typedef void (__stdcall * PFNGLMAPVERTEXATTRIB1FAPPLEPROC) (GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat* points);
typedef void (__stdcall * PFNGLMAPVERTEXATTRIB2DAPPLEPROC) (GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble* points);
typedef void (__stdcall * PFNGLMAPVERTEXATTRIB2FAPPLEPROC) (GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat* points);











#line 3785 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 3796 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 





















typedef int GLfixed;

typedef void (__stdcall * PFNGLCLEARDEPTHFPROC) (GLclampf d);
typedef void (__stdcall * PFNGLDEPTHRANGEFPROC) (GLclampf n, GLclampf f);
typedef void (__stdcall * PFNGLGETSHADERPRECISIONFORMATPROC) (GLenum shadertype, GLenum precisiontype, GLint* range, GLint *precision);
typedef void (__stdcall * PFNGLRELEASESHADERCOMPILERPROC) (void);
typedef void (__stdcall * PFNGLSHADERBINARYPROC) (GLsizei count, const GLuint* shaders, GLenum binaryformat, const void*binary, GLsizei length);









#line 3836 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLMEMORYBARRIERBYREGIONPROC) (GLbitfield barriers);





#line 3849 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








typedef void (__stdcall * PFNGLPRIMITIVEBOUNDINGBOXARBPROC) (GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW);





#line 3866 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 





















#line 3890 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 3899 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC) (GLenum mode, GLint first, GLsizei count, GLsizei primcount, GLuint baseinstance);
typedef void (__stdcall * PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount, GLuint baseinstance);
typedef void (__stdcall * PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount, GLint basevertex, GLuint baseinstance);







#line 3916 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






typedef GLuint64 (__stdcall * PFNGLGETIMAGEHANDLEARBPROC) (GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format);
typedef GLuint64 (__stdcall * PFNGLGETTEXTUREHANDLEARBPROC) (GLuint texture);
typedef GLuint64 (__stdcall * PFNGLGETTEXTURESAMPLERHANDLEARBPROC) (GLuint texture, GLuint sampler);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBLUI64VARBPROC) (GLuint index, GLenum pname, GLuint64EXT* params);
typedef GLboolean (__stdcall * PFNGLISIMAGEHANDLERESIDENTARBPROC) (GLuint64 handle);
typedef GLboolean (__stdcall * PFNGLISTEXTUREHANDLERESIDENTARBPROC) (GLuint64 handle);
typedef void (__stdcall * PFNGLMAKEIMAGEHANDLENONRESIDENTARBPROC) (GLuint64 handle);
typedef void (__stdcall * PFNGLMAKEIMAGEHANDLERESIDENTARBPROC) (GLuint64 handle, GLenum access);
typedef void (__stdcall * PFNGLMAKETEXTUREHANDLENONRESIDENTARBPROC) (GLuint64 handle);
typedef void (__stdcall * PFNGLMAKETEXTUREHANDLERESIDENTARBPROC) (GLuint64 handle);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMHANDLEUI64ARBPROC) (GLuint program, GLint location, GLuint64 value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMHANDLEUI64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLuint64* values);
typedef void (__stdcall * PFNGLUNIFORMHANDLEUI64ARBPROC) (GLint location, GLuint64 value);
typedef void (__stdcall * PFNGLUNIFORMHANDLEUI64VARBPROC) (GLint location, GLsizei count, const GLuint64* value);
typedef void (__stdcall * PFNGLVERTEXATTRIBL1UI64ARBPROC) (GLuint index, GLuint64EXT x);
typedef void (__stdcall * PFNGLVERTEXATTRIBL1UI64VARBPROC) (GLuint index, const GLuint64EXT* v);




















#line 3961 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









typedef void (__stdcall * PFNGLBINDFRAGDATALOCATIONINDEXEDPROC) (GLuint program, GLuint colorNumber, GLuint index, const GLchar * name);
typedef GLint (__stdcall * PFNGLGETFRAGDATAINDEXPROC) (GLuint program, const GLchar * name);






#line 3981 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 














typedef void (__stdcall * PFNGLBUFFERSTORAGEPROC) (GLenum target, GLsizeiptr size, const void *data, GLbitfield flags);





#line 4004 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 







typedef struct _cl_context *cl_context;
typedef struct _cl_event *cl_event;

typedef GLsync (__stdcall * PFNGLCREATESYNCFROMCLEVENTARBPROC) (cl_context context, cl_event event, GLbitfield flags);





#line 4023 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLCLEARBUFFERDATAPROC) (GLenum target, GLenum internalformat, GLenum format, GLenum type, const void *data);
typedef void (__stdcall * PFNGLCLEARBUFFERSUBDATAPROC) (GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data);
typedef void (__stdcall * PFNGLCLEARNAMEDBUFFERDATAEXTPROC) (GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void *data);
typedef void (__stdcall * PFNGLCLEARNAMEDBUFFERSUBDATAEXTPROC) (GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data);








#line 4042 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






typedef void (__stdcall * PFNGLCLEARTEXIMAGEPROC) (GLuint texture, GLint level, GLenum format, GLenum type, const void *data);
typedef void (__stdcall * PFNGLCLEARTEXSUBIMAGEPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data);






#line 4059 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











typedef void (__stdcall * PFNGLCLIPCONTROLPROC) (GLenum origin, GLenum depth);





#line 4079 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 










typedef void (__stdcall * PFNGLCLAMPCOLORARBPROC) (GLenum target, GLenum clamp);





#line 4098 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 4107 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 















#line 4125 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 























typedef void (__stdcall * PFNGLDISPATCHCOMPUTEPROC) (GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z);
typedef void (__stdcall * PFNGLDISPATCHCOMPUTEINDIRECTPROC) (GLintptr indirect);






#line 4159 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









typedef void (__stdcall * PFNGLDISPATCHCOMPUTEGROUPSIZEARBPROC) (GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z, GLuint group_size_x, GLuint group_size_y, GLuint group_size_z);





#line 4177 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











#line 4191 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 4200 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 







typedef void (__stdcall * PFNGLCOPYBUFFERSUBDATAPROC) (GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size);





#line 4216 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLCOPYIMAGESUBDATAPROC) (GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);





#line 4229 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 4241 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 



























typedef void (__stdcall *GLDEBUGPROCARB)(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* message, const void* userParam);

typedef void (__stdcall * PFNGLDEBUGMESSAGECALLBACKARBPROC) (GLDEBUGPROCARB callback, const void *userParam);
typedef void (__stdcall * PFNGLDEBUGMESSAGECONTROLARBPROC) (GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint* ids, GLboolean enabled);
typedef void (__stdcall * PFNGLDEBUGMESSAGEINSERTARBPROC) (GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* buf);
typedef GLuint (__stdcall * PFNGLGETDEBUGMESSAGELOGARBPROC) (GLuint count, GLsizei bufSize, GLenum* sources, GLenum* types, GLuint* ids, GLenum* severities, GLsizei* lengths, GLchar* messageLog);








#line 4285 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 










#line 4298 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 4309 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 












#line 4324 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 4333 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 







typedef void (__stdcall * PFNGLBINDTEXTUREUNITPROC) (GLuint unit, GLuint texture);
typedef void (__stdcall * PFNGLBLITNAMEDFRAMEBUFFERPROC) (GLuint readFramebuffer, GLuint drawFramebuffer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
typedef GLenum (__stdcall * PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC) (GLuint framebuffer, GLenum target);
typedef void (__stdcall * PFNGLCLEARNAMEDBUFFERDATAPROC) (GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void *data);
typedef void (__stdcall * PFNGLCLEARNAMEDBUFFERSUBDATAPROC) (GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data);
typedef void (__stdcall * PFNGLCLEARNAMEDFRAMEBUFFERFIPROC) (GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
typedef void (__stdcall * PFNGLCLEARNAMEDFRAMEBUFFERFVPROC) (GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLfloat* value);
typedef void (__stdcall * PFNGLCLEARNAMEDFRAMEBUFFERIVPROC) (GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLint* value);
typedef void (__stdcall * PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC) (GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLuint* value);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC) (GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOPYNAMEDBUFFERSUBDATAPROC) (GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
typedef void (__stdcall * PFNGLCOPYTEXTURESUBIMAGE1DPROC) (GLuint texture, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void (__stdcall * PFNGLCOPYTEXTURESUBIMAGE2DPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLCOPYTEXTURESUBIMAGE3DPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLCREATEBUFFERSPROC) (GLsizei n, GLuint* buffers);
typedef void (__stdcall * PFNGLCREATEFRAMEBUFFERSPROC) (GLsizei n, GLuint* framebuffers);
typedef void (__stdcall * PFNGLCREATEPROGRAMPIPELINESPROC) (GLsizei n, GLuint* pipelines);
typedef void (__stdcall * PFNGLCREATEQUERIESPROC) (GLenum target, GLsizei n, GLuint* ids);
typedef void (__stdcall * PFNGLCREATERENDERBUFFERSPROC) (GLsizei n, GLuint* renderbuffers);
typedef void (__stdcall * PFNGLCREATESAMPLERSPROC) (GLsizei n, GLuint* samplers);
typedef void (__stdcall * PFNGLCREATETEXTURESPROC) (GLenum target, GLsizei n, GLuint* textures);
typedef void (__stdcall * PFNGLCREATETRANSFORMFEEDBACKSPROC) (GLsizei n, GLuint* ids);
typedef void (__stdcall * PFNGLCREATEVERTEXARRAYSPROC) (GLsizei n, GLuint* arrays);
typedef void (__stdcall * PFNGLDISABLEVERTEXARRAYATTRIBPROC) (GLuint vaobj, GLuint index);
typedef void (__stdcall * PFNGLENABLEVERTEXARRAYATTRIBPROC) (GLuint vaobj, GLuint index);
typedef void (__stdcall * PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length);
typedef void (__stdcall * PFNGLGENERATETEXTUREMIPMAPPROC) (GLuint texture);
typedef void (__stdcall * PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC) (GLuint texture, GLint level, GLsizei bufSize, void *pixels);
typedef void (__stdcall * PFNGLGETNAMEDBUFFERPARAMETERI64VPROC) (GLuint buffer, GLenum pname, GLint64* params);
typedef void (__stdcall * PFNGLGETNAMEDBUFFERPARAMETERIVPROC) (GLuint buffer, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETNAMEDBUFFERPOINTERVPROC) (GLuint buffer, GLenum pname, void** params);
typedef void (__stdcall * PFNGLGETNAMEDBUFFERSUBDATAPROC) (GLuint buffer, GLintptr offset, GLsizeiptr size, void *data);
typedef void (__stdcall * PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC) (GLuint framebuffer, GLenum attachment, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC) (GLuint framebuffer, GLenum pname, GLint* param);
typedef void (__stdcall * PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC) (GLuint renderbuffer, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETQUERYBUFFEROBJECTI64VPROC) (GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
typedef void (__stdcall * PFNGLGETQUERYBUFFEROBJECTIVPROC) (GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
typedef void (__stdcall * PFNGLGETQUERYBUFFEROBJECTUI64VPROC) (GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
typedef void (__stdcall * PFNGLGETQUERYBUFFEROBJECTUIVPROC) (GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
typedef void (__stdcall * PFNGLGETTEXTUREIMAGEPROC) (GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels);
typedef void (__stdcall * PFNGLGETTEXTURELEVELPARAMETERFVPROC) (GLuint texture, GLint level, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETTEXTURELEVELPARAMETERIVPROC) (GLuint texture, GLint level, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETTEXTUREPARAMETERIIVPROC) (GLuint texture, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETTEXTUREPARAMETERIUIVPROC) (GLuint texture, GLenum pname, GLuint* params);
typedef void (__stdcall * PFNGLGETTEXTUREPARAMETERFVPROC) (GLuint texture, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETTEXTUREPARAMETERIVPROC) (GLuint texture, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETTRANSFORMFEEDBACKI64_VPROC) (GLuint xfb, GLenum pname, GLuint index, GLint64* param);
typedef void (__stdcall * PFNGLGETTRANSFORMFEEDBACKI_VPROC) (GLuint xfb, GLenum pname, GLuint index, GLint* param);
typedef void (__stdcall * PFNGLGETTRANSFORMFEEDBACKIVPROC) (GLuint xfb, GLenum pname, GLint* param);
typedef void (__stdcall * PFNGLGETVERTEXARRAYINDEXED64IVPROC) (GLuint vaobj, GLuint index, GLenum pname, GLint64* param);
typedef void (__stdcall * PFNGLGETVERTEXARRAYINDEXEDIVPROC) (GLuint vaobj, GLuint index, GLenum pname, GLint* param);
typedef void (__stdcall * PFNGLGETVERTEXARRAYIVPROC) (GLuint vaobj, GLenum pname, GLint* param);
typedef void (__stdcall * PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC) (GLuint framebuffer, GLsizei numAttachments, const GLenum* attachments);
typedef void (__stdcall * PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC) (GLuint framebuffer, GLsizei numAttachments, const GLenum* attachments, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void * (__stdcall * PFNGLMAPNAMEDBUFFERPROC) (GLuint buffer, GLenum access);
typedef void * (__stdcall * PFNGLMAPNAMEDBUFFERRANGEPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access);
typedef void (__stdcall * PFNGLNAMEDBUFFERDATAPROC) (GLuint buffer, GLsizeiptr size, const void *data, GLenum usage);
typedef void (__stdcall * PFNGLNAMEDBUFFERSTORAGEPROC) (GLuint buffer, GLsizeiptr size, const void *data, GLbitfield flags);
typedef void (__stdcall * PFNGLNAMEDBUFFERSUBDATAPROC) (GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC) (GLuint framebuffer, GLenum mode);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC) (GLuint framebuffer, GLsizei n, const GLenum* bufs);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC) (GLuint framebuffer, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC) (GLuint framebuffer, GLenum mode);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC) (GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERTEXTUREPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void (__stdcall * PFNGLNAMEDRENDERBUFFERSTORAGEPROC) (GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC) (GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLTEXTUREBUFFERPROC) (GLuint texture, GLenum internalformat, GLuint buffer);
typedef void (__stdcall * PFNGLTEXTUREBUFFERRANGEPROC) (GLuint texture, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void (__stdcall * PFNGLTEXTUREPARAMETERIIVPROC) (GLuint texture, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLTEXTUREPARAMETERIUIVPROC) (GLuint texture, GLenum pname, const GLuint* params);
typedef void (__stdcall * PFNGLTEXTUREPARAMETERFPROC) (GLuint texture, GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLTEXTUREPARAMETERFVPROC) (GLuint texture, GLenum pname, const GLfloat* param);
typedef void (__stdcall * PFNGLTEXTUREPARAMETERIPROC) (GLuint texture, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLTEXTUREPARAMETERIVPROC) (GLuint texture, GLenum pname, const GLint* param);
typedef void (__stdcall * PFNGLTEXTURESTORAGE1DPROC) (GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width);
typedef void (__stdcall * PFNGLTEXTURESTORAGE2DPROC) (GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC) (GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void (__stdcall * PFNGLTEXTURESTORAGE3DPROC) (GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
typedef void (__stdcall * PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC) (GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
typedef void (__stdcall * PFNGLTEXTURESUBIMAGE1DPROC) (GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLTEXTURESUBIMAGE2DPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLTEXTURESUBIMAGE3DPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC) (GLuint xfb, GLuint index, GLuint buffer);
typedef void (__stdcall * PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC) (GLuint xfb, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef GLboolean (__stdcall * PFNGLUNMAPNAMEDBUFFERPROC) (GLuint buffer);
typedef void (__stdcall * PFNGLVERTEXARRAYATTRIBBINDINGPROC) (GLuint vaobj, GLuint attribindex, GLuint bindingindex);
typedef void (__stdcall * PFNGLVERTEXARRAYATTRIBFORMATPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
typedef void (__stdcall * PFNGLVERTEXARRAYATTRIBIFORMATPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void (__stdcall * PFNGLVERTEXARRAYATTRIBLFORMATPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void (__stdcall * PFNGLVERTEXARRAYBINDINGDIVISORPROC) (GLuint vaobj, GLuint bindingindex, GLuint divisor);
typedef void (__stdcall * PFNGLVERTEXARRAYELEMENTBUFFERPROC) (GLuint vaobj, GLuint buffer);
typedef void (__stdcall * PFNGLVERTEXARRAYVERTEXBUFFERPROC) (GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
typedef void (__stdcall * PFNGLVERTEXARRAYVERTEXBUFFERSPROC) (GLuint vaobj, GLuint first, GLsizei count, const GLuint* buffers, const GLintptr *offsets, const GLsizei *strides);





































































































#line 4541 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






















typedef void (__stdcall * PFNGLDRAWBUFFERSARBPROC) (GLsizei n, const GLenum* bufs);





#line 4572 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLBLENDEQUATIONSEPARATEIARBPROC) (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
typedef void (__stdcall * PFNGLBLENDEQUATIONIARBPROC) (GLuint buf, GLenum mode);
typedef void (__stdcall * PFNGLBLENDFUNCSEPARATEIARBPROC) (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
typedef void (__stdcall * PFNGLBLENDFUNCIARBPROC) (GLuint buf, GLenum src, GLenum dst);








#line 4591 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLDRAWELEMENTSBASEVERTEXPROC) (GLenum mode, GLsizei count, GLenum type, void *indices, GLint basevertex);
typedef void (__stdcall * PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount, GLint basevertex);
typedef void (__stdcall * PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, void *indices, GLint basevertex);
typedef void (__stdcall * PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC) (GLenum mode, GLsizei* count, GLenum type, void**indices, GLsizei primcount, GLint *basevertex);








#line 4610 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 







typedef void (__stdcall * PFNGLDRAWARRAYSINDIRECTPROC) (GLenum mode, const void *indirect);
typedef void (__stdcall * PFNGLDRAWELEMENTSINDIRECTPROC) (GLenum mode, GLenum type, const void *indirect);






#line 4628 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 4637 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 










#line 4650 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 4659 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 4670 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 4679 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 4688 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






















#line 4713 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 4722 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 










#line 4735 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 4744 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 














typedef void (__stdcall * PFNGLFRAMEBUFFERPARAMETERIPROC) (GLenum target, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLGETFRAMEBUFFERPARAMETERIVPROC) (GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVEXTPROC) (GLuint framebuffer, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERPARAMETERIEXTPROC) (GLuint framebuffer, GLenum pname, GLint param);








#line 4773 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 















































































typedef void (__stdcall * PFNGLBINDFRAMEBUFFERPROC) (GLenum target, GLuint framebuffer);
typedef void (__stdcall * PFNGLBINDRENDERBUFFERPROC) (GLenum target, GLuint renderbuffer);
typedef void (__stdcall * PFNGLBLITFRAMEBUFFERPROC) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
typedef GLenum (__stdcall * PFNGLCHECKFRAMEBUFFERSTATUSPROC) (GLenum target);
typedef void (__stdcall * PFNGLDELETEFRAMEBUFFERSPROC) (GLsizei n, const GLuint* framebuffers);
typedef void (__stdcall * PFNGLDELETERENDERBUFFERSPROC) (GLsizei n, const GLuint* renderbuffers);
typedef void (__stdcall * PFNGLFRAMEBUFFERRENDERBUFFERPROC) (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTURE1DPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTURE2DPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTURE3DPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint layer);
typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTURELAYERPROC) (GLenum target,GLenum attachment, GLuint texture,GLint level,GLint layer);
typedef void (__stdcall * PFNGLGENFRAMEBUFFERSPROC) (GLsizei n, GLuint* framebuffers);
typedef void (__stdcall * PFNGLGENRENDERBUFFERSPROC) (GLsizei n, GLuint* renderbuffers);
typedef void (__stdcall * PFNGLGENERATEMIPMAPPROC) (GLenum target);
typedef void (__stdcall * PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC) (GLenum target, GLenum attachment, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETRENDERBUFFERPARAMETERIVPROC) (GLenum target, GLenum pname, GLint* params);
typedef GLboolean (__stdcall * PFNGLISFRAMEBUFFERPROC) (GLuint framebuffer);
typedef GLboolean (__stdcall * PFNGLISRENDERBUFFERPROC) (GLuint renderbuffer);
typedef void (__stdcall * PFNGLRENDERBUFFERSTORAGEPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
























#line 4899 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 4910 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 
























typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTUREARBPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level);
typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTUREFACEARBPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);
typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTURELAYERARBPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void (__stdcall * PFNGLPROGRAMPARAMETERIARBPROC) (GLuint program, GLenum pname, GLint value);








#line 4949 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









typedef void (__stdcall * PFNGLGETPROGRAMBINARYPROC) (GLuint program, GLsizei bufSize, GLsizei* length, GLenum *binaryFormat, void*binary);
typedef void (__stdcall * PFNGLPROGRAMBINARYPROC) (GLuint program, GLenum binaryFormat, const void *binary, GLsizei length);
typedef void (__stdcall * PFNGLPROGRAMPARAMETERIPROC) (GLuint program, GLenum pname, GLint value);







#line 4971 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei bufSize, void *pixels);
typedef void (__stdcall * PFNGLGETTEXTURESUBIMAGEPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLsizei bufSize, void *pixels);






#line 4986 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 







typedef void (__stdcall * PFNGLSPECIALIZESHADERARBPROC) (GLuint shader, const GLchar* pEntryPoint, GLuint numSpecializationConstants, const GLuint* pConstantIndex, const GLuint* pConstantValue);





#line 5002 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 













#line 5018 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 

















typedef void (__stdcall * PFNGLGETUNIFORMDVPROC) (GLuint program, GLint location, GLdouble* params);
typedef void (__stdcall * PFNGLUNIFORM1DPROC) (GLint location, GLdouble x);
typedef void (__stdcall * PFNGLUNIFORM1DVPROC) (GLint location, GLsizei count, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORM2DPROC) (GLint location, GLdouble x, GLdouble y);
typedef void (__stdcall * PFNGLUNIFORM2DVPROC) (GLint location, GLsizei count, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORM3DPROC) (GLint location, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLUNIFORM3DVPROC) (GLint location, GLsizei count, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORM4DPROC) (GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLUNIFORM4DVPROC) (GLint location, GLsizei count, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX2DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX2X3DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX2X4DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX3DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX3X2DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX3X4DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX4DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX4X2DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX4X3DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);






















#line 5078 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 













typedef void (__stdcall * PFNGLGETUNIFORMI64VARBPROC) (GLuint program, GLint location, GLint64* params);
typedef void (__stdcall * PFNGLGETUNIFORMUI64VARBPROC) (GLuint program, GLint location, GLuint64* params);
typedef void (__stdcall * PFNGLGETNUNIFORMI64VARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLint64* params);
typedef void (__stdcall * PFNGLGETNUNIFORMUI64VARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLuint64* params);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1I64ARBPROC) (GLuint program, GLint location, GLint64 x);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1I64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLint64* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1UI64ARBPROC) (GLuint program, GLint location, GLuint64 x);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1UI64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLuint64* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2I64ARBPROC) (GLuint program, GLint location, GLint64 x, GLint64 y);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2I64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLint64* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2UI64ARBPROC) (GLuint program, GLint location, GLuint64 x, GLuint64 y);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2UI64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLuint64* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3I64ARBPROC) (GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3I64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLint64* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3UI64ARBPROC) (GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3UI64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLuint64* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4I64ARBPROC) (GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4I64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLint64* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4UI64ARBPROC) (GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4UI64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLuint64* value);
typedef void (__stdcall * PFNGLUNIFORM1I64ARBPROC) (GLint location, GLint64 x);
typedef void (__stdcall * PFNGLUNIFORM1I64VARBPROC) (GLint location, GLsizei count, const GLint64* value);
typedef void (__stdcall * PFNGLUNIFORM1UI64ARBPROC) (GLint location, GLuint64 x);
typedef void (__stdcall * PFNGLUNIFORM1UI64VARBPROC) (GLint location, GLsizei count, const GLuint64* value);
typedef void (__stdcall * PFNGLUNIFORM2I64ARBPROC) (GLint location, GLint64 x, GLint64 y);
typedef void (__stdcall * PFNGLUNIFORM2I64VARBPROC) (GLint location, GLsizei count, const GLint64* value);
typedef void (__stdcall * PFNGLUNIFORM2UI64ARBPROC) (GLint location, GLuint64 x, GLuint64 y);
typedef void (__stdcall * PFNGLUNIFORM2UI64VARBPROC) (GLint location, GLsizei count, const GLuint64* value);
typedef void (__stdcall * PFNGLUNIFORM3I64ARBPROC) (GLint location, GLint64 x, GLint64 y, GLint64 z);
typedef void (__stdcall * PFNGLUNIFORM3I64VARBPROC) (GLint location, GLsizei count, const GLint64* value);
typedef void (__stdcall * PFNGLUNIFORM3UI64ARBPROC) (GLint location, GLuint64 x, GLuint64 y, GLuint64 z);
typedef void (__stdcall * PFNGLUNIFORM3UI64VARBPROC) (GLint location, GLsizei count, const GLuint64* value);
typedef void (__stdcall * PFNGLUNIFORM4I64ARBPROC) (GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w);
typedef void (__stdcall * PFNGLUNIFORM4I64VARBPROC) (GLint location, GLsizei count, const GLint64* value);
typedef void (__stdcall * PFNGLUNIFORM4UI64ARBPROC) (GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w);
typedef void (__stdcall * PFNGLUNIFORM4UI64VARBPROC) (GLint location, GLsizei count, const GLuint64* value);








































#line 5170 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 5181 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 5192 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 


















































































typedef void (__stdcall * PFNGLCOLORSUBTABLEPROC) (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void *data);
typedef void (__stdcall * PFNGLCOLORTABLEPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *table);
typedef void (__stdcall * PFNGLCOLORTABLEPARAMETERFVPROC) (GLenum target, GLenum pname, const GLfloat *params);
typedef void (__stdcall * PFNGLCOLORTABLEPARAMETERIVPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void (__stdcall * PFNGLCONVOLUTIONFILTER1DPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *image);
typedef void (__stdcall * PFNGLCONVOLUTIONFILTER2DPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *image);
typedef void (__stdcall * PFNGLCONVOLUTIONPARAMETERFPROC) (GLenum target, GLenum pname, GLfloat params);
typedef void (__stdcall * PFNGLCONVOLUTIONPARAMETERFVPROC) (GLenum target, GLenum pname, const GLfloat *params);
typedef void (__stdcall * PFNGLCONVOLUTIONPARAMETERIPROC) (GLenum target, GLenum pname, GLint params);
typedef void (__stdcall * PFNGLCONVOLUTIONPARAMETERIVPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void (__stdcall * PFNGLCOPYCOLORSUBTABLEPROC) (GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
typedef void (__stdcall * PFNGLCOPYCOLORTABLEPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void (__stdcall * PFNGLCOPYCONVOLUTIONFILTER1DPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void (__stdcall * PFNGLCOPYCONVOLUTIONFILTER2DPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLGETCOLORTABLEPROC) (GLenum target, GLenum format, GLenum type, void *table);
typedef void (__stdcall * PFNGLGETCOLORTABLEPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void (__stdcall * PFNGLGETCOLORTABLEPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void (__stdcall * PFNGLGETCONVOLUTIONFILTERPROC) (GLenum target, GLenum format, GLenum type, void *image);
typedef void (__stdcall * PFNGLGETCONVOLUTIONPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void (__stdcall * PFNGLGETCONVOLUTIONPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void (__stdcall * PFNGLGETHISTOGRAMPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, void *values);
typedef void (__stdcall * PFNGLGETHISTOGRAMPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void (__stdcall * PFNGLGETHISTOGRAMPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void (__stdcall * PFNGLGETMINMAXPROC) (GLenum target, GLboolean reset, GLenum format, GLenum types, void *values);
typedef void (__stdcall * PFNGLGETMINMAXPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void (__stdcall * PFNGLGETMINMAXPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void (__stdcall * PFNGLGETSEPARABLEFILTERPROC) (GLenum target, GLenum format, GLenum type, void *row, void *column, void *span);
typedef void (__stdcall * PFNGLHISTOGRAMPROC) (GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
typedef void (__stdcall * PFNGLMINMAXPROC) (GLenum target, GLenum internalformat, GLboolean sink);
typedef void (__stdcall * PFNGLRESETHISTOGRAMPROC) (GLenum target);
typedef void (__stdcall * PFNGLRESETMINMAXPROC) (GLenum target);
typedef void (__stdcall * PFNGLSEPARABLEFILTER2DPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *row, const void *column);




































#line 5345 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 







typedef void (__stdcall * PFNGLMULTIDRAWARRAYSINDIRECTCOUNTARBPROC) (GLenum mode, const void *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
typedef void (__stdcall * PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTARBPROC) (GLenum mode, GLenum type, const void *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);






#line 5363 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






typedef void (__stdcall * PFNGLDRAWARRAYSINSTANCEDARBPROC) (GLenum mode, GLint first, GLsizei count, GLsizei primcount);
typedef void (__stdcall * PFNGLDRAWELEMENTSINSTANCEDARBPROC) (GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei primcount);
typedef void (__stdcall * PFNGLVERTEXATTRIBDIVISORARBPROC) (GLuint index, GLuint divisor);







#line 5382 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






typedef void (__stdcall * PFNGLGETINTERNALFORMATIVPROC) (GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint* params);





#line 5397 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








































































































typedef void (__stdcall * PFNGLGETINTERNALFORMATI64VPROC) (GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64* params);





#line 5510 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLINVALIDATEBUFFERDATAPROC) (GLuint buffer);
typedef void (__stdcall * PFNGLINVALIDATEBUFFERSUBDATAPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length);
typedef void (__stdcall * PFNGLINVALIDATEFRAMEBUFFERPROC) (GLenum target, GLsizei numAttachments, const GLenum* attachments);
typedef void (__stdcall * PFNGLINVALIDATESUBFRAMEBUFFERPROC) (GLenum target, GLsizei numAttachments, const GLenum* attachments, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLINVALIDATETEXIMAGEPROC) (GLuint texture, GLint level);
typedef void (__stdcall * PFNGLINVALIDATETEXSUBIMAGEPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth);










#line 5533 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 5544 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











typedef void (__stdcall * PFNGLFLUSHMAPPEDBUFFERRANGEPROC) (GLenum target, GLintptr offset, GLsizeiptr length);
typedef void * (__stdcall * PFNGLMAPBUFFERRANGEPROC) (GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);






#line 5566 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 















typedef void (__stdcall * PFNGLCURRENTPALETTEMATRIXARBPROC) (GLint index);
typedef void (__stdcall * PFNGLMATRIXINDEXPOINTERARBPROC) (GLint size, GLenum type, GLsizei stride, void *pointer);
typedef void (__stdcall * PFNGLMATRIXINDEXUBVARBPROC) (GLint size, GLubyte *indices);
typedef void (__stdcall * PFNGLMATRIXINDEXUIVARBPROC) (GLint size, GLuint *indices);
typedef void (__stdcall * PFNGLMATRIXINDEXUSVARBPROC) (GLint size, GLushort *indices);









#line 5598 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLBINDBUFFERSBASEPROC) (GLenum target, GLuint first, GLsizei count, const GLuint* buffers);
typedef void (__stdcall * PFNGLBINDBUFFERSRANGEPROC) (GLenum target, GLuint first, GLsizei count, const GLuint* buffers, const GLintptr *offsets, const GLsizeiptr *sizes);
typedef void (__stdcall * PFNGLBINDIMAGETEXTURESPROC) (GLuint first, GLsizei count, const GLuint* textures);
typedef void (__stdcall * PFNGLBINDSAMPLERSPROC) (GLuint first, GLsizei count, const GLuint* samplers);
typedef void (__stdcall * PFNGLBINDTEXTURESPROC) (GLuint first, GLsizei count, const GLuint* textures);
typedef void (__stdcall * PFNGLBINDVERTEXBUFFERSPROC) (GLuint first, GLsizei count, const GLuint* buffers, const GLintptr *offsets, const GLsizei *strides);










#line 5621 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLMULTIDRAWARRAYSINDIRECTPROC) (GLenum mode, const void *indirect, GLsizei primcount, GLsizei stride);
typedef void (__stdcall * PFNGLMULTIDRAWELEMENTSINDIRECTPROC) (GLenum mode, GLenum type, const void *indirect, GLsizei primcount, GLsizei stride);






#line 5636 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 














typedef void (__stdcall * PFNGLSAMPLECOVERAGEARBPROC) (GLclampf value, GLboolean invert);





#line 5659 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








































typedef void (__stdcall * PFNGLACTIVETEXTUREARBPROC) (GLenum texture);
typedef void (__stdcall * PFNGLCLIENTACTIVETEXTUREARBPROC) (GLenum texture);
typedef void (__stdcall * PFNGLMULTITEXCOORD1DARBPROC) (GLenum target, GLdouble s);
typedef void (__stdcall * PFNGLMULTITEXCOORD1DVARBPROC) (GLenum target, const GLdouble *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD1FARBPROC) (GLenum target, GLfloat s);
typedef void (__stdcall * PFNGLMULTITEXCOORD1FVARBPROC) (GLenum target, const GLfloat *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD1IARBPROC) (GLenum target, GLint s);
typedef void (__stdcall * PFNGLMULTITEXCOORD1IVARBPROC) (GLenum target, const GLint *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD1SARBPROC) (GLenum target, GLshort s);
typedef void (__stdcall * PFNGLMULTITEXCOORD1SVARBPROC) (GLenum target, const GLshort *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD2DARBPROC) (GLenum target, GLdouble s, GLdouble t);
typedef void (__stdcall * PFNGLMULTITEXCOORD2DVARBPROC) (GLenum target, const GLdouble *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD2FARBPROC) (GLenum target, GLfloat s, GLfloat t);
typedef void (__stdcall * PFNGLMULTITEXCOORD2FVARBPROC) (GLenum target, const GLfloat *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD2IARBPROC) (GLenum target, GLint s, GLint t);
typedef void (__stdcall * PFNGLMULTITEXCOORD2IVARBPROC) (GLenum target, const GLint *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD2SARBPROC) (GLenum target, GLshort s, GLshort t);
typedef void (__stdcall * PFNGLMULTITEXCOORD2SVARBPROC) (GLenum target, const GLshort *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD3DARBPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r);
typedef void (__stdcall * PFNGLMULTITEXCOORD3DVARBPROC) (GLenum target, const GLdouble *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD3FARBPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r);
typedef void (__stdcall * PFNGLMULTITEXCOORD3FVARBPROC) (GLenum target, const GLfloat *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD3IARBPROC) (GLenum target, GLint s, GLint t, GLint r);
typedef void (__stdcall * PFNGLMULTITEXCOORD3IVARBPROC) (GLenum target, const GLint *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD3SARBPROC) (GLenum target, GLshort s, GLshort t, GLshort r);
typedef void (__stdcall * PFNGLMULTITEXCOORD3SVARBPROC) (GLenum target, const GLshort *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD4DARBPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
typedef void (__stdcall * PFNGLMULTITEXCOORD4DVARBPROC) (GLenum target, const GLdouble *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD4FARBPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
typedef void (__stdcall * PFNGLMULTITEXCOORD4FVARBPROC) (GLenum target, const GLfloat *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD4IARBPROC) (GLenum target, GLint s, GLint t, GLint r, GLint q);
typedef void (__stdcall * PFNGLMULTITEXCOORD4IVARBPROC) (GLenum target, const GLint *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD4SARBPROC) (GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
typedef void (__stdcall * PFNGLMULTITEXCOORD4SVARBPROC) (GLenum target, const GLshort *v);






































#line 5774 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 










typedef void (__stdcall * PFNGLBEGINQUERYARBPROC) (GLenum target, GLuint id);
typedef void (__stdcall * PFNGLDELETEQUERIESARBPROC) (GLsizei n, const GLuint* ids);
typedef void (__stdcall * PFNGLENDQUERYARBPROC) (GLenum target);
typedef void (__stdcall * PFNGLGENQUERIESARBPROC) (GLsizei n, GLuint* ids);
typedef void (__stdcall * PFNGLGETQUERYOBJECTIVARBPROC) (GLuint id, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETQUERYOBJECTUIVARBPROC) (GLuint id, GLenum pname, GLuint* params);
typedef void (__stdcall * PFNGLGETQUERYIVARBPROC) (GLenum target, GLenum pname, GLint* params);
typedef GLboolean (__stdcall * PFNGLISQUERYARBPROC) (GLuint id);












#line 5807 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 5818 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 







typedef void (__stdcall * PFNGLMAXSHADERCOMPILERTHREADSARBPROC) (GLuint count);





#line 5834 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 


















#line 5855 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











#line 5869 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









typedef void (__stdcall * PFNGLPOINTPARAMETERFARBPROC) (GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLPOINTPARAMETERFVARBPROC) (GLenum pname, const GLfloat* params);






#line 5889 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 5901 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






typedef void (__stdcall * PFNGLPOLYGONOFFSETCLAMPPROC) (GLfloat factor, GLfloat units, GLfloat clamp);





#line 5916 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 5925 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




















































typedef void (__stdcall * PFNGLGETPROGRAMINTERFACEIVPROC) (GLuint program, GLenum programInterface, GLenum pname, GLint* params);
typedef GLuint (__stdcall * PFNGLGETPROGRAMRESOURCEINDEXPROC) (GLuint program, GLenum programInterface, const GLchar* name);
typedef GLint (__stdcall * PFNGLGETPROGRAMRESOURCELOCATIONPROC) (GLuint program, GLenum programInterface, const GLchar* name);
typedef GLint (__stdcall * PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC) (GLuint program, GLenum programInterface, const GLchar* name);
typedef void (__stdcall * PFNGLGETPROGRAMRESOURCENAMEPROC) (GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei* length, GLchar *name);
typedef void (__stdcall * PFNGLGETPROGRAMRESOURCEIVPROC) (GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum* props, GLsizei bufSize, GLsizei *length, GLint *params);










#line 5996 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









typedef void (__stdcall * PFNGLPROVOKINGVERTEXPROC) (GLenum mode);





#line 6014 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











#line 6028 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 6037 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 












typedef GLenum (__stdcall * PFNGLGETGRAPHICSRESETSTATUSARBPROC) (void);
typedef void (__stdcall * PFNGLGETNCOLORTABLEARBPROC) (GLenum target, GLenum format, GLenum type, GLsizei bufSize, void* table);
typedef void (__stdcall * PFNGLGETNCOMPRESSEDTEXIMAGEARBPROC) (GLenum target, GLint lod, GLsizei bufSize, void* img);
typedef void (__stdcall * PFNGLGETNCONVOLUTIONFILTERARBPROC) (GLenum target, GLenum format, GLenum type, GLsizei bufSize, void* image);
typedef void (__stdcall * PFNGLGETNHISTOGRAMARBPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void* values);
typedef void (__stdcall * PFNGLGETNMAPDVARBPROC) (GLenum target, GLenum query, GLsizei bufSize, GLdouble* v);
typedef void (__stdcall * PFNGLGETNMAPFVARBPROC) (GLenum target, GLenum query, GLsizei bufSize, GLfloat* v);
typedef void (__stdcall * PFNGLGETNMAPIVARBPROC) (GLenum target, GLenum query, GLsizei bufSize, GLint* v);
typedef void (__stdcall * PFNGLGETNMINMAXARBPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void* values);
typedef void (__stdcall * PFNGLGETNPIXELMAPFVARBPROC) (GLenum map, GLsizei bufSize, GLfloat* values);
typedef void (__stdcall * PFNGLGETNPIXELMAPUIVARBPROC) (GLenum map, GLsizei bufSize, GLuint* values);
typedef void (__stdcall * PFNGLGETNPIXELMAPUSVARBPROC) (GLenum map, GLsizei bufSize, GLushort* values);
typedef void (__stdcall * PFNGLGETNPOLYGONSTIPPLEARBPROC) (GLsizei bufSize, GLubyte* pattern);
typedef void (__stdcall * PFNGLGETNSEPARABLEFILTERARBPROC) (GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, void* row, GLsizei columnBufSize, void*column, void*span);
typedef void (__stdcall * PFNGLGETNTEXIMAGEARBPROC) (GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void* img);
typedef void (__stdcall * PFNGLGETNUNIFORMDVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLdouble* params);
typedef void (__stdcall * PFNGLGETNUNIFORMFVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLfloat* params);
typedef void (__stdcall * PFNGLGETNUNIFORMIVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLint* params);
typedef void (__stdcall * PFNGLGETNUNIFORMUIVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLuint* params);
typedef void (__stdcall * PFNGLREADNPIXELSARBPROC) (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void* data);
























#line 6096 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 6105 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 6114 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 













typedef void (__stdcall * PFNGLFRAMEBUFFERSAMPLELOCATIONSFVARBPROC) (GLenum target, GLuint start, GLsizei count, const GLfloat* v);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVARBPROC) (GLuint framebuffer, GLuint start, GLsizei count, const GLfloat* v);






#line 6138 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 







typedef void (__stdcall * PFNGLMINSAMPLESHADINGARBPROC) (GLclampf value);





#line 6154 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






typedef void (__stdcall * PFNGLBINDSAMPLERPROC) (GLuint unit, GLuint sampler);
typedef void (__stdcall * PFNGLDELETESAMPLERSPROC) (GLsizei count, const GLuint * samplers);
typedef void (__stdcall * PFNGLGENSAMPLERSPROC) (GLsizei count, GLuint* samplers);
typedef void (__stdcall * PFNGLGETSAMPLERPARAMETERIIVPROC) (GLuint sampler, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETSAMPLERPARAMETERIUIVPROC) (GLuint sampler, GLenum pname, GLuint* params);
typedef void (__stdcall * PFNGLGETSAMPLERPARAMETERFVPROC) (GLuint sampler, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETSAMPLERPARAMETERIVPROC) (GLuint sampler, GLenum pname, GLint* params);
typedef GLboolean (__stdcall * PFNGLISSAMPLERPROC) (GLuint sampler);
typedef void (__stdcall * PFNGLSAMPLERPARAMETERIIVPROC) (GLuint sampler, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLSAMPLERPARAMETERIUIVPROC) (GLuint sampler, GLenum pname, const GLuint* params);
typedef void (__stdcall * PFNGLSAMPLERPARAMETERFPROC) (GLuint sampler, GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLSAMPLERPARAMETERFVPROC) (GLuint sampler, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLSAMPLERPARAMETERIPROC) (GLuint sampler, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLSAMPLERPARAMETERIVPROC) (GLuint sampler, GLenum pname, const GLint* params);


















#line 6195 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 6206 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 6217 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 














typedef void (__stdcall * PFNGLACTIVESHADERPROGRAMPROC) (GLuint pipeline, GLuint program);
typedef void (__stdcall * PFNGLBINDPROGRAMPIPELINEPROC) (GLuint pipeline);
typedef GLuint (__stdcall * PFNGLCREATESHADERPROGRAMVPROC) (GLenum type, GLsizei count, const GLchar * const * strings);
typedef void (__stdcall * PFNGLDELETEPROGRAMPIPELINESPROC) (GLsizei n, const GLuint* pipelines);
typedef void (__stdcall * PFNGLGENPROGRAMPIPELINESPROC) (GLsizei n, GLuint* pipelines);
typedef void (__stdcall * PFNGLGETPROGRAMPIPELINEINFOLOGPROC) (GLuint pipeline, GLsizei bufSize, GLsizei* length, GLchar *infoLog);
typedef void (__stdcall * PFNGLGETPROGRAMPIPELINEIVPROC) (GLuint pipeline, GLenum pname, GLint* params);
typedef GLboolean (__stdcall * PFNGLISPROGRAMPIPELINEPROC) (GLuint pipeline);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1DPROC) (GLuint program, GLint location, GLdouble x);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1FPROC) (GLuint program, GLint location, GLfloat x);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1IPROC) (GLuint program, GLint location, GLint x);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1IVPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1UIPROC) (GLuint program, GLint location, GLuint x);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2DPROC) (GLuint program, GLint location, GLdouble x, GLdouble y);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2FPROC) (GLuint program, GLint location, GLfloat x, GLfloat y);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2IPROC) (GLuint program, GLint location, GLint x, GLint y);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2IVPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2UIPROC) (GLuint program, GLint location, GLuint x, GLuint y);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3DPROC) (GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3FPROC) (GLuint program, GLint location, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3IPROC) (GLuint program, GLint location, GLint x, GLint y, GLint z);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3IVPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3UIPROC) (GLuint program, GLint location, GLuint x, GLuint y, GLuint z);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4DPROC) (GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4FPROC) (GLuint program, GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4IPROC) (GLuint program, GLint location, GLint x, GLint y, GLint z, GLint w);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4IVPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4UIPROC) (GLuint program, GLint location, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX2DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX2FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX3DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX3FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX4DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX4FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLUSEPROGRAMSTAGESPROC) (GLuint pipeline, GLbitfield stages, GLuint program);
typedef void (__stdcall * PFNGLVALIDATEPROGRAMPIPELINEPROC) (GLuint pipeline);
































































#line 6358 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 6367 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 


































typedef void (__stdcall * PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC) (GLuint program, GLuint bufferIndex, GLenum pname, GLint* params);





#line 6410 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 6419 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 6428 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 6437 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 6446 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 6455 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 





































































typedef void (__stdcall * PFNGLBINDIMAGETEXTUREPROC) (GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format);
typedef void (__stdcall * PFNGLMEMORYBARRIERPROC) (GLbitfield barriers);






#line 6535 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 6544 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 







































typedef char GLcharARB;
typedef unsigned int GLhandleARB;

typedef void (__stdcall * PFNGLATTACHOBJECTARBPROC) (GLhandleARB containerObj, GLhandleARB obj);
typedef void (__stdcall * PFNGLCOMPILESHADERARBPROC) (GLhandleARB shaderObj);
typedef GLhandleARB (__stdcall * PFNGLCREATEPROGRAMOBJECTARBPROC) (void);
typedef GLhandleARB (__stdcall * PFNGLCREATESHADEROBJECTARBPROC) (GLenum shaderType);
typedef void (__stdcall * PFNGLDELETEOBJECTARBPROC) (GLhandleARB obj);
typedef void (__stdcall * PFNGLDETACHOBJECTARBPROC) (GLhandleARB containerObj, GLhandleARB attachedObj);
typedef void (__stdcall * PFNGLGETACTIVEUNIFORMARBPROC) (GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei* length, GLint *size, GLenum *type, GLcharARB *name);
typedef void (__stdcall * PFNGLGETATTACHEDOBJECTSARBPROC) (GLhandleARB containerObj, GLsizei maxCount, GLsizei* count, GLhandleARB *obj);
typedef GLhandleARB (__stdcall * PFNGLGETHANDLEARBPROC) (GLenum pname);
typedef void (__stdcall * PFNGLGETINFOLOGARBPROC) (GLhandleARB obj, GLsizei maxLength, GLsizei* length, GLcharARB *infoLog);
typedef void (__stdcall * PFNGLGETOBJECTPARAMETERFVARBPROC) (GLhandleARB obj, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETOBJECTPARAMETERIVARBPROC) (GLhandleARB obj, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETSHADERSOURCEARBPROC) (GLhandleARB obj, GLsizei maxLength, GLsizei* length, GLcharARB *source);
typedef GLint (__stdcall * PFNGLGETUNIFORMLOCATIONARBPROC) (GLhandleARB programObj, const GLcharARB* name);
typedef void (__stdcall * PFNGLGETUNIFORMFVARBPROC) (GLhandleARB programObj, GLint location, GLfloat* params);
typedef void (__stdcall * PFNGLGETUNIFORMIVARBPROC) (GLhandleARB programObj, GLint location, GLint* params);
typedef void (__stdcall * PFNGLLINKPROGRAMARBPROC) (GLhandleARB programObj);
typedef void (__stdcall * PFNGLSHADERSOURCEARBPROC) (GLhandleARB shaderObj, GLsizei count, const GLcharARB ** string, const GLint *length);
typedef void (__stdcall * PFNGLUNIFORM1FARBPROC) (GLint location, GLfloat v0);
typedef void (__stdcall * PFNGLUNIFORM1FVARBPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORM1IARBPROC) (GLint location, GLint v0);
typedef void (__stdcall * PFNGLUNIFORM1IVARBPROC) (GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLUNIFORM2FARBPROC) (GLint location, GLfloat v0, GLfloat v1);
typedef void (__stdcall * PFNGLUNIFORM2FVARBPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORM2IARBPROC) (GLint location, GLint v0, GLint v1);
typedef void (__stdcall * PFNGLUNIFORM2IVARBPROC) (GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLUNIFORM3FARBPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void (__stdcall * PFNGLUNIFORM3FVARBPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORM3IARBPROC) (GLint location, GLint v0, GLint v1, GLint v2);
typedef void (__stdcall * PFNGLUNIFORM3IVARBPROC) (GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLUNIFORM4FARBPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void (__stdcall * PFNGLUNIFORM4FVARBPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORM4IARBPROC) (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void (__stdcall * PFNGLUNIFORM4IVARBPROC) (GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX2FVARBPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX3FVARBPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX4FVARBPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLUSEPROGRAMOBJECTARBPROC) (GLhandleARB programObj);
typedef void (__stdcall * PFNGLVALIDATEPROGRAMARBPROC) (GLhandleARB programObj);











































#line 6671 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 6680 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 6689 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 





















typedef void (__stdcall * PFNGLSHADERSTORAGEBLOCKBINDINGPROC) (GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding);





#line 6719 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 














typedef void (__stdcall * PFNGLGETACTIVESUBROUTINENAMEPROC) (GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei* length, GLchar *name);
typedef void (__stdcall * PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC) (GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei* length, GLchar *name);
typedef void (__stdcall * PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC) (GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint* values);
typedef void (__stdcall * PFNGLGETPROGRAMSTAGEIVPROC) (GLuint program, GLenum shadertype, GLenum pname, GLint* values);
typedef GLuint (__stdcall * PFNGLGETSUBROUTINEINDEXPROC) (GLuint program, GLenum shadertype, const GLchar* name);
typedef GLint (__stdcall * PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC) (GLuint program, GLenum shadertype, const GLchar* name);
typedef void (__stdcall * PFNGLGETUNIFORMSUBROUTINEUIVPROC) (GLenum shadertype, GLint location, GLuint* params);
typedef void (__stdcall * PFNGLUNIFORMSUBROUTINESUIVPROC) (GLenum shadertype, GLsizei count, const GLuint* indices);












#line 6756 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 6765 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 6774 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 6783 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 6794 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 6803 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








typedef void (__stdcall * PFNGLCOMPILESHADERINCLUDEARBPROC) (GLuint shader, GLsizei count, const GLchar* const *path, const GLint *length);
typedef void (__stdcall * PFNGLDELETENAMEDSTRINGARBPROC) (GLint namelen, const GLchar* name);
typedef void (__stdcall * PFNGLGETNAMEDSTRINGARBPROC) (GLint namelen, const GLchar* name, GLsizei bufSize, GLint *stringlen, GLchar *string);
typedef void (__stdcall * PFNGLGETNAMEDSTRINGIVARBPROC) (GLint namelen, const GLchar* name, GLenum pname, GLint *params);
typedef GLboolean (__stdcall * PFNGLISNAMEDSTRINGARBPROC) (GLint namelen, const GLchar* name);
typedef void (__stdcall * PFNGLNAMEDSTRINGARBPROC) (GLenum type, GLint namelen, const GLchar* name, GLint stringlen, const GLchar *string);










#line 6830 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 6839 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 










#line 6852 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 6863 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 







typedef void (__stdcall * PFNGLBUFFERPAGECOMMITMENTARBPROC) (GLenum target, GLintptr offset, GLsizeiptr size, GLboolean commit);





#line 6879 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 
















typedef void (__stdcall * PFNGLTEXPAGECOMMITMENTARBPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit);





#line 6904 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 6913 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 6922 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 6934 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 6945 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




















typedef GLenum (__stdcall * PFNGLCLIENTWAITSYNCPROC) (GLsync GLsync,GLbitfield flags,GLuint64 timeout);
typedef void (__stdcall * PFNGLDELETESYNCPROC) (GLsync GLsync);
typedef GLsync (__stdcall * PFNGLFENCESYNCPROC) (GLenum condition,GLbitfield flags);
typedef void (__stdcall * PFNGLGETINTEGER64VPROC) (GLenum pname, GLint64* params);
typedef void (__stdcall * PFNGLGETSYNCIVPROC) (GLsync GLsync,GLenum pname,GLsizei bufSize,GLsizei* length, GLint *values);
typedef GLboolean (__stdcall * PFNGLISSYNCPROC) (GLsync GLsync);
typedef void (__stdcall * PFNGLWAITSYNCPROC) (GLsync GLsync,GLbitfield flags,GLuint64 timeout);











#line 6986 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 





































typedef void (__stdcall * PFNGLPATCHPARAMETERFVPROC) (GLenum pname, const GLfloat* values);
typedef void (__stdcall * PFNGLPATCHPARAMETERIPROC) (GLenum pname, GLint value);






#line 7034 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLTEXTUREBARRIERPROC) (void);





#line 7047 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 7058 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 










typedef void (__stdcall * PFNGLTEXBUFFERARBPROC) (GLenum target, GLenum internalformat, GLuint buffer);





#line 7077 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 7086 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








typedef void (__stdcall * PFNGLTEXBUFFERRANGEPROC) (GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void (__stdcall * PFNGLTEXTUREBUFFERRANGEEXTPROC) (GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);






#line 7105 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 
















typedef void (__stdcall * PFNGLCOMPRESSEDTEXIMAGE1DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXIMAGE2DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXIMAGE3DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLGETCOMPRESSEDTEXIMAGEARBPROC) (GLenum target, GLint lod, void *img);











#line 7142 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











#line 7156 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











#line 7170 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 



















#line 7192 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 














#line 7209 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 7218 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 





























#line 7250 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 7259 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 7271 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 7283 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 7295 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 



























#line 7325 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 










#line 7338 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 7349 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 7360 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 


























typedef void (__stdcall * PFNGLGETMULTISAMPLEFVPROC) (GLenum pname, GLuint index, GLfloat* val);
typedef void (__stdcall * PFNGLSAMPLEMASKIPROC) (GLuint index, GLbitfield mask);
typedef void (__stdcall * PFNGLTEXIMAGE2DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void (__stdcall * PFNGLTEXIMAGE3DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);








#line 7401 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 7410 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 7419 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 7428 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 













#line 7444 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 































#line 7478 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 7489 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 7501 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






typedef void (__stdcall * PFNGLTEXSTORAGE1DPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
typedef void (__stdcall * PFNGLTEXSTORAGE2DPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLTEXSTORAGE3DPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);







#line 7520 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLTEXSTORAGE2DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void (__stdcall * PFNGLTEXSTORAGE3DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
typedef void (__stdcall * PFNGLTEXTURESTORAGE2DMULTISAMPLEEXTPROC) (GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void (__stdcall * PFNGLTEXTURESTORAGE3DMULTISAMPLEEXTPROC) (GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);








#line 7539 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 












#line 7554 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 










typedef void (__stdcall * PFNGLTEXTUREVIEWPROC) (GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers);





#line 7573 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 







typedef void (__stdcall * PFNGLGETQUERYOBJECTI64VPROC) (GLuint id, GLenum pname, GLint64* params);
typedef void (__stdcall * PFNGLGETQUERYOBJECTUI64VPROC) (GLuint id, GLenum pname, GLuint64* params);
typedef void (__stdcall * PFNGLQUERYCOUNTERPROC) (GLuint id, GLenum target);







#line 7593 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









typedef void (__stdcall * PFNGLBINDTRANSFORMFEEDBACKPROC) (GLenum target, GLuint id);
typedef void (__stdcall * PFNGLDELETETRANSFORMFEEDBACKSPROC) (GLsizei n, const GLuint* ids);
typedef void (__stdcall * PFNGLDRAWTRANSFORMFEEDBACKPROC) (GLenum mode, GLuint id);
typedef void (__stdcall * PFNGLGENTRANSFORMFEEDBACKSPROC) (GLsizei n, GLuint* ids);
typedef GLboolean (__stdcall * PFNGLISTRANSFORMFEEDBACKPROC) (GLuint id);
typedef void (__stdcall * PFNGLPAUSETRANSFORMFEEDBACKPROC) (void);
typedef void (__stdcall * PFNGLRESUMETRANSFORMFEEDBACKPROC) (void);











#line 7623 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 







typedef void (__stdcall * PFNGLBEGINQUERYINDEXEDPROC) (GLenum target, GLuint index, GLuint id);
typedef void (__stdcall * PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC) (GLenum mode, GLuint id, GLuint stream);
typedef void (__stdcall * PFNGLENDQUERYINDEXEDPROC) (GLenum target, GLuint index);
typedef void (__stdcall * PFNGLGETQUERYINDEXEDIVPROC) (GLenum target, GLuint index, GLenum pname, GLint* params);








#line 7645 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC) (GLenum mode, GLuint id, GLsizei primcount);
typedef void (__stdcall * PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC) (GLenum mode, GLuint id, GLuint stream, GLsizei primcount);






#line 7660 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 7672 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









typedef void (__stdcall * PFNGLLOADTRANSPOSEMATRIXDARBPROC) (GLdouble m[16]);
typedef void (__stdcall * PFNGLLOADTRANSPOSEMATRIXFARBPROC) (GLfloat m[16]);
typedef void (__stdcall * PFNGLMULTTRANSPOSEMATRIXDARBPROC) (GLdouble m[16]);
typedef void (__stdcall * PFNGLMULTTRANSPOSEMATRIXFARBPROC) (GLfloat m[16]);








#line 7696 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






































typedef void (__stdcall * PFNGLBINDBUFFERBASEPROC) (GLenum target, GLuint index, GLuint buffer);
typedef void (__stdcall * PFNGLBINDBUFFERRANGEPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void (__stdcall * PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC) (GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformBlockName);
typedef void (__stdcall * PFNGLGETACTIVEUNIFORMBLOCKIVPROC) (GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETACTIVEUNIFORMNAMEPROC) (GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformName);
typedef void (__stdcall * PFNGLGETACTIVEUNIFORMSIVPROC) (GLuint program, GLsizei uniformCount, const GLuint* uniformIndices, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETINTEGERI_VPROC) (GLenum target, GLuint index, GLint* data);
typedef GLuint (__stdcall * PFNGLGETUNIFORMBLOCKINDEXPROC) (GLuint program, const GLchar* uniformBlockName);
typedef void (__stdcall * PFNGLGETUNIFORMINDICESPROC) (GLuint program, GLsizei uniformCount, const GLchar* const * uniformNames, GLuint* uniformIndices);
typedef void (__stdcall * PFNGLUNIFORMBLOCKBINDINGPROC) (GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);














#line 7761 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 7772 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






typedef void (__stdcall * PFNGLBINDVERTEXARRAYPROC) (GLuint array);
typedef void (__stdcall * PFNGLDELETEVERTEXARRAYSPROC) (GLsizei n, const GLuint* arrays);
typedef void (__stdcall * PFNGLGENVERTEXARRAYSPROC) (GLsizei n, GLuint* arrays);
typedef GLboolean (__stdcall * PFNGLISVERTEXARRAYPROC) (GLuint array);








#line 7793 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLGETVERTEXATTRIBLDVPROC) (GLuint index, GLenum pname, GLdouble* params);
typedef void (__stdcall * PFNGLVERTEXATTRIBL1DPROC) (GLuint index, GLdouble x);
typedef void (__stdcall * PFNGLVERTEXATTRIBL1DVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL2DPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void (__stdcall * PFNGLVERTEXATTRIBL2DVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL3DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLVERTEXATTRIBL3DVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL4DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLVERTEXATTRIBL4DVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBLPOINTERPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const void* pointer);














#line 7824 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 













typedef void (__stdcall * PFNGLBINDVERTEXBUFFERPROC) (GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
typedef void (__stdcall * PFNGLVERTEXARRAYBINDVERTEXBUFFEREXTPROC) (GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
typedef void (__stdcall * PFNGLVERTEXARRAYVERTEXATTRIBBINDINGEXTPROC) (GLuint vaobj, GLuint attribindex, GLuint bindingindex);
typedef void (__stdcall * PFNGLVERTEXARRAYVERTEXATTRIBFORMATEXTPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
typedef void (__stdcall * PFNGLVERTEXARRAYVERTEXATTRIBIFORMATEXTPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void (__stdcall * PFNGLVERTEXARRAYVERTEXATTRIBLFORMATEXTPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void (__stdcall * PFNGLVERTEXARRAYVERTEXBINDINGDIVISOREXTPROC) (GLuint vaobj, GLuint bindingindex, GLuint divisor);
typedef void (__stdcall * PFNGLVERTEXATTRIBBINDINGPROC) (GLuint attribindex, GLuint bindingindex);
typedef void (__stdcall * PFNGLVERTEXATTRIBFORMATPROC) (GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
typedef void (__stdcall * PFNGLVERTEXATTRIBIFORMATPROC) (GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void (__stdcall * PFNGLVERTEXATTRIBLFORMATPROC) (GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void (__stdcall * PFNGLVERTEXBINDINGDIVISORPROC) (GLuint bindingindex, GLuint divisor);
















#line 7868 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 















































typedef void (__stdcall * PFNGLVERTEXBLENDARBPROC) (GLint count);
typedef void (__stdcall * PFNGLWEIGHTPOINTERARBPROC) (GLint size, GLenum type, GLsizei stride, void *pointer);
typedef void (__stdcall * PFNGLWEIGHTBVARBPROC) (GLint size, GLbyte *weights);
typedef void (__stdcall * PFNGLWEIGHTDVARBPROC) (GLint size, GLdouble *weights);
typedef void (__stdcall * PFNGLWEIGHTFVARBPROC) (GLint size, GLfloat *weights);
typedef void (__stdcall * PFNGLWEIGHTIVARBPROC) (GLint size, GLint *weights);
typedef void (__stdcall * PFNGLWEIGHTSVARBPROC) (GLint size, GLshort *weights);
typedef void (__stdcall * PFNGLWEIGHTUBVARBPROC) (GLint size, GLubyte *weights);
typedef void (__stdcall * PFNGLWEIGHTUIVARBPROC) (GLint size, GLuint *weights);
typedef void (__stdcall * PFNGLWEIGHTUSVARBPROC) (GLint size, GLushort *weights);














#line 7942 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




































typedef ptrdiff_t GLintptrARB;
typedef ptrdiff_t GLsizeiptrARB;

typedef void (__stdcall * PFNGLBINDBUFFERARBPROC) (GLenum target, GLuint buffer);
typedef void (__stdcall * PFNGLBUFFERDATAARBPROC) (GLenum target, GLsizeiptrARB size, const void *data, GLenum usage);
typedef void (__stdcall * PFNGLBUFFERSUBDATAARBPROC) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, const void *data);
typedef void (__stdcall * PFNGLDELETEBUFFERSARBPROC) (GLsizei n, const GLuint* buffers);
typedef void (__stdcall * PFNGLGENBUFFERSARBPROC) (GLsizei n, GLuint* buffers);
typedef void (__stdcall * PFNGLGETBUFFERPARAMETERIVARBPROC) (GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETBUFFERPOINTERVARBPROC) (GLenum target, GLenum pname, void** params);
typedef void (__stdcall * PFNGLGETBUFFERSUBDATAARBPROC) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, void *data);
typedef GLboolean (__stdcall * PFNGLISBUFFERARBPROC) (GLuint buffer);
typedef void * (__stdcall * PFNGLMAPBUFFERARBPROC) (GLenum target, GLenum access);
typedef GLboolean (__stdcall * PFNGLUNMAPBUFFERARBPROC) (GLenum target);















#line 8010 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




















































































typedef void (__stdcall * PFNGLBINDPROGRAMARBPROC) (GLenum target, GLuint program);
typedef void (__stdcall * PFNGLDELETEPROGRAMSARBPROC) (GLsizei n, const GLuint* programs);
typedef void (__stdcall * PFNGLDISABLEVERTEXATTRIBARRAYARBPROC) (GLuint index);
typedef void (__stdcall * PFNGLENABLEVERTEXATTRIBARRAYARBPROC) (GLuint index);
typedef void (__stdcall * PFNGLGENPROGRAMSARBPROC) (GLsizei n, GLuint* programs);
typedef void (__stdcall * PFNGLGETPROGRAMENVPARAMETERDVARBPROC) (GLenum target, GLuint index, GLdouble* params);
typedef void (__stdcall * PFNGLGETPROGRAMENVPARAMETERFVARBPROC) (GLenum target, GLuint index, GLfloat* params);
typedef void (__stdcall * PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC) (GLenum target, GLuint index, GLdouble* params);
typedef void (__stdcall * PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC) (GLenum target, GLuint index, GLfloat* params);
typedef void (__stdcall * PFNGLGETPROGRAMSTRINGARBPROC) (GLenum target, GLenum pname, void *string);
typedef void (__stdcall * PFNGLGETPROGRAMIVARBPROC) (GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBPOINTERVARBPROC) (GLuint index, GLenum pname, void** pointer);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBDVARBPROC) (GLuint index, GLenum pname, GLdouble* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBFVARBPROC) (GLuint index, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBIVARBPROC) (GLuint index, GLenum pname, GLint* params);
typedef GLboolean (__stdcall * PFNGLISPROGRAMARBPROC) (GLuint program);
typedef void (__stdcall * PFNGLPROGRAMENVPARAMETER4DARBPROC) (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLPROGRAMENVPARAMETER4DVARBPROC) (GLenum target, GLuint index, const GLdouble* params);
typedef void (__stdcall * PFNGLPROGRAMENVPARAMETER4FARBPROC) (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLPROGRAMENVPARAMETER4FVARBPROC) (GLenum target, GLuint index, const GLfloat* params);
typedef void (__stdcall * PFNGLPROGRAMLOCALPARAMETER4DARBPROC) (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLPROGRAMLOCALPARAMETER4DVARBPROC) (GLenum target, GLuint index, const GLdouble* params);
typedef void (__stdcall * PFNGLPROGRAMLOCALPARAMETER4FARBPROC) (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLPROGRAMLOCALPARAMETER4FVARBPROC) (GLenum target, GLuint index, const GLfloat* params);
typedef void (__stdcall * PFNGLPROGRAMSTRINGARBPROC) (GLenum target, GLenum format, GLsizei len, const void *string);
typedef void (__stdcall * PFNGLVERTEXATTRIB1DARBPROC) (GLuint index, GLdouble x);
typedef void (__stdcall * PFNGLVERTEXATTRIB1DVARBPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB1FARBPROC) (GLuint index, GLfloat x);
typedef void (__stdcall * PFNGLVERTEXATTRIB1FVARBPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB1SARBPROC) (GLuint index, GLshort x);
typedef void (__stdcall * PFNGLVERTEXATTRIB1SVARBPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB2DARBPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void (__stdcall * PFNGLVERTEXATTRIB2DVARBPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB2FARBPROC) (GLuint index, GLfloat x, GLfloat y);
typedef void (__stdcall * PFNGLVERTEXATTRIB2FVARBPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB2SARBPROC) (GLuint index, GLshort x, GLshort y);
typedef void (__stdcall * PFNGLVERTEXATTRIB2SVARBPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB3DARBPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLVERTEXATTRIB3DVARBPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB3FARBPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLVERTEXATTRIB3FVARBPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB3SARBPROC) (GLuint index, GLshort x, GLshort y, GLshort z);
typedef void (__stdcall * PFNGLVERTEXATTRIB3SVARBPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NBVARBPROC) (GLuint index, const GLbyte* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NIVARBPROC) (GLuint index, const GLint* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NSVARBPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NUBARBPROC) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NUBVARBPROC) (GLuint index, const GLubyte* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NUIVARBPROC) (GLuint index, const GLuint* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NUSVARBPROC) (GLuint index, const GLushort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4BVARBPROC) (GLuint index, const GLbyte* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4DARBPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4DVARBPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4FARBPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4FVARBPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4IVARBPROC) (GLuint index, const GLint* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4SARBPROC) (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4SVARBPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4UBVARBPROC) (GLuint index, const GLubyte* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4UIVARBPROC) (GLuint index, const GLuint* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4USVARBPROC) (GLuint index, const GLushort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBPOINTERARBPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *pointer);


































































#line 8225 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 












typedef void (__stdcall * PFNGLBINDATTRIBLOCATIONARBPROC) (GLhandleARB programObj, GLuint index, const GLcharARB* name);
typedef void (__stdcall * PFNGLGETACTIVEATTRIBARBPROC) (GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei* length, GLint *size, GLenum *type, GLcharARB *name);
typedef GLint (__stdcall * PFNGLGETATTRIBLOCATIONARBPROC) (GLhandleARB programObj, const GLcharARB* name);







#line 8250 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 8261 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 







typedef void (__stdcall * PFNGLCOLORP3UIPROC) (GLenum type, GLuint color);
typedef void (__stdcall * PFNGLCOLORP3UIVPROC) (GLenum type, const GLuint* color);
typedef void (__stdcall * PFNGLCOLORP4UIPROC) (GLenum type, GLuint color);
typedef void (__stdcall * PFNGLCOLORP4UIVPROC) (GLenum type, const GLuint* color);
typedef void (__stdcall * PFNGLMULTITEXCOORDP1UIPROC) (GLenum texture, GLenum type, GLuint coords);
typedef void (__stdcall * PFNGLMULTITEXCOORDP1UIVPROC) (GLenum texture, GLenum type, const GLuint* coords);
typedef void (__stdcall * PFNGLMULTITEXCOORDP2UIPROC) (GLenum texture, GLenum type, GLuint coords);
typedef void (__stdcall * PFNGLMULTITEXCOORDP2UIVPROC) (GLenum texture, GLenum type, const GLuint* coords);
typedef void (__stdcall * PFNGLMULTITEXCOORDP3UIPROC) (GLenum texture, GLenum type, GLuint coords);
typedef void (__stdcall * PFNGLMULTITEXCOORDP3UIVPROC) (GLenum texture, GLenum type, const GLuint* coords);
typedef void (__stdcall * PFNGLMULTITEXCOORDP4UIPROC) (GLenum texture, GLenum type, GLuint coords);
typedef void (__stdcall * PFNGLMULTITEXCOORDP4UIVPROC) (GLenum texture, GLenum type, const GLuint* coords);
typedef void (__stdcall * PFNGLNORMALP3UIPROC) (GLenum type, GLuint coords);
typedef void (__stdcall * PFNGLNORMALP3UIVPROC) (GLenum type, const GLuint* coords);
typedef void (__stdcall * PFNGLSECONDARYCOLORP3UIPROC) (GLenum type, GLuint color);
typedef void (__stdcall * PFNGLSECONDARYCOLORP3UIVPROC) (GLenum type, const GLuint* color);
typedef void (__stdcall * PFNGLTEXCOORDP1UIPROC) (GLenum type, GLuint coords);
typedef void (__stdcall * PFNGLTEXCOORDP1UIVPROC) (GLenum type, const GLuint* coords);
typedef void (__stdcall * PFNGLTEXCOORDP2UIPROC) (GLenum type, GLuint coords);
typedef void (__stdcall * PFNGLTEXCOORDP2UIVPROC) (GLenum type, const GLuint* coords);
typedef void (__stdcall * PFNGLTEXCOORDP3UIPROC) (GLenum type, GLuint coords);
typedef void (__stdcall * PFNGLTEXCOORDP3UIVPROC) (GLenum type, const GLuint* coords);
typedef void (__stdcall * PFNGLTEXCOORDP4UIPROC) (GLenum type, GLuint coords);
typedef void (__stdcall * PFNGLTEXCOORDP4UIVPROC) (GLenum type, const GLuint* coords);
typedef void (__stdcall * PFNGLVERTEXATTRIBP1UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void (__stdcall * PFNGLVERTEXATTRIBP1UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
typedef void (__stdcall * PFNGLVERTEXATTRIBP2UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void (__stdcall * PFNGLVERTEXATTRIBP2UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
typedef void (__stdcall * PFNGLVERTEXATTRIBP3UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void (__stdcall * PFNGLVERTEXATTRIBP3UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
typedef void (__stdcall * PFNGLVERTEXATTRIBP4UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void (__stdcall * PFNGLVERTEXATTRIBP4UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
typedef void (__stdcall * PFNGLVERTEXP2UIPROC) (GLenum type, GLuint value);
typedef void (__stdcall * PFNGLVERTEXP2UIVPROC) (GLenum type, const GLuint* value);
typedef void (__stdcall * PFNGLVERTEXP3UIPROC) (GLenum type, GLuint value);
typedef void (__stdcall * PFNGLVERTEXP3UIVPROC) (GLenum type, const GLuint* value);
typedef void (__stdcall * PFNGLVERTEXP4UIPROC) (GLenum type, GLuint value);
typedef void (__stdcall * PFNGLVERTEXP4UIVPROC) (GLenum type, const GLuint* value);










































#line 8351 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 


















typedef void (__stdcall * PFNGLDEPTHRANGEARRAYVPROC) (GLuint first, GLsizei count, const GLclampd * v);
typedef void (__stdcall * PFNGLDEPTHRANGEINDEXEDPROC) (GLuint index, GLclampd n, GLclampd f);
typedef void (__stdcall * PFNGLGETDOUBLEI_VPROC) (GLenum target, GLuint index, GLdouble* data);
typedef void (__stdcall * PFNGLGETFLOATI_VPROC) (GLenum target, GLuint index, GLfloat* data);
typedef void (__stdcall * PFNGLSCISSORARRAYVPROC) (GLuint first, GLsizei count, const GLint * v);
typedef void (__stdcall * PFNGLSCISSORINDEXEDPROC) (GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLSCISSORINDEXEDVPROC) (GLuint index, const GLint * v);
typedef void (__stdcall * PFNGLVIEWPORTARRAYVPROC) (GLuint first, GLsizei count, const GLfloat * v);
typedef void (__stdcall * PFNGLVIEWPORTINDEXEDFPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h);
typedef void (__stdcall * PFNGLVIEWPORTINDEXEDFVPROC) (GLuint index, const GLfloat * v);














#line 8396 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLWINDOWPOS2DARBPROC) (GLdouble x, GLdouble y);
typedef void (__stdcall * PFNGLWINDOWPOS2DVARBPROC) (const GLdouble* p);
typedef void (__stdcall * PFNGLWINDOWPOS2FARBPROC) (GLfloat x, GLfloat y);
typedef void (__stdcall * PFNGLWINDOWPOS2FVARBPROC) (const GLfloat* p);
typedef void (__stdcall * PFNGLWINDOWPOS2IARBPROC) (GLint x, GLint y);
typedef void (__stdcall * PFNGLWINDOWPOS2IVARBPROC) (const GLint* p);
typedef void (__stdcall * PFNGLWINDOWPOS2SARBPROC) (GLshort x, GLshort y);
typedef void (__stdcall * PFNGLWINDOWPOS2SVARBPROC) (const GLshort* p);
typedef void (__stdcall * PFNGLWINDOWPOS3DARBPROC) (GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLWINDOWPOS3DVARBPROC) (const GLdouble* p);
typedef void (__stdcall * PFNGLWINDOWPOS3FARBPROC) (GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLWINDOWPOS3FVARBPROC) (const GLfloat* p);
typedef void (__stdcall * PFNGLWINDOWPOS3IARBPROC) (GLint x, GLint y, GLint z);
typedef void (__stdcall * PFNGLWINDOWPOS3IVARBPROC) (const GLint* p);
typedef void (__stdcall * PFNGLWINDOWPOS3SARBPROC) (GLshort x, GLshort y, GLshort z);
typedef void (__stdcall * PFNGLWINDOWPOS3SVARBPROC) (const GLshort* p);




















#line 8439 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 8450 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 8461 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 8472 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 8484 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 8493 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 













#line 8509 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 










#line 8522 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 










#line 8535 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 8546 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






















typedef void (__stdcall * PFNGLDRAWBUFFERSATIPROC) (GLsizei n, const GLenum* bufs);





#line 8577 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








typedef void (__stdcall * PFNGLDRAWELEMENTARRAYATIPROC) (GLenum mode, GLsizei count);
typedef void (__stdcall * PFNGLDRAWRANGEELEMENTARRAYATIPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count);
typedef void (__stdcall * PFNGLELEMENTPOINTERATIPROC) (GLenum type, const void *pointer);







#line 8598 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 













typedef void (__stdcall * PFNGLGETTEXBUMPPARAMETERFVATIPROC) (GLenum pname, GLfloat *param);
typedef void (__stdcall * PFNGLGETTEXBUMPPARAMETERIVATIPROC) (GLenum pname, GLint *param);
typedef void (__stdcall * PFNGLTEXBUMPPARAMETERFVATIPROC) (GLenum pname, GLfloat *param);
typedef void (__stdcall * PFNGLTEXBUMPPARAMETERIVATIPROC) (GLenum pname, GLint *param);








#line 8626 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 



























































typedef void (__stdcall * PFNGLALPHAFRAGMENTOP1ATIPROC) (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod);
typedef void (__stdcall * PFNGLALPHAFRAGMENTOP2ATIPROC) (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);
typedef void (__stdcall * PFNGLALPHAFRAGMENTOP3ATIPROC) (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod);
typedef void (__stdcall * PFNGLBEGINFRAGMENTSHADERATIPROC) (void);
typedef void (__stdcall * PFNGLBINDFRAGMENTSHADERATIPROC) (GLuint id);
typedef void (__stdcall * PFNGLCOLORFRAGMENTOP1ATIPROC) (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod);
typedef void (__stdcall * PFNGLCOLORFRAGMENTOP2ATIPROC) (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);
typedef void (__stdcall * PFNGLCOLORFRAGMENTOP3ATIPROC) (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod);
typedef void (__stdcall * PFNGLDELETEFRAGMENTSHADERATIPROC) (GLuint id);
typedef void (__stdcall * PFNGLENDFRAGMENTSHADERATIPROC) (void);
typedef GLuint (__stdcall * PFNGLGENFRAGMENTSHADERSATIPROC) (GLuint range);
typedef void (__stdcall * PFNGLPASSTEXCOORDATIPROC) (GLuint dst, GLuint coord, GLenum swizzle);
typedef void (__stdcall * PFNGLSAMPLEMAPATIPROC) (GLuint dst, GLuint interp, GLenum swizzle);
typedef void (__stdcall * PFNGLSETFRAGMENTSHADERCONSTANTATIPROC) (GLuint dst, const GLfloat* value);


















#line 8720 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void * (__stdcall * PFNGLMAPOBJECTBUFFERATIPROC) (GLuint buffer);
typedef void (__stdcall * PFNGLUNMAPOBJECTBUFFERATIPROC) (GLuint buffer);






#line 8735 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 










#line 8748 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 














typedef void (__stdcall * PFNGLPNTRIANGLESFATIPROC) (GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLPNTRIANGLESIATIPROC) (GLenum pname, GLint param);






#line 8773 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









typedef void (__stdcall * PFNGLSTENCILFUNCSEPARATEATIPROC) (GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask);
typedef void (__stdcall * PFNGLSTENCILOPSEPARATEATIPROC) (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);






#line 8793 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 8802 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 8813 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 8824 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 










#line 8837 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 



















#line 8859 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 8871 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 













typedef void (__stdcall * PFNGLARRAYOBJECTATIPROC) (GLenum array, GLint size, GLenum type, GLsizei stride, GLuint buffer, GLuint offset);
typedef void (__stdcall * PFNGLFREEOBJECTBUFFERATIPROC) (GLuint buffer);
typedef void (__stdcall * PFNGLGETARRAYOBJECTFVATIPROC) (GLenum array, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETARRAYOBJECTIVATIPROC) (GLenum array, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETOBJECTBUFFERFVATIPROC) (GLuint buffer, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETOBJECTBUFFERIVATIPROC) (GLuint buffer, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETVARIANTARRAYOBJECTFVATIPROC) (GLuint id, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETVARIANTARRAYOBJECTIVATIPROC) (GLuint id, GLenum pname, GLint* params);
typedef GLboolean (__stdcall * PFNGLISOBJECTBUFFERATIPROC) (GLuint buffer);
typedef GLuint (__stdcall * PFNGLNEWOBJECTBUFFERATIPROC) (GLsizei size, const void *pointer, GLenum usage);
typedef void (__stdcall * PFNGLUPDATEOBJECTBUFFERATIPROC) (GLuint buffer, GLuint offset, GLsizei size, const void *pointer, GLenum preserve);
typedef void (__stdcall * PFNGLVARIANTARRAYOBJECTATIPROC) (GLuint id, GLenum type, GLsizei stride, GLuint buffer, GLuint offset);
















#line 8915 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLGETVERTEXATTRIBARRAYOBJECTFVATIPROC) (GLuint index, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBARRAYOBJECTIVATIPROC) (GLuint index, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLVERTEXATTRIBARRAYOBJECTATIPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint buffer, GLuint offset);







#line 8932 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 















typedef void (__stdcall * PFNGLCLIENTACTIVEVERTEXSTREAMATIPROC) (GLenum stream);
typedef void (__stdcall * PFNGLNORMALSTREAM3BATIPROC) (GLenum stream, GLbyte x, GLbyte y, GLbyte z);
typedef void (__stdcall * PFNGLNORMALSTREAM3BVATIPROC) (GLenum stream, const GLbyte *coords);
typedef void (__stdcall * PFNGLNORMALSTREAM3DATIPROC) (GLenum stream, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLNORMALSTREAM3DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void (__stdcall * PFNGLNORMALSTREAM3FATIPROC) (GLenum stream, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLNORMALSTREAM3FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void (__stdcall * PFNGLNORMALSTREAM3IATIPROC) (GLenum stream, GLint x, GLint y, GLint z);
typedef void (__stdcall * PFNGLNORMALSTREAM3IVATIPROC) (GLenum stream, const GLint *coords);
typedef void (__stdcall * PFNGLNORMALSTREAM3SATIPROC) (GLenum stream, GLshort x, GLshort y, GLshort z);
typedef void (__stdcall * PFNGLNORMALSTREAM3SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void (__stdcall * PFNGLVERTEXBLENDENVFATIPROC) (GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLVERTEXBLENDENVIATIPROC) (GLenum pname, GLint param);
typedef void (__stdcall * PFNGLVERTEXSTREAM1DATIPROC) (GLenum stream, GLdouble x);
typedef void (__stdcall * PFNGLVERTEXSTREAM1DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM1FATIPROC) (GLenum stream, GLfloat x);
typedef void (__stdcall * PFNGLVERTEXSTREAM1FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM1IATIPROC) (GLenum stream, GLint x);
typedef void (__stdcall * PFNGLVERTEXSTREAM1IVATIPROC) (GLenum stream, const GLint *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM1SATIPROC) (GLenum stream, GLshort x);
typedef void (__stdcall * PFNGLVERTEXSTREAM1SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM2DATIPROC) (GLenum stream, GLdouble x, GLdouble y);
typedef void (__stdcall * PFNGLVERTEXSTREAM2DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM2FATIPROC) (GLenum stream, GLfloat x, GLfloat y);
typedef void (__stdcall * PFNGLVERTEXSTREAM2FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM2IATIPROC) (GLenum stream, GLint x, GLint y);
typedef void (__stdcall * PFNGLVERTEXSTREAM2IVATIPROC) (GLenum stream, const GLint *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM2SATIPROC) (GLenum stream, GLshort x, GLshort y);
typedef void (__stdcall * PFNGLVERTEXSTREAM2SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM3DATIPROC) (GLenum stream, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLVERTEXSTREAM3DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM3FATIPROC) (GLenum stream, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLVERTEXSTREAM3FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM3IATIPROC) (GLenum stream, GLint x, GLint y, GLint z);
typedef void (__stdcall * PFNGLVERTEXSTREAM3IVATIPROC) (GLenum stream, const GLint *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM3SATIPROC) (GLenum stream, GLshort x, GLshort y, GLshort z);
typedef void (__stdcall * PFNGLVERTEXSTREAM3SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM4DATIPROC) (GLenum stream, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLVERTEXSTREAM4DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM4FATIPROC) (GLenum stream, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLVERTEXSTREAM4FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM4IATIPROC) (GLenum stream, GLint x, GLint y, GLint z, GLint w);
typedef void (__stdcall * PFNGLVERTEXSTREAM4IVATIPROC) (GLenum stream, const GLint *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM4SATIPROC) (GLenum stream, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void (__stdcall * PFNGLVERTEXSTREAM4SVATIPROC) (GLenum stream, const GLshort *coords);

















































#line 9044 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 9053 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 9065 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











#line 9079 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 9091 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 9100 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 9111 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 9122 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEEXTPROC) (GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance);
typedef void (__stdcall * PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEEXTPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLuint baseinstance);
typedef void (__stdcall * PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEEXTPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance);







#line 9139 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 9151 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











typedef GLint (__stdcall * PFNGLGETUNIFORMBUFFERSIZEEXTPROC) (GLuint program, GLint location);
typedef GLintptr (__stdcall * PFNGLGETUNIFORMOFFSETEXTPROC) (GLuint program, GLint location);
typedef void (__stdcall * PFNGLUNIFORMBUFFEREXTPROC) (GLuint program, GLint location, GLuint buffer);







#line 9175 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 










typedef void (__stdcall * PFNGLBLENDCOLOREXTPROC) (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);





#line 9194 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 







typedef void (__stdcall * PFNGLBLENDEQUATIONSEPARATEEXTPROC) (GLenum modeRGB, GLenum modeAlpha);





#line 9210 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 












typedef void (__stdcall * PFNGLBINDFRAGDATALOCATIONINDEXEDEXTPROC) (GLuint program, GLuint colorNumber, GLuint index, const GLchar * name);
typedef GLint (__stdcall * PFNGLGETFRAGDATAINDEXEXTPROC) (GLuint program, const GLchar * name);
typedef GLint (__stdcall * PFNGLGETPROGRAMRESOURCELOCATIONINDEXEXTPROC) (GLuint program, GLenum programInterface, const GLchar* name);







#line 9235 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









typedef void (__stdcall * PFNGLBLENDFUNCSEPARATEEXTPROC) (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);





#line 9253 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 9262 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









typedef void (__stdcall * PFNGLBLENDEQUATIONEXTPROC) (GLenum mode);





#line 9280 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 9292 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 














typedef void (__stdcall * PFNGLBUFFERSTORAGEEXTPROC) (GLenum target, GLsizeiptr size, const void *data, GLbitfield flags);
typedef void (__stdcall * PFNGLNAMEDBUFFERSTORAGEEXTPROC) (GLuint buffer, GLsizeiptr size, const void *data, GLbitfield flags);






#line 9317 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLCLEARTEXIMAGEEXTPROC) (GLuint texture, GLint level, GLenum format, GLenum type, const void *data);
typedef void (__stdcall * PFNGLCLEARTEXSUBIMAGEEXTPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data);






#line 9332 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 


















#line 9353 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 9364 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











#line 9378 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 9387 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 













#line 9403 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLCOLORSUBTABLEEXTPROC) (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void *data);
typedef void (__stdcall * PFNGLCOPYCOLORSUBTABLEEXTPROC) (GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);






#line 9418 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 







typedef void (__stdcall * PFNGLLOCKARRAYSEXTPROC) (GLint first, GLsizei count);
typedef void (__stdcall * PFNGLUNLOCKARRAYSEXTPROC) (void);






#line 9436 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 9445 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 9454 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 

























typedef void (__stdcall * PFNGLCONVOLUTIONFILTER1DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *image);
typedef void (__stdcall * PFNGLCONVOLUTIONFILTER2DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *image);
typedef void (__stdcall * PFNGLCONVOLUTIONPARAMETERFEXTPROC) (GLenum target, GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLCONVOLUTIONPARAMETERFVEXTPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLCONVOLUTIONPARAMETERIEXTPROC) (GLenum target, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLCONVOLUTIONPARAMETERIVEXTPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLCOPYCONVOLUTIONFILTER1DEXTPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void (__stdcall * PFNGLCOPYCONVOLUTIONFILTER2DEXTPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLGETCONVOLUTIONFILTEREXTPROC) (GLenum target, GLenum format, GLenum type, void *image);
typedef void (__stdcall * PFNGLGETCONVOLUTIONPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETCONVOLUTIONPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETSEPARABLEFILTEREXTPROC) (GLenum target, GLenum format, GLenum type, void *row, void *column, void *span);
typedef void (__stdcall * PFNGLSEPARABLEFILTER2DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *row, const void *column);

















#line 9512 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 



















typedef void (__stdcall * PFNGLBINORMALPOINTEREXTPROC) (GLenum type, GLsizei stride, void *pointer);
typedef void (__stdcall * PFNGLTANGENTPOINTEREXTPROC) (GLenum type, GLsizei stride, void *pointer);






#line 9542 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLCOPYIMAGESUBDATAEXTPROC) (GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);





#line 9555 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLCOPYTEXIMAGE1DEXTPROC) (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
typedef void (__stdcall * PFNGLCOPYTEXIMAGE2DEXTPROC) (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
typedef void (__stdcall * PFNGLCOPYTEXSUBIMAGE1DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void (__stdcall * PFNGLCOPYTEXSUBIMAGE2DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLCOPYTEXSUBIMAGE3DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);









#line 9576 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








typedef void (__stdcall * PFNGLCULLPARAMETERDVEXTPROC) (GLenum pname, GLdouble* params);
typedef void (__stdcall * PFNGLCULLPARAMETERFVEXTPROC) (GLenum pname, GLfloat* params);






#line 9595 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











typedef void (__stdcall * PFNGLGETOBJECTLABELEXTPROC) (GLenum type, GLuint object, GLsizei bufSize, GLsizei* length, GLchar *label);
typedef void (__stdcall * PFNGLLABELOBJECTEXTPROC) (GLenum type, GLuint object, GLsizei length, const GLchar* label);






#line 9617 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLINSERTEVENTMARKEREXTPROC) (GLsizei length, const GLchar* marker);
typedef void (__stdcall * PFNGLPOPGROUPMARKEREXTPROC) (void);
typedef void (__stdcall * PFNGLPUSHGROUPMARKEREXTPROC) (GLsizei length, const GLchar* marker);







#line 9634 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 







typedef void (__stdcall * PFNGLDEPTHBOUNDSEXTPROC) (GLclampd zmin, GLclampd zmax);





#line 9650 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








typedef void (__stdcall * PFNGLBINDMULTITEXTUREEXTPROC) (GLenum texunit, GLenum target, GLuint texture);
typedef GLenum (__stdcall * PFNGLCHECKNAMEDFRAMEBUFFERSTATUSEXTPROC) (GLuint framebuffer, GLenum target);
typedef void (__stdcall * PFNGLCLIENTATTRIBDEFAULTEXTPROC) (GLbitfield mask);
typedef void (__stdcall * PFNGLCOMPRESSEDMULTITEXIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDMULTITEXIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDMULTITEXIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDMULTITEXSUBIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDMULTITEXSUBIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDMULTITEXSUBIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXTUREIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXTUREIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXTUREIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXTURESUBIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXTURESUBIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXTURESUBIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOPYMULTITEXIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
typedef void (__stdcall * PFNGLCOPYMULTITEXIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
typedef void (__stdcall * PFNGLCOPYMULTITEXSUBIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void (__stdcall * PFNGLCOPYMULTITEXSUBIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLCOPYMULTITEXSUBIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLCOPYTEXTUREIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
typedef void (__stdcall * PFNGLCOPYTEXTUREIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
typedef void (__stdcall * PFNGLCOPYTEXTURESUBIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void (__stdcall * PFNGLCOPYTEXTURESUBIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLCOPYTEXTURESUBIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLDISABLECLIENTSTATEINDEXEDEXTPROC) (GLenum array, GLuint index);
typedef void (__stdcall * PFNGLDISABLECLIENTSTATEIEXTPROC) (GLenum array, GLuint index);
typedef void (__stdcall * PFNGLDISABLEVERTEXARRAYATTRIBEXTPROC) (GLuint vaobj, GLuint index);
typedef void (__stdcall * PFNGLDISABLEVERTEXARRAYEXTPROC) (GLuint vaobj, GLenum array);
typedef void (__stdcall * PFNGLENABLECLIENTSTATEINDEXEDEXTPROC) (GLenum array, GLuint index);
typedef void (__stdcall * PFNGLENABLECLIENTSTATEIEXTPROC) (GLenum array, GLuint index);
typedef void (__stdcall * PFNGLENABLEVERTEXARRAYATTRIBEXTPROC) (GLuint vaobj, GLuint index);
typedef void (__stdcall * PFNGLENABLEVERTEXARRAYEXTPROC) (GLuint vaobj, GLenum array);
typedef void (__stdcall * PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length);
typedef void (__stdcall * PFNGLFRAMEBUFFERDRAWBUFFEREXTPROC) (GLuint framebuffer, GLenum mode);
typedef void (__stdcall * PFNGLFRAMEBUFFERDRAWBUFFERSEXTPROC) (GLuint framebuffer, GLsizei n, const GLenum* bufs);
typedef void (__stdcall * PFNGLFRAMEBUFFERREADBUFFEREXTPROC) (GLuint framebuffer, GLenum mode);
typedef void (__stdcall * PFNGLGENERATEMULTITEXMIPMAPEXTPROC) (GLenum texunit, GLenum target);
typedef void (__stdcall * PFNGLGENERATETEXTUREMIPMAPEXTPROC) (GLuint texture, GLenum target);
typedef void (__stdcall * PFNGLGETCOMPRESSEDMULTITEXIMAGEEXTPROC) (GLenum texunit, GLenum target, GLint level, void *img);
typedef void (__stdcall * PFNGLGETCOMPRESSEDTEXTUREIMAGEEXTPROC) (GLuint texture, GLenum target, GLint level, void *img);
typedef void (__stdcall * PFNGLGETDOUBLEINDEXEDVEXTPROC) (GLenum target, GLuint index, GLdouble* params);
typedef void (__stdcall * PFNGLGETDOUBLEI_VEXTPROC) (GLenum pname, GLuint index, GLdouble* params);
typedef void (__stdcall * PFNGLGETFLOATINDEXEDVEXTPROC) (GLenum target, GLuint index, GLfloat* params);
typedef void (__stdcall * PFNGLGETFLOATI_VEXTPROC) (GLenum pname, GLuint index, GLfloat* params);
typedef void (__stdcall * PFNGLGETFRAMEBUFFERPARAMETERIVEXTPROC) (GLuint framebuffer, GLenum pname, GLint* param);
typedef void (__stdcall * PFNGLGETMULTITEXENVFVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETMULTITEXENVIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETMULTITEXGENDVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLdouble* params);
typedef void (__stdcall * PFNGLGETMULTITEXGENFVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETMULTITEXGENIVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETMULTITEXIMAGEEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, void *pixels);
typedef void (__stdcall * PFNGLGETMULTITEXLEVELPARAMETERFVEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETMULTITEXLEVELPARAMETERIVEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETMULTITEXPARAMETERIIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETMULTITEXPARAMETERIUIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLuint* params);
typedef void (__stdcall * PFNGLGETMULTITEXPARAMETERFVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETMULTITEXPARAMETERIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETNAMEDBUFFERPARAMETERIVEXTPROC) (GLuint buffer, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETNAMEDBUFFERPOINTERVEXTPROC) (GLuint buffer, GLenum pname, void** params);
typedef void (__stdcall * PFNGLGETNAMEDBUFFERSUBDATAEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr size, void *data);
typedef void (__stdcall * PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC) (GLuint framebuffer, GLenum attachment, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETNAMEDPROGRAMLOCALPARAMETERIIVEXTPROC) (GLuint program, GLenum target, GLuint index, GLint* params);
typedef void (__stdcall * PFNGLGETNAMEDPROGRAMLOCALPARAMETERIUIVEXTPROC) (GLuint program, GLenum target, GLuint index, GLuint* params);
typedef void (__stdcall * PFNGLGETNAMEDPROGRAMLOCALPARAMETERDVEXTPROC) (GLuint program, GLenum target, GLuint index, GLdouble* params);
typedef void (__stdcall * PFNGLGETNAMEDPROGRAMLOCALPARAMETERFVEXTPROC) (GLuint program, GLenum target, GLuint index, GLfloat* params);
typedef void (__stdcall * PFNGLGETNAMEDPROGRAMSTRINGEXTPROC) (GLuint program, GLenum target, GLenum pname, void *string);
typedef void (__stdcall * PFNGLGETNAMEDPROGRAMIVEXTPROC) (GLuint program, GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETNAMEDRENDERBUFFERPARAMETERIVEXTPROC) (GLuint renderbuffer, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETPOINTERINDEXEDVEXTPROC) (GLenum target, GLuint index, void** params);
typedef void (__stdcall * PFNGLGETPOINTERI_VEXTPROC) (GLenum pname, GLuint index, void** params);
typedef void (__stdcall * PFNGLGETTEXTUREIMAGEEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, void *pixels);
typedef void (__stdcall * PFNGLGETTEXTURELEVELPARAMETERFVEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETTEXTURELEVELPARAMETERIVEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETTEXTUREPARAMETERIIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETTEXTUREPARAMETERIUIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLuint* params);
typedef void (__stdcall * PFNGLGETTEXTUREPARAMETERFVEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETTEXTUREPARAMETERIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETVERTEXARRAYINTEGERI_VEXTPROC) (GLuint vaobj, GLuint index, GLenum pname, GLint* param);
typedef void (__stdcall * PFNGLGETVERTEXARRAYINTEGERVEXTPROC) (GLuint vaobj, GLenum pname, GLint* param);
typedef void (__stdcall * PFNGLGETVERTEXARRAYPOINTERI_VEXTPROC) (GLuint vaobj, GLuint index, GLenum pname, void** param);
typedef void (__stdcall * PFNGLGETVERTEXARRAYPOINTERVEXTPROC) (GLuint vaobj, GLenum pname, void** param);
typedef void * (__stdcall * PFNGLMAPNAMEDBUFFEREXTPROC) (GLuint buffer, GLenum access);
typedef void * (__stdcall * PFNGLMAPNAMEDBUFFERRANGEEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access);
typedef void (__stdcall * PFNGLMATRIXFRUSTUMEXTPROC) (GLenum matrixMode, GLdouble l, GLdouble r, GLdouble b, GLdouble t, GLdouble n, GLdouble f);
typedef void (__stdcall * PFNGLMATRIXLOADIDENTITYEXTPROC) (GLenum matrixMode);
typedef void (__stdcall * PFNGLMATRIXLOADTRANSPOSEDEXTPROC) (GLenum matrixMode, const GLdouble* m);
typedef void (__stdcall * PFNGLMATRIXLOADTRANSPOSEFEXTPROC) (GLenum matrixMode, const GLfloat* m);
typedef void (__stdcall * PFNGLMATRIXLOADDEXTPROC) (GLenum matrixMode, const GLdouble* m);
typedef void (__stdcall * PFNGLMATRIXLOADFEXTPROC) (GLenum matrixMode, const GLfloat* m);
typedef void (__stdcall * PFNGLMATRIXMULTTRANSPOSEDEXTPROC) (GLenum matrixMode, const GLdouble* m);
typedef void (__stdcall * PFNGLMATRIXMULTTRANSPOSEFEXTPROC) (GLenum matrixMode, const GLfloat* m);
typedef void (__stdcall * PFNGLMATRIXMULTDEXTPROC) (GLenum matrixMode, const GLdouble* m);
typedef void (__stdcall * PFNGLMATRIXMULTFEXTPROC) (GLenum matrixMode, const GLfloat* m);
typedef void (__stdcall * PFNGLMATRIXORTHOEXTPROC) (GLenum matrixMode, GLdouble l, GLdouble r, GLdouble b, GLdouble t, GLdouble n, GLdouble f);
typedef void (__stdcall * PFNGLMATRIXPOPEXTPROC) (GLenum matrixMode);
typedef void (__stdcall * PFNGLMATRIXPUSHEXTPROC) (GLenum matrixMode);
typedef void (__stdcall * PFNGLMATRIXROTATEDEXTPROC) (GLenum matrixMode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLMATRIXROTATEFEXTPROC) (GLenum matrixMode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLMATRIXSCALEDEXTPROC) (GLenum matrixMode, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLMATRIXSCALEFEXTPROC) (GLenum matrixMode, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLMATRIXTRANSLATEDEXTPROC) (GLenum matrixMode, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLMATRIXTRANSLATEFEXTPROC) (GLenum matrixMode, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLMULTITEXBUFFEREXTPROC) (GLenum texunit, GLenum target, GLenum internalformat, GLuint buffer);
typedef void (__stdcall * PFNGLMULTITEXCOORDPOINTEREXTPROC) (GLenum texunit, GLint size, GLenum type, GLsizei stride, const void *pointer);
typedef void (__stdcall * PFNGLMULTITEXENVFEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLMULTITEXENVFVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLMULTITEXENVIEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLMULTITEXENVIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLMULTITEXGENDEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLdouble param);
typedef void (__stdcall * PFNGLMULTITEXGENDVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, const GLdouble* params);
typedef void (__stdcall * PFNGLMULTITEXGENFEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLMULTITEXGENFVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLMULTITEXGENIEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLMULTITEXGENIVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLMULTITEXIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLMULTITEXIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLMULTITEXIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLMULTITEXPARAMETERIIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLMULTITEXPARAMETERIUIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLuint* params);
typedef void (__stdcall * PFNGLMULTITEXPARAMETERFEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLMULTITEXPARAMETERFVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLfloat* param);
typedef void (__stdcall * PFNGLMULTITEXPARAMETERIEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLMULTITEXPARAMETERIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLint* param);
typedef void (__stdcall * PFNGLMULTITEXRENDERBUFFEREXTPROC) (GLenum texunit, GLenum target, GLuint renderbuffer);
typedef void (__stdcall * PFNGLMULTITEXSUBIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLMULTITEXSUBIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLMULTITEXSUBIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLNAMEDBUFFERDATAEXTPROC) (GLuint buffer, GLsizeiptr size, const void *data, GLenum usage);
typedef void (__stdcall * PFNGLNAMEDBUFFERSUBDATAEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data);
typedef void (__stdcall * PFNGLNAMEDCOPYBUFFERSUBDATAEXTPROC) (GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERRENDERBUFFEREXTPROC) (GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERTEXTURE1DEXTPROC) (GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERTEXTURE2DEXTPROC) (GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERTEXTURE3DEXTPROC) (GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERTEXTUREEXTPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERTEXTUREFACEEXTPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLenum face);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERTEXTURELAYEREXTPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void (__stdcall * PFNGLNAMEDPROGRAMLOCALPARAMETER4DEXTPROC) (GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLNAMEDPROGRAMLOCALPARAMETER4DVEXTPROC) (GLuint program, GLenum target, GLuint index, const GLdouble* params);
typedef void (__stdcall * PFNGLNAMEDPROGRAMLOCALPARAMETER4FEXTPROC) (GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLNAMEDPROGRAMLOCALPARAMETER4FVEXTPROC) (GLuint program, GLenum target, GLuint index, const GLfloat* params);
typedef void (__stdcall * PFNGLNAMEDPROGRAMLOCALPARAMETERI4IEXTPROC) (GLuint program, GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void (__stdcall * PFNGLNAMEDPROGRAMLOCALPARAMETERI4IVEXTPROC) (GLuint program, GLenum target, GLuint index, const GLint* params);
typedef void (__stdcall * PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIEXTPROC) (GLuint program, GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void (__stdcall * PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIVEXTPROC) (GLuint program, GLenum target, GLuint index, const GLuint* params);
typedef void (__stdcall * PFNGLNAMEDPROGRAMLOCALPARAMETERS4FVEXTPROC) (GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat* params);
typedef void (__stdcall * PFNGLNAMEDPROGRAMLOCALPARAMETERSI4IVEXTPROC) (GLuint program, GLenum target, GLuint index, GLsizei count, const GLint* params);
typedef void (__stdcall * PFNGLNAMEDPROGRAMLOCALPARAMETERSI4UIVEXTPROC) (GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint* params);
typedef void (__stdcall * PFNGLNAMEDPROGRAMSTRINGEXTPROC) (GLuint program, GLenum target, GLenum format, GLsizei len, const void *string);
typedef void (__stdcall * PFNGLNAMEDRENDERBUFFERSTORAGEEXTPROC) (GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLECOVERAGEEXTPROC) (GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC) (GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1FEXTPROC) (GLuint program, GLint location, GLfloat v0);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1FVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1IEXTPROC) (GLuint program, GLint location, GLint v0);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1IVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1UIEXTPROC) (GLuint program, GLint location, GLuint v0);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1UIVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2FEXTPROC) (GLuint program, GLint location, GLfloat v0, GLfloat v1);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2FVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2IEXTPROC) (GLuint program, GLint location, GLint v0, GLint v1);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2IVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2UIEXTPROC) (GLuint program, GLint location, GLuint v0, GLuint v1);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2UIVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3FEXTPROC) (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3FVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3IEXTPROC) (GLuint program, GLint location, GLint v0, GLint v1, GLint v2);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3IVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3UIEXTPROC) (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3UIVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4FEXTPROC) (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4FVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4IEXTPROC) (GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4IVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4UIEXTPROC) (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4UIVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX2FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX2X3FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX2X4FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX3FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX3X2FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX3X4FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX4FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX4X2FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX4X3FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPUSHCLIENTATTRIBDEFAULTEXTPROC) (GLbitfield mask);
typedef void (__stdcall * PFNGLTEXTUREBUFFEREXTPROC) (GLuint texture, GLenum target, GLenum internalformat, GLuint buffer);
typedef void (__stdcall * PFNGLTEXTUREIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLTEXTUREIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLTEXTUREIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLTEXTUREPARAMETERIIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLTEXTUREPARAMETERIUIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, const GLuint* params);
typedef void (__stdcall * PFNGLTEXTUREPARAMETERFEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLTEXTUREPARAMETERFVEXTPROC) (GLuint texture, GLenum target, GLenum pname, const GLfloat* param);
typedef void (__stdcall * PFNGLTEXTUREPARAMETERIEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLTEXTUREPARAMETERIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, const GLint* param);
typedef void (__stdcall * PFNGLTEXTURERENDERBUFFEREXTPROC) (GLuint texture, GLenum target, GLuint renderbuffer);
typedef void (__stdcall * PFNGLTEXTURESUBIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLTEXTURESUBIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLTEXTURESUBIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
typedef GLboolean (__stdcall * PFNGLUNMAPNAMEDBUFFEREXTPROC) (GLuint buffer);
typedef void (__stdcall * PFNGLVERTEXARRAYCOLOROFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void (__stdcall * PFNGLVERTEXARRAYEDGEFLAGOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLsizei stride, GLintptr offset);
typedef void (__stdcall * PFNGLVERTEXARRAYFOGCOORDOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
typedef void (__stdcall * PFNGLVERTEXARRAYINDEXOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
typedef void (__stdcall * PFNGLVERTEXARRAYMULTITEXCOORDOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLenum texunit, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void (__stdcall * PFNGLVERTEXARRAYNORMALOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
typedef void (__stdcall * PFNGLVERTEXARRAYSECONDARYCOLOROFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void (__stdcall * PFNGLVERTEXARRAYTEXCOORDOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void (__stdcall * PFNGLVERTEXARRAYVERTEXATTRIBDIVISOREXTPROC) (GLuint vaobj, GLuint index, GLuint divisor);
typedef void (__stdcall * PFNGLVERTEXARRAYVERTEXATTRIBIOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void (__stdcall * PFNGLVERTEXARRAYVERTEXATTRIBOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLintptr offset);
typedef void (__stdcall * PFNGLVERTEXARRAYVERTEXOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);


























































































































































































































#line 10093 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








typedef void (__stdcall * PFNGLDISCARDFRAMEBUFFEREXTPROC) (GLenum target, GLsizei numAttachments, const GLenum* attachments);





#line 10110 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 







































typedef void (__stdcall * PFNGLDRAWBUFFERSEXTPROC) (GLsizei n, const GLenum* bufs);





#line 10158 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLCOLORMASKINDEXEDEXTPROC) (GLuint buf, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
typedef void (__stdcall * PFNGLDISABLEINDEXEDEXTPROC) (GLenum target, GLuint index);
typedef void (__stdcall * PFNGLENABLEINDEXEDEXTPROC) (GLenum target, GLuint index);
typedef void (__stdcall * PFNGLGETBOOLEANINDEXEDVEXTPROC) (GLenum value, GLuint index, GLboolean* data);
typedef void (__stdcall * PFNGLGETINTEGERINDEXEDVEXTPROC) (GLenum value, GLuint index, GLint* data);
typedef GLboolean (__stdcall * PFNGLISENABLEDINDEXEDEXTPROC) (GLenum target, GLuint index);










#line 10181 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLBLENDEQUATIONSEPARATEIEXTPROC) (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
typedef void (__stdcall * PFNGLBLENDEQUATIONIEXTPROC) (GLuint buf, GLenum mode);
typedef void (__stdcall * PFNGLBLENDFUNCSEPARATEIEXTPROC) (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
typedef void (__stdcall * PFNGLBLENDFUNCIEXTPROC) (GLuint buf, GLenum src, GLenum dst);
typedef void (__stdcall * PFNGLCOLORMASKIEXTPROC) (GLuint buf, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
typedef void (__stdcall * PFNGLDISABLEIEXTPROC) (GLenum target, GLuint index);
typedef void (__stdcall * PFNGLENABLEIEXTPROC) (GLenum target, GLuint index);
typedef GLboolean (__stdcall * PFNGLISENABLEDIEXTPROC) (GLenum target, GLuint index);












#line 10208 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLDRAWELEMENTSBASEVERTEXEXTPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLint basevertex);
typedef void (__stdcall * PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXEXTPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex);
typedef void (__stdcall * PFNGLDRAWRANGEELEMENTSBASEVERTEXEXTPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices, GLint basevertex);
typedef void (__stdcall * PFNGLMULTIDRAWELEMENTSBASEVERTEXEXTPROC) (GLenum mode, const GLsizei* count, GLenum type, const void *const *indices, GLsizei primcount, const GLint *basevertex);








#line 10227 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLDRAWARRAYSINSTANCEDEXTPROC) (GLenum mode, GLint start, GLsizei count, GLsizei primcount);
typedef void (__stdcall * PFNGLDRAWELEMENTSINSTANCEDEXTPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount);






#line 10242 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 







typedef void (__stdcall * PFNGLDRAWRANGEELEMENTSEXTPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices);





#line 10258 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void* GLeglClientBufferEXT;

typedef void (__stdcall * PFNGLBUFFERSTORAGEEXTERNALEXTPROC) (GLenum target, GLintptr offset, GLsizeiptr size, GLeglClientBufferEXT clientBuffer, GLbitfield flags);
typedef void (__stdcall * PFNGLNAMEDBUFFERSTORAGEEXTERNALEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr size, GLeglClientBufferEXT clientBuffer, GLbitfield flags);






#line 10275 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 10284 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 













typedef void (__stdcall * PFNGLFOGCOORDPOINTEREXTPROC) (GLenum type, GLsizei stride, const void *pointer);
typedef void (__stdcall * PFNGLFOGCOORDDEXTPROC) (GLdouble coord);
typedef void (__stdcall * PFNGLFOGCOORDDVEXTPROC) (const GLdouble *coord);
typedef void (__stdcall * PFNGLFOGCOORDFEXTPROC) (GLfloat coord);
typedef void (__stdcall * PFNGLFOGCOORDFVEXTPROC) (const GLfloat *coord);









#line 10314 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 10323 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 



















typedef void (__stdcall * PFNGLFRAGMENTCOLORMATERIALEXTPROC) (GLenum face, GLenum mode);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTMODELFEXTPROC) (GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTMODELFVEXTPROC) (GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTMODELIEXTPROC) (GLenum pname, GLint param);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTMODELIVEXTPROC) (GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTFEXTPROC) (GLenum light, GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTFVEXTPROC) (GLenum light, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTIEXTPROC) (GLenum light, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTIVEXTPROC) (GLenum light, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLFRAGMENTMATERIALFEXTPROC) (GLenum face, GLenum pname, const GLfloat param);
typedef void (__stdcall * PFNGLFRAGMENTMATERIALFVEXTPROC) (GLenum face, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLFRAGMENTMATERIALIEXTPROC) (GLenum face, GLenum pname, const GLint param);
typedef void (__stdcall * PFNGLFRAGMENTMATERIALIVEXTPROC) (GLenum face, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLGETFRAGMENTLIGHTFVEXTPROC) (GLenum light, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETFRAGMENTLIGHTIVEXTPROC) (GLenum light, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETFRAGMENTMATERIALFVEXTPROC) (GLenum face, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLGETFRAGMENTMATERIALIVEXTPROC) (GLenum face, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLLIGHTENVIEXTPROC) (GLenum pname, GLint param);






















#line 10385 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









typedef void (__stdcall * PFNGLBLITFRAMEBUFFEREXTPROC) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);





#line 10403 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








typedef void (__stdcall * PFNGLRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);





#line 10420 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 10432 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 
























































typedef void (__stdcall * PFNGLBINDFRAMEBUFFEREXTPROC) (GLenum target, GLuint framebuffer);
typedef void (__stdcall * PFNGLBINDRENDERBUFFEREXTPROC) (GLenum target, GLuint renderbuffer);
typedef GLenum (__stdcall * PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC) (GLenum target);
typedef void (__stdcall * PFNGLDELETEFRAMEBUFFERSEXTPROC) (GLsizei n, const GLuint* framebuffers);
typedef void (__stdcall * PFNGLDELETERENDERBUFFERSEXTPROC) (GLsizei n, const GLuint* renderbuffers);
typedef void (__stdcall * PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC) (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTURE1DEXTPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTURE2DEXTPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTURE3DEXTPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
typedef void (__stdcall * PFNGLGENFRAMEBUFFERSEXTPROC) (GLsizei n, GLuint* framebuffers);
typedef void (__stdcall * PFNGLGENRENDERBUFFERSEXTPROC) (GLsizei n, GLuint* renderbuffers);
typedef void (__stdcall * PFNGLGENERATEMIPMAPEXTPROC) (GLenum target);
typedef void (__stdcall * PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC) (GLenum target, GLenum attachment, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETRENDERBUFFERPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint* params);
typedef GLboolean (__stdcall * PFNGLISFRAMEBUFFEREXTPROC) (GLuint framebuffer);
typedef GLboolean (__stdcall * PFNGLISRENDERBUFFEREXTPROC) (GLuint renderbuffer);
typedef void (__stdcall * PFNGLRENDERBUFFERSTORAGEEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height);





















#line 10529 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 10541 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








































#line 10584 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








































#line 10627 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 

























typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTUREEXTPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level);
typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTUREFACEEXTPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);
typedef void (__stdcall * PFNGLPROGRAMPARAMETERIEXTPROC) (GLuint program, GLenum pname, GLint value);







#line 10665 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLPROGRAMENVPARAMETERS4FVEXTPROC) (GLenum target, GLuint index, GLsizei count, const GLfloat* params);
typedef void (__stdcall * PFNGLPROGRAMLOCALPARAMETERS4FVEXTPROC) (GLenum target, GLuint index, GLsizei count, const GLfloat* params);






#line 10680 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 































typedef void (__stdcall * PFNGLBINDFRAGDATALOCATIONEXTPROC) (GLuint program, GLuint color, const GLchar *name);
typedef GLint (__stdcall * PFNGLGETFRAGDATALOCATIONEXTPROC) (GLuint program, const GLchar *name);
typedef void (__stdcall * PFNGLGETUNIFORMUIVEXTPROC) (GLuint program, GLint location, GLuint *params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBIIVEXTPROC) (GLuint index, GLenum pname, GLint *params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBIUIVEXTPROC) (GLuint index, GLenum pname, GLuint *params);
typedef void (__stdcall * PFNGLUNIFORM1UIEXTPROC) (GLint location, GLuint v0);
typedef void (__stdcall * PFNGLUNIFORM1UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void (__stdcall * PFNGLUNIFORM2UIEXTPROC) (GLint location, GLuint v0, GLuint v1);
typedef void (__stdcall * PFNGLUNIFORM2UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void (__stdcall * PFNGLUNIFORM3UIEXTPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2);
typedef void (__stdcall * PFNGLUNIFORM3UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void (__stdcall * PFNGLUNIFORM4UIEXTPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void (__stdcall * PFNGLUNIFORM4UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void (__stdcall * PFNGLVERTEXATTRIBI1IEXTPROC) (GLuint index, GLint x);
typedef void (__stdcall * PFNGLVERTEXATTRIBI1IVEXTPROC) (GLuint index, const GLint *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBI1UIEXTPROC) (GLuint index, GLuint x);
typedef void (__stdcall * PFNGLVERTEXATTRIBI1UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBI2IEXTPROC) (GLuint index, GLint x, GLint y);
typedef void (__stdcall * PFNGLVERTEXATTRIBI2IVEXTPROC) (GLuint index, const GLint *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBI2UIEXTPROC) (GLuint index, GLuint x, GLuint y);
typedef void (__stdcall * PFNGLVERTEXATTRIBI2UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBI3IEXTPROC) (GLuint index, GLint x, GLint y, GLint z);
typedef void (__stdcall * PFNGLVERTEXATTRIBI3IVEXTPROC) (GLuint index, const GLint *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBI3UIEXTPROC) (GLuint index, GLuint x, GLuint y, GLuint z);
typedef void (__stdcall * PFNGLVERTEXATTRIBI3UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4BVEXTPROC) (GLuint index, const GLbyte *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4IEXTPROC) (GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4IVEXTPROC) (GLuint index, const GLint *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4SVEXTPROC) (GLuint index, const GLshort *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4UBVEXTPROC) (GLuint index, const GLubyte *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4UIEXTPROC) (GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4USVEXTPROC) (GLuint index, const GLushort *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBIPOINTEREXTPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer);






































#line 10786 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 10795 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 


















typedef void (__stdcall * PFNGLGETHISTOGRAMEXTPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, void *values);
typedef void (__stdcall * PFNGLGETHISTOGRAMPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETHISTOGRAMPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETMINMAXEXTPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, void *values);
typedef void (__stdcall * PFNGLGETMINMAXPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETMINMAXPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLHISTOGRAMEXTPROC) (GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
typedef void (__stdcall * PFNGLMINMAXEXTPROC) (GLenum target, GLenum internalformat, GLboolean sink);
typedef void (__stdcall * PFNGLRESETHISTOGRAMEXTPROC) (GLenum target);
typedef void (__stdcall * PFNGLRESETMINMAXEXTPROC) (GLenum target);














#line 10840 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 10849 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLINDEXFUNCEXTPROC) (GLenum func, GLfloat ref);





#line 10862 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLINDEXMATERIALEXTPROC) (GLenum face, GLenum mode);





#line 10875 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 10884 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






typedef void (__stdcall * PFNGLVERTEXATTRIBDIVISOREXTPROC) (GLuint index, GLuint divisor);





#line 10899 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 














typedef void (__stdcall * PFNGLAPPLYTEXTUREEXTPROC) (GLenum mode);
typedef void (__stdcall * PFNGLTEXTURELIGHTEXTPROC) (GLenum pname);
typedef void (__stdcall * PFNGLTEXTUREMATERIALEXTPROC) (GLenum face, GLenum mode);







#line 10926 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











typedef void (__stdcall * PFNGLFLUSHMAPPEDBUFFERRANGEEXTPROC) (GLenum target, GLintptr offset, GLsizeiptr length);
typedef void * (__stdcall * PFNGLMAPBUFFERRANGEEXTPROC) (GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);






#line 10948 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 























typedef void (__stdcall * PFNGLBUFFERSTORAGEMEMEXTPROC) (GLenum target, GLsizeiptr size, GLuint memory, GLuint64 offset);
typedef void (__stdcall * PFNGLCREATEMEMORYOBJECTSEXTPROC) (GLsizei n, GLuint* memoryObjects);
typedef void (__stdcall * PFNGLDELETEMEMORYOBJECTSEXTPROC) (GLsizei n, const GLuint* memoryObjects);
typedef void (__stdcall * PFNGLGETMEMORYOBJECTPARAMETERIVEXTPROC) (GLuint memoryObject, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETUNSIGNEDBYTEI_VEXTPROC) (GLenum target, GLuint index, GLubyte* data);
typedef void (__stdcall * PFNGLGETUNSIGNEDBYTEVEXTPROC) (GLenum pname, GLubyte* data);
typedef GLboolean (__stdcall * PFNGLISMEMORYOBJECTEXTPROC) (GLuint memoryObject);
typedef void (__stdcall * PFNGLMEMORYOBJECTPARAMETERIVEXTPROC) (GLuint memoryObject, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLNAMEDBUFFERSTORAGEMEMEXTPROC) (GLuint buffer, GLsizeiptr size, GLuint memory, GLuint64 offset);
typedef void (__stdcall * PFNGLTEXSTORAGEMEM1DEXTPROC) (GLenum target, GLsizei levels, GLenum internalFormat, GLsizei width, GLuint memory, GLuint64 offset);
typedef void (__stdcall * PFNGLTEXSTORAGEMEM2DEXTPROC) (GLenum target, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLuint memory, GLuint64 offset);
typedef void (__stdcall * PFNGLTEXSTORAGEMEM2DMULTISAMPLEEXTPROC) (GLenum target, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset);
typedef void (__stdcall * PFNGLTEXSTORAGEMEM3DEXTPROC) (GLenum target, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset);
typedef void (__stdcall * PFNGLTEXSTORAGEMEM3DMULTISAMPLEEXTPROC) (GLenum target, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset);
typedef void (__stdcall * PFNGLTEXTURESTORAGEMEM1DEXTPROC) (GLuint texture, GLsizei levels, GLenum internalFormat, GLsizei width, GLuint memory, GLuint64 offset);
typedef void (__stdcall * PFNGLTEXTURESTORAGEMEM2DEXTPROC) (GLuint texture, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLuint memory, GLuint64 offset);
typedef void (__stdcall * PFNGLTEXTURESTORAGEMEM2DMULTISAMPLEEXTPROC) (GLuint texture, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset);
typedef void (__stdcall * PFNGLTEXTURESTORAGEMEM3DEXTPROC) (GLuint texture, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset);
typedef void (__stdcall * PFNGLTEXTURESTORAGEMEM3DMULTISAMPLEEXTPROC) (GLuint texture, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset);























#line 11016 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






typedef void (__stdcall * PFNGLIMPORTMEMORYFDEXTPROC) (GLuint memory, GLuint64 size, GLenum handleType, GLint fd);





#line 11031 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 
















typedef void (__stdcall * PFNGLIMPORTMEMORYWIN32HANDLEEXTPROC) (GLuint memory, GLuint64 size, GLenum handleType, void *handle);
typedef void (__stdcall * PFNGLIMPORTMEMORYWIN32NAMEEXTPROC) (GLuint memory, GLuint64 size, GLenum handleType, const void *name);






#line 11058 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 11067 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLMULTIDRAWARRAYSEXTPROC) (GLenum mode, const GLint* first, const GLsizei *count, GLsizei primcount);
typedef void (__stdcall * PFNGLMULTIDRAWELEMENTSEXTPROC) (GLenum mode, GLsizei* count, GLenum type, const void *const *indices, GLsizei primcount);






#line 11082 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLMULTIDRAWARRAYSINDIRECTEXTPROC) (GLenum mode, const void *indirect, GLsizei drawcount, GLsizei stride);
typedef void (__stdcall * PFNGLMULTIDRAWELEMENTSINDIRECTEXTPROC) (GLenum mode, GLenum type, const void *indirect, GLsizei drawcount, GLsizei stride);






#line 11097 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 11106 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






















typedef void (__stdcall * PFNGLSAMPLEMASKEXTPROC) (GLclampf value, GLboolean invert);
typedef void (__stdcall * PFNGLSAMPLEPATTERNEXTPROC) (GLenum pattern);






#line 11139 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 11151 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTURE2DMULTISAMPLEEXTPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples);





#line 11169 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 11178 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 










typedef void (__stdcall * PFNGLDRAWBUFFERSINDEXEDEXTPROC) (GLint n, const GLenum* location, const GLint *indices);
typedef void (__stdcall * PFNGLGETINTEGERI_VEXTPROC) (GLenum target, GLuint index, GLint* data);
typedef void (__stdcall * PFNGLREADBUFFERINDEXEDEXTPROC) (GLenum src, GLint index);







#line 11201 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











#line 11215 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 










#line 11228 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 












#line 11243 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 


























typedef void (__stdcall * PFNGLCOLORTABLEEXTPROC) (GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const void *data);
typedef void (__stdcall * PFNGLGETCOLORTABLEEXTPROC) (GLenum target, GLenum format, GLenum type, void *data);
typedef void (__stdcall * PFNGLGETCOLORTABLEPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETCOLORTABLEPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint* params);








#line 11284 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











#line 11298 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 














typedef void (__stdcall * PFNGLGETPIXELTRANSFORMPARAMETERFVEXTPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLGETPIXELTRANSFORMPARAMETERIVEXTPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLPIXELTRANSFORMPARAMETERFEXTPROC) (GLenum target, GLenum pname, const GLfloat param);
typedef void (__stdcall * PFNGLPIXELTRANSFORMPARAMETERFVEXTPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLPIXELTRANSFORMPARAMETERIEXTPROC) (GLenum target, GLenum pname, const GLint param);
typedef void (__stdcall * PFNGLPIXELTRANSFORMPARAMETERIVEXTPROC) (GLenum target, GLenum pname, const GLint* params);










#line 11331 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 11340 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









typedef void (__stdcall * PFNGLPOINTPARAMETERFEXTPROC) (GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLPOINTPARAMETERFVEXTPROC) (GLenum pname, const GLfloat* params);






#line 11360 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








typedef void (__stdcall * PFNGLPOLYGONOFFSETEXTPROC) (GLfloat factor, GLfloat bias);





#line 11377 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






typedef void (__stdcall * PFNGLPOLYGONOFFSETCLAMPEXTPROC) (GLfloat factor, GLfloat units, GLfloat clamp);





#line 11392 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 11401 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









typedef void (__stdcall * PFNGLPROVOKINGVERTEXEXTPROC) (GLenum mode);





#line 11419 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











#line 11433 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 



















typedef void (__stdcall * PFNGLCOVERAGEMODULATIONNVPROC) (GLenum components);
typedef void (__stdcall * PFNGLCOVERAGEMODULATIONTABLENVPROC) (GLsizei n, const GLfloat* v);
typedef void (__stdcall * PFNGLGETCOVERAGEMODULATIONTABLENVPROC) (GLsizei bufsize, GLfloat* v);
typedef void (__stdcall * PFNGLRASTERSAMPLESEXTPROC) (GLuint samples, GLboolean fixedsamplelocations);








#line 11467 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 










#line 11480 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 















#line 11498 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 11509 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











#line 11523 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 11534 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLBEGINSCENEEXTPROC) (void);
typedef void (__stdcall * PFNGLENDSCENEEXTPROC) (void);






#line 11549 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 












typedef void (__stdcall * PFNGLSECONDARYCOLOR3BEXTPROC) (GLbyte red, GLbyte green, GLbyte blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3BVEXTPROC) (const GLbyte *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3DEXTPROC) (GLdouble red, GLdouble green, GLdouble blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3DVEXTPROC) (const GLdouble *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3FEXTPROC) (GLfloat red, GLfloat green, GLfloat blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3FVEXTPROC) (const GLfloat *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3IEXTPROC) (GLint red, GLint green, GLint blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3IVEXTPROC) (const GLint *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3SEXTPROC) (GLshort red, GLshort green, GLshort blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3SVEXTPROC) (const GLshort *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3UBEXTPROC) (GLubyte red, GLubyte green, GLubyte blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3UBVEXTPROC) (const GLubyte *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3UIEXTPROC) (GLuint red, GLuint green, GLuint blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3UIVEXTPROC) (const GLuint *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3USEXTPROC) (GLushort red, GLushort green, GLushort blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3USVEXTPROC) (const GLushort *v);
typedef void (__stdcall * PFNGLSECONDARYCOLORPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, const void *pointer);





















#line 11602 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLDELETESEMAPHORESEXTPROC) (GLsizei n, const GLuint* semaphores);
typedef void (__stdcall * PFNGLGENSEMAPHORESEXTPROC) (GLsizei n, GLuint* semaphores);
typedef void (__stdcall * PFNGLGETSEMAPHOREPARAMETERUI64VEXTPROC) (GLuint semaphore, GLenum pname, GLuint64* params);
typedef GLboolean (__stdcall * PFNGLISSEMAPHOREEXTPROC) (GLuint semaphore);
typedef void (__stdcall * PFNGLSEMAPHOREPARAMETERUI64VEXTPROC) (GLuint semaphore, GLenum pname, const GLuint64* params);
typedef void (__stdcall * PFNGLSIGNALSEMAPHOREEXTPROC) (GLuint semaphore, GLuint numBufferBarriers, const GLuint* buffers, GLuint numTextureBarriers, const GLuint *textures, const GLenum *dstLayouts);
typedef void (__stdcall * PFNGLWAITSEMAPHOREEXTPROC) (GLuint semaphore, GLuint numBufferBarriers, const GLuint* buffers, GLuint numTextureBarriers, const GLuint *textures, const GLenum *srcLayouts);











#line 11627 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLIMPORTSEMAPHOREFDEXTPROC) (GLuint semaphore, GLenum handleType, GLint fd);





#line 11640 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLIMPORTSEMAPHOREWIN32HANDLEEXTPROC) (GLuint semaphore, GLenum handleType, void *handle);
typedef void (__stdcall * PFNGLIMPORTSEMAPHOREWIN32NAMEEXTPROC) (GLuint semaphore, GLenum handleType, const void *name);






#line 11655 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






typedef void (__stdcall * PFNGLACTIVEPROGRAMEXTPROC) (GLuint program);
typedef GLuint (__stdcall * PFNGLCREATESHADERPROGRAMEXTPROC) (GLenum type, const GLchar* string);
typedef void (__stdcall * PFNGLUSESHADERPROGRAMEXTPROC) (GLenum type, GLuint program);







#line 11674 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 










#line 11687 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 11698 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 11707 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 11716 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




























































typedef void (__stdcall * PFNGLBINDIMAGETEXTUREEXTPROC) (GLuint index, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLint format);
typedef void (__stdcall * PFNGLMEMORYBARRIEREXTPROC) (GLbitfield barriers);






#line 11787 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 11796 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 11805 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 11814 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 11823 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 










#line 11836 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








typedef void (__stdcall * PFNGLCLEARPIXELLOCALSTORAGEUIEXTPROC) (GLsizei offset, GLsizei n, const GLuint* values);
typedef void (__stdcall * PFNGLFRAMEBUFFERPIXELLOCALSTORAGESIZEEXTPROC) (GLuint target, GLsizei size);
typedef GLsizei (__stdcall * PFNGLGETFRAMEBUFFERPIXELLOCALSTORAGESIZEEXTPROC) (GLuint target);







#line 11857 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 11866 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 11875 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











#line 11889 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 11900 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 





















typedef void (__stdcall * PFNGLTEXPAGECOMMITMENTEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit);
typedef void (__stdcall * PFNGLTEXTUREPAGECOMMITMENTEXTPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit);






#line 11932 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 11941 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 11953 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 







typedef void (__stdcall * PFNGLACTIVESTENCILFACEEXTPROC) (GLenum face);





#line 11969 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 11981 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLTEXSUBIMAGE1DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLTEXSUBIMAGE2DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLTEXSUBIMAGE3DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);







#line 11998 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 

















































#line 12050 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 














typedef void (__stdcall * PFNGLTEXIMAGE3DEXTPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);





#line 12073 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 













typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTURELAYEREXTPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);





#line 12095 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 










typedef void (__stdcall * PFNGLTEXBUFFEREXTPROC) (GLenum target, GLenum internalformat, GLuint buffer);





#line 12114 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 12125 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 12136 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











#line 12150 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 12159 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











#line 12173 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











#line 12187 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











#line 12201 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 



















#line 12223 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 
















#line 12242 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 12253 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 12262 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 12271 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




























#line 12302 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 12314 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 12326 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 12338 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 12349 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




















































typedef void (__stdcall * PFNGLCLEARCOLORIIEXTPROC) (GLint red, GLint green, GLint blue, GLint alpha);
typedef void (__stdcall * PFNGLCLEARCOLORIUIEXTPROC) (GLuint red, GLuint green, GLuint blue, GLuint alpha);
typedef void (__stdcall * PFNGLGETTEXPARAMETERIIVEXTPROC) (GLenum target, GLenum pname, GLint *params);
typedef void (__stdcall * PFNGLGETTEXPARAMETERIUIVEXTPROC) (GLenum target, GLenum pname, GLuint *params);
typedef void (__stdcall * PFNGLTEXPARAMETERIIVEXTPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void (__stdcall * PFNGLTEXPARAMETERIUIVEXTPROC) (GLenum target, GLenum pname, const GLuint *params);










#line 12420 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 










#line 12433 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 










#line 12446 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 















#line 12464 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 










typedef GLboolean (__stdcall * PFNGLARETEXTURESRESIDENTEXTPROC) (GLsizei n, const GLuint* textures, GLboolean* residences);
typedef void (__stdcall * PFNGLBINDTEXTUREEXTPROC) (GLenum target, GLuint texture);
typedef void (__stdcall * PFNGLDELETETEXTURESEXTPROC) (GLsizei n, const GLuint* textures);
typedef void (__stdcall * PFNGLGENTEXTURESEXTPROC) (GLsizei n, GLuint* textures);
typedef GLboolean (__stdcall * PFNGLISTEXTUREEXTPROC) (GLuint texture);
typedef void (__stdcall * PFNGLPRIORITIZETEXTURESEXTPROC) (GLsizei n, const GLuint* textures, const GLclampf* priorities);










#line 12493 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 







typedef void (__stdcall * PFNGLTEXTURENORMALEXTPROC) (GLenum mode);





#line 12509 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











#line 12523 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











#line 12537 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 























#line 12563 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 12574 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 12585 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 










#line 12598 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 










#line 12611 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 
































#line 12646 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 





























typedef void (__stdcall * PFNGLTEXSTORAGE1DEXTPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
typedef void (__stdcall * PFNGLTEXSTORAGE2DEXTPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLTEXSTORAGE3DEXTPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
typedef void (__stdcall * PFNGLTEXTURESTORAGE1DEXTPROC) (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
typedef void (__stdcall * PFNGLTEXTURESTORAGE2DEXTPROC) (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLTEXTURESTORAGE3DEXTPROC) (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);










#line 12694 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 












#line 12709 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 12720 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 










typedef void (__stdcall * PFNGLTEXTUREVIEWEXTPROC) (GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers);





#line 12739 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






typedef void (__stdcall * PFNGLGETQUERYOBJECTI64VEXTPROC) (GLuint id, GLenum pname, GLint64EXT *params);
typedef void (__stdcall * PFNGLGETQUERYOBJECTUI64VEXTPROC) (GLuint id, GLenum pname, GLuint64EXT *params);






#line 12756 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




















typedef void (__stdcall * PFNGLBEGINTRANSFORMFEEDBACKEXTPROC) (GLenum primitiveMode);
typedef void (__stdcall * PFNGLBINDBUFFERBASEEXTPROC) (GLenum target, GLuint index, GLuint buffer);
typedef void (__stdcall * PFNGLBINDBUFFEROFFSETEXTPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset);
typedef void (__stdcall * PFNGLBINDBUFFERRANGEEXTPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void (__stdcall * PFNGLENDTRANSFORMFEEDBACKEXTPROC) (void);
typedef void (__stdcall * PFNGLGETTRANSFORMFEEDBACKVARYINGEXTPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLsizei *size, GLenum *type, GLchar *name);
typedef void (__stdcall * PFNGLTRANSFORMFEEDBACKVARYINGSEXTPROC) (GLuint program, GLsizei count, const GLchar * const* varyings, GLenum bufferMode);











#line 12797 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 










#line 12810 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






































typedef void (__stdcall * PFNGLARRAYELEMENTEXTPROC) (GLint i);
typedef void (__stdcall * PFNGLCOLORPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const void *pointer);
typedef void (__stdcall * PFNGLDRAWARRAYSEXTPROC) (GLenum mode, GLint first, GLsizei count);
typedef void (__stdcall * PFNGLEDGEFLAGPOINTEREXTPROC) (GLsizei stride, GLsizei count, const GLboolean* pointer);
typedef void (__stdcall * PFNGLINDEXPOINTEREXTPROC) (GLenum type, GLsizei stride, GLsizei count, const void *pointer);
typedef void (__stdcall * PFNGLNORMALPOINTEREXTPROC) (GLenum type, GLsizei stride, GLsizei count, const void *pointer);
typedef void (__stdcall * PFNGLTEXCOORDPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const void *pointer);
typedef void (__stdcall * PFNGLVERTEXPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const void *pointer);












#line 12871 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 12882 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLBINDARRAYSETEXTPROC) (const void *arrayset);
typedef const void * (__stdcall * PFNGLCREATEARRAYSETEXTPROC) (void);
typedef void (__stdcall * PFNGLDELETEARRAYSETSEXTPROC) (GLsizei n, const void *arrayset[]);







#line 12899 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 

















typedef void (__stdcall * PFNGLGETVERTEXATTRIBLDVEXTPROC) (GLuint index, GLenum pname, GLdouble* params);
typedef void (__stdcall * PFNGLVERTEXARRAYVERTEXATTRIBLOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void (__stdcall * PFNGLVERTEXATTRIBL1DEXTPROC) (GLuint index, GLdouble x);
typedef void (__stdcall * PFNGLVERTEXATTRIBL1DVEXTPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL2DEXTPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void (__stdcall * PFNGLVERTEXATTRIBL2DVEXTPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL3DEXTPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLVERTEXATTRIBL3DVEXTPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL4DEXTPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLVERTEXATTRIBL4DVEXTPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBLPOINTEREXTPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer);















#line 12945 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 



















































































































typedef void (__stdcall * PFNGLBEGINVERTEXSHADEREXTPROC) (void);
typedef GLuint (__stdcall * PFNGLBINDLIGHTPARAMETEREXTPROC) (GLenum light, GLenum value);
typedef GLuint (__stdcall * PFNGLBINDMATERIALPARAMETEREXTPROC) (GLenum face, GLenum value);
typedef GLuint (__stdcall * PFNGLBINDPARAMETEREXTPROC) (GLenum value);
typedef GLuint (__stdcall * PFNGLBINDTEXGENPARAMETEREXTPROC) (GLenum unit, GLenum coord, GLenum value);
typedef GLuint (__stdcall * PFNGLBINDTEXTUREUNITPARAMETEREXTPROC) (GLenum unit, GLenum value);
typedef void (__stdcall * PFNGLBINDVERTEXSHADEREXTPROC) (GLuint id);
typedef void (__stdcall * PFNGLDELETEVERTEXSHADEREXTPROC) (GLuint id);
typedef void (__stdcall * PFNGLDISABLEVARIANTCLIENTSTATEEXTPROC) (GLuint id);
typedef void (__stdcall * PFNGLENABLEVARIANTCLIENTSTATEEXTPROC) (GLuint id);
typedef void (__stdcall * PFNGLENDVERTEXSHADEREXTPROC) (void);
typedef void (__stdcall * PFNGLEXTRACTCOMPONENTEXTPROC) (GLuint res, GLuint src, GLuint num);
typedef GLuint (__stdcall * PFNGLGENSYMBOLSEXTPROC) (GLenum dataType, GLenum storageType, GLenum range, GLuint components);
typedef GLuint (__stdcall * PFNGLGENVERTEXSHADERSEXTPROC) (GLuint range);
typedef void (__stdcall * PFNGLGETINVARIANTBOOLEANVEXTPROC) (GLuint id, GLenum value, GLboolean *data);
typedef void (__stdcall * PFNGLGETINVARIANTFLOATVEXTPROC) (GLuint id, GLenum value, GLfloat *data);
typedef void (__stdcall * PFNGLGETINVARIANTINTEGERVEXTPROC) (GLuint id, GLenum value, GLint *data);
typedef void (__stdcall * PFNGLGETLOCALCONSTANTBOOLEANVEXTPROC) (GLuint id, GLenum value, GLboolean *data);
typedef void (__stdcall * PFNGLGETLOCALCONSTANTFLOATVEXTPROC) (GLuint id, GLenum value, GLfloat *data);
typedef void (__stdcall * PFNGLGETLOCALCONSTANTINTEGERVEXTPROC) (GLuint id, GLenum value, GLint *data);
typedef void (__stdcall * PFNGLGETVARIANTBOOLEANVEXTPROC) (GLuint id, GLenum value, GLboolean *data);
typedef void (__stdcall * PFNGLGETVARIANTFLOATVEXTPROC) (GLuint id, GLenum value, GLfloat *data);
typedef void (__stdcall * PFNGLGETVARIANTINTEGERVEXTPROC) (GLuint id, GLenum value, GLint *data);
typedef void (__stdcall * PFNGLGETVARIANTPOINTERVEXTPROC) (GLuint id, GLenum value, void **data);
typedef void (__stdcall * PFNGLINSERTCOMPONENTEXTPROC) (GLuint res, GLuint src, GLuint num);
typedef GLboolean (__stdcall * PFNGLISVARIANTENABLEDEXTPROC) (GLuint id, GLenum cap);
typedef void (__stdcall * PFNGLSETINVARIANTEXTPROC) (GLuint id, GLenum type, void *addr);
typedef void (__stdcall * PFNGLSETLOCALCONSTANTEXTPROC) (GLuint id, GLenum type, void *addr);
typedef void (__stdcall * PFNGLSHADEROP1EXTPROC) (GLenum op, GLuint res, GLuint arg1);
typedef void (__stdcall * PFNGLSHADEROP2EXTPROC) (GLenum op, GLuint res, GLuint arg1, GLuint arg2);
typedef void (__stdcall * PFNGLSHADEROP3EXTPROC) (GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3);
typedef void (__stdcall * PFNGLSWIZZLEEXTPROC) (GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW);
typedef void (__stdcall * PFNGLVARIANTPOINTEREXTPROC) (GLuint id, GLenum type, GLuint stride, void *addr);
typedef void (__stdcall * PFNGLVARIANTBVEXTPROC) (GLuint id, GLbyte *addr);
typedef void (__stdcall * PFNGLVARIANTDVEXTPROC) (GLuint id, GLdouble *addr);
typedef void (__stdcall * PFNGLVARIANTFVEXTPROC) (GLuint id, GLfloat *addr);
typedef void (__stdcall * PFNGLVARIANTIVEXTPROC) (GLuint id, GLint *addr);
typedef void (__stdcall * PFNGLVARIANTSVEXTPROC) (GLuint id, GLshort *addr);
typedef void (__stdcall * PFNGLVARIANTUBVEXTPROC) (GLuint id, GLubyte *addr);
typedef void (__stdcall * PFNGLVARIANTUIVEXTPROC) (GLuint id, GLuint *addr);
typedef void (__stdcall * PFNGLVARIANTUSVEXTPROC) (GLuint id, GLushort *addr);
typedef void (__stdcall * PFNGLWRITEMASKEXTPROC) (GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW);














































#line 13151 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 


















typedef void (__stdcall * PFNGLVERTEXWEIGHTPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, void *pointer);
typedef void (__stdcall * PFNGLVERTEXWEIGHTFEXTPROC) (GLfloat weight);
typedef void (__stdcall * PFNGLVERTEXWEIGHTFVEXTPROC) (GLfloat* weight);







#line 13182 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef GLboolean (__stdcall * PFNGLACQUIREKEYEDMUTEXWIN32EXTPROC) (GLuint memory, GLuint64 key, GLuint timeout);
typedef GLboolean (__stdcall * PFNGLRELEASEKEYEDMUTEXWIN32EXTPROC) (GLuint memory, GLuint64 key);






#line 13197 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











typedef void (__stdcall * PFNGLWINDOWRECTANGLESEXTPROC) (GLenum mode, GLsizei count, const GLint box[]);





#line 13217 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






typedef GLsync (__stdcall * PFNGLIMPORTSYNCEXTPROC) (GLenum external_sync_type, GLintptr external_sync, GLbitfield flags);





#line 13232 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLFRAMETERMINATORGREMEDYPROC) (void);





#line 13245 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLSTRINGMARKERGREMEDYPROC) (GLsizei len, const void *string);





#line 13258 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 13267 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLGETIMAGETRANSFORMPARAMETERFVHPPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLGETIMAGETRANSFORMPARAMETERIVHPPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLIMAGETRANSFORMPARAMETERFHPPROC) (GLenum target, GLenum pname, const GLfloat param);
typedef void (__stdcall * PFNGLIMAGETRANSFORMPARAMETERFVHPPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLIMAGETRANSFORMPARAMETERIHPPROC) (GLenum target, GLenum pname, const GLint param);
typedef void (__stdcall * PFNGLIMAGETRANSFORMPARAMETERIVHPPROC) (GLenum target, GLenum pname, const GLint* params);










#line 13290 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 13299 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 13308 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 13319 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLMULTIMODEDRAWARRAYSIBMPROC) (const GLenum* mode, const GLint *first, const GLsizei *count, GLsizei primcount, GLint modestride);
typedef void (__stdcall * PFNGLMULTIMODEDRAWELEMENTSIBMPROC) (const GLenum* mode, const GLsizei *count, GLenum type, const void *const *indices, GLsizei primcount, GLint modestride);






#line 13334 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 13345 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 13357 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 13368 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 





















typedef void (__stdcall * PFNGLCOLORPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const void** pointer, GLint ptrstride);
typedef void (__stdcall * PFNGLEDGEFLAGPOINTERLISTIBMPROC) (GLint stride, const GLboolean ** pointer, GLint ptrstride);
typedef void (__stdcall * PFNGLFOGCOORDPOINTERLISTIBMPROC) (GLenum type, GLint stride, const void** pointer, GLint ptrstride);
typedef void (__stdcall * PFNGLINDEXPOINTERLISTIBMPROC) (GLenum type, GLint stride, const void** pointer, GLint ptrstride);
typedef void (__stdcall * PFNGLNORMALPOINTERLISTIBMPROC) (GLenum type, GLint stride, const void** pointer, GLint ptrstride);
typedef void (__stdcall * PFNGLSECONDARYCOLORPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const void** pointer, GLint ptrstride);
typedef void (__stdcall * PFNGLTEXCOORDPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const void** pointer, GLint ptrstride);
typedef void (__stdcall * PFNGLVERTEXPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const void** pointer, GLint ptrstride);












#line 13412 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 















#line 13430 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 13441 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 13452 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 13461 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 13470 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









typedef void * (__stdcall * PFNGLMAPTEXTURE2DINTELPROC) (GLuint texture, GLint level, GLbitfield access, GLint* stride, GLenum *layout);
typedef void (__stdcall * PFNGLSYNCTEXTUREINTELPROC) (GLuint texture);
typedef void (__stdcall * PFNGLUNMAPTEXTURE2DINTELPROC) (GLuint texture, GLint level);







#line 13492 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 










typedef void (__stdcall * PFNGLCOLORPOINTERVINTELPROC) (GLint size, GLenum type, const void** pointer);
typedef void (__stdcall * PFNGLNORMALPOINTERVINTELPROC) (GLenum type, const void** pointer);
typedef void (__stdcall * PFNGLTEXCOORDPOINTERVINTELPROC) (GLint size, GLenum type, const void** pointer);
typedef void (__stdcall * PFNGLVERTEXPOINTERVINTELPROC) (GLint size, GLenum type, const void** pointer);








#line 13517 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 

























typedef void (__stdcall * PFNGLBEGINPERFQUERYINTELPROC) (GLuint queryHandle);
typedef void (__stdcall * PFNGLCREATEPERFQUERYINTELPROC) (GLuint queryId, GLuint* queryHandle);
typedef void (__stdcall * PFNGLDELETEPERFQUERYINTELPROC) (GLuint queryHandle);
typedef void (__stdcall * PFNGLENDPERFQUERYINTELPROC) (GLuint queryHandle);
typedef void (__stdcall * PFNGLGETFIRSTPERFQUERYIDINTELPROC) (GLuint* queryId);
typedef void (__stdcall * PFNGLGETNEXTPERFQUERYIDINTELPROC) (GLuint queryId, GLuint* nextQueryId);
typedef void (__stdcall * PFNGLGETPERFCOUNTERINFOINTELPROC) (GLuint queryId, GLuint counterId, GLuint counterNameLength, GLchar* counterName, GLuint counterDescLength, GLchar *counterDesc, GLuint *counterOffset, GLuint *counterDataSize, GLuint *counterTypeEnum, GLuint *counterDataTypeEnum, GLuint64 *rawCounterMaxValue);
typedef void (__stdcall * PFNGLGETPERFQUERYDATAINTELPROC) (GLuint queryHandle, GLuint flags, GLsizei dataSize, void *data, GLuint *bytesWritten);
typedef void (__stdcall * PFNGLGETPERFQUERYIDBYNAMEINTELPROC) (GLchar* queryName, GLuint *queryId);
typedef void (__stdcall * PFNGLGETPERFQUERYINFOINTELPROC) (GLuint queryId, GLuint queryNameLength, GLchar* queryName, GLuint *dataSize, GLuint *noCounters, GLuint *noInstances, GLuint *capsMask);














#line 13569 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLTEXSCISSORFUNCINTELPROC) (GLenum target, GLenum lfunc, GLenum hfunc);
typedef void (__stdcall * PFNGLTEXSCISSORINTELPROC) (GLenum target, GLclampf tlow, GLclampf thigh);






#line 13584 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 





















typedef void (__stdcall * PFNGLBLENDBARRIERKHRPROC) (void);





#line 13614 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 13623 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 13632 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 













































typedef void (__stdcall *GLDEBUGPROC)(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* message, const void* userParam);

typedef void (__stdcall * PFNGLDEBUGMESSAGECALLBACKPROC) (GLDEBUGPROC callback, const void *userParam);
typedef void (__stdcall * PFNGLDEBUGMESSAGECONTROLPROC) (GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint* ids, GLboolean enabled);
typedef void (__stdcall * PFNGLDEBUGMESSAGEINSERTPROC) (GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* buf);
typedef GLuint (__stdcall * PFNGLGETDEBUGMESSAGELOGPROC) (GLuint count, GLsizei bufSize, GLenum* sources, GLenum* types, GLuint* ids, GLenum* severities, GLsizei* lengths, GLchar* messageLog);
typedef void (__stdcall * PFNGLGETOBJECTLABELPROC) (GLenum identifier, GLuint name, GLsizei bufSize, GLsizei* length, GLchar *label);
typedef void (__stdcall * PFNGLGETOBJECTPTRLABELPROC) (void* ptr, GLsizei bufSize, GLsizei* length, GLchar *label);
typedef void (__stdcall * PFNGLOBJECTLABELPROC) (GLenum identifier, GLuint name, GLsizei length, const GLchar* label);
typedef void (__stdcall * PFNGLOBJECTPTRLABELPROC) (void* ptr, GLsizei length, const GLchar* label);
typedef void (__stdcall * PFNGLPOPDEBUGGROUPPROC) (void);
typedef void (__stdcall * PFNGLPUSHDEBUGGROUPPROC) (GLenum source, GLuint id, GLsizei length, const GLchar * message);














#line 13706 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 13717 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 







typedef void (__stdcall * PFNGLMAXSHADERCOMPILERTHREADSKHRPROC) (GLuint count);





#line 13733 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 13742 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 













typedef void (__stdcall * PFNGLGETNUNIFORMFVPROC) (GLuint program, GLint location, GLsizei bufSize, GLfloat* params);
typedef void (__stdcall * PFNGLGETNUNIFORMIVPROC) (GLuint program, GLint location, GLsizei bufSize, GLint* params);
typedef void (__stdcall * PFNGLGETNUNIFORMUIVPROC) (GLuint program, GLint location, GLsizei bufSize, GLuint* params);
typedef void (__stdcall * PFNGLREADNPIXELSPROC) (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data);








#line 13770 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 



































#line 13808 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 



































#line 13846 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 13855 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









typedef GLuint (__stdcall * PFNGLBUFFERREGIONENABLEDPROC) (void);
typedef void (__stdcall * PFNGLDELETEBUFFERREGIONPROC) (GLenum region);
typedef void (__stdcall * PFNGLDRAWBUFFERREGIONPROC) (GLuint region, GLint x, GLint y, GLsizei width, GLsizei height, GLint xDest, GLint yDest);
typedef GLuint (__stdcall * PFNGLNEWBUFFERREGIONPROC) (GLenum region);
typedef void (__stdcall * PFNGLREADBUFFERREGIONPROC) (GLuint region, GLint x, GLint y, GLsizei width, GLsizei height);









#line 13881 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 













#line 13897 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 13908 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLRESIZEBUFFERSMESAPROC) (void);





#line 13921 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 13930 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLWINDOWPOS2DMESAPROC) (GLdouble x, GLdouble y);
typedef void (__stdcall * PFNGLWINDOWPOS2DVMESAPROC) (const GLdouble* p);
typedef void (__stdcall * PFNGLWINDOWPOS2FMESAPROC) (GLfloat x, GLfloat y);
typedef void (__stdcall * PFNGLWINDOWPOS2FVMESAPROC) (const GLfloat* p);
typedef void (__stdcall * PFNGLWINDOWPOS2IMESAPROC) (GLint x, GLint y);
typedef void (__stdcall * PFNGLWINDOWPOS2IVMESAPROC) (const GLint* p);
typedef void (__stdcall * PFNGLWINDOWPOS2SMESAPROC) (GLshort x, GLshort y);
typedef void (__stdcall * PFNGLWINDOWPOS2SVMESAPROC) (const GLshort* p);
typedef void (__stdcall * PFNGLWINDOWPOS3DMESAPROC) (GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLWINDOWPOS3DVMESAPROC) (const GLdouble* p);
typedef void (__stdcall * PFNGLWINDOWPOS3FMESAPROC) (GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLWINDOWPOS3FVMESAPROC) (const GLfloat* p);
typedef void (__stdcall * PFNGLWINDOWPOS3IMESAPROC) (GLint x, GLint y, GLint z);
typedef void (__stdcall * PFNGLWINDOWPOS3IVMESAPROC) (const GLint* p);
typedef void (__stdcall * PFNGLWINDOWPOS3SMESAPROC) (GLshort x, GLshort y, GLshort z);
typedef void (__stdcall * PFNGLWINDOWPOS3SVMESAPROC) (const GLshort* p);
typedef void (__stdcall * PFNGLWINDOWPOS4DMESAPROC) (GLdouble x, GLdouble y, GLdouble z, GLdouble);
typedef void (__stdcall * PFNGLWINDOWPOS4DVMESAPROC) (const GLdouble* p);
typedef void (__stdcall * PFNGLWINDOWPOS4FMESAPROC) (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLWINDOWPOS4FVMESAPROC) (const GLfloat* p);
typedef void (__stdcall * PFNGLWINDOWPOS4IMESAPROC) (GLint x, GLint y, GLint z, GLint w);
typedef void (__stdcall * PFNGLWINDOWPOS4IVMESAPROC) (const GLint* p);
typedef void (__stdcall * PFNGLWINDOWPOS4SMESAPROC) (GLshort x, GLshort y, GLshort z, GLshort w);
typedef void (__stdcall * PFNGLWINDOWPOS4SVMESAPROC) (const GLshort* p);




























#line 13989 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 










#line 14002 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 14011 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLBEGINCONDITIONALRENDERNVXPROC) (GLuint id);
typedef void (__stdcall * PFNGLENDCONDITIONALRENDERNVXPROC) (void);






#line 14026 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 












#line 14041 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 







typedef void (__stdcall * PFNGLLGPUCOPYIMAGESUBDATANVXPROC) (GLuint sourceGpu, GLbitfield destinationGpuMask, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srxY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);
typedef void (__stdcall * PFNGLLGPUINTERLOCKNVXPROC) (void);
typedef void (__stdcall * PFNGLLGPUNAMEDBUFFERSUBDATANVXPROC) (GLbitfield gpuMask, GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data);







#line 14061 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 












typedef void (__stdcall * PFNGLSTEREOPARAMETERFNVPROC) (GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLSTEREOPARAMETERINVPROC) (GLenum pname, GLint param);






#line 14084 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











#line 14098 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











#line 14112 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 14123 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSNVPROC) (GLenum mode, const void *indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount);
typedef void (__stdcall * PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSNVPROC) (GLenum mode, GLenum type, const void *indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount);






#line 14138 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSCOUNTNVPROC) (GLenum mode, const void *indirect, GLintptr drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount);
typedef void (__stdcall * PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSCOUNTNVPROC) (GLenum mode, GLenum type, const void *indirect, GLintptr drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount);






#line 14153 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef GLuint64 (__stdcall * PFNGLGETIMAGEHANDLENVPROC) (GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format);
typedef GLuint64 (__stdcall * PFNGLGETTEXTUREHANDLENVPROC) (GLuint texture);
typedef GLuint64 (__stdcall * PFNGLGETTEXTURESAMPLERHANDLENVPROC) (GLuint texture, GLuint sampler);
typedef GLboolean (__stdcall * PFNGLISIMAGEHANDLERESIDENTNVPROC) (GLuint64 handle);
typedef GLboolean (__stdcall * PFNGLISTEXTUREHANDLERESIDENTNVPROC) (GLuint64 handle);
typedef void (__stdcall * PFNGLMAKEIMAGEHANDLENONRESIDENTNVPROC) (GLuint64 handle);
typedef void (__stdcall * PFNGLMAKEIMAGEHANDLERESIDENTNVPROC) (GLuint64 handle, GLenum access);
typedef void (__stdcall * PFNGLMAKETEXTUREHANDLENONRESIDENTNVPROC) (GLuint64 handle);
typedef void (__stdcall * PFNGLMAKETEXTUREHANDLERESIDENTNVPROC) (GLuint64 handle);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMHANDLEUI64NVPROC) (GLuint program, GLint location, GLuint64 value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMHANDLEUI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64* values);
typedef void (__stdcall * PFNGLUNIFORMHANDLEUI64NVPROC) (GLint location, GLuint64 value);
typedef void (__stdcall * PFNGLUNIFORMHANDLEUI64VNVPROC) (GLint location, GLsizei count, const GLuint64* value);

















#line 14190 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 























































typedef void (__stdcall * PFNGLBLENDBARRIERNVPROC) (void);
typedef void (__stdcall * PFNGLBLENDPARAMETERINVPROC) (GLenum pname, GLint value);






#line 14256 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 14265 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 14277 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 14286 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








typedef void (__stdcall * PFNGLVIEWPORTPOSITIONWSCALENVPROC) (GLuint index, GLfloat xcoeff, GLfloat ycoeff);





#line 14303 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 
























typedef void (__stdcall * PFNGLCALLCOMMANDLISTNVPROC) (GLuint list);
typedef void (__stdcall * PFNGLCOMMANDLISTSEGMENTSNVPROC) (GLuint list, GLuint segments);
typedef void (__stdcall * PFNGLCOMPILECOMMANDLISTNVPROC) (GLuint list);
typedef void (__stdcall * PFNGLCREATECOMMANDLISTSNVPROC) (GLsizei n, GLuint* lists);
typedef void (__stdcall * PFNGLCREATESTATESNVPROC) (GLsizei n, GLuint* states);
typedef void (__stdcall * PFNGLDELETECOMMANDLISTSNVPROC) (GLsizei n, const GLuint* lists);
typedef void (__stdcall * PFNGLDELETESTATESNVPROC) (GLsizei n, const GLuint* states);
typedef void (__stdcall * PFNGLDRAWCOMMANDSADDRESSNVPROC) (GLenum primitiveMode, const GLuint64* indirects, const GLsizei* sizes, GLuint count);
typedef void (__stdcall * PFNGLDRAWCOMMANDSNVPROC) (GLenum primitiveMode, GLuint buffer, const GLintptr* indirects, const GLsizei* sizes, GLuint count);
typedef void (__stdcall * PFNGLDRAWCOMMANDSSTATESADDRESSNVPROC) (const GLuint64* indirects, const GLsizei* sizes, const GLuint* states, const GLuint* fbos, GLuint count);
typedef void (__stdcall * PFNGLDRAWCOMMANDSSTATESNVPROC) (GLuint buffer, const GLintptr* indirects, const GLsizei* sizes, const GLuint* states, const GLuint* fbos, GLuint count);
typedef GLuint (__stdcall * PFNGLGETCOMMANDHEADERNVPROC) (GLenum tokenID, GLuint size);
typedef GLushort (__stdcall * PFNGLGETSTAGEINDEXNVPROC) (GLenum shadertype);
typedef GLboolean (__stdcall * PFNGLISCOMMANDLISTNVPROC) (GLuint list);
typedef GLboolean (__stdcall * PFNGLISSTATENVPROC) (GLuint state);
typedef void (__stdcall * PFNGLLISTDRAWCOMMANDSSTATESCLIENTNVPROC) (GLuint list, GLuint segment, const void** indirects, const GLsizei* sizes, const GLuint* states, const GLuint* fbos, GLuint count);
typedef void (__stdcall * PFNGLSTATECAPTURENVPROC) (GLuint state, GLenum mode);





















#line 14368 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 14380 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









typedef void (__stdcall * PFNGLBEGINCONDITIONALRENDERNVPROC) (GLuint id, GLenum mode);
typedef void (__stdcall * PFNGLENDCONDITIONALRENDERNVPROC) (void);






#line 14400 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









typedef void (__stdcall * PFNGLSUBPIXELPRECISIONBIASNVPROC) (GLuint xbits, GLuint ybits);





#line 14418 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








typedef void (__stdcall * PFNGLCONSERVATIVERASTERPARAMETERFNVPROC) (GLenum pname, GLfloat value);





#line 14435 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








typedef void (__stdcall * PFNGLCONSERVATIVERASTERPARAMETERINVPROC) (GLenum pname, GLint param);





#line 14452 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 







typedef void (__stdcall * PFNGLCOPYBUFFERSUBDATANVPROC) (GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size);





#line 14468 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 14480 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLCOPYIMAGESUBDATANVPROC) (GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);





#line 14493 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 14505 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









typedef void (__stdcall * PFNGLCLEARDEPTHDNVPROC) (GLdouble depth);
typedef void (__stdcall * PFNGLDEPTHBOUNDSDNVPROC) (GLdouble zmin, GLdouble zmax);
typedef void (__stdcall * PFNGLDEPTHRANGEDNVPROC) (GLdouble zNear, GLdouble zFar);







#line 14527 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 14538 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 












#line 14553 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






































typedef void (__stdcall * PFNGLDRAWBUFFERSNVPROC) (GLsizei n, const GLenum* bufs);





#line 14600 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLDRAWARRAYSINSTANCEDNVPROC) (GLenum mode, GLint first, GLsizei count, GLsizei primcount);
typedef void (__stdcall * PFNGLDRAWELEMENTSINSTANCEDNVPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount);






#line 14615 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLDRAWTEXTURENVPROC) (GLuint texture, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1);





#line 14628 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall *GLVULKANPROCNV)(void);

typedef void (__stdcall * PFNGLDRAWVKIMAGENVPROC) (GLuint64 vkImage, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1);
typedef GLVULKANPROCNV (__stdcall * PFNGLGETVKPROCADDRNVPROC) (const GLchar* name);
typedef void (__stdcall * PFNGLSIGNALVKFENCENVPROC) (GLuint64 vkFence);
typedef void (__stdcall * PFNGLSIGNALVKSEMAPHORENVPROC) (GLuint64 vkSemaphore);
typedef void (__stdcall * PFNGLWAITVKSEMAPHORENVPROC) (GLuint64 vkSemaphore);









#line 14651 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 





























typedef void (__stdcall * PFNGLEVALMAPSNVPROC) (GLenum target, GLenum mode);
typedef void (__stdcall * PFNGLGETMAPATTRIBPARAMETERFVNVPROC) (GLenum target, GLuint index, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETMAPATTRIBPARAMETERIVNVPROC) (GLenum target, GLuint index, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETMAPCONTROLPOINTSNVPROC) (GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, void *points);
typedef void (__stdcall * PFNGLGETMAPPARAMETERFVNVPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETMAPPARAMETERIVNVPROC) (GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLMAPCONTROLPOINTSNVPROC) (GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const void *points);
typedef void (__stdcall * PFNGLMAPPARAMETERFVNVPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLMAPPARAMETERIVNVPROC) (GLenum target, GLenum pname, const GLint* params);













#line 14705 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 14714 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 















typedef void (__stdcall * PFNGLGETMULTISAMPLEFVNVPROC) (GLenum pname, GLuint index, GLfloat* val);
typedef void (__stdcall * PFNGLSAMPLEMASKINDEXEDNVPROC) (GLuint index, GLbitfield mask);
typedef void (__stdcall * PFNGLTEXRENDERBUFFERNVPROC) (GLenum target, GLuint renderbuffer);







#line 14742 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 
























#line 14769 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








typedef void (__stdcall * PFNGLDELETEFENCESNVPROC) (GLsizei n, const GLuint* fences);
typedef void (__stdcall * PFNGLFINISHFENCENVPROC) (GLuint fence);
typedef void (__stdcall * PFNGLGENFENCESNVPROC) (GLsizei n, GLuint* fences);
typedef void (__stdcall * PFNGLGETFENCEIVNVPROC) (GLuint fence, GLenum pname, GLint* params);
typedef GLboolean (__stdcall * PFNGLISFENCENVPROC) (GLuint fence);
typedef void (__stdcall * PFNGLSETFENCENVPROC) (GLuint fence, GLenum condition);
typedef GLboolean (__stdcall * PFNGLTESTFENCENVPROC) (GLuint fence);











#line 14798 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 14809 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






















#line 14834 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 










#line 14847 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 







typedef void (__stdcall * PFNGLFRAGMENTCOVERAGECOLORNVPROC) (GLuint color);





#line 14863 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











typedef void (__stdcall * PFNGLGETPROGRAMNAMEDPARAMETERDVNVPROC) (GLuint id, GLsizei len, const GLubyte* name, GLdouble *params);
typedef void (__stdcall * PFNGLGETPROGRAMNAMEDPARAMETERFVNVPROC) (GLuint id, GLsizei len, const GLubyte* name, GLfloat *params);
typedef void (__stdcall * PFNGLPROGRAMNAMEDPARAMETER4DNVPROC) (GLuint id, GLsizei len, const GLubyte* name, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLPROGRAMNAMEDPARAMETER4DVNVPROC) (GLuint id, GLsizei len, const GLubyte* name, const GLdouble v[]);
typedef void (__stdcall * PFNGLPROGRAMNAMEDPARAMETER4FNVPROC) (GLuint id, GLsizei len, const GLubyte* name, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLPROGRAMNAMEDPARAMETER4FVNVPROC) (GLuint id, GLsizei len, const GLubyte* name, const GLfloat v[]);










#line 14893 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 












#line 14908 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 14917 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 14926 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 14935 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









typedef void (__stdcall * PFNGLBLITFRAMEBUFFERNVPROC) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);





#line 14953 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 





















#line 14977 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








typedef void (__stdcall * PFNGLRENDERBUFFERSTORAGEMULTISAMPLENVPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);





#line 14994 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









typedef void (__stdcall * PFNGLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENVPROC) (GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height);





#line 15012 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 15021 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








typedef void (__stdcall * PFNGLPROGRAMVERTEXLIMITNVPROC) (GLenum target, GLint limit);





#line 15038 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 15047 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 15056 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 










typedef void (__stdcall * PFNGLMULTICASTBARRIERNVPROC) (void);
typedef void (__stdcall * PFNGLMULTICASTBLITFRAMEBUFFERNVPROC) (GLuint srcGpu, GLuint dstGpu, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
typedef void (__stdcall * PFNGLMULTICASTBUFFERSUBDATANVPROC) (GLbitfield gpuMask, GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data);
typedef void (__stdcall * PFNGLMULTICASTCOPYBUFFERSUBDATANVPROC) (GLuint readGpu, GLbitfield writeGpuMask, GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
typedef void (__stdcall * PFNGLMULTICASTCOPYIMAGESUBDATANVPROC) (GLuint srcGpu, GLbitfield dstGpuMask, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);
typedef void (__stdcall * PFNGLMULTICASTFRAMEBUFFERSAMPLELOCATIONSFVNVPROC) (GLuint gpu, GLuint framebuffer, GLuint start, GLsizei count, const GLfloat* v);
typedef void (__stdcall * PFNGLMULTICASTGETQUERYOBJECTI64VNVPROC) (GLuint gpu, GLuint id, GLenum pname, GLint64* params);
typedef void (__stdcall * PFNGLMULTICASTGETQUERYOBJECTIVNVPROC) (GLuint gpu, GLuint id, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLMULTICASTGETQUERYOBJECTUI64VNVPROC) (GLuint gpu, GLuint id, GLenum pname, GLuint64* params);
typedef void (__stdcall * PFNGLMULTICASTGETQUERYOBJECTUIVNVPROC) (GLuint gpu, GLuint id, GLenum pname, GLuint* params);
typedef void (__stdcall * PFNGLMULTICASTWAITSYNCNVPROC) (GLuint signalGpu, GLbitfield waitGpuMask);
typedef void (__stdcall * PFNGLRENDERGPUMASKNVPROC) (GLbitfield mask);
















#line 15097 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 













typedef void (__stdcall * PFNGLPROGRAMENVPARAMETERI4INVPROC) (GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void (__stdcall * PFNGLPROGRAMENVPARAMETERI4IVNVPROC) (GLenum target, GLuint index, const GLint *params);
typedef void (__stdcall * PFNGLPROGRAMENVPARAMETERI4UINVPROC) (GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void (__stdcall * PFNGLPROGRAMENVPARAMETERI4UIVNVPROC) (GLenum target, GLuint index, const GLuint *params);
typedef void (__stdcall * PFNGLPROGRAMENVPARAMETERSI4IVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLint *params);
typedef void (__stdcall * PFNGLPROGRAMENVPARAMETERSI4UIVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLuint *params);
typedef void (__stdcall * PFNGLPROGRAMLOCALPARAMETERI4INVPROC) (GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void (__stdcall * PFNGLPROGRAMLOCALPARAMETERI4IVNVPROC) (GLenum target, GLuint index, const GLint *params);
typedef void (__stdcall * PFNGLPROGRAMLOCALPARAMETERI4UINVPROC) (GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void (__stdcall * PFNGLPROGRAMLOCALPARAMETERI4UIVNVPROC) (GLenum target, GLuint index, const GLuint *params);
typedef void (__stdcall * PFNGLPROGRAMLOCALPARAMETERSI4IVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLint *params);
typedef void (__stdcall * PFNGLPROGRAMLOCALPARAMETERSI4UIVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLuint *params);
















#line 15141 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 













#line 15157 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 15166 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 15175 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 

































typedef void (__stdcall * PFNGLGETUNIFORMI64VNVPROC) (GLuint program, GLint location, GLint64EXT* params);
typedef void (__stdcall * PFNGLGETUNIFORMUI64VNVPROC) (GLuint program, GLint location, GLuint64EXT* params);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1I64NVPROC) (GLuint program, GLint location, GLint64EXT x);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1I64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1UI64NVPROC) (GLuint program, GLint location, GLuint64EXT x);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1UI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2I64NVPROC) (GLuint program, GLint location, GLint64EXT x, GLint64EXT y);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2I64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2UI64NVPROC) (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2UI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3I64NVPROC) (GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3I64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3UI64NVPROC) (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3UI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4I64NVPROC) (GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4I64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4UI64NVPROC) (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4UI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
typedef void (__stdcall * PFNGLUNIFORM1I64NVPROC) (GLint location, GLint64EXT x);
typedef void (__stdcall * PFNGLUNIFORM1I64VNVPROC) (GLint location, GLsizei count, const GLint64EXT* value);
typedef void (__stdcall * PFNGLUNIFORM1UI64NVPROC) (GLint location, GLuint64EXT x);
typedef void (__stdcall * PFNGLUNIFORM1UI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);
typedef void (__stdcall * PFNGLUNIFORM2I64NVPROC) (GLint location, GLint64EXT x, GLint64EXT y);
typedef void (__stdcall * PFNGLUNIFORM2I64VNVPROC) (GLint location, GLsizei count, const GLint64EXT* value);
typedef void (__stdcall * PFNGLUNIFORM2UI64NVPROC) (GLint location, GLuint64EXT x, GLuint64EXT y);
typedef void (__stdcall * PFNGLUNIFORM2UI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);
typedef void (__stdcall * PFNGLUNIFORM3I64NVPROC) (GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z);
typedef void (__stdcall * PFNGLUNIFORM3I64VNVPROC) (GLint location, GLsizei count, const GLint64EXT* value);
typedef void (__stdcall * PFNGLUNIFORM3UI64NVPROC) (GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
typedef void (__stdcall * PFNGLUNIFORM3UI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);
typedef void (__stdcall * PFNGLUNIFORM4I64NVPROC) (GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
typedef void (__stdcall * PFNGLUNIFORM4I64VNVPROC) (GLint location, GLsizei count, const GLint64EXT* value);
typedef void (__stdcall * PFNGLUNIFORM4UI64NVPROC) (GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
typedef void (__stdcall * PFNGLUNIFORM4UI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);






































#line 15283 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






typedef unsigned short GLhalf;

typedef void (__stdcall * PFNGLCOLOR3HNVPROC) (GLhalf red, GLhalf green, GLhalf blue);
typedef void (__stdcall * PFNGLCOLOR3HVNVPROC) (const GLhalf* v);
typedef void (__stdcall * PFNGLCOLOR4HNVPROC) (GLhalf red, GLhalf green, GLhalf blue, GLhalf alpha);
typedef void (__stdcall * PFNGLCOLOR4HVNVPROC) (const GLhalf* v);
typedef void (__stdcall * PFNGLFOGCOORDHNVPROC) (GLhalf fog);
typedef void (__stdcall * PFNGLFOGCOORDHVNVPROC) (const GLhalf* fog);
typedef void (__stdcall * PFNGLMULTITEXCOORD1HNVPROC) (GLenum target, GLhalf s);
typedef void (__stdcall * PFNGLMULTITEXCOORD1HVNVPROC) (GLenum target, const GLhalf* v);
typedef void (__stdcall * PFNGLMULTITEXCOORD2HNVPROC) (GLenum target, GLhalf s, GLhalf t);
typedef void (__stdcall * PFNGLMULTITEXCOORD2HVNVPROC) (GLenum target, const GLhalf* v);
typedef void (__stdcall * PFNGLMULTITEXCOORD3HNVPROC) (GLenum target, GLhalf s, GLhalf t, GLhalf r);
typedef void (__stdcall * PFNGLMULTITEXCOORD3HVNVPROC) (GLenum target, const GLhalf* v);
typedef void (__stdcall * PFNGLMULTITEXCOORD4HNVPROC) (GLenum target, GLhalf s, GLhalf t, GLhalf r, GLhalf q);
typedef void (__stdcall * PFNGLMULTITEXCOORD4HVNVPROC) (GLenum target, const GLhalf* v);
typedef void (__stdcall * PFNGLNORMAL3HNVPROC) (GLhalf nx, GLhalf ny, GLhalf nz);
typedef void (__stdcall * PFNGLNORMAL3HVNVPROC) (const GLhalf* v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3HNVPROC) (GLhalf red, GLhalf green, GLhalf blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3HVNVPROC) (const GLhalf* v);
typedef void (__stdcall * PFNGLTEXCOORD1HNVPROC) (GLhalf s);
typedef void (__stdcall * PFNGLTEXCOORD1HVNVPROC) (const GLhalf* v);
typedef void (__stdcall * PFNGLTEXCOORD2HNVPROC) (GLhalf s, GLhalf t);
typedef void (__stdcall * PFNGLTEXCOORD2HVNVPROC) (const GLhalf* v);
typedef void (__stdcall * PFNGLTEXCOORD3HNVPROC) (GLhalf s, GLhalf t, GLhalf r);
typedef void (__stdcall * PFNGLTEXCOORD3HVNVPROC) (const GLhalf* v);
typedef void (__stdcall * PFNGLTEXCOORD4HNVPROC) (GLhalf s, GLhalf t, GLhalf r, GLhalf q);
typedef void (__stdcall * PFNGLTEXCOORD4HVNVPROC) (const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEX2HNVPROC) (GLhalf x, GLhalf y);
typedef void (__stdcall * PFNGLVERTEX2HVNVPROC) (const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEX3HNVPROC) (GLhalf x, GLhalf y, GLhalf z);
typedef void (__stdcall * PFNGLVERTEX3HVNVPROC) (const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEX4HNVPROC) (GLhalf x, GLhalf y, GLhalf z, GLhalf w);
typedef void (__stdcall * PFNGLVERTEX4HVNVPROC) (const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB1HNVPROC) (GLuint index, GLhalf x);
typedef void (__stdcall * PFNGLVERTEXATTRIB1HVNVPROC) (GLuint index, const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB2HNVPROC) (GLuint index, GLhalf x, GLhalf y);
typedef void (__stdcall * PFNGLVERTEXATTRIB2HVNVPROC) (GLuint index, const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB3HNVPROC) (GLuint index, GLhalf x, GLhalf y, GLhalf z);
typedef void (__stdcall * PFNGLVERTEXATTRIB3HVNVPROC) (GLuint index, const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4HNVPROC) (GLuint index, GLhalf x, GLhalf y, GLhalf z, GLhalf w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4HVNVPROC) (GLuint index, const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS1HVNVPROC) (GLuint index, GLsizei n, const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS2HVNVPROC) (GLuint index, GLsizei n, const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS3HVNVPROC) (GLuint index, GLsizei n, const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS4HVNVPROC) (GLuint index, GLsizei n, const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEXWEIGHTHNVPROC) (GLhalf weight);
typedef void (__stdcall * PFNGLVERTEXWEIGHTHVNVPROC) (const GLhalf* weight);


















































#line 15390 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 15399 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






typedef void (__stdcall * PFNGLVERTEXATTRIBDIVISORNVPROC) (GLuint index, GLuint divisor);





#line 15414 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









typedef void (__stdcall * PFNGLGETINTERNALFORMATSAMPLEIVNVPROC) (GLenum target, GLenum internalformat, GLsizei samples, GLenum pname, GLsizei bufSize, GLint* params);





#line 15432 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 15444 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 15455 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 15466 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











typedef void (__stdcall * PFNGLUNIFORMMATRIX2X3FVNVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX2X4FVNVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX3X2FVNVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX3X4FVNVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX4X2FVNVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX4X3FVNVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);










#line 15496 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









typedef void (__stdcall * PFNGLBEGINOCCLUSIONQUERYNVPROC) (GLuint id);
typedef void (__stdcall * PFNGLDELETEOCCLUSIONQUERIESNVPROC) (GLsizei n, const GLuint* ids);
typedef void (__stdcall * PFNGLENDOCCLUSIONQUERYNVPROC) (void);
typedef void (__stdcall * PFNGLGENOCCLUSIONQUERIESNVPROC) (GLsizei n, GLuint* ids);
typedef void (__stdcall * PFNGLGETOCCLUSIONQUERYIVNVPROC) (GLuint id, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETOCCLUSIONQUERYUIVNVPROC) (GLuint id, GLenum pname, GLuint* params);
typedef GLboolean (__stdcall * PFNGLISOCCLUSIONQUERYNVPROC) (GLuint id);











#line 15526 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 










#line 15539 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 15551 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 15563 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 15575 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 










typedef void (__stdcall * PFNGLPROGRAMBUFFERPARAMETERSIIVNVPROC) (GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLint *params);
typedef void (__stdcall * PFNGLPROGRAMBUFFERPARAMETERSIUIVNVPROC) (GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLuint *params);
typedef void (__stdcall * PFNGLPROGRAMBUFFERPARAMETERSFVNVPROC) (GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLfloat *params);







#line 15598 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 15607 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 


























































































































































typedef void (__stdcall * PFNGLCOPYPATHNVPROC) (GLuint resultPath, GLuint srcPath);
typedef void (__stdcall * PFNGLCOVERFILLPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues);
typedef void (__stdcall * PFNGLCOVERFILLPATHNVPROC) (GLuint path, GLenum coverMode);
typedef void (__stdcall * PFNGLCOVERSTROKEPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues);
typedef void (__stdcall * PFNGLCOVERSTROKEPATHNVPROC) (GLuint path, GLenum coverMode);
typedef void (__stdcall * PFNGLDELETEPATHSNVPROC) (GLuint path, GLsizei range);
typedef GLuint (__stdcall * PFNGLGENPATHSNVPROC) (GLsizei range);
typedef void (__stdcall * PFNGLGETPATHCOLORGENFVNVPROC) (GLenum color, GLenum pname, GLfloat* value);
typedef void (__stdcall * PFNGLGETPATHCOLORGENIVNVPROC) (GLenum color, GLenum pname, GLint* value);
typedef void (__stdcall * PFNGLGETPATHCOMMANDSNVPROC) (GLuint path, GLubyte* commands);
typedef void (__stdcall * PFNGLGETPATHCOORDSNVPROC) (GLuint path, GLfloat* coords);
typedef void (__stdcall * PFNGLGETPATHDASHARRAYNVPROC) (GLuint path, GLfloat* dashArray);
typedef GLfloat (__stdcall * PFNGLGETPATHLENGTHNVPROC) (GLuint path, GLsizei startSegment, GLsizei numSegments);
typedef void (__stdcall * PFNGLGETPATHMETRICRANGENVPROC) (GLbitfield metricQueryMask, GLuint firstPathName, GLsizei numPaths, GLsizei stride, GLfloat* metrics);
typedef void (__stdcall * PFNGLGETPATHMETRICSNVPROC) (GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLsizei stride, GLfloat *metrics);
typedef void (__stdcall * PFNGLGETPATHPARAMETERFVNVPROC) (GLuint path, GLenum pname, GLfloat* value);
typedef void (__stdcall * PFNGLGETPATHPARAMETERIVNVPROC) (GLuint path, GLenum pname, GLint* value);
typedef void (__stdcall * PFNGLGETPATHSPACINGNVPROC) (GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat *returnedSpacing);
typedef void (__stdcall * PFNGLGETPATHTEXGENFVNVPROC) (GLenum texCoordSet, GLenum pname, GLfloat* value);
typedef void (__stdcall * PFNGLGETPATHTEXGENIVNVPROC) (GLenum texCoordSet, GLenum pname, GLint* value);
typedef void (__stdcall * PFNGLGETPROGRAMRESOURCEFVNVPROC) (GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum* props, GLsizei bufSize, GLsizei *length, GLfloat *params);
typedef void (__stdcall * PFNGLINTERPOLATEPATHSNVPROC) (GLuint resultPath, GLuint pathA, GLuint pathB, GLfloat weight);
typedef GLboolean (__stdcall * PFNGLISPATHNVPROC) (GLuint path);
typedef GLboolean (__stdcall * PFNGLISPOINTINFILLPATHNVPROC) (GLuint path, GLuint mask, GLfloat x, GLfloat y);
typedef GLboolean (__stdcall * PFNGLISPOINTINSTROKEPATHNVPROC) (GLuint path, GLfloat x, GLfloat y);
typedef void (__stdcall * PFNGLMATRIXLOAD3X2FNVPROC) (GLenum matrixMode, const GLfloat* m);
typedef void (__stdcall * PFNGLMATRIXLOAD3X3FNVPROC) (GLenum matrixMode, const GLfloat* m);
typedef void (__stdcall * PFNGLMATRIXLOADTRANSPOSE3X3FNVPROC) (GLenum matrixMode, const GLfloat* m);
typedef void (__stdcall * PFNGLMATRIXMULT3X2FNVPROC) (GLenum matrixMode, const GLfloat* m);
typedef void (__stdcall * PFNGLMATRIXMULT3X3FNVPROC) (GLenum matrixMode, const GLfloat* m);
typedef void (__stdcall * PFNGLMATRIXMULTTRANSPOSE3X3FNVPROC) (GLenum matrixMode, const GLfloat* m);
typedef void (__stdcall * PFNGLPATHCOLORGENNVPROC) (GLenum color, GLenum genMode, GLenum colorFormat, const GLfloat* coeffs);
typedef void (__stdcall * PFNGLPATHCOMMANDSNVPROC) (GLuint path, GLsizei numCommands, const GLubyte* commands, GLsizei numCoords, GLenum coordType, const void*coords);
typedef void (__stdcall * PFNGLPATHCOORDSNVPROC) (GLuint path, GLsizei numCoords, GLenum coordType, const void *coords);
typedef void (__stdcall * PFNGLPATHCOVERDEPTHFUNCNVPROC) (GLenum zfunc);
typedef void (__stdcall * PFNGLPATHDASHARRAYNVPROC) (GLuint path, GLsizei dashCount, const GLfloat* dashArray);
typedef void (__stdcall * PFNGLPATHFOGGENNVPROC) (GLenum genMode);
typedef GLenum (__stdcall * PFNGLPATHGLYPHINDEXARRAYNVPROC) (GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
typedef GLenum (__stdcall * PFNGLPATHGLYPHINDEXRANGENVPROC) (GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLuint pathParameterTemplate, GLfloat emScale, GLuint baseAndCount[2]);
typedef void (__stdcall * PFNGLPATHGLYPHRANGENVPROC) (GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
typedef void (__stdcall * PFNGLPATHGLYPHSNVPROC) (GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const void*charcodes, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
typedef GLenum (__stdcall * PFNGLPATHMEMORYGLYPHINDEXARRAYNVPROC) (GLuint firstPathName, GLenum fontTarget, GLsizeiptr fontSize, const void *fontData, GLsizei faceIndex, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
typedef void (__stdcall * PFNGLPATHPARAMETERFNVPROC) (GLuint path, GLenum pname, GLfloat value);
typedef void (__stdcall * PFNGLPATHPARAMETERFVNVPROC) (GLuint path, GLenum pname, const GLfloat* value);
typedef void (__stdcall * PFNGLPATHPARAMETERINVPROC) (GLuint path, GLenum pname, GLint value);
typedef void (__stdcall * PFNGLPATHPARAMETERIVNVPROC) (GLuint path, GLenum pname, const GLint* value);
typedef void (__stdcall * PFNGLPATHSTENCILDEPTHOFFSETNVPROC) (GLfloat factor, GLfloat units);
typedef void (__stdcall * PFNGLPATHSTENCILFUNCNVPROC) (GLenum func, GLint ref, GLuint mask);
typedef void (__stdcall * PFNGLPATHSTRINGNVPROC) (GLuint path, GLenum format, GLsizei length, const void *pathString);
typedef void (__stdcall * PFNGLPATHSUBCOMMANDSNVPROC) (GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const GLubyte* commands, GLsizei numCoords, GLenum coordType, const void*coords);
typedef void (__stdcall * PFNGLPATHSUBCOORDSNVPROC) (GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const void *coords);
typedef void (__stdcall * PFNGLPATHTEXGENNVPROC) (GLenum texCoordSet, GLenum genMode, GLint components, const GLfloat* coeffs);
typedef GLboolean (__stdcall * PFNGLPOINTALONGPATHNVPROC) (GLuint path, GLsizei startSegment, GLsizei numSegments, GLfloat distance, GLfloat* x, GLfloat *y, GLfloat *tangentX, GLfloat *tangentY);
typedef void (__stdcall * PFNGLPROGRAMPATHFRAGMENTINPUTGENNVPROC) (GLuint program, GLint location, GLenum genMode, GLint components, const GLfloat* coeffs);
typedef void (__stdcall * PFNGLSTENCILFILLPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const GLfloat *transformValues);
typedef void (__stdcall * PFNGLSTENCILFILLPATHNVPROC) (GLuint path, GLenum fillMode, GLuint mask);
typedef void (__stdcall * PFNGLSTENCILSTROKEPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const GLfloat *transformValues);
typedef void (__stdcall * PFNGLSTENCILSTROKEPATHNVPROC) (GLuint path, GLint reference, GLuint mask);
typedef void (__stdcall * PFNGLSTENCILTHENCOVERFILLPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat *transformValues);
typedef void (__stdcall * PFNGLSTENCILTHENCOVERFILLPATHNVPROC) (GLuint path, GLenum fillMode, GLuint mask, GLenum coverMode);
typedef void (__stdcall * PFNGLSTENCILTHENCOVERSTROKEPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLint reference, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat *transformValues);
typedef void (__stdcall * PFNGLSTENCILTHENCOVERSTROKEPATHNVPROC) (GLuint path, GLint reference, GLuint mask, GLenum coverMode);
typedef void (__stdcall * PFNGLTRANSFORMPATHNVPROC) (GLuint resultPath, GLuint srcPath, GLenum transformType, const GLfloat* transformValues);
typedef void (__stdcall * PFNGLWEIGHTPATHSNVPROC) (GLuint resultPath, GLsizei numPaths, const GLuint paths[], const GLfloat weights[]);




































































#line 15896 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 15907 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











#line 15921 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











typedef void (__stdcall * PFNGLFLUSHPIXELDATARANGENVPROC) (GLenum target);
typedef void (__stdcall * PFNGLPIXELDATARANGENVPROC) (GLenum target, GLsizei length, void *pointer);






#line 15943 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 15954 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








typedef void (__stdcall * PFNGLPOINTPARAMETERINVPROC) (GLenum pname, GLint param);
typedef void (__stdcall * PFNGLPOINTPARAMETERIVNVPROC) (GLenum pname, const GLint* params);






#line 15973 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











typedef void (__stdcall * PFNGLPOLYGONMODENVPROC) (GLenum face, GLenum mode);





#line 15993 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











typedef void (__stdcall * PFNGLGETVIDEOI64VNVPROC) (GLuint video_slot, GLenum pname, GLint64EXT* params);
typedef void (__stdcall * PFNGLGETVIDEOIVNVPROC) (GLuint video_slot, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETVIDEOUI64VNVPROC) (GLuint video_slot, GLenum pname, GLuint64EXT* params);
typedef void (__stdcall * PFNGLGETVIDEOUIVNVPROC) (GLuint video_slot, GLenum pname, GLuint* params);
typedef void (__stdcall * PFNGLPRESENTFRAMEDUALFILLNVPROC) (GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLenum target1, GLuint fill1, GLenum target2, GLuint fill2, GLenum target3, GLuint fill3);
typedef void (__stdcall * PFNGLPRESENTFRAMEKEYEDNVPROC) (GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLuint key0, GLenum target1, GLuint fill1, GLuint key1);










#line 16023 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 







typedef void (__stdcall * PFNGLPRIMITIVERESTARTINDEXNVPROC) (GLuint index);
typedef void (__stdcall * PFNGLPRIMITIVERESTARTNVPROC) (void);






#line 16041 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 16050 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 16059 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 16068 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 
























































typedef void (__stdcall * PFNGLCOMBINERINPUTNVPROC) (GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);
typedef void (__stdcall * PFNGLCOMBINEROUTPUTNVPROC) (GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum);
typedef void (__stdcall * PFNGLCOMBINERPARAMETERFNVPROC) (GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLCOMBINERPARAMETERFVNVPROC) (GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLCOMBINERPARAMETERINVPROC) (GLenum pname, GLint param);
typedef void (__stdcall * PFNGLCOMBINERPARAMETERIVNVPROC) (GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLFINALCOMBINERINPUTNVPROC) (GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);
typedef void (__stdcall * PFNGLGETCOMBINERINPUTPARAMETERFVNVPROC) (GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETCOMBINERINPUTPARAMETERIVNVPROC) (GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETCOMBINEROUTPUTPARAMETERFVNVPROC) (GLenum stage, GLenum portion, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETCOMBINEROUTPUTPARAMETERIVNVPROC) (GLenum stage, GLenum portion, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETFINALCOMBINERINPUTPARAMETERFVNVPROC) (GLenum variable, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETFINALCOMBINERINPUTPARAMETERIVNVPROC) (GLenum variable, GLenum pname, GLint* params);

















#line 16157 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






typedef void (__stdcall * PFNGLCOMBINERSTAGEPARAMETERFVNVPROC) (GLenum stage, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLGETCOMBINERSTAGEPARAMETERFVNVPROC) (GLenum stage, GLenum pname, GLfloat* params);






#line 16174 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 16186 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 

















#line 16206 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 













typedef void (__stdcall * PFNGLFRAMEBUFFERSAMPLELOCATIONSFVNVPROC) (GLenum target, GLuint start, GLsizei count, const GLfloat* v);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVNVPROC) (GLuint framebuffer, GLuint start, GLsizei count, const GLfloat* v);






#line 16230 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 16239 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 16248 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 16257 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 16266 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 16275 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 16284 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








typedef void (__stdcall * PFNGLGETBUFFERPARAMETERUI64VNVPROC) (GLenum target, GLenum pname, GLuint64EXT* params);
typedef void (__stdcall * PFNGLGETINTEGERUI64VNVPROC) (GLenum value, GLuint64EXT* result);
typedef void (__stdcall * PFNGLGETNAMEDBUFFERPARAMETERUI64VNVPROC) (GLuint buffer, GLenum pname, GLuint64EXT* params);
typedef GLboolean (__stdcall * PFNGLISBUFFERRESIDENTNVPROC) (GLenum target);
typedef GLboolean (__stdcall * PFNGLISNAMEDBUFFERRESIDENTNVPROC) (GLuint buffer);
typedef void (__stdcall * PFNGLMAKEBUFFERNONRESIDENTNVPROC) (GLenum target);
typedef void (__stdcall * PFNGLMAKEBUFFERRESIDENTNVPROC) (GLenum target, GLenum access);
typedef void (__stdcall * PFNGLMAKENAMEDBUFFERNONRESIDENTNVPROC) (GLuint buffer);
typedef void (__stdcall * PFNGLMAKENAMEDBUFFERRESIDENTNVPROC) (GLuint buffer, GLenum access);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMUI64NVPROC) (GLuint program, GLint location, GLuint64EXT value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMUI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
typedef void (__stdcall * PFNGLUNIFORMUI64NVPROC) (GLint location, GLuint64EXT value);
typedef void (__stdcall * PFNGLUNIFORMUI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);

















#line 16325 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 16334 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 16343 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 










#line 16356 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 16365 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 16376 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 16387 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 16396 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 












#line 16411 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 










#line 16424 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 16436 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 












typedef void (__stdcall * PFNGLCOMPRESSEDTEXIMAGE3DNVPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXSUBIMAGE3DNVPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOPYTEXSUBIMAGE3DNVPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTURELAYERNVPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void (__stdcall * PFNGLTEXIMAGE3DNVPROC) (GLenum target, GLint level, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLTEXSUBIMAGE3DNVPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);










#line 16467 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLTEXTUREBARRIERNVPROC) (void);





#line 16480 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 16492 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











#line 16506 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











#line 16520 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 16529 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 16538 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 












#line 16553 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 16564 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 







typedef void (__stdcall * PFNGLTEXIMAGE2DMULTISAMPLECOVERAGENVPROC) (GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
typedef void (__stdcall * PFNGLTEXIMAGE3DMULTISAMPLECOVERAGENVPROC) (GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
typedef void (__stdcall * PFNGLTEXTUREIMAGE2DMULTISAMPLECOVERAGENVPROC) (GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
typedef void (__stdcall * PFNGLTEXTUREIMAGE2DMULTISAMPLENVPROC) (GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
typedef void (__stdcall * PFNGLTEXTUREIMAGE3DMULTISAMPLECOVERAGENVPROC) (GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
typedef void (__stdcall * PFNGLTEXTUREIMAGE3DMULTISAMPLENVPROC) (GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);










#line 16590 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 16599 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











#line 16613 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 16622 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 
















































































#line 16705 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 



































#line 16743 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 
























#line 16770 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






























typedef void (__stdcall * PFNGLACTIVEVARYINGNVPROC) (GLuint program, const GLchar *name);
typedef void (__stdcall * PFNGLBEGINTRANSFORMFEEDBACKNVPROC) (GLenum primitiveMode);
typedef void (__stdcall * PFNGLBINDBUFFERBASENVPROC) (GLenum target, GLuint index, GLuint buffer);
typedef void (__stdcall * PFNGLBINDBUFFEROFFSETNVPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset);
typedef void (__stdcall * PFNGLBINDBUFFERRANGENVPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void (__stdcall * PFNGLENDTRANSFORMFEEDBACKNVPROC) (void);
typedef void (__stdcall * PFNGLGETACTIVEVARYINGNVPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name);
typedef void (__stdcall * PFNGLGETTRANSFORMFEEDBACKVARYINGNVPROC) (GLuint program, GLuint index, GLint *location);
typedef GLint (__stdcall * PFNGLGETVARYINGLOCATIONNVPROC) (GLuint program, const GLchar *name);
typedef void (__stdcall * PFNGLTRANSFORMFEEDBACKATTRIBSNVPROC) (GLuint count, const GLint *attribs, GLenum bufferMode);
typedef void (__stdcall * PFNGLTRANSFORMFEEDBACKVARYINGSNVPROC) (GLuint program, GLsizei count, const GLint *locations, GLenum bufferMode);















#line 16829 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









typedef void (__stdcall * PFNGLBINDTRANSFORMFEEDBACKNVPROC) (GLenum target, GLuint id);
typedef void (__stdcall * PFNGLDELETETRANSFORMFEEDBACKSNVPROC) (GLsizei n, const GLuint* ids);
typedef void (__stdcall * PFNGLDRAWTRANSFORMFEEDBACKNVPROC) (GLenum mode, GLuint id);
typedef void (__stdcall * PFNGLGENTRANSFORMFEEDBACKSNVPROC) (GLsizei n, GLuint* ids);
typedef GLboolean (__stdcall * PFNGLISTRANSFORMFEEDBACKNVPROC) (GLuint id);
typedef void (__stdcall * PFNGLPAUSETRANSFORMFEEDBACKNVPROC) (void);
typedef void (__stdcall * PFNGLRESUMETRANSFORMFEEDBACKNVPROC) (void);











#line 16859 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 










#line 16872 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









typedef GLintptr GLvdpauSurfaceNV;

typedef void (__stdcall * PFNGLVDPAUFININVPROC) (void);
typedef void (__stdcall * PFNGLVDPAUGETSURFACEIVNVPROC) (GLvdpauSurfaceNV surface, GLenum pname, GLsizei bufSize, GLsizei* length, GLint *values);
typedef void (__stdcall * PFNGLVDPAUINITNVPROC) (const void* vdpDevice, const void*getProcAddress);
typedef void (__stdcall * PFNGLVDPAUISSURFACENVPROC) (GLvdpauSurfaceNV surface);
typedef void (__stdcall * PFNGLVDPAUMAPSURFACESNVPROC) (GLsizei numSurfaces, const GLvdpauSurfaceNV* surfaces);
typedef GLvdpauSurfaceNV (__stdcall * PFNGLVDPAUREGISTEROUTPUTSURFACENVPROC) (const void* vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames);
typedef GLvdpauSurfaceNV (__stdcall * PFNGLVDPAUREGISTERVIDEOSURFACENVPROC) (const void* vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames);
typedef void (__stdcall * PFNGLVDPAUSURFACEACCESSNVPROC) (GLvdpauSurfaceNV surface, GLenum access);
typedef void (__stdcall * PFNGLVDPAUUNMAPSURFACESNVPROC) (GLsizei numSurface, const GLvdpauSurfaceNV* surfaces);
typedef void (__stdcall * PFNGLVDPAUUNREGISTERSURFACENVPROC) (GLvdpauSurfaceNV surface);














#line 16910 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 










typedef void (__stdcall * PFNGLFLUSHVERTEXARRAYRANGENVPROC) (void);
typedef void (__stdcall * PFNGLVERTEXARRAYRANGENVPROC) (GLsizei length, void *pointer);






#line 16931 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 16942 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 







typedef void (__stdcall * PFNGLGETVERTEXATTRIBLI64VNVPROC) (GLuint index, GLenum pname, GLint64EXT* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBLUI64VNVPROC) (GLuint index, GLenum pname, GLuint64EXT* params);
typedef void (__stdcall * PFNGLVERTEXATTRIBL1I64NVPROC) (GLuint index, GLint64EXT x);
typedef void (__stdcall * PFNGLVERTEXATTRIBL1I64VNVPROC) (GLuint index, const GLint64EXT* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL1UI64NVPROC) (GLuint index, GLuint64EXT x);
typedef void (__stdcall * PFNGLVERTEXATTRIBL1UI64VNVPROC) (GLuint index, const GLuint64EXT* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL2I64NVPROC) (GLuint index, GLint64EXT x, GLint64EXT y);
typedef void (__stdcall * PFNGLVERTEXATTRIBL2I64VNVPROC) (GLuint index, const GLint64EXT* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL2UI64NVPROC) (GLuint index, GLuint64EXT x, GLuint64EXT y);
typedef void (__stdcall * PFNGLVERTEXATTRIBL2UI64VNVPROC) (GLuint index, const GLuint64EXT* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL3I64NVPROC) (GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z);
typedef void (__stdcall * PFNGLVERTEXATTRIBL3I64VNVPROC) (GLuint index, const GLint64EXT* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL3UI64NVPROC) (GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
typedef void (__stdcall * PFNGLVERTEXATTRIBL3UI64VNVPROC) (GLuint index, const GLuint64EXT* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL4I64NVPROC) (GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
typedef void (__stdcall * PFNGLVERTEXATTRIBL4I64VNVPROC) (GLuint index, const GLint64EXT* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL4UI64NVPROC) (GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
typedef void (__stdcall * PFNGLVERTEXATTRIBL4UI64VNVPROC) (GLuint index, const GLuint64EXT* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBLFORMATNVPROC) (GLuint index, GLint size, GLenum type, GLsizei stride);























#line 16994 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






























typedef void (__stdcall * PFNGLBUFFERADDRESSRANGENVPROC) (GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length);
typedef void (__stdcall * PFNGLCOLORFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
typedef void (__stdcall * PFNGLEDGEFLAGFORMATNVPROC) (GLsizei stride);
typedef void (__stdcall * PFNGLFOGCOORDFORMATNVPROC) (GLenum type, GLsizei stride);
typedef void (__stdcall * PFNGLGETINTEGERUI64I_VNVPROC) (GLenum value, GLuint index, GLuint64EXT result[]);
typedef void (__stdcall * PFNGLINDEXFORMATNVPROC) (GLenum type, GLsizei stride);
typedef void (__stdcall * PFNGLNORMALFORMATNVPROC) (GLenum type, GLsizei stride);
typedef void (__stdcall * PFNGLSECONDARYCOLORFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
typedef void (__stdcall * PFNGLTEXCOORDFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
typedef void (__stdcall * PFNGLVERTEXATTRIBFORMATNVPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride);
typedef void (__stdcall * PFNGLVERTEXATTRIBIFORMATNVPROC) (GLuint index, GLint size, GLenum type, GLsizei stride);
typedef void (__stdcall * PFNGLVERTEXFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
















#line 17055 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 
























































































typedef GLboolean (__stdcall * PFNGLAREPROGRAMSRESIDENTNVPROC) (GLsizei n, const GLuint* ids, GLboolean *residences);
typedef void (__stdcall * PFNGLBINDPROGRAMNVPROC) (GLenum target, GLuint id);
typedef void (__stdcall * PFNGLDELETEPROGRAMSNVPROC) (GLsizei n, const GLuint* ids);
typedef void (__stdcall * PFNGLEXECUTEPROGRAMNVPROC) (GLenum target, GLuint id, const GLfloat* params);
typedef void (__stdcall * PFNGLGENPROGRAMSNVPROC) (GLsizei n, GLuint* ids);
typedef void (__stdcall * PFNGLGETPROGRAMPARAMETERDVNVPROC) (GLenum target, GLuint index, GLenum pname, GLdouble* params);
typedef void (__stdcall * PFNGLGETPROGRAMPARAMETERFVNVPROC) (GLenum target, GLuint index, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETPROGRAMSTRINGNVPROC) (GLuint id, GLenum pname, GLubyte* program);
typedef void (__stdcall * PFNGLGETPROGRAMIVNVPROC) (GLuint id, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETTRACKMATRIXIVNVPROC) (GLenum target, GLuint address, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBPOINTERVNVPROC) (GLuint index, GLenum pname, void** pointer);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBDVNVPROC) (GLuint index, GLenum pname, GLdouble* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBFVNVPROC) (GLuint index, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBIVNVPROC) (GLuint index, GLenum pname, GLint* params);
typedef GLboolean (__stdcall * PFNGLISPROGRAMNVPROC) (GLuint id);
typedef void (__stdcall * PFNGLLOADPROGRAMNVPROC) (GLenum target, GLuint id, GLsizei len, const GLubyte* program);
typedef void (__stdcall * PFNGLPROGRAMPARAMETER4DNVPROC) (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLPROGRAMPARAMETER4DVNVPROC) (GLenum target, GLuint index, const GLdouble* params);
typedef void (__stdcall * PFNGLPROGRAMPARAMETER4FNVPROC) (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLPROGRAMPARAMETER4FVNVPROC) (GLenum target, GLuint index, const GLfloat* params);
typedef void (__stdcall * PFNGLPROGRAMPARAMETERS4DVNVPROC) (GLenum target, GLuint index, GLsizei num, const GLdouble* params);
typedef void (__stdcall * PFNGLPROGRAMPARAMETERS4FVNVPROC) (GLenum target, GLuint index, GLsizei num, const GLfloat* params);
typedef void (__stdcall * PFNGLREQUESTRESIDENTPROGRAMSNVPROC) (GLsizei n, GLuint* ids);
typedef void (__stdcall * PFNGLTRACKMATRIXNVPROC) (GLenum target, GLuint address, GLenum matrix, GLenum transform);
typedef void (__stdcall * PFNGLVERTEXATTRIB1DNVPROC) (GLuint index, GLdouble x);
typedef void (__stdcall * PFNGLVERTEXATTRIB1DVNVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB1FNVPROC) (GLuint index, GLfloat x);
typedef void (__stdcall * PFNGLVERTEXATTRIB1FVNVPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB1SNVPROC) (GLuint index, GLshort x);
typedef void (__stdcall * PFNGLVERTEXATTRIB1SVNVPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB2DNVPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void (__stdcall * PFNGLVERTEXATTRIB2DVNVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB2FNVPROC) (GLuint index, GLfloat x, GLfloat y);
typedef void (__stdcall * PFNGLVERTEXATTRIB2FVNVPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB2SNVPROC) (GLuint index, GLshort x, GLshort y);
typedef void (__stdcall * PFNGLVERTEXATTRIB2SVNVPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB3DNVPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLVERTEXATTRIB3DVNVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB3FNVPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLVERTEXATTRIB3FVNVPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB3SNVPROC) (GLuint index, GLshort x, GLshort y, GLshort z);
typedef void (__stdcall * PFNGLVERTEXATTRIB3SVNVPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4DNVPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4DVNVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4FNVPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4FVNVPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4SNVPROC) (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4SVNVPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4UBNVPROC) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4UBVNVPROC) (GLuint index, const GLubyte* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBPOINTERNVPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer);
typedef void (__stdcall * PFNGLVERTEXATTRIBS1DVNVPROC) (GLuint index, GLsizei n, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS1FVNVPROC) (GLuint index, GLsizei n, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS1SVNVPROC) (GLuint index, GLsizei n, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS2DVNVPROC) (GLuint index, GLsizei n, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS2FVNVPROC) (GLuint index, GLsizei n, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS2SVNVPROC) (GLuint index, GLsizei n, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS3DVNVPROC) (GLuint index, GLsizei n, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS3FVNVPROC) (GLuint index, GLsizei n, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS3SVNVPROC) (GLuint index, GLsizei n, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS4DVNVPROC) (GLuint index, GLsizei n, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS4FVNVPROC) (GLuint index, GLsizei n, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS4SVNVPROC) (GLuint index, GLsizei n, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS4UBVNVPROC) (GLuint index, GLsizei n, const GLubyte* v);




































































#line 17278 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 17287 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 17296 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 17308 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 17319 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 17330 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 


































typedef void (__stdcall * PFNGLBEGINVIDEOCAPTURENVPROC) (GLuint video_capture_slot);
typedef void (__stdcall * PFNGLBINDVIDEOCAPTURESTREAMBUFFERNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptrARB offset);
typedef void (__stdcall * PFNGLBINDVIDEOCAPTURESTREAMTEXTURENVPROC) (GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target, GLuint texture);
typedef void (__stdcall * PFNGLENDVIDEOCAPTURENVPROC) (GLuint video_capture_slot);
typedef void (__stdcall * PFNGLGETVIDEOCAPTURESTREAMDVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble* params);
typedef void (__stdcall * PFNGLGETVIDEOCAPTURESTREAMFVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETVIDEOCAPTURESTREAMIVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETVIDEOCAPTUREIVNVPROC) (GLuint video_capture_slot, GLenum pname, GLint* params);
typedef GLenum (__stdcall * PFNGLVIDEOCAPTURENVPROC) (GLuint video_capture_slot, GLuint* sequence_num, GLuint64EXT *capture_time);
typedef void (__stdcall * PFNGLVIDEOCAPTURESTREAMPARAMETERDVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble* params);
typedef void (__stdcall * PFNGLVIDEOCAPTURESTREAMPARAMETERFVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLVIDEOCAPTURESTREAMPARAMETERIVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint* params);
















#line 17395 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 













typedef void (__stdcall * PFNGLDEPTHRANGEARRAYFVNVPROC) (GLuint first, GLsizei count, const GLfloat * v);
typedef void (__stdcall * PFNGLDEPTHRANGEINDEXEDFNVPROC) (GLuint index, GLfloat n, GLfloat f);
typedef void (__stdcall * PFNGLDISABLEINVPROC) (GLenum target, GLuint index);
typedef void (__stdcall * PFNGLENABLEINVPROC) (GLenum target, GLuint index);
typedef void (__stdcall * PFNGLGETFLOATI_VNVPROC) (GLenum target, GLuint index, GLfloat* data);
typedef GLboolean (__stdcall * PFNGLISENABLEDINVPROC) (GLenum target, GLuint index);
typedef void (__stdcall * PFNGLSCISSORARRAYVNVPROC) (GLuint first, GLsizei count, const GLint * v);
typedef void (__stdcall * PFNGLSCISSORINDEXEDNVPROC) (GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLSCISSORINDEXEDVNVPROC) (GLuint index, const GLint * v);
typedef void (__stdcall * PFNGLVIEWPORTARRAYVNVPROC) (GLuint first, GLsizei count, const GLfloat * v);
typedef void (__stdcall * PFNGLVIEWPORTINDEXEDFNVPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h);
typedef void (__stdcall * PFNGLVIEWPORTINDEXEDFVNVPROC) (GLuint index, const GLfloat * v);
















#line 17439 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 17448 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 

















typedef void (__stdcall * PFNGLVIEWPORTSWIZZLENVPROC) (GLuint index, GLenum swizzlex, GLenum swizzley, GLenum swizzlez, GLenum swizzlew);





#line 17474 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 17483 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 17495 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 













#line 17511 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 17523 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTUREMULTIVIEWOVRPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint baseViewIndex, GLsizei numViews);





#line 17541 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 17550 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTUREMULTISAMPLEMULTIVIEWOVRPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLsizei samples, GLint baseViewIndex, GLsizei numViews);





#line 17563 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 



























#line 17593 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 





























#line 17625 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








typedef void (__stdcall * PFNGLALPHAFUNCQCOMPROC) (GLenum func, GLclampf ref);





#line 17642 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 












#line 17657 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLDISABLEDRIVERCONTROLQCOMPROC) (GLuint driverControl);
typedef void (__stdcall * PFNGLENABLEDRIVERCONTROLQCOMPROC) (GLuint driverControl);
typedef void (__stdcall * PFNGLGETDRIVERCONTROLSTRINGQCOMPROC) (GLuint driverControl, GLsizei bufSize, GLsizei* length, GLchar *driverControlString);
typedef void (__stdcall * PFNGLGETDRIVERCONTROLSQCOMPROC) (GLint* num, GLsizei size, GLuint *driverControls);








#line 17676 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 
















typedef void (__stdcall * PFNGLEXTGETBUFFERPOINTERVQCOMPROC) (GLenum target, void** params);
typedef void (__stdcall * PFNGLEXTGETBUFFERSQCOMPROC) (GLuint* buffers, GLint maxBuffers, GLint* numBuffers);
typedef void (__stdcall * PFNGLEXTGETFRAMEBUFFERSQCOMPROC) (GLuint* framebuffers, GLint maxFramebuffers, GLint* numFramebuffers);
typedef void (__stdcall * PFNGLEXTGETRENDERBUFFERSQCOMPROC) (GLuint* renderbuffers, GLint maxRenderbuffers, GLint* numRenderbuffers);
typedef void (__stdcall * PFNGLEXTGETTEXLEVELPARAMETERIVQCOMPROC) (GLuint texture, GLenum face, GLint level, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLEXTGETTEXSUBIMAGEQCOMPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, void *texels);
typedef void (__stdcall * PFNGLEXTGETTEXTURESQCOMPROC) (GLuint* textures, GLint maxTextures, GLint* numTextures);
typedef void (__stdcall * PFNGLEXTTEXOBJECTSTATEOVERRIDEIQCOMPROC) (GLenum target, GLenum pname, GLint param);












#line 17715 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLEXTGETPROGRAMBINARYSOURCEQCOMPROC) (GLuint program, GLenum shadertype, GLchar* source, GLint* length);
typedef void (__stdcall * PFNGLEXTGETPROGRAMSQCOMPROC) (GLuint* programs, GLint maxPrograms, GLint* numPrograms);
typedef void (__stdcall * PFNGLEXTGETSHADERSQCOMPROC) (GLuint* shaders, GLint maxShaders, GLint* numShaders);
typedef GLboolean (__stdcall * PFNGLEXTISPROGRAMBINARYQCOMPROC) (GLuint program);








#line 17734 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 







typedef void (__stdcall * PFNGLFRAMEBUFFERFOVEATIONCONFIGQCOMPROC) (GLuint fbo, GLuint numLayers, GLuint focalPointsPerLayer, GLuint requestedFeatures, GLuint* providedFeatures);
typedef void (__stdcall * PFNGLFRAMEBUFFERFOVEATIONPARAMETERSQCOMPROC) (GLuint fbo, GLuint layer, GLuint focalPoint, GLfloat focalX, GLfloat focalY, GLfloat gainX, GLfloat gainY, GLfloat foveaArea);






#line 17752 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 17763 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






typedef void (__stdcall * PFNGLFRAMEBUFFERFETCHBARRIERQCOMPROC) (void);





#line 17778 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 





































typedef void (__stdcall * PFNGLENDTILINGQCOMPROC) (GLbitfield preserveMask);
typedef void (__stdcall * PFNGLSTARTTILINGQCOMPROC) (GLuint x, GLuint y, GLuint width, GLuint height, GLbitfield preserveMask);






#line 17826 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 17837 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef int GLclampx;

typedef void (__stdcall * PFNGLALPHAFUNCXPROC) (GLenum func, GLclampx ref);
typedef void (__stdcall * PFNGLCLEARCOLORXPROC) (GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha);
typedef void (__stdcall * PFNGLCLEARDEPTHXPROC) (GLclampx depth);
typedef void (__stdcall * PFNGLCOLOR4XPROC) (GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha);
typedef void (__stdcall * PFNGLDEPTHRANGEXPROC) (GLclampx zNear, GLclampx zFar);
typedef void (__stdcall * PFNGLFOGXPROC) (GLenum pname, GLfixed param);
typedef void (__stdcall * PFNGLFOGXVPROC) (GLenum pname, const GLfixed* params);
typedef void (__stdcall * PFNGLFRUSTUMFPROC) (GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
typedef void (__stdcall * PFNGLFRUSTUMXPROC) (GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
typedef void (__stdcall * PFNGLLIGHTMODELXPROC) (GLenum pname, GLfixed param);
typedef void (__stdcall * PFNGLLIGHTMODELXVPROC) (GLenum pname, const GLfixed* params);
typedef void (__stdcall * PFNGLLIGHTXPROC) (GLenum light, GLenum pname, GLfixed param);
typedef void (__stdcall * PFNGLLIGHTXVPROC) (GLenum light, GLenum pname, const GLfixed* params);
typedef void (__stdcall * PFNGLLINEWIDTHXPROC) (GLfixed width);
typedef void (__stdcall * PFNGLLOADMATRIXXPROC) (const GLfixed* m);
typedef void (__stdcall * PFNGLMATERIALXPROC) (GLenum face, GLenum pname, GLfixed param);
typedef void (__stdcall * PFNGLMATERIALXVPROC) (GLenum face, GLenum pname, const GLfixed* params);
typedef void (__stdcall * PFNGLMULTMATRIXXPROC) (const GLfixed* m);
typedef void (__stdcall * PFNGLMULTITEXCOORD4XPROC) (GLenum target, GLfixed s, GLfixed t, GLfixed r, GLfixed q);
typedef void (__stdcall * PFNGLNORMAL3XPROC) (GLfixed nx, GLfixed ny, GLfixed nz);
typedef void (__stdcall * PFNGLORTHOFPROC) (GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
typedef void (__stdcall * PFNGLORTHOXPROC) (GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
typedef void (__stdcall * PFNGLPOINTSIZEXPROC) (GLfixed size);
typedef void (__stdcall * PFNGLPOLYGONOFFSETXPROC) (GLfixed factor, GLfixed units);
typedef void (__stdcall * PFNGLROTATEXPROC) (GLfixed angle, GLfixed x, GLfixed y, GLfixed z);
typedef void (__stdcall * PFNGLSAMPLECOVERAGEXPROC) (GLclampx value, GLboolean invert);
typedef void (__stdcall * PFNGLSCALEXPROC) (GLfixed x, GLfixed y, GLfixed z);
typedef void (__stdcall * PFNGLTEXENVXPROC) (GLenum target, GLenum pname, GLfixed param);
typedef void (__stdcall * PFNGLTEXENVXVPROC) (GLenum target, GLenum pname, const GLfixed* params);
typedef void (__stdcall * PFNGLTEXPARAMETERXPROC) (GLenum target, GLenum pname, GLfixed param);
typedef void (__stdcall * PFNGLTRANSLATEXPROC) (GLfixed x, GLfixed y, GLfixed z);



































#line 17912 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLCLIPPLANEFPROC) (GLenum plane, const GLfloat* equation);
typedef void (__stdcall * PFNGLCLIPPLANEXPROC) (GLenum plane, const GLfixed* equation);
typedef void (__stdcall * PFNGLGETCLIPPLANEFPROC) (GLenum pname, GLfloat eqn[4]);
typedef void (__stdcall * PFNGLGETCLIPPLANEXPROC) (GLenum pname, GLfixed eqn[4]);
typedef void (__stdcall * PFNGLGETFIXEDVPROC) (GLenum pname, GLfixed* params);
typedef void (__stdcall * PFNGLGETLIGHTXVPROC) (GLenum light, GLenum pname, GLfixed* params);
typedef void (__stdcall * PFNGLGETMATERIALXVPROC) (GLenum face, GLenum pname, GLfixed* params);
typedef void (__stdcall * PFNGLGETTEXENVXVPROC) (GLenum env, GLenum pname, GLfixed* params);
typedef void (__stdcall * PFNGLGETTEXPARAMETERXVPROC) (GLenum target, GLenum pname, GLfixed* params);
typedef void (__stdcall * PFNGLPOINTPARAMETERXPROC) (GLenum pname, GLfixed param);
typedef void (__stdcall * PFNGLPOINTPARAMETERXVPROC) (GLenum pname, const GLfixed* params);
typedef void (__stdcall * PFNGLPOINTSIZEPOINTEROESPROC) (GLenum type, GLsizei stride, const void *pointer);
typedef void (__stdcall * PFNGLTEXPARAMETERXVPROC) (GLenum target, GLenum pname, const GLfixed* params);

















#line 17949 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 

















#line 17969 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef const GLchar* (__stdcall * PFNGLERRORSTRINGREGALPROC) (GLenum error);





#line 17982 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef GLboolean (__stdcall * PFNGLGETEXTENSIONREGALPROC) (const GLchar* ext);
typedef GLboolean (__stdcall * PFNGLISSUPPORTEDREGALPROC) (const GLchar* ext);






#line 17997 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 














typedef void (__stdcall *GLLOGPROCREGAL)(GLenum stream, GLsizei length, const GLchar *message, void *context);

typedef void (__stdcall * PFNGLLOGMESSAGECALLBACKREGALPROC) (GLLOGPROCREGAL callback);





#line 18022 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void * (__stdcall * PFNGLGETPROCADDRESSREGALPROC) (const GLchar *name);





#line 18035 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 18047 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 













#line 18063 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 18072 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 
















#line 18091 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLDETAILTEXFUNCSGISPROC) (GLenum target, GLsizei n, const GLfloat* points);
typedef void (__stdcall * PFNGLGETDETAILTEXFUNCSGISPROC) (GLenum target, GLfloat* points);






#line 18106 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLFOGFUNCSGISPROC) (GLsizei n, const GLfloat* points);
typedef void (__stdcall * PFNGLGETFOGFUNCSGISPROC) (GLfloat* points);






#line 18121 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 18133 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 18142 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 





















typedef void (__stdcall * PFNGLSAMPLEMASKSGISPROC) (GLclampf value, GLboolean invert);
typedef void (__stdcall * PFNGLSAMPLEPATTERNSGISPROC) (GLenum pattern);






#line 18174 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 
















typedef void (__stdcall * PFNGLINTERLEAVEDTEXTURECOORDSETSSGISPROC) (GLint factor);
typedef void (__stdcall * PFNGLSELECTTEXTURECOORDSETSGISPROC) (GLenum target);
typedef void (__stdcall * PFNGLSELECTTEXTURESGISPROC) (GLenum target);
typedef void (__stdcall * PFNGLSELECTTEXTURETRANSFORMSGISPROC) (GLenum target);








#line 18205 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 18214 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 















#line 18232 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLMULTISAMPLESUBRECTPOSSGISPROC) (GLint x, GLint y);





#line 18245 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLGETSHARPENTEXFUNCSGISPROC) (GLenum target, GLfloat* points);
typedef void (__stdcall * PFNGLSHARPENTEXFUNCSGISPROC) (GLenum target, GLsizei n, const GLfloat* points);






#line 18260 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLTEXIMAGE4DSGISPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei extent, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLTEXSUBIMAGE4DSGISPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei extent, GLenum format, GLenum type, const void *pixels);






#line 18275 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 18286 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 18297 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLGETTEXFILTERFUNCSGISPROC) (GLenum target, GLenum filter, GLfloat* weights);
typedef void (__stdcall * PFNGLTEXFILTERFUNCSGISPROC) (GLenum target, GLenum filter, GLsizei n, const GLfloat* weights);






#line 18312 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











#line 18326 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 18335 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






typedef void (__stdcall * PFNGLASYNCMARKERSGIXPROC) (GLuint marker);
typedef void (__stdcall * PFNGLDELETEASYNCMARKERSSGIXPROC) (GLuint marker, GLsizei range);
typedef GLint (__stdcall * PFNGLFINISHASYNCSGIXPROC) (GLuint* markerp);
typedef GLuint (__stdcall * PFNGLGENASYNCMARKERSSGIXPROC) (GLsizei range);
typedef GLboolean (__stdcall * PFNGLISASYNCMARKERSGIXPROC) (GLuint marker);
typedef GLint (__stdcall * PFNGLPOLLASYNCSGIXPROC) (GLuint* markerp);










#line 18360 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 18372 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 













#line 18388 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











#line 18402 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 










#line 18415 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 18424 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 18436 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 18447 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 18458 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 18467 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 18476 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 18487 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 18496 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 18505 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 18516 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 
















#line 18535 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 18544 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 







typedef void (__stdcall * PFNGLADDRESSSPACEPROC) (GLenum space, GLbitfield mask);
typedef GLint (__stdcall * PFNGLDATAPIPEPROC) (GLenum space);






#line 18562 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 18571 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 










#line 18584 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 










#line 18597 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 18606 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLFLUSHRASTERSGIXPROC) (void);





#line 18619 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 18631 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 18640 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











typedef void (__stdcall * PFNGLFOGLAYERSSGIXPROC) (GLsizei n, const GLfloat* points);
typedef void (__stdcall * PFNGLGETFOGLAYERSSGIXPROC) (GLfloat* points);






#line 18662 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 18674 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 18683 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 18695 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLTEXTUREFOGSGIXPROC) (GLenum pname);





#line 18708 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











#line 18722 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLFRAGMENTCOLORMATERIALSGIXPROC) (GLenum face, GLenum mode);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTMODELFSGIXPROC) (GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTMODELFVSGIXPROC) (GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTMODELISGIXPROC) (GLenum pname, GLint param);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTMODELIVSGIXPROC) (GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTFSGIXPROC) (GLenum light, GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTFVSGIXPROC) (GLenum light, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTISGIXPROC) (GLenum light, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTIVSGIXPROC) (GLenum light, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLFRAGMENTMATERIALFSGIXPROC) (GLenum face, GLenum pname, const GLfloat param);
typedef void (__stdcall * PFNGLFRAGMENTMATERIALFVSGIXPROC) (GLenum face, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLFRAGMENTMATERIALISGIXPROC) (GLenum face, GLenum pname, const GLint param);
typedef void (__stdcall * PFNGLFRAGMENTMATERIALIVSGIXPROC) (GLenum face, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLGETFRAGMENTLIGHTFVSGIXPROC) (GLenum light, GLenum value, GLfloat* data);
typedef void (__stdcall * PFNGLGETFRAGMENTLIGHTIVSGIXPROC) (GLenum light, GLenum value, GLint* data);
typedef void (__stdcall * PFNGLGETFRAGMENTMATERIALFVSGIXPROC) (GLenum face, GLenum pname, const GLfloat* data);
typedef void (__stdcall * PFNGLGETFRAGMENTMATERIALIVSGIXPROC) (GLenum face, GLenum pname, const GLint* data);





















#line 18767 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 










#line 18780 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLFRAMEZOOMSGIXPROC) (GLint factor);





#line 18793 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 



















#line 18815 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 













typedef void (__stdcall * PFNGLIGLOOINTERFACESGIXPROC) (GLenum pname, void *param);





#line 18837 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 18846 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 18855 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 18864 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 18875 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 18884 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 18895 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 18904 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLALLOCMPEGPREDICTORSSGIXPROC) (GLsizei width, GLsizei height, GLsizei n, GLuint* predictors);
typedef void (__stdcall * PFNGLDELETEMPEGPREDICTORSSGIXPROC) (GLsizei n, GLuint* predictors);
typedef void (__stdcall * PFNGLGENMPEGPREDICTORSSGIXPROC) (GLsizei n, GLuint* predictors);
typedef void (__stdcall * PFNGLGETMPEGPARAMETERFVSGIXPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETMPEGPARAMETERIVSGIXPROC) (GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETMPEGPREDICTORSGIXPROC) (GLenum target, GLenum format, GLenum type, void *pixels);
typedef void (__stdcall * PFNGLGETMPEGQUANTTABLEUBVPROC) (GLenum target, GLubyte* values);
typedef GLboolean (__stdcall * PFNGLISMPEGPREDICTORSGIXPROC) (GLuint predictor);
typedef void (__stdcall * PFNGLMPEGPREDICTORSGIXPROC) (GLenum target, GLenum format, GLenum type, void *pixels);
typedef void (__stdcall * PFNGLMPEGQUANTTABLEUBVPROC) (GLenum target, GLubyte* values);
typedef void (__stdcall * PFNGLSWAPMPEGPREDICTORSSGIXPROC) (GLenum target0, GLenum target1);















#line 18937 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 18946 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLGETNONLINLIGHTFVSGIXPROC) (GLenum light, GLenum pname, GLint* terms, GLfloat *data);
typedef void (__stdcall * PFNGLGETNONLINMATERIALFVSGIXPROC) (GLenum face, GLenum pname, GLint* terms, const GLfloat *data);
typedef void (__stdcall * PFNGLNONLINLIGHTFVSGIXPROC) (GLenum light, GLenum pname, GLint terms, GLfloat* params);
typedef void (__stdcall * PFNGLNONLINMATERIALFVSGIXPROC) (GLenum face, GLenum pname, GLint terms, const GLfloat* params);








#line 18965 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 



























#line 18995 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 19006 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 19015 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLPIXELTEXGENSGIXPROC) (GLenum mode);





#line 19028 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 19037 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 19046 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 19055 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 







typedef void (__stdcall * PFNGLDEFORMSGIXPROC) (GLbitfield mask);
typedef void (__stdcall * PFNGLLOADIDENTITYDEFORMATIONMAPSGIXPROC) (GLbitfield mask);






#line 19073 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLMESHBREADTHSGIXPROC) (GLint breadth);
typedef void (__stdcall * PFNGLMESHSTRIDESGIXPROC) (GLint stride);






#line 19088 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLREFERENCEPLANESGIXPROC) (const GLdouble* equation);





#line 19101 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 












#line 19116 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 19127 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











#line 19141 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 19152 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











#line 19166 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 19177 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLSPRITEPARAMETERFSGIXPROC) (GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLSPRITEPARAMETERFVSGIXPROC) (GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLSPRITEPARAMETERISGIXPROC) (GLenum pname, GLint param);
typedef void (__stdcall * PFNGLSPRITEPARAMETERIVSGIXPROC) (GLenum pname, GLint* params);








#line 19196 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 19205 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 












#line 19220 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLTAGSAMPLEBUFFERSGIXPROC) (void);





#line 19233 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 19242 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 










#line 19255 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 19264 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 19276 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 19287 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 19298 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 



































#line 19336 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 











#line 19350 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 19359 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLGETVECTOROPERATIONSGIXPROC) (GLenum operation);
typedef void (__stdcall * PFNGLVECTOROPERATIONSGIXPROC) (GLenum operation);






#line 19374 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef GLboolean (__stdcall * PFNGLAREVERTEXARRAYSRESIDENTSGIXPROC) (GLsizei n, const GLuint* arrays, GLboolean* residences);
typedef void (__stdcall * PFNGLBINDVERTEXARRAYSGIXPROC) (GLuint array);
typedef void (__stdcall * PFNGLDELETEVERTEXARRAYSSGIXPROC) (GLsizei n, const GLuint* arrays);
typedef void (__stdcall * PFNGLGENVERTEXARRAYSSGIXPROC) (GLsizei n, GLuint* arrays);
typedef GLboolean (__stdcall * PFNGLISVERTEXARRAYSGIXPROC) (GLuint array);
typedef void (__stdcall * PFNGLPRIORITIZEVERTEXARRAYSSGIXPROC) (GLsizei n, const GLuint* arrays, const GLclampf* priorities);










#line 19397 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 19409 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 19421 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 19430 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 19439 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 19451 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 


















#line 19472 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 





















typedef void (__stdcall * PFNGLCOLORTABLEPARAMETERFVSGIPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLCOLORTABLEPARAMETERIVSGIPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLCOLORTABLESGIPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *table);
typedef void (__stdcall * PFNGLCOPYCOLORTABLESGIPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void (__stdcall * PFNGLGETCOLORTABLEPARAMETERFVSGIPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETCOLORTABLEPARAMETERIVSGIPROC) (GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETCOLORTABLESGIPROC) (GLenum target, GLenum format, GLenum type, void *table);











#line 19514 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 19523 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 














#line 19540 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 










typedef void (__stdcall * PFNGLGETPIXELTRANSFORMPARAMETERFVSGIPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETPIXELTRANSFORMPARAMETERIVSGIPROC) (GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLPIXELTRANSFORMPARAMETERFSGIPROC) (GLenum target, GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLPIXELTRANSFORMPARAMETERFVSGIPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLPIXELTRANSFORMPARAMETERISGIPROC) (GLenum target, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLPIXELTRANSFORMPARAMETERIVSGIPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLPIXELTRANSFORMSGIPROC) (GLenum target);











#line 19571 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 19583 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 







typedef void (__stdcall * PFNGLFINISHTEXTURESUNXPROC) (void);





#line 19599 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 19610 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 







typedef void (__stdcall * PFNGLGLOBALALPHAFACTORBSUNPROC) (GLbyte factor);
typedef void (__stdcall * PFNGLGLOBALALPHAFACTORDSUNPROC) (GLdouble factor);
typedef void (__stdcall * PFNGLGLOBALALPHAFACTORFSUNPROC) (GLfloat factor);
typedef void (__stdcall * PFNGLGLOBALALPHAFACTORISUNPROC) (GLint factor);
typedef void (__stdcall * PFNGLGLOBALALPHAFACTORSSUNPROC) (GLshort factor);
typedef void (__stdcall * PFNGLGLOBALALPHAFACTORUBSUNPROC) (GLubyte factor);
typedef void (__stdcall * PFNGLGLOBALALPHAFACTORUISUNPROC) (GLuint factor);
typedef void (__stdcall * PFNGLGLOBALALPHAFACTORUSSUNPROC) (GLushort factor);












#line 19640 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 19652 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLREADVIDEOPIXELSSUNPROC) (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void* pixels);





#line 19665 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 19676 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






















typedef void (__stdcall * PFNGLREPLACEMENTCODEPOINTERSUNPROC) (GLenum type, GLsizei stride, const void *pointer);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUBSUNPROC) (GLubyte code);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUBVSUNPROC) (const GLubyte* code);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUISUNPROC) (GLuint code);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUIVSUNPROC) (const GLuint* code);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUSSUNPROC) (GLushort code);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUSVSUNPROC) (const GLushort* code);











#line 19719 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLCOLOR3FVERTEX3FSUNPROC) (GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLCOLOR3FVERTEX3FVSUNPROC) (const GLfloat* c, const GLfloat *v);
typedef void (__stdcall * PFNGLCOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLCOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLfloat* c, const GLfloat *n, const GLfloat *v);
typedef void (__stdcall * PFNGLCOLOR4UBVERTEX2FSUNPROC) (GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y);
typedef void (__stdcall * PFNGLCOLOR4UBVERTEX2FVSUNPROC) (const GLubyte* c, const GLfloat *v);
typedef void (__stdcall * PFNGLCOLOR4UBVERTEX3FSUNPROC) (GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLCOLOR4UBVERTEX3FVSUNPROC) (const GLubyte* c, const GLfloat *v);
typedef void (__stdcall * PFNGLNORMAL3FVERTEX3FSUNPROC) (GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLNORMAL3FVERTEX3FVSUNPROC) (const GLfloat* n, const GLfloat *v);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FSUNPROC) (GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *c, const GLfloat *v);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUNPROC) (GLuint rc, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUNPROC) (const GLuint* rc, const GLubyte *c, const GLfloat *v);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *n, const GLfloat *v);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *tc, const GLfloat *n, const GLfloat *v);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUNPROC) (GLuint rc, GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *tc, const GLfloat *v);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUIVERTEX3FSUNPROC) (GLuint rc, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUIVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *v);
typedef void (__stdcall * PFNGLTEXCOORD2FCOLOR3FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLTEXCOORD2FCOLOR3FVERTEX3FVSUNPROC) (const GLfloat* tc, const GLfloat *c, const GLfloat *v);
typedef void (__stdcall * PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLfloat* tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void (__stdcall * PFNGLTEXCOORD2FCOLOR4UBVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLTEXCOORD2FCOLOR4UBVERTEX3FVSUNPROC) (const GLfloat* tc, const GLubyte *c, const GLfloat *v);
typedef void (__stdcall * PFNGLTEXCOORD2FNORMAL3FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLTEXCOORD2FNORMAL3FVERTEX3FVSUNPROC) (const GLfloat* tc, const GLfloat *n, const GLfloat *v);
typedef void (__stdcall * PFNGLTEXCOORD2FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLTEXCOORD2FVERTEX3FVSUNPROC) (const GLfloat* tc, const GLfloat *v);
typedef void (__stdcall * PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUNPROC) (GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUNPROC) (const GLfloat* tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void (__stdcall * PFNGLTEXCOORD4FVERTEX4FSUNPROC) (GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLTEXCOORD4FVERTEX4FVSUNPROC) (const GLfloat* tc, const GLfloat *v);












































#line 19810 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 









#line 19822 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 






#line 19831 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 








#line 19842 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 




typedef void (__stdcall * PFNGLADDSWAPHINTRECTWINPROC) (GLint x, GLint y, GLsizei width, GLsizei height);





#line 19855 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

 



extern __declspec(dllimport) PFNGLCOPYTEXSUBIMAGE3DPROC __glewCopyTexSubImage3D;
extern __declspec(dllimport) PFNGLDRAWRANGEELEMENTSPROC __glewDrawRangeElements;
extern __declspec(dllimport) PFNGLTEXIMAGE3DPROC __glewTexImage3D;
extern __declspec(dllimport) PFNGLTEXSUBIMAGE3DPROC __glewTexSubImage3D;

extern __declspec(dllimport) PFNGLACTIVETEXTUREPROC __glewActiveTexture;
extern __declspec(dllimport) PFNGLCLIENTACTIVETEXTUREPROC __glewClientActiveTexture;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXIMAGE1DPROC __glewCompressedTexImage1D;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXIMAGE2DPROC __glewCompressedTexImage2D;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXIMAGE3DPROC __glewCompressedTexImage3D;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC __glewCompressedTexSubImage1D;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC __glewCompressedTexSubImage2D;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC __glewCompressedTexSubImage3D;
extern __declspec(dllimport) PFNGLGETCOMPRESSEDTEXIMAGEPROC __glewGetCompressedTexImage;
extern __declspec(dllimport) PFNGLLOADTRANSPOSEMATRIXDPROC __glewLoadTransposeMatrixd;
extern __declspec(dllimport) PFNGLLOADTRANSPOSEMATRIXFPROC __glewLoadTransposeMatrixf;
extern __declspec(dllimport) PFNGLMULTTRANSPOSEMATRIXDPROC __glewMultTransposeMatrixd;
extern __declspec(dllimport) PFNGLMULTTRANSPOSEMATRIXFPROC __glewMultTransposeMatrixf;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1DPROC __glewMultiTexCoord1d;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1DVPROC __glewMultiTexCoord1dv;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1FPROC __glewMultiTexCoord1f;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1FVPROC __glewMultiTexCoord1fv;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1IPROC __glewMultiTexCoord1i;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1IVPROC __glewMultiTexCoord1iv;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1SPROC __glewMultiTexCoord1s;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1SVPROC __glewMultiTexCoord1sv;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2DPROC __glewMultiTexCoord2d;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2DVPROC __glewMultiTexCoord2dv;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2FPROC __glewMultiTexCoord2f;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2FVPROC __glewMultiTexCoord2fv;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2IPROC __glewMultiTexCoord2i;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2IVPROC __glewMultiTexCoord2iv;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2SPROC __glewMultiTexCoord2s;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2SVPROC __glewMultiTexCoord2sv;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3DPROC __glewMultiTexCoord3d;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3DVPROC __glewMultiTexCoord3dv;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3FPROC __glewMultiTexCoord3f;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3FVPROC __glewMultiTexCoord3fv;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3IPROC __glewMultiTexCoord3i;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3IVPROC __glewMultiTexCoord3iv;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3SPROC __glewMultiTexCoord3s;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3SVPROC __glewMultiTexCoord3sv;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4DPROC __glewMultiTexCoord4d;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4DVPROC __glewMultiTexCoord4dv;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4FPROC __glewMultiTexCoord4f;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4FVPROC __glewMultiTexCoord4fv;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4IPROC __glewMultiTexCoord4i;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4IVPROC __glewMultiTexCoord4iv;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4SPROC __glewMultiTexCoord4s;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4SVPROC __glewMultiTexCoord4sv;
extern __declspec(dllimport) PFNGLSAMPLECOVERAGEPROC __glewSampleCoverage;

extern __declspec(dllimport) PFNGLBLENDCOLORPROC __glewBlendColor;
extern __declspec(dllimport) PFNGLBLENDEQUATIONPROC __glewBlendEquation;
extern __declspec(dllimport) PFNGLBLENDFUNCSEPARATEPROC __glewBlendFuncSeparate;
extern __declspec(dllimport) PFNGLFOGCOORDPOINTERPROC __glewFogCoordPointer;
extern __declspec(dllimport) PFNGLFOGCOORDDPROC __glewFogCoordd;
extern __declspec(dllimport) PFNGLFOGCOORDDVPROC __glewFogCoorddv;
extern __declspec(dllimport) PFNGLFOGCOORDFPROC __glewFogCoordf;
extern __declspec(dllimport) PFNGLFOGCOORDFVPROC __glewFogCoordfv;
extern __declspec(dllimport) PFNGLMULTIDRAWARRAYSPROC __glewMultiDrawArrays;
extern __declspec(dllimport) PFNGLMULTIDRAWELEMENTSPROC __glewMultiDrawElements;
extern __declspec(dllimport) PFNGLPOINTPARAMETERFPROC __glewPointParameterf;
extern __declspec(dllimport) PFNGLPOINTPARAMETERFVPROC __glewPointParameterfv;
extern __declspec(dllimport) PFNGLPOINTPARAMETERIPROC __glewPointParameteri;
extern __declspec(dllimport) PFNGLPOINTPARAMETERIVPROC __glewPointParameteriv;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3BPROC __glewSecondaryColor3b;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3BVPROC __glewSecondaryColor3bv;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3DPROC __glewSecondaryColor3d;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3DVPROC __glewSecondaryColor3dv;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3FPROC __glewSecondaryColor3f;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3FVPROC __glewSecondaryColor3fv;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3IPROC __glewSecondaryColor3i;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3IVPROC __glewSecondaryColor3iv;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3SPROC __glewSecondaryColor3s;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3SVPROC __glewSecondaryColor3sv;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3UBPROC __glewSecondaryColor3ub;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3UBVPROC __glewSecondaryColor3ubv;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3UIPROC __glewSecondaryColor3ui;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3UIVPROC __glewSecondaryColor3uiv;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3USPROC __glewSecondaryColor3us;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3USVPROC __glewSecondaryColor3usv;
extern __declspec(dllimport) PFNGLSECONDARYCOLORPOINTERPROC __glewSecondaryColorPointer;
extern __declspec(dllimport) PFNGLWINDOWPOS2DPROC __glewWindowPos2d;
extern __declspec(dllimport) PFNGLWINDOWPOS2DVPROC __glewWindowPos2dv;
extern __declspec(dllimport) PFNGLWINDOWPOS2FPROC __glewWindowPos2f;
extern __declspec(dllimport) PFNGLWINDOWPOS2FVPROC __glewWindowPos2fv;
extern __declspec(dllimport) PFNGLWINDOWPOS2IPROC __glewWindowPos2i;
extern __declspec(dllimport) PFNGLWINDOWPOS2IVPROC __glewWindowPos2iv;
extern __declspec(dllimport) PFNGLWINDOWPOS2SPROC __glewWindowPos2s;
extern __declspec(dllimport) PFNGLWINDOWPOS2SVPROC __glewWindowPos2sv;
extern __declspec(dllimport) PFNGLWINDOWPOS3DPROC __glewWindowPos3d;
extern __declspec(dllimport) PFNGLWINDOWPOS3DVPROC __glewWindowPos3dv;
extern __declspec(dllimport) PFNGLWINDOWPOS3FPROC __glewWindowPos3f;
extern __declspec(dllimport) PFNGLWINDOWPOS3FVPROC __glewWindowPos3fv;
extern __declspec(dllimport) PFNGLWINDOWPOS3IPROC __glewWindowPos3i;
extern __declspec(dllimport) PFNGLWINDOWPOS3IVPROC __glewWindowPos3iv;
extern __declspec(dllimport) PFNGLWINDOWPOS3SPROC __glewWindowPos3s;
extern __declspec(dllimport) PFNGLWINDOWPOS3SVPROC __glewWindowPos3sv;

extern __declspec(dllimport) PFNGLBEGINQUERYPROC __glewBeginQuery;
extern __declspec(dllimport) PFNGLBINDBUFFERPROC __glewBindBuffer;
extern __declspec(dllimport) PFNGLBUFFERDATAPROC __glewBufferData;
extern __declspec(dllimport) PFNGLBUFFERSUBDATAPROC __glewBufferSubData;
extern __declspec(dllimport) PFNGLDELETEBUFFERSPROC __glewDeleteBuffers;
extern __declspec(dllimport) PFNGLDELETEQUERIESPROC __glewDeleteQueries;
extern __declspec(dllimport) PFNGLENDQUERYPROC __glewEndQuery;
extern __declspec(dllimport) PFNGLGENBUFFERSPROC __glewGenBuffers;
extern __declspec(dllimport) PFNGLGENQUERIESPROC __glewGenQueries;
extern __declspec(dllimport) PFNGLGETBUFFERPARAMETERIVPROC __glewGetBufferParameteriv;
extern __declspec(dllimport) PFNGLGETBUFFERPOINTERVPROC __glewGetBufferPointerv;
extern __declspec(dllimport) PFNGLGETBUFFERSUBDATAPROC __glewGetBufferSubData;
extern __declspec(dllimport) PFNGLGETQUERYOBJECTIVPROC __glewGetQueryObjectiv;
extern __declspec(dllimport) PFNGLGETQUERYOBJECTUIVPROC __glewGetQueryObjectuiv;
extern __declspec(dllimport) PFNGLGETQUERYIVPROC __glewGetQueryiv;
extern __declspec(dllimport) PFNGLISBUFFERPROC __glewIsBuffer;
extern __declspec(dllimport) PFNGLISQUERYPROC __glewIsQuery;
extern __declspec(dllimport) PFNGLMAPBUFFERPROC __glewMapBuffer;
extern __declspec(dllimport) PFNGLUNMAPBUFFERPROC __glewUnmapBuffer;

extern __declspec(dllimport) PFNGLATTACHSHADERPROC __glewAttachShader;
extern __declspec(dllimport) PFNGLBINDATTRIBLOCATIONPROC __glewBindAttribLocation;
extern __declspec(dllimport) PFNGLBLENDEQUATIONSEPARATEPROC __glewBlendEquationSeparate;
extern __declspec(dllimport) PFNGLCOMPILESHADERPROC __glewCompileShader;
extern __declspec(dllimport) PFNGLCREATEPROGRAMPROC __glewCreateProgram;
extern __declspec(dllimport) PFNGLCREATESHADERPROC __glewCreateShader;
extern __declspec(dllimport) PFNGLDELETEPROGRAMPROC __glewDeleteProgram;
extern __declspec(dllimport) PFNGLDELETESHADERPROC __glewDeleteShader;
extern __declspec(dllimport) PFNGLDETACHSHADERPROC __glewDetachShader;
extern __declspec(dllimport) PFNGLDISABLEVERTEXATTRIBARRAYPROC __glewDisableVertexAttribArray;
extern __declspec(dllimport) PFNGLDRAWBUFFERSPROC __glewDrawBuffers;
extern __declspec(dllimport) PFNGLENABLEVERTEXATTRIBARRAYPROC __glewEnableVertexAttribArray;
extern __declspec(dllimport) PFNGLGETACTIVEATTRIBPROC __glewGetActiveAttrib;
extern __declspec(dllimport) PFNGLGETACTIVEUNIFORMPROC __glewGetActiveUniform;
extern __declspec(dllimport) PFNGLGETATTACHEDSHADERSPROC __glewGetAttachedShaders;
extern __declspec(dllimport) PFNGLGETATTRIBLOCATIONPROC __glewGetAttribLocation;
extern __declspec(dllimport) PFNGLGETPROGRAMINFOLOGPROC __glewGetProgramInfoLog;
extern __declspec(dllimport) PFNGLGETPROGRAMIVPROC __glewGetProgramiv;
extern __declspec(dllimport) PFNGLGETSHADERINFOLOGPROC __glewGetShaderInfoLog;
extern __declspec(dllimport) PFNGLGETSHADERSOURCEPROC __glewGetShaderSource;
extern __declspec(dllimport) PFNGLGETSHADERIVPROC __glewGetShaderiv;
extern __declspec(dllimport) PFNGLGETUNIFORMLOCATIONPROC __glewGetUniformLocation;
extern __declspec(dllimport) PFNGLGETUNIFORMFVPROC __glewGetUniformfv;
extern __declspec(dllimport) PFNGLGETUNIFORMIVPROC __glewGetUniformiv;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBPOINTERVPROC __glewGetVertexAttribPointerv;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBDVPROC __glewGetVertexAttribdv;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBFVPROC __glewGetVertexAttribfv;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBIVPROC __glewGetVertexAttribiv;
extern __declspec(dllimport) PFNGLISPROGRAMPROC __glewIsProgram;
extern __declspec(dllimport) PFNGLISSHADERPROC __glewIsShader;
extern __declspec(dllimport) PFNGLLINKPROGRAMPROC __glewLinkProgram;
extern __declspec(dllimport) PFNGLSHADERSOURCEPROC __glewShaderSource;
extern __declspec(dllimport) PFNGLSTENCILFUNCSEPARATEPROC __glewStencilFuncSeparate;
extern __declspec(dllimport) PFNGLSTENCILMASKSEPARATEPROC __glewStencilMaskSeparate;
extern __declspec(dllimport) PFNGLSTENCILOPSEPARATEPROC __glewStencilOpSeparate;
extern __declspec(dllimport) PFNGLUNIFORM1FPROC __glewUniform1f;
extern __declspec(dllimport) PFNGLUNIFORM1FVPROC __glewUniform1fv;
extern __declspec(dllimport) PFNGLUNIFORM1IPROC __glewUniform1i;
extern __declspec(dllimport) PFNGLUNIFORM1IVPROC __glewUniform1iv;
extern __declspec(dllimport) PFNGLUNIFORM2FPROC __glewUniform2f;
extern __declspec(dllimport) PFNGLUNIFORM2FVPROC __glewUniform2fv;
extern __declspec(dllimport) PFNGLUNIFORM2IPROC __glewUniform2i;
extern __declspec(dllimport) PFNGLUNIFORM2IVPROC __glewUniform2iv;
extern __declspec(dllimport) PFNGLUNIFORM3FPROC __glewUniform3f;
extern __declspec(dllimport) PFNGLUNIFORM3FVPROC __glewUniform3fv;
extern __declspec(dllimport) PFNGLUNIFORM3IPROC __glewUniform3i;
extern __declspec(dllimport) PFNGLUNIFORM3IVPROC __glewUniform3iv;
extern __declspec(dllimport) PFNGLUNIFORM4FPROC __glewUniform4f;
extern __declspec(dllimport) PFNGLUNIFORM4FVPROC __glewUniform4fv;
extern __declspec(dllimport) PFNGLUNIFORM4IPROC __glewUniform4i;
extern __declspec(dllimport) PFNGLUNIFORM4IVPROC __glewUniform4iv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX2FVPROC __glewUniformMatrix2fv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX3FVPROC __glewUniformMatrix3fv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX4FVPROC __glewUniformMatrix4fv;
extern __declspec(dllimport) PFNGLUSEPROGRAMPROC __glewUseProgram;
extern __declspec(dllimport) PFNGLVALIDATEPROGRAMPROC __glewValidateProgram;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1DPROC __glewVertexAttrib1d;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1DVPROC __glewVertexAttrib1dv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1FPROC __glewVertexAttrib1f;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1FVPROC __glewVertexAttrib1fv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1SPROC __glewVertexAttrib1s;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1SVPROC __glewVertexAttrib1sv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2DPROC __glewVertexAttrib2d;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2DVPROC __glewVertexAttrib2dv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2FPROC __glewVertexAttrib2f;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2FVPROC __glewVertexAttrib2fv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2SPROC __glewVertexAttrib2s;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2SVPROC __glewVertexAttrib2sv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3DPROC __glewVertexAttrib3d;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3DVPROC __glewVertexAttrib3dv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3FPROC __glewVertexAttrib3f;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3FVPROC __glewVertexAttrib3fv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3SPROC __glewVertexAttrib3s;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3SVPROC __glewVertexAttrib3sv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4NBVPROC __glewVertexAttrib4Nbv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4NIVPROC __glewVertexAttrib4Niv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4NSVPROC __glewVertexAttrib4Nsv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4NUBPROC __glewVertexAttrib4Nub;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4NUBVPROC __glewVertexAttrib4Nubv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4NUIVPROC __glewVertexAttrib4Nuiv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4NUSVPROC __glewVertexAttrib4Nusv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4BVPROC __glewVertexAttrib4bv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4DPROC __glewVertexAttrib4d;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4DVPROC __glewVertexAttrib4dv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4FPROC __glewVertexAttrib4f;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4FVPROC __glewVertexAttrib4fv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4IVPROC __glewVertexAttrib4iv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4SPROC __glewVertexAttrib4s;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4SVPROC __glewVertexAttrib4sv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4UBVPROC __glewVertexAttrib4ubv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4UIVPROC __glewVertexAttrib4uiv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4USVPROC __glewVertexAttrib4usv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBPOINTERPROC __glewVertexAttribPointer;

extern __declspec(dllimport) PFNGLUNIFORMMATRIX2X3FVPROC __glewUniformMatrix2x3fv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX2X4FVPROC __glewUniformMatrix2x4fv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX3X2FVPROC __glewUniformMatrix3x2fv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX3X4FVPROC __glewUniformMatrix3x4fv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX4X2FVPROC __glewUniformMatrix4x2fv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX4X3FVPROC __glewUniformMatrix4x3fv;

extern __declspec(dllimport) PFNGLBEGINCONDITIONALRENDERPROC __glewBeginConditionalRender;
extern __declspec(dllimport) PFNGLBEGINTRANSFORMFEEDBACKPROC __glewBeginTransformFeedback;
extern __declspec(dllimport) PFNGLBINDFRAGDATALOCATIONPROC __glewBindFragDataLocation;
extern __declspec(dllimport) PFNGLCLAMPCOLORPROC __glewClampColor;
extern __declspec(dllimport) PFNGLCLEARBUFFERFIPROC __glewClearBufferfi;
extern __declspec(dllimport) PFNGLCLEARBUFFERFVPROC __glewClearBufferfv;
extern __declspec(dllimport) PFNGLCLEARBUFFERIVPROC __glewClearBufferiv;
extern __declspec(dllimport) PFNGLCLEARBUFFERUIVPROC __glewClearBufferuiv;
extern __declspec(dllimport) PFNGLCOLORMASKIPROC __glewColorMaski;
extern __declspec(dllimport) PFNGLDISABLEIPROC __glewDisablei;
extern __declspec(dllimport) PFNGLENABLEIPROC __glewEnablei;
extern __declspec(dllimport) PFNGLENDCONDITIONALRENDERPROC __glewEndConditionalRender;
extern __declspec(dllimport) PFNGLENDTRANSFORMFEEDBACKPROC __glewEndTransformFeedback;
extern __declspec(dllimport) PFNGLGETBOOLEANI_VPROC __glewGetBooleani_v;
extern __declspec(dllimport) PFNGLGETFRAGDATALOCATIONPROC __glewGetFragDataLocation;
extern __declspec(dllimport) PFNGLGETSTRINGIPROC __glewGetStringi;
extern __declspec(dllimport) PFNGLGETTEXPARAMETERIIVPROC __glewGetTexParameterIiv;
extern __declspec(dllimport) PFNGLGETTEXPARAMETERIUIVPROC __glewGetTexParameterIuiv;
extern __declspec(dllimport) PFNGLGETTRANSFORMFEEDBACKVARYINGPROC __glewGetTransformFeedbackVarying;
extern __declspec(dllimport) PFNGLGETUNIFORMUIVPROC __glewGetUniformuiv;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBIIVPROC __glewGetVertexAttribIiv;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBIUIVPROC __glewGetVertexAttribIuiv;
extern __declspec(dllimport) PFNGLISENABLEDIPROC __glewIsEnabledi;
extern __declspec(dllimport) PFNGLTEXPARAMETERIIVPROC __glewTexParameterIiv;
extern __declspec(dllimport) PFNGLTEXPARAMETERIUIVPROC __glewTexParameterIuiv;
extern __declspec(dllimport) PFNGLTRANSFORMFEEDBACKVARYINGSPROC __glewTransformFeedbackVaryings;
extern __declspec(dllimport) PFNGLUNIFORM1UIPROC __glewUniform1ui;
extern __declspec(dllimport) PFNGLUNIFORM1UIVPROC __glewUniform1uiv;
extern __declspec(dllimport) PFNGLUNIFORM2UIPROC __glewUniform2ui;
extern __declspec(dllimport) PFNGLUNIFORM2UIVPROC __glewUniform2uiv;
extern __declspec(dllimport) PFNGLUNIFORM3UIPROC __glewUniform3ui;
extern __declspec(dllimport) PFNGLUNIFORM3UIVPROC __glewUniform3uiv;
extern __declspec(dllimport) PFNGLUNIFORM4UIPROC __glewUniform4ui;
extern __declspec(dllimport) PFNGLUNIFORM4UIVPROC __glewUniform4uiv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI1IPROC __glewVertexAttribI1i;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI1IVPROC __glewVertexAttribI1iv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI1UIPROC __glewVertexAttribI1ui;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI1UIVPROC __glewVertexAttribI1uiv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI2IPROC __glewVertexAttribI2i;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI2IVPROC __glewVertexAttribI2iv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI2UIPROC __glewVertexAttribI2ui;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI2UIVPROC __glewVertexAttribI2uiv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI3IPROC __glewVertexAttribI3i;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI3IVPROC __glewVertexAttribI3iv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI3UIPROC __glewVertexAttribI3ui;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI3UIVPROC __glewVertexAttribI3uiv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4BVPROC __glewVertexAttribI4bv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4IPROC __glewVertexAttribI4i;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4IVPROC __glewVertexAttribI4iv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4SVPROC __glewVertexAttribI4sv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4UBVPROC __glewVertexAttribI4ubv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4UIPROC __glewVertexAttribI4ui;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4UIVPROC __glewVertexAttribI4uiv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4USVPROC __glewVertexAttribI4usv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBIPOINTERPROC __glewVertexAttribIPointer;

extern __declspec(dllimport) PFNGLDRAWARRAYSINSTANCEDPROC __glewDrawArraysInstanced;
extern __declspec(dllimport) PFNGLDRAWELEMENTSINSTANCEDPROC __glewDrawElementsInstanced;
extern __declspec(dllimport) PFNGLPRIMITIVERESTARTINDEXPROC __glewPrimitiveRestartIndex;
extern __declspec(dllimport) PFNGLTEXBUFFERPROC __glewTexBuffer;

extern __declspec(dllimport) PFNGLFRAMEBUFFERTEXTUREPROC __glewFramebufferTexture;
extern __declspec(dllimport) PFNGLGETBUFFERPARAMETERI64VPROC __glewGetBufferParameteri64v;
extern __declspec(dllimport) PFNGLGETINTEGER64I_VPROC __glewGetInteger64i_v;

extern __declspec(dllimport) PFNGLVERTEXATTRIBDIVISORPROC __glewVertexAttribDivisor;

extern __declspec(dllimport) PFNGLBLENDEQUATIONSEPARATEIPROC __glewBlendEquationSeparatei;
extern __declspec(dllimport) PFNGLBLENDEQUATIONIPROC __glewBlendEquationi;
extern __declspec(dllimport) PFNGLBLENDFUNCSEPARATEIPROC __glewBlendFuncSeparatei;
extern __declspec(dllimport) PFNGLBLENDFUNCIPROC __glewBlendFunci;
extern __declspec(dllimport) PFNGLMINSAMPLESHADINGPROC __glewMinSampleShading;

extern __declspec(dllimport) PFNGLGETGRAPHICSRESETSTATUSPROC __glewGetGraphicsResetStatus;
extern __declspec(dllimport) PFNGLGETNCOMPRESSEDTEXIMAGEPROC __glewGetnCompressedTexImage;
extern __declspec(dllimport) PFNGLGETNTEXIMAGEPROC __glewGetnTexImage;
extern __declspec(dllimport) PFNGLGETNUNIFORMDVPROC __glewGetnUniformdv;

extern __declspec(dllimport) PFNGLMULTIDRAWARRAYSINDIRECTCOUNTPROC __glewMultiDrawArraysIndirectCount;
extern __declspec(dllimport) PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTPROC __glewMultiDrawElementsIndirectCount;
extern __declspec(dllimport) PFNGLSPECIALIZESHADERPROC __glewSpecializeShader;

extern __declspec(dllimport) PFNGLTBUFFERMASK3DFXPROC __glewTbufferMask3DFX;

extern __declspec(dllimport) PFNGLDEBUGMESSAGECALLBACKAMDPROC __glewDebugMessageCallbackAMD;
extern __declspec(dllimport) PFNGLDEBUGMESSAGEENABLEAMDPROC __glewDebugMessageEnableAMD;
extern __declspec(dllimport) PFNGLDEBUGMESSAGEINSERTAMDPROC __glewDebugMessageInsertAMD;
extern __declspec(dllimport) PFNGLGETDEBUGMESSAGELOGAMDPROC __glewGetDebugMessageLogAMD;

extern __declspec(dllimport) PFNGLBLENDEQUATIONINDEXEDAMDPROC __glewBlendEquationIndexedAMD;
extern __declspec(dllimport) PFNGLBLENDEQUATIONSEPARATEINDEXEDAMDPROC __glewBlendEquationSeparateIndexedAMD;
extern __declspec(dllimport) PFNGLBLENDFUNCINDEXEDAMDPROC __glewBlendFuncIndexedAMD;
extern __declspec(dllimport) PFNGLBLENDFUNCSEPARATEINDEXEDAMDPROC __glewBlendFuncSeparateIndexedAMD;

extern __declspec(dllimport) PFNGLFRAMEBUFFERSAMPLEPOSITIONSFVAMDPROC __glewFramebufferSamplePositionsfvAMD;
extern __declspec(dllimport) PFNGLGETFRAMEBUFFERPARAMETERFVAMDPROC __glewGetFramebufferParameterfvAMD;
extern __declspec(dllimport) PFNGLGETNAMEDFRAMEBUFFERPARAMETERFVAMDPROC __glewGetNamedFramebufferParameterfvAMD;
extern __declspec(dllimport) PFNGLNAMEDFRAMEBUFFERSAMPLEPOSITIONSFVAMDPROC __glewNamedFramebufferSamplePositionsfvAMD;

extern __declspec(dllimport) PFNGLVERTEXATTRIBPARAMETERIAMDPROC __glewVertexAttribParameteriAMD;

extern __declspec(dllimport) PFNGLMULTIDRAWARRAYSINDIRECTAMDPROC __glewMultiDrawArraysIndirectAMD;
extern __declspec(dllimport) PFNGLMULTIDRAWELEMENTSINDIRECTAMDPROC __glewMultiDrawElementsIndirectAMD;

extern __declspec(dllimport) PFNGLDELETENAMESAMDPROC __glewDeleteNamesAMD;
extern __declspec(dllimport) PFNGLGENNAMESAMDPROC __glewGenNamesAMD;
extern __declspec(dllimport) PFNGLISNAMEAMDPROC __glewIsNameAMD;

extern __declspec(dllimport) PFNGLQUERYOBJECTPARAMETERUIAMDPROC __glewQueryObjectParameteruiAMD;

extern __declspec(dllimport) PFNGLBEGINPERFMONITORAMDPROC __glewBeginPerfMonitorAMD;
extern __declspec(dllimport) PFNGLDELETEPERFMONITORSAMDPROC __glewDeletePerfMonitorsAMD;
extern __declspec(dllimport) PFNGLENDPERFMONITORAMDPROC __glewEndPerfMonitorAMD;
extern __declspec(dllimport) PFNGLGENPERFMONITORSAMDPROC __glewGenPerfMonitorsAMD;
extern __declspec(dllimport) PFNGLGETPERFMONITORCOUNTERDATAAMDPROC __glewGetPerfMonitorCounterDataAMD;
extern __declspec(dllimport) PFNGLGETPERFMONITORCOUNTERINFOAMDPROC __glewGetPerfMonitorCounterInfoAMD;
extern __declspec(dllimport) PFNGLGETPERFMONITORCOUNTERSTRINGAMDPROC __glewGetPerfMonitorCounterStringAMD;
extern __declspec(dllimport) PFNGLGETPERFMONITORCOUNTERSAMDPROC __glewGetPerfMonitorCountersAMD;
extern __declspec(dllimport) PFNGLGETPERFMONITORGROUPSTRINGAMDPROC __glewGetPerfMonitorGroupStringAMD;
extern __declspec(dllimport) PFNGLGETPERFMONITORGROUPSAMDPROC __glewGetPerfMonitorGroupsAMD;
extern __declspec(dllimport) PFNGLSELECTPERFMONITORCOUNTERSAMDPROC __glewSelectPerfMonitorCountersAMD;

extern __declspec(dllimport) PFNGLSETMULTISAMPLEFVAMDPROC __glewSetMultisamplefvAMD;

extern __declspec(dllimport) PFNGLTEXSTORAGESPARSEAMDPROC __glewTexStorageSparseAMD;
extern __declspec(dllimport) PFNGLTEXTURESTORAGESPARSEAMDPROC __glewTextureStorageSparseAMD;

extern __declspec(dllimport) PFNGLSTENCILOPVALUEAMDPROC __glewStencilOpValueAMD;

extern __declspec(dllimport) PFNGLTESSELLATIONFACTORAMDPROC __glewTessellationFactorAMD;
extern __declspec(dllimport) PFNGLTESSELLATIONMODEAMDPROC __glewTessellationModeAMD;

extern __declspec(dllimport) PFNGLBLITFRAMEBUFFERANGLEPROC __glewBlitFramebufferANGLE;

extern __declspec(dllimport) PFNGLRENDERBUFFERSTORAGEMULTISAMPLEANGLEPROC __glewRenderbufferStorageMultisampleANGLE;

extern __declspec(dllimport) PFNGLDRAWARRAYSINSTANCEDANGLEPROC __glewDrawArraysInstancedANGLE;
extern __declspec(dllimport) PFNGLDRAWELEMENTSINSTANCEDANGLEPROC __glewDrawElementsInstancedANGLE;
extern __declspec(dllimport) PFNGLVERTEXATTRIBDIVISORANGLEPROC __glewVertexAttribDivisorANGLE;

extern __declspec(dllimport) PFNGLBEGINQUERYANGLEPROC __glewBeginQueryANGLE;
extern __declspec(dllimport) PFNGLDELETEQUERIESANGLEPROC __glewDeleteQueriesANGLE;
extern __declspec(dllimport) PFNGLENDQUERYANGLEPROC __glewEndQueryANGLE;
extern __declspec(dllimport) PFNGLGENQUERIESANGLEPROC __glewGenQueriesANGLE;
extern __declspec(dllimport) PFNGLGETQUERYOBJECTI64VANGLEPROC __glewGetQueryObjecti64vANGLE;
extern __declspec(dllimport) PFNGLGETQUERYOBJECTIVANGLEPROC __glewGetQueryObjectivANGLE;
extern __declspec(dllimport) PFNGLGETQUERYOBJECTUI64VANGLEPROC __glewGetQueryObjectui64vANGLE;
extern __declspec(dllimport) PFNGLGETQUERYOBJECTUIVANGLEPROC __glewGetQueryObjectuivANGLE;
extern __declspec(dllimport) PFNGLGETQUERYIVANGLEPROC __glewGetQueryivANGLE;
extern __declspec(dllimport) PFNGLISQUERYANGLEPROC __glewIsQueryANGLE;
extern __declspec(dllimport) PFNGLQUERYCOUNTERANGLEPROC __glewQueryCounterANGLE;

extern __declspec(dllimport) PFNGLGETTRANSLATEDSHADERSOURCEANGLEPROC __glewGetTranslatedShaderSourceANGLE;

extern __declspec(dllimport) PFNGLCOPYTEXTURELEVELSAPPLEPROC __glewCopyTextureLevelsAPPLE;

extern __declspec(dllimport) PFNGLDRAWELEMENTARRAYAPPLEPROC __glewDrawElementArrayAPPLE;
extern __declspec(dllimport) PFNGLDRAWRANGEELEMENTARRAYAPPLEPROC __glewDrawRangeElementArrayAPPLE;
extern __declspec(dllimport) PFNGLELEMENTPOINTERAPPLEPROC __glewElementPointerAPPLE;
extern __declspec(dllimport) PFNGLMULTIDRAWELEMENTARRAYAPPLEPROC __glewMultiDrawElementArrayAPPLE;
extern __declspec(dllimport) PFNGLMULTIDRAWRANGEELEMENTARRAYAPPLEPROC __glewMultiDrawRangeElementArrayAPPLE;

extern __declspec(dllimport) PFNGLDELETEFENCESAPPLEPROC __glewDeleteFencesAPPLE;
extern __declspec(dllimport) PFNGLFINISHFENCEAPPLEPROC __glewFinishFenceAPPLE;
extern __declspec(dllimport) PFNGLFINISHOBJECTAPPLEPROC __glewFinishObjectAPPLE;
extern __declspec(dllimport) PFNGLGENFENCESAPPLEPROC __glewGenFencesAPPLE;
extern __declspec(dllimport) PFNGLISFENCEAPPLEPROC __glewIsFenceAPPLE;
extern __declspec(dllimport) PFNGLSETFENCEAPPLEPROC __glewSetFenceAPPLE;
extern __declspec(dllimport) PFNGLTESTFENCEAPPLEPROC __glewTestFenceAPPLE;
extern __declspec(dllimport) PFNGLTESTOBJECTAPPLEPROC __glewTestObjectAPPLE;

extern __declspec(dllimport) PFNGLBUFFERPARAMETERIAPPLEPROC __glewBufferParameteriAPPLE;
extern __declspec(dllimport) PFNGLFLUSHMAPPEDBUFFERRANGEAPPLEPROC __glewFlushMappedBufferRangeAPPLE;

extern __declspec(dllimport) PFNGLRENDERBUFFERSTORAGEMULTISAMPLEAPPLEPROC __glewRenderbufferStorageMultisampleAPPLE;
extern __declspec(dllimport) PFNGLRESOLVEMULTISAMPLEFRAMEBUFFERAPPLEPROC __glewResolveMultisampleFramebufferAPPLE;

extern __declspec(dllimport) PFNGLGETOBJECTPARAMETERIVAPPLEPROC __glewGetObjectParameterivAPPLE;
extern __declspec(dllimport) PFNGLOBJECTPURGEABLEAPPLEPROC __glewObjectPurgeableAPPLE;
extern __declspec(dllimport) PFNGLOBJECTUNPURGEABLEAPPLEPROC __glewObjectUnpurgeableAPPLE;

extern __declspec(dllimport) PFNGLCLIENTWAITSYNCAPPLEPROC __glewClientWaitSyncAPPLE;
extern __declspec(dllimport) PFNGLDELETESYNCAPPLEPROC __glewDeleteSyncAPPLE;
extern __declspec(dllimport) PFNGLFENCESYNCAPPLEPROC __glewFenceSyncAPPLE;
extern __declspec(dllimport) PFNGLGETINTEGER64VAPPLEPROC __glewGetInteger64vAPPLE;
extern __declspec(dllimport) PFNGLGETSYNCIVAPPLEPROC __glewGetSyncivAPPLE;
extern __declspec(dllimport) PFNGLISSYNCAPPLEPROC __glewIsSyncAPPLE;
extern __declspec(dllimport) PFNGLWAITSYNCAPPLEPROC __glewWaitSyncAPPLE;

extern __declspec(dllimport) PFNGLGETTEXPARAMETERPOINTERVAPPLEPROC __glewGetTexParameterPointervAPPLE;
extern __declspec(dllimport) PFNGLTEXTURERANGEAPPLEPROC __glewTextureRangeAPPLE;

extern __declspec(dllimport) PFNGLBINDVERTEXARRAYAPPLEPROC __glewBindVertexArrayAPPLE;
extern __declspec(dllimport) PFNGLDELETEVERTEXARRAYSAPPLEPROC __glewDeleteVertexArraysAPPLE;
extern __declspec(dllimport) PFNGLGENVERTEXARRAYSAPPLEPROC __glewGenVertexArraysAPPLE;
extern __declspec(dllimport) PFNGLISVERTEXARRAYAPPLEPROC __glewIsVertexArrayAPPLE;

extern __declspec(dllimport) PFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC __glewFlushVertexArrayRangeAPPLE;
extern __declspec(dllimport) PFNGLVERTEXARRAYPARAMETERIAPPLEPROC __glewVertexArrayParameteriAPPLE;
extern __declspec(dllimport) PFNGLVERTEXARRAYRANGEAPPLEPROC __glewVertexArrayRangeAPPLE;

extern __declspec(dllimport) PFNGLDISABLEVERTEXATTRIBAPPLEPROC __glewDisableVertexAttribAPPLE;
extern __declspec(dllimport) PFNGLENABLEVERTEXATTRIBAPPLEPROC __glewEnableVertexAttribAPPLE;
extern __declspec(dllimport) PFNGLISVERTEXATTRIBENABLEDAPPLEPROC __glewIsVertexAttribEnabledAPPLE;
extern __declspec(dllimport) PFNGLMAPVERTEXATTRIB1DAPPLEPROC __glewMapVertexAttrib1dAPPLE;
extern __declspec(dllimport) PFNGLMAPVERTEXATTRIB1FAPPLEPROC __glewMapVertexAttrib1fAPPLE;
extern __declspec(dllimport) PFNGLMAPVERTEXATTRIB2DAPPLEPROC __glewMapVertexAttrib2dAPPLE;
extern __declspec(dllimport) PFNGLMAPVERTEXATTRIB2FAPPLEPROC __glewMapVertexAttrib2fAPPLE;

extern __declspec(dllimport) PFNGLCLEARDEPTHFPROC __glewClearDepthf;
extern __declspec(dllimport) PFNGLDEPTHRANGEFPROC __glewDepthRangef;
extern __declspec(dllimport) PFNGLGETSHADERPRECISIONFORMATPROC __glewGetShaderPrecisionFormat;
extern __declspec(dllimport) PFNGLRELEASESHADERCOMPILERPROC __glewReleaseShaderCompiler;
extern __declspec(dllimport) PFNGLSHADERBINARYPROC __glewShaderBinary;

extern __declspec(dllimport) PFNGLMEMORYBARRIERBYREGIONPROC __glewMemoryBarrierByRegion;

extern __declspec(dllimport) PFNGLPRIMITIVEBOUNDINGBOXARBPROC __glewPrimitiveBoundingBoxARB;

extern __declspec(dllimport) PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC __glewDrawArraysInstancedBaseInstance;
extern __declspec(dllimport) PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC __glewDrawElementsInstancedBaseInstance;
extern __declspec(dllimport) PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC __glewDrawElementsInstancedBaseVertexBaseInstance;

extern __declspec(dllimport) PFNGLGETIMAGEHANDLEARBPROC __glewGetImageHandleARB;
extern __declspec(dllimport) PFNGLGETTEXTUREHANDLEARBPROC __glewGetTextureHandleARB;
extern __declspec(dllimport) PFNGLGETTEXTURESAMPLERHANDLEARBPROC __glewGetTextureSamplerHandleARB;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBLUI64VARBPROC __glewGetVertexAttribLui64vARB;
extern __declspec(dllimport) PFNGLISIMAGEHANDLERESIDENTARBPROC __glewIsImageHandleResidentARB;
extern __declspec(dllimport) PFNGLISTEXTUREHANDLERESIDENTARBPROC __glewIsTextureHandleResidentARB;
extern __declspec(dllimport) PFNGLMAKEIMAGEHANDLENONRESIDENTARBPROC __glewMakeImageHandleNonResidentARB;
extern __declspec(dllimport) PFNGLMAKEIMAGEHANDLERESIDENTARBPROC __glewMakeImageHandleResidentARB;
extern __declspec(dllimport) PFNGLMAKETEXTUREHANDLENONRESIDENTARBPROC __glewMakeTextureHandleNonResidentARB;
extern __declspec(dllimport) PFNGLMAKETEXTUREHANDLERESIDENTARBPROC __glewMakeTextureHandleResidentARB;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMHANDLEUI64ARBPROC __glewProgramUniformHandleui64ARB;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMHANDLEUI64VARBPROC __glewProgramUniformHandleui64vARB;
extern __declspec(dllimport) PFNGLUNIFORMHANDLEUI64ARBPROC __glewUniformHandleui64ARB;
extern __declspec(dllimport) PFNGLUNIFORMHANDLEUI64VARBPROC __glewUniformHandleui64vARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL1UI64ARBPROC __glewVertexAttribL1ui64ARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL1UI64VARBPROC __glewVertexAttribL1ui64vARB;

extern __declspec(dllimport) PFNGLBINDFRAGDATALOCATIONINDEXEDPROC __glewBindFragDataLocationIndexed;
extern __declspec(dllimport) PFNGLGETFRAGDATAINDEXPROC __glewGetFragDataIndex;

extern __declspec(dllimport) PFNGLBUFFERSTORAGEPROC __glewBufferStorage;

extern __declspec(dllimport) PFNGLCREATESYNCFROMCLEVENTARBPROC __glewCreateSyncFromCLeventARB;

extern __declspec(dllimport) PFNGLCLEARBUFFERDATAPROC __glewClearBufferData;
extern __declspec(dllimport) PFNGLCLEARBUFFERSUBDATAPROC __glewClearBufferSubData;
extern __declspec(dllimport) PFNGLCLEARNAMEDBUFFERDATAEXTPROC __glewClearNamedBufferDataEXT;
extern __declspec(dllimport) PFNGLCLEARNAMEDBUFFERSUBDATAEXTPROC __glewClearNamedBufferSubDataEXT;

extern __declspec(dllimport) PFNGLCLEARTEXIMAGEPROC __glewClearTexImage;
extern __declspec(dllimport) PFNGLCLEARTEXSUBIMAGEPROC __glewClearTexSubImage;

extern __declspec(dllimport) PFNGLCLIPCONTROLPROC __glewClipControl;

extern __declspec(dllimport) PFNGLCLAMPCOLORARBPROC __glewClampColorARB;

extern __declspec(dllimport) PFNGLDISPATCHCOMPUTEPROC __glewDispatchCompute;
extern __declspec(dllimport) PFNGLDISPATCHCOMPUTEINDIRECTPROC __glewDispatchComputeIndirect;

extern __declspec(dllimport) PFNGLDISPATCHCOMPUTEGROUPSIZEARBPROC __glewDispatchComputeGroupSizeARB;

extern __declspec(dllimport) PFNGLCOPYBUFFERSUBDATAPROC __glewCopyBufferSubData;

extern __declspec(dllimport) PFNGLCOPYIMAGESUBDATAPROC __glewCopyImageSubData;

extern __declspec(dllimport) PFNGLDEBUGMESSAGECALLBACKARBPROC __glewDebugMessageCallbackARB;
extern __declspec(dllimport) PFNGLDEBUGMESSAGECONTROLARBPROC __glewDebugMessageControlARB;
extern __declspec(dllimport) PFNGLDEBUGMESSAGEINSERTARBPROC __glewDebugMessageInsertARB;
extern __declspec(dllimport) PFNGLGETDEBUGMESSAGELOGARBPROC __glewGetDebugMessageLogARB;

extern __declspec(dllimport) PFNGLBINDTEXTUREUNITPROC __glewBindTextureUnit;
extern __declspec(dllimport) PFNGLBLITNAMEDFRAMEBUFFERPROC __glewBlitNamedFramebuffer;
extern __declspec(dllimport) PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC __glewCheckNamedFramebufferStatus;
extern __declspec(dllimport) PFNGLCLEARNAMEDBUFFERDATAPROC __glewClearNamedBufferData;
extern __declspec(dllimport) PFNGLCLEARNAMEDBUFFERSUBDATAPROC __glewClearNamedBufferSubData;
extern __declspec(dllimport) PFNGLCLEARNAMEDFRAMEBUFFERFIPROC __glewClearNamedFramebufferfi;
extern __declspec(dllimport) PFNGLCLEARNAMEDFRAMEBUFFERFVPROC __glewClearNamedFramebufferfv;
extern __declspec(dllimport) PFNGLCLEARNAMEDFRAMEBUFFERIVPROC __glewClearNamedFramebufferiv;
extern __declspec(dllimport) PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC __glewClearNamedFramebufferuiv;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC __glewCompressedTextureSubImage1D;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC __glewCompressedTextureSubImage2D;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC __glewCompressedTextureSubImage3D;
extern __declspec(dllimport) PFNGLCOPYNAMEDBUFFERSUBDATAPROC __glewCopyNamedBufferSubData;
extern __declspec(dllimport) PFNGLCOPYTEXTURESUBIMAGE1DPROC __glewCopyTextureSubImage1D;
extern __declspec(dllimport) PFNGLCOPYTEXTURESUBIMAGE2DPROC __glewCopyTextureSubImage2D;
extern __declspec(dllimport) PFNGLCOPYTEXTURESUBIMAGE3DPROC __glewCopyTextureSubImage3D;
extern __declspec(dllimport) PFNGLCREATEBUFFERSPROC __glewCreateBuffers;
extern __declspec(dllimport) PFNGLCREATEFRAMEBUFFERSPROC __glewCreateFramebuffers;
extern __declspec(dllimport) PFNGLCREATEPROGRAMPIPELINESPROC __glewCreateProgramPipelines;
extern __declspec(dllimport) PFNGLCREATEQUERIESPROC __glewCreateQueries;
extern __declspec(dllimport) PFNGLCREATERENDERBUFFERSPROC __glewCreateRenderbuffers;
extern __declspec(dllimport) PFNGLCREATESAMPLERSPROC __glewCreateSamplers;
extern __declspec(dllimport) PFNGLCREATETEXTURESPROC __glewCreateTextures;
extern __declspec(dllimport) PFNGLCREATETRANSFORMFEEDBACKSPROC __glewCreateTransformFeedbacks;
extern __declspec(dllimport) PFNGLCREATEVERTEXARRAYSPROC __glewCreateVertexArrays;
extern __declspec(dllimport) PFNGLDISABLEVERTEXARRAYATTRIBPROC __glewDisableVertexArrayAttrib;
extern __declspec(dllimport) PFNGLENABLEVERTEXARRAYATTRIBPROC __glewEnableVertexArrayAttrib;
extern __declspec(dllimport) PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC __glewFlushMappedNamedBufferRange;
extern __declspec(dllimport) PFNGLGENERATETEXTUREMIPMAPPROC __glewGenerateTextureMipmap;
extern __declspec(dllimport) PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC __glewGetCompressedTextureImage;
extern __declspec(dllimport) PFNGLGETNAMEDBUFFERPARAMETERI64VPROC __glewGetNamedBufferParameteri64v;
extern __declspec(dllimport) PFNGLGETNAMEDBUFFERPARAMETERIVPROC __glewGetNamedBufferParameteriv;
extern __declspec(dllimport) PFNGLGETNAMEDBUFFERPOINTERVPROC __glewGetNamedBufferPointerv;
extern __declspec(dllimport) PFNGLGETNAMEDBUFFERSUBDATAPROC __glewGetNamedBufferSubData;
extern __declspec(dllimport) PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC __glewGetNamedFramebufferAttachmentParameteriv;
extern __declspec(dllimport) PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC __glewGetNamedFramebufferParameteriv;
extern __declspec(dllimport) PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC __glewGetNamedRenderbufferParameteriv;
extern __declspec(dllimport) PFNGLGETQUERYBUFFEROBJECTI64VPROC __glewGetQueryBufferObjecti64v;
extern __declspec(dllimport) PFNGLGETQUERYBUFFEROBJECTIVPROC __glewGetQueryBufferObjectiv;
extern __declspec(dllimport) PFNGLGETQUERYBUFFEROBJECTUI64VPROC __glewGetQueryBufferObjectui64v;
extern __declspec(dllimport) PFNGLGETQUERYBUFFEROBJECTUIVPROC __glewGetQueryBufferObjectuiv;
extern __declspec(dllimport) PFNGLGETTEXTUREIMAGEPROC __glewGetTextureImage;
extern __declspec(dllimport) PFNGLGETTEXTURELEVELPARAMETERFVPROC __glewGetTextureLevelParameterfv;
extern __declspec(dllimport) PFNGLGETTEXTURELEVELPARAMETERIVPROC __glewGetTextureLevelParameteriv;
extern __declspec(dllimport) PFNGLGETTEXTUREPARAMETERIIVPROC __glewGetTextureParameterIiv;
extern __declspec(dllimport) PFNGLGETTEXTUREPARAMETERIUIVPROC __glewGetTextureParameterIuiv;
extern __declspec(dllimport) PFNGLGETTEXTUREPARAMETERFVPROC __glewGetTextureParameterfv;
extern __declspec(dllimport) PFNGLGETTEXTUREPARAMETERIVPROC __glewGetTextureParameteriv;
extern __declspec(dllimport) PFNGLGETTRANSFORMFEEDBACKI64_VPROC __glewGetTransformFeedbacki64_v;
extern __declspec(dllimport) PFNGLGETTRANSFORMFEEDBACKI_VPROC __glewGetTransformFeedbacki_v;
extern __declspec(dllimport) PFNGLGETTRANSFORMFEEDBACKIVPROC __glewGetTransformFeedbackiv;
extern __declspec(dllimport) PFNGLGETVERTEXARRAYINDEXED64IVPROC __glewGetVertexArrayIndexed64iv;
extern __declspec(dllimport) PFNGLGETVERTEXARRAYINDEXEDIVPROC __glewGetVertexArrayIndexediv;
extern __declspec(dllimport) PFNGLGETVERTEXARRAYIVPROC __glewGetVertexArrayiv;
extern __declspec(dllimport) PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC __glewInvalidateNamedFramebufferData;
extern __declspec(dllimport) PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC __glewInvalidateNamedFramebufferSubData;
extern __declspec(dllimport) PFNGLMAPNAMEDBUFFERPROC __glewMapNamedBuffer;
extern __declspec(dllimport) PFNGLMAPNAMEDBUFFERRANGEPROC __glewMapNamedBufferRange;
extern __declspec(dllimport) PFNGLNAMEDBUFFERDATAPROC __glewNamedBufferData;
extern __declspec(dllimport) PFNGLNAMEDBUFFERSTORAGEPROC __glewNamedBufferStorage;
extern __declspec(dllimport) PFNGLNAMEDBUFFERSUBDATAPROC __glewNamedBufferSubData;
extern __declspec(dllimport) PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC __glewNamedFramebufferDrawBuffer;
extern __declspec(dllimport) PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC __glewNamedFramebufferDrawBuffers;
extern __declspec(dllimport) PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC __glewNamedFramebufferParameteri;
extern __declspec(dllimport) PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC __glewNamedFramebufferReadBuffer;
extern __declspec(dllimport) PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC __glewNamedFramebufferRenderbuffer;
extern __declspec(dllimport) PFNGLNAMEDFRAMEBUFFERTEXTUREPROC __glewNamedFramebufferTexture;
extern __declspec(dllimport) PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC __glewNamedFramebufferTextureLayer;
extern __declspec(dllimport) PFNGLNAMEDRENDERBUFFERSTORAGEPROC __glewNamedRenderbufferStorage;
extern __declspec(dllimport) PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC __glewNamedRenderbufferStorageMultisample;
extern __declspec(dllimport) PFNGLTEXTUREBUFFERPROC __glewTextureBuffer;
extern __declspec(dllimport) PFNGLTEXTUREBUFFERRANGEPROC __glewTextureBufferRange;
extern __declspec(dllimport) PFNGLTEXTUREPARAMETERIIVPROC __glewTextureParameterIiv;
extern __declspec(dllimport) PFNGLTEXTUREPARAMETERIUIVPROC __glewTextureParameterIuiv;
extern __declspec(dllimport) PFNGLTEXTUREPARAMETERFPROC __glewTextureParameterf;
extern __declspec(dllimport) PFNGLTEXTUREPARAMETERFVPROC __glewTextureParameterfv;
extern __declspec(dllimport) PFNGLTEXTUREPARAMETERIPROC __glewTextureParameteri;
extern __declspec(dllimport) PFNGLTEXTUREPARAMETERIVPROC __glewTextureParameteriv;
extern __declspec(dllimport) PFNGLTEXTURESTORAGE1DPROC __glewTextureStorage1D;
extern __declspec(dllimport) PFNGLTEXTURESTORAGE2DPROC __glewTextureStorage2D;
extern __declspec(dllimport) PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC __glewTextureStorage2DMultisample;
extern __declspec(dllimport) PFNGLTEXTURESTORAGE3DPROC __glewTextureStorage3D;
extern __declspec(dllimport) PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC __glewTextureStorage3DMultisample;
extern __declspec(dllimport) PFNGLTEXTURESUBIMAGE1DPROC __glewTextureSubImage1D;
extern __declspec(dllimport) PFNGLTEXTURESUBIMAGE2DPROC __glewTextureSubImage2D;
extern __declspec(dllimport) PFNGLTEXTURESUBIMAGE3DPROC __glewTextureSubImage3D;
extern __declspec(dllimport) PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC __glewTransformFeedbackBufferBase;
extern __declspec(dllimport) PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC __glewTransformFeedbackBufferRange;
extern __declspec(dllimport) PFNGLUNMAPNAMEDBUFFERPROC __glewUnmapNamedBuffer;
extern __declspec(dllimport) PFNGLVERTEXARRAYATTRIBBINDINGPROC __glewVertexArrayAttribBinding;
extern __declspec(dllimport) PFNGLVERTEXARRAYATTRIBFORMATPROC __glewVertexArrayAttribFormat;
extern __declspec(dllimport) PFNGLVERTEXARRAYATTRIBIFORMATPROC __glewVertexArrayAttribIFormat;
extern __declspec(dllimport) PFNGLVERTEXARRAYATTRIBLFORMATPROC __glewVertexArrayAttribLFormat;
extern __declspec(dllimport) PFNGLVERTEXARRAYBINDINGDIVISORPROC __glewVertexArrayBindingDivisor;
extern __declspec(dllimport) PFNGLVERTEXARRAYELEMENTBUFFERPROC __glewVertexArrayElementBuffer;
extern __declspec(dllimport) PFNGLVERTEXARRAYVERTEXBUFFERPROC __glewVertexArrayVertexBuffer;
extern __declspec(dllimport) PFNGLVERTEXARRAYVERTEXBUFFERSPROC __glewVertexArrayVertexBuffers;

extern __declspec(dllimport) PFNGLDRAWBUFFERSARBPROC __glewDrawBuffersARB;

extern __declspec(dllimport) PFNGLBLENDEQUATIONSEPARATEIARBPROC __glewBlendEquationSeparateiARB;
extern __declspec(dllimport) PFNGLBLENDEQUATIONIARBPROC __glewBlendEquationiARB;
extern __declspec(dllimport) PFNGLBLENDFUNCSEPARATEIARBPROC __glewBlendFuncSeparateiARB;
extern __declspec(dllimport) PFNGLBLENDFUNCIARBPROC __glewBlendFunciARB;

extern __declspec(dllimport) PFNGLDRAWELEMENTSBASEVERTEXPROC __glewDrawElementsBaseVertex;
extern __declspec(dllimport) PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC __glewDrawElementsInstancedBaseVertex;
extern __declspec(dllimport) PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC __glewDrawRangeElementsBaseVertex;
extern __declspec(dllimport) PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC __glewMultiDrawElementsBaseVertex;

extern __declspec(dllimport) PFNGLDRAWARRAYSINDIRECTPROC __glewDrawArraysIndirect;
extern __declspec(dllimport) PFNGLDRAWELEMENTSINDIRECTPROC __glewDrawElementsIndirect;

extern __declspec(dllimport) PFNGLFRAMEBUFFERPARAMETERIPROC __glewFramebufferParameteri;
extern __declspec(dllimport) PFNGLGETFRAMEBUFFERPARAMETERIVPROC __glewGetFramebufferParameteriv;
extern __declspec(dllimport) PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVEXTPROC __glewGetNamedFramebufferParameterivEXT;
extern __declspec(dllimport) PFNGLNAMEDFRAMEBUFFERPARAMETERIEXTPROC __glewNamedFramebufferParameteriEXT;

extern __declspec(dllimport) PFNGLBINDFRAMEBUFFERPROC __glewBindFramebuffer;
extern __declspec(dllimport) PFNGLBINDRENDERBUFFERPROC __glewBindRenderbuffer;
extern __declspec(dllimport) PFNGLBLITFRAMEBUFFERPROC __glewBlitFramebuffer;
extern __declspec(dllimport) PFNGLCHECKFRAMEBUFFERSTATUSPROC __glewCheckFramebufferStatus;
extern __declspec(dllimport) PFNGLDELETEFRAMEBUFFERSPROC __glewDeleteFramebuffers;
extern __declspec(dllimport) PFNGLDELETERENDERBUFFERSPROC __glewDeleteRenderbuffers;
extern __declspec(dllimport) PFNGLFRAMEBUFFERRENDERBUFFERPROC __glewFramebufferRenderbuffer;
extern __declspec(dllimport) PFNGLFRAMEBUFFERTEXTURE1DPROC __glewFramebufferTexture1D;
extern __declspec(dllimport) PFNGLFRAMEBUFFERTEXTURE2DPROC __glewFramebufferTexture2D;
extern __declspec(dllimport) PFNGLFRAMEBUFFERTEXTURE3DPROC __glewFramebufferTexture3D;
extern __declspec(dllimport) PFNGLFRAMEBUFFERTEXTURELAYERPROC __glewFramebufferTextureLayer;
extern __declspec(dllimport) PFNGLGENFRAMEBUFFERSPROC __glewGenFramebuffers;
extern __declspec(dllimport) PFNGLGENRENDERBUFFERSPROC __glewGenRenderbuffers;
extern __declspec(dllimport) PFNGLGENERATEMIPMAPPROC __glewGenerateMipmap;
extern __declspec(dllimport) PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC __glewGetFramebufferAttachmentParameteriv;
extern __declspec(dllimport) PFNGLGETRENDERBUFFERPARAMETERIVPROC __glewGetRenderbufferParameteriv;
extern __declspec(dllimport) PFNGLISFRAMEBUFFERPROC __glewIsFramebuffer;
extern __declspec(dllimport) PFNGLISRENDERBUFFERPROC __glewIsRenderbuffer;
extern __declspec(dllimport) PFNGLRENDERBUFFERSTORAGEPROC __glewRenderbufferStorage;
extern __declspec(dllimport) PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC __glewRenderbufferStorageMultisample;

extern __declspec(dllimport) PFNGLFRAMEBUFFERTEXTUREARBPROC __glewFramebufferTextureARB;
extern __declspec(dllimport) PFNGLFRAMEBUFFERTEXTUREFACEARBPROC __glewFramebufferTextureFaceARB;
extern __declspec(dllimport) PFNGLFRAMEBUFFERTEXTURELAYERARBPROC __glewFramebufferTextureLayerARB;
extern __declspec(dllimport) PFNGLPROGRAMPARAMETERIARBPROC __glewProgramParameteriARB;

extern __declspec(dllimport) PFNGLGETPROGRAMBINARYPROC __glewGetProgramBinary;
extern __declspec(dllimport) PFNGLPROGRAMBINARYPROC __glewProgramBinary;
extern __declspec(dllimport) PFNGLPROGRAMPARAMETERIPROC __glewProgramParameteri;

extern __declspec(dllimport) PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC __glewGetCompressedTextureSubImage;
extern __declspec(dllimport) PFNGLGETTEXTURESUBIMAGEPROC __glewGetTextureSubImage;

extern __declspec(dllimport) PFNGLSPECIALIZESHADERARBPROC __glewSpecializeShaderARB;

extern __declspec(dllimport) PFNGLGETUNIFORMDVPROC __glewGetUniformdv;
extern __declspec(dllimport) PFNGLUNIFORM1DPROC __glewUniform1d;
extern __declspec(dllimport) PFNGLUNIFORM1DVPROC __glewUniform1dv;
extern __declspec(dllimport) PFNGLUNIFORM2DPROC __glewUniform2d;
extern __declspec(dllimport) PFNGLUNIFORM2DVPROC __glewUniform2dv;
extern __declspec(dllimport) PFNGLUNIFORM3DPROC __glewUniform3d;
extern __declspec(dllimport) PFNGLUNIFORM3DVPROC __glewUniform3dv;
extern __declspec(dllimport) PFNGLUNIFORM4DPROC __glewUniform4d;
extern __declspec(dllimport) PFNGLUNIFORM4DVPROC __glewUniform4dv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX2DVPROC __glewUniformMatrix2dv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX2X3DVPROC __glewUniformMatrix2x3dv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX2X4DVPROC __glewUniformMatrix2x4dv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX3DVPROC __glewUniformMatrix3dv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX3X2DVPROC __glewUniformMatrix3x2dv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX3X4DVPROC __glewUniformMatrix3x4dv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX4DVPROC __glewUniformMatrix4dv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX4X2DVPROC __glewUniformMatrix4x2dv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX4X3DVPROC __glewUniformMatrix4x3dv;

extern __declspec(dllimport) PFNGLGETUNIFORMI64VARBPROC __glewGetUniformi64vARB;
extern __declspec(dllimport) PFNGLGETUNIFORMUI64VARBPROC __glewGetUniformui64vARB;
extern __declspec(dllimport) PFNGLGETNUNIFORMI64VARBPROC __glewGetnUniformi64vARB;
extern __declspec(dllimport) PFNGLGETNUNIFORMUI64VARBPROC __glewGetnUniformui64vARB;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1I64ARBPROC __glewProgramUniform1i64ARB;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1I64VARBPROC __glewProgramUniform1i64vARB;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1UI64ARBPROC __glewProgramUniform1ui64ARB;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1UI64VARBPROC __glewProgramUniform1ui64vARB;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2I64ARBPROC __glewProgramUniform2i64ARB;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2I64VARBPROC __glewProgramUniform2i64vARB;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2UI64ARBPROC __glewProgramUniform2ui64ARB;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2UI64VARBPROC __glewProgramUniform2ui64vARB;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3I64ARBPROC __glewProgramUniform3i64ARB;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3I64VARBPROC __glewProgramUniform3i64vARB;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3UI64ARBPROC __glewProgramUniform3ui64ARB;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3UI64VARBPROC __glewProgramUniform3ui64vARB;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4I64ARBPROC __glewProgramUniform4i64ARB;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4I64VARBPROC __glewProgramUniform4i64vARB;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4UI64ARBPROC __glewProgramUniform4ui64ARB;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4UI64VARBPROC __glewProgramUniform4ui64vARB;
extern __declspec(dllimport) PFNGLUNIFORM1I64ARBPROC __glewUniform1i64ARB;
extern __declspec(dllimport) PFNGLUNIFORM1I64VARBPROC __glewUniform1i64vARB;
extern __declspec(dllimport) PFNGLUNIFORM1UI64ARBPROC __glewUniform1ui64ARB;
extern __declspec(dllimport) PFNGLUNIFORM1UI64VARBPROC __glewUniform1ui64vARB;
extern __declspec(dllimport) PFNGLUNIFORM2I64ARBPROC __glewUniform2i64ARB;
extern __declspec(dllimport) PFNGLUNIFORM2I64VARBPROC __glewUniform2i64vARB;
extern __declspec(dllimport) PFNGLUNIFORM2UI64ARBPROC __glewUniform2ui64ARB;
extern __declspec(dllimport) PFNGLUNIFORM2UI64VARBPROC __glewUniform2ui64vARB;
extern __declspec(dllimport) PFNGLUNIFORM3I64ARBPROC __glewUniform3i64ARB;
extern __declspec(dllimport) PFNGLUNIFORM3I64VARBPROC __glewUniform3i64vARB;
extern __declspec(dllimport) PFNGLUNIFORM3UI64ARBPROC __glewUniform3ui64ARB;
extern __declspec(dllimport) PFNGLUNIFORM3UI64VARBPROC __glewUniform3ui64vARB;
extern __declspec(dllimport) PFNGLUNIFORM4I64ARBPROC __glewUniform4i64ARB;
extern __declspec(dllimport) PFNGLUNIFORM4I64VARBPROC __glewUniform4i64vARB;
extern __declspec(dllimport) PFNGLUNIFORM4UI64ARBPROC __glewUniform4ui64ARB;
extern __declspec(dllimport) PFNGLUNIFORM4UI64VARBPROC __glewUniform4ui64vARB;

extern __declspec(dllimport) PFNGLCOLORSUBTABLEPROC __glewColorSubTable;
extern __declspec(dllimport) PFNGLCOLORTABLEPROC __glewColorTable;
extern __declspec(dllimport) PFNGLCOLORTABLEPARAMETERFVPROC __glewColorTableParameterfv;
extern __declspec(dllimport) PFNGLCOLORTABLEPARAMETERIVPROC __glewColorTableParameteriv;
extern __declspec(dllimport) PFNGLCONVOLUTIONFILTER1DPROC __glewConvolutionFilter1D;
extern __declspec(dllimport) PFNGLCONVOLUTIONFILTER2DPROC __glewConvolutionFilter2D;
extern __declspec(dllimport) PFNGLCONVOLUTIONPARAMETERFPROC __glewConvolutionParameterf;
extern __declspec(dllimport) PFNGLCONVOLUTIONPARAMETERFVPROC __glewConvolutionParameterfv;
extern __declspec(dllimport) PFNGLCONVOLUTIONPARAMETERIPROC __glewConvolutionParameteri;
extern __declspec(dllimport) PFNGLCONVOLUTIONPARAMETERIVPROC __glewConvolutionParameteriv;
extern __declspec(dllimport) PFNGLCOPYCOLORSUBTABLEPROC __glewCopyColorSubTable;
extern __declspec(dllimport) PFNGLCOPYCOLORTABLEPROC __glewCopyColorTable;
extern __declspec(dllimport) PFNGLCOPYCONVOLUTIONFILTER1DPROC __glewCopyConvolutionFilter1D;
extern __declspec(dllimport) PFNGLCOPYCONVOLUTIONFILTER2DPROC __glewCopyConvolutionFilter2D;
extern __declspec(dllimport) PFNGLGETCOLORTABLEPROC __glewGetColorTable;
extern __declspec(dllimport) PFNGLGETCOLORTABLEPARAMETERFVPROC __glewGetColorTableParameterfv;
extern __declspec(dllimport) PFNGLGETCOLORTABLEPARAMETERIVPROC __glewGetColorTableParameteriv;
extern __declspec(dllimport) PFNGLGETCONVOLUTIONFILTERPROC __glewGetConvolutionFilter;
extern __declspec(dllimport) PFNGLGETCONVOLUTIONPARAMETERFVPROC __glewGetConvolutionParameterfv;
extern __declspec(dllimport) PFNGLGETCONVOLUTIONPARAMETERIVPROC __glewGetConvolutionParameteriv;
extern __declspec(dllimport) PFNGLGETHISTOGRAMPROC __glewGetHistogram;
extern __declspec(dllimport) PFNGLGETHISTOGRAMPARAMETERFVPROC __glewGetHistogramParameterfv;
extern __declspec(dllimport) PFNGLGETHISTOGRAMPARAMETERIVPROC __glewGetHistogramParameteriv;
extern __declspec(dllimport) PFNGLGETMINMAXPROC __glewGetMinmax;
extern __declspec(dllimport) PFNGLGETMINMAXPARAMETERFVPROC __glewGetMinmaxParameterfv;
extern __declspec(dllimport) PFNGLGETMINMAXPARAMETERIVPROC __glewGetMinmaxParameteriv;
extern __declspec(dllimport) PFNGLGETSEPARABLEFILTERPROC __glewGetSeparableFilter;
extern __declspec(dllimport) PFNGLHISTOGRAMPROC __glewHistogram;
extern __declspec(dllimport) PFNGLMINMAXPROC __glewMinmax;
extern __declspec(dllimport) PFNGLRESETHISTOGRAMPROC __glewResetHistogram;
extern __declspec(dllimport) PFNGLRESETMINMAXPROC __glewResetMinmax;
extern __declspec(dllimport) PFNGLSEPARABLEFILTER2DPROC __glewSeparableFilter2D;

extern __declspec(dllimport) PFNGLMULTIDRAWARRAYSINDIRECTCOUNTARBPROC __glewMultiDrawArraysIndirectCountARB;
extern __declspec(dllimport) PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTARBPROC __glewMultiDrawElementsIndirectCountARB;

extern __declspec(dllimport) PFNGLDRAWARRAYSINSTANCEDARBPROC __glewDrawArraysInstancedARB;
extern __declspec(dllimport) PFNGLDRAWELEMENTSINSTANCEDARBPROC __glewDrawElementsInstancedARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIBDIVISORARBPROC __glewVertexAttribDivisorARB;

extern __declspec(dllimport) PFNGLGETINTERNALFORMATIVPROC __glewGetInternalformativ;

extern __declspec(dllimport) PFNGLGETINTERNALFORMATI64VPROC __glewGetInternalformati64v;

extern __declspec(dllimport) PFNGLINVALIDATEBUFFERDATAPROC __glewInvalidateBufferData;
extern __declspec(dllimport) PFNGLINVALIDATEBUFFERSUBDATAPROC __glewInvalidateBufferSubData;
extern __declspec(dllimport) PFNGLINVALIDATEFRAMEBUFFERPROC __glewInvalidateFramebuffer;
extern __declspec(dllimport) PFNGLINVALIDATESUBFRAMEBUFFERPROC __glewInvalidateSubFramebuffer;
extern __declspec(dllimport) PFNGLINVALIDATETEXIMAGEPROC __glewInvalidateTexImage;
extern __declspec(dllimport) PFNGLINVALIDATETEXSUBIMAGEPROC __glewInvalidateTexSubImage;

extern __declspec(dllimport) PFNGLFLUSHMAPPEDBUFFERRANGEPROC __glewFlushMappedBufferRange;
extern __declspec(dllimport) PFNGLMAPBUFFERRANGEPROC __glewMapBufferRange;

extern __declspec(dllimport) PFNGLCURRENTPALETTEMATRIXARBPROC __glewCurrentPaletteMatrixARB;
extern __declspec(dllimport) PFNGLMATRIXINDEXPOINTERARBPROC __glewMatrixIndexPointerARB;
extern __declspec(dllimport) PFNGLMATRIXINDEXUBVARBPROC __glewMatrixIndexubvARB;
extern __declspec(dllimport) PFNGLMATRIXINDEXUIVARBPROC __glewMatrixIndexuivARB;
extern __declspec(dllimport) PFNGLMATRIXINDEXUSVARBPROC __glewMatrixIndexusvARB;

extern __declspec(dllimport) PFNGLBINDBUFFERSBASEPROC __glewBindBuffersBase;
extern __declspec(dllimport) PFNGLBINDBUFFERSRANGEPROC __glewBindBuffersRange;
extern __declspec(dllimport) PFNGLBINDIMAGETEXTURESPROC __glewBindImageTextures;
extern __declspec(dllimport) PFNGLBINDSAMPLERSPROC __glewBindSamplers;
extern __declspec(dllimport) PFNGLBINDTEXTURESPROC __glewBindTextures;
extern __declspec(dllimport) PFNGLBINDVERTEXBUFFERSPROC __glewBindVertexBuffers;

extern __declspec(dllimport) PFNGLMULTIDRAWARRAYSINDIRECTPROC __glewMultiDrawArraysIndirect;
extern __declspec(dllimport) PFNGLMULTIDRAWELEMENTSINDIRECTPROC __glewMultiDrawElementsIndirect;

extern __declspec(dllimport) PFNGLSAMPLECOVERAGEARBPROC __glewSampleCoverageARB;

extern __declspec(dllimport) PFNGLACTIVETEXTUREARBPROC __glewActiveTextureARB;
extern __declspec(dllimport) PFNGLCLIENTACTIVETEXTUREARBPROC __glewClientActiveTextureARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1DARBPROC __glewMultiTexCoord1dARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1DVARBPROC __glewMultiTexCoord1dvARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1FARBPROC __glewMultiTexCoord1fARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1FVARBPROC __glewMultiTexCoord1fvARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1IARBPROC __glewMultiTexCoord1iARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1IVARBPROC __glewMultiTexCoord1ivARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1SARBPROC __glewMultiTexCoord1sARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1SVARBPROC __glewMultiTexCoord1svARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2DARBPROC __glewMultiTexCoord2dARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2DVARBPROC __glewMultiTexCoord2dvARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2FARBPROC __glewMultiTexCoord2fARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2FVARBPROC __glewMultiTexCoord2fvARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2IARBPROC __glewMultiTexCoord2iARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2IVARBPROC __glewMultiTexCoord2ivARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2SARBPROC __glewMultiTexCoord2sARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2SVARBPROC __glewMultiTexCoord2svARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3DARBPROC __glewMultiTexCoord3dARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3DVARBPROC __glewMultiTexCoord3dvARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3FARBPROC __glewMultiTexCoord3fARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3FVARBPROC __glewMultiTexCoord3fvARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3IARBPROC __glewMultiTexCoord3iARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3IVARBPROC __glewMultiTexCoord3ivARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3SARBPROC __glewMultiTexCoord3sARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3SVARBPROC __glewMultiTexCoord3svARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4DARBPROC __glewMultiTexCoord4dARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4DVARBPROC __glewMultiTexCoord4dvARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4FARBPROC __glewMultiTexCoord4fARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4FVARBPROC __glewMultiTexCoord4fvARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4IARBPROC __glewMultiTexCoord4iARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4IVARBPROC __glewMultiTexCoord4ivARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4SARBPROC __glewMultiTexCoord4sARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4SVARBPROC __glewMultiTexCoord4svARB;

extern __declspec(dllimport) PFNGLBEGINQUERYARBPROC __glewBeginQueryARB;
extern __declspec(dllimport) PFNGLDELETEQUERIESARBPROC __glewDeleteQueriesARB;
extern __declspec(dllimport) PFNGLENDQUERYARBPROC __glewEndQueryARB;
extern __declspec(dllimport) PFNGLGENQUERIESARBPROC __glewGenQueriesARB;
extern __declspec(dllimport) PFNGLGETQUERYOBJECTIVARBPROC __glewGetQueryObjectivARB;
extern __declspec(dllimport) PFNGLGETQUERYOBJECTUIVARBPROC __glewGetQueryObjectuivARB;
extern __declspec(dllimport) PFNGLGETQUERYIVARBPROC __glewGetQueryivARB;
extern __declspec(dllimport) PFNGLISQUERYARBPROC __glewIsQueryARB;

extern __declspec(dllimport) PFNGLMAXSHADERCOMPILERTHREADSARBPROC __glewMaxShaderCompilerThreadsARB;

extern __declspec(dllimport) PFNGLPOINTPARAMETERFARBPROC __glewPointParameterfARB;
extern __declspec(dllimport) PFNGLPOINTPARAMETERFVARBPROC __glewPointParameterfvARB;

extern __declspec(dllimport) PFNGLPOLYGONOFFSETCLAMPPROC __glewPolygonOffsetClamp;

extern __declspec(dllimport) PFNGLGETPROGRAMINTERFACEIVPROC __glewGetProgramInterfaceiv;
extern __declspec(dllimport) PFNGLGETPROGRAMRESOURCEINDEXPROC __glewGetProgramResourceIndex;
extern __declspec(dllimport) PFNGLGETPROGRAMRESOURCELOCATIONPROC __glewGetProgramResourceLocation;
extern __declspec(dllimport) PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC __glewGetProgramResourceLocationIndex;
extern __declspec(dllimport) PFNGLGETPROGRAMRESOURCENAMEPROC __glewGetProgramResourceName;
extern __declspec(dllimport) PFNGLGETPROGRAMRESOURCEIVPROC __glewGetProgramResourceiv;

extern __declspec(dllimport) PFNGLPROVOKINGVERTEXPROC __glewProvokingVertex;

extern __declspec(dllimport) PFNGLGETGRAPHICSRESETSTATUSARBPROC __glewGetGraphicsResetStatusARB;
extern __declspec(dllimport) PFNGLGETNCOLORTABLEARBPROC __glewGetnColorTableARB;
extern __declspec(dllimport) PFNGLGETNCOMPRESSEDTEXIMAGEARBPROC __glewGetnCompressedTexImageARB;
extern __declspec(dllimport) PFNGLGETNCONVOLUTIONFILTERARBPROC __glewGetnConvolutionFilterARB;
extern __declspec(dllimport) PFNGLGETNHISTOGRAMARBPROC __glewGetnHistogramARB;
extern __declspec(dllimport) PFNGLGETNMAPDVARBPROC __glewGetnMapdvARB;
extern __declspec(dllimport) PFNGLGETNMAPFVARBPROC __glewGetnMapfvARB;
extern __declspec(dllimport) PFNGLGETNMAPIVARBPROC __glewGetnMapivARB;
extern __declspec(dllimport) PFNGLGETNMINMAXARBPROC __glewGetnMinmaxARB;
extern __declspec(dllimport) PFNGLGETNPIXELMAPFVARBPROC __glewGetnPixelMapfvARB;
extern __declspec(dllimport) PFNGLGETNPIXELMAPUIVARBPROC __glewGetnPixelMapuivARB;
extern __declspec(dllimport) PFNGLGETNPIXELMAPUSVARBPROC __glewGetnPixelMapusvARB;
extern __declspec(dllimport) PFNGLGETNPOLYGONSTIPPLEARBPROC __glewGetnPolygonStippleARB;
extern __declspec(dllimport) PFNGLGETNSEPARABLEFILTERARBPROC __glewGetnSeparableFilterARB;
extern __declspec(dllimport) PFNGLGETNTEXIMAGEARBPROC __glewGetnTexImageARB;
extern __declspec(dllimport) PFNGLGETNUNIFORMDVARBPROC __glewGetnUniformdvARB;
extern __declspec(dllimport) PFNGLGETNUNIFORMFVARBPROC __glewGetnUniformfvARB;
extern __declspec(dllimport) PFNGLGETNUNIFORMIVARBPROC __glewGetnUniformivARB;
extern __declspec(dllimport) PFNGLGETNUNIFORMUIVARBPROC __glewGetnUniformuivARB;
extern __declspec(dllimport) PFNGLREADNPIXELSARBPROC __glewReadnPixelsARB;

extern __declspec(dllimport) PFNGLFRAMEBUFFERSAMPLELOCATIONSFVARBPROC __glewFramebufferSampleLocationsfvARB;
extern __declspec(dllimport) PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVARBPROC __glewNamedFramebufferSampleLocationsfvARB;

extern __declspec(dllimport) PFNGLMINSAMPLESHADINGARBPROC __glewMinSampleShadingARB;

extern __declspec(dllimport) PFNGLBINDSAMPLERPROC __glewBindSampler;
extern __declspec(dllimport) PFNGLDELETESAMPLERSPROC __glewDeleteSamplers;
extern __declspec(dllimport) PFNGLGENSAMPLERSPROC __glewGenSamplers;
extern __declspec(dllimport) PFNGLGETSAMPLERPARAMETERIIVPROC __glewGetSamplerParameterIiv;
extern __declspec(dllimport) PFNGLGETSAMPLERPARAMETERIUIVPROC __glewGetSamplerParameterIuiv;
extern __declspec(dllimport) PFNGLGETSAMPLERPARAMETERFVPROC __glewGetSamplerParameterfv;
extern __declspec(dllimport) PFNGLGETSAMPLERPARAMETERIVPROC __glewGetSamplerParameteriv;
extern __declspec(dllimport) PFNGLISSAMPLERPROC __glewIsSampler;
extern __declspec(dllimport) PFNGLSAMPLERPARAMETERIIVPROC __glewSamplerParameterIiv;
extern __declspec(dllimport) PFNGLSAMPLERPARAMETERIUIVPROC __glewSamplerParameterIuiv;
extern __declspec(dllimport) PFNGLSAMPLERPARAMETERFPROC __glewSamplerParameterf;
extern __declspec(dllimport) PFNGLSAMPLERPARAMETERFVPROC __glewSamplerParameterfv;
extern __declspec(dllimport) PFNGLSAMPLERPARAMETERIPROC __glewSamplerParameteri;
extern __declspec(dllimport) PFNGLSAMPLERPARAMETERIVPROC __glewSamplerParameteriv;

extern __declspec(dllimport) PFNGLACTIVESHADERPROGRAMPROC __glewActiveShaderProgram;
extern __declspec(dllimport) PFNGLBINDPROGRAMPIPELINEPROC __glewBindProgramPipeline;
extern __declspec(dllimport) PFNGLCREATESHADERPROGRAMVPROC __glewCreateShaderProgramv;
extern __declspec(dllimport) PFNGLDELETEPROGRAMPIPELINESPROC __glewDeleteProgramPipelines;
extern __declspec(dllimport) PFNGLGENPROGRAMPIPELINESPROC __glewGenProgramPipelines;
extern __declspec(dllimport) PFNGLGETPROGRAMPIPELINEINFOLOGPROC __glewGetProgramPipelineInfoLog;
extern __declspec(dllimport) PFNGLGETPROGRAMPIPELINEIVPROC __glewGetProgramPipelineiv;
extern __declspec(dllimport) PFNGLISPROGRAMPIPELINEPROC __glewIsProgramPipeline;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1DPROC __glewProgramUniform1d;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1DVPROC __glewProgramUniform1dv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1FPROC __glewProgramUniform1f;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1FVPROC __glewProgramUniform1fv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1IPROC __glewProgramUniform1i;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1IVPROC __glewProgramUniform1iv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1UIPROC __glewProgramUniform1ui;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1UIVPROC __glewProgramUniform1uiv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2DPROC __glewProgramUniform2d;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2DVPROC __glewProgramUniform2dv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2FPROC __glewProgramUniform2f;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2FVPROC __glewProgramUniform2fv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2IPROC __glewProgramUniform2i;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2IVPROC __glewProgramUniform2iv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2UIPROC __glewProgramUniform2ui;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2UIVPROC __glewProgramUniform2uiv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3DPROC __glewProgramUniform3d;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3DVPROC __glewProgramUniform3dv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3FPROC __glewProgramUniform3f;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3FVPROC __glewProgramUniform3fv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3IPROC __glewProgramUniform3i;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3IVPROC __glewProgramUniform3iv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3UIPROC __glewProgramUniform3ui;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3UIVPROC __glewProgramUniform3uiv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4DPROC __glewProgramUniform4d;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4DVPROC __glewProgramUniform4dv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4FPROC __glewProgramUniform4f;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4FVPROC __glewProgramUniform4fv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4IPROC __glewProgramUniform4i;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4IVPROC __glewProgramUniform4iv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4UIPROC __glewProgramUniform4ui;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4UIVPROC __glewProgramUniform4uiv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX2DVPROC __glewProgramUniformMatrix2dv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX2FVPROC __glewProgramUniformMatrix2fv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC __glewProgramUniformMatrix2x3dv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC __glewProgramUniformMatrix2x3fv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC __glewProgramUniformMatrix2x4dv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC __glewProgramUniformMatrix2x4fv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX3DVPROC __glewProgramUniformMatrix3dv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX3FVPROC __glewProgramUniformMatrix3fv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC __glewProgramUniformMatrix3x2dv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC __glewProgramUniformMatrix3x2fv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC __glewProgramUniformMatrix3x4dv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC __glewProgramUniformMatrix3x4fv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX4DVPROC __glewProgramUniformMatrix4dv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX4FVPROC __glewProgramUniformMatrix4fv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC __glewProgramUniformMatrix4x2dv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC __glewProgramUniformMatrix4x2fv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC __glewProgramUniformMatrix4x3dv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC __glewProgramUniformMatrix4x3fv;
extern __declspec(dllimport) PFNGLUSEPROGRAMSTAGESPROC __glewUseProgramStages;
extern __declspec(dllimport) PFNGLVALIDATEPROGRAMPIPELINEPROC __glewValidateProgramPipeline;

extern __declspec(dllimport) PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC __glewGetActiveAtomicCounterBufferiv;

extern __declspec(dllimport) PFNGLBINDIMAGETEXTUREPROC __glewBindImageTexture;
extern __declspec(dllimport) PFNGLMEMORYBARRIERPROC __glewMemoryBarrier;

extern __declspec(dllimport) PFNGLATTACHOBJECTARBPROC __glewAttachObjectARB;
extern __declspec(dllimport) PFNGLCOMPILESHADERARBPROC __glewCompileShaderARB;
extern __declspec(dllimport) PFNGLCREATEPROGRAMOBJECTARBPROC __glewCreateProgramObjectARB;
extern __declspec(dllimport) PFNGLCREATESHADEROBJECTARBPROC __glewCreateShaderObjectARB;
extern __declspec(dllimport) PFNGLDELETEOBJECTARBPROC __glewDeleteObjectARB;
extern __declspec(dllimport) PFNGLDETACHOBJECTARBPROC __glewDetachObjectARB;
extern __declspec(dllimport) PFNGLGETACTIVEUNIFORMARBPROC __glewGetActiveUniformARB;
extern __declspec(dllimport) PFNGLGETATTACHEDOBJECTSARBPROC __glewGetAttachedObjectsARB;
extern __declspec(dllimport) PFNGLGETHANDLEARBPROC __glewGetHandleARB;
extern __declspec(dllimport) PFNGLGETINFOLOGARBPROC __glewGetInfoLogARB;
extern __declspec(dllimport) PFNGLGETOBJECTPARAMETERFVARBPROC __glewGetObjectParameterfvARB;
extern __declspec(dllimport) PFNGLGETOBJECTPARAMETERIVARBPROC __glewGetObjectParameterivARB;
extern __declspec(dllimport) PFNGLGETSHADERSOURCEARBPROC __glewGetShaderSourceARB;
extern __declspec(dllimport) PFNGLGETUNIFORMLOCATIONARBPROC __glewGetUniformLocationARB;
extern __declspec(dllimport) PFNGLGETUNIFORMFVARBPROC __glewGetUniformfvARB;
extern __declspec(dllimport) PFNGLGETUNIFORMIVARBPROC __glewGetUniformivARB;
extern __declspec(dllimport) PFNGLLINKPROGRAMARBPROC __glewLinkProgramARB;
extern __declspec(dllimport) PFNGLSHADERSOURCEARBPROC __glewShaderSourceARB;
extern __declspec(dllimport) PFNGLUNIFORM1FARBPROC __glewUniform1fARB;
extern __declspec(dllimport) PFNGLUNIFORM1FVARBPROC __glewUniform1fvARB;
extern __declspec(dllimport) PFNGLUNIFORM1IARBPROC __glewUniform1iARB;
extern __declspec(dllimport) PFNGLUNIFORM1IVARBPROC __glewUniform1ivARB;
extern __declspec(dllimport) PFNGLUNIFORM2FARBPROC __glewUniform2fARB;
extern __declspec(dllimport) PFNGLUNIFORM2FVARBPROC __glewUniform2fvARB;
extern __declspec(dllimport) PFNGLUNIFORM2IARBPROC __glewUniform2iARB;
extern __declspec(dllimport) PFNGLUNIFORM2IVARBPROC __glewUniform2ivARB;
extern __declspec(dllimport) PFNGLUNIFORM3FARBPROC __glewUniform3fARB;
extern __declspec(dllimport) PFNGLUNIFORM3FVARBPROC __glewUniform3fvARB;
extern __declspec(dllimport) PFNGLUNIFORM3IARBPROC __glewUniform3iARB;
extern __declspec(dllimport) PFNGLUNIFORM3IVARBPROC __glewUniform3ivARB;
extern __declspec(dllimport) PFNGLUNIFORM4FARBPROC __glewUniform4fARB;
extern __declspec(dllimport) PFNGLUNIFORM4FVARBPROC __glewUniform4fvARB;
extern __declspec(dllimport) PFNGLUNIFORM4IARBPROC __glewUniform4iARB;
extern __declspec(dllimport) PFNGLUNIFORM4IVARBPROC __glewUniform4ivARB;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX2FVARBPROC __glewUniformMatrix2fvARB;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX3FVARBPROC __glewUniformMatrix3fvARB;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX4FVARBPROC __glewUniformMatrix4fvARB;
extern __declspec(dllimport) PFNGLUSEPROGRAMOBJECTARBPROC __glewUseProgramObjectARB;
extern __declspec(dllimport) PFNGLVALIDATEPROGRAMARBPROC __glewValidateProgramARB;

extern __declspec(dllimport) PFNGLSHADERSTORAGEBLOCKBINDINGPROC __glewShaderStorageBlockBinding;

extern __declspec(dllimport) PFNGLGETACTIVESUBROUTINENAMEPROC __glewGetActiveSubroutineName;
extern __declspec(dllimport) PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC __glewGetActiveSubroutineUniformName;
extern __declspec(dllimport) PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC __glewGetActiveSubroutineUniformiv;
extern __declspec(dllimport) PFNGLGETPROGRAMSTAGEIVPROC __glewGetProgramStageiv;
extern __declspec(dllimport) PFNGLGETSUBROUTINEINDEXPROC __glewGetSubroutineIndex;
extern __declspec(dllimport) PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC __glewGetSubroutineUniformLocation;
extern __declspec(dllimport) PFNGLGETUNIFORMSUBROUTINEUIVPROC __glewGetUniformSubroutineuiv;
extern __declspec(dllimport) PFNGLUNIFORMSUBROUTINESUIVPROC __glewUniformSubroutinesuiv;

extern __declspec(dllimport) PFNGLCOMPILESHADERINCLUDEARBPROC __glewCompileShaderIncludeARB;
extern __declspec(dllimport) PFNGLDELETENAMEDSTRINGARBPROC __glewDeleteNamedStringARB;
extern __declspec(dllimport) PFNGLGETNAMEDSTRINGARBPROC __glewGetNamedStringARB;
extern __declspec(dllimport) PFNGLGETNAMEDSTRINGIVARBPROC __glewGetNamedStringivARB;
extern __declspec(dllimport) PFNGLISNAMEDSTRINGARBPROC __glewIsNamedStringARB;
extern __declspec(dllimport) PFNGLNAMEDSTRINGARBPROC __glewNamedStringARB;

extern __declspec(dllimport) PFNGLBUFFERPAGECOMMITMENTARBPROC __glewBufferPageCommitmentARB;

extern __declspec(dllimport) PFNGLTEXPAGECOMMITMENTARBPROC __glewTexPageCommitmentARB;

extern __declspec(dllimport) PFNGLCLIENTWAITSYNCPROC __glewClientWaitSync;
extern __declspec(dllimport) PFNGLDELETESYNCPROC __glewDeleteSync;
extern __declspec(dllimport) PFNGLFENCESYNCPROC __glewFenceSync;
extern __declspec(dllimport) PFNGLGETINTEGER64VPROC __glewGetInteger64v;
extern __declspec(dllimport) PFNGLGETSYNCIVPROC __glewGetSynciv;
extern __declspec(dllimport) PFNGLISSYNCPROC __glewIsSync;
extern __declspec(dllimport) PFNGLWAITSYNCPROC __glewWaitSync;

extern __declspec(dllimport) PFNGLPATCHPARAMETERFVPROC __glewPatchParameterfv;
extern __declspec(dllimport) PFNGLPATCHPARAMETERIPROC __glewPatchParameteri;

extern __declspec(dllimport) PFNGLTEXTUREBARRIERPROC __glewTextureBarrier;

extern __declspec(dllimport) PFNGLTEXBUFFERARBPROC __glewTexBufferARB;

extern __declspec(dllimport) PFNGLTEXBUFFERRANGEPROC __glewTexBufferRange;
extern __declspec(dllimport) PFNGLTEXTUREBUFFERRANGEEXTPROC __glewTextureBufferRangeEXT;

extern __declspec(dllimport) PFNGLCOMPRESSEDTEXIMAGE1DARBPROC __glewCompressedTexImage1DARB;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXIMAGE2DARBPROC __glewCompressedTexImage2DARB;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXIMAGE3DARBPROC __glewCompressedTexImage3DARB;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC __glewCompressedTexSubImage1DARB;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC __glewCompressedTexSubImage2DARB;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC __glewCompressedTexSubImage3DARB;
extern __declspec(dllimport) PFNGLGETCOMPRESSEDTEXIMAGEARBPROC __glewGetCompressedTexImageARB;

extern __declspec(dllimport) PFNGLGETMULTISAMPLEFVPROC __glewGetMultisamplefv;
extern __declspec(dllimport) PFNGLSAMPLEMASKIPROC __glewSampleMaski;
extern __declspec(dllimport) PFNGLTEXIMAGE2DMULTISAMPLEPROC __glewTexImage2DMultisample;
extern __declspec(dllimport) PFNGLTEXIMAGE3DMULTISAMPLEPROC __glewTexImage3DMultisample;

extern __declspec(dllimport) PFNGLTEXSTORAGE1DPROC __glewTexStorage1D;
extern __declspec(dllimport) PFNGLTEXSTORAGE2DPROC __glewTexStorage2D;
extern __declspec(dllimport) PFNGLTEXSTORAGE3DPROC __glewTexStorage3D;

extern __declspec(dllimport) PFNGLTEXSTORAGE2DMULTISAMPLEPROC __glewTexStorage2DMultisample;
extern __declspec(dllimport) PFNGLTEXSTORAGE3DMULTISAMPLEPROC __glewTexStorage3DMultisample;
extern __declspec(dllimport) PFNGLTEXTURESTORAGE2DMULTISAMPLEEXTPROC __glewTextureStorage2DMultisampleEXT;
extern __declspec(dllimport) PFNGLTEXTURESTORAGE3DMULTISAMPLEEXTPROC __glewTextureStorage3DMultisampleEXT;

extern __declspec(dllimport) PFNGLTEXTUREVIEWPROC __glewTextureView;

extern __declspec(dllimport) PFNGLGETQUERYOBJECTI64VPROC __glewGetQueryObjecti64v;
extern __declspec(dllimport) PFNGLGETQUERYOBJECTUI64VPROC __glewGetQueryObjectui64v;
extern __declspec(dllimport) PFNGLQUERYCOUNTERPROC __glewQueryCounter;

extern __declspec(dllimport) PFNGLBINDTRANSFORMFEEDBACKPROC __glewBindTransformFeedback;
extern __declspec(dllimport) PFNGLDELETETRANSFORMFEEDBACKSPROC __glewDeleteTransformFeedbacks;
extern __declspec(dllimport) PFNGLDRAWTRANSFORMFEEDBACKPROC __glewDrawTransformFeedback;
extern __declspec(dllimport) PFNGLGENTRANSFORMFEEDBACKSPROC __glewGenTransformFeedbacks;
extern __declspec(dllimport) PFNGLISTRANSFORMFEEDBACKPROC __glewIsTransformFeedback;
extern __declspec(dllimport) PFNGLPAUSETRANSFORMFEEDBACKPROC __glewPauseTransformFeedback;
extern __declspec(dllimport) PFNGLRESUMETRANSFORMFEEDBACKPROC __glewResumeTransformFeedback;

extern __declspec(dllimport) PFNGLBEGINQUERYINDEXEDPROC __glewBeginQueryIndexed;
extern __declspec(dllimport) PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC __glewDrawTransformFeedbackStream;
extern __declspec(dllimport) PFNGLENDQUERYINDEXEDPROC __glewEndQueryIndexed;
extern __declspec(dllimport) PFNGLGETQUERYINDEXEDIVPROC __glewGetQueryIndexediv;

extern __declspec(dllimport) PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC __glewDrawTransformFeedbackInstanced;
extern __declspec(dllimport) PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC __glewDrawTransformFeedbackStreamInstanced;

extern __declspec(dllimport) PFNGLLOADTRANSPOSEMATRIXDARBPROC __glewLoadTransposeMatrixdARB;
extern __declspec(dllimport) PFNGLLOADTRANSPOSEMATRIXFARBPROC __glewLoadTransposeMatrixfARB;
extern __declspec(dllimport) PFNGLMULTTRANSPOSEMATRIXDARBPROC __glewMultTransposeMatrixdARB;
extern __declspec(dllimport) PFNGLMULTTRANSPOSEMATRIXFARBPROC __glewMultTransposeMatrixfARB;

extern __declspec(dllimport) PFNGLBINDBUFFERBASEPROC __glewBindBufferBase;
extern __declspec(dllimport) PFNGLBINDBUFFERRANGEPROC __glewBindBufferRange;
extern __declspec(dllimport) PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC __glewGetActiveUniformBlockName;
extern __declspec(dllimport) PFNGLGETACTIVEUNIFORMBLOCKIVPROC __glewGetActiveUniformBlockiv;
extern __declspec(dllimport) PFNGLGETACTIVEUNIFORMNAMEPROC __glewGetActiveUniformName;
extern __declspec(dllimport) PFNGLGETACTIVEUNIFORMSIVPROC __glewGetActiveUniformsiv;
extern __declspec(dllimport) PFNGLGETINTEGERI_VPROC __glewGetIntegeri_v;
extern __declspec(dllimport) PFNGLGETUNIFORMBLOCKINDEXPROC __glewGetUniformBlockIndex;
extern __declspec(dllimport) PFNGLGETUNIFORMINDICESPROC __glewGetUniformIndices;
extern __declspec(dllimport) PFNGLUNIFORMBLOCKBINDINGPROC __glewUniformBlockBinding;

extern __declspec(dllimport) PFNGLBINDVERTEXARRAYPROC __glewBindVertexArray;
extern __declspec(dllimport) PFNGLDELETEVERTEXARRAYSPROC __glewDeleteVertexArrays;
extern __declspec(dllimport) PFNGLGENVERTEXARRAYSPROC __glewGenVertexArrays;
extern __declspec(dllimport) PFNGLISVERTEXARRAYPROC __glewIsVertexArray;

extern __declspec(dllimport) PFNGLGETVERTEXATTRIBLDVPROC __glewGetVertexAttribLdv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL1DPROC __glewVertexAttribL1d;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL1DVPROC __glewVertexAttribL1dv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL2DPROC __glewVertexAttribL2d;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL2DVPROC __glewVertexAttribL2dv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL3DPROC __glewVertexAttribL3d;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL3DVPROC __glewVertexAttribL3dv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL4DPROC __glewVertexAttribL4d;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL4DVPROC __glewVertexAttribL4dv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBLPOINTERPROC __glewVertexAttribLPointer;

extern __declspec(dllimport) PFNGLBINDVERTEXBUFFERPROC __glewBindVertexBuffer;
extern __declspec(dllimport) PFNGLVERTEXARRAYBINDVERTEXBUFFEREXTPROC __glewVertexArrayBindVertexBufferEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYVERTEXATTRIBBINDINGEXTPROC __glewVertexArrayVertexAttribBindingEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYVERTEXATTRIBFORMATEXTPROC __glewVertexArrayVertexAttribFormatEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYVERTEXATTRIBIFORMATEXTPROC __glewVertexArrayVertexAttribIFormatEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYVERTEXATTRIBLFORMATEXTPROC __glewVertexArrayVertexAttribLFormatEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYVERTEXBINDINGDIVISOREXTPROC __glewVertexArrayVertexBindingDivisorEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBBINDINGPROC __glewVertexAttribBinding;
extern __declspec(dllimport) PFNGLVERTEXATTRIBFORMATPROC __glewVertexAttribFormat;
extern __declspec(dllimport) PFNGLVERTEXATTRIBIFORMATPROC __glewVertexAttribIFormat;
extern __declspec(dllimport) PFNGLVERTEXATTRIBLFORMATPROC __glewVertexAttribLFormat;
extern __declspec(dllimport) PFNGLVERTEXBINDINGDIVISORPROC __glewVertexBindingDivisor;

extern __declspec(dllimport) PFNGLVERTEXBLENDARBPROC __glewVertexBlendARB;
extern __declspec(dllimport) PFNGLWEIGHTPOINTERARBPROC __glewWeightPointerARB;
extern __declspec(dllimport) PFNGLWEIGHTBVARBPROC __glewWeightbvARB;
extern __declspec(dllimport) PFNGLWEIGHTDVARBPROC __glewWeightdvARB;
extern __declspec(dllimport) PFNGLWEIGHTFVARBPROC __glewWeightfvARB;
extern __declspec(dllimport) PFNGLWEIGHTIVARBPROC __glewWeightivARB;
extern __declspec(dllimport) PFNGLWEIGHTSVARBPROC __glewWeightsvARB;
extern __declspec(dllimport) PFNGLWEIGHTUBVARBPROC __glewWeightubvARB;
extern __declspec(dllimport) PFNGLWEIGHTUIVARBPROC __glewWeightuivARB;
extern __declspec(dllimport) PFNGLWEIGHTUSVARBPROC __glewWeightusvARB;

extern __declspec(dllimport) PFNGLBINDBUFFERARBPROC __glewBindBufferARB;
extern __declspec(dllimport) PFNGLBUFFERDATAARBPROC __glewBufferDataARB;
extern __declspec(dllimport) PFNGLBUFFERSUBDATAARBPROC __glewBufferSubDataARB;
extern __declspec(dllimport) PFNGLDELETEBUFFERSARBPROC __glewDeleteBuffersARB;
extern __declspec(dllimport) PFNGLGENBUFFERSARBPROC __glewGenBuffersARB;
extern __declspec(dllimport) PFNGLGETBUFFERPARAMETERIVARBPROC __glewGetBufferParameterivARB;
extern __declspec(dllimport) PFNGLGETBUFFERPOINTERVARBPROC __glewGetBufferPointervARB;
extern __declspec(dllimport) PFNGLGETBUFFERSUBDATAARBPROC __glewGetBufferSubDataARB;
extern __declspec(dllimport) PFNGLISBUFFERARBPROC __glewIsBufferARB;
extern __declspec(dllimport) PFNGLMAPBUFFERARBPROC __glewMapBufferARB;
extern __declspec(dllimport) PFNGLUNMAPBUFFERARBPROC __glewUnmapBufferARB;

extern __declspec(dllimport) PFNGLBINDPROGRAMARBPROC __glewBindProgramARB;
extern __declspec(dllimport) PFNGLDELETEPROGRAMSARBPROC __glewDeleteProgramsARB;
extern __declspec(dllimport) PFNGLDISABLEVERTEXATTRIBARRAYARBPROC __glewDisableVertexAttribArrayARB;
extern __declspec(dllimport) PFNGLENABLEVERTEXATTRIBARRAYARBPROC __glewEnableVertexAttribArrayARB;
extern __declspec(dllimport) PFNGLGENPROGRAMSARBPROC __glewGenProgramsARB;
extern __declspec(dllimport) PFNGLGETPROGRAMENVPARAMETERDVARBPROC __glewGetProgramEnvParameterdvARB;
extern __declspec(dllimport) PFNGLGETPROGRAMENVPARAMETERFVARBPROC __glewGetProgramEnvParameterfvARB;
extern __declspec(dllimport) PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC __glewGetProgramLocalParameterdvARB;
extern __declspec(dllimport) PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC __glewGetProgramLocalParameterfvARB;
extern __declspec(dllimport) PFNGLGETPROGRAMSTRINGARBPROC __glewGetProgramStringARB;
extern __declspec(dllimport) PFNGLGETPROGRAMIVARBPROC __glewGetProgramivARB;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBPOINTERVARBPROC __glewGetVertexAttribPointervARB;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBDVARBPROC __glewGetVertexAttribdvARB;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBFVARBPROC __glewGetVertexAttribfvARB;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBIVARBPROC __glewGetVertexAttribivARB;
extern __declspec(dllimport) PFNGLISPROGRAMARBPROC __glewIsProgramARB;
extern __declspec(dllimport) PFNGLPROGRAMENVPARAMETER4DARBPROC __glewProgramEnvParameter4dARB;
extern __declspec(dllimport) PFNGLPROGRAMENVPARAMETER4DVARBPROC __glewProgramEnvParameter4dvARB;
extern __declspec(dllimport) PFNGLPROGRAMENVPARAMETER4FARBPROC __glewProgramEnvParameter4fARB;
extern __declspec(dllimport) PFNGLPROGRAMENVPARAMETER4FVARBPROC __glewProgramEnvParameter4fvARB;
extern __declspec(dllimport) PFNGLPROGRAMLOCALPARAMETER4DARBPROC __glewProgramLocalParameter4dARB;
extern __declspec(dllimport) PFNGLPROGRAMLOCALPARAMETER4DVARBPROC __glewProgramLocalParameter4dvARB;
extern __declspec(dllimport) PFNGLPROGRAMLOCALPARAMETER4FARBPROC __glewProgramLocalParameter4fARB;
extern __declspec(dllimport) PFNGLPROGRAMLOCALPARAMETER4FVARBPROC __glewProgramLocalParameter4fvARB;
extern __declspec(dllimport) PFNGLPROGRAMSTRINGARBPROC __glewProgramStringARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1DARBPROC __glewVertexAttrib1dARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1DVARBPROC __glewVertexAttrib1dvARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1FARBPROC __glewVertexAttrib1fARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1FVARBPROC __glewVertexAttrib1fvARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1SARBPROC __glewVertexAttrib1sARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1SVARBPROC __glewVertexAttrib1svARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2DARBPROC __glewVertexAttrib2dARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2DVARBPROC __glewVertexAttrib2dvARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2FARBPROC __glewVertexAttrib2fARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2FVARBPROC __glewVertexAttrib2fvARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2SARBPROC __glewVertexAttrib2sARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2SVARBPROC __glewVertexAttrib2svARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3DARBPROC __glewVertexAttrib3dARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3DVARBPROC __glewVertexAttrib3dvARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3FARBPROC __glewVertexAttrib3fARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3FVARBPROC __glewVertexAttrib3fvARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3SARBPROC __glewVertexAttrib3sARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3SVARBPROC __glewVertexAttrib3svARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4NBVARBPROC __glewVertexAttrib4NbvARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4NIVARBPROC __glewVertexAttrib4NivARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4NSVARBPROC __glewVertexAttrib4NsvARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4NUBARBPROC __glewVertexAttrib4NubARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4NUBVARBPROC __glewVertexAttrib4NubvARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4NUIVARBPROC __glewVertexAttrib4NuivARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4NUSVARBPROC __glewVertexAttrib4NusvARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4BVARBPROC __glewVertexAttrib4bvARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4DARBPROC __glewVertexAttrib4dARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4DVARBPROC __glewVertexAttrib4dvARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4FARBPROC __glewVertexAttrib4fARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4FVARBPROC __glewVertexAttrib4fvARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4IVARBPROC __glewVertexAttrib4ivARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4SARBPROC __glewVertexAttrib4sARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4SVARBPROC __glewVertexAttrib4svARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4UBVARBPROC __glewVertexAttrib4ubvARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4UIVARBPROC __glewVertexAttrib4uivARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4USVARBPROC __glewVertexAttrib4usvARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIBPOINTERARBPROC __glewVertexAttribPointerARB;

extern __declspec(dllimport) PFNGLBINDATTRIBLOCATIONARBPROC __glewBindAttribLocationARB;
extern __declspec(dllimport) PFNGLGETACTIVEATTRIBARBPROC __glewGetActiveAttribARB;
extern __declspec(dllimport) PFNGLGETATTRIBLOCATIONARBPROC __glewGetAttribLocationARB;

extern __declspec(dllimport) PFNGLCOLORP3UIPROC __glewColorP3ui;
extern __declspec(dllimport) PFNGLCOLORP3UIVPROC __glewColorP3uiv;
extern __declspec(dllimport) PFNGLCOLORP4UIPROC __glewColorP4ui;
extern __declspec(dllimport) PFNGLCOLORP4UIVPROC __glewColorP4uiv;
extern __declspec(dllimport) PFNGLMULTITEXCOORDP1UIPROC __glewMultiTexCoordP1ui;
extern __declspec(dllimport) PFNGLMULTITEXCOORDP1UIVPROC __glewMultiTexCoordP1uiv;
extern __declspec(dllimport) PFNGLMULTITEXCOORDP2UIPROC __glewMultiTexCoordP2ui;
extern __declspec(dllimport) PFNGLMULTITEXCOORDP2UIVPROC __glewMultiTexCoordP2uiv;
extern __declspec(dllimport) PFNGLMULTITEXCOORDP3UIPROC __glewMultiTexCoordP3ui;
extern __declspec(dllimport) PFNGLMULTITEXCOORDP3UIVPROC __glewMultiTexCoordP3uiv;
extern __declspec(dllimport) PFNGLMULTITEXCOORDP4UIPROC __glewMultiTexCoordP4ui;
extern __declspec(dllimport) PFNGLMULTITEXCOORDP4UIVPROC __glewMultiTexCoordP4uiv;
extern __declspec(dllimport) PFNGLNORMALP3UIPROC __glewNormalP3ui;
extern __declspec(dllimport) PFNGLNORMALP3UIVPROC __glewNormalP3uiv;
extern __declspec(dllimport) PFNGLSECONDARYCOLORP3UIPROC __glewSecondaryColorP3ui;
extern __declspec(dllimport) PFNGLSECONDARYCOLORP3UIVPROC __glewSecondaryColorP3uiv;
extern __declspec(dllimport) PFNGLTEXCOORDP1UIPROC __glewTexCoordP1ui;
extern __declspec(dllimport) PFNGLTEXCOORDP1UIVPROC __glewTexCoordP1uiv;
extern __declspec(dllimport) PFNGLTEXCOORDP2UIPROC __glewTexCoordP2ui;
extern __declspec(dllimport) PFNGLTEXCOORDP2UIVPROC __glewTexCoordP2uiv;
extern __declspec(dllimport) PFNGLTEXCOORDP3UIPROC __glewTexCoordP3ui;
extern __declspec(dllimport) PFNGLTEXCOORDP3UIVPROC __glewTexCoordP3uiv;
extern __declspec(dllimport) PFNGLTEXCOORDP4UIPROC __glewTexCoordP4ui;
extern __declspec(dllimport) PFNGLTEXCOORDP4UIVPROC __glewTexCoordP4uiv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBP1UIPROC __glewVertexAttribP1ui;
extern __declspec(dllimport) PFNGLVERTEXATTRIBP1UIVPROC __glewVertexAttribP1uiv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBP2UIPROC __glewVertexAttribP2ui;
extern __declspec(dllimport) PFNGLVERTEXATTRIBP2UIVPROC __glewVertexAttribP2uiv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBP3UIPROC __glewVertexAttribP3ui;
extern __declspec(dllimport) PFNGLVERTEXATTRIBP3UIVPROC __glewVertexAttribP3uiv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBP4UIPROC __glewVertexAttribP4ui;
extern __declspec(dllimport) PFNGLVERTEXATTRIBP4UIVPROC __glewVertexAttribP4uiv;
extern __declspec(dllimport) PFNGLVERTEXP2UIPROC __glewVertexP2ui;
extern __declspec(dllimport) PFNGLVERTEXP2UIVPROC __glewVertexP2uiv;
extern __declspec(dllimport) PFNGLVERTEXP3UIPROC __glewVertexP3ui;
extern __declspec(dllimport) PFNGLVERTEXP3UIVPROC __glewVertexP3uiv;
extern __declspec(dllimport) PFNGLVERTEXP4UIPROC __glewVertexP4ui;
extern __declspec(dllimport) PFNGLVERTEXP4UIVPROC __glewVertexP4uiv;

extern __declspec(dllimport) PFNGLDEPTHRANGEARRAYVPROC __glewDepthRangeArrayv;
extern __declspec(dllimport) PFNGLDEPTHRANGEINDEXEDPROC __glewDepthRangeIndexed;
extern __declspec(dllimport) PFNGLGETDOUBLEI_VPROC __glewGetDoublei_v;
extern __declspec(dllimport) PFNGLGETFLOATI_VPROC __glewGetFloati_v;
extern __declspec(dllimport) PFNGLSCISSORARRAYVPROC __glewScissorArrayv;
extern __declspec(dllimport) PFNGLSCISSORINDEXEDPROC __glewScissorIndexed;
extern __declspec(dllimport) PFNGLSCISSORINDEXEDVPROC __glewScissorIndexedv;
extern __declspec(dllimport) PFNGLVIEWPORTARRAYVPROC __glewViewportArrayv;
extern __declspec(dllimport) PFNGLVIEWPORTINDEXEDFPROC __glewViewportIndexedf;
extern __declspec(dllimport) PFNGLVIEWPORTINDEXEDFVPROC __glewViewportIndexedfv;

extern __declspec(dllimport) PFNGLWINDOWPOS2DARBPROC __glewWindowPos2dARB;
extern __declspec(dllimport) PFNGLWINDOWPOS2DVARBPROC __glewWindowPos2dvARB;
extern __declspec(dllimport) PFNGLWINDOWPOS2FARBPROC __glewWindowPos2fARB;
extern __declspec(dllimport) PFNGLWINDOWPOS2FVARBPROC __glewWindowPos2fvARB;
extern __declspec(dllimport) PFNGLWINDOWPOS2IARBPROC __glewWindowPos2iARB;
extern __declspec(dllimport) PFNGLWINDOWPOS2IVARBPROC __glewWindowPos2ivARB;
extern __declspec(dllimport) PFNGLWINDOWPOS2SARBPROC __glewWindowPos2sARB;
extern __declspec(dllimport) PFNGLWINDOWPOS2SVARBPROC __glewWindowPos2svARB;
extern __declspec(dllimport) PFNGLWINDOWPOS3DARBPROC __glewWindowPos3dARB;
extern __declspec(dllimport) PFNGLWINDOWPOS3DVARBPROC __glewWindowPos3dvARB;
extern __declspec(dllimport) PFNGLWINDOWPOS3FARBPROC __glewWindowPos3fARB;
extern __declspec(dllimport) PFNGLWINDOWPOS3FVARBPROC __glewWindowPos3fvARB;
extern __declspec(dllimport) PFNGLWINDOWPOS3IARBPROC __glewWindowPos3iARB;
extern __declspec(dllimport) PFNGLWINDOWPOS3IVARBPROC __glewWindowPos3ivARB;
extern __declspec(dllimport) PFNGLWINDOWPOS3SARBPROC __glewWindowPos3sARB;
extern __declspec(dllimport) PFNGLWINDOWPOS3SVARBPROC __glewWindowPos3svARB;

extern __declspec(dllimport) PFNGLDRAWBUFFERSATIPROC __glewDrawBuffersATI;

extern __declspec(dllimport) PFNGLDRAWELEMENTARRAYATIPROC __glewDrawElementArrayATI;
extern __declspec(dllimport) PFNGLDRAWRANGEELEMENTARRAYATIPROC __glewDrawRangeElementArrayATI;
extern __declspec(dllimport) PFNGLELEMENTPOINTERATIPROC __glewElementPointerATI;

extern __declspec(dllimport) PFNGLGETTEXBUMPPARAMETERFVATIPROC __glewGetTexBumpParameterfvATI;
extern __declspec(dllimport) PFNGLGETTEXBUMPPARAMETERIVATIPROC __glewGetTexBumpParameterivATI;
extern __declspec(dllimport) PFNGLTEXBUMPPARAMETERFVATIPROC __glewTexBumpParameterfvATI;
extern __declspec(dllimport) PFNGLTEXBUMPPARAMETERIVATIPROC __glewTexBumpParameterivATI;

extern __declspec(dllimport) PFNGLALPHAFRAGMENTOP1ATIPROC __glewAlphaFragmentOp1ATI;
extern __declspec(dllimport) PFNGLALPHAFRAGMENTOP2ATIPROC __glewAlphaFragmentOp2ATI;
extern __declspec(dllimport) PFNGLALPHAFRAGMENTOP3ATIPROC __glewAlphaFragmentOp3ATI;
extern __declspec(dllimport) PFNGLBEGINFRAGMENTSHADERATIPROC __glewBeginFragmentShaderATI;
extern __declspec(dllimport) PFNGLBINDFRAGMENTSHADERATIPROC __glewBindFragmentShaderATI;
extern __declspec(dllimport) PFNGLCOLORFRAGMENTOP1ATIPROC __glewColorFragmentOp1ATI;
extern __declspec(dllimport) PFNGLCOLORFRAGMENTOP2ATIPROC __glewColorFragmentOp2ATI;
extern __declspec(dllimport) PFNGLCOLORFRAGMENTOP3ATIPROC __glewColorFragmentOp3ATI;
extern __declspec(dllimport) PFNGLDELETEFRAGMENTSHADERATIPROC __glewDeleteFragmentShaderATI;
extern __declspec(dllimport) PFNGLENDFRAGMENTSHADERATIPROC __glewEndFragmentShaderATI;
extern __declspec(dllimport) PFNGLGENFRAGMENTSHADERSATIPROC __glewGenFragmentShadersATI;
extern __declspec(dllimport) PFNGLPASSTEXCOORDATIPROC __glewPassTexCoordATI;
extern __declspec(dllimport) PFNGLSAMPLEMAPATIPROC __glewSampleMapATI;
extern __declspec(dllimport) PFNGLSETFRAGMENTSHADERCONSTANTATIPROC __glewSetFragmentShaderConstantATI;

extern __declspec(dllimport) PFNGLMAPOBJECTBUFFERATIPROC __glewMapObjectBufferATI;
extern __declspec(dllimport) PFNGLUNMAPOBJECTBUFFERATIPROC __glewUnmapObjectBufferATI;

extern __declspec(dllimport) PFNGLPNTRIANGLESFATIPROC __glewPNTrianglesfATI;
extern __declspec(dllimport) PFNGLPNTRIANGLESIATIPROC __glewPNTrianglesiATI;

extern __declspec(dllimport) PFNGLSTENCILFUNCSEPARATEATIPROC __glewStencilFuncSeparateATI;
extern __declspec(dllimport) PFNGLSTENCILOPSEPARATEATIPROC __glewStencilOpSeparateATI;

extern __declspec(dllimport) PFNGLARRAYOBJECTATIPROC __glewArrayObjectATI;
extern __declspec(dllimport) PFNGLFREEOBJECTBUFFERATIPROC __glewFreeObjectBufferATI;
extern __declspec(dllimport) PFNGLGETARRAYOBJECTFVATIPROC __glewGetArrayObjectfvATI;
extern __declspec(dllimport) PFNGLGETARRAYOBJECTIVATIPROC __glewGetArrayObjectivATI;
extern __declspec(dllimport) PFNGLGETOBJECTBUFFERFVATIPROC __glewGetObjectBufferfvATI;
extern __declspec(dllimport) PFNGLGETOBJECTBUFFERIVATIPROC __glewGetObjectBufferivATI;
extern __declspec(dllimport) PFNGLGETVARIANTARRAYOBJECTFVATIPROC __glewGetVariantArrayObjectfvATI;
extern __declspec(dllimport) PFNGLGETVARIANTARRAYOBJECTIVATIPROC __glewGetVariantArrayObjectivATI;
extern __declspec(dllimport) PFNGLISOBJECTBUFFERATIPROC __glewIsObjectBufferATI;
extern __declspec(dllimport) PFNGLNEWOBJECTBUFFERATIPROC __glewNewObjectBufferATI;
extern __declspec(dllimport) PFNGLUPDATEOBJECTBUFFERATIPROC __glewUpdateObjectBufferATI;
extern __declspec(dllimport) PFNGLVARIANTARRAYOBJECTATIPROC __glewVariantArrayObjectATI;

extern __declspec(dllimport) PFNGLGETVERTEXATTRIBARRAYOBJECTFVATIPROC __glewGetVertexAttribArrayObjectfvATI;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBARRAYOBJECTIVATIPROC __glewGetVertexAttribArrayObjectivATI;
extern __declspec(dllimport) PFNGLVERTEXATTRIBARRAYOBJECTATIPROC __glewVertexAttribArrayObjectATI;

extern __declspec(dllimport) PFNGLCLIENTACTIVEVERTEXSTREAMATIPROC __glewClientActiveVertexStreamATI;
extern __declspec(dllimport) PFNGLNORMALSTREAM3BATIPROC __glewNormalStream3bATI;
extern __declspec(dllimport) PFNGLNORMALSTREAM3BVATIPROC __glewNormalStream3bvATI;
extern __declspec(dllimport) PFNGLNORMALSTREAM3DATIPROC __glewNormalStream3dATI;
extern __declspec(dllimport) PFNGLNORMALSTREAM3DVATIPROC __glewNormalStream3dvATI;
extern __declspec(dllimport) PFNGLNORMALSTREAM3FATIPROC __glewNormalStream3fATI;
extern __declspec(dllimport) PFNGLNORMALSTREAM3FVATIPROC __glewNormalStream3fvATI;
extern __declspec(dllimport) PFNGLNORMALSTREAM3IATIPROC __glewNormalStream3iATI;
extern __declspec(dllimport) PFNGLNORMALSTREAM3IVATIPROC __glewNormalStream3ivATI;
extern __declspec(dllimport) PFNGLNORMALSTREAM3SATIPROC __glewNormalStream3sATI;
extern __declspec(dllimport) PFNGLNORMALSTREAM3SVATIPROC __glewNormalStream3svATI;
extern __declspec(dllimport) PFNGLVERTEXBLENDENVFATIPROC __glewVertexBlendEnvfATI;
extern __declspec(dllimport) PFNGLVERTEXBLENDENVIATIPROC __glewVertexBlendEnviATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM1DATIPROC __glewVertexStream1dATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM1DVATIPROC __glewVertexStream1dvATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM1FATIPROC __glewVertexStream1fATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM1FVATIPROC __glewVertexStream1fvATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM1IATIPROC __glewVertexStream1iATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM1IVATIPROC __glewVertexStream1ivATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM1SATIPROC __glewVertexStream1sATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM1SVATIPROC __glewVertexStream1svATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM2DATIPROC __glewVertexStream2dATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM2DVATIPROC __glewVertexStream2dvATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM2FATIPROC __glewVertexStream2fATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM2FVATIPROC __glewVertexStream2fvATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM2IATIPROC __glewVertexStream2iATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM2IVATIPROC __glewVertexStream2ivATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM2SATIPROC __glewVertexStream2sATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM2SVATIPROC __glewVertexStream2svATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM3DATIPROC __glewVertexStream3dATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM3DVATIPROC __glewVertexStream3dvATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM3FATIPROC __glewVertexStream3fATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM3FVATIPROC __glewVertexStream3fvATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM3IATIPROC __glewVertexStream3iATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM3IVATIPROC __glewVertexStream3ivATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM3SATIPROC __glewVertexStream3sATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM3SVATIPROC __glewVertexStream3svATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM4DATIPROC __glewVertexStream4dATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM4DVATIPROC __glewVertexStream4dvATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM4FATIPROC __glewVertexStream4fATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM4FVATIPROC __glewVertexStream4fvATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM4IATIPROC __glewVertexStream4iATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM4IVATIPROC __glewVertexStream4ivATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM4SATIPROC __glewVertexStream4sATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM4SVATIPROC __glewVertexStream4svATI;

extern __declspec(dllimport) PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEEXTPROC __glewDrawArraysInstancedBaseInstanceEXT;
extern __declspec(dllimport) PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEEXTPROC __glewDrawElementsInstancedBaseInstanceEXT;
extern __declspec(dllimport) PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEEXTPROC __glewDrawElementsInstancedBaseVertexBaseInstanceEXT;

extern __declspec(dllimport) PFNGLGETUNIFORMBUFFERSIZEEXTPROC __glewGetUniformBufferSizeEXT;
extern __declspec(dllimport) PFNGLGETUNIFORMOFFSETEXTPROC __glewGetUniformOffsetEXT;
extern __declspec(dllimport) PFNGLUNIFORMBUFFEREXTPROC __glewUniformBufferEXT;

extern __declspec(dllimport) PFNGLBLENDCOLOREXTPROC __glewBlendColorEXT;

extern __declspec(dllimport) PFNGLBLENDEQUATIONSEPARATEEXTPROC __glewBlendEquationSeparateEXT;

extern __declspec(dllimport) PFNGLBINDFRAGDATALOCATIONINDEXEDEXTPROC __glewBindFragDataLocationIndexedEXT;
extern __declspec(dllimport) PFNGLGETFRAGDATAINDEXEXTPROC __glewGetFragDataIndexEXT;
extern __declspec(dllimport) PFNGLGETPROGRAMRESOURCELOCATIONINDEXEXTPROC __glewGetProgramResourceLocationIndexEXT;

extern __declspec(dllimport) PFNGLBLENDFUNCSEPARATEEXTPROC __glewBlendFuncSeparateEXT;

extern __declspec(dllimport) PFNGLBLENDEQUATIONEXTPROC __glewBlendEquationEXT;

extern __declspec(dllimport) PFNGLBUFFERSTORAGEEXTPROC __glewBufferStorageEXT;
extern __declspec(dllimport) PFNGLNAMEDBUFFERSTORAGEEXTPROC __glewNamedBufferStorageEXT;

extern __declspec(dllimport) PFNGLCLEARTEXIMAGEEXTPROC __glewClearTexImageEXT;
extern __declspec(dllimport) PFNGLCLEARTEXSUBIMAGEEXTPROC __glewClearTexSubImageEXT;

extern __declspec(dllimport) PFNGLCOLORSUBTABLEEXTPROC __glewColorSubTableEXT;
extern __declspec(dllimport) PFNGLCOPYCOLORSUBTABLEEXTPROC __glewCopyColorSubTableEXT;

extern __declspec(dllimport) PFNGLLOCKARRAYSEXTPROC __glewLockArraysEXT;
extern __declspec(dllimport) PFNGLUNLOCKARRAYSEXTPROC __glewUnlockArraysEXT;

extern __declspec(dllimport) PFNGLCONVOLUTIONFILTER1DEXTPROC __glewConvolutionFilter1DEXT;
extern __declspec(dllimport) PFNGLCONVOLUTIONFILTER2DEXTPROC __glewConvolutionFilter2DEXT;
extern __declspec(dllimport) PFNGLCONVOLUTIONPARAMETERFEXTPROC __glewConvolutionParameterfEXT;
extern __declspec(dllimport) PFNGLCONVOLUTIONPARAMETERFVEXTPROC __glewConvolutionParameterfvEXT;
extern __declspec(dllimport) PFNGLCONVOLUTIONPARAMETERIEXTPROC __glewConvolutionParameteriEXT;
extern __declspec(dllimport) PFNGLCONVOLUTIONPARAMETERIVEXTPROC __glewConvolutionParameterivEXT;
extern __declspec(dllimport) PFNGLCOPYCONVOLUTIONFILTER1DEXTPROC __glewCopyConvolutionFilter1DEXT;
extern __declspec(dllimport) PFNGLCOPYCONVOLUTIONFILTER2DEXTPROC __glewCopyConvolutionFilter2DEXT;
extern __declspec(dllimport) PFNGLGETCONVOLUTIONFILTEREXTPROC __glewGetConvolutionFilterEXT;
extern __declspec(dllimport) PFNGLGETCONVOLUTIONPARAMETERFVEXTPROC __glewGetConvolutionParameterfvEXT;
extern __declspec(dllimport) PFNGLGETCONVOLUTIONPARAMETERIVEXTPROC __glewGetConvolutionParameterivEXT;
extern __declspec(dllimport) PFNGLGETSEPARABLEFILTEREXTPROC __glewGetSeparableFilterEXT;
extern __declspec(dllimport) PFNGLSEPARABLEFILTER2DEXTPROC __glewSeparableFilter2DEXT;

extern __declspec(dllimport) PFNGLBINORMALPOINTEREXTPROC __glewBinormalPointerEXT;
extern __declspec(dllimport) PFNGLTANGENTPOINTEREXTPROC __glewTangentPointerEXT;

extern __declspec(dllimport) PFNGLCOPYIMAGESUBDATAEXTPROC __glewCopyImageSubDataEXT;

extern __declspec(dllimport) PFNGLCOPYTEXIMAGE1DEXTPROC __glewCopyTexImage1DEXT;
extern __declspec(dllimport) PFNGLCOPYTEXIMAGE2DEXTPROC __glewCopyTexImage2DEXT;
extern __declspec(dllimport) PFNGLCOPYTEXSUBIMAGE1DEXTPROC __glewCopyTexSubImage1DEXT;
extern __declspec(dllimport) PFNGLCOPYTEXSUBIMAGE2DEXTPROC __glewCopyTexSubImage2DEXT;
extern __declspec(dllimport) PFNGLCOPYTEXSUBIMAGE3DEXTPROC __glewCopyTexSubImage3DEXT;

extern __declspec(dllimport) PFNGLCULLPARAMETERDVEXTPROC __glewCullParameterdvEXT;
extern __declspec(dllimport) PFNGLCULLPARAMETERFVEXTPROC __glewCullParameterfvEXT;

extern __declspec(dllimport) PFNGLGETOBJECTLABELEXTPROC __glewGetObjectLabelEXT;
extern __declspec(dllimport) PFNGLLABELOBJECTEXTPROC __glewLabelObjectEXT;

extern __declspec(dllimport) PFNGLINSERTEVENTMARKEREXTPROC __glewInsertEventMarkerEXT;
extern __declspec(dllimport) PFNGLPOPGROUPMARKEREXTPROC __glewPopGroupMarkerEXT;
extern __declspec(dllimport) PFNGLPUSHGROUPMARKEREXTPROC __glewPushGroupMarkerEXT;

extern __declspec(dllimport) PFNGLDEPTHBOUNDSEXTPROC __glewDepthBoundsEXT;

extern __declspec(dllimport) PFNGLBINDMULTITEXTUREEXTPROC __glewBindMultiTextureEXT;
extern __declspec(dllimport) PFNGLCHECKNAMEDFRAMEBUFFERSTATUSEXTPROC __glewCheckNamedFramebufferStatusEXT;
extern __declspec(dllimport) PFNGLCLIENTATTRIBDEFAULTEXTPROC __glewClientAttribDefaultEXT;
extern __declspec(dllimport) PFNGLCOMPRESSEDMULTITEXIMAGE1DEXTPROC __glewCompressedMultiTexImage1DEXT;
extern __declspec(dllimport) PFNGLCOMPRESSEDMULTITEXIMAGE2DEXTPROC __glewCompressedMultiTexImage2DEXT;
extern __declspec(dllimport) PFNGLCOMPRESSEDMULTITEXIMAGE3DEXTPROC __glewCompressedMultiTexImage3DEXT;
extern __declspec(dllimport) PFNGLCOMPRESSEDMULTITEXSUBIMAGE1DEXTPROC __glewCompressedMultiTexSubImage1DEXT;
extern __declspec(dllimport) PFNGLCOMPRESSEDMULTITEXSUBIMAGE2DEXTPROC __glewCompressedMultiTexSubImage2DEXT;
extern __declspec(dllimport) PFNGLCOMPRESSEDMULTITEXSUBIMAGE3DEXTPROC __glewCompressedMultiTexSubImage3DEXT;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXTUREIMAGE1DEXTPROC __glewCompressedTextureImage1DEXT;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXTUREIMAGE2DEXTPROC __glewCompressedTextureImage2DEXT;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXTUREIMAGE3DEXTPROC __glewCompressedTextureImage3DEXT;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXTURESUBIMAGE1DEXTPROC __glewCompressedTextureSubImage1DEXT;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXTURESUBIMAGE2DEXTPROC __glewCompressedTextureSubImage2DEXT;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXTURESUBIMAGE3DEXTPROC __glewCompressedTextureSubImage3DEXT;
extern __declspec(dllimport) PFNGLCOPYMULTITEXIMAGE1DEXTPROC __glewCopyMultiTexImage1DEXT;
extern __declspec(dllimport) PFNGLCOPYMULTITEXIMAGE2DEXTPROC __glewCopyMultiTexImage2DEXT;
extern __declspec(dllimport) PFNGLCOPYMULTITEXSUBIMAGE1DEXTPROC __glewCopyMultiTexSubImage1DEXT;
extern __declspec(dllimport) PFNGLCOPYMULTITEXSUBIMAGE2DEXTPROC __glewCopyMultiTexSubImage2DEXT;
extern __declspec(dllimport) PFNGLCOPYMULTITEXSUBIMAGE3DEXTPROC __glewCopyMultiTexSubImage3DEXT;
extern __declspec(dllimport) PFNGLCOPYTEXTUREIMAGE1DEXTPROC __glewCopyTextureImage1DEXT;
extern __declspec(dllimport) PFNGLCOPYTEXTUREIMAGE2DEXTPROC __glewCopyTextureImage2DEXT;
extern __declspec(dllimport) PFNGLCOPYTEXTURESUBIMAGE1DEXTPROC __glewCopyTextureSubImage1DEXT;
extern __declspec(dllimport) PFNGLCOPYTEXTURESUBIMAGE2DEXTPROC __glewCopyTextureSubImage2DEXT;
extern __declspec(dllimport) PFNGLCOPYTEXTURESUBIMAGE3DEXTPROC __glewCopyTextureSubImage3DEXT;
extern __declspec(dllimport) PFNGLDISABLECLIENTSTATEINDEXEDEXTPROC __glewDisableClientStateIndexedEXT;
extern __declspec(dllimport) PFNGLDISABLECLIENTSTATEIEXTPROC __glewDisableClientStateiEXT;
extern __declspec(dllimport) PFNGLDISABLEVERTEXARRAYATTRIBEXTPROC __glewDisableVertexArrayAttribEXT;
extern __declspec(dllimport) PFNGLDISABLEVERTEXARRAYEXTPROC __glewDisableVertexArrayEXT;
extern __declspec(dllimport) PFNGLENABLECLIENTSTATEINDEXEDEXTPROC __glewEnableClientStateIndexedEXT;
extern __declspec(dllimport) PFNGLENABLECLIENTSTATEIEXTPROC __glewEnableClientStateiEXT;
extern __declspec(dllimport) PFNGLENABLEVERTEXARRAYATTRIBEXTPROC __glewEnableVertexArrayAttribEXT;
extern __declspec(dllimport) PFNGLENABLEVERTEXARRAYEXTPROC __glewEnableVertexArrayEXT;
extern __declspec(dllimport) PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEEXTPROC __glewFlushMappedNamedBufferRangeEXT;
extern __declspec(dllimport) PFNGLFRAMEBUFFERDRAWBUFFEREXTPROC __glewFramebufferDrawBufferEXT;
extern __declspec(dllimport) PFNGLFRAMEBUFFERDRAWBUFFERSEXTPROC __glewFramebufferDrawBuffersEXT;
extern __declspec(dllimport) PFNGLFRAMEBUFFERREADBUFFEREXTPROC __glewFramebufferReadBufferEXT;
extern __declspec(dllimport) PFNGLGENERATEMULTITEXMIPMAPEXTPROC __glewGenerateMultiTexMipmapEXT;
extern __declspec(dllimport) PFNGLGENERATETEXTUREMIPMAPEXTPROC __glewGenerateTextureMipmapEXT;
extern __declspec(dllimport) PFNGLGETCOMPRESSEDMULTITEXIMAGEEXTPROC __glewGetCompressedMultiTexImageEXT;
extern __declspec(dllimport) PFNGLGETCOMPRESSEDTEXTUREIMAGEEXTPROC __glewGetCompressedTextureImageEXT;
extern __declspec(dllimport) PFNGLGETDOUBLEINDEXEDVEXTPROC __glewGetDoubleIndexedvEXT;
extern __declspec(dllimport) PFNGLGETDOUBLEI_VEXTPROC __glewGetDoublei_vEXT;
extern __declspec(dllimport) PFNGLGETFLOATINDEXEDVEXTPROC __glewGetFloatIndexedvEXT;
extern __declspec(dllimport) PFNGLGETFLOATI_VEXTPROC __glewGetFloati_vEXT;
extern __declspec(dllimport) PFNGLGETFRAMEBUFFERPARAMETERIVEXTPROC __glewGetFramebufferParameterivEXT;
extern __declspec(dllimport) PFNGLGETMULTITEXENVFVEXTPROC __glewGetMultiTexEnvfvEXT;
extern __declspec(dllimport) PFNGLGETMULTITEXENVIVEXTPROC __glewGetMultiTexEnvivEXT;
extern __declspec(dllimport) PFNGLGETMULTITEXGENDVEXTPROC __glewGetMultiTexGendvEXT;
extern __declspec(dllimport) PFNGLGETMULTITEXGENFVEXTPROC __glewGetMultiTexGenfvEXT;
extern __declspec(dllimport) PFNGLGETMULTITEXGENIVEXTPROC __glewGetMultiTexGenivEXT;
extern __declspec(dllimport) PFNGLGETMULTITEXIMAGEEXTPROC __glewGetMultiTexImageEXT;
extern __declspec(dllimport) PFNGLGETMULTITEXLEVELPARAMETERFVEXTPROC __glewGetMultiTexLevelParameterfvEXT;
extern __declspec(dllimport) PFNGLGETMULTITEXLEVELPARAMETERIVEXTPROC __glewGetMultiTexLevelParameterivEXT;
extern __declspec(dllimport) PFNGLGETMULTITEXPARAMETERIIVEXTPROC __glewGetMultiTexParameterIivEXT;
extern __declspec(dllimport) PFNGLGETMULTITEXPARAMETERIUIVEXTPROC __glewGetMultiTexParameterIuivEXT;
extern __declspec(dllimport) PFNGLGETMULTITEXPARAMETERFVEXTPROC __glewGetMultiTexParameterfvEXT;
extern __declspec(dllimport) PFNGLGETMULTITEXPARAMETERIVEXTPROC __glewGetMultiTexParameterivEXT;
extern __declspec(dllimport) PFNGLGETNAMEDBUFFERPARAMETERIVEXTPROC __glewGetNamedBufferParameterivEXT;
extern __declspec(dllimport) PFNGLGETNAMEDBUFFERPOINTERVEXTPROC __glewGetNamedBufferPointervEXT;
extern __declspec(dllimport) PFNGLGETNAMEDBUFFERSUBDATAEXTPROC __glewGetNamedBufferSubDataEXT;
extern __declspec(dllimport) PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC __glewGetNamedFramebufferAttachmentParameterivEXT;
extern __declspec(dllimport) PFNGLGETNAMEDPROGRAMLOCALPARAMETERIIVEXTPROC __glewGetNamedProgramLocalParameterIivEXT;
extern __declspec(dllimport) PFNGLGETNAMEDPROGRAMLOCALPARAMETERIUIVEXTPROC __glewGetNamedProgramLocalParameterIuivEXT;
extern __declspec(dllimport) PFNGLGETNAMEDPROGRAMLOCALPARAMETERDVEXTPROC __glewGetNamedProgramLocalParameterdvEXT;
extern __declspec(dllimport) PFNGLGETNAMEDPROGRAMLOCALPARAMETERFVEXTPROC __glewGetNamedProgramLocalParameterfvEXT;
extern __declspec(dllimport) PFNGLGETNAMEDPROGRAMSTRINGEXTPROC __glewGetNamedProgramStringEXT;
extern __declspec(dllimport) PFNGLGETNAMEDPROGRAMIVEXTPROC __glewGetNamedProgramivEXT;
extern __declspec(dllimport) PFNGLGETNAMEDRENDERBUFFERPARAMETERIVEXTPROC __glewGetNamedRenderbufferParameterivEXT;
extern __declspec(dllimport) PFNGLGETPOINTERINDEXEDVEXTPROC __glewGetPointerIndexedvEXT;
extern __declspec(dllimport) PFNGLGETPOINTERI_VEXTPROC __glewGetPointeri_vEXT;
extern __declspec(dllimport) PFNGLGETTEXTUREIMAGEEXTPROC __glewGetTextureImageEXT;
extern __declspec(dllimport) PFNGLGETTEXTURELEVELPARAMETERFVEXTPROC __glewGetTextureLevelParameterfvEXT;
extern __declspec(dllimport) PFNGLGETTEXTURELEVELPARAMETERIVEXTPROC __glewGetTextureLevelParameterivEXT;
extern __declspec(dllimport) PFNGLGETTEXTUREPARAMETERIIVEXTPROC __glewGetTextureParameterIivEXT;
extern __declspec(dllimport) PFNGLGETTEXTUREPARAMETERIUIVEXTPROC __glewGetTextureParameterIuivEXT;
extern __declspec(dllimport) PFNGLGETTEXTUREPARAMETERFVEXTPROC __glewGetTextureParameterfvEXT;
extern __declspec(dllimport) PFNGLGETTEXTUREPARAMETERIVEXTPROC __glewGetTextureParameterivEXT;
extern __declspec(dllimport) PFNGLGETVERTEXARRAYINTEGERI_VEXTPROC __glewGetVertexArrayIntegeri_vEXT;
extern __declspec(dllimport) PFNGLGETVERTEXARRAYINTEGERVEXTPROC __glewGetVertexArrayIntegervEXT;
extern __declspec(dllimport) PFNGLGETVERTEXARRAYPOINTERI_VEXTPROC __glewGetVertexArrayPointeri_vEXT;
extern __declspec(dllimport) PFNGLGETVERTEXARRAYPOINTERVEXTPROC __glewGetVertexArrayPointervEXT;
extern __declspec(dllimport) PFNGLMAPNAMEDBUFFEREXTPROC __glewMapNamedBufferEXT;
extern __declspec(dllimport) PFNGLMAPNAMEDBUFFERRANGEEXTPROC __glewMapNamedBufferRangeEXT;
extern __declspec(dllimport) PFNGLMATRIXFRUSTUMEXTPROC __glewMatrixFrustumEXT;
extern __declspec(dllimport) PFNGLMATRIXLOADIDENTITYEXTPROC __glewMatrixLoadIdentityEXT;
extern __declspec(dllimport) PFNGLMATRIXLOADTRANSPOSEDEXTPROC __glewMatrixLoadTransposedEXT;
extern __declspec(dllimport) PFNGLMATRIXLOADTRANSPOSEFEXTPROC __glewMatrixLoadTransposefEXT;
extern __declspec(dllimport) PFNGLMATRIXLOADDEXTPROC __glewMatrixLoaddEXT;
extern __declspec(dllimport) PFNGLMATRIXLOADFEXTPROC __glewMatrixLoadfEXT;
extern __declspec(dllimport) PFNGLMATRIXMULTTRANSPOSEDEXTPROC __glewMatrixMultTransposedEXT;
extern __declspec(dllimport) PFNGLMATRIXMULTTRANSPOSEFEXTPROC __glewMatrixMultTransposefEXT;
extern __declspec(dllimport) PFNGLMATRIXMULTDEXTPROC __glewMatrixMultdEXT;
extern __declspec(dllimport) PFNGLMATRIXMULTFEXTPROC __glewMatrixMultfEXT;
extern __declspec(dllimport) PFNGLMATRIXORTHOEXTPROC __glewMatrixOrthoEXT;
extern __declspec(dllimport) PFNGLMATRIXPOPEXTPROC __glewMatrixPopEXT;
extern __declspec(dllimport) PFNGLMATRIXPUSHEXTPROC __glewMatrixPushEXT;
extern __declspec(dllimport) PFNGLMATRIXROTATEDEXTPROC __glewMatrixRotatedEXT;
extern __declspec(dllimport) PFNGLMATRIXROTATEFEXTPROC __glewMatrixRotatefEXT;
extern __declspec(dllimport) PFNGLMATRIXSCALEDEXTPROC __glewMatrixScaledEXT;
extern __declspec(dllimport) PFNGLMATRIXSCALEFEXTPROC __glewMatrixScalefEXT;
extern __declspec(dllimport) PFNGLMATRIXTRANSLATEDEXTPROC __glewMatrixTranslatedEXT;
extern __declspec(dllimport) PFNGLMATRIXTRANSLATEFEXTPROC __glewMatrixTranslatefEXT;
extern __declspec(dllimport) PFNGLMULTITEXBUFFEREXTPROC __glewMultiTexBufferEXT;
extern __declspec(dllimport) PFNGLMULTITEXCOORDPOINTEREXTPROC __glewMultiTexCoordPointerEXT;
extern __declspec(dllimport) PFNGLMULTITEXENVFEXTPROC __glewMultiTexEnvfEXT;
extern __declspec(dllimport) PFNGLMULTITEXENVFVEXTPROC __glewMultiTexEnvfvEXT;
extern __declspec(dllimport) PFNGLMULTITEXENVIEXTPROC __glewMultiTexEnviEXT;
extern __declspec(dllimport) PFNGLMULTITEXENVIVEXTPROC __glewMultiTexEnvivEXT;
extern __declspec(dllimport) PFNGLMULTITEXGENDEXTPROC __glewMultiTexGendEXT;
extern __declspec(dllimport) PFNGLMULTITEXGENDVEXTPROC __glewMultiTexGendvEXT;
extern __declspec(dllimport) PFNGLMULTITEXGENFEXTPROC __glewMultiTexGenfEXT;
extern __declspec(dllimport) PFNGLMULTITEXGENFVEXTPROC __glewMultiTexGenfvEXT;
extern __declspec(dllimport) PFNGLMULTITEXGENIEXTPROC __glewMultiTexGeniEXT;
extern __declspec(dllimport) PFNGLMULTITEXGENIVEXTPROC __glewMultiTexGenivEXT;
extern __declspec(dllimport) PFNGLMULTITEXIMAGE1DEXTPROC __glewMultiTexImage1DEXT;
extern __declspec(dllimport) PFNGLMULTITEXIMAGE2DEXTPROC __glewMultiTexImage2DEXT;
extern __declspec(dllimport) PFNGLMULTITEXIMAGE3DEXTPROC __glewMultiTexImage3DEXT;
extern __declspec(dllimport) PFNGLMULTITEXPARAMETERIIVEXTPROC __glewMultiTexParameterIivEXT;
extern __declspec(dllimport) PFNGLMULTITEXPARAMETERIUIVEXTPROC __glewMultiTexParameterIuivEXT;
extern __declspec(dllimport) PFNGLMULTITEXPARAMETERFEXTPROC __glewMultiTexParameterfEXT;
extern __declspec(dllimport) PFNGLMULTITEXPARAMETERFVEXTPROC __glewMultiTexParameterfvEXT;
extern __declspec(dllimport) PFNGLMULTITEXPARAMETERIEXTPROC __glewMultiTexParameteriEXT;
extern __declspec(dllimport) PFNGLMULTITEXPARAMETERIVEXTPROC __glewMultiTexParameterivEXT;
extern __declspec(dllimport) PFNGLMULTITEXRENDERBUFFEREXTPROC __glewMultiTexRenderbufferEXT;
extern __declspec(dllimport) PFNGLMULTITEXSUBIMAGE1DEXTPROC __glewMultiTexSubImage1DEXT;
extern __declspec(dllimport) PFNGLMULTITEXSUBIMAGE2DEXTPROC __glewMultiTexSubImage2DEXT;
extern __declspec(dllimport) PFNGLMULTITEXSUBIMAGE3DEXTPROC __glewMultiTexSubImage3DEXT;
extern __declspec(dllimport) PFNGLNAMEDBUFFERDATAEXTPROC __glewNamedBufferDataEXT;
extern __declspec(dllimport) PFNGLNAMEDBUFFERSUBDATAEXTPROC __glewNamedBufferSubDataEXT;
extern __declspec(dllimport) PFNGLNAMEDCOPYBUFFERSUBDATAEXTPROC __glewNamedCopyBufferSubDataEXT;
extern __declspec(dllimport) PFNGLNAMEDFRAMEBUFFERRENDERBUFFEREXTPROC __glewNamedFramebufferRenderbufferEXT;
extern __declspec(dllimport) PFNGLNAMEDFRAMEBUFFERTEXTURE1DEXTPROC __glewNamedFramebufferTexture1DEXT;
extern __declspec(dllimport) PFNGLNAMEDFRAMEBUFFERTEXTURE2DEXTPROC __glewNamedFramebufferTexture2DEXT;
extern __declspec(dllimport) PFNGLNAMEDFRAMEBUFFERTEXTURE3DEXTPROC __glewNamedFramebufferTexture3DEXT;
extern __declspec(dllimport) PFNGLNAMEDFRAMEBUFFERTEXTUREEXTPROC __glewNamedFramebufferTextureEXT;
extern __declspec(dllimport) PFNGLNAMEDFRAMEBUFFERTEXTUREFACEEXTPROC __glewNamedFramebufferTextureFaceEXT;
extern __declspec(dllimport) PFNGLNAMEDFRAMEBUFFERTEXTURELAYEREXTPROC __glewNamedFramebufferTextureLayerEXT;
extern __declspec(dllimport) PFNGLNAMEDPROGRAMLOCALPARAMETER4DEXTPROC __glewNamedProgramLocalParameter4dEXT;
extern __declspec(dllimport) PFNGLNAMEDPROGRAMLOCALPARAMETER4DVEXTPROC __glewNamedProgramLocalParameter4dvEXT;
extern __declspec(dllimport) PFNGLNAMEDPROGRAMLOCALPARAMETER4FEXTPROC __glewNamedProgramLocalParameter4fEXT;
extern __declspec(dllimport) PFNGLNAMEDPROGRAMLOCALPARAMETER4FVEXTPROC __glewNamedProgramLocalParameter4fvEXT;
extern __declspec(dllimport) PFNGLNAMEDPROGRAMLOCALPARAMETERI4IEXTPROC __glewNamedProgramLocalParameterI4iEXT;
extern __declspec(dllimport) PFNGLNAMEDPROGRAMLOCALPARAMETERI4IVEXTPROC __glewNamedProgramLocalParameterI4ivEXT;
extern __declspec(dllimport) PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIEXTPROC __glewNamedProgramLocalParameterI4uiEXT;
extern __declspec(dllimport) PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIVEXTPROC __glewNamedProgramLocalParameterI4uivEXT;
extern __declspec(dllimport) PFNGLNAMEDPROGRAMLOCALPARAMETERS4FVEXTPROC __glewNamedProgramLocalParameters4fvEXT;
extern __declspec(dllimport) PFNGLNAMEDPROGRAMLOCALPARAMETERSI4IVEXTPROC __glewNamedProgramLocalParametersI4ivEXT;
extern __declspec(dllimport) PFNGLNAMEDPROGRAMLOCALPARAMETERSI4UIVEXTPROC __glewNamedProgramLocalParametersI4uivEXT;
extern __declspec(dllimport) PFNGLNAMEDPROGRAMSTRINGEXTPROC __glewNamedProgramStringEXT;
extern __declspec(dllimport) PFNGLNAMEDRENDERBUFFERSTORAGEEXTPROC __glewNamedRenderbufferStorageEXT;
extern __declspec(dllimport) PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLECOVERAGEEXTPROC __glewNamedRenderbufferStorageMultisampleCoverageEXT;
extern __declspec(dllimport) PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC __glewNamedRenderbufferStorageMultisampleEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1FEXTPROC __glewProgramUniform1fEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1FVEXTPROC __glewProgramUniform1fvEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1IEXTPROC __glewProgramUniform1iEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1IVEXTPROC __glewProgramUniform1ivEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1UIEXTPROC __glewProgramUniform1uiEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1UIVEXTPROC __glewProgramUniform1uivEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2FEXTPROC __glewProgramUniform2fEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2FVEXTPROC __glewProgramUniform2fvEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2IEXTPROC __glewProgramUniform2iEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2IVEXTPROC __glewProgramUniform2ivEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2UIEXTPROC __glewProgramUniform2uiEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2UIVEXTPROC __glewProgramUniform2uivEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3FEXTPROC __glewProgramUniform3fEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3FVEXTPROC __glewProgramUniform3fvEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3IEXTPROC __glewProgramUniform3iEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3IVEXTPROC __glewProgramUniform3ivEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3UIEXTPROC __glewProgramUniform3uiEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3UIVEXTPROC __glewProgramUniform3uivEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4FEXTPROC __glewProgramUniform4fEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4FVEXTPROC __glewProgramUniform4fvEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4IEXTPROC __glewProgramUniform4iEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4IVEXTPROC __glewProgramUniform4ivEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4UIEXTPROC __glewProgramUniform4uiEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4UIVEXTPROC __glewProgramUniform4uivEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX2FVEXTPROC __glewProgramUniformMatrix2fvEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX2X3FVEXTPROC __glewProgramUniformMatrix2x3fvEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX2X4FVEXTPROC __glewProgramUniformMatrix2x4fvEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX3FVEXTPROC __glewProgramUniformMatrix3fvEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX3X2FVEXTPROC __glewProgramUniformMatrix3x2fvEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX3X4FVEXTPROC __glewProgramUniformMatrix3x4fvEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX4FVEXTPROC __glewProgramUniformMatrix4fvEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX4X2FVEXTPROC __glewProgramUniformMatrix4x2fvEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX4X3FVEXTPROC __glewProgramUniformMatrix4x3fvEXT;
extern __declspec(dllimport) PFNGLPUSHCLIENTATTRIBDEFAULTEXTPROC __glewPushClientAttribDefaultEXT;
extern __declspec(dllimport) PFNGLTEXTUREBUFFEREXTPROC __glewTextureBufferEXT;
extern __declspec(dllimport) PFNGLTEXTUREIMAGE1DEXTPROC __glewTextureImage1DEXT;
extern __declspec(dllimport) PFNGLTEXTUREIMAGE2DEXTPROC __glewTextureImage2DEXT;
extern __declspec(dllimport) PFNGLTEXTUREIMAGE3DEXTPROC __glewTextureImage3DEXT;
extern __declspec(dllimport) PFNGLTEXTUREPARAMETERIIVEXTPROC __glewTextureParameterIivEXT;
extern __declspec(dllimport) PFNGLTEXTUREPARAMETERIUIVEXTPROC __glewTextureParameterIuivEXT;
extern __declspec(dllimport) PFNGLTEXTUREPARAMETERFEXTPROC __glewTextureParameterfEXT;
extern __declspec(dllimport) PFNGLTEXTUREPARAMETERFVEXTPROC __glewTextureParameterfvEXT;
extern __declspec(dllimport) PFNGLTEXTUREPARAMETERIEXTPROC __glewTextureParameteriEXT;
extern __declspec(dllimport) PFNGLTEXTUREPARAMETERIVEXTPROC __glewTextureParameterivEXT;
extern __declspec(dllimport) PFNGLTEXTURERENDERBUFFEREXTPROC __glewTextureRenderbufferEXT;
extern __declspec(dllimport) PFNGLTEXTURESUBIMAGE1DEXTPROC __glewTextureSubImage1DEXT;
extern __declspec(dllimport) PFNGLTEXTURESUBIMAGE2DEXTPROC __glewTextureSubImage2DEXT;
extern __declspec(dllimport) PFNGLTEXTURESUBIMAGE3DEXTPROC __glewTextureSubImage3DEXT;
extern __declspec(dllimport) PFNGLUNMAPNAMEDBUFFEREXTPROC __glewUnmapNamedBufferEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYCOLOROFFSETEXTPROC __glewVertexArrayColorOffsetEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYEDGEFLAGOFFSETEXTPROC __glewVertexArrayEdgeFlagOffsetEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYFOGCOORDOFFSETEXTPROC __glewVertexArrayFogCoordOffsetEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYINDEXOFFSETEXTPROC __glewVertexArrayIndexOffsetEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYMULTITEXCOORDOFFSETEXTPROC __glewVertexArrayMultiTexCoordOffsetEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYNORMALOFFSETEXTPROC __glewVertexArrayNormalOffsetEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYSECONDARYCOLOROFFSETEXTPROC __glewVertexArraySecondaryColorOffsetEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYTEXCOORDOFFSETEXTPROC __glewVertexArrayTexCoordOffsetEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYVERTEXATTRIBDIVISOREXTPROC __glewVertexArrayVertexAttribDivisorEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYVERTEXATTRIBIOFFSETEXTPROC __glewVertexArrayVertexAttribIOffsetEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYVERTEXATTRIBOFFSETEXTPROC __glewVertexArrayVertexAttribOffsetEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYVERTEXOFFSETEXTPROC __glewVertexArrayVertexOffsetEXT;

extern __declspec(dllimport) PFNGLDISCARDFRAMEBUFFEREXTPROC __glewDiscardFramebufferEXT;

extern __declspec(dllimport) PFNGLDRAWBUFFERSEXTPROC __glewDrawBuffersEXT;

extern __declspec(dllimport) PFNGLCOLORMASKINDEXEDEXTPROC __glewColorMaskIndexedEXT;
extern __declspec(dllimport) PFNGLDISABLEINDEXEDEXTPROC __glewDisableIndexedEXT;
extern __declspec(dllimport) PFNGLENABLEINDEXEDEXTPROC __glewEnableIndexedEXT;
extern __declspec(dllimport) PFNGLGETBOOLEANINDEXEDVEXTPROC __glewGetBooleanIndexedvEXT;
extern __declspec(dllimport) PFNGLGETINTEGERINDEXEDVEXTPROC __glewGetIntegerIndexedvEXT;
extern __declspec(dllimport) PFNGLISENABLEDINDEXEDEXTPROC __glewIsEnabledIndexedEXT;

extern __declspec(dllimport) PFNGLBLENDEQUATIONSEPARATEIEXTPROC __glewBlendEquationSeparateiEXT;
extern __declspec(dllimport) PFNGLBLENDEQUATIONIEXTPROC __glewBlendEquationiEXT;
extern __declspec(dllimport) PFNGLBLENDFUNCSEPARATEIEXTPROC __glewBlendFuncSeparateiEXT;
extern __declspec(dllimport) PFNGLBLENDFUNCIEXTPROC __glewBlendFunciEXT;
extern __declspec(dllimport) PFNGLCOLORMASKIEXTPROC __glewColorMaskiEXT;
extern __declspec(dllimport) PFNGLDISABLEIEXTPROC __glewDisableiEXT;
extern __declspec(dllimport) PFNGLENABLEIEXTPROC __glewEnableiEXT;
extern __declspec(dllimport) PFNGLISENABLEDIEXTPROC __glewIsEnablediEXT;

extern __declspec(dllimport) PFNGLDRAWELEMENTSBASEVERTEXEXTPROC __glewDrawElementsBaseVertexEXT;
extern __declspec(dllimport) PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXEXTPROC __glewDrawElementsInstancedBaseVertexEXT;
extern __declspec(dllimport) PFNGLDRAWRANGEELEMENTSBASEVERTEXEXTPROC __glewDrawRangeElementsBaseVertexEXT;
extern __declspec(dllimport) PFNGLMULTIDRAWELEMENTSBASEVERTEXEXTPROC __glewMultiDrawElementsBaseVertexEXT;

extern __declspec(dllimport) PFNGLDRAWARRAYSINSTANCEDEXTPROC __glewDrawArraysInstancedEXT;
extern __declspec(dllimport) PFNGLDRAWELEMENTSINSTANCEDEXTPROC __glewDrawElementsInstancedEXT;

extern __declspec(dllimport) PFNGLDRAWRANGEELEMENTSEXTPROC __glewDrawRangeElementsEXT;

extern __declspec(dllimport) PFNGLBUFFERSTORAGEEXTERNALEXTPROC __glewBufferStorageExternalEXT;
extern __declspec(dllimport) PFNGLNAMEDBUFFERSTORAGEEXTERNALEXTPROC __glewNamedBufferStorageExternalEXT;

extern __declspec(dllimport) PFNGLFOGCOORDPOINTEREXTPROC __glewFogCoordPointerEXT;
extern __declspec(dllimport) PFNGLFOGCOORDDEXTPROC __glewFogCoorddEXT;
extern __declspec(dllimport) PFNGLFOGCOORDDVEXTPROC __glewFogCoorddvEXT;
extern __declspec(dllimport) PFNGLFOGCOORDFEXTPROC __glewFogCoordfEXT;
extern __declspec(dllimport) PFNGLFOGCOORDFVEXTPROC __glewFogCoordfvEXT;

extern __declspec(dllimport) PFNGLFRAGMENTCOLORMATERIALEXTPROC __glewFragmentColorMaterialEXT;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTMODELFEXTPROC __glewFragmentLightModelfEXT;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTMODELFVEXTPROC __glewFragmentLightModelfvEXT;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTMODELIEXTPROC __glewFragmentLightModeliEXT;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTMODELIVEXTPROC __glewFragmentLightModelivEXT;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTFEXTPROC __glewFragmentLightfEXT;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTFVEXTPROC __glewFragmentLightfvEXT;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTIEXTPROC __glewFragmentLightiEXT;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTIVEXTPROC __glewFragmentLightivEXT;
extern __declspec(dllimport) PFNGLFRAGMENTMATERIALFEXTPROC __glewFragmentMaterialfEXT;
extern __declspec(dllimport) PFNGLFRAGMENTMATERIALFVEXTPROC __glewFragmentMaterialfvEXT;
extern __declspec(dllimport) PFNGLFRAGMENTMATERIALIEXTPROC __glewFragmentMaterialiEXT;
extern __declspec(dllimport) PFNGLFRAGMENTMATERIALIVEXTPROC __glewFragmentMaterialivEXT;
extern __declspec(dllimport) PFNGLGETFRAGMENTLIGHTFVEXTPROC __glewGetFragmentLightfvEXT;
extern __declspec(dllimport) PFNGLGETFRAGMENTLIGHTIVEXTPROC __glewGetFragmentLightivEXT;
extern __declspec(dllimport) PFNGLGETFRAGMENTMATERIALFVEXTPROC __glewGetFragmentMaterialfvEXT;
extern __declspec(dllimport) PFNGLGETFRAGMENTMATERIALIVEXTPROC __glewGetFragmentMaterialivEXT;
extern __declspec(dllimport) PFNGLLIGHTENVIEXTPROC __glewLightEnviEXT;

extern __declspec(dllimport) PFNGLBLITFRAMEBUFFEREXTPROC __glewBlitFramebufferEXT;

extern __declspec(dllimport) PFNGLRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC __glewRenderbufferStorageMultisampleEXT;

extern __declspec(dllimport) PFNGLBINDFRAMEBUFFEREXTPROC __glewBindFramebufferEXT;
extern __declspec(dllimport) PFNGLBINDRENDERBUFFEREXTPROC __glewBindRenderbufferEXT;
extern __declspec(dllimport) PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC __glewCheckFramebufferStatusEXT;
extern __declspec(dllimport) PFNGLDELETEFRAMEBUFFERSEXTPROC __glewDeleteFramebuffersEXT;
extern __declspec(dllimport) PFNGLDELETERENDERBUFFERSEXTPROC __glewDeleteRenderbuffersEXT;
extern __declspec(dllimport) PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC __glewFramebufferRenderbufferEXT;
extern __declspec(dllimport) PFNGLFRAMEBUFFERTEXTURE1DEXTPROC __glewFramebufferTexture1DEXT;
extern __declspec(dllimport) PFNGLFRAMEBUFFERTEXTURE2DEXTPROC __glewFramebufferTexture2DEXT;
extern __declspec(dllimport) PFNGLFRAMEBUFFERTEXTURE3DEXTPROC __glewFramebufferTexture3DEXT;
extern __declspec(dllimport) PFNGLGENFRAMEBUFFERSEXTPROC __glewGenFramebuffersEXT;
extern __declspec(dllimport) PFNGLGENRENDERBUFFERSEXTPROC __glewGenRenderbuffersEXT;
extern __declspec(dllimport) PFNGLGENERATEMIPMAPEXTPROC __glewGenerateMipmapEXT;
extern __declspec(dllimport) PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC __glewGetFramebufferAttachmentParameterivEXT;
extern __declspec(dllimport) PFNGLGETRENDERBUFFERPARAMETERIVEXTPROC __glewGetRenderbufferParameterivEXT;
extern __declspec(dllimport) PFNGLISFRAMEBUFFEREXTPROC __glewIsFramebufferEXT;
extern __declspec(dllimport) PFNGLISRENDERBUFFEREXTPROC __glewIsRenderbufferEXT;
extern __declspec(dllimport) PFNGLRENDERBUFFERSTORAGEEXTPROC __glewRenderbufferStorageEXT;

extern __declspec(dllimport) PFNGLFRAMEBUFFERTEXTUREEXTPROC __glewFramebufferTextureEXT;
extern __declspec(dllimport) PFNGLFRAMEBUFFERTEXTUREFACEEXTPROC __glewFramebufferTextureFaceEXT;
extern __declspec(dllimport) PFNGLPROGRAMPARAMETERIEXTPROC __glewProgramParameteriEXT;

extern __declspec(dllimport) PFNGLPROGRAMENVPARAMETERS4FVEXTPROC __glewProgramEnvParameters4fvEXT;
extern __declspec(dllimport) PFNGLPROGRAMLOCALPARAMETERS4FVEXTPROC __glewProgramLocalParameters4fvEXT;

extern __declspec(dllimport) PFNGLBINDFRAGDATALOCATIONEXTPROC __glewBindFragDataLocationEXT;
extern __declspec(dllimport) PFNGLGETFRAGDATALOCATIONEXTPROC __glewGetFragDataLocationEXT;
extern __declspec(dllimport) PFNGLGETUNIFORMUIVEXTPROC __glewGetUniformuivEXT;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBIIVEXTPROC __glewGetVertexAttribIivEXT;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBIUIVEXTPROC __glewGetVertexAttribIuivEXT;
extern __declspec(dllimport) PFNGLUNIFORM1UIEXTPROC __glewUniform1uiEXT;
extern __declspec(dllimport) PFNGLUNIFORM1UIVEXTPROC __glewUniform1uivEXT;
extern __declspec(dllimport) PFNGLUNIFORM2UIEXTPROC __glewUniform2uiEXT;
extern __declspec(dllimport) PFNGLUNIFORM2UIVEXTPROC __glewUniform2uivEXT;
extern __declspec(dllimport) PFNGLUNIFORM3UIEXTPROC __glewUniform3uiEXT;
extern __declspec(dllimport) PFNGLUNIFORM3UIVEXTPROC __glewUniform3uivEXT;
extern __declspec(dllimport) PFNGLUNIFORM4UIEXTPROC __glewUniform4uiEXT;
extern __declspec(dllimport) PFNGLUNIFORM4UIVEXTPROC __glewUniform4uivEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI1IEXTPROC __glewVertexAttribI1iEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI1IVEXTPROC __glewVertexAttribI1ivEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI1UIEXTPROC __glewVertexAttribI1uiEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI1UIVEXTPROC __glewVertexAttribI1uivEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI2IEXTPROC __glewVertexAttribI2iEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI2IVEXTPROC __glewVertexAttribI2ivEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI2UIEXTPROC __glewVertexAttribI2uiEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI2UIVEXTPROC __glewVertexAttribI2uivEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI3IEXTPROC __glewVertexAttribI3iEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI3IVEXTPROC __glewVertexAttribI3ivEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI3UIEXTPROC __glewVertexAttribI3uiEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI3UIVEXTPROC __glewVertexAttribI3uivEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4BVEXTPROC __glewVertexAttribI4bvEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4IEXTPROC __glewVertexAttribI4iEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4IVEXTPROC __glewVertexAttribI4ivEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4SVEXTPROC __glewVertexAttribI4svEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4UBVEXTPROC __glewVertexAttribI4ubvEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4UIEXTPROC __glewVertexAttribI4uiEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4UIVEXTPROC __glewVertexAttribI4uivEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4USVEXTPROC __glewVertexAttribI4usvEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBIPOINTEREXTPROC __glewVertexAttribIPointerEXT;

extern __declspec(dllimport) PFNGLGETHISTOGRAMEXTPROC __glewGetHistogramEXT;
extern __declspec(dllimport) PFNGLGETHISTOGRAMPARAMETERFVEXTPROC __glewGetHistogramParameterfvEXT;
extern __declspec(dllimport) PFNGLGETHISTOGRAMPARAMETERIVEXTPROC __glewGetHistogramParameterivEXT;
extern __declspec(dllimport) PFNGLGETMINMAXEXTPROC __glewGetMinmaxEXT;
extern __declspec(dllimport) PFNGLGETMINMAXPARAMETERFVEXTPROC __glewGetMinmaxParameterfvEXT;
extern __declspec(dllimport) PFNGLGETMINMAXPARAMETERIVEXTPROC __glewGetMinmaxParameterivEXT;
extern __declspec(dllimport) PFNGLHISTOGRAMEXTPROC __glewHistogramEXT;
extern __declspec(dllimport) PFNGLMINMAXEXTPROC __glewMinmaxEXT;
extern __declspec(dllimport) PFNGLRESETHISTOGRAMEXTPROC __glewResetHistogramEXT;
extern __declspec(dllimport) PFNGLRESETMINMAXEXTPROC __glewResetMinmaxEXT;

extern __declspec(dllimport) PFNGLINDEXFUNCEXTPROC __glewIndexFuncEXT;

extern __declspec(dllimport) PFNGLINDEXMATERIALEXTPROC __glewIndexMaterialEXT;

extern __declspec(dllimport) PFNGLVERTEXATTRIBDIVISOREXTPROC __glewVertexAttribDivisorEXT;

extern __declspec(dllimport) PFNGLAPPLYTEXTUREEXTPROC __glewApplyTextureEXT;
extern __declspec(dllimport) PFNGLTEXTURELIGHTEXTPROC __glewTextureLightEXT;
extern __declspec(dllimport) PFNGLTEXTUREMATERIALEXTPROC __glewTextureMaterialEXT;

extern __declspec(dllimport) PFNGLFLUSHMAPPEDBUFFERRANGEEXTPROC __glewFlushMappedBufferRangeEXT;
extern __declspec(dllimport) PFNGLMAPBUFFERRANGEEXTPROC __glewMapBufferRangeEXT;

extern __declspec(dllimport) PFNGLBUFFERSTORAGEMEMEXTPROC __glewBufferStorageMemEXT;
extern __declspec(dllimport) PFNGLCREATEMEMORYOBJECTSEXTPROC __glewCreateMemoryObjectsEXT;
extern __declspec(dllimport) PFNGLDELETEMEMORYOBJECTSEXTPROC __glewDeleteMemoryObjectsEXT;
extern __declspec(dllimport) PFNGLGETMEMORYOBJECTPARAMETERIVEXTPROC __glewGetMemoryObjectParameterivEXT;
extern __declspec(dllimport) PFNGLGETUNSIGNEDBYTEI_VEXTPROC __glewGetUnsignedBytei_vEXT;
extern __declspec(dllimport) PFNGLGETUNSIGNEDBYTEVEXTPROC __glewGetUnsignedBytevEXT;
extern __declspec(dllimport) PFNGLISMEMORYOBJECTEXTPROC __glewIsMemoryObjectEXT;
extern __declspec(dllimport) PFNGLMEMORYOBJECTPARAMETERIVEXTPROC __glewMemoryObjectParameterivEXT;
extern __declspec(dllimport) PFNGLNAMEDBUFFERSTORAGEMEMEXTPROC __glewNamedBufferStorageMemEXT;
extern __declspec(dllimport) PFNGLTEXSTORAGEMEM1DEXTPROC __glewTexStorageMem1DEXT;
extern __declspec(dllimport) PFNGLTEXSTORAGEMEM2DEXTPROC __glewTexStorageMem2DEXT;
extern __declspec(dllimport) PFNGLTEXSTORAGEMEM2DMULTISAMPLEEXTPROC __glewTexStorageMem2DMultisampleEXT;
extern __declspec(dllimport) PFNGLTEXSTORAGEMEM3DEXTPROC __glewTexStorageMem3DEXT;
extern __declspec(dllimport) PFNGLTEXSTORAGEMEM3DMULTISAMPLEEXTPROC __glewTexStorageMem3DMultisampleEXT;
extern __declspec(dllimport) PFNGLTEXTURESTORAGEMEM1DEXTPROC __glewTextureStorageMem1DEXT;
extern __declspec(dllimport) PFNGLTEXTURESTORAGEMEM2DEXTPROC __glewTextureStorageMem2DEXT;
extern __declspec(dllimport) PFNGLTEXTURESTORAGEMEM2DMULTISAMPLEEXTPROC __glewTextureStorageMem2DMultisampleEXT;
extern __declspec(dllimport) PFNGLTEXTURESTORAGEMEM3DEXTPROC __glewTextureStorageMem3DEXT;
extern __declspec(dllimport) PFNGLTEXTURESTORAGEMEM3DMULTISAMPLEEXTPROC __glewTextureStorageMem3DMultisampleEXT;

extern __declspec(dllimport) PFNGLIMPORTMEMORYFDEXTPROC __glewImportMemoryFdEXT;

extern __declspec(dllimport) PFNGLIMPORTMEMORYWIN32HANDLEEXTPROC __glewImportMemoryWin32HandleEXT;
extern __declspec(dllimport) PFNGLIMPORTMEMORYWIN32NAMEEXTPROC __glewImportMemoryWin32NameEXT;

extern __declspec(dllimport) PFNGLMULTIDRAWARRAYSEXTPROC __glewMultiDrawArraysEXT;
extern __declspec(dllimport) PFNGLMULTIDRAWELEMENTSEXTPROC __glewMultiDrawElementsEXT;

extern __declspec(dllimport) PFNGLMULTIDRAWARRAYSINDIRECTEXTPROC __glewMultiDrawArraysIndirectEXT;
extern __declspec(dllimport) PFNGLMULTIDRAWELEMENTSINDIRECTEXTPROC __glewMultiDrawElementsIndirectEXT;

extern __declspec(dllimport) PFNGLSAMPLEMASKEXTPROC __glewSampleMaskEXT;
extern __declspec(dllimport) PFNGLSAMPLEPATTERNEXTPROC __glewSamplePatternEXT;

extern __declspec(dllimport) PFNGLFRAMEBUFFERTEXTURE2DMULTISAMPLEEXTPROC __glewFramebufferTexture2DMultisampleEXT;

extern __declspec(dllimport) PFNGLDRAWBUFFERSINDEXEDEXTPROC __glewDrawBuffersIndexedEXT;
extern __declspec(dllimport) PFNGLGETINTEGERI_VEXTPROC __glewGetIntegeri_vEXT;
extern __declspec(dllimport) PFNGLREADBUFFERINDEXEDEXTPROC __glewReadBufferIndexedEXT;

extern __declspec(dllimport) PFNGLCOLORTABLEEXTPROC __glewColorTableEXT;
extern __declspec(dllimport) PFNGLGETCOLORTABLEEXTPROC __glewGetColorTableEXT;
extern __declspec(dllimport) PFNGLGETCOLORTABLEPARAMETERFVEXTPROC __glewGetColorTableParameterfvEXT;
extern __declspec(dllimport) PFNGLGETCOLORTABLEPARAMETERIVEXTPROC __glewGetColorTableParameterivEXT;

extern __declspec(dllimport) PFNGLGETPIXELTRANSFORMPARAMETERFVEXTPROC __glewGetPixelTransformParameterfvEXT;
extern __declspec(dllimport) PFNGLGETPIXELTRANSFORMPARAMETERIVEXTPROC __glewGetPixelTransformParameterivEXT;
extern __declspec(dllimport) PFNGLPIXELTRANSFORMPARAMETERFEXTPROC __glewPixelTransformParameterfEXT;
extern __declspec(dllimport) PFNGLPIXELTRANSFORMPARAMETERFVEXTPROC __glewPixelTransformParameterfvEXT;
extern __declspec(dllimport) PFNGLPIXELTRANSFORMPARAMETERIEXTPROC __glewPixelTransformParameteriEXT;
extern __declspec(dllimport) PFNGLPIXELTRANSFORMPARAMETERIVEXTPROC __glewPixelTransformParameterivEXT;

extern __declspec(dllimport) PFNGLPOINTPARAMETERFEXTPROC __glewPointParameterfEXT;
extern __declspec(dllimport) PFNGLPOINTPARAMETERFVEXTPROC __glewPointParameterfvEXT;

extern __declspec(dllimport) PFNGLPOLYGONOFFSETEXTPROC __glewPolygonOffsetEXT;

extern __declspec(dllimport) PFNGLPOLYGONOFFSETCLAMPEXTPROC __glewPolygonOffsetClampEXT;

extern __declspec(dllimport) PFNGLPROVOKINGVERTEXEXTPROC __glewProvokingVertexEXT;

extern __declspec(dllimport) PFNGLCOVERAGEMODULATIONNVPROC __glewCoverageModulationNV;
extern __declspec(dllimport) PFNGLCOVERAGEMODULATIONTABLENVPROC __glewCoverageModulationTableNV;
extern __declspec(dllimport) PFNGLGETCOVERAGEMODULATIONTABLENVPROC __glewGetCoverageModulationTableNV;
extern __declspec(dllimport) PFNGLRASTERSAMPLESEXTPROC __glewRasterSamplesEXT;

extern __declspec(dllimport) PFNGLBEGINSCENEEXTPROC __glewBeginSceneEXT;
extern __declspec(dllimport) PFNGLENDSCENEEXTPROC __glewEndSceneEXT;

extern __declspec(dllimport) PFNGLSECONDARYCOLOR3BEXTPROC __glewSecondaryColor3bEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3BVEXTPROC __glewSecondaryColor3bvEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3DEXTPROC __glewSecondaryColor3dEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3DVEXTPROC __glewSecondaryColor3dvEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3FEXTPROC __glewSecondaryColor3fEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3FVEXTPROC __glewSecondaryColor3fvEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3IEXTPROC __glewSecondaryColor3iEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3IVEXTPROC __glewSecondaryColor3ivEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3SEXTPROC __glewSecondaryColor3sEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3SVEXTPROC __glewSecondaryColor3svEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3UBEXTPROC __glewSecondaryColor3ubEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3UBVEXTPROC __glewSecondaryColor3ubvEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3UIEXTPROC __glewSecondaryColor3uiEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3UIVEXTPROC __glewSecondaryColor3uivEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3USEXTPROC __glewSecondaryColor3usEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3USVEXTPROC __glewSecondaryColor3usvEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLORPOINTEREXTPROC __glewSecondaryColorPointerEXT;

extern __declspec(dllimport) PFNGLDELETESEMAPHORESEXTPROC __glewDeleteSemaphoresEXT;
extern __declspec(dllimport) PFNGLGENSEMAPHORESEXTPROC __glewGenSemaphoresEXT;
extern __declspec(dllimport) PFNGLGETSEMAPHOREPARAMETERUI64VEXTPROC __glewGetSemaphoreParameterui64vEXT;
extern __declspec(dllimport) PFNGLISSEMAPHOREEXTPROC __glewIsSemaphoreEXT;
extern __declspec(dllimport) PFNGLSEMAPHOREPARAMETERUI64VEXTPROC __glewSemaphoreParameterui64vEXT;
extern __declspec(dllimport) PFNGLSIGNALSEMAPHOREEXTPROC __glewSignalSemaphoreEXT;
extern __declspec(dllimport) PFNGLWAITSEMAPHOREEXTPROC __glewWaitSemaphoreEXT;

extern __declspec(dllimport) PFNGLIMPORTSEMAPHOREFDEXTPROC __glewImportSemaphoreFdEXT;

extern __declspec(dllimport) PFNGLIMPORTSEMAPHOREWIN32HANDLEEXTPROC __glewImportSemaphoreWin32HandleEXT;
extern __declspec(dllimport) PFNGLIMPORTSEMAPHOREWIN32NAMEEXTPROC __glewImportSemaphoreWin32NameEXT;

extern __declspec(dllimport) PFNGLACTIVEPROGRAMEXTPROC __glewActiveProgramEXT;
extern __declspec(dllimport) PFNGLCREATESHADERPROGRAMEXTPROC __glewCreateShaderProgramEXT;
extern __declspec(dllimport) PFNGLUSESHADERPROGRAMEXTPROC __glewUseShaderProgramEXT;

extern __declspec(dllimport) PFNGLBINDIMAGETEXTUREEXTPROC __glewBindImageTextureEXT;
extern __declspec(dllimport) PFNGLMEMORYBARRIEREXTPROC __glewMemoryBarrierEXT;

extern __declspec(dllimport) PFNGLCLEARPIXELLOCALSTORAGEUIEXTPROC __glewClearPixelLocalStorageuiEXT;
extern __declspec(dllimport) PFNGLFRAMEBUFFERPIXELLOCALSTORAGESIZEEXTPROC __glewFramebufferPixelLocalStorageSizeEXT;
extern __declspec(dllimport) PFNGLGETFRAMEBUFFERPIXELLOCALSTORAGESIZEEXTPROC __glewGetFramebufferPixelLocalStorageSizeEXT;

extern __declspec(dllimport) PFNGLTEXPAGECOMMITMENTEXTPROC __glewTexPageCommitmentEXT;
extern __declspec(dllimport) PFNGLTEXTUREPAGECOMMITMENTEXTPROC __glewTexturePageCommitmentEXT;

extern __declspec(dllimport) PFNGLACTIVESTENCILFACEEXTPROC __glewActiveStencilFaceEXT;

extern __declspec(dllimport) PFNGLTEXSUBIMAGE1DEXTPROC __glewTexSubImage1DEXT;
extern __declspec(dllimport) PFNGLTEXSUBIMAGE2DEXTPROC __glewTexSubImage2DEXT;
extern __declspec(dllimport) PFNGLTEXSUBIMAGE3DEXTPROC __glewTexSubImage3DEXT;

extern __declspec(dllimport) PFNGLTEXIMAGE3DEXTPROC __glewTexImage3DEXT;

extern __declspec(dllimport) PFNGLFRAMEBUFFERTEXTURELAYEREXTPROC __glewFramebufferTextureLayerEXT;

extern __declspec(dllimport) PFNGLTEXBUFFEREXTPROC __glewTexBufferEXT;

extern __declspec(dllimport) PFNGLCLEARCOLORIIEXTPROC __glewClearColorIiEXT;
extern __declspec(dllimport) PFNGLCLEARCOLORIUIEXTPROC __glewClearColorIuiEXT;
extern __declspec(dllimport) PFNGLGETTEXPARAMETERIIVEXTPROC __glewGetTexParameterIivEXT;
extern __declspec(dllimport) PFNGLGETTEXPARAMETERIUIVEXTPROC __glewGetTexParameterIuivEXT;
extern __declspec(dllimport) PFNGLTEXPARAMETERIIVEXTPROC __glewTexParameterIivEXT;
extern __declspec(dllimport) PFNGLTEXPARAMETERIUIVEXTPROC __glewTexParameterIuivEXT;

extern __declspec(dllimport) PFNGLARETEXTURESRESIDENTEXTPROC __glewAreTexturesResidentEXT;
extern __declspec(dllimport) PFNGLBINDTEXTUREEXTPROC __glewBindTextureEXT;
extern __declspec(dllimport) PFNGLDELETETEXTURESEXTPROC __glewDeleteTexturesEXT;
extern __declspec(dllimport) PFNGLGENTEXTURESEXTPROC __glewGenTexturesEXT;
extern __declspec(dllimport) PFNGLISTEXTUREEXTPROC __glewIsTextureEXT;
extern __declspec(dllimport) PFNGLPRIORITIZETEXTURESEXTPROC __glewPrioritizeTexturesEXT;

extern __declspec(dllimport) PFNGLTEXTURENORMALEXTPROC __glewTextureNormalEXT;

extern __declspec(dllimport) PFNGLTEXSTORAGE1DEXTPROC __glewTexStorage1DEXT;
extern __declspec(dllimport) PFNGLTEXSTORAGE2DEXTPROC __glewTexStorage2DEXT;
extern __declspec(dllimport) PFNGLTEXSTORAGE3DEXTPROC __glewTexStorage3DEXT;
extern __declspec(dllimport) PFNGLTEXTURESTORAGE1DEXTPROC __glewTextureStorage1DEXT;
extern __declspec(dllimport) PFNGLTEXTURESTORAGE2DEXTPROC __glewTextureStorage2DEXT;
extern __declspec(dllimport) PFNGLTEXTURESTORAGE3DEXTPROC __glewTextureStorage3DEXT;

extern __declspec(dllimport) PFNGLTEXTUREVIEWEXTPROC __glewTextureViewEXT;

extern __declspec(dllimport) PFNGLGETQUERYOBJECTI64VEXTPROC __glewGetQueryObjecti64vEXT;
extern __declspec(dllimport) PFNGLGETQUERYOBJECTUI64VEXTPROC __glewGetQueryObjectui64vEXT;

extern __declspec(dllimport) PFNGLBEGINTRANSFORMFEEDBACKEXTPROC __glewBeginTransformFeedbackEXT;
extern __declspec(dllimport) PFNGLBINDBUFFERBASEEXTPROC __glewBindBufferBaseEXT;
extern __declspec(dllimport) PFNGLBINDBUFFEROFFSETEXTPROC __glewBindBufferOffsetEXT;
extern __declspec(dllimport) PFNGLBINDBUFFERRANGEEXTPROC __glewBindBufferRangeEXT;
extern __declspec(dllimport) PFNGLENDTRANSFORMFEEDBACKEXTPROC __glewEndTransformFeedbackEXT;
extern __declspec(dllimport) PFNGLGETTRANSFORMFEEDBACKVARYINGEXTPROC __glewGetTransformFeedbackVaryingEXT;
extern __declspec(dllimport) PFNGLTRANSFORMFEEDBACKVARYINGSEXTPROC __glewTransformFeedbackVaryingsEXT;

extern __declspec(dllimport) PFNGLARRAYELEMENTEXTPROC __glewArrayElementEXT;
extern __declspec(dllimport) PFNGLCOLORPOINTEREXTPROC __glewColorPointerEXT;
extern __declspec(dllimport) PFNGLDRAWARRAYSEXTPROC __glewDrawArraysEXT;
extern __declspec(dllimport) PFNGLEDGEFLAGPOINTEREXTPROC __glewEdgeFlagPointerEXT;
extern __declspec(dllimport) PFNGLINDEXPOINTEREXTPROC __glewIndexPointerEXT;
extern __declspec(dllimport) PFNGLNORMALPOINTEREXTPROC __glewNormalPointerEXT;
extern __declspec(dllimport) PFNGLTEXCOORDPOINTEREXTPROC __glewTexCoordPointerEXT;
extern __declspec(dllimport) PFNGLVERTEXPOINTEREXTPROC __glewVertexPointerEXT;

extern __declspec(dllimport) PFNGLBINDARRAYSETEXTPROC __glewBindArraySetEXT;
extern __declspec(dllimport) PFNGLCREATEARRAYSETEXTPROC __glewCreateArraySetExt;
extern __declspec(dllimport) PFNGLDELETEARRAYSETSEXTPROC __glewDeleteArraySetsEXT;

extern __declspec(dllimport) PFNGLGETVERTEXATTRIBLDVEXTPROC __glewGetVertexAttribLdvEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYVERTEXATTRIBLOFFSETEXTPROC __glewVertexArrayVertexAttribLOffsetEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL1DEXTPROC __glewVertexAttribL1dEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL1DVEXTPROC __glewVertexAttribL1dvEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL2DEXTPROC __glewVertexAttribL2dEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL2DVEXTPROC __glewVertexAttribL2dvEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL3DEXTPROC __glewVertexAttribL3dEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL3DVEXTPROC __glewVertexAttribL3dvEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL4DEXTPROC __glewVertexAttribL4dEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL4DVEXTPROC __glewVertexAttribL4dvEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBLPOINTEREXTPROC __glewVertexAttribLPointerEXT;

extern __declspec(dllimport) PFNGLBEGINVERTEXSHADEREXTPROC __glewBeginVertexShaderEXT;
extern __declspec(dllimport) PFNGLBINDLIGHTPARAMETEREXTPROC __glewBindLightParameterEXT;
extern __declspec(dllimport) PFNGLBINDMATERIALPARAMETEREXTPROC __glewBindMaterialParameterEXT;
extern __declspec(dllimport) PFNGLBINDPARAMETEREXTPROC __glewBindParameterEXT;
extern __declspec(dllimport) PFNGLBINDTEXGENPARAMETEREXTPROC __glewBindTexGenParameterEXT;
extern __declspec(dllimport) PFNGLBINDTEXTUREUNITPARAMETEREXTPROC __glewBindTextureUnitParameterEXT;
extern __declspec(dllimport) PFNGLBINDVERTEXSHADEREXTPROC __glewBindVertexShaderEXT;
extern __declspec(dllimport) PFNGLDELETEVERTEXSHADEREXTPROC __glewDeleteVertexShaderEXT;
extern __declspec(dllimport) PFNGLDISABLEVARIANTCLIENTSTATEEXTPROC __glewDisableVariantClientStateEXT;
extern __declspec(dllimport) PFNGLENABLEVARIANTCLIENTSTATEEXTPROC __glewEnableVariantClientStateEXT;
extern __declspec(dllimport) PFNGLENDVERTEXSHADEREXTPROC __glewEndVertexShaderEXT;
extern __declspec(dllimport) PFNGLEXTRACTCOMPONENTEXTPROC __glewExtractComponentEXT;
extern __declspec(dllimport) PFNGLGENSYMBOLSEXTPROC __glewGenSymbolsEXT;
extern __declspec(dllimport) PFNGLGENVERTEXSHADERSEXTPROC __glewGenVertexShadersEXT;
extern __declspec(dllimport) PFNGLGETINVARIANTBOOLEANVEXTPROC __glewGetInvariantBooleanvEXT;
extern __declspec(dllimport) PFNGLGETINVARIANTFLOATVEXTPROC __glewGetInvariantFloatvEXT;
extern __declspec(dllimport) PFNGLGETINVARIANTINTEGERVEXTPROC __glewGetInvariantIntegervEXT;
extern __declspec(dllimport) PFNGLGETLOCALCONSTANTBOOLEANVEXTPROC __glewGetLocalConstantBooleanvEXT;
extern __declspec(dllimport) PFNGLGETLOCALCONSTANTFLOATVEXTPROC __glewGetLocalConstantFloatvEXT;
extern __declspec(dllimport) PFNGLGETLOCALCONSTANTINTEGERVEXTPROC __glewGetLocalConstantIntegervEXT;
extern __declspec(dllimport) PFNGLGETVARIANTBOOLEANVEXTPROC __glewGetVariantBooleanvEXT;
extern __declspec(dllimport) PFNGLGETVARIANTFLOATVEXTPROC __glewGetVariantFloatvEXT;
extern __declspec(dllimport) PFNGLGETVARIANTINTEGERVEXTPROC __glewGetVariantIntegervEXT;
extern __declspec(dllimport) PFNGLGETVARIANTPOINTERVEXTPROC __glewGetVariantPointervEXT;
extern __declspec(dllimport) PFNGLINSERTCOMPONENTEXTPROC __glewInsertComponentEXT;
extern __declspec(dllimport) PFNGLISVARIANTENABLEDEXTPROC __glewIsVariantEnabledEXT;
extern __declspec(dllimport) PFNGLSETINVARIANTEXTPROC __glewSetInvariantEXT;
extern __declspec(dllimport) PFNGLSETLOCALCONSTANTEXTPROC __glewSetLocalConstantEXT;
extern __declspec(dllimport) PFNGLSHADEROP1EXTPROC __glewShaderOp1EXT;
extern __declspec(dllimport) PFNGLSHADEROP2EXTPROC __glewShaderOp2EXT;
extern __declspec(dllimport) PFNGLSHADEROP3EXTPROC __glewShaderOp3EXT;
extern __declspec(dllimport) PFNGLSWIZZLEEXTPROC __glewSwizzleEXT;
extern __declspec(dllimport) PFNGLVARIANTPOINTEREXTPROC __glewVariantPointerEXT;
extern __declspec(dllimport) PFNGLVARIANTBVEXTPROC __glewVariantbvEXT;
extern __declspec(dllimport) PFNGLVARIANTDVEXTPROC __glewVariantdvEXT;
extern __declspec(dllimport) PFNGLVARIANTFVEXTPROC __glewVariantfvEXT;
extern __declspec(dllimport) PFNGLVARIANTIVEXTPROC __glewVariantivEXT;
extern __declspec(dllimport) PFNGLVARIANTSVEXTPROC __glewVariantsvEXT;
extern __declspec(dllimport) PFNGLVARIANTUBVEXTPROC __glewVariantubvEXT;
extern __declspec(dllimport) PFNGLVARIANTUIVEXTPROC __glewVariantuivEXT;
extern __declspec(dllimport) PFNGLVARIANTUSVEXTPROC __glewVariantusvEXT;
extern __declspec(dllimport) PFNGLWRITEMASKEXTPROC __glewWriteMaskEXT;

extern __declspec(dllimport) PFNGLVERTEXWEIGHTPOINTEREXTPROC __glewVertexWeightPointerEXT;
extern __declspec(dllimport) PFNGLVERTEXWEIGHTFEXTPROC __glewVertexWeightfEXT;
extern __declspec(dllimport) PFNGLVERTEXWEIGHTFVEXTPROC __glewVertexWeightfvEXT;

extern __declspec(dllimport) PFNGLACQUIREKEYEDMUTEXWIN32EXTPROC __glewAcquireKeyedMutexWin32EXT;
extern __declspec(dllimport) PFNGLRELEASEKEYEDMUTEXWIN32EXTPROC __glewReleaseKeyedMutexWin32EXT;

extern __declspec(dllimport) PFNGLWINDOWRECTANGLESEXTPROC __glewWindowRectanglesEXT;

extern __declspec(dllimport) PFNGLIMPORTSYNCEXTPROC __glewImportSyncEXT;

extern __declspec(dllimport) PFNGLFRAMETERMINATORGREMEDYPROC __glewFrameTerminatorGREMEDY;

extern __declspec(dllimport) PFNGLSTRINGMARKERGREMEDYPROC __glewStringMarkerGREMEDY;

extern __declspec(dllimport) PFNGLGETIMAGETRANSFORMPARAMETERFVHPPROC __glewGetImageTransformParameterfvHP;
extern __declspec(dllimport) PFNGLGETIMAGETRANSFORMPARAMETERIVHPPROC __glewGetImageTransformParameterivHP;
extern __declspec(dllimport) PFNGLIMAGETRANSFORMPARAMETERFHPPROC __glewImageTransformParameterfHP;
extern __declspec(dllimport) PFNGLIMAGETRANSFORMPARAMETERFVHPPROC __glewImageTransformParameterfvHP;
extern __declspec(dllimport) PFNGLIMAGETRANSFORMPARAMETERIHPPROC __glewImageTransformParameteriHP;
extern __declspec(dllimport) PFNGLIMAGETRANSFORMPARAMETERIVHPPROC __glewImageTransformParameterivHP;

extern __declspec(dllimport) PFNGLMULTIMODEDRAWARRAYSIBMPROC __glewMultiModeDrawArraysIBM;
extern __declspec(dllimport) PFNGLMULTIMODEDRAWELEMENTSIBMPROC __glewMultiModeDrawElementsIBM;

extern __declspec(dllimport) PFNGLCOLORPOINTERLISTIBMPROC __glewColorPointerListIBM;
extern __declspec(dllimport) PFNGLEDGEFLAGPOINTERLISTIBMPROC __glewEdgeFlagPointerListIBM;
extern __declspec(dllimport) PFNGLFOGCOORDPOINTERLISTIBMPROC __glewFogCoordPointerListIBM;
extern __declspec(dllimport) PFNGLINDEXPOINTERLISTIBMPROC __glewIndexPointerListIBM;
extern __declspec(dllimport) PFNGLNORMALPOINTERLISTIBMPROC __glewNormalPointerListIBM;
extern __declspec(dllimport) PFNGLSECONDARYCOLORPOINTERLISTIBMPROC __glewSecondaryColorPointerListIBM;
extern __declspec(dllimport) PFNGLTEXCOORDPOINTERLISTIBMPROC __glewTexCoordPointerListIBM;
extern __declspec(dllimport) PFNGLVERTEXPOINTERLISTIBMPROC __glewVertexPointerListIBM;

extern __declspec(dllimport) PFNGLMAPTEXTURE2DINTELPROC __glewMapTexture2DINTEL;
extern __declspec(dllimport) PFNGLSYNCTEXTUREINTELPROC __glewSyncTextureINTEL;
extern __declspec(dllimport) PFNGLUNMAPTEXTURE2DINTELPROC __glewUnmapTexture2DINTEL;

extern __declspec(dllimport) PFNGLCOLORPOINTERVINTELPROC __glewColorPointervINTEL;
extern __declspec(dllimport) PFNGLNORMALPOINTERVINTELPROC __glewNormalPointervINTEL;
extern __declspec(dllimport) PFNGLTEXCOORDPOINTERVINTELPROC __glewTexCoordPointervINTEL;
extern __declspec(dllimport) PFNGLVERTEXPOINTERVINTELPROC __glewVertexPointervINTEL;

extern __declspec(dllimport) PFNGLBEGINPERFQUERYINTELPROC __glewBeginPerfQueryINTEL;
extern __declspec(dllimport) PFNGLCREATEPERFQUERYINTELPROC __glewCreatePerfQueryINTEL;
extern __declspec(dllimport) PFNGLDELETEPERFQUERYINTELPROC __glewDeletePerfQueryINTEL;
extern __declspec(dllimport) PFNGLENDPERFQUERYINTELPROC __glewEndPerfQueryINTEL;
extern __declspec(dllimport) PFNGLGETFIRSTPERFQUERYIDINTELPROC __glewGetFirstPerfQueryIdINTEL;
extern __declspec(dllimport) PFNGLGETNEXTPERFQUERYIDINTELPROC __glewGetNextPerfQueryIdINTEL;
extern __declspec(dllimport) PFNGLGETPERFCOUNTERINFOINTELPROC __glewGetPerfCounterInfoINTEL;
extern __declspec(dllimport) PFNGLGETPERFQUERYDATAINTELPROC __glewGetPerfQueryDataINTEL;
extern __declspec(dllimport) PFNGLGETPERFQUERYIDBYNAMEINTELPROC __glewGetPerfQueryIdByNameINTEL;
extern __declspec(dllimport) PFNGLGETPERFQUERYINFOINTELPROC __glewGetPerfQueryInfoINTEL;

extern __declspec(dllimport) PFNGLTEXSCISSORFUNCINTELPROC __glewTexScissorFuncINTEL;
extern __declspec(dllimport) PFNGLTEXSCISSORINTELPROC __glewTexScissorINTEL;

extern __declspec(dllimport) PFNGLBLENDBARRIERKHRPROC __glewBlendBarrierKHR;

extern __declspec(dllimport) PFNGLDEBUGMESSAGECALLBACKPROC __glewDebugMessageCallback;
extern __declspec(dllimport) PFNGLDEBUGMESSAGECONTROLPROC __glewDebugMessageControl;
extern __declspec(dllimport) PFNGLDEBUGMESSAGEINSERTPROC __glewDebugMessageInsert;
extern __declspec(dllimport) PFNGLGETDEBUGMESSAGELOGPROC __glewGetDebugMessageLog;
extern __declspec(dllimport) PFNGLGETOBJECTLABELPROC __glewGetObjectLabel;
extern __declspec(dllimport) PFNGLGETOBJECTPTRLABELPROC __glewGetObjectPtrLabel;
extern __declspec(dllimport) PFNGLOBJECTLABELPROC __glewObjectLabel;
extern __declspec(dllimport) PFNGLOBJECTPTRLABELPROC __glewObjectPtrLabel;
extern __declspec(dllimport) PFNGLPOPDEBUGGROUPPROC __glewPopDebugGroup;
extern __declspec(dllimport) PFNGLPUSHDEBUGGROUPPROC __glewPushDebugGroup;

extern __declspec(dllimport) PFNGLMAXSHADERCOMPILERTHREADSKHRPROC __glewMaxShaderCompilerThreadsKHR;

extern __declspec(dllimport) PFNGLGETNUNIFORMFVPROC __glewGetnUniformfv;
extern __declspec(dllimport) PFNGLGETNUNIFORMIVPROC __glewGetnUniformiv;
extern __declspec(dllimport) PFNGLGETNUNIFORMUIVPROC __glewGetnUniformuiv;
extern __declspec(dllimport) PFNGLREADNPIXELSPROC __glewReadnPixels;

extern __declspec(dllimport) PFNGLBUFFERREGIONENABLEDPROC __glewBufferRegionEnabled;
extern __declspec(dllimport) PFNGLDELETEBUFFERREGIONPROC __glewDeleteBufferRegion;
extern __declspec(dllimport) PFNGLDRAWBUFFERREGIONPROC __glewDrawBufferRegion;
extern __declspec(dllimport) PFNGLNEWBUFFERREGIONPROC __glewNewBufferRegion;
extern __declspec(dllimport) PFNGLREADBUFFERREGIONPROC __glewReadBufferRegion;

extern __declspec(dllimport) PFNGLRESIZEBUFFERSMESAPROC __glewResizeBuffersMESA;

extern __declspec(dllimport) PFNGLWINDOWPOS2DMESAPROC __glewWindowPos2dMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS2DVMESAPROC __glewWindowPos2dvMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS2FMESAPROC __glewWindowPos2fMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS2FVMESAPROC __glewWindowPos2fvMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS2IMESAPROC __glewWindowPos2iMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS2IVMESAPROC __glewWindowPos2ivMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS2SMESAPROC __glewWindowPos2sMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS2SVMESAPROC __glewWindowPos2svMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS3DMESAPROC __glewWindowPos3dMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS3DVMESAPROC __glewWindowPos3dvMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS3FMESAPROC __glewWindowPos3fMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS3FVMESAPROC __glewWindowPos3fvMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS3IMESAPROC __glewWindowPos3iMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS3IVMESAPROC __glewWindowPos3ivMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS3SMESAPROC __glewWindowPos3sMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS3SVMESAPROC __glewWindowPos3svMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS4DMESAPROC __glewWindowPos4dMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS4DVMESAPROC __glewWindowPos4dvMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS4FMESAPROC __glewWindowPos4fMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS4FVMESAPROC __glewWindowPos4fvMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS4IMESAPROC __glewWindowPos4iMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS4IVMESAPROC __glewWindowPos4ivMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS4SMESAPROC __glewWindowPos4sMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS4SVMESAPROC __glewWindowPos4svMESA;

extern __declspec(dllimport) PFNGLBEGINCONDITIONALRENDERNVXPROC __glewBeginConditionalRenderNVX;
extern __declspec(dllimport) PFNGLENDCONDITIONALRENDERNVXPROC __glewEndConditionalRenderNVX;

extern __declspec(dllimport) PFNGLLGPUCOPYIMAGESUBDATANVXPROC __glewLGPUCopyImageSubDataNVX;
extern __declspec(dllimport) PFNGLLGPUINTERLOCKNVXPROC __glewLGPUInterlockNVX;
extern __declspec(dllimport) PFNGLLGPUNAMEDBUFFERSUBDATANVXPROC __glewLGPUNamedBufferSubDataNVX;

extern __declspec(dllimport) PFNGLSTEREOPARAMETERFNVPROC __glewStereoParameterfNV;
extern __declspec(dllimport) PFNGLSTEREOPARAMETERINVPROC __glewStereoParameteriNV;

extern __declspec(dllimport) PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSNVPROC __glewMultiDrawArraysIndirectBindlessNV;
extern __declspec(dllimport) PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSNVPROC __glewMultiDrawElementsIndirectBindlessNV;

extern __declspec(dllimport) PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSCOUNTNVPROC __glewMultiDrawArraysIndirectBindlessCountNV;
extern __declspec(dllimport) PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSCOUNTNVPROC __glewMultiDrawElementsIndirectBindlessCountNV;

extern __declspec(dllimport) PFNGLGETIMAGEHANDLENVPROC __glewGetImageHandleNV;
extern __declspec(dllimport) PFNGLGETTEXTUREHANDLENVPROC __glewGetTextureHandleNV;
extern __declspec(dllimport) PFNGLGETTEXTURESAMPLERHANDLENVPROC __glewGetTextureSamplerHandleNV;
extern __declspec(dllimport) PFNGLISIMAGEHANDLERESIDENTNVPROC __glewIsImageHandleResidentNV;
extern __declspec(dllimport) PFNGLISTEXTUREHANDLERESIDENTNVPROC __glewIsTextureHandleResidentNV;
extern __declspec(dllimport) PFNGLMAKEIMAGEHANDLENONRESIDENTNVPROC __glewMakeImageHandleNonResidentNV;
extern __declspec(dllimport) PFNGLMAKEIMAGEHANDLERESIDENTNVPROC __glewMakeImageHandleResidentNV;
extern __declspec(dllimport) PFNGLMAKETEXTUREHANDLENONRESIDENTNVPROC __glewMakeTextureHandleNonResidentNV;
extern __declspec(dllimport) PFNGLMAKETEXTUREHANDLERESIDENTNVPROC __glewMakeTextureHandleResidentNV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMHANDLEUI64NVPROC __glewProgramUniformHandleui64NV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMHANDLEUI64VNVPROC __glewProgramUniformHandleui64vNV;
extern __declspec(dllimport) PFNGLUNIFORMHANDLEUI64NVPROC __glewUniformHandleui64NV;
extern __declspec(dllimport) PFNGLUNIFORMHANDLEUI64VNVPROC __glewUniformHandleui64vNV;

extern __declspec(dllimport) PFNGLBLENDBARRIERNVPROC __glewBlendBarrierNV;
extern __declspec(dllimport) PFNGLBLENDPARAMETERINVPROC __glewBlendParameteriNV;

extern __declspec(dllimport) PFNGLVIEWPORTPOSITIONWSCALENVPROC __glewViewportPositionWScaleNV;

extern __declspec(dllimport) PFNGLCALLCOMMANDLISTNVPROC __glewCallCommandListNV;
extern __declspec(dllimport) PFNGLCOMMANDLISTSEGMENTSNVPROC __glewCommandListSegmentsNV;
extern __declspec(dllimport) PFNGLCOMPILECOMMANDLISTNVPROC __glewCompileCommandListNV;
extern __declspec(dllimport) PFNGLCREATECOMMANDLISTSNVPROC __glewCreateCommandListsNV;
extern __declspec(dllimport) PFNGLCREATESTATESNVPROC __glewCreateStatesNV;
extern __declspec(dllimport) PFNGLDELETECOMMANDLISTSNVPROC __glewDeleteCommandListsNV;
extern __declspec(dllimport) PFNGLDELETESTATESNVPROC __glewDeleteStatesNV;
extern __declspec(dllimport) PFNGLDRAWCOMMANDSADDRESSNVPROC __glewDrawCommandsAddressNV;
extern __declspec(dllimport) PFNGLDRAWCOMMANDSNVPROC __glewDrawCommandsNV;
extern __declspec(dllimport) PFNGLDRAWCOMMANDSSTATESADDRESSNVPROC __glewDrawCommandsStatesAddressNV;
extern __declspec(dllimport) PFNGLDRAWCOMMANDSSTATESNVPROC __glewDrawCommandsStatesNV;
extern __declspec(dllimport) PFNGLGETCOMMANDHEADERNVPROC __glewGetCommandHeaderNV;
extern __declspec(dllimport) PFNGLGETSTAGEINDEXNVPROC __glewGetStageIndexNV;
extern __declspec(dllimport) PFNGLISCOMMANDLISTNVPROC __glewIsCommandListNV;
extern __declspec(dllimport) PFNGLISSTATENVPROC __glewIsStateNV;
extern __declspec(dllimport) PFNGLLISTDRAWCOMMANDSSTATESCLIENTNVPROC __glewListDrawCommandsStatesClientNV;
extern __declspec(dllimport) PFNGLSTATECAPTURENVPROC __glewStateCaptureNV;

extern __declspec(dllimport) PFNGLBEGINCONDITIONALRENDERNVPROC __glewBeginConditionalRenderNV;
extern __declspec(dllimport) PFNGLENDCONDITIONALRENDERNVPROC __glewEndConditionalRenderNV;

extern __declspec(dllimport) PFNGLSUBPIXELPRECISIONBIASNVPROC __glewSubpixelPrecisionBiasNV;

extern __declspec(dllimport) PFNGLCONSERVATIVERASTERPARAMETERFNVPROC __glewConservativeRasterParameterfNV;

extern __declspec(dllimport) PFNGLCONSERVATIVERASTERPARAMETERINVPROC __glewConservativeRasterParameteriNV;

extern __declspec(dllimport) PFNGLCOPYBUFFERSUBDATANVPROC __glewCopyBufferSubDataNV;

extern __declspec(dllimport) PFNGLCOPYIMAGESUBDATANVPROC __glewCopyImageSubDataNV;

extern __declspec(dllimport) PFNGLCLEARDEPTHDNVPROC __glewClearDepthdNV;
extern __declspec(dllimport) PFNGLDEPTHBOUNDSDNVPROC __glewDepthBoundsdNV;
extern __declspec(dllimport) PFNGLDEPTHRANGEDNVPROC __glewDepthRangedNV;

extern __declspec(dllimport) PFNGLDRAWBUFFERSNVPROC __glewDrawBuffersNV;

extern __declspec(dllimport) PFNGLDRAWARRAYSINSTANCEDNVPROC __glewDrawArraysInstancedNV;
extern __declspec(dllimport) PFNGLDRAWELEMENTSINSTANCEDNVPROC __glewDrawElementsInstancedNV;

extern __declspec(dllimport) PFNGLDRAWTEXTURENVPROC __glewDrawTextureNV;

extern __declspec(dllimport) PFNGLDRAWVKIMAGENVPROC __glewDrawVkImageNV;
extern __declspec(dllimport) PFNGLGETVKPROCADDRNVPROC __glewGetVkProcAddrNV;
extern __declspec(dllimport) PFNGLSIGNALVKFENCENVPROC __glewSignalVkFenceNV;
extern __declspec(dllimport) PFNGLSIGNALVKSEMAPHORENVPROC __glewSignalVkSemaphoreNV;
extern __declspec(dllimport) PFNGLWAITVKSEMAPHORENVPROC __glewWaitVkSemaphoreNV;

extern __declspec(dllimport) PFNGLEVALMAPSNVPROC __glewEvalMapsNV;
extern __declspec(dllimport) PFNGLGETMAPATTRIBPARAMETERFVNVPROC __glewGetMapAttribParameterfvNV;
extern __declspec(dllimport) PFNGLGETMAPATTRIBPARAMETERIVNVPROC __glewGetMapAttribParameterivNV;
extern __declspec(dllimport) PFNGLGETMAPCONTROLPOINTSNVPROC __glewGetMapControlPointsNV;
extern __declspec(dllimport) PFNGLGETMAPPARAMETERFVNVPROC __glewGetMapParameterfvNV;
extern __declspec(dllimport) PFNGLGETMAPPARAMETERIVNVPROC __glewGetMapParameterivNV;
extern __declspec(dllimport) PFNGLMAPCONTROLPOINTSNVPROC __glewMapControlPointsNV;
extern __declspec(dllimport) PFNGLMAPPARAMETERFVNVPROC __glewMapParameterfvNV;
extern __declspec(dllimport) PFNGLMAPPARAMETERIVNVPROC __glewMapParameterivNV;

extern __declspec(dllimport) PFNGLGETMULTISAMPLEFVNVPROC __glewGetMultisamplefvNV;
extern __declspec(dllimport) PFNGLSAMPLEMASKINDEXEDNVPROC __glewSampleMaskIndexedNV;
extern __declspec(dllimport) PFNGLTEXRENDERBUFFERNVPROC __glewTexRenderbufferNV;

extern __declspec(dllimport) PFNGLDELETEFENCESNVPROC __glewDeleteFencesNV;
extern __declspec(dllimport) PFNGLFINISHFENCENVPROC __glewFinishFenceNV;
extern __declspec(dllimport) PFNGLGENFENCESNVPROC __glewGenFencesNV;
extern __declspec(dllimport) PFNGLGETFENCEIVNVPROC __glewGetFenceivNV;
extern __declspec(dllimport) PFNGLISFENCENVPROC __glewIsFenceNV;
extern __declspec(dllimport) PFNGLSETFENCENVPROC __glewSetFenceNV;
extern __declspec(dllimport) PFNGLTESTFENCENVPROC __glewTestFenceNV;

extern __declspec(dllimport) PFNGLFRAGMENTCOVERAGECOLORNVPROC __glewFragmentCoverageColorNV;

extern __declspec(dllimport) PFNGLGETPROGRAMNAMEDPARAMETERDVNVPROC __glewGetProgramNamedParameterdvNV;
extern __declspec(dllimport) PFNGLGETPROGRAMNAMEDPARAMETERFVNVPROC __glewGetProgramNamedParameterfvNV;
extern __declspec(dllimport) PFNGLPROGRAMNAMEDPARAMETER4DNVPROC __glewProgramNamedParameter4dNV;
extern __declspec(dllimport) PFNGLPROGRAMNAMEDPARAMETER4DVNVPROC __glewProgramNamedParameter4dvNV;
extern __declspec(dllimport) PFNGLPROGRAMNAMEDPARAMETER4FNVPROC __glewProgramNamedParameter4fNV;
extern __declspec(dllimport) PFNGLPROGRAMNAMEDPARAMETER4FVNVPROC __glewProgramNamedParameter4fvNV;

extern __declspec(dllimport) PFNGLBLITFRAMEBUFFERNVPROC __glewBlitFramebufferNV;

extern __declspec(dllimport) PFNGLRENDERBUFFERSTORAGEMULTISAMPLENVPROC __glewRenderbufferStorageMultisampleNV;

extern __declspec(dllimport) PFNGLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENVPROC __glewRenderbufferStorageMultisampleCoverageNV;

extern __declspec(dllimport) PFNGLPROGRAMVERTEXLIMITNVPROC __glewProgramVertexLimitNV;

extern __declspec(dllimport) PFNGLMULTICASTBARRIERNVPROC __glewMulticastBarrierNV;
extern __declspec(dllimport) PFNGLMULTICASTBLITFRAMEBUFFERNVPROC __glewMulticastBlitFramebufferNV;
extern __declspec(dllimport) PFNGLMULTICASTBUFFERSUBDATANVPROC __glewMulticastBufferSubDataNV;
extern __declspec(dllimport) PFNGLMULTICASTCOPYBUFFERSUBDATANVPROC __glewMulticastCopyBufferSubDataNV;
extern __declspec(dllimport) PFNGLMULTICASTCOPYIMAGESUBDATANVPROC __glewMulticastCopyImageSubDataNV;
extern __declspec(dllimport) PFNGLMULTICASTFRAMEBUFFERSAMPLELOCATIONSFVNVPROC __glewMulticastFramebufferSampleLocationsfvNV;
extern __declspec(dllimport) PFNGLMULTICASTGETQUERYOBJECTI64VNVPROC __glewMulticastGetQueryObjecti64vNV;
extern __declspec(dllimport) PFNGLMULTICASTGETQUERYOBJECTIVNVPROC __glewMulticastGetQueryObjectivNV;
extern __declspec(dllimport) PFNGLMULTICASTGETQUERYOBJECTUI64VNVPROC __glewMulticastGetQueryObjectui64vNV;
extern __declspec(dllimport) PFNGLMULTICASTGETQUERYOBJECTUIVNVPROC __glewMulticastGetQueryObjectuivNV;
extern __declspec(dllimport) PFNGLMULTICASTWAITSYNCNVPROC __glewMulticastWaitSyncNV;
extern __declspec(dllimport) PFNGLRENDERGPUMASKNVPROC __glewRenderGpuMaskNV;

extern __declspec(dllimport) PFNGLPROGRAMENVPARAMETERI4INVPROC __glewProgramEnvParameterI4iNV;
extern __declspec(dllimport) PFNGLPROGRAMENVPARAMETERI4IVNVPROC __glewProgramEnvParameterI4ivNV;
extern __declspec(dllimport) PFNGLPROGRAMENVPARAMETERI4UINVPROC __glewProgramEnvParameterI4uiNV;
extern __declspec(dllimport) PFNGLPROGRAMENVPARAMETERI4UIVNVPROC __glewProgramEnvParameterI4uivNV;
extern __declspec(dllimport) PFNGLPROGRAMENVPARAMETERSI4IVNVPROC __glewProgramEnvParametersI4ivNV;
extern __declspec(dllimport) PFNGLPROGRAMENVPARAMETERSI4UIVNVPROC __glewProgramEnvParametersI4uivNV;
extern __declspec(dllimport) PFNGLPROGRAMLOCALPARAMETERI4INVPROC __glewProgramLocalParameterI4iNV;
extern __declspec(dllimport) PFNGLPROGRAMLOCALPARAMETERI4IVNVPROC __glewProgramLocalParameterI4ivNV;
extern __declspec(dllimport) PFNGLPROGRAMLOCALPARAMETERI4UINVPROC __glewProgramLocalParameterI4uiNV;
extern __declspec(dllimport) PFNGLPROGRAMLOCALPARAMETERI4UIVNVPROC __glewProgramLocalParameterI4uivNV;
extern __declspec(dllimport) PFNGLPROGRAMLOCALPARAMETERSI4IVNVPROC __glewProgramLocalParametersI4ivNV;
extern __declspec(dllimport) PFNGLPROGRAMLOCALPARAMETERSI4UIVNVPROC __glewProgramLocalParametersI4uivNV;

extern __declspec(dllimport) PFNGLGETUNIFORMI64VNVPROC __glewGetUniformi64vNV;
extern __declspec(dllimport) PFNGLGETUNIFORMUI64VNVPROC __glewGetUniformui64vNV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1I64NVPROC __glewProgramUniform1i64NV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1I64VNVPROC __glewProgramUniform1i64vNV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1UI64NVPROC __glewProgramUniform1ui64NV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1UI64VNVPROC __glewProgramUniform1ui64vNV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2I64NVPROC __glewProgramUniform2i64NV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2I64VNVPROC __glewProgramUniform2i64vNV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2UI64NVPROC __glewProgramUniform2ui64NV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2UI64VNVPROC __glewProgramUniform2ui64vNV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3I64NVPROC __glewProgramUniform3i64NV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3I64VNVPROC __glewProgramUniform3i64vNV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3UI64NVPROC __glewProgramUniform3ui64NV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3UI64VNVPROC __glewProgramUniform3ui64vNV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4I64NVPROC __glewProgramUniform4i64NV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4I64VNVPROC __glewProgramUniform4i64vNV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4UI64NVPROC __glewProgramUniform4ui64NV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4UI64VNVPROC __glewProgramUniform4ui64vNV;
extern __declspec(dllimport) PFNGLUNIFORM1I64NVPROC __glewUniform1i64NV;
extern __declspec(dllimport) PFNGLUNIFORM1I64VNVPROC __glewUniform1i64vNV;
extern __declspec(dllimport) PFNGLUNIFORM1UI64NVPROC __glewUniform1ui64NV;
extern __declspec(dllimport) PFNGLUNIFORM1UI64VNVPROC __glewUniform1ui64vNV;
extern __declspec(dllimport) PFNGLUNIFORM2I64NVPROC __glewUniform2i64NV;
extern __declspec(dllimport) PFNGLUNIFORM2I64VNVPROC __glewUniform2i64vNV;
extern __declspec(dllimport) PFNGLUNIFORM2UI64NVPROC __glewUniform2ui64NV;
extern __declspec(dllimport) PFNGLUNIFORM2UI64VNVPROC __glewUniform2ui64vNV;
extern __declspec(dllimport) PFNGLUNIFORM3I64NVPROC __glewUniform3i64NV;
extern __declspec(dllimport) PFNGLUNIFORM3I64VNVPROC __glewUniform3i64vNV;
extern __declspec(dllimport) PFNGLUNIFORM3UI64NVPROC __glewUniform3ui64NV;
extern __declspec(dllimport) PFNGLUNIFORM3UI64VNVPROC __glewUniform3ui64vNV;
extern __declspec(dllimport) PFNGLUNIFORM4I64NVPROC __glewUniform4i64NV;
extern __declspec(dllimport) PFNGLUNIFORM4I64VNVPROC __glewUniform4i64vNV;
extern __declspec(dllimport) PFNGLUNIFORM4UI64NVPROC __glewUniform4ui64NV;
extern __declspec(dllimport) PFNGLUNIFORM4UI64VNVPROC __glewUniform4ui64vNV;

extern __declspec(dllimport) PFNGLCOLOR3HNVPROC __glewColor3hNV;
extern __declspec(dllimport) PFNGLCOLOR3HVNVPROC __glewColor3hvNV;
extern __declspec(dllimport) PFNGLCOLOR4HNVPROC __glewColor4hNV;
extern __declspec(dllimport) PFNGLCOLOR4HVNVPROC __glewColor4hvNV;
extern __declspec(dllimport) PFNGLFOGCOORDHNVPROC __glewFogCoordhNV;
extern __declspec(dllimport) PFNGLFOGCOORDHVNVPROC __glewFogCoordhvNV;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1HNVPROC __glewMultiTexCoord1hNV;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1HVNVPROC __glewMultiTexCoord1hvNV;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2HNVPROC __glewMultiTexCoord2hNV;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2HVNVPROC __glewMultiTexCoord2hvNV;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3HNVPROC __glewMultiTexCoord3hNV;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3HVNVPROC __glewMultiTexCoord3hvNV;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4HNVPROC __glewMultiTexCoord4hNV;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4HVNVPROC __glewMultiTexCoord4hvNV;
extern __declspec(dllimport) PFNGLNORMAL3HNVPROC __glewNormal3hNV;
extern __declspec(dllimport) PFNGLNORMAL3HVNVPROC __glewNormal3hvNV;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3HNVPROC __glewSecondaryColor3hNV;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3HVNVPROC __glewSecondaryColor3hvNV;
extern __declspec(dllimport) PFNGLTEXCOORD1HNVPROC __glewTexCoord1hNV;
extern __declspec(dllimport) PFNGLTEXCOORD1HVNVPROC __glewTexCoord1hvNV;
extern __declspec(dllimport) PFNGLTEXCOORD2HNVPROC __glewTexCoord2hNV;
extern __declspec(dllimport) PFNGLTEXCOORD2HVNVPROC __glewTexCoord2hvNV;
extern __declspec(dllimport) PFNGLTEXCOORD3HNVPROC __glewTexCoord3hNV;
extern __declspec(dllimport) PFNGLTEXCOORD3HVNVPROC __glewTexCoord3hvNV;
extern __declspec(dllimport) PFNGLTEXCOORD4HNVPROC __glewTexCoord4hNV;
extern __declspec(dllimport) PFNGLTEXCOORD4HVNVPROC __glewTexCoord4hvNV;
extern __declspec(dllimport) PFNGLVERTEX2HNVPROC __glewVertex2hNV;
extern __declspec(dllimport) PFNGLVERTEX2HVNVPROC __glewVertex2hvNV;
extern __declspec(dllimport) PFNGLVERTEX3HNVPROC __glewVertex3hNV;
extern __declspec(dllimport) PFNGLVERTEX3HVNVPROC __glewVertex3hvNV;
extern __declspec(dllimport) PFNGLVERTEX4HNVPROC __glewVertex4hNV;
extern __declspec(dllimport) PFNGLVERTEX4HVNVPROC __glewVertex4hvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1HNVPROC __glewVertexAttrib1hNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1HVNVPROC __glewVertexAttrib1hvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2HNVPROC __glewVertexAttrib2hNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2HVNVPROC __glewVertexAttrib2hvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3HNVPROC __glewVertexAttrib3hNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3HVNVPROC __glewVertexAttrib3hvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4HNVPROC __glewVertexAttrib4hNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4HVNVPROC __glewVertexAttrib4hvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS1HVNVPROC __glewVertexAttribs1hvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS2HVNVPROC __glewVertexAttribs2hvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS3HVNVPROC __glewVertexAttribs3hvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS4HVNVPROC __glewVertexAttribs4hvNV;
extern __declspec(dllimport) PFNGLVERTEXWEIGHTHNVPROC __glewVertexWeighthNV;
extern __declspec(dllimport) PFNGLVERTEXWEIGHTHVNVPROC __glewVertexWeighthvNV;

extern __declspec(dllimport) PFNGLVERTEXATTRIBDIVISORNVPROC __glewVertexAttribDivisorNV;

extern __declspec(dllimport) PFNGLGETINTERNALFORMATSAMPLEIVNVPROC __glewGetInternalformatSampleivNV;

extern __declspec(dllimport) PFNGLUNIFORMMATRIX2X3FVNVPROC __glewUniformMatrix2x3fvNV;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX2X4FVNVPROC __glewUniformMatrix2x4fvNV;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX3X2FVNVPROC __glewUniformMatrix3x2fvNV;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX3X4FVNVPROC __glewUniformMatrix3x4fvNV;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX4X2FVNVPROC __glewUniformMatrix4x2fvNV;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX4X3FVNVPROC __glewUniformMatrix4x3fvNV;

extern __declspec(dllimport) PFNGLBEGINOCCLUSIONQUERYNVPROC __glewBeginOcclusionQueryNV;
extern __declspec(dllimport) PFNGLDELETEOCCLUSIONQUERIESNVPROC __glewDeleteOcclusionQueriesNV;
extern __declspec(dllimport) PFNGLENDOCCLUSIONQUERYNVPROC __glewEndOcclusionQueryNV;
extern __declspec(dllimport) PFNGLGENOCCLUSIONQUERIESNVPROC __glewGenOcclusionQueriesNV;
extern __declspec(dllimport) PFNGLGETOCCLUSIONQUERYIVNVPROC __glewGetOcclusionQueryivNV;
extern __declspec(dllimport) PFNGLGETOCCLUSIONQUERYUIVNVPROC __glewGetOcclusionQueryuivNV;
extern __declspec(dllimport) PFNGLISOCCLUSIONQUERYNVPROC __glewIsOcclusionQueryNV;

extern __declspec(dllimport) PFNGLPROGRAMBUFFERPARAMETERSIIVNVPROC __glewProgramBufferParametersIivNV;
extern __declspec(dllimport) PFNGLPROGRAMBUFFERPARAMETERSIUIVNVPROC __glewProgramBufferParametersIuivNV;
extern __declspec(dllimport) PFNGLPROGRAMBUFFERPARAMETERSFVNVPROC __glewProgramBufferParametersfvNV;

extern __declspec(dllimport) PFNGLCOPYPATHNVPROC __glewCopyPathNV;
extern __declspec(dllimport) PFNGLCOVERFILLPATHINSTANCEDNVPROC __glewCoverFillPathInstancedNV;
extern __declspec(dllimport) PFNGLCOVERFILLPATHNVPROC __glewCoverFillPathNV;
extern __declspec(dllimport) PFNGLCOVERSTROKEPATHINSTANCEDNVPROC __glewCoverStrokePathInstancedNV;
extern __declspec(dllimport) PFNGLCOVERSTROKEPATHNVPROC __glewCoverStrokePathNV;
extern __declspec(dllimport) PFNGLDELETEPATHSNVPROC __glewDeletePathsNV;
extern __declspec(dllimport) PFNGLGENPATHSNVPROC __glewGenPathsNV;
extern __declspec(dllimport) PFNGLGETPATHCOLORGENFVNVPROC __glewGetPathColorGenfvNV;
extern __declspec(dllimport) PFNGLGETPATHCOLORGENIVNVPROC __glewGetPathColorGenivNV;
extern __declspec(dllimport) PFNGLGETPATHCOMMANDSNVPROC __glewGetPathCommandsNV;
extern __declspec(dllimport) PFNGLGETPATHCOORDSNVPROC __glewGetPathCoordsNV;
extern __declspec(dllimport) PFNGLGETPATHDASHARRAYNVPROC __glewGetPathDashArrayNV;
extern __declspec(dllimport) PFNGLGETPATHLENGTHNVPROC __glewGetPathLengthNV;
extern __declspec(dllimport) PFNGLGETPATHMETRICRANGENVPROC __glewGetPathMetricRangeNV;
extern __declspec(dllimport) PFNGLGETPATHMETRICSNVPROC __glewGetPathMetricsNV;
extern __declspec(dllimport) PFNGLGETPATHPARAMETERFVNVPROC __glewGetPathParameterfvNV;
extern __declspec(dllimport) PFNGLGETPATHPARAMETERIVNVPROC __glewGetPathParameterivNV;
extern __declspec(dllimport) PFNGLGETPATHSPACINGNVPROC __glewGetPathSpacingNV;
extern __declspec(dllimport) PFNGLGETPATHTEXGENFVNVPROC __glewGetPathTexGenfvNV;
extern __declspec(dllimport) PFNGLGETPATHTEXGENIVNVPROC __glewGetPathTexGenivNV;
extern __declspec(dllimport) PFNGLGETPROGRAMRESOURCEFVNVPROC __glewGetProgramResourcefvNV;
extern __declspec(dllimport) PFNGLINTERPOLATEPATHSNVPROC __glewInterpolatePathsNV;
extern __declspec(dllimport) PFNGLISPATHNVPROC __glewIsPathNV;
extern __declspec(dllimport) PFNGLISPOINTINFILLPATHNVPROC __glewIsPointInFillPathNV;
extern __declspec(dllimport) PFNGLISPOINTINSTROKEPATHNVPROC __glewIsPointInStrokePathNV;
extern __declspec(dllimport) PFNGLMATRIXLOAD3X2FNVPROC __glewMatrixLoad3x2fNV;
extern __declspec(dllimport) PFNGLMATRIXLOAD3X3FNVPROC __glewMatrixLoad3x3fNV;
extern __declspec(dllimport) PFNGLMATRIXLOADTRANSPOSE3X3FNVPROC __glewMatrixLoadTranspose3x3fNV;
extern __declspec(dllimport) PFNGLMATRIXMULT3X2FNVPROC __glewMatrixMult3x2fNV;
extern __declspec(dllimport) PFNGLMATRIXMULT3X3FNVPROC __glewMatrixMult3x3fNV;
extern __declspec(dllimport) PFNGLMATRIXMULTTRANSPOSE3X3FNVPROC __glewMatrixMultTranspose3x3fNV;
extern __declspec(dllimport) PFNGLPATHCOLORGENNVPROC __glewPathColorGenNV;
extern __declspec(dllimport) PFNGLPATHCOMMANDSNVPROC __glewPathCommandsNV;
extern __declspec(dllimport) PFNGLPATHCOORDSNVPROC __glewPathCoordsNV;
extern __declspec(dllimport) PFNGLPATHCOVERDEPTHFUNCNVPROC __glewPathCoverDepthFuncNV;
extern __declspec(dllimport) PFNGLPATHDASHARRAYNVPROC __glewPathDashArrayNV;
extern __declspec(dllimport) PFNGLPATHFOGGENNVPROC __glewPathFogGenNV;
extern __declspec(dllimport) PFNGLPATHGLYPHINDEXARRAYNVPROC __glewPathGlyphIndexArrayNV;
extern __declspec(dllimport) PFNGLPATHGLYPHINDEXRANGENVPROC __glewPathGlyphIndexRangeNV;
extern __declspec(dllimport) PFNGLPATHGLYPHRANGENVPROC __glewPathGlyphRangeNV;
extern __declspec(dllimport) PFNGLPATHGLYPHSNVPROC __glewPathGlyphsNV;
extern __declspec(dllimport) PFNGLPATHMEMORYGLYPHINDEXARRAYNVPROC __glewPathMemoryGlyphIndexArrayNV;
extern __declspec(dllimport) PFNGLPATHPARAMETERFNVPROC __glewPathParameterfNV;
extern __declspec(dllimport) PFNGLPATHPARAMETERFVNVPROC __glewPathParameterfvNV;
extern __declspec(dllimport) PFNGLPATHPARAMETERINVPROC __glewPathParameteriNV;
extern __declspec(dllimport) PFNGLPATHPARAMETERIVNVPROC __glewPathParameterivNV;
extern __declspec(dllimport) PFNGLPATHSTENCILDEPTHOFFSETNVPROC __glewPathStencilDepthOffsetNV;
extern __declspec(dllimport) PFNGLPATHSTENCILFUNCNVPROC __glewPathStencilFuncNV;
extern __declspec(dllimport) PFNGLPATHSTRINGNVPROC __glewPathStringNV;
extern __declspec(dllimport) PFNGLPATHSUBCOMMANDSNVPROC __glewPathSubCommandsNV;
extern __declspec(dllimport) PFNGLPATHSUBCOORDSNVPROC __glewPathSubCoordsNV;
extern __declspec(dllimport) PFNGLPATHTEXGENNVPROC __glewPathTexGenNV;
extern __declspec(dllimport) PFNGLPOINTALONGPATHNVPROC __glewPointAlongPathNV;
extern __declspec(dllimport) PFNGLPROGRAMPATHFRAGMENTINPUTGENNVPROC __glewProgramPathFragmentInputGenNV;
extern __declspec(dllimport) PFNGLSTENCILFILLPATHINSTANCEDNVPROC __glewStencilFillPathInstancedNV;
extern __declspec(dllimport) PFNGLSTENCILFILLPATHNVPROC __glewStencilFillPathNV;
extern __declspec(dllimport) PFNGLSTENCILSTROKEPATHINSTANCEDNVPROC __glewStencilStrokePathInstancedNV;
extern __declspec(dllimport) PFNGLSTENCILSTROKEPATHNVPROC __glewStencilStrokePathNV;
extern __declspec(dllimport) PFNGLSTENCILTHENCOVERFILLPATHINSTANCEDNVPROC __glewStencilThenCoverFillPathInstancedNV;
extern __declspec(dllimport) PFNGLSTENCILTHENCOVERFILLPATHNVPROC __glewStencilThenCoverFillPathNV;
extern __declspec(dllimport) PFNGLSTENCILTHENCOVERSTROKEPATHINSTANCEDNVPROC __glewStencilThenCoverStrokePathInstancedNV;
extern __declspec(dllimport) PFNGLSTENCILTHENCOVERSTROKEPATHNVPROC __glewStencilThenCoverStrokePathNV;
extern __declspec(dllimport) PFNGLTRANSFORMPATHNVPROC __glewTransformPathNV;
extern __declspec(dllimport) PFNGLWEIGHTPATHSNVPROC __glewWeightPathsNV;

extern __declspec(dllimport) PFNGLFLUSHPIXELDATARANGENVPROC __glewFlushPixelDataRangeNV;
extern __declspec(dllimport) PFNGLPIXELDATARANGENVPROC __glewPixelDataRangeNV;

extern __declspec(dllimport) PFNGLPOINTPARAMETERINVPROC __glewPointParameteriNV;
extern __declspec(dllimport) PFNGLPOINTPARAMETERIVNVPROC __glewPointParameterivNV;

extern __declspec(dllimport) PFNGLPOLYGONMODENVPROC __glewPolygonModeNV;

extern __declspec(dllimport) PFNGLGETVIDEOI64VNVPROC __glewGetVideoi64vNV;
extern __declspec(dllimport) PFNGLGETVIDEOIVNVPROC __glewGetVideoivNV;
extern __declspec(dllimport) PFNGLGETVIDEOUI64VNVPROC __glewGetVideoui64vNV;
extern __declspec(dllimport) PFNGLGETVIDEOUIVNVPROC __glewGetVideouivNV;
extern __declspec(dllimport) PFNGLPRESENTFRAMEDUALFILLNVPROC __glewPresentFrameDualFillNV;
extern __declspec(dllimport) PFNGLPRESENTFRAMEKEYEDNVPROC __glewPresentFrameKeyedNV;

extern __declspec(dllimport) PFNGLPRIMITIVERESTARTINDEXNVPROC __glewPrimitiveRestartIndexNV;
extern __declspec(dllimport) PFNGLPRIMITIVERESTARTNVPROC __glewPrimitiveRestartNV;

extern __declspec(dllimport) PFNGLCOMBINERINPUTNVPROC __glewCombinerInputNV;
extern __declspec(dllimport) PFNGLCOMBINEROUTPUTNVPROC __glewCombinerOutputNV;
extern __declspec(dllimport) PFNGLCOMBINERPARAMETERFNVPROC __glewCombinerParameterfNV;
extern __declspec(dllimport) PFNGLCOMBINERPARAMETERFVNVPROC __glewCombinerParameterfvNV;
extern __declspec(dllimport) PFNGLCOMBINERPARAMETERINVPROC __glewCombinerParameteriNV;
extern __declspec(dllimport) PFNGLCOMBINERPARAMETERIVNVPROC __glewCombinerParameterivNV;
extern __declspec(dllimport) PFNGLFINALCOMBINERINPUTNVPROC __glewFinalCombinerInputNV;
extern __declspec(dllimport) PFNGLGETCOMBINERINPUTPARAMETERFVNVPROC __glewGetCombinerInputParameterfvNV;
extern __declspec(dllimport) PFNGLGETCOMBINERINPUTPARAMETERIVNVPROC __glewGetCombinerInputParameterivNV;
extern __declspec(dllimport) PFNGLGETCOMBINEROUTPUTPARAMETERFVNVPROC __glewGetCombinerOutputParameterfvNV;
extern __declspec(dllimport) PFNGLGETCOMBINEROUTPUTPARAMETERIVNVPROC __glewGetCombinerOutputParameterivNV;
extern __declspec(dllimport) PFNGLGETFINALCOMBINERINPUTPARAMETERFVNVPROC __glewGetFinalCombinerInputParameterfvNV;
extern __declspec(dllimport) PFNGLGETFINALCOMBINERINPUTPARAMETERIVNVPROC __glewGetFinalCombinerInputParameterivNV;

extern __declspec(dllimport) PFNGLCOMBINERSTAGEPARAMETERFVNVPROC __glewCombinerStageParameterfvNV;
extern __declspec(dllimport) PFNGLGETCOMBINERSTAGEPARAMETERFVNVPROC __glewGetCombinerStageParameterfvNV;

extern __declspec(dllimport) PFNGLFRAMEBUFFERSAMPLELOCATIONSFVNVPROC __glewFramebufferSampleLocationsfvNV;
extern __declspec(dllimport) PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVNVPROC __glewNamedFramebufferSampleLocationsfvNV;

extern __declspec(dllimport) PFNGLGETBUFFERPARAMETERUI64VNVPROC __glewGetBufferParameterui64vNV;
extern __declspec(dllimport) PFNGLGETINTEGERUI64VNVPROC __glewGetIntegerui64vNV;
extern __declspec(dllimport) PFNGLGETNAMEDBUFFERPARAMETERUI64VNVPROC __glewGetNamedBufferParameterui64vNV;
extern __declspec(dllimport) PFNGLISBUFFERRESIDENTNVPROC __glewIsBufferResidentNV;
extern __declspec(dllimport) PFNGLISNAMEDBUFFERRESIDENTNVPROC __glewIsNamedBufferResidentNV;
extern __declspec(dllimport) PFNGLMAKEBUFFERNONRESIDENTNVPROC __glewMakeBufferNonResidentNV;
extern __declspec(dllimport) PFNGLMAKEBUFFERRESIDENTNVPROC __glewMakeBufferResidentNV;
extern __declspec(dllimport) PFNGLMAKENAMEDBUFFERNONRESIDENTNVPROC __glewMakeNamedBufferNonResidentNV;
extern __declspec(dllimport) PFNGLMAKENAMEDBUFFERRESIDENTNVPROC __glewMakeNamedBufferResidentNV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMUI64NVPROC __glewProgramUniformui64NV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMUI64VNVPROC __glewProgramUniformui64vNV;
extern __declspec(dllimport) PFNGLUNIFORMUI64NVPROC __glewUniformui64NV;
extern __declspec(dllimport) PFNGLUNIFORMUI64VNVPROC __glewUniformui64vNV;

extern __declspec(dllimport) PFNGLCOMPRESSEDTEXIMAGE3DNVPROC __glewCompressedTexImage3DNV;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXSUBIMAGE3DNVPROC __glewCompressedTexSubImage3DNV;
extern __declspec(dllimport) PFNGLCOPYTEXSUBIMAGE3DNVPROC __glewCopyTexSubImage3DNV;
extern __declspec(dllimport) PFNGLFRAMEBUFFERTEXTURELAYERNVPROC __glewFramebufferTextureLayerNV;
extern __declspec(dllimport) PFNGLTEXIMAGE3DNVPROC __glewTexImage3DNV;
extern __declspec(dllimport) PFNGLTEXSUBIMAGE3DNVPROC __glewTexSubImage3DNV;

extern __declspec(dllimport) PFNGLTEXTUREBARRIERNVPROC __glewTextureBarrierNV;

extern __declspec(dllimport) PFNGLTEXIMAGE2DMULTISAMPLECOVERAGENVPROC __glewTexImage2DMultisampleCoverageNV;
extern __declspec(dllimport) PFNGLTEXIMAGE3DMULTISAMPLECOVERAGENVPROC __glewTexImage3DMultisampleCoverageNV;
extern __declspec(dllimport) PFNGLTEXTUREIMAGE2DMULTISAMPLECOVERAGENVPROC __glewTextureImage2DMultisampleCoverageNV;
extern __declspec(dllimport) PFNGLTEXTUREIMAGE2DMULTISAMPLENVPROC __glewTextureImage2DMultisampleNV;
extern __declspec(dllimport) PFNGLTEXTUREIMAGE3DMULTISAMPLECOVERAGENVPROC __glewTextureImage3DMultisampleCoverageNV;
extern __declspec(dllimport) PFNGLTEXTUREIMAGE3DMULTISAMPLENVPROC __glewTextureImage3DMultisampleNV;

extern __declspec(dllimport) PFNGLACTIVEVARYINGNVPROC __glewActiveVaryingNV;
extern __declspec(dllimport) PFNGLBEGINTRANSFORMFEEDBACKNVPROC __glewBeginTransformFeedbackNV;
extern __declspec(dllimport) PFNGLBINDBUFFERBASENVPROC __glewBindBufferBaseNV;
extern __declspec(dllimport) PFNGLBINDBUFFEROFFSETNVPROC __glewBindBufferOffsetNV;
extern __declspec(dllimport) PFNGLBINDBUFFERRANGENVPROC __glewBindBufferRangeNV;
extern __declspec(dllimport) PFNGLENDTRANSFORMFEEDBACKNVPROC __glewEndTransformFeedbackNV;
extern __declspec(dllimport) PFNGLGETACTIVEVARYINGNVPROC __glewGetActiveVaryingNV;
extern __declspec(dllimport) PFNGLGETTRANSFORMFEEDBACKVARYINGNVPROC __glewGetTransformFeedbackVaryingNV;
extern __declspec(dllimport) PFNGLGETVARYINGLOCATIONNVPROC __glewGetVaryingLocationNV;
extern __declspec(dllimport) PFNGLTRANSFORMFEEDBACKATTRIBSNVPROC __glewTransformFeedbackAttribsNV;
extern __declspec(dllimport) PFNGLTRANSFORMFEEDBACKVARYINGSNVPROC __glewTransformFeedbackVaryingsNV;

extern __declspec(dllimport) PFNGLBINDTRANSFORMFEEDBACKNVPROC __glewBindTransformFeedbackNV;
extern __declspec(dllimport) PFNGLDELETETRANSFORMFEEDBACKSNVPROC __glewDeleteTransformFeedbacksNV;
extern __declspec(dllimport) PFNGLDRAWTRANSFORMFEEDBACKNVPROC __glewDrawTransformFeedbackNV;
extern __declspec(dllimport) PFNGLGENTRANSFORMFEEDBACKSNVPROC __glewGenTransformFeedbacksNV;
extern __declspec(dllimport) PFNGLISTRANSFORMFEEDBACKNVPROC __glewIsTransformFeedbackNV;
extern __declspec(dllimport) PFNGLPAUSETRANSFORMFEEDBACKNVPROC __glewPauseTransformFeedbackNV;
extern __declspec(dllimport) PFNGLRESUMETRANSFORMFEEDBACKNVPROC __glewResumeTransformFeedbackNV;

extern __declspec(dllimport) PFNGLVDPAUFININVPROC __glewVDPAUFiniNV;
extern __declspec(dllimport) PFNGLVDPAUGETSURFACEIVNVPROC __glewVDPAUGetSurfaceivNV;
extern __declspec(dllimport) PFNGLVDPAUINITNVPROC __glewVDPAUInitNV;
extern __declspec(dllimport) PFNGLVDPAUISSURFACENVPROC __glewVDPAUIsSurfaceNV;
extern __declspec(dllimport) PFNGLVDPAUMAPSURFACESNVPROC __glewVDPAUMapSurfacesNV;
extern __declspec(dllimport) PFNGLVDPAUREGISTEROUTPUTSURFACENVPROC __glewVDPAURegisterOutputSurfaceNV;
extern __declspec(dllimport) PFNGLVDPAUREGISTERVIDEOSURFACENVPROC __glewVDPAURegisterVideoSurfaceNV;
extern __declspec(dllimport) PFNGLVDPAUSURFACEACCESSNVPROC __glewVDPAUSurfaceAccessNV;
extern __declspec(dllimport) PFNGLVDPAUUNMAPSURFACESNVPROC __glewVDPAUUnmapSurfacesNV;
extern __declspec(dllimport) PFNGLVDPAUUNREGISTERSURFACENVPROC __glewVDPAUUnregisterSurfaceNV;

extern __declspec(dllimport) PFNGLFLUSHVERTEXARRAYRANGENVPROC __glewFlushVertexArrayRangeNV;
extern __declspec(dllimport) PFNGLVERTEXARRAYRANGENVPROC __glewVertexArrayRangeNV;

extern __declspec(dllimport) PFNGLGETVERTEXATTRIBLI64VNVPROC __glewGetVertexAttribLi64vNV;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBLUI64VNVPROC __glewGetVertexAttribLui64vNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL1I64NVPROC __glewVertexAttribL1i64NV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL1I64VNVPROC __glewVertexAttribL1i64vNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL1UI64NVPROC __glewVertexAttribL1ui64NV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL1UI64VNVPROC __glewVertexAttribL1ui64vNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL2I64NVPROC __glewVertexAttribL2i64NV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL2I64VNVPROC __glewVertexAttribL2i64vNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL2UI64NVPROC __glewVertexAttribL2ui64NV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL2UI64VNVPROC __glewVertexAttribL2ui64vNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL3I64NVPROC __glewVertexAttribL3i64NV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL3I64VNVPROC __glewVertexAttribL3i64vNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL3UI64NVPROC __glewVertexAttribL3ui64NV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL3UI64VNVPROC __glewVertexAttribL3ui64vNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL4I64NVPROC __glewVertexAttribL4i64NV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL4I64VNVPROC __glewVertexAttribL4i64vNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL4UI64NVPROC __glewVertexAttribL4ui64NV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL4UI64VNVPROC __glewVertexAttribL4ui64vNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBLFORMATNVPROC __glewVertexAttribLFormatNV;

extern __declspec(dllimport) PFNGLBUFFERADDRESSRANGENVPROC __glewBufferAddressRangeNV;
extern __declspec(dllimport) PFNGLCOLORFORMATNVPROC __glewColorFormatNV;
extern __declspec(dllimport) PFNGLEDGEFLAGFORMATNVPROC __glewEdgeFlagFormatNV;
extern __declspec(dllimport) PFNGLFOGCOORDFORMATNVPROC __glewFogCoordFormatNV;
extern __declspec(dllimport) PFNGLGETINTEGERUI64I_VNVPROC __glewGetIntegerui64i_vNV;
extern __declspec(dllimport) PFNGLINDEXFORMATNVPROC __glewIndexFormatNV;
extern __declspec(dllimport) PFNGLNORMALFORMATNVPROC __glewNormalFormatNV;
extern __declspec(dllimport) PFNGLSECONDARYCOLORFORMATNVPROC __glewSecondaryColorFormatNV;
extern __declspec(dllimport) PFNGLTEXCOORDFORMATNVPROC __glewTexCoordFormatNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBFORMATNVPROC __glewVertexAttribFormatNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBIFORMATNVPROC __glewVertexAttribIFormatNV;
extern __declspec(dllimport) PFNGLVERTEXFORMATNVPROC __glewVertexFormatNV;

extern __declspec(dllimport) PFNGLAREPROGRAMSRESIDENTNVPROC __glewAreProgramsResidentNV;
extern __declspec(dllimport) PFNGLBINDPROGRAMNVPROC __glewBindProgramNV;
extern __declspec(dllimport) PFNGLDELETEPROGRAMSNVPROC __glewDeleteProgramsNV;
extern __declspec(dllimport) PFNGLEXECUTEPROGRAMNVPROC __glewExecuteProgramNV;
extern __declspec(dllimport) PFNGLGENPROGRAMSNVPROC __glewGenProgramsNV;
extern __declspec(dllimport) PFNGLGETPROGRAMPARAMETERDVNVPROC __glewGetProgramParameterdvNV;
extern __declspec(dllimport) PFNGLGETPROGRAMPARAMETERFVNVPROC __glewGetProgramParameterfvNV;
extern __declspec(dllimport) PFNGLGETPROGRAMSTRINGNVPROC __glewGetProgramStringNV;
extern __declspec(dllimport) PFNGLGETPROGRAMIVNVPROC __glewGetProgramivNV;
extern __declspec(dllimport) PFNGLGETTRACKMATRIXIVNVPROC __glewGetTrackMatrixivNV;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBPOINTERVNVPROC __glewGetVertexAttribPointervNV;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBDVNVPROC __glewGetVertexAttribdvNV;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBFVNVPROC __glewGetVertexAttribfvNV;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBIVNVPROC __glewGetVertexAttribivNV;
extern __declspec(dllimport) PFNGLISPROGRAMNVPROC __glewIsProgramNV;
extern __declspec(dllimport) PFNGLLOADPROGRAMNVPROC __glewLoadProgramNV;
extern __declspec(dllimport) PFNGLPROGRAMPARAMETER4DNVPROC __glewProgramParameter4dNV;
extern __declspec(dllimport) PFNGLPROGRAMPARAMETER4DVNVPROC __glewProgramParameter4dvNV;
extern __declspec(dllimport) PFNGLPROGRAMPARAMETER4FNVPROC __glewProgramParameter4fNV;
extern __declspec(dllimport) PFNGLPROGRAMPARAMETER4FVNVPROC __glewProgramParameter4fvNV;
extern __declspec(dllimport) PFNGLPROGRAMPARAMETERS4DVNVPROC __glewProgramParameters4dvNV;
extern __declspec(dllimport) PFNGLPROGRAMPARAMETERS4FVNVPROC __glewProgramParameters4fvNV;
extern __declspec(dllimport) PFNGLREQUESTRESIDENTPROGRAMSNVPROC __glewRequestResidentProgramsNV;
extern __declspec(dllimport) PFNGLTRACKMATRIXNVPROC __glewTrackMatrixNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1DNVPROC __glewVertexAttrib1dNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1DVNVPROC __glewVertexAttrib1dvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1FNVPROC __glewVertexAttrib1fNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1FVNVPROC __glewVertexAttrib1fvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1SNVPROC __glewVertexAttrib1sNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1SVNVPROC __glewVertexAttrib1svNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2DNVPROC __glewVertexAttrib2dNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2DVNVPROC __glewVertexAttrib2dvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2FNVPROC __glewVertexAttrib2fNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2FVNVPROC __glewVertexAttrib2fvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2SNVPROC __glewVertexAttrib2sNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2SVNVPROC __glewVertexAttrib2svNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3DNVPROC __glewVertexAttrib3dNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3DVNVPROC __glewVertexAttrib3dvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3FNVPROC __glewVertexAttrib3fNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3FVNVPROC __glewVertexAttrib3fvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3SNVPROC __glewVertexAttrib3sNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3SVNVPROC __glewVertexAttrib3svNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4DNVPROC __glewVertexAttrib4dNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4DVNVPROC __glewVertexAttrib4dvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4FNVPROC __glewVertexAttrib4fNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4FVNVPROC __glewVertexAttrib4fvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4SNVPROC __glewVertexAttrib4sNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4SVNVPROC __glewVertexAttrib4svNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4UBNVPROC __glewVertexAttrib4ubNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4UBVNVPROC __glewVertexAttrib4ubvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBPOINTERNVPROC __glewVertexAttribPointerNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS1DVNVPROC __glewVertexAttribs1dvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS1FVNVPROC __glewVertexAttribs1fvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS1SVNVPROC __glewVertexAttribs1svNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS2DVNVPROC __glewVertexAttribs2dvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS2FVNVPROC __glewVertexAttribs2fvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS2SVNVPROC __glewVertexAttribs2svNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS3DVNVPROC __glewVertexAttribs3dvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS3FVNVPROC __glewVertexAttribs3fvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS3SVNVPROC __glewVertexAttribs3svNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS4DVNVPROC __glewVertexAttribs4dvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS4FVNVPROC __glewVertexAttribs4fvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS4SVNVPROC __glewVertexAttribs4svNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS4UBVNVPROC __glewVertexAttribs4ubvNV;

extern __declspec(dllimport) PFNGLBEGINVIDEOCAPTURENVPROC __glewBeginVideoCaptureNV;
extern __declspec(dllimport) PFNGLBINDVIDEOCAPTURESTREAMBUFFERNVPROC __glewBindVideoCaptureStreamBufferNV;
extern __declspec(dllimport) PFNGLBINDVIDEOCAPTURESTREAMTEXTURENVPROC __glewBindVideoCaptureStreamTextureNV;
extern __declspec(dllimport) PFNGLENDVIDEOCAPTURENVPROC __glewEndVideoCaptureNV;
extern __declspec(dllimport) PFNGLGETVIDEOCAPTURESTREAMDVNVPROC __glewGetVideoCaptureStreamdvNV;
extern __declspec(dllimport) PFNGLGETVIDEOCAPTURESTREAMFVNVPROC __glewGetVideoCaptureStreamfvNV;
extern __declspec(dllimport) PFNGLGETVIDEOCAPTURESTREAMIVNVPROC __glewGetVideoCaptureStreamivNV;
extern __declspec(dllimport) PFNGLGETVIDEOCAPTUREIVNVPROC __glewGetVideoCaptureivNV;
extern __declspec(dllimport) PFNGLVIDEOCAPTURENVPROC __glewVideoCaptureNV;
extern __declspec(dllimport) PFNGLVIDEOCAPTURESTREAMPARAMETERDVNVPROC __glewVideoCaptureStreamParameterdvNV;
extern __declspec(dllimport) PFNGLVIDEOCAPTURESTREAMPARAMETERFVNVPROC __glewVideoCaptureStreamParameterfvNV;
extern __declspec(dllimport) PFNGLVIDEOCAPTURESTREAMPARAMETERIVNVPROC __glewVideoCaptureStreamParameterivNV;

extern __declspec(dllimport) PFNGLDEPTHRANGEARRAYFVNVPROC __glewDepthRangeArrayfvNV;
extern __declspec(dllimport) PFNGLDEPTHRANGEINDEXEDFNVPROC __glewDepthRangeIndexedfNV;
extern __declspec(dllimport) PFNGLDISABLEINVPROC __glewDisableiNV;
extern __declspec(dllimport) PFNGLENABLEINVPROC __glewEnableiNV;
extern __declspec(dllimport) PFNGLGETFLOATI_VNVPROC __glewGetFloati_vNV;
extern __declspec(dllimport) PFNGLISENABLEDINVPROC __glewIsEnablediNV;
extern __declspec(dllimport) PFNGLSCISSORARRAYVNVPROC __glewScissorArrayvNV;
extern __declspec(dllimport) PFNGLSCISSORINDEXEDNVPROC __glewScissorIndexedNV;
extern __declspec(dllimport) PFNGLSCISSORINDEXEDVNVPROC __glewScissorIndexedvNV;
extern __declspec(dllimport) PFNGLVIEWPORTARRAYVNVPROC __glewViewportArrayvNV;
extern __declspec(dllimport) PFNGLVIEWPORTINDEXEDFNVPROC __glewViewportIndexedfNV;
extern __declspec(dllimport) PFNGLVIEWPORTINDEXEDFVNVPROC __glewViewportIndexedfvNV;

extern __declspec(dllimport) PFNGLVIEWPORTSWIZZLENVPROC __glewViewportSwizzleNV;

extern __declspec(dllimport) PFNGLFRAMEBUFFERTEXTUREMULTIVIEWOVRPROC __glewFramebufferTextureMultiviewOVR;

extern __declspec(dllimport) PFNGLFRAMEBUFFERTEXTUREMULTISAMPLEMULTIVIEWOVRPROC __glewFramebufferTextureMultisampleMultiviewOVR;

extern __declspec(dllimport) PFNGLALPHAFUNCQCOMPROC __glewAlphaFuncQCOM;

extern __declspec(dllimport) PFNGLDISABLEDRIVERCONTROLQCOMPROC __glewDisableDriverControlQCOM;
extern __declspec(dllimport) PFNGLENABLEDRIVERCONTROLQCOMPROC __glewEnableDriverControlQCOM;
extern __declspec(dllimport) PFNGLGETDRIVERCONTROLSTRINGQCOMPROC __glewGetDriverControlStringQCOM;
extern __declspec(dllimport) PFNGLGETDRIVERCONTROLSQCOMPROC __glewGetDriverControlsQCOM;

extern __declspec(dllimport) PFNGLEXTGETBUFFERPOINTERVQCOMPROC __glewExtGetBufferPointervQCOM;
extern __declspec(dllimport) PFNGLEXTGETBUFFERSQCOMPROC __glewExtGetBuffersQCOM;
extern __declspec(dllimport) PFNGLEXTGETFRAMEBUFFERSQCOMPROC __glewExtGetFramebuffersQCOM;
extern __declspec(dllimport) PFNGLEXTGETRENDERBUFFERSQCOMPROC __glewExtGetRenderbuffersQCOM;
extern __declspec(dllimport) PFNGLEXTGETTEXLEVELPARAMETERIVQCOMPROC __glewExtGetTexLevelParameterivQCOM;
extern __declspec(dllimport) PFNGLEXTGETTEXSUBIMAGEQCOMPROC __glewExtGetTexSubImageQCOM;
extern __declspec(dllimport) PFNGLEXTGETTEXTURESQCOMPROC __glewExtGetTexturesQCOM;
extern __declspec(dllimport) PFNGLEXTTEXOBJECTSTATEOVERRIDEIQCOMPROC __glewExtTexObjectStateOverrideiQCOM;

extern __declspec(dllimport) PFNGLEXTGETPROGRAMBINARYSOURCEQCOMPROC __glewExtGetProgramBinarySourceQCOM;
extern __declspec(dllimport) PFNGLEXTGETPROGRAMSQCOMPROC __glewExtGetProgramsQCOM;
extern __declspec(dllimport) PFNGLEXTGETSHADERSQCOMPROC __glewExtGetShadersQCOM;
extern __declspec(dllimport) PFNGLEXTISPROGRAMBINARYQCOMPROC __glewExtIsProgramBinaryQCOM;

extern __declspec(dllimport) PFNGLFRAMEBUFFERFOVEATIONCONFIGQCOMPROC __glewFramebufferFoveationConfigQCOM;
extern __declspec(dllimport) PFNGLFRAMEBUFFERFOVEATIONPARAMETERSQCOMPROC __glewFramebufferFoveationParametersQCOM;

extern __declspec(dllimport) PFNGLFRAMEBUFFERFETCHBARRIERQCOMPROC __glewFramebufferFetchBarrierQCOM;

extern __declspec(dllimport) PFNGLENDTILINGQCOMPROC __glewEndTilingQCOM;
extern __declspec(dllimport) PFNGLSTARTTILINGQCOMPROC __glewStartTilingQCOM;

extern __declspec(dllimport) PFNGLALPHAFUNCXPROC __glewAlphaFuncx;
extern __declspec(dllimport) PFNGLCLEARCOLORXPROC __glewClearColorx;
extern __declspec(dllimport) PFNGLCLEARDEPTHXPROC __glewClearDepthx;
extern __declspec(dllimport) PFNGLCOLOR4XPROC __glewColor4x;
extern __declspec(dllimport) PFNGLDEPTHRANGEXPROC __glewDepthRangex;
extern __declspec(dllimport) PFNGLFOGXPROC __glewFogx;
extern __declspec(dllimport) PFNGLFOGXVPROC __glewFogxv;
extern __declspec(dllimport) PFNGLFRUSTUMFPROC __glewFrustumf;
extern __declspec(dllimport) PFNGLFRUSTUMXPROC __glewFrustumx;
extern __declspec(dllimport) PFNGLLIGHTMODELXPROC __glewLightModelx;
extern __declspec(dllimport) PFNGLLIGHTMODELXVPROC __glewLightModelxv;
extern __declspec(dllimport) PFNGLLIGHTXPROC __glewLightx;
extern __declspec(dllimport) PFNGLLIGHTXVPROC __glewLightxv;
extern __declspec(dllimport) PFNGLLINEWIDTHXPROC __glewLineWidthx;
extern __declspec(dllimport) PFNGLLOADMATRIXXPROC __glewLoadMatrixx;
extern __declspec(dllimport) PFNGLMATERIALXPROC __glewMaterialx;
extern __declspec(dllimport) PFNGLMATERIALXVPROC __glewMaterialxv;
extern __declspec(dllimport) PFNGLMULTMATRIXXPROC __glewMultMatrixx;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4XPROC __glewMultiTexCoord4x;
extern __declspec(dllimport) PFNGLNORMAL3XPROC __glewNormal3x;
extern __declspec(dllimport) PFNGLORTHOFPROC __glewOrthof;
extern __declspec(dllimport) PFNGLORTHOXPROC __glewOrthox;
extern __declspec(dllimport) PFNGLPOINTSIZEXPROC __glewPointSizex;
extern __declspec(dllimport) PFNGLPOLYGONOFFSETXPROC __glewPolygonOffsetx;
extern __declspec(dllimport) PFNGLROTATEXPROC __glewRotatex;
extern __declspec(dllimport) PFNGLSAMPLECOVERAGEXPROC __glewSampleCoveragex;
extern __declspec(dllimport) PFNGLSCALEXPROC __glewScalex;
extern __declspec(dllimport) PFNGLTEXENVXPROC __glewTexEnvx;
extern __declspec(dllimport) PFNGLTEXENVXVPROC __glewTexEnvxv;
extern __declspec(dllimport) PFNGLTEXPARAMETERXPROC __glewTexParameterx;
extern __declspec(dllimport) PFNGLTRANSLATEXPROC __glewTranslatex;

extern __declspec(dllimport) PFNGLCLIPPLANEFPROC __glewClipPlanef;
extern __declspec(dllimport) PFNGLCLIPPLANEXPROC __glewClipPlanex;
extern __declspec(dllimport) PFNGLGETCLIPPLANEFPROC __glewGetClipPlanef;
extern __declspec(dllimport) PFNGLGETCLIPPLANEXPROC __glewGetClipPlanex;
extern __declspec(dllimport) PFNGLGETFIXEDVPROC __glewGetFixedv;
extern __declspec(dllimport) PFNGLGETLIGHTXVPROC __glewGetLightxv;
extern __declspec(dllimport) PFNGLGETMATERIALXVPROC __glewGetMaterialxv;
extern __declspec(dllimport) PFNGLGETTEXENVXVPROC __glewGetTexEnvxv;
extern __declspec(dllimport) PFNGLGETTEXPARAMETERXVPROC __glewGetTexParameterxv;
extern __declspec(dllimport) PFNGLPOINTPARAMETERXPROC __glewPointParameterx;
extern __declspec(dllimport) PFNGLPOINTPARAMETERXVPROC __glewPointParameterxv;
extern __declspec(dllimport) PFNGLPOINTSIZEPOINTEROESPROC __glewPointSizePointerOES;
extern __declspec(dllimport) PFNGLTEXPARAMETERXVPROC __glewTexParameterxv;

extern __declspec(dllimport) PFNGLERRORSTRINGREGALPROC __glewErrorStringREGAL;

extern __declspec(dllimport) PFNGLGETEXTENSIONREGALPROC __glewGetExtensionREGAL;
extern __declspec(dllimport) PFNGLISSUPPORTEDREGALPROC __glewIsSupportedREGAL;

extern __declspec(dllimport) PFNGLLOGMESSAGECALLBACKREGALPROC __glewLogMessageCallbackREGAL;

extern __declspec(dllimport) PFNGLGETPROCADDRESSREGALPROC __glewGetProcAddressREGAL;

extern __declspec(dllimport) PFNGLDETAILTEXFUNCSGISPROC __glewDetailTexFuncSGIS;
extern __declspec(dllimport) PFNGLGETDETAILTEXFUNCSGISPROC __glewGetDetailTexFuncSGIS;

extern __declspec(dllimport) PFNGLFOGFUNCSGISPROC __glewFogFuncSGIS;
extern __declspec(dllimport) PFNGLGETFOGFUNCSGISPROC __glewGetFogFuncSGIS;

extern __declspec(dllimport) PFNGLSAMPLEMASKSGISPROC __glewSampleMaskSGIS;
extern __declspec(dllimport) PFNGLSAMPLEPATTERNSGISPROC __glewSamplePatternSGIS;

extern __declspec(dllimport) PFNGLINTERLEAVEDTEXTURECOORDSETSSGISPROC __glewInterleavedTextureCoordSetsSGIS;
extern __declspec(dllimport) PFNGLSELECTTEXTURECOORDSETSGISPROC __glewSelectTextureCoordSetSGIS;
extern __declspec(dllimport) PFNGLSELECTTEXTURESGISPROC __glewSelectTextureSGIS;
extern __declspec(dllimport) PFNGLSELECTTEXTURETRANSFORMSGISPROC __glewSelectTextureTransformSGIS;

extern __declspec(dllimport) PFNGLMULTISAMPLESUBRECTPOSSGISPROC __glewMultisampleSubRectPosSGIS;

extern __declspec(dllimport) PFNGLGETSHARPENTEXFUNCSGISPROC __glewGetSharpenTexFuncSGIS;
extern __declspec(dllimport) PFNGLSHARPENTEXFUNCSGISPROC __glewSharpenTexFuncSGIS;

extern __declspec(dllimport) PFNGLTEXIMAGE4DSGISPROC __glewTexImage4DSGIS;
extern __declspec(dllimport) PFNGLTEXSUBIMAGE4DSGISPROC __glewTexSubImage4DSGIS;

extern __declspec(dllimport) PFNGLGETTEXFILTERFUNCSGISPROC __glewGetTexFilterFuncSGIS;
extern __declspec(dllimport) PFNGLTEXFILTERFUNCSGISPROC __glewTexFilterFuncSGIS;

extern __declspec(dllimport) PFNGLASYNCMARKERSGIXPROC __glewAsyncMarkerSGIX;
extern __declspec(dllimport) PFNGLDELETEASYNCMARKERSSGIXPROC __glewDeleteAsyncMarkersSGIX;
extern __declspec(dllimport) PFNGLFINISHASYNCSGIXPROC __glewFinishAsyncSGIX;
extern __declspec(dllimport) PFNGLGENASYNCMARKERSSGIXPROC __glewGenAsyncMarkersSGIX;
extern __declspec(dllimport) PFNGLISASYNCMARKERSGIXPROC __glewIsAsyncMarkerSGIX;
extern __declspec(dllimport) PFNGLPOLLASYNCSGIXPROC __glewPollAsyncSGIX;

extern __declspec(dllimport) PFNGLADDRESSSPACEPROC __glewAddressSpace;
extern __declspec(dllimport) PFNGLDATAPIPEPROC __glewDataPipe;

extern __declspec(dllimport) PFNGLFLUSHRASTERSGIXPROC __glewFlushRasterSGIX;

extern __declspec(dllimport) PFNGLFOGLAYERSSGIXPROC __glewFogLayersSGIX;
extern __declspec(dllimport) PFNGLGETFOGLAYERSSGIXPROC __glewGetFogLayersSGIX;

extern __declspec(dllimport) PFNGLTEXTUREFOGSGIXPROC __glewTextureFogSGIX;

extern __declspec(dllimport) PFNGLFRAGMENTCOLORMATERIALSGIXPROC __glewFragmentColorMaterialSGIX;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTMODELFSGIXPROC __glewFragmentLightModelfSGIX;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTMODELFVSGIXPROC __glewFragmentLightModelfvSGIX;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTMODELISGIXPROC __glewFragmentLightModeliSGIX;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTMODELIVSGIXPROC __glewFragmentLightModelivSGIX;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTFSGIXPROC __glewFragmentLightfSGIX;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTFVSGIXPROC __glewFragmentLightfvSGIX;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTISGIXPROC __glewFragmentLightiSGIX;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTIVSGIXPROC __glewFragmentLightivSGIX;
extern __declspec(dllimport) PFNGLFRAGMENTMATERIALFSGIXPROC __glewFragmentMaterialfSGIX;
extern __declspec(dllimport) PFNGLFRAGMENTMATERIALFVSGIXPROC __glewFragmentMaterialfvSGIX;
extern __declspec(dllimport) PFNGLFRAGMENTMATERIALISGIXPROC __glewFragmentMaterialiSGIX;
extern __declspec(dllimport) PFNGLFRAGMENTMATERIALIVSGIXPROC __glewFragmentMaterialivSGIX;
extern __declspec(dllimport) PFNGLGETFRAGMENTLIGHTFVSGIXPROC __glewGetFragmentLightfvSGIX;
extern __declspec(dllimport) PFNGLGETFRAGMENTLIGHTIVSGIXPROC __glewGetFragmentLightivSGIX;
extern __declspec(dllimport) PFNGLGETFRAGMENTMATERIALFVSGIXPROC __glewGetFragmentMaterialfvSGIX;
extern __declspec(dllimport) PFNGLGETFRAGMENTMATERIALIVSGIXPROC __glewGetFragmentMaterialivSGIX;

extern __declspec(dllimport) PFNGLFRAMEZOOMSGIXPROC __glewFrameZoomSGIX;

extern __declspec(dllimport) PFNGLIGLOOINTERFACESGIXPROC __glewIglooInterfaceSGIX;

extern __declspec(dllimport) PFNGLALLOCMPEGPREDICTORSSGIXPROC __glewAllocMPEGPredictorsSGIX;
extern __declspec(dllimport) PFNGLDELETEMPEGPREDICTORSSGIXPROC __glewDeleteMPEGPredictorsSGIX;
extern __declspec(dllimport) PFNGLGENMPEGPREDICTORSSGIXPROC __glewGenMPEGPredictorsSGIX;
extern __declspec(dllimport) PFNGLGETMPEGPARAMETERFVSGIXPROC __glewGetMPEGParameterfvSGIX;
extern __declspec(dllimport) PFNGLGETMPEGPARAMETERIVSGIXPROC __glewGetMPEGParameterivSGIX;
extern __declspec(dllimport) PFNGLGETMPEGPREDICTORSGIXPROC __glewGetMPEGPredictorSGIX;
extern __declspec(dllimport) PFNGLGETMPEGQUANTTABLEUBVPROC __glewGetMPEGQuantTableubv;
extern __declspec(dllimport) PFNGLISMPEGPREDICTORSGIXPROC __glewIsMPEGPredictorSGIX;
extern __declspec(dllimport) PFNGLMPEGPREDICTORSGIXPROC __glewMPEGPredictorSGIX;
extern __declspec(dllimport) PFNGLMPEGQUANTTABLEUBVPROC __glewMPEGQuantTableubv;
extern __declspec(dllimport) PFNGLSWAPMPEGPREDICTORSSGIXPROC __glewSwapMPEGPredictorsSGIX;

extern __declspec(dllimport) PFNGLGETNONLINLIGHTFVSGIXPROC __glewGetNonlinLightfvSGIX;
extern __declspec(dllimport) PFNGLGETNONLINMATERIALFVSGIXPROC __glewGetNonlinMaterialfvSGIX;
extern __declspec(dllimport) PFNGLNONLINLIGHTFVSGIXPROC __glewNonlinLightfvSGIX;
extern __declspec(dllimport) PFNGLNONLINMATERIALFVSGIXPROC __glewNonlinMaterialfvSGIX;

extern __declspec(dllimport) PFNGLPIXELTEXGENSGIXPROC __glewPixelTexGenSGIX;

extern __declspec(dllimport) PFNGLDEFORMSGIXPROC __glewDeformSGIX;
extern __declspec(dllimport) PFNGLLOADIDENTITYDEFORMATIONMAPSGIXPROC __glewLoadIdentityDeformationMapSGIX;

extern __declspec(dllimport) PFNGLMESHBREADTHSGIXPROC __glewMeshBreadthSGIX;
extern __declspec(dllimport) PFNGLMESHSTRIDESGIXPROC __glewMeshStrideSGIX;

extern __declspec(dllimport) PFNGLREFERENCEPLANESGIXPROC __glewReferencePlaneSGIX;

extern __declspec(dllimport) PFNGLSPRITEPARAMETERFSGIXPROC __glewSpriteParameterfSGIX;
extern __declspec(dllimport) PFNGLSPRITEPARAMETERFVSGIXPROC __glewSpriteParameterfvSGIX;
extern __declspec(dllimport) PFNGLSPRITEPARAMETERISGIXPROC __glewSpriteParameteriSGIX;
extern __declspec(dllimport) PFNGLSPRITEPARAMETERIVSGIXPROC __glewSpriteParameterivSGIX;

extern __declspec(dllimport) PFNGLTAGSAMPLEBUFFERSGIXPROC __glewTagSampleBufferSGIX;

extern __declspec(dllimport) PFNGLGETVECTOROPERATIONSGIXPROC __glewGetVectorOperationSGIX;
extern __declspec(dllimport) PFNGLVECTOROPERATIONSGIXPROC __glewVectorOperationSGIX;

extern __declspec(dllimport) PFNGLAREVERTEXARRAYSRESIDENTSGIXPROC __glewAreVertexArraysResidentSGIX;
extern __declspec(dllimport) PFNGLBINDVERTEXARRAYSGIXPROC __glewBindVertexArraySGIX;
extern __declspec(dllimport) PFNGLDELETEVERTEXARRAYSSGIXPROC __glewDeleteVertexArraysSGIX;
extern __declspec(dllimport) PFNGLGENVERTEXARRAYSSGIXPROC __glewGenVertexArraysSGIX;
extern __declspec(dllimport) PFNGLISVERTEXARRAYSGIXPROC __glewIsVertexArraySGIX;
extern __declspec(dllimport) PFNGLPRIORITIZEVERTEXARRAYSSGIXPROC __glewPrioritizeVertexArraysSGIX;

extern __declspec(dllimport) PFNGLCOLORTABLEPARAMETERFVSGIPROC __glewColorTableParameterfvSGI;
extern __declspec(dllimport) PFNGLCOLORTABLEPARAMETERIVSGIPROC __glewColorTableParameterivSGI;
extern __declspec(dllimport) PFNGLCOLORTABLESGIPROC __glewColorTableSGI;
extern __declspec(dllimport) PFNGLCOPYCOLORTABLESGIPROC __glewCopyColorTableSGI;
extern __declspec(dllimport) PFNGLGETCOLORTABLEPARAMETERFVSGIPROC __glewGetColorTableParameterfvSGI;
extern __declspec(dllimport) PFNGLGETCOLORTABLEPARAMETERIVSGIPROC __glewGetColorTableParameterivSGI;
extern __declspec(dllimport) PFNGLGETCOLORTABLESGIPROC __glewGetColorTableSGI;

extern __declspec(dllimport) PFNGLGETPIXELTRANSFORMPARAMETERFVSGIPROC __glewGetPixelTransformParameterfvSGI;
extern __declspec(dllimport) PFNGLGETPIXELTRANSFORMPARAMETERIVSGIPROC __glewGetPixelTransformParameterivSGI;
extern __declspec(dllimport) PFNGLPIXELTRANSFORMPARAMETERFSGIPROC __glewPixelTransformParameterfSGI;
extern __declspec(dllimport) PFNGLPIXELTRANSFORMPARAMETERFVSGIPROC __glewPixelTransformParameterfvSGI;
extern __declspec(dllimport) PFNGLPIXELTRANSFORMPARAMETERISGIPROC __glewPixelTransformParameteriSGI;
extern __declspec(dllimport) PFNGLPIXELTRANSFORMPARAMETERIVSGIPROC __glewPixelTransformParameterivSGI;
extern __declspec(dllimport) PFNGLPIXELTRANSFORMSGIPROC __glewPixelTransformSGI;

extern __declspec(dllimport) PFNGLFINISHTEXTURESUNXPROC __glewFinishTextureSUNX;

extern __declspec(dllimport) PFNGLGLOBALALPHAFACTORBSUNPROC __glewGlobalAlphaFactorbSUN;
extern __declspec(dllimport) PFNGLGLOBALALPHAFACTORDSUNPROC __glewGlobalAlphaFactordSUN;
extern __declspec(dllimport) PFNGLGLOBALALPHAFACTORFSUNPROC __glewGlobalAlphaFactorfSUN;
extern __declspec(dllimport) PFNGLGLOBALALPHAFACTORISUNPROC __glewGlobalAlphaFactoriSUN;
extern __declspec(dllimport) PFNGLGLOBALALPHAFACTORSSUNPROC __glewGlobalAlphaFactorsSUN;
extern __declspec(dllimport) PFNGLGLOBALALPHAFACTORUBSUNPROC __glewGlobalAlphaFactorubSUN;
extern __declspec(dllimport) PFNGLGLOBALALPHAFACTORUISUNPROC __glewGlobalAlphaFactoruiSUN;
extern __declspec(dllimport) PFNGLGLOBALALPHAFACTORUSSUNPROC __glewGlobalAlphaFactorusSUN;

extern __declspec(dllimport) PFNGLREADVIDEOPIXELSSUNPROC __glewReadVideoPixelsSUN;

extern __declspec(dllimport) PFNGLREPLACEMENTCODEPOINTERSUNPROC __glewReplacementCodePointerSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUBSUNPROC __glewReplacementCodeubSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUBVSUNPROC __glewReplacementCodeubvSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUISUNPROC __glewReplacementCodeuiSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUIVSUNPROC __glewReplacementCodeuivSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUSSUNPROC __glewReplacementCodeusSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUSVSUNPROC __glewReplacementCodeusvSUN;

extern __declspec(dllimport) PFNGLCOLOR3FVERTEX3FSUNPROC __glewColor3fVertex3fSUN;
extern __declspec(dllimport) PFNGLCOLOR3FVERTEX3FVSUNPROC __glewColor3fVertex3fvSUN;
extern __declspec(dllimport) PFNGLCOLOR4FNORMAL3FVERTEX3FSUNPROC __glewColor4fNormal3fVertex3fSUN;
extern __declspec(dllimport) PFNGLCOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewColor4fNormal3fVertex3fvSUN;
extern __declspec(dllimport) PFNGLCOLOR4UBVERTEX2FSUNPROC __glewColor4ubVertex2fSUN;
extern __declspec(dllimport) PFNGLCOLOR4UBVERTEX2FVSUNPROC __glewColor4ubVertex2fvSUN;
extern __declspec(dllimport) PFNGLCOLOR4UBVERTEX3FSUNPROC __glewColor4ubVertex3fSUN;
extern __declspec(dllimport) PFNGLCOLOR4UBVERTEX3FVSUNPROC __glewColor4ubVertex3fvSUN;
extern __declspec(dllimport) PFNGLNORMAL3FVERTEX3FSUNPROC __glewNormal3fVertex3fSUN;
extern __declspec(dllimport) PFNGLNORMAL3FVERTEX3FVSUNPROC __glewNormal3fVertex3fvSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FSUNPROC __glewReplacementCodeuiColor3fVertex3fSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUNPROC __glewReplacementCodeuiColor3fVertex3fvSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiColor4fNormal3fVertex3fSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiColor4fNormal3fVertex3fvSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUNPROC __glewReplacementCodeuiColor4ubVertex3fSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUNPROC __glewReplacementCodeuiColor4ubVertex3fvSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiNormal3fVertex3fSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiNormal3fVertex3fvSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiTexCoord2fNormal3fVertex3fSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUNPROC __glewReplacementCodeuiTexCoord2fVertex3fSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUNPROC __glewReplacementCodeuiTexCoord2fVertex3fvSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUIVERTEX3FSUNPROC __glewReplacementCodeuiVertex3fSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUIVERTEX3FVSUNPROC __glewReplacementCodeuiVertex3fvSUN;
extern __declspec(dllimport) PFNGLTEXCOORD2FCOLOR3FVERTEX3FSUNPROC __glewTexCoord2fColor3fVertex3fSUN;
extern __declspec(dllimport) PFNGLTEXCOORD2FCOLOR3FVERTEX3FVSUNPROC __glewTexCoord2fColor3fVertex3fvSUN;
extern __declspec(dllimport) PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC __glewTexCoord2fColor4fNormal3fVertex3fSUN;
extern __declspec(dllimport) PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewTexCoord2fColor4fNormal3fVertex3fvSUN;
extern __declspec(dllimport) PFNGLTEXCOORD2FCOLOR4UBVERTEX3FSUNPROC __glewTexCoord2fColor4ubVertex3fSUN;
extern __declspec(dllimport) PFNGLTEXCOORD2FCOLOR4UBVERTEX3FVSUNPROC __glewTexCoord2fColor4ubVertex3fvSUN;
extern __declspec(dllimport) PFNGLTEXCOORD2FNORMAL3FVERTEX3FSUNPROC __glewTexCoord2fNormal3fVertex3fSUN;
extern __declspec(dllimport) PFNGLTEXCOORD2FNORMAL3FVERTEX3FVSUNPROC __glewTexCoord2fNormal3fVertex3fvSUN;
extern __declspec(dllimport) PFNGLTEXCOORD2FVERTEX3FSUNPROC __glewTexCoord2fVertex3fSUN;
extern __declspec(dllimport) PFNGLTEXCOORD2FVERTEX3FVSUNPROC __glewTexCoord2fVertex3fvSUN;
extern __declspec(dllimport) PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUNPROC __glewTexCoord4fColor4fNormal3fVertex4fSUN;
extern __declspec(dllimport) PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUNPROC __glewTexCoord4fColor4fNormal3fVertex4fvSUN;
extern __declspec(dllimport) PFNGLTEXCOORD4FVERTEX4FSUNPROC __glewTexCoord4fVertex4fSUN;
extern __declspec(dllimport) PFNGLTEXCOORD4FVERTEX4FVSUNPROC __glewTexCoord4fVertex4fvSUN;

extern __declspec(dllimport) PFNGLADDSWAPHINTRECTWINPROC __glewAddSwapHintRectWIN;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_1_1;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_1_2;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_1_2_1;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_1_3;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_1_4;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_1_5;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_2_0;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_2_1;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_3_0;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_3_1;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_3_2;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_3_3;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_4_0;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_4_1;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_4_2;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_4_3;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_4_4;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_4_5;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_4_6;
extern __declspec(dllimport) GLboolean __GLEW_3DFX_multisample;
extern __declspec(dllimport) GLboolean __GLEW_3DFX_tbuffer;
extern __declspec(dllimport) GLboolean __GLEW_3DFX_texture_compression_FXT1;
extern __declspec(dllimport) GLboolean __GLEW_AMD_blend_minmax_factor;
extern __declspec(dllimport) GLboolean __GLEW_AMD_compressed_3DC_texture;
extern __declspec(dllimport) GLboolean __GLEW_AMD_compressed_ATC_texture;
extern __declspec(dllimport) GLboolean __GLEW_AMD_conservative_depth;
extern __declspec(dllimport) GLboolean __GLEW_AMD_debug_output;
extern __declspec(dllimport) GLboolean __GLEW_AMD_depth_clamp_separate;
extern __declspec(dllimport) GLboolean __GLEW_AMD_draw_buffers_blend;
extern __declspec(dllimport) GLboolean __GLEW_AMD_framebuffer_sample_positions;
extern __declspec(dllimport) GLboolean __GLEW_AMD_gcn_shader;
extern __declspec(dllimport) GLboolean __GLEW_AMD_gpu_shader_half_float;
extern __declspec(dllimport) GLboolean __GLEW_AMD_gpu_shader_int16;
extern __declspec(dllimport) GLboolean __GLEW_AMD_gpu_shader_int64;
extern __declspec(dllimport) GLboolean __GLEW_AMD_interleaved_elements;
extern __declspec(dllimport) GLboolean __GLEW_AMD_multi_draw_indirect;
extern __declspec(dllimport) GLboolean __GLEW_AMD_name_gen_delete;
extern __declspec(dllimport) GLboolean __GLEW_AMD_occlusion_query_event;
extern __declspec(dllimport) GLboolean __GLEW_AMD_performance_monitor;
extern __declspec(dllimport) GLboolean __GLEW_AMD_pinned_memory;
extern __declspec(dllimport) GLboolean __GLEW_AMD_program_binary_Z400;
extern __declspec(dllimport) GLboolean __GLEW_AMD_query_buffer_object;
extern __declspec(dllimport) GLboolean __GLEW_AMD_sample_positions;
extern __declspec(dllimport) GLboolean __GLEW_AMD_seamless_cubemap_per_texture;
extern __declspec(dllimport) GLboolean __GLEW_AMD_shader_atomic_counter_ops;
extern __declspec(dllimport) GLboolean __GLEW_AMD_shader_ballot;
extern __declspec(dllimport) GLboolean __GLEW_AMD_shader_explicit_vertex_parameter;
extern __declspec(dllimport) GLboolean __GLEW_AMD_shader_stencil_export;
extern __declspec(dllimport) GLboolean __GLEW_AMD_shader_stencil_value_export;
extern __declspec(dllimport) GLboolean __GLEW_AMD_shader_trinary_minmax;
extern __declspec(dllimport) GLboolean __GLEW_AMD_sparse_texture;
extern __declspec(dllimport) GLboolean __GLEW_AMD_stencil_operation_extended;
extern __declspec(dllimport) GLboolean __GLEW_AMD_texture_gather_bias_lod;
extern __declspec(dllimport) GLboolean __GLEW_AMD_texture_texture4;
extern __declspec(dllimport) GLboolean __GLEW_AMD_transform_feedback3_lines_triangles;
extern __declspec(dllimport) GLboolean __GLEW_AMD_transform_feedback4;
extern __declspec(dllimport) GLboolean __GLEW_AMD_vertex_shader_layer;
extern __declspec(dllimport) GLboolean __GLEW_AMD_vertex_shader_tessellator;
extern __declspec(dllimport) GLboolean __GLEW_AMD_vertex_shader_viewport_index;
extern __declspec(dllimport) GLboolean __GLEW_ANDROID_extension_pack_es31a;
extern __declspec(dllimport) GLboolean __GLEW_ANGLE_depth_texture;
extern __declspec(dllimport) GLboolean __GLEW_ANGLE_framebuffer_blit;
extern __declspec(dllimport) GLboolean __GLEW_ANGLE_framebuffer_multisample;
extern __declspec(dllimport) GLboolean __GLEW_ANGLE_instanced_arrays;
extern __declspec(dllimport) GLboolean __GLEW_ANGLE_pack_reverse_row_order;
extern __declspec(dllimport) GLboolean __GLEW_ANGLE_program_binary;
extern __declspec(dllimport) GLboolean __GLEW_ANGLE_texture_compression_dxt1;
extern __declspec(dllimport) GLboolean __GLEW_ANGLE_texture_compression_dxt3;
extern __declspec(dllimport) GLboolean __GLEW_ANGLE_texture_compression_dxt5;
extern __declspec(dllimport) GLboolean __GLEW_ANGLE_texture_usage;
extern __declspec(dllimport) GLboolean __GLEW_ANGLE_timer_query;
extern __declspec(dllimport) GLboolean __GLEW_ANGLE_translated_shader_source;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_aux_depth_stencil;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_client_storage;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_clip_distance;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_color_buffer_packed_float;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_copy_texture_levels;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_element_array;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_fence;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_float_pixels;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_flush_buffer_range;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_framebuffer_multisample;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_object_purgeable;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_pixel_buffer;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_rgb_422;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_row_bytes;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_specular_vector;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_sync;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_texture_2D_limited_npot;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_texture_format_BGRA8888;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_texture_max_level;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_texture_packed_float;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_texture_range;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_transform_hint;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_vertex_array_object;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_vertex_array_range;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_vertex_program_evaluators;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_ycbcr_422;
extern __declspec(dllimport) GLboolean __GLEW_ARB_ES2_compatibility;
extern __declspec(dllimport) GLboolean __GLEW_ARB_ES3_1_compatibility;
extern __declspec(dllimport) GLboolean __GLEW_ARB_ES3_2_compatibility;
extern __declspec(dllimport) GLboolean __GLEW_ARB_ES3_compatibility;
extern __declspec(dllimport) GLboolean __GLEW_ARB_arrays_of_arrays;
extern __declspec(dllimport) GLboolean __GLEW_ARB_base_instance;
extern __declspec(dllimport) GLboolean __GLEW_ARB_bindless_texture;
extern __declspec(dllimport) GLboolean __GLEW_ARB_blend_func_extended;
extern __declspec(dllimport) GLboolean __GLEW_ARB_buffer_storage;
extern __declspec(dllimport) GLboolean __GLEW_ARB_cl_event;
extern __declspec(dllimport) GLboolean __GLEW_ARB_clear_buffer_object;
extern __declspec(dllimport) GLboolean __GLEW_ARB_clear_texture;
extern __declspec(dllimport) GLboolean __GLEW_ARB_clip_control;
extern __declspec(dllimport) GLboolean __GLEW_ARB_color_buffer_float;
extern __declspec(dllimport) GLboolean __GLEW_ARB_compatibility;
extern __declspec(dllimport) GLboolean __GLEW_ARB_compressed_texture_pixel_storage;
extern __declspec(dllimport) GLboolean __GLEW_ARB_compute_shader;
extern __declspec(dllimport) GLboolean __GLEW_ARB_compute_variable_group_size;
extern __declspec(dllimport) GLboolean __GLEW_ARB_conditional_render_inverted;
extern __declspec(dllimport) GLboolean __GLEW_ARB_conservative_depth;
extern __declspec(dllimport) GLboolean __GLEW_ARB_copy_buffer;
extern __declspec(dllimport) GLboolean __GLEW_ARB_copy_image;
extern __declspec(dllimport) GLboolean __GLEW_ARB_cull_distance;
extern __declspec(dllimport) GLboolean __GLEW_ARB_debug_output;
extern __declspec(dllimport) GLboolean __GLEW_ARB_depth_buffer_float;
extern __declspec(dllimport) GLboolean __GLEW_ARB_depth_clamp;
extern __declspec(dllimport) GLboolean __GLEW_ARB_depth_texture;
extern __declspec(dllimport) GLboolean __GLEW_ARB_derivative_control;
extern __declspec(dllimport) GLboolean __GLEW_ARB_direct_state_access;
extern __declspec(dllimport) GLboolean __GLEW_ARB_draw_buffers;
extern __declspec(dllimport) GLboolean __GLEW_ARB_draw_buffers_blend;
extern __declspec(dllimport) GLboolean __GLEW_ARB_draw_elements_base_vertex;
extern __declspec(dllimport) GLboolean __GLEW_ARB_draw_indirect;
extern __declspec(dllimport) GLboolean __GLEW_ARB_draw_instanced;
extern __declspec(dllimport) GLboolean __GLEW_ARB_enhanced_layouts;
extern __declspec(dllimport) GLboolean __GLEW_ARB_explicit_attrib_location;
extern __declspec(dllimport) GLboolean __GLEW_ARB_explicit_uniform_location;
extern __declspec(dllimport) GLboolean __GLEW_ARB_fragment_coord_conventions;
extern __declspec(dllimport) GLboolean __GLEW_ARB_fragment_layer_viewport;
extern __declspec(dllimport) GLboolean __GLEW_ARB_fragment_program;
extern __declspec(dllimport) GLboolean __GLEW_ARB_fragment_program_shadow;
extern __declspec(dllimport) GLboolean __GLEW_ARB_fragment_shader;
extern __declspec(dllimport) GLboolean __GLEW_ARB_fragment_shader_interlock;
extern __declspec(dllimport) GLboolean __GLEW_ARB_framebuffer_no_attachments;
extern __declspec(dllimport) GLboolean __GLEW_ARB_framebuffer_object;
extern __declspec(dllimport) GLboolean __GLEW_ARB_framebuffer_sRGB;
extern __declspec(dllimport) GLboolean __GLEW_ARB_geometry_shader4;
extern __declspec(dllimport) GLboolean __GLEW_ARB_get_program_binary;
extern __declspec(dllimport) GLboolean __GLEW_ARB_get_texture_sub_image;
extern __declspec(dllimport) GLboolean __GLEW_ARB_gl_spirv;
extern __declspec(dllimport) GLboolean __GLEW_ARB_gpu_shader5;
extern __declspec(dllimport) GLboolean __GLEW_ARB_gpu_shader_fp64;
extern __declspec(dllimport) GLboolean __GLEW_ARB_gpu_shader_int64;
extern __declspec(dllimport) GLboolean __GLEW_ARB_half_float_pixel;
extern __declspec(dllimport) GLboolean __GLEW_ARB_half_float_vertex;
extern __declspec(dllimport) GLboolean __GLEW_ARB_imaging;
extern __declspec(dllimport) GLboolean __GLEW_ARB_indirect_parameters;
extern __declspec(dllimport) GLboolean __GLEW_ARB_instanced_arrays;
extern __declspec(dllimport) GLboolean __GLEW_ARB_internalformat_query;
extern __declspec(dllimport) GLboolean __GLEW_ARB_internalformat_query2;
extern __declspec(dllimport) GLboolean __GLEW_ARB_invalidate_subdata;
extern __declspec(dllimport) GLboolean __GLEW_ARB_map_buffer_alignment;
extern __declspec(dllimport) GLboolean __GLEW_ARB_map_buffer_range;
extern __declspec(dllimport) GLboolean __GLEW_ARB_matrix_palette;
extern __declspec(dllimport) GLboolean __GLEW_ARB_multi_bind;
extern __declspec(dllimport) GLboolean __GLEW_ARB_multi_draw_indirect;
extern __declspec(dllimport) GLboolean __GLEW_ARB_multisample;
extern __declspec(dllimport) GLboolean __GLEW_ARB_multitexture;
extern __declspec(dllimport) GLboolean __GLEW_ARB_occlusion_query;
extern __declspec(dllimport) GLboolean __GLEW_ARB_occlusion_query2;
extern __declspec(dllimport) GLboolean __GLEW_ARB_parallel_shader_compile;
extern __declspec(dllimport) GLboolean __GLEW_ARB_pipeline_statistics_query;
extern __declspec(dllimport) GLboolean __GLEW_ARB_pixel_buffer_object;
extern __declspec(dllimport) GLboolean __GLEW_ARB_point_parameters;
extern __declspec(dllimport) GLboolean __GLEW_ARB_point_sprite;
extern __declspec(dllimport) GLboolean __GLEW_ARB_polygon_offset_clamp;
extern __declspec(dllimport) GLboolean __GLEW_ARB_post_depth_coverage;
extern __declspec(dllimport) GLboolean __GLEW_ARB_program_interface_query;
extern __declspec(dllimport) GLboolean __GLEW_ARB_provoking_vertex;
extern __declspec(dllimport) GLboolean __GLEW_ARB_query_buffer_object;
extern __declspec(dllimport) GLboolean __GLEW_ARB_robust_buffer_access_behavior;
extern __declspec(dllimport) GLboolean __GLEW_ARB_robustness;
extern __declspec(dllimport) GLboolean __GLEW_ARB_robustness_application_isolation;
extern __declspec(dllimport) GLboolean __GLEW_ARB_robustness_share_group_isolation;
extern __declspec(dllimport) GLboolean __GLEW_ARB_sample_locations;
extern __declspec(dllimport) GLboolean __GLEW_ARB_sample_shading;
extern __declspec(dllimport) GLboolean __GLEW_ARB_sampler_objects;
extern __declspec(dllimport) GLboolean __GLEW_ARB_seamless_cube_map;
extern __declspec(dllimport) GLboolean __GLEW_ARB_seamless_cubemap_per_texture;
extern __declspec(dllimport) GLboolean __GLEW_ARB_separate_shader_objects;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shader_atomic_counter_ops;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shader_atomic_counters;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shader_ballot;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shader_bit_encoding;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shader_clock;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shader_draw_parameters;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shader_group_vote;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shader_image_load_store;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shader_image_size;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shader_objects;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shader_precision;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shader_stencil_export;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shader_storage_buffer_object;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shader_subroutine;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shader_texture_image_samples;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shader_texture_lod;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shader_viewport_layer_array;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shading_language_100;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shading_language_420pack;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shading_language_include;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shading_language_packing;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shadow;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shadow_ambient;
extern __declspec(dllimport) GLboolean __GLEW_ARB_sparse_buffer;
extern __declspec(dllimport) GLboolean __GLEW_ARB_sparse_texture;
extern __declspec(dllimport) GLboolean __GLEW_ARB_sparse_texture2;
extern __declspec(dllimport) GLboolean __GLEW_ARB_sparse_texture_clamp;
extern __declspec(dllimport) GLboolean __GLEW_ARB_spirv_extensions;
extern __declspec(dllimport) GLboolean __GLEW_ARB_stencil_texturing;
extern __declspec(dllimport) GLboolean __GLEW_ARB_sync;
extern __declspec(dllimport) GLboolean __GLEW_ARB_tessellation_shader;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_barrier;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_border_clamp;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_buffer_object;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_buffer_object_rgb32;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_buffer_range;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_compression;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_compression_bptc;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_compression_rgtc;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_cube_map;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_cube_map_array;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_env_add;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_env_combine;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_env_crossbar;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_env_dot3;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_filter_anisotropic;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_filter_minmax;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_float;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_gather;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_mirror_clamp_to_edge;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_mirrored_repeat;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_multisample;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_non_power_of_two;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_query_levels;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_query_lod;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_rectangle;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_rg;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_rgb10_a2ui;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_stencil8;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_storage;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_storage_multisample;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_swizzle;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_view;
extern __declspec(dllimport) GLboolean __GLEW_ARB_timer_query;
extern __declspec(dllimport) GLboolean __GLEW_ARB_transform_feedback2;
extern __declspec(dllimport) GLboolean __GLEW_ARB_transform_feedback3;
extern __declspec(dllimport) GLboolean __GLEW_ARB_transform_feedback_instanced;
extern __declspec(dllimport) GLboolean __GLEW_ARB_transform_feedback_overflow_query;
extern __declspec(dllimport) GLboolean __GLEW_ARB_transpose_matrix;
extern __declspec(dllimport) GLboolean __GLEW_ARB_uniform_buffer_object;
extern __declspec(dllimport) GLboolean __GLEW_ARB_vertex_array_bgra;
extern __declspec(dllimport) GLboolean __GLEW_ARB_vertex_array_object;
extern __declspec(dllimport) GLboolean __GLEW_ARB_vertex_attrib_64bit;
extern __declspec(dllimport) GLboolean __GLEW_ARB_vertex_attrib_binding;
extern __declspec(dllimport) GLboolean __GLEW_ARB_vertex_blend;
extern __declspec(dllimport) GLboolean __GLEW_ARB_vertex_buffer_object;
extern __declspec(dllimport) GLboolean __GLEW_ARB_vertex_program;
extern __declspec(dllimport) GLboolean __GLEW_ARB_vertex_shader;
extern __declspec(dllimport) GLboolean __GLEW_ARB_vertex_type_10f_11f_11f_rev;
extern __declspec(dllimport) GLboolean __GLEW_ARB_vertex_type_2_10_10_10_rev;
extern __declspec(dllimport) GLboolean __GLEW_ARB_viewport_array;
extern __declspec(dllimport) GLboolean __GLEW_ARB_window_pos;
extern __declspec(dllimport) GLboolean __GLEW_ARM_mali_program_binary;
extern __declspec(dllimport) GLboolean __GLEW_ARM_mali_shader_binary;
extern __declspec(dllimport) GLboolean __GLEW_ARM_rgba8;
extern __declspec(dllimport) GLboolean __GLEW_ARM_shader_framebuffer_fetch;
extern __declspec(dllimport) GLboolean __GLEW_ARM_shader_framebuffer_fetch_depth_stencil;
extern __declspec(dllimport) GLboolean __GLEW_ATIX_point_sprites;
extern __declspec(dllimport) GLboolean __GLEW_ATIX_texture_env_combine3;
extern __declspec(dllimport) GLboolean __GLEW_ATIX_texture_env_route;
extern __declspec(dllimport) GLboolean __GLEW_ATIX_vertex_shader_output_point_size;
extern __declspec(dllimport) GLboolean __GLEW_ATI_draw_buffers;
extern __declspec(dllimport) GLboolean __GLEW_ATI_element_array;
extern __declspec(dllimport) GLboolean __GLEW_ATI_envmap_bumpmap;
extern __declspec(dllimport) GLboolean __GLEW_ATI_fragment_shader;
extern __declspec(dllimport) GLboolean __GLEW_ATI_map_object_buffer;
extern __declspec(dllimport) GLboolean __GLEW_ATI_meminfo;
extern __declspec(dllimport) GLboolean __GLEW_ATI_pn_triangles;
extern __declspec(dllimport) GLboolean __GLEW_ATI_separate_stencil;
extern __declspec(dllimport) GLboolean __GLEW_ATI_shader_texture_lod;
extern __declspec(dllimport) GLboolean __GLEW_ATI_text_fragment_shader;
extern __declspec(dllimport) GLboolean __GLEW_ATI_texture_compression_3dc;
extern __declspec(dllimport) GLboolean __GLEW_ATI_texture_env_combine3;
extern __declspec(dllimport) GLboolean __GLEW_ATI_texture_float;
extern __declspec(dllimport) GLboolean __GLEW_ATI_texture_mirror_once;
extern __declspec(dllimport) GLboolean __GLEW_ATI_vertex_array_object;
extern __declspec(dllimport) GLboolean __GLEW_ATI_vertex_attrib_array_object;
extern __declspec(dllimport) GLboolean __GLEW_ATI_vertex_streams;
extern __declspec(dllimport) GLboolean __GLEW_EGL_KHR_context_flush_control;
extern __declspec(dllimport) GLboolean __GLEW_EGL_NV_robustness_video_memory_purge;
extern __declspec(dllimport) GLboolean __GLEW_EXT_422_pixels;
extern __declspec(dllimport) GLboolean __GLEW_EXT_Cg_shader;
extern __declspec(dllimport) GLboolean __GLEW_EXT_EGL_image_array;
extern __declspec(dllimport) GLboolean __GLEW_EXT_YUV_target;
extern __declspec(dllimport) GLboolean __GLEW_EXT_abgr;
extern __declspec(dllimport) GLboolean __GLEW_EXT_base_instance;
extern __declspec(dllimport) GLboolean __GLEW_EXT_bgra;
extern __declspec(dllimport) GLboolean __GLEW_EXT_bindable_uniform;
extern __declspec(dllimport) GLboolean __GLEW_EXT_blend_color;
extern __declspec(dllimport) GLboolean __GLEW_EXT_blend_equation_separate;
extern __declspec(dllimport) GLboolean __GLEW_EXT_blend_func_extended;
extern __declspec(dllimport) GLboolean __GLEW_EXT_blend_func_separate;
extern __declspec(dllimport) GLboolean __GLEW_EXT_blend_logic_op;
extern __declspec(dllimport) GLboolean __GLEW_EXT_blend_minmax;
extern __declspec(dllimport) GLboolean __GLEW_EXT_blend_subtract;
extern __declspec(dllimport) GLboolean __GLEW_EXT_buffer_storage;
extern __declspec(dllimport) GLboolean __GLEW_EXT_clear_texture;
extern __declspec(dllimport) GLboolean __GLEW_EXT_clip_cull_distance;
extern __declspec(dllimport) GLboolean __GLEW_EXT_clip_volume_hint;
extern __declspec(dllimport) GLboolean __GLEW_EXT_cmyka;
extern __declspec(dllimport) GLboolean __GLEW_EXT_color_buffer_float;
extern __declspec(dllimport) GLboolean __GLEW_EXT_color_buffer_half_float;
extern __declspec(dllimport) GLboolean __GLEW_EXT_color_subtable;
extern __declspec(dllimport) GLboolean __GLEW_EXT_compiled_vertex_array;
extern __declspec(dllimport) GLboolean __GLEW_EXT_compressed_ETC1_RGB8_sub_texture;
extern __declspec(dllimport) GLboolean __GLEW_EXT_conservative_depth;
extern __declspec(dllimport) GLboolean __GLEW_EXT_convolution;
extern __declspec(dllimport) GLboolean __GLEW_EXT_coordinate_frame;
extern __declspec(dllimport) GLboolean __GLEW_EXT_copy_image;
extern __declspec(dllimport) GLboolean __GLEW_EXT_copy_texture;
extern __declspec(dllimport) GLboolean __GLEW_EXT_cull_vertex;
extern __declspec(dllimport) GLboolean __GLEW_EXT_debug_label;
extern __declspec(dllimport) GLboolean __GLEW_EXT_debug_marker;
extern __declspec(dllimport) GLboolean __GLEW_EXT_depth_bounds_test;
extern __declspec(dllimport) GLboolean __GLEW_EXT_direct_state_access;
extern __declspec(dllimport) GLboolean __GLEW_EXT_discard_framebuffer;
extern __declspec(dllimport) GLboolean __GLEW_EXT_draw_buffers;
extern __declspec(dllimport) GLboolean __GLEW_EXT_draw_buffers2;
extern __declspec(dllimport) GLboolean __GLEW_EXT_draw_buffers_indexed;
extern __declspec(dllimport) GLboolean __GLEW_EXT_draw_elements_base_vertex;
extern __declspec(dllimport) GLboolean __GLEW_EXT_draw_instanced;
extern __declspec(dllimport) GLboolean __GLEW_EXT_draw_range_elements;
extern __declspec(dllimport) GLboolean __GLEW_EXT_external_buffer;
extern __declspec(dllimport) GLboolean __GLEW_EXT_float_blend;
extern __declspec(dllimport) GLboolean __GLEW_EXT_fog_coord;
extern __declspec(dllimport) GLboolean __GLEW_EXT_frag_depth;
extern __declspec(dllimport) GLboolean __GLEW_EXT_fragment_lighting;
extern __declspec(dllimport) GLboolean __GLEW_EXT_framebuffer_blit;
extern __declspec(dllimport) GLboolean __GLEW_EXT_framebuffer_multisample;
extern __declspec(dllimport) GLboolean __GLEW_EXT_framebuffer_multisample_blit_scaled;
extern __declspec(dllimport) GLboolean __GLEW_EXT_framebuffer_object;
extern __declspec(dllimport) GLboolean __GLEW_EXT_framebuffer_sRGB;
extern __declspec(dllimport) GLboolean __GLEW_EXT_geometry_point_size;
extern __declspec(dllimport) GLboolean __GLEW_EXT_geometry_shader;
extern __declspec(dllimport) GLboolean __GLEW_EXT_geometry_shader4;
extern __declspec(dllimport) GLboolean __GLEW_EXT_gpu_program_parameters;
extern __declspec(dllimport) GLboolean __GLEW_EXT_gpu_shader4;
extern __declspec(dllimport) GLboolean __GLEW_EXT_gpu_shader5;
extern __declspec(dllimport) GLboolean __GLEW_EXT_histogram;
extern __declspec(dllimport) GLboolean __GLEW_EXT_index_array_formats;
extern __declspec(dllimport) GLboolean __GLEW_EXT_index_func;
extern __declspec(dllimport) GLboolean __GLEW_EXT_index_material;
extern __declspec(dllimport) GLboolean __GLEW_EXT_index_texture;
extern __declspec(dllimport) GLboolean __GLEW_EXT_instanced_arrays;
extern __declspec(dllimport) GLboolean __GLEW_EXT_light_texture;
extern __declspec(dllimport) GLboolean __GLEW_EXT_map_buffer_range;
extern __declspec(dllimport) GLboolean __GLEW_EXT_memory_object;
extern __declspec(dllimport) GLboolean __GLEW_EXT_memory_object_fd;
extern __declspec(dllimport) GLboolean __GLEW_EXT_memory_object_win32;
extern __declspec(dllimport) GLboolean __GLEW_EXT_misc_attribute;
extern __declspec(dllimport) GLboolean __GLEW_EXT_multi_draw_arrays;
extern __declspec(dllimport) GLboolean __GLEW_EXT_multi_draw_indirect;
extern __declspec(dllimport) GLboolean __GLEW_EXT_multiple_textures;
extern __declspec(dllimport) GLboolean __GLEW_EXT_multisample;
extern __declspec(dllimport) GLboolean __GLEW_EXT_multisample_compatibility;
extern __declspec(dllimport) GLboolean __GLEW_EXT_multisampled_render_to_texture;
extern __declspec(dllimport) GLboolean __GLEW_EXT_multisampled_render_to_texture2;
extern __declspec(dllimport) GLboolean __GLEW_EXT_multiview_draw_buffers;
extern __declspec(dllimport) GLboolean __GLEW_EXT_packed_depth_stencil;
extern __declspec(dllimport) GLboolean __GLEW_EXT_packed_float;
extern __declspec(dllimport) GLboolean __GLEW_EXT_packed_pixels;
extern __declspec(dllimport) GLboolean __GLEW_EXT_paletted_texture;
extern __declspec(dllimport) GLboolean __GLEW_EXT_pixel_buffer_object;
extern __declspec(dllimport) GLboolean __GLEW_EXT_pixel_transform;
extern __declspec(dllimport) GLboolean __GLEW_EXT_pixel_transform_color_table;
extern __declspec(dllimport) GLboolean __GLEW_EXT_point_parameters;
extern __declspec(dllimport) GLboolean __GLEW_EXT_polygon_offset;
extern __declspec(dllimport) GLboolean __GLEW_EXT_polygon_offset_clamp;
extern __declspec(dllimport) GLboolean __GLEW_EXT_post_depth_coverage;
extern __declspec(dllimport) GLboolean __GLEW_EXT_provoking_vertex;
extern __declspec(dllimport) GLboolean __GLEW_EXT_pvrtc_sRGB;
extern __declspec(dllimport) GLboolean __GLEW_EXT_raster_multisample;
extern __declspec(dllimport) GLboolean __GLEW_EXT_read_format_bgra;
extern __declspec(dllimport) GLboolean __GLEW_EXT_render_snorm;
extern __declspec(dllimport) GLboolean __GLEW_EXT_rescale_normal;
extern __declspec(dllimport) GLboolean __GLEW_EXT_sRGB;
extern __declspec(dllimport) GLboolean __GLEW_EXT_sRGB_write_control;
extern __declspec(dllimport) GLboolean __GLEW_EXT_scene_marker;
extern __declspec(dllimport) GLboolean __GLEW_EXT_secondary_color;
extern __declspec(dllimport) GLboolean __GLEW_EXT_semaphore;
extern __declspec(dllimport) GLboolean __GLEW_EXT_semaphore_fd;
extern __declspec(dllimport) GLboolean __GLEW_EXT_semaphore_win32;
extern __declspec(dllimport) GLboolean __GLEW_EXT_separate_shader_objects;
extern __declspec(dllimport) GLboolean __GLEW_EXT_separate_specular_color;
extern __declspec(dllimport) GLboolean __GLEW_EXT_shader_framebuffer_fetch;
extern __declspec(dllimport) GLboolean __GLEW_EXT_shader_group_vote;
extern __declspec(dllimport) GLboolean __GLEW_EXT_shader_image_load_formatted;
extern __declspec(dllimport) GLboolean __GLEW_EXT_shader_image_load_store;
extern __declspec(dllimport) GLboolean __GLEW_EXT_shader_implicit_conversions;
extern __declspec(dllimport) GLboolean __GLEW_EXT_shader_integer_mix;
extern __declspec(dllimport) GLboolean __GLEW_EXT_shader_io_blocks;
extern __declspec(dllimport) GLboolean __GLEW_EXT_shader_non_constant_global_initializers;
extern __declspec(dllimport) GLboolean __GLEW_EXT_shader_pixel_local_storage;
extern __declspec(dllimport) GLboolean __GLEW_EXT_shader_pixel_local_storage2;
extern __declspec(dllimport) GLboolean __GLEW_EXT_shader_texture_lod;
extern __declspec(dllimport) GLboolean __GLEW_EXT_shadow_funcs;
extern __declspec(dllimport) GLboolean __GLEW_EXT_shadow_samplers;
extern __declspec(dllimport) GLboolean __GLEW_EXT_shared_texture_palette;
extern __declspec(dllimport) GLboolean __GLEW_EXT_sparse_texture;
extern __declspec(dllimport) GLboolean __GLEW_EXT_sparse_texture2;
extern __declspec(dllimport) GLboolean __GLEW_EXT_stencil_clear_tag;
extern __declspec(dllimport) GLboolean __GLEW_EXT_stencil_two_side;
extern __declspec(dllimport) GLboolean __GLEW_EXT_stencil_wrap;
extern __declspec(dllimport) GLboolean __GLEW_EXT_subtexture;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture3D;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_array;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_buffer_object;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_compression_astc_decode_mode;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_compression_astc_decode_mode_rgb9e5;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_compression_bptc;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_compression_dxt1;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_compression_latc;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_compression_rgtc;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_compression_s3tc;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_cube_map;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_cube_map_array;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_edge_clamp;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_env;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_env_add;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_env_combine;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_env_dot3;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_filter_anisotropic;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_filter_minmax;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_format_BGRA8888;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_integer;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_lod_bias;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_mirror_clamp;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_norm16;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_object;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_perturb_normal;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_rectangle;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_rg;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_sRGB;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_sRGB_R8;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_sRGB_RG8;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_sRGB_decode;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_shared_exponent;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_snorm;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_storage;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_swizzle;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_type_2_10_10_10_REV;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_view;
extern __declspec(dllimport) GLboolean __GLEW_EXT_timer_query;
extern __declspec(dllimport) GLboolean __GLEW_EXT_transform_feedback;
extern __declspec(dllimport) GLboolean __GLEW_EXT_unpack_subimage;
extern __declspec(dllimport) GLboolean __GLEW_EXT_vertex_array;
extern __declspec(dllimport) GLboolean __GLEW_EXT_vertex_array_bgra;
extern __declspec(dllimport) GLboolean __GLEW_EXT_vertex_array_setXXX;
extern __declspec(dllimport) GLboolean __GLEW_EXT_vertex_attrib_64bit;
extern __declspec(dllimport) GLboolean __GLEW_EXT_vertex_shader;
extern __declspec(dllimport) GLboolean __GLEW_EXT_vertex_weighting;
extern __declspec(dllimport) GLboolean __GLEW_EXT_win32_keyed_mutex;
extern __declspec(dllimport) GLboolean __GLEW_EXT_window_rectangles;
extern __declspec(dllimport) GLboolean __GLEW_EXT_x11_sync_object;
extern __declspec(dllimport) GLboolean __GLEW_GREMEDY_frame_terminator;
extern __declspec(dllimport) GLboolean __GLEW_GREMEDY_string_marker;
extern __declspec(dllimport) GLboolean __GLEW_HP_convolution_border_modes;
extern __declspec(dllimport) GLboolean __GLEW_HP_image_transform;
extern __declspec(dllimport) GLboolean __GLEW_HP_occlusion_test;
extern __declspec(dllimport) GLboolean __GLEW_HP_texture_lighting;
extern __declspec(dllimport) GLboolean __GLEW_IBM_cull_vertex;
extern __declspec(dllimport) GLboolean __GLEW_IBM_multimode_draw_arrays;
extern __declspec(dllimport) GLboolean __GLEW_IBM_rasterpos_clip;
extern __declspec(dllimport) GLboolean __GLEW_IBM_static_data;
extern __declspec(dllimport) GLboolean __GLEW_IBM_texture_mirrored_repeat;
extern __declspec(dllimport) GLboolean __GLEW_IBM_vertex_array_lists;
extern __declspec(dllimport) GLboolean __GLEW_INGR_color_clamp;
extern __declspec(dllimport) GLboolean __GLEW_INGR_interlace_read;
extern __declspec(dllimport) GLboolean __GLEW_INTEL_conservative_rasterization;
extern __declspec(dllimport) GLboolean __GLEW_INTEL_fragment_shader_ordering;
extern __declspec(dllimport) GLboolean __GLEW_INTEL_framebuffer_CMAA;
extern __declspec(dllimport) GLboolean __GLEW_INTEL_map_texture;
extern __declspec(dllimport) GLboolean __GLEW_INTEL_parallel_arrays;
extern __declspec(dllimport) GLboolean __GLEW_INTEL_performance_query;
extern __declspec(dllimport) GLboolean __GLEW_INTEL_texture_scissor;
extern __declspec(dllimport) GLboolean __GLEW_KHR_blend_equation_advanced;
extern __declspec(dllimport) GLboolean __GLEW_KHR_blend_equation_advanced_coherent;
extern __declspec(dllimport) GLboolean __GLEW_KHR_context_flush_control;
extern __declspec(dllimport) GLboolean __GLEW_KHR_debug;
extern __declspec(dllimport) GLboolean __GLEW_KHR_no_error;
extern __declspec(dllimport) GLboolean __GLEW_KHR_parallel_shader_compile;
extern __declspec(dllimport) GLboolean __GLEW_KHR_robust_buffer_access_behavior;
extern __declspec(dllimport) GLboolean __GLEW_KHR_robustness;
extern __declspec(dllimport) GLboolean __GLEW_KHR_texture_compression_astc_hdr;
extern __declspec(dllimport) GLboolean __GLEW_KHR_texture_compression_astc_ldr;
extern __declspec(dllimport) GLboolean __GLEW_KHR_texture_compression_astc_sliced_3d;
extern __declspec(dllimport) GLboolean __GLEW_KTX_buffer_region;
extern __declspec(dllimport) GLboolean __GLEW_MESAX_texture_stack;
extern __declspec(dllimport) GLboolean __GLEW_MESA_pack_invert;
extern __declspec(dllimport) GLboolean __GLEW_MESA_resize_buffers;
extern __declspec(dllimport) GLboolean __GLEW_MESA_shader_integer_functions;
extern __declspec(dllimport) GLboolean __GLEW_MESA_window_pos;
extern __declspec(dllimport) GLboolean __GLEW_MESA_ycbcr_texture;
extern __declspec(dllimport) GLboolean __GLEW_NVX_blend_equation_advanced_multi_draw_buffers;
extern __declspec(dllimport) GLboolean __GLEW_NVX_conditional_render;
extern __declspec(dllimport) GLboolean __GLEW_NVX_gpu_memory_info;
extern __declspec(dllimport) GLboolean __GLEW_NVX_linked_gpu_multicast;
extern __declspec(dllimport) GLboolean __GLEW_NV_3dvision_settings;
extern __declspec(dllimport) GLboolean __GLEW_NV_EGL_stream_consumer_external;
extern __declspec(dllimport) GLboolean __GLEW_NV_alpha_to_coverage_dither_control;
extern __declspec(dllimport) GLboolean __GLEW_NV_bgr;
extern __declspec(dllimport) GLboolean __GLEW_NV_bindless_multi_draw_indirect;
extern __declspec(dllimport) GLboolean __GLEW_NV_bindless_multi_draw_indirect_count;
extern __declspec(dllimport) GLboolean __GLEW_NV_bindless_texture;
extern __declspec(dllimport) GLboolean __GLEW_NV_blend_equation_advanced;
extern __declspec(dllimport) GLboolean __GLEW_NV_blend_equation_advanced_coherent;
extern __declspec(dllimport) GLboolean __GLEW_NV_blend_minmax_factor;
extern __declspec(dllimport) GLboolean __GLEW_NV_blend_square;
extern __declspec(dllimport) GLboolean __GLEW_NV_clip_space_w_scaling;
extern __declspec(dllimport) GLboolean __GLEW_NV_command_list;
extern __declspec(dllimport) GLboolean __GLEW_NV_compute_program5;
extern __declspec(dllimport) GLboolean __GLEW_NV_conditional_render;
extern __declspec(dllimport) GLboolean __GLEW_NV_conservative_raster;
extern __declspec(dllimport) GLboolean __GLEW_NV_conservative_raster_dilate;
extern __declspec(dllimport) GLboolean __GLEW_NV_conservative_raster_pre_snap_triangles;
extern __declspec(dllimport) GLboolean __GLEW_NV_copy_buffer;
extern __declspec(dllimport) GLboolean __GLEW_NV_copy_depth_to_color;
extern __declspec(dllimport) GLboolean __GLEW_NV_copy_image;
extern __declspec(dllimport) GLboolean __GLEW_NV_deep_texture3D;
extern __declspec(dllimport) GLboolean __GLEW_NV_depth_buffer_float;
extern __declspec(dllimport) GLboolean __GLEW_NV_depth_clamp;
extern __declspec(dllimport) GLboolean __GLEW_NV_depth_range_unclamped;
extern __declspec(dllimport) GLboolean __GLEW_NV_draw_buffers;
extern __declspec(dllimport) GLboolean __GLEW_NV_draw_instanced;
extern __declspec(dllimport) GLboolean __GLEW_NV_draw_texture;
extern __declspec(dllimport) GLboolean __GLEW_NV_draw_vulkan_image;
extern __declspec(dllimport) GLboolean __GLEW_NV_evaluators;
extern __declspec(dllimport) GLboolean __GLEW_NV_explicit_attrib_location;
extern __declspec(dllimport) GLboolean __GLEW_NV_explicit_multisample;
extern __declspec(dllimport) GLboolean __GLEW_NV_fbo_color_attachments;
extern __declspec(dllimport) GLboolean __GLEW_NV_fence;
extern __declspec(dllimport) GLboolean __GLEW_NV_fill_rectangle;
extern __declspec(dllimport) GLboolean __GLEW_NV_float_buffer;
extern __declspec(dllimport) GLboolean __GLEW_NV_fog_distance;
extern __declspec(dllimport) GLboolean __GLEW_NV_fragment_coverage_to_color;
extern __declspec(dllimport) GLboolean __GLEW_NV_fragment_program;
extern __declspec(dllimport) GLboolean __GLEW_NV_fragment_program2;
extern __declspec(dllimport) GLboolean __GLEW_NV_fragment_program4;
extern __declspec(dllimport) GLboolean __GLEW_NV_fragment_program_option;
extern __declspec(dllimport) GLboolean __GLEW_NV_fragment_shader_interlock;
extern __declspec(dllimport) GLboolean __GLEW_NV_framebuffer_blit;
extern __declspec(dllimport) GLboolean __GLEW_NV_framebuffer_mixed_samples;
extern __declspec(dllimport) GLboolean __GLEW_NV_framebuffer_multisample;
extern __declspec(dllimport) GLboolean __GLEW_NV_framebuffer_multisample_coverage;
extern __declspec(dllimport) GLboolean __GLEW_NV_generate_mipmap_sRGB;
extern __declspec(dllimport) GLboolean __GLEW_NV_geometry_program4;
extern __declspec(dllimport) GLboolean __GLEW_NV_geometry_shader4;
extern __declspec(dllimport) GLboolean __GLEW_NV_geometry_shader_passthrough;
extern __declspec(dllimport) GLboolean __GLEW_NV_gpu_multicast;
extern __declspec(dllimport) GLboolean __GLEW_NV_gpu_program4;
extern __declspec(dllimport) GLboolean __GLEW_NV_gpu_program5;
extern __declspec(dllimport) GLboolean __GLEW_NV_gpu_program5_mem_extended;
extern __declspec(dllimport) GLboolean __GLEW_NV_gpu_program_fp64;
extern __declspec(dllimport) GLboolean __GLEW_NV_gpu_shader5;
extern __declspec(dllimport) GLboolean __GLEW_NV_half_float;
extern __declspec(dllimport) GLboolean __GLEW_NV_image_formats;
extern __declspec(dllimport) GLboolean __GLEW_NV_instanced_arrays;
extern __declspec(dllimport) GLboolean __GLEW_NV_internalformat_sample_query;
extern __declspec(dllimport) GLboolean __GLEW_NV_light_max_exponent;
extern __declspec(dllimport) GLboolean __GLEW_NV_multisample_coverage;
extern __declspec(dllimport) GLboolean __GLEW_NV_multisample_filter_hint;
extern __declspec(dllimport) GLboolean __GLEW_NV_non_square_matrices;
extern __declspec(dllimport) GLboolean __GLEW_NV_occlusion_query;
extern __declspec(dllimport) GLboolean __GLEW_NV_pack_subimage;
extern __declspec(dllimport) GLboolean __GLEW_NV_packed_depth_stencil;
extern __declspec(dllimport) GLboolean __GLEW_NV_packed_float;
extern __declspec(dllimport) GLboolean __GLEW_NV_packed_float_linear;
extern __declspec(dllimport) GLboolean __GLEW_NV_parameter_buffer_object;
extern __declspec(dllimport) GLboolean __GLEW_NV_parameter_buffer_object2;
extern __declspec(dllimport) GLboolean __GLEW_NV_path_rendering;
extern __declspec(dllimport) GLboolean __GLEW_NV_path_rendering_shared_edge;
extern __declspec(dllimport) GLboolean __GLEW_NV_pixel_buffer_object;
extern __declspec(dllimport) GLboolean __GLEW_NV_pixel_data_range;
extern __declspec(dllimport) GLboolean __GLEW_NV_platform_binary;
extern __declspec(dllimport) GLboolean __GLEW_NV_point_sprite;
extern __declspec(dllimport) GLboolean __GLEW_NV_polygon_mode;
extern __declspec(dllimport) GLboolean __GLEW_NV_present_video;
extern __declspec(dllimport) GLboolean __GLEW_NV_primitive_restart;
extern __declspec(dllimport) GLboolean __GLEW_NV_read_depth;
extern __declspec(dllimport) GLboolean __GLEW_NV_read_depth_stencil;
extern __declspec(dllimport) GLboolean __GLEW_NV_read_stencil;
extern __declspec(dllimport) GLboolean __GLEW_NV_register_combiners;
extern __declspec(dllimport) GLboolean __GLEW_NV_register_combiners2;
extern __declspec(dllimport) GLboolean __GLEW_NV_robustness_video_memory_purge;
extern __declspec(dllimport) GLboolean __GLEW_NV_sRGB_formats;
extern __declspec(dllimport) GLboolean __GLEW_NV_sample_locations;
extern __declspec(dllimport) GLboolean __GLEW_NV_sample_mask_override_coverage;
extern __declspec(dllimport) GLboolean __GLEW_NV_shader_atomic_counters;
extern __declspec(dllimport) GLboolean __GLEW_NV_shader_atomic_float;
extern __declspec(dllimport) GLboolean __GLEW_NV_shader_atomic_float64;
extern __declspec(dllimport) GLboolean __GLEW_NV_shader_atomic_fp16_vector;
extern __declspec(dllimport) GLboolean __GLEW_NV_shader_atomic_int64;
extern __declspec(dllimport) GLboolean __GLEW_NV_shader_buffer_load;
extern __declspec(dllimport) GLboolean __GLEW_NV_shader_noperspective_interpolation;
extern __declspec(dllimport) GLboolean __GLEW_NV_shader_storage_buffer_object;
extern __declspec(dllimport) GLboolean __GLEW_NV_shader_thread_group;
extern __declspec(dllimport) GLboolean __GLEW_NV_shader_thread_shuffle;
extern __declspec(dllimport) GLboolean __GLEW_NV_shadow_samplers_array;
extern __declspec(dllimport) GLboolean __GLEW_NV_shadow_samplers_cube;
extern __declspec(dllimport) GLboolean __GLEW_NV_stereo_view_rendering;
extern __declspec(dllimport) GLboolean __GLEW_NV_tessellation_program5;
extern __declspec(dllimport) GLboolean __GLEW_NV_texgen_emboss;
extern __declspec(dllimport) GLboolean __GLEW_NV_texgen_reflection;
extern __declspec(dllimport) GLboolean __GLEW_NV_texture_array;
extern __declspec(dllimport) GLboolean __GLEW_NV_texture_barrier;
extern __declspec(dllimport) GLboolean __GLEW_NV_texture_border_clamp;
extern __declspec(dllimport) GLboolean __GLEW_NV_texture_compression_latc;
extern __declspec(dllimport) GLboolean __GLEW_NV_texture_compression_s3tc;
extern __declspec(dllimport) GLboolean __GLEW_NV_texture_compression_s3tc_update;
extern __declspec(dllimport) GLboolean __GLEW_NV_texture_compression_vtc;
extern __declspec(dllimport) GLboolean __GLEW_NV_texture_env_combine4;
extern __declspec(dllimport) GLboolean __GLEW_NV_texture_expand_normal;
extern __declspec(dllimport) GLboolean __GLEW_NV_texture_multisample;
extern __declspec(dllimport) GLboolean __GLEW_NV_texture_npot_2D_mipmap;
extern __declspec(dllimport) GLboolean __GLEW_NV_texture_rectangle;
extern __declspec(dllimport) GLboolean __GLEW_NV_texture_rectangle_compressed;
extern __declspec(dllimport) GLboolean __GLEW_NV_texture_shader;
extern __declspec(dllimport) GLboolean __GLEW_NV_texture_shader2;
extern __declspec(dllimport) GLboolean __GLEW_NV_texture_shader3;
extern __declspec(dllimport) GLboolean __GLEW_NV_transform_feedback;
extern __declspec(dllimport) GLboolean __GLEW_NV_transform_feedback2;
extern __declspec(dllimport) GLboolean __GLEW_NV_uniform_buffer_unified_memory;
extern __declspec(dllimport) GLboolean __GLEW_NV_vdpau_interop;
extern __declspec(dllimport) GLboolean __GLEW_NV_vertex_array_range;
extern __declspec(dllimport) GLboolean __GLEW_NV_vertex_array_range2;
extern __declspec(dllimport) GLboolean __GLEW_NV_vertex_attrib_integer_64bit;
extern __declspec(dllimport) GLboolean __GLEW_NV_vertex_buffer_unified_memory;
extern __declspec(dllimport) GLboolean __GLEW_NV_vertex_program;
extern __declspec(dllimport) GLboolean __GLEW_NV_vertex_program1_1;
extern __declspec(dllimport) GLboolean __GLEW_NV_vertex_program2;
extern __declspec(dllimport) GLboolean __GLEW_NV_vertex_program2_option;
extern __declspec(dllimport) GLboolean __GLEW_NV_vertex_program3;
extern __declspec(dllimport) GLboolean __GLEW_NV_vertex_program4;
extern __declspec(dllimport) GLboolean __GLEW_NV_video_capture;
extern __declspec(dllimport) GLboolean __GLEW_NV_viewport_array;
extern __declspec(dllimport) GLboolean __GLEW_NV_viewport_array2;
extern __declspec(dllimport) GLboolean __GLEW_NV_viewport_swizzle;
extern __declspec(dllimport) GLboolean __GLEW_OES_byte_coordinates;
extern __declspec(dllimport) GLboolean __GLEW_OML_interlace;
extern __declspec(dllimport) GLboolean __GLEW_OML_resample;
extern __declspec(dllimport) GLboolean __GLEW_OML_subsample;
extern __declspec(dllimport) GLboolean __GLEW_OVR_multiview;
extern __declspec(dllimport) GLboolean __GLEW_OVR_multiview2;
extern __declspec(dllimport) GLboolean __GLEW_OVR_multiview_multisampled_render_to_texture;
extern __declspec(dllimport) GLboolean __GLEW_PGI_misc_hints;
extern __declspec(dllimport) GLboolean __GLEW_PGI_vertex_hints;
extern __declspec(dllimport) GLboolean __GLEW_QCOM_alpha_test;
extern __declspec(dllimport) GLboolean __GLEW_QCOM_binning_control;
extern __declspec(dllimport) GLboolean __GLEW_QCOM_driver_control;
extern __declspec(dllimport) GLboolean __GLEW_QCOM_extended_get;
extern __declspec(dllimport) GLboolean __GLEW_QCOM_extended_get2;
extern __declspec(dllimport) GLboolean __GLEW_QCOM_framebuffer_foveated;
extern __declspec(dllimport) GLboolean __GLEW_QCOM_perfmon_global_mode;
extern __declspec(dllimport) GLboolean __GLEW_QCOM_shader_framebuffer_fetch_noncoherent;
extern __declspec(dllimport) GLboolean __GLEW_QCOM_tiled_rendering;
extern __declspec(dllimport) GLboolean __GLEW_QCOM_writeonly_rendering;
extern __declspec(dllimport) GLboolean __GLEW_REGAL_ES1_0_compatibility;
extern __declspec(dllimport) GLboolean __GLEW_REGAL_ES1_1_compatibility;
extern __declspec(dllimport) GLboolean __GLEW_REGAL_enable;
extern __declspec(dllimport) GLboolean __GLEW_REGAL_error_string;
extern __declspec(dllimport) GLboolean __GLEW_REGAL_extension_query;
extern __declspec(dllimport) GLboolean __GLEW_REGAL_log;
extern __declspec(dllimport) GLboolean __GLEW_REGAL_proc_address;
extern __declspec(dllimport) GLboolean __GLEW_REND_screen_coordinates;
extern __declspec(dllimport) GLboolean __GLEW_S3_s3tc;
extern __declspec(dllimport) GLboolean __GLEW_SGIS_clip_band_hint;
extern __declspec(dllimport) GLboolean __GLEW_SGIS_color_range;
extern __declspec(dllimport) GLboolean __GLEW_SGIS_detail_texture;
extern __declspec(dllimport) GLboolean __GLEW_SGIS_fog_function;
extern __declspec(dllimport) GLboolean __GLEW_SGIS_generate_mipmap;
extern __declspec(dllimport) GLboolean __GLEW_SGIS_line_texgen;
extern __declspec(dllimport) GLboolean __GLEW_SGIS_multisample;
extern __declspec(dllimport) GLboolean __GLEW_SGIS_multitexture;
extern __declspec(dllimport) GLboolean __GLEW_SGIS_pixel_texture;
extern __declspec(dllimport) GLboolean __GLEW_SGIS_point_line_texgen;
extern __declspec(dllimport) GLboolean __GLEW_SGIS_shared_multisample;
extern __declspec(dllimport) GLboolean __GLEW_SGIS_sharpen_texture;
extern __declspec(dllimport) GLboolean __GLEW_SGIS_texture4D;
extern __declspec(dllimport) GLboolean __GLEW_SGIS_texture_border_clamp;
extern __declspec(dllimport) GLboolean __GLEW_SGIS_texture_edge_clamp;
extern __declspec(dllimport) GLboolean __GLEW_SGIS_texture_filter4;
extern __declspec(dllimport) GLboolean __GLEW_SGIS_texture_lod;
extern __declspec(dllimport) GLboolean __GLEW_SGIS_texture_select;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_async;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_async_histogram;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_async_pixel;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_bali_g_instruments;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_bali_r_instruments;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_bali_timer_instruments;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_blend_alpha_minmax;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_blend_cadd;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_blend_cmultiply;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_calligraphic_fragment;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_clipmap;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_color_matrix_accuracy;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_color_table_index_mode;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_complex_polar;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_convolution_accuracy;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_cube_map;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_cylinder_texgen;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_datapipe;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_decimation;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_depth_pass_instrument;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_depth_texture;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_dvc;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_flush_raster;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_fog_blend;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_fog_factor_to_alpha;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_fog_layers;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_fog_offset;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_fog_patchy;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_fog_scale;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_fog_texture;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_fragment_lighting_space;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_fragment_specular_lighting;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_fragments_instrument;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_framezoom;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_icc_texture;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_igloo_interface;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_image_compression;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_impact_pixel_texture;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_instrument_error;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_interlace;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_ir_instrument1;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_line_quality_hint;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_list_priority;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_mpeg1;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_mpeg2;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_nonlinear_lighting_pervertex;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_nurbs_eval;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_occlusion_instrument;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_packed_6bytes;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_pixel_texture;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_pixel_texture_bits;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_pixel_texture_lod;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_pixel_tiles;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_polynomial_ffd;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_quad_mesh;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_reference_plane;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_resample;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_scalebias_hint;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_shadow;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_shadow_ambient;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_slim;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_spotlight_cutoff;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_sprite;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_subdiv_patch;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_subsample;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_tag_sample_buffer;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_texture_add_env;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_texture_coordinate_clamp;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_texture_lod_bias;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_texture_mipmap_anisotropic;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_texture_multi_buffer;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_texture_phase;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_texture_range;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_texture_scale_bias;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_texture_supersample;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_vector_ops;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_vertex_array_object;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_vertex_preclip;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_vertex_preclip_hint;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_ycrcb;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_ycrcb_subsample;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_ycrcba;
extern __declspec(dllimport) GLboolean __GLEW_SGI_color_matrix;
extern __declspec(dllimport) GLboolean __GLEW_SGI_color_table;
extern __declspec(dllimport) GLboolean __GLEW_SGI_complex;
extern __declspec(dllimport) GLboolean __GLEW_SGI_complex_type;
extern __declspec(dllimport) GLboolean __GLEW_SGI_fft;
extern __declspec(dllimport) GLboolean __GLEW_SGI_texture_color_table;
extern __declspec(dllimport) GLboolean __GLEW_SUNX_constant_data;
extern __declspec(dllimport) GLboolean __GLEW_SUN_convolution_border_modes;
extern __declspec(dllimport) GLboolean __GLEW_SUN_global_alpha;
extern __declspec(dllimport) GLboolean __GLEW_SUN_mesh_array;
extern __declspec(dllimport) GLboolean __GLEW_SUN_read_video_pixels;
extern __declspec(dllimport) GLboolean __GLEW_SUN_slice_accum;
extern __declspec(dllimport) GLboolean __GLEW_SUN_triangle_list;
extern __declspec(dllimport) GLboolean __GLEW_SUN_vertex;
extern __declspec(dllimport) GLboolean __GLEW_WIN_phong_shading;
extern __declspec(dllimport) GLboolean __GLEW_WIN_scene_markerXXX;
extern __declspec(dllimport) GLboolean __GLEW_WIN_specular_fog;
extern __declspec(dllimport) GLboolean __GLEW_WIN_swap_hint;
 

 







 





 

 








 
extern __declspec(dllimport) GLenum __stdcall glewInit (void);
extern __declspec(dllimport) GLboolean __stdcall glewIsSupported (const char *name);




#line 23654 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"



#line 23658 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"

extern __declspec(dllimport) GLboolean glewExperimental;
extern __declspec(dllimport) GLboolean __stdcall glewGetExtension (const char *name);
extern __declspec(dllimport) const GLubyte * __stdcall glewGetErrorString (GLenum error);
extern __declspec(dllimport) const GLubyte * __stdcall glewGetString (GLenum name);


}
#line 23667 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"




#line 23672 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"




#line 23677 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"




#line 23682 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"


 

#line 23687 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"
#line 3 "D:\\dev\\DaisyEngine\\DaisyEngine\\src\\Model.h"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\src\\Defines_Renderer.h"
#pragma once




#line 4 "D:\\dev\\DaisyEngine\\DaisyEngine\\src\\Model.h"
#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iostream"





#pragma once


#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"





#pragma once








#line 16 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"

#line 18 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"
#line 19 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"






























































































































































































































































































































































































































































#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"







#pragma once






















#line 32 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"

#line 34 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
#line 35 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"


    
#line 39 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"






    
    

#line 49 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
        
            
        

#line 54 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
    #line 55 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
#line 56 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"

#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"













#pragma once







































































































































#line 151 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"



#line 155 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"





























#line 185 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"


#line 188 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"

#line 190 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"





#line 196 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"



#line 200 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"






#line 207 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"











#line 219 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"








#line 228 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"
#line 229 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"































































































































































































































































































































































































































































































#pragma region Input Buffer SAL 1 compatibility macros



























































































































































































































































































































































































































































































































































































































































































































































































#pragma endregion Input Buffer SAL 1 compatibility macros

















































































#line 1555 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"






























#line 1586 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"
























#line 1611 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"












#line 1624 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"






































#line 1663 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"















































































































#line 1775 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"






































































































#line 1878 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"








































































































































































#line 2047 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"





































































































#line 2149 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"



















































































































































































































#line 2361 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"
extern "C" {




#line 2367 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"



































































































































































































































#line 2595 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    

    
    

#line 2634 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"









































































































































































































































#line 2868 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"









#line 2878 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"





#line 2884 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"
    
#line 2886 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"
#line 2887 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"






#line 2894 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"
#line 2895 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"






#line 2902 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"
#line 2903 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"











#line 2915 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"

































#line 2949 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"






















}
#line 2973 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"

#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\concurrencysal.h"


















#pragma once


extern "C" {
#line 24 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\concurrencysal.h"











































































































































































































































































#line 292 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\concurrencysal.h"



#line 296 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\concurrencysal.h"
















































#line 345 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\concurrencysal.h"











































#line 389 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\concurrencysal.h"


}
#line 393 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\concurrencysal.h"

#line 395 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\concurrencysal.h"
#pragma external_header(pop)
#line 2975 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"
#pragma external_header(pop)
#line 58 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"










#pragma once



#pragma pack(push, 8 )



    


        
    #line 24 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"
#line 25 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"




    


        
    #line 34 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"
#line 35 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"



    
#line 40 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"




    
#line 46 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"

#pragma warning(push)
#pragma warning(disable: 4514 4820 )


extern "C" {
#line 53 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"



#line 57 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"


    
    
        typedef unsigned __int64  uintptr_t;
    

#line 65 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"
#line 66 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"


    
    


        typedef char* va_list;
    #line 74 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"
#line 75 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"


    


#line 81 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"





#line 87 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"



#line 91 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"
    
    
#line 94 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"











#line 106 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"







#line 114 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"











#line 126 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"





#line 132 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"










#line 143 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"










#line 154 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"

    void __cdecl __va_start(va_list* , ...);

    
    



    

#line 165 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"


} 
#line 169 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"


    extern "C++"
    {
        template <typename _Ty>
        struct __vcrt_va_list_is_reference
        {
            enum : bool { __the_value = false };
        };

        template <typename _Ty>
        struct __vcrt_va_list_is_reference<_Ty&>
        {
            enum : bool { __the_value = true };
        };

        template <typename _Ty>
        struct __vcrt_va_list_is_reference<_Ty&&>
        {
            enum : bool { __the_value = true };
        };

        template <typename _Ty>
        struct __vcrt_assert_va_start_is_not_reference
        {
            static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value,
                "va_start argument must not have reference type and must not be parenthesized");
        };
    } 

    





#line 206 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"

#pragma warning(pop) 
#pragma pack(pop)
#pragma external_header(pop)
#line 59 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"

#pragma warning(push)
#pragma warning(disable: 4514 4820 )






    



    





















#line 95 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"

__pragma(pack(push, 8)) extern "C" {




    


        
    #line 106 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
#line 107 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
















    

#line 126 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"

#line 128 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
        
    #line 130 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
#line 131 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"


    

#line 136 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
        
    #line 138 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
#line 139 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"





#line 145 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
    
    
#line 148 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"




    
#line 154 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"








    


#line 166 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"



#line 170 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
    
#line 172 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"




    
#line 178 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"


    
        
        
    

#line 186 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
#line 187 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"






    typedef unsigned __int64 size_t;
    typedef __int64          ptrdiff_t;
    typedef __int64          intptr_t;




#line 201 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"


    typedef bool  __vcrt_bool;






#line 211 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"



    
#line 216 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"






    
#line 224 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"








    
        
    

#line 237 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
#line 238 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"


    


#line 244 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"



#line 248 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"


    extern "C++"
    {
        template <typename _CountofType, size_t _SizeOfArray>
        char (*__countof_helper(__unaligned _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];

        
    }


#line 260 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"



#line 264 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"


    

#line 269 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
        
    #line 271 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"


#line 274 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"


    
        
    

#line 281 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
#line 282 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"


    
        
    

#line 289 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
#line 290 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"


    

#line 295 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
        
    #line 297 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
#line 298 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"





#line 304 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"



#line 308 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"



    


        
    

#line 318 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
#line 319 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"


    


#line 325 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"









    
        
    

#line 339 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
#line 340 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"









#line 350 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"


    


        




    #line 361 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
#line 362 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"



#line 366 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"


    
        
    


#line 374 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
#line 375 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"


    void __cdecl __security_init_cookie(void);

    


#line 383 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"


#line 386 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
        void __cdecl __security_check_cookie( uintptr_t _StackCookie);
        __declspec(noreturn) void __cdecl __report_gsfailure( uintptr_t _StackCookie);
    #line 389 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
#line 390 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"

extern uintptr_t __security_cookie;


    
    
    
#line 398 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"

} __pragma(pack(pop))

#pragma warning(pop) 

#line 404 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
#pragma external_header(pop)
#line 466 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"
#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#pragma once

























#line 33 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 39 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 45 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 51 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 57 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 63 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 69 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 75 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 81 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 87 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 93 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 99 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 105 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 111 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 117 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 123 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 129 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 135 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 141 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 147 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 153 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 159 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 165 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 171 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 177 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 183 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 189 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 195 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 201 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 207 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 213 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 219 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 225 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 231 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 237 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 243 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 249 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 255 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 261 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 267 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 273 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 279 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 285 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 291 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 297 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"






#line 304 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 310 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 316 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 322 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 328 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 334 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 340 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 346 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 352 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 358 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 364 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 370 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 376 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 382 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 388 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 394 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 400 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 406 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 412 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 418 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 424 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 430 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 436 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 442 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 448 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 454 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 460 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 466 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 472 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 478 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 484 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 490 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 496 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 502 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 508 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 514 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"






#line 521 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 527 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 533 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 539 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"






#line 546 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 552 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 558 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"







#line 566 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 572 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 578 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 584 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"



#line 588 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"

#line 590 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"
#line 591 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"
#pragma external_header(pop)
#line 467 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"





#line 473 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"

#line 475 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"














#line 490 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"

#line 492 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"
#line 493 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 497 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 501 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"







#line 509 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"













#line 523 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"










#line 534 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 538 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"

#line 540 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"





















































































#line 626 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"































#line 658 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"

#line 660 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"







#line 668 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"







#line 676 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"







#line 684 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"













#line 698 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"




#line 703 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"

#line 705 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"




#line 710 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"

#line 712 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 716 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"






































#line 755 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"






















#line 778 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"
#line 779 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"






#line 786 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"
#line 787 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"











#line 799 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 803 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"
#line 804 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"







#line 812 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"

#line 814 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"
#line 815 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"










#line 826 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"

#line 828 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 832 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"


#line 835 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"


#line 838 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"
#line 839 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 843 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 847 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"









#line 857 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"






#line 864 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"




#line 869 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"

#line 871 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"




#line 876 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"

#line 878 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"






#line 885 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"




#line 890 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"




#line 895 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 899 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"




#line 904 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"




#line 909 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"







#line 917 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"




#line 922 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"














#line 937 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"






#line 944 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"










#line 955 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"










#line 966 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"





#line 972 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"








#line 981 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"
#line 982 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"














#line 998 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"









#line 1009 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"











#line 1022 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"












#line 1036 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"











#line 1049 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"













#line 1064 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"











#line 1077 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"










#line 1089 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"










#line 1101 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"











#line 1114 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"















#line 1131 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"










#line 1143 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"
















#line 1161 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"
















#line 1178 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"















#line 1195 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"












#line 1209 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"











#line 1221 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"












#line 1234 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"












#line 1248 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"











#line 1261 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"









#line 1271 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"











#line 1284 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"










#line 1296 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"










#line 1308 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"









#line 1319 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"









#line 1330 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"










#line 1342 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"










#line 1354 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"








#line 1364 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"

#line 1366 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"








#line 1376 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"

#line 1378 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"









#line 1388 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"










#line 1399 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"














#line 1414 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 1418 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 1422 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 1426 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 1430 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 1434 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 1438 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 1442 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 1446 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 1450 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 1454 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"






#line 1461 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"




#line 1466 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"





#line 1472 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"




#line 1477 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"




#line 1482 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"


















#line 1501 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"


























#line 1528 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"





#line 1534 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"

















#line 1552 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"






#line 1559 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"






#line 1566 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 1570 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"





#line 1576 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"

#line 1578 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"
#line 1579 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 1583 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"






























#line 1614 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"










#line 1625 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"
#line 1626 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"






#line 1633 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"
#line 1634 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"








#line 1643 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"








#line 1652 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"








#line 1661 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"





#line 1667 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"

























































#line 1725 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"






#line 1732 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"







#line 1740 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 1744 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"

#line 1746 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"






#line 1753 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"
#line 1754 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 1758 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 1762 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"




#line 1767 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"

#line 1769 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"
#line 1770 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"





#line 1776 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 1780 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"

#line 1782 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"





#line 1788 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"





































#line 1826 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 1830 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 1834 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"












#line 1847 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"


#line 1850 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"


#line 1853 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"
#line 1854 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"





#line 1860 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"







#line 1868 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"





#line 1874 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"

#line 1876 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"
#line 1877 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"
#pragma external_header(pop)
#line 10 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iostream"

#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\istream"





#pragma once




#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ostream"





#pragma once




#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ios"





#pragma once




#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xlocnum"





#pragma once




#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\climits"





#pragma once





#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits.h"







#pragma once




#pragma warning(push)
#pragma warning(disable: 4514 4820 )

__pragma(pack(push, 8)) extern "C" {







    
    



#line 30 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits.h"
































    
    
        
    

#line 68 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits.h"
#line 69 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits.h"





#line 75 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits.h"

} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 13 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\climits"

#line 15 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\climits"
#line 16 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\climits"
#pragma external_header(pop)
#line 12 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xlocnum"
#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"





#pragma once


#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"





#pragma once










#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\crtdbg.h"







#pragma once



#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"







#pragma once









    
        
        
            
        











#line 35 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
    

#line 38 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
#line 39 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"


    
#line 43 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"


    
        
    

#line 50 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
#line 51 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"

















    


        
    #line 73 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
#line 74 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"



    
#line 79 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"














    
#line 95 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"


    











        
    #line 111 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
#line 112 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"


    


        
    #line 119 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
#line 120 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"

#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {







    

#line 136 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
        
    

#line 140 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
#line 141 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"




    
#line 147 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"


    

#line 152 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
        
    

#line 156 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
#line 157 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"



#line 161 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
    
#line 163 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"


    


#line 169 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"





#line 175 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
    
#line 177 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"





    
#line 184 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"



#line 188 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
    
#line 190 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"









    
#line 201 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"













    


        
    #line 219 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
#line 220 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"



#line 224 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
    
#line 226 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"



#line 230 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
    
#line 232 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"



#line 236 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
    
#line 238 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"


    
        
    

#line 245 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
#line 246 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"








extern "C++"
{
    template<bool _Enable, typename _Ty>
    struct _CrtEnableIf;

    template<typename _Ty>
    struct _CrtEnableIf<true, _Ty>
    {
        typedef _Ty _Type;
    };
}
#line 266 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"


    typedef bool  __crt_bool;






#line 276 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"










    
        
    #line 289 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"








#line 298 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"



















    

#line 320 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
        
    #line 322 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
#line 323 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"



#line 327 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"


    
#line 331 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"


 
  
   
  

#line 339 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
 





#line 346 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
#line 347 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"


 

#line 352 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
   
 #line 354 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
#line 355 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
















__declspec(dllimport) void __cdecl _invalid_parameter_noinfo(void);
__declspec(dllimport) __declspec(noreturn) void __cdecl _invalid_parameter_noinfo_noreturn(void);

__declspec(noreturn)
__declspec(dllimport) void __cdecl _invoke_watson(
     wchar_t const* _Expression,
     wchar_t const* _FunctionName,
     wchar_t const* _FileName,
           unsigned int _LineNo,
           uintptr_t _Reserved);


    



        
        
        
        
        
        
        
        
        
        
        
        

    #line 401 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
#line 402 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"












    


#line 419 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"



#line 423 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"


    


        


    #line 432 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
#line 433 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"









    






        
    #line 451 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
#line 452 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"


    


        
    #line 459 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
#line 460 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"



#line 464 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"













#line 478 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"















#line 494 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"





    
#line 501 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"



#line 505 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"


    

#line 510 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
#line 511 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"


    


        


            
        #line 521 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
    #line 522 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
#line 523 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"



#line 527 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"





#line 533 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"


    


        



    #line 543 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
#line 544 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"


    
        
    



#line 553 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"

    
        
        
        
    



#line 563 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"

    
        
              
        

#line 570 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
    



#line 575 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"

    
        
    



#line 583 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"

    
        
    



#line 591 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
#line 592 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"


    
#line 596 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"








typedef int                           errno_t;
typedef unsigned short                wint_t;
typedef unsigned short                wctype_t;
typedef long                          __time32_t;
typedef __int64                       __time64_t;

typedef struct __crt_locale_data_public
{
      unsigned short const* _locale_pctype;
     int _locale_mb_cur_max;
               unsigned int _locale_lc_codepage;
} __crt_locale_data_public;

typedef struct __crt_locale_pointers
{
    struct __crt_locale_data*    locinfo;
    struct __crt_multibyte_data* mbcinfo;
} __crt_locale_pointers;

typedef __crt_locale_pointers* _locale_t;

typedef struct _Mbstatet
{ 
    unsigned long _Wchar;
    unsigned short _Byte, _State;
} _Mbstatet;

typedef _Mbstatet mbstate_t;



#line 636 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"



#line 640 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"


    


        typedef __time64_t time_t;
    #line 647 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
#line 648 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"



    
#line 653 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"


    typedef size_t rsize_t;
#line 657 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"










    

        










        










        










        










        










        










        










        










        










        












        












        
















    














#line 827 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
#line 828 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"












































































    













































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1879 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"

        
        
        
        

        

            


            


            


            


            


            


            


            


            



            



            


            


            


            


            


            


            


            


            


            


            



            



            



            


            



            




            

            




            

            




            

            




            

            




            

            




            

            




            

            




            

        











































#line 2069 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
    #line 2070 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
#line 2071 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"

} __pragma(pack(pop))


#pragma warning(pop) 
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\crtdbg.h"
#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime_new_debug.h"







#pragma once

#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime_new.h"







#pragma once



#pragma warning(push)
#pragma warning(disable: 4514 4820 )
#pragma warning(disable: 4985) 


extern "C++" {

#pragma pack(push, 8 )





namespace std
{
    enum class align_val_t : size_t {};
}
#line 30 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime_new.h"



    namespace std
    {
        struct nothrow_t {
            explicit nothrow_t() = default;
        };

        


            extern nothrow_t const nothrow;
        #line 44 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime_new.h"
    }
#line 46 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime_new.h"

[[nodiscard]]   __declspec(allocator)
void* __cdecl operator new(
    size_t _Size
    );

[[nodiscard]]    __declspec(allocator)
void* __cdecl operator new(
    size_t _Size,
    ::std::nothrow_t const&
    ) noexcept;

[[nodiscard]]   __declspec(allocator)
void* __cdecl operator new[](
    size_t _Size
    );

[[nodiscard]]    __declspec(allocator)
void* __cdecl operator new[](
    size_t _Size,
    ::std::nothrow_t const&
    ) noexcept;

void __cdecl operator delete(
    void* _Block
    ) noexcept;

void __cdecl operator delete(
    void* _Block,
    ::std::nothrow_t const&
    ) noexcept;

void __cdecl operator delete[](
    void* _Block
    ) noexcept;

void __cdecl operator delete[](
    void* _Block,
    ::std::nothrow_t const&
    ) noexcept;

void __cdecl operator delete(
    void*  _Block,
    size_t _Size
    ) noexcept;

void __cdecl operator delete[](
    void* _Block,
    size_t _Size
    ) noexcept;


[[nodiscard]]   __declspec(allocator)
void* __cdecl operator new(
    size_t             _Size,
    ::std::align_val_t _Al
    );

[[nodiscard]]    __declspec(allocator)
void* __cdecl operator new(
    size_t                  _Size,
    ::std::align_val_t      _Al,
    ::std::nothrow_t const&
    ) noexcept;


[[nodiscard]]   __declspec(allocator)
void* __cdecl operator new[](
    size_t             _Size,
    ::std::align_val_t _Al
    );

[[nodiscard]]    __declspec(allocator)
void* __cdecl operator new[](
    size_t                  _Size,
    ::std::align_val_t      _Al,
    ::std::nothrow_t const&
    ) noexcept;

void __cdecl operator delete(
    void*              _Block,
    ::std::align_val_t _Al
    ) noexcept;

void __cdecl operator delete(
    void*                   _Block,
    ::std::align_val_t      _Al,
    ::std::nothrow_t const&
    ) noexcept;

void __cdecl operator delete[](
    void*              _Block,
    ::std::align_val_t _Al
    ) noexcept;

void __cdecl operator delete[](
    void*                   _Block,
    ::std::align_val_t      _Al,
    ::std::nothrow_t const&
    ) noexcept;

void __cdecl operator delete(
    void*              _Block,
    size_t             _Size,
    ::std::align_val_t _Al
    ) noexcept;

void __cdecl operator delete[](
    void*              _Block,
    size_t             _Size,
    ::std::align_val_t _Al
    ) noexcept;
#line 159 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime_new.h"

#pragma warning(push)
#pragma warning(disable: 4577) 
#pragma warning(disable: 4514) 

    
    [[nodiscard]] [[msvc::constexpr]]   
    inline void* __cdecl operator new(size_t _Size,
         void* _Where) noexcept
    {
        (void)_Size;
        return _Where;
    }

    inline void __cdecl operator delete(void*, void*) noexcept
    {
        return;
    }
#line 178 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime_new.h"


    
    [[nodiscard]]   
    inline void* __cdecl operator new[](size_t _Size,
         void* _Where) noexcept
    {
        (void)_Size;
        return _Where;
    }

    inline void __cdecl operator delete[](void*, void*) noexcept
    {
    }
#line 193 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime_new.h"
#pragma warning(pop)



#pragma pack(pop)

} 
#line 201 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime_new.h"

#pragma warning(pop) 
#pragma external_header(pop)
#line 11 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime_new_debug.h"

#pragma warning(push)
#pragma warning(disable: 4514 4820 )


extern "C++" {

#pragma pack(push, 8 )






    [[nodiscard]]   
    __declspec(allocator) void* __cdecl operator new(
           size_t      _Size,
           int         _BlockUse,
         char const* _FileName,
           int         _LineNumber
        );

    [[nodiscard]]   
    __declspec(allocator) void* __cdecl operator new[](
           size_t      _Size,
           int         _BlockUse,
         char const* _FileName,
           int         _LineNumber
        );

    void __cdecl operator delete(
        void*       _Block,
        int         _BlockUse,
        char const* _FileName,
        int         _LineNumber
        ) noexcept;

    void __cdecl operator delete[](
        void*       _Block,
        int         _BlockUse,
        char const* _FileName,
        int         _LineNumber
        ) noexcept;

#line 56 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime_new_debug.h"



#pragma pack(pop)

} 
#line 63 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime_new_debug.h"

#pragma warning(pop) 
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\crtdbg.h"

#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {



typedef void* _HFILE; 

























typedef int (__cdecl * _CRT_REPORT_HOOK )(int, char*,    int*);
typedef int (__cdecl * _CRT_REPORT_HOOKW)(int, wchar_t*, int*);





typedef int (__cdecl * _CRT_ALLOC_HOOK)(int, void*, size_t, int, long, unsigned char const*, int);























































typedef void (__cdecl * _CRT_DUMP_CLIENT)(void*, size_t);





struct _CrtMemBlockHeader;

typedef struct _CrtMemState
{
    struct _CrtMemBlockHeader* pBlockHeader;
    size_t lCounts[5 ];
    size_t lSizes[5 ];
    size_t lHighWaterCount;
    size_t lTotalCount;
} _CrtMemState;



    
    

    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
























































































#line 239 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\crtdbg.h"










    
    
    
    
    
    
    

    
    
    
    
    
    
    
    

    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

















































































































































































































































































































#line 590 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\crtdbg.h"











    
    
    
    
    
    
    

















































































#line 690 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\crtdbg.h"











    

    
        
    #line 706 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\crtdbg.h"

    
        
    #line 710 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\crtdbg.h"

    
        
    #line 714 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\crtdbg.h"

    
    

    
    

    
    

    
    












































#line 771 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\crtdbg.h"













    
#line 786 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\crtdbg.h"



























} __pragma(pack(pop))

#pragma warning(pop) 
#line 817 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\crtdbg.h"
#pragma external_header(pop)
#line 18 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"
#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\crtdefs.h"




















    

#line 24 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\crtdefs.h"
        
    #line 26 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\crtdefs.h"
#line 27 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\crtdefs.h"



    

#line 33 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\crtdefs.h"
        
    #line 35 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\crtdefs.h"
#line 36 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\crtdefs.h"



    

#line 42 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\crtdefs.h"
        
    #line 44 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\crtdefs.h"
#line 45 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\crtdefs.h"





    


#line 54 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\crtdefs.h"
        
        
    


#line 60 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\crtdefs.h"
#line 61 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\crtdefs.h"


    

#line 66 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\crtdefs.h"
        
            
        

#line 71 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\crtdefs.h"
    #line 72 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\crtdefs.h"
#line 73 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\crtdefs.h"


    

#line 78 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\crtdefs.h"

#line 80 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\crtdefs.h"
        
    #line 82 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\crtdefs.h"
#line 83 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\crtdefs.h"
#pragma external_header(pop)
#line 19 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"

#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )












#line 36 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"

#line 38 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"















#line 54 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"
#line 55 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"
#line 56 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"






















































#line 111 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"
#line 112 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"









#line 122 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"

#line 124 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"
#line 125 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"




#line 130 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"

#line 132 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"

#line 134 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"

#line 136 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"


#pragma detect_mismatch("_MSC_VER", "1900")
#line 140 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"


#pragma detect_mismatch("_ITERATOR_DEBUG_LEVEL", "0" )
#line 144 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"




#line 149 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"

#line 151 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"
#pragma detect_mismatch("RuntimeLibrary", "MD_DynamicRelease")


#line 155 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"
#line 156 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"






#line 163 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"
#line 164 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"



#line 168 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"






#line 175 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"

#line 177 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"
#line 178 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"





























#line 208 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"





#line 214 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"





#line 220 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"






#line 227 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"
#line 228 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"



#line 232 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"

#line 234 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"


#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\use_ansi.h"





#pragma once








#line 16 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\use_ansi.h"
















#line 33 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\use_ansi.h"









#line 43 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\use_ansi.h"




#line 48 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\use_ansi.h"

#pragma comment(lib, "msvcprt" "" "" )






#line 57 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\use_ansi.h"

#line 59 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\use_ansi.h"

#line 61 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\use_ansi.h"
#pragma external_header(pop)
#line 237 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"

















#line 255 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"






#line 262 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"
#line 263 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"



#line 267 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"






#line 274 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"
#line 275 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"












#line 288 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"



#line 292 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"
#line 293 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"






#line 300 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"
#line 301 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"






#line 308 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"
#line 309 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"




#line 314 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"

#line 316 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"
#line 317 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"
















#line 334 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"

#line 336 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"
#line 337 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"



#line 341 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"



#line 345 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"

namespace std {
enum _Uninitialized { 
    _Noinit
};

extern "C++" class __declspec(dllimport) _Lockit { 
public:














    __thiscall _Lockit() noexcept;
    explicit __thiscall _Lockit(int) noexcept; 
    __thiscall ~_Lockit() noexcept; 
#line 371 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"

    static void __cdecl _Lockit_ctor(int) noexcept;
    static void __cdecl _Lockit_dtor(int) noexcept;

private:
    static void __cdecl _Lockit_ctor(_Lockit*) noexcept;
    static void __cdecl _Lockit_ctor(_Lockit*, int) noexcept;
    static void __cdecl _Lockit_dtor(_Lockit*) noexcept;

public:
     _Lockit(const _Lockit&)            = delete;
    _Lockit&  operator=(const _Lockit&) = delete;

private:
    int _Locktype;
};



































































#line 455 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"

















































#line 505 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"
}



#pragma warning(pop)
#pragma pack(pop)
#line 512 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"
#line 513 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"
#pragma external_header(pop)
#line 10 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"


#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cstdlib"





#pragma once





#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\math.h"










#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_math.h"







#pragma once





#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {


    
    
    struct _exception
    {
        int    type;   
        char*  name;   
        double arg1;   
        double arg2;   
        double retval; 
    };

    
    
    
        

        struct _complex
        {
            double x, y; 
        };

        


#line 46 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_math.h"
    #line 47 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_math.h"
#line 48 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_math.h"










#line 59 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_math.h"
    typedef float  float_t;
    typedef double double_t;
#line 62 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_math.h"















    
        extern double const _HUGE;
    

#line 82 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_math.h"
#line 83 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_math.h"


    
#line 87 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_math.h"











#line 99 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_math.h"












































































void __cdecl _fperrraise( int _Except);

 __declspec(dllimport) short __cdecl _dclass( double _X);
 __declspec(dllimport) short __cdecl _ldclass( long double _X);
 __declspec(dllimport) short __cdecl _fdclass( float _X);

 __declspec(dllimport) int __cdecl _dsign( double _X);
 __declspec(dllimport) int __cdecl _ldsign( long double _X);
 __declspec(dllimport) int __cdecl _fdsign( float _X);

 __declspec(dllimport) int __cdecl _dpcomp( double _X,  double _Y);
 __declspec(dllimport) int __cdecl _ldpcomp( long double _X,  long double _Y);
 __declspec(dllimport) int __cdecl _fdpcomp( float _X,  float _Y);

 __declspec(dllimport) short __cdecl _dtest( double* _Px);
 __declspec(dllimport) short __cdecl _ldtest( long double* _Px);
 __declspec(dllimport) short __cdecl _fdtest( float* _Px);

__declspec(dllimport) short __cdecl _d_int( double* _Px,  short _Xexp);
__declspec(dllimport) short __cdecl _ld_int( long double* _Px,  short _Xexp);
__declspec(dllimport) short __cdecl _fd_int( float* _Px,  short _Xexp);

__declspec(dllimport) short __cdecl _dscale( double* _Px,  long _Lexp);
__declspec(dllimport) short __cdecl _ldscale( long double* _Px,  long _Lexp);
__declspec(dllimport) short __cdecl _fdscale( float* _Px,  long _Lexp);

__declspec(dllimport) short __cdecl _dunscale( short* _Pex,  double* _Px);
__declspec(dllimport) short __cdecl _ldunscale( short* _Pex,  long double* _Px);
__declspec(dllimport) short __cdecl _fdunscale( short* _Pex,  float* _Px);

 __declspec(dllimport) short __cdecl _dexp( double* _Px,  double _Y,  long _Eoff);
 __declspec(dllimport) short __cdecl _ldexp( long double* _Px,  long double _Y,  long _Eoff);
 __declspec(dllimport) short __cdecl _fdexp( float* _Px,  float _Y,  long _Eoff);

 __declspec(dllimport) short __cdecl _dnorm( unsigned short* _Ps);
 __declspec(dllimport) short __cdecl _fdnorm( unsigned short* _Ps);

 __declspec(dllimport) double __cdecl _dpoly( double _X,  double const* _Tab,  int _N);
 __declspec(dllimport) long double __cdecl _ldpoly( long double _X,  long double const* _Tab,  int _N);
 __declspec(dllimport) float __cdecl _fdpoly( float _X,  float const* _Tab,  int _N);

 __declspec(dllimport) double __cdecl _dlog( double _X,  int _Baseflag);
 __declspec(dllimport) long double __cdecl _ldlog( long double _X,  int _Baseflag);
 __declspec(dllimport) float __cdecl _fdlog( float _X,  int _Baseflag);

 __declspec(dllimport) double __cdecl _dsin( double _X,  unsigned int _Qoff);
 __declspec(dllimport) long double __cdecl _ldsin( long double _X,  unsigned int _Qoff);
 __declspec(dllimport) float __cdecl _fdsin( float _X,  unsigned int _Qoff);


typedef union
{   
    unsigned short _Sh[4];
    double _Val;
} _double_val;


typedef union
{   
    unsigned short _Sh[2];
    float _Val;
} _float_val;


typedef union
{   
    unsigned short _Sh[4];
    long double _Val;
} _ldouble_val;

typedef union
{   
    unsigned short _Word[4];
    float _Float;
    double _Double;
    long double _Long_double;
} _float_const;

extern const _float_const _Denorm_C,  _Inf_C,  _Nan_C,  _Snan_C, _Hugeval_C;
extern const _float_const _FDenorm_C, _FInf_C, _FNan_C, _FSnan_C;
extern const _float_const _LDenorm_C, _LInf_C, _LNan_C, _LSnan_C;

extern const _float_const _Eps_C,  _Rteps_C;
extern const _float_const _FEps_C, _FRteps_C;
extern const _float_const _LEps_C, _LRteps_C;

extern const double      _Zero_C,  _Xbig_C;
extern const float       _FZero_C, _FXbig_C;
extern const long double _LZero_C, _LXbig_C;




























extern "C++"
{
     inline int fpclassify( float _X) throw()
    {
        return _fdtest(&_X);
    }

     inline int fpclassify( double _X) throw()
    {
        return _dtest(&_X);
    }

     inline int fpclassify( long double _X) throw()
    {
        return _ldtest(&_X);
    }

     inline bool signbit( float _X) throw()
    {
        return _fdsign(_X) != 0;
    }

     inline bool signbit( double _X) throw()
    {
        return _dsign(_X) != 0;
    }

     inline bool signbit( long double _X) throw()
    {
        return _ldsign(_X) != 0;
    }

     inline int _fpcomp( float _X,  float _Y) throw()
    {
        return _fdpcomp(_X, _Y);
    }

     inline int _fpcomp( double _X,  double _Y) throw()
    {
        return _dpcomp(_X, _Y);
    }

     inline int _fpcomp( long double _X,  long double _Y) throw()
    {
        return _ldpcomp(_X, _Y);
    }

    template <class _Trc, class _Tre> struct _Combined_type
    {   
        typedef float _Type;
    };

    template <> struct _Combined_type<float, double>
    {   
        typedef double _Type;
    };

    template <> struct _Combined_type<float, long double>
    {   
        typedef long double _Type;
    };

    template <class _Ty, class _T2> struct _Real_widened
    {   
        typedef long double _Type;
    };

    template <> struct _Real_widened<float, float>
    {   
        typedef float _Type;
    };

    template <> struct _Real_widened<float, double>
    {   
        typedef double _Type;
    };

    template <> struct _Real_widened<double, float>
    {   
        typedef double _Type;
    };

    template <> struct _Real_widened<double, double>
    {   
        typedef double _Type;
    };

    template <class _Ty> struct _Real_type
    {   
        typedef double _Type;   
    };

    template <> struct _Real_type<float>
    {   
        typedef float _Type;
    };

    template <> struct _Real_type<long double>
    {   
        typedef long double _Type;
    };

    template <class _T1, class _T2>
     inline int _fpcomp( _T1 _X,  _T2 _Y) throw()
    {   
        typedef typename _Combined_type<float,
            typename _Real_widened<
            typename _Real_type<_T1>::_Type,
            typename _Real_type<_T2>::_Type>::_Type>::_Type _Tw;
        return _fpcomp((_Tw)_X, (_Tw)_Y);
    }

    template <class _Ty>
     inline bool isfinite( _Ty _X) throw()
    {
        return fpclassify(_X) <= 0;
    }

    template <class _Ty>
     inline bool isinf( _Ty _X) throw()
    {
        return fpclassify(_X) == 1 ;
    }

    template <class _Ty>
     inline bool isnan( _Ty _X) throw()
    {
        return fpclassify(_X) == 2 ;
    }

    template <class _Ty>
     inline bool isnormal( _Ty _X) throw()
    {
        return fpclassify(_X) == (-1) ;
    }

    template <class _Ty1, class _Ty2>
     inline bool isgreater( _Ty1 _X,  _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & 4 ) != 0;
    }

    template <class _Ty1, class _Ty2>
     inline bool isgreaterequal( _Ty1 _X,  _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (2 | 4 )) != 0;
    }

    template <class _Ty1, class _Ty2>
     inline bool isless( _Ty1 _X,  _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & 1 ) != 0;
    }

    template <class _Ty1, class _Ty2>
     inline bool islessequal( _Ty1 _X,  _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (1 | 2 )) != 0;
    }

    template <class _Ty1, class _Ty2>
     inline bool islessgreater( _Ty1 _X,  _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (1 | 4 )) != 0;
    }

    template <class _Ty1, class _Ty2>
     inline bool isunordered( _Ty1 _X,  _Ty2 _Y) throw()
    {
        return _fpcomp(_X, _Y) == 0;
    }
}  
#line 465 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_math.h"





     int       __cdecl abs( int _X);
     long      __cdecl labs( long _X);
     long long __cdecl llabs( long long _X);

     double __cdecl acos( double _X);
     double __cdecl asin( double _X);
     double __cdecl atan( double _X);
     double __cdecl atan2( double _Y,  double _X);

     double __cdecl cos( double _X);
     double __cdecl cosh( double _X);
     double __cdecl exp( double _X);
      double __cdecl fabs( double _X);
     double __cdecl fmod( double _X,  double _Y);
     double __cdecl log( double _X);
     double __cdecl log10( double _X);
     double __cdecl pow( double _X,  double _Y);
     double __cdecl sin( double _X);
     double __cdecl sinh( double _X);
      double __cdecl sqrt( double _X);
     double __cdecl tan( double _X);
     double __cdecl tanh( double _X);

     __declspec(dllimport) double    __cdecl acosh( double _X);
     __declspec(dllimport) double    __cdecl asinh( double _X);
     __declspec(dllimport) double    __cdecl atanh( double _X);
     __declspec(dllimport)  double    __cdecl atof( char const* _String);
     __declspec(dllimport)  double    __cdecl _atof_l( char const* _String,  _locale_t _Locale);
     __declspec(dllimport) double    __cdecl _cabs( struct _complex _Complex_value);
     __declspec(dllimport) double    __cdecl cbrt( double _X);
     __declspec(dllimport) double    __cdecl ceil( double _X);
     __declspec(dllimport) double    __cdecl _chgsign( double _X);
     __declspec(dllimport) double    __cdecl copysign( double _Number,  double _Sign);
     __declspec(dllimport) double    __cdecl _copysign( double _Number,  double _Sign);
     __declspec(dllimport) double    __cdecl erf( double _X);
     __declspec(dllimport) double    __cdecl erfc( double _X);
     __declspec(dllimport) double    __cdecl exp2( double _X);
     __declspec(dllimport) double    __cdecl expm1( double _X);
     __declspec(dllimport) double    __cdecl fdim( double _X,  double _Y);
     __declspec(dllimport) double    __cdecl floor( double _X);
     __declspec(dllimport) double    __cdecl fma( double _X,  double _Y,  double _Z);
     __declspec(dllimport) double    __cdecl fmax( double _X,  double _Y);
     __declspec(dllimport) double    __cdecl fmin( double _X,  double _Y);
     __declspec(dllimport) double    __cdecl frexp( double _X,  int* _Y);
     __declspec(dllimport) double    __cdecl hypot( double _X,  double _Y);
     __declspec(dllimport) double    __cdecl _hypot( double _X,  double _Y);
     __declspec(dllimport) int       __cdecl ilogb( double _X);
     __declspec(dllimport) double    __cdecl ldexp( double _X,  int _Y);
     __declspec(dllimport) double    __cdecl lgamma( double _X);
     __declspec(dllimport) long long __cdecl llrint( double _X);
     __declspec(dllimport) long long __cdecl llround( double _X);
     __declspec(dllimport) double    __cdecl log1p( double _X);
     __declspec(dllimport) double    __cdecl log2( double _X);
     __declspec(dllimport) double    __cdecl logb( double _X);
     __declspec(dllimport) long      __cdecl lrint( double _X);
     __declspec(dllimport) long      __cdecl lround( double _X);

    int __cdecl _matherr( struct _exception* _Except);

     __declspec(dllimport) double __cdecl modf( double _X,  double* _Y);
     __declspec(dllimport) double __cdecl nan( char const* _X);
     __declspec(dllimport) double __cdecl nearbyint( double _X);
     __declspec(dllimport) double __cdecl nextafter( double _X,  double _Y);
     __declspec(dllimport) double __cdecl nexttoward( double _X,  long double _Y);
     __declspec(dllimport) double __cdecl remainder( double _X,  double _Y);
     __declspec(dllimport) double __cdecl remquo( double _X,  double _Y,  int* _Z);
     __declspec(dllimport) double __cdecl rint( double _X);
     __declspec(dllimport) double __cdecl round( double _X);
     __declspec(dllimport) double __cdecl scalbln( double _X,  long _Y);
     __declspec(dllimport) double __cdecl scalbn( double _X,  int _Y);
     __declspec(dllimport) double __cdecl tgamma( double _X);
     __declspec(dllimport) double __cdecl trunc( double _X);
     __declspec(dllimport) double __cdecl _j0( double _X );
     __declspec(dllimport) double __cdecl _j1( double _X );
     __declspec(dllimport) double __cdecl _jn(int _X,  double _Y);
     __declspec(dllimport) double __cdecl _y0( double _X);
     __declspec(dllimport) double __cdecl _y1( double _X);
     __declspec(dllimport) double __cdecl _yn( int _X,  double _Y);

     __declspec(dllimport) float     __cdecl acoshf( float _X);
     __declspec(dllimport) float     __cdecl asinhf( float _X);
     __declspec(dllimport) float     __cdecl atanhf( float _X);
     __declspec(dllimport) float     __cdecl cbrtf( float _X);
     __declspec(dllimport) float     __cdecl _chgsignf( float _X);
     __declspec(dllimport) float     __cdecl copysignf( float _Number,  float _Sign);
     __declspec(dllimport) float     __cdecl _copysignf( float _Number,  float _Sign);
     __declspec(dllimport) float     __cdecl erff( float _X);
     __declspec(dllimport) float     __cdecl erfcf( float _X);
     __declspec(dllimport) float     __cdecl expm1f( float _X);
     __declspec(dllimport) float     __cdecl exp2f( float _X);
     __declspec(dllimport) float     __cdecl fdimf( float _X,  float _Y);
     __declspec(dllimport) float     __cdecl fmaf( float _X,  float _Y,  float _Z);
     __declspec(dllimport) float     __cdecl fmaxf( float _X,  float _Y);
     __declspec(dllimport) float     __cdecl fminf( float _X,  float _Y);
     __declspec(dllimport) float     __cdecl _hypotf( float _X,  float _Y);
     __declspec(dllimport) int       __cdecl ilogbf( float _X);
     __declspec(dllimport) float     __cdecl lgammaf( float _X);
     __declspec(dllimport) long long __cdecl llrintf( float _X);
     __declspec(dllimport) long long __cdecl llroundf( float _X);
     __declspec(dllimport) float     __cdecl log1pf( float _X);
     __declspec(dllimport) float     __cdecl log2f( float _X);
     __declspec(dllimport) float     __cdecl logbf( float _X);
     __declspec(dllimport) long      __cdecl lrintf( float _X);
     __declspec(dllimport) long      __cdecl lroundf( float _X);
     __declspec(dllimport) float     __cdecl nanf( char const* _X);
     __declspec(dllimport) float     __cdecl nearbyintf( float _X);
     __declspec(dllimport) float     __cdecl nextafterf( float _X,  float _Y);
     __declspec(dllimport) float     __cdecl nexttowardf( float _X,  long double _Y);
     __declspec(dllimport) float     __cdecl remainderf( float _X,  float _Y);
     __declspec(dllimport) float     __cdecl remquof( float _X,  float _Y,  int* _Z);
     __declspec(dllimport) float     __cdecl rintf( float _X);
     __declspec(dllimport) float     __cdecl roundf( float _X);
     __declspec(dllimport) float     __cdecl scalblnf( float _X,  long _Y);
     __declspec(dllimport) float     __cdecl scalbnf( float _X,  int _Y);
     __declspec(dllimport) float     __cdecl tgammaf( float _X);
     __declspec(dllimport) float     __cdecl truncf( float _X);

    



#line 592 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_math.h"

    

         __declspec(dllimport) float __cdecl _logbf( float _X);
         __declspec(dllimport) float __cdecl _nextafterf( float _X,  float _Y);
         __declspec(dllimport) int   __cdecl _finitef( float _X);
         __declspec(dllimport) int   __cdecl _isnanf( float _X);
         __declspec(dllimport) int   __cdecl _fpclassf( float _X);

         __declspec(dllimport) int   __cdecl _set_FMA3_enable( int _Flag);
         __declspec(dllimport) int   __cdecl _get_FMA3_enable(void);

    




#line 610 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_math.h"



    

         __declspec(dllimport) float __cdecl acosf( float _X);
         __declspec(dllimport) float __cdecl asinf( float _X);
         __declspec(dllimport) float __cdecl atan2f( float _Y,  float _X);
         __declspec(dllimport) float __cdecl atanf( float _X);
         __declspec(dllimport) float __cdecl ceilf( float _X);
         __declspec(dllimport) float __cdecl cosf( float _X);
         __declspec(dllimport) float __cdecl coshf( float _X);
         __declspec(dllimport) float __cdecl expf( float _X);

    









































#line 667 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_math.h"

    



#line 673 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_math.h"

         __inline float __cdecl fabsf( float _X)
        {
            return (float)fabs(_X);
        }

    #line 680 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_math.h"

    

         __declspec(dllimport) float __cdecl floorf( float _X);
         __declspec(dllimport) float __cdecl fmodf( float _X,  float _Y);

    











#line 699 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_math.h"

     __inline float __cdecl frexpf( float _X,  int *_Y)
    {
        return (float)frexp(_X, _Y);
    }

     __inline float __cdecl hypotf( float _X,  float _Y)
    {
        return _hypotf(_X, _Y);
    }

     __inline float __cdecl ldexpf( float _X,  int _Y)
    {
        return (float)ldexp(_X, _Y);
    }

    

         __declspec(dllimport) float  __cdecl log10f( float _X);
         __declspec(dllimport) float  __cdecl logf( float _X);
         __declspec(dllimport) float  __cdecl modff( float _X,  float *_Y);
         __declspec(dllimport) float  __cdecl powf( float _X,  float _Y);
         __declspec(dllimport) float  __cdecl sinf( float _X);
         __declspec(dllimport) float  __cdecl sinhf( float _X);
         __declspec(dllimport) float  __cdecl sqrtf( float _X);
         __declspec(dllimport) float  __cdecl tanf( float _X);
         __declspec(dllimport) float  __cdecl tanhf( float _X);

    

















































#line 778 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_math.h"

     __declspec(dllimport) long double __cdecl acoshl( long double _X);

     __inline long double __cdecl acosl( long double _X)
    {
        return acos((double)_X);
    }

     __declspec(dllimport) long double __cdecl asinhl( long double _X);

     __inline long double __cdecl asinl( long double _X)
    {
        return asin((double)_X);
    }

     __inline long double __cdecl atan2l( long double _Y,  long double _X)
    {
        return atan2((double)_Y, (double)_X);
    }

     __declspec(dllimport) long double __cdecl atanhl( long double _X);

     __inline long double __cdecl atanl( long double _X)
    {
        return atan((double)_X);
    }

     __declspec(dllimport) long double __cdecl cbrtl( long double _X);

     __inline long double __cdecl ceill( long double _X)
    {
        return ceil((double)_X);
    }

     __inline long double __cdecl _chgsignl( long double _X)
    {
        return _chgsign((double)_X);
    }

     __declspec(dllimport) long double __cdecl copysignl( long double _Number,  long double _Sign);

     __inline long double __cdecl _copysignl( long double _Number,  long double _Sign)
    {
        return _copysign((double)_Number, (double)_Sign);
    }

     __inline long double __cdecl coshl( long double _X)
    {
        return cosh((double)_X);
    }

     __inline long double __cdecl cosl( long double _X)
    {
        return cos((double)_X);
    }

     __declspec(dllimport) long double __cdecl erfl( long double _X);
     __declspec(dllimport) long double __cdecl erfcl( long double _X);

     __inline long double __cdecl expl( long double _X)
    {
        return exp((double)_X);
    }

     __declspec(dllimport) long double __cdecl exp2l( long double _X);
     __declspec(dllimport) long double __cdecl expm1l( long double _X);

     __inline long double __cdecl fabsl( long double _X)
    {
        return fabs((double)_X);
    }

     __declspec(dllimport) long double __cdecl fdiml( long double _X,  long double _Y);

     __inline long double __cdecl floorl( long double _X)
    {
        return floor((double)_X);
    }

     __declspec(dllimport) long double __cdecl fmal( long double _X,  long double _Y,  long double _Z);
     __declspec(dllimport) long double __cdecl fmaxl( long double _X,  long double _Y);
     __declspec(dllimport) long double __cdecl fminl( long double _X,  long double _Y);

     __inline long double __cdecl fmodl( long double _X,  long double _Y)
    {
        return fmod((double)_X, (double)_Y);
    }

     __inline long double __cdecl frexpl( long double _X,  int *_Y)
    {
        return frexp((double)_X, _Y);
    }

     __declspec(dllimport) int __cdecl ilogbl( long double _X);

     __inline long double __cdecl _hypotl( long double _X,  long double _Y)
    {
        return _hypot((double)_X, (double)_Y);
    }

     __inline long double __cdecl hypotl( long double _X,  long double _Y)
    {
        return _hypot((double)_X, (double)_Y);
    }

     __inline long double __cdecl ldexpl( long double _X,  int _Y)
    {
        return ldexp((double)_X, _Y);
    }

     __declspec(dllimport) long double __cdecl lgammal( long double _X);
     __declspec(dllimport) long long __cdecl llrintl( long double _X);
     __declspec(dllimport) long long __cdecl llroundl( long double _X);

     __inline long double __cdecl logl( long double _X)
    {
        return log((double)_X);
    }

     __inline long double __cdecl log10l( long double _X)
    {
        return log10((double)_X);
    }

     __declspec(dllimport) long double __cdecl log1pl( long double _X);
     __declspec(dllimport) long double __cdecl log2l( long double _X);
     __declspec(dllimport) long double __cdecl logbl( long double _X);
     __declspec(dllimport) long __cdecl lrintl( long double _X);
     __declspec(dllimport) long __cdecl lroundl( long double _X);

     __inline long double __cdecl modfl( long double _X,  long double* _Y)
    {
        double _F, _I;
        _F = modf((double)_X, &_I);
        *_Y = _I;
        return _F;
    }

     __declspec(dllimport) long double __cdecl nanl( char const* _X);
     __declspec(dllimport) long double __cdecl nearbyintl( long double _X);
     __declspec(dllimport) long double __cdecl nextafterl( long double _X,  long double _Y);
     __declspec(dllimport) long double __cdecl nexttowardl( long double _X,  long double _Y);

     __inline long double __cdecl powl( long double _X,  long double _Y)
    {
        return pow((double)_X, (double)_Y);
    }

     __declspec(dllimport) long double __cdecl remainderl( long double _X,  long double _Y);
     __declspec(dllimport) long double __cdecl remquol( long double _X,  long double _Y,  int* _Z);
     __declspec(dllimport) long double __cdecl rintl( long double _X);
     __declspec(dllimport) long double __cdecl roundl( long double _X);
     __declspec(dllimport) long double __cdecl scalblnl( long double _X,  long _Y);
     __declspec(dllimport) long double __cdecl scalbnl( long double _X,  int _Y);

     __inline long double __cdecl sinhl( long double _X)
    {
        return sinh((double)_X);
    }

     __inline long double __cdecl sinl( long double _X)
    {
        return sin((double)_X);
    }

     __inline long double __cdecl sqrtl( long double _X)
    {
        return sqrt((double)_X);
    }

     __inline long double __cdecl tanhl( long double _X)
    {
        return tanh((double)_X);
    }

     __inline long double __cdecl tanl( long double _X)
    {
        return tan((double)_X);
    }

     __declspec(dllimport) long double __cdecl tgammal( long double _X);
     __declspec(dllimport) long double __cdecl truncl( long double _X);

    



#line 966 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_math.h"



    
    
    
    
    
    

    

    
        
            extern double HUGE;
        

#line 984 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_math.h"

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_j0" ". See online help for details."))  __declspec(dllimport) double __cdecl j0( double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_j1" ". See online help for details."))  __declspec(dllimport) double __cdecl j1( double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_jn" ". See online help for details."))  __declspec(dllimport) double __cdecl jn( int _X,  double _Y);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_y0" ". See online help for details."))  __declspec(dllimport) double __cdecl y0( double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_y1" ". See online help for details."))  __declspec(dllimport) double __cdecl y1( double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_yn" ". See online help for details."))  __declspec(dllimport) double __cdecl yn( int _X,  double _Y);
    #line 992 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_math.h"

#line 994 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_math.h"

} __pragma(pack(pop))

#pragma warning(pop) 
#line 999 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_math.h"
#pragma external_header(pop)
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\math.h"




#pragma external_header(pop)
#line 13 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cstdlib"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"







#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_malloc.h"








#pragma once



#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {





































#line 56 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_malloc.h"

  
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _calloc_base(
     size_t _Count,
     size_t _Size
    );

  
__declspec(dllimport)  __declspec(allocator) __declspec(restrict) 
void* __cdecl calloc(
      size_t _Count,
      size_t _Size
    );


__declspec(dllimport) int __cdecl _callnewh(
     size_t _Size
    );

  
__declspec(dllimport) __declspec(allocator) 
void* __cdecl _expand(
               void*  _Block,
      size_t _Size
    );

__declspec(dllimport)
void __cdecl _free_base(
      void* _Block
    );

__declspec(dllimport) 
void __cdecl free(
      void* _Block
    );

  
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _malloc_base(
     size_t _Size
    );

  
__declspec(dllimport) __declspec(allocator)  __declspec(restrict) 
void* __cdecl malloc(
      size_t _Size
    );


__declspec(dllimport)
size_t __cdecl _msize_base(
     void* _Block
    ) noexcept ;


__declspec(dllimport) 
size_t __cdecl _msize(
     void* _Block
    );

   
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _realloc_base(
       void*  _Block,
                                size_t _Size
    );

   
__declspec(dllimport) __declspec(allocator) __declspec(restrict) 
void* __cdecl realloc(
      void*  _Block,
             size_t _Size
    );

   
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _recalloc_base(
      void*  _Block,
                               size_t _Count,
                               size_t _Size
    );

   
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _recalloc(
      void*  _Block,
             size_t _Count,
             size_t _Size
    );

__declspec(dllimport)
void __cdecl _aligned_free(
      void* _Block
    );

  
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_malloc(
      size_t _Size,
                        size_t _Alignment
    );

  
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_malloc(
      size_t _Size,
                        size_t _Alignment,
                        size_t _Offset
    );


__declspec(dllimport)
size_t __cdecl _aligned_msize(
     void*  _Block,
              size_t _Alignment,
              size_t _Offset
    );

   
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_realloc(
      void*  _Block,
             size_t _Size,
                               size_t _Alignment,
                               size_t _Offset
    );

   
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_recalloc(
      void*  _Block,
             size_t _Count,
             size_t _Size,
                               size_t _Alignment,
                               size_t _Offset
    );

   
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_realloc(
      void*  _Block,
             size_t _Size,
                               size_t _Alignment
    );

   
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_recalloc(
      void*  _Block,
             size_t _Count,
             size_t _Size,
                               size_t _Alignment
    );


















#line 229 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_malloc.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_search.h"










#pragma once


#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stddef.h"







#pragma once





#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {




    namespace std
    {
        typedef decltype(__nullptr) nullptr_t;
    }

    using ::std::nullptr_t;
#line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stddef.h"





    __declspec(dllimport) int* __cdecl _errno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_errno( int _Value);
    __declspec(dllimport) errno_t __cdecl _get_errno( int* _Value);

#line 42 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stddef.h"









#line 52 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stddef.h"
    
#line 54 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stddef.h"

__declspec(dllimport) extern unsigned long  __cdecl __threadid(void);

__declspec(dllimport) extern uintptr_t __cdecl __threadhandle(void);



} __pragma(pack(pop))

#pragma warning(pop) 
#line 65 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stddef.h"
#pragma external_header(pop)
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_search.h"

#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {


    typedef int (__cdecl* _CoreCrtSecureSearchSortCompareFunction)(void*, void const*, void const*);
    typedef int (__cdecl* _CoreCrtNonSecureSearchSortCompareFunction)(void const*, void const*);




    
    __declspec(dllimport) void* __cdecl bsearch_s(
                                                       void const* _Key,
         void const* _Base,
                                                       rsize_t     _NumOfElements,
                                                       rsize_t     _SizeOfElements,
                           _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                   void*       _Context
        );

    __declspec(dllimport) void __cdecl qsort_s(
         void*   _Base,
                                                            rsize_t _NumOfElements,
                                                            rsize_t _SizeOfElements,
                            _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                        void*   _Context
        );

#line 48 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_search.h"




__declspec(dllimport) void* __cdecl bsearch(
                                                   void const* _Key,
     void const* _Base,
                                                   size_t      _NumOfElements,
                                                   size_t      _SizeOfElements,
                    _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );

__declspec(dllimport) void __cdecl qsort(
     void*  _Base,
                                                        size_t _NumOfElements,
                                                        size_t _SizeOfElements,
                    _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );


__declspec(dllimport) void* __cdecl _lfind_s(
                                                      void const*   _Key,
     void const*   _Base,
                                                   unsigned int* _NumOfElements,
                                                      size_t        _SizeOfElements,
                            _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                      void*         _Context
    );


__declspec(dllimport) void* __cdecl _lfind(
                                                      void const*   _Key,
     void const*   _Base,
                                                   unsigned int* _NumOfElements,
                                                      unsigned int  _SizeOfElements,
                         _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );


__declspec(dllimport) void* __cdecl _lsearch_s(
                                                            void const*   _Key,
     void*         _Base,
                                                         unsigned int* _NumOfElements,
                                                            size_t        _SizeOfElements,
                                  _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                            void*         _Context
    );


__declspec(dllimport) void* __cdecl _lsearch(
                                                            void const*   _Key,
     void*         _Base,
                                                         unsigned int* _NumOfElements,
                                                            unsigned int  _SizeOfElements,
                               _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );




















































































#line 189 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_search.h"





     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_lfind" ". See online help for details."))
    __declspec(dllimport) void* __cdecl lfind(
                                                          void const*   _Key,
         void const*   _Base,
                                                       unsigned int* _NumOfElements,
                                                          unsigned int  _SizeOfElements,
                             _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
        );

     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_lsearch" ". See online help for details."))
    __declspec(dllimport) void* __cdecl lsearch(
                                                               void const*   _Key,
         void*         _Base,
                                                            unsigned int* _NumOfElements,
                                                               unsigned int  _SizeOfElements,
                                  _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
        );

#line 213 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_search.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdlib.h"








#pragma once



#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {


































    
    
    __declspec(dllimport) errno_t __cdecl _itow_s(
                                 int      _Value,
         wchar_t* _Buffer,
                                 size_t   _BufferCount,
                                 int      _Radix
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _itow_s(int _Value, wchar_t (&_Buffer)[_Size], int _Radix) throw() { return _itow_s(_Value, _Buffer, _Size, _Radix); } }






    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_itow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _itow(int _Value, wchar_t *_Buffer, int _Radix);






    
    
    __declspec(dllimport) errno_t __cdecl _ltow_s(
                                 long     _Value,
         wchar_t* _Buffer,
                                 size_t   _BufferCount,
                                 int      _Radix
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltow_s(long _Value, wchar_t (&_Buffer)[_Size], int _Radix) throw() { return _ltow_s(_Value, _Buffer, _Size, _Radix); } }






    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _ltow(long _Value, wchar_t *_Buffer, int _Radix);






    
    __declspec(dllimport) errno_t __cdecl _ultow_s(
                                 unsigned long _Value,
         wchar_t*      _Buffer,
                                 size_t        _BufferCount,
                                 int           _Radix
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultow_s(unsigned long _Value, wchar_t (&_Buffer)[_Size], int _Radix) throw() { return _ultow_s(_Value, _Buffer, _Size, _Radix); } }






    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _ultow(unsigned long _Value, wchar_t *_Buffer, int _Radix);






    
    __declspec(dllimport) double __cdecl wcstod(
                           wchar_t const* _String,
          wchar_t**      _EndPtr
        );

    
    __declspec(dllimport) double __cdecl _wcstod_l(
                           wchar_t const* _String,
          wchar_t**      _EndPtr,
                         _locale_t      _Locale
        );

    
    __declspec(dllimport) long __cdecl wcstol(
                           wchar_t const* _String,
          wchar_t**      _EndPtr,
                             int            _Radix
        );

    
    __declspec(dllimport) long __cdecl _wcstol_l(
                           wchar_t const* _String,
          wchar_t**      _EndPtr,
                             int            _Radix,
                         _locale_t      _Locale
        );

    
    __declspec(dllimport) long long __cdecl wcstoll(
                           wchar_t const* _String,
          wchar_t**      _EndPtr,
                             int            _Radix
        );

    
    __declspec(dllimport) long long __cdecl _wcstoll_l(
                           wchar_t const* _String,
          wchar_t**      _EndPtr,
                             int            _Radix,
                         _locale_t      _Locale
        );

    
    __declspec(dllimport) unsigned long __cdecl wcstoul(
                           wchar_t const* _String,
          wchar_t**      _EndPtr,
                             int            _Radix
        );

    
    __declspec(dllimport) unsigned long __cdecl _wcstoul_l(
                           wchar_t const* _String,
          wchar_t**      _EndPtr,
                             int            _Radix,
                         _locale_t      _Locale
        );

    
    __declspec(dllimport) unsigned long long __cdecl wcstoull(
                           wchar_t const* _String,
          wchar_t**      _EndPtr,
                             int            _Radix
        );

    
    __declspec(dllimport) unsigned long long __cdecl _wcstoull_l(
                           wchar_t const* _String,
          wchar_t**      _EndPtr,
                             int            _Radix,
                         _locale_t      _Locale
        );

    
    __declspec(dllimport) long double __cdecl wcstold(
                           wchar_t const* _String,
          wchar_t**      _EndPtr
        );

    
    __declspec(dllimport) long double __cdecl _wcstold_l(
                           wchar_t const* _String,
          wchar_t**      _EndPtr,
                         _locale_t      _Locale
        );

    
    __declspec(dllimport) float __cdecl wcstof(
                           wchar_t const* _String,
          wchar_t**      _EndPtr
        );

    
    __declspec(dllimport) float __cdecl _wcstof_l(
                           wchar_t const* _String,
          wchar_t**      _EndPtr,
                         _locale_t      _Locale
        );

    
    __declspec(dllimport) double __cdecl _wtof(
         wchar_t const* _String
        );

    
    __declspec(dllimport) double __cdecl _wtof_l(
           wchar_t const* _String,
         _locale_t      _Locale
        );

    
    __declspec(dllimport) int __cdecl _wtoi(
         wchar_t const* _String
        );

    
    __declspec(dllimport) int __cdecl _wtoi_l(
           wchar_t const* _String,
         _locale_t      _Locale
        );

    
    __declspec(dllimport) long __cdecl _wtol(
         wchar_t const* _String
        );

    
    __declspec(dllimport) long __cdecl _wtol_l(
           wchar_t const* _String,
         _locale_t      _Locale
        );

    
    __declspec(dllimport) long long __cdecl _wtoll(
         wchar_t const* _String
        );

    
    __declspec(dllimport) long long __cdecl _wtoll_l(
           wchar_t const* _String,
         _locale_t      _Locale
        );

    
    __declspec(dllimport) errno_t __cdecl _i64tow_s(
                                 __int64  _Value,
         wchar_t* _Buffer,
                                 size_t   _BufferCount,
                                 int      _Radix
        );

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_i64tow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) wchar_t* __cdecl _i64tow(
                           __int64  _Value,
          wchar_t* _Buffer,
                           int      _Radix
        );

    
    __declspec(dllimport) errno_t __cdecl _ui64tow_s(
                                 unsigned __int64 _Value,
         wchar_t*         _Buffer,
                                 size_t           _BufferCount,
                                 int              _Radix
        );

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ui64tow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) wchar_t* __cdecl _ui64tow(
                           unsigned __int64 _Value,
          wchar_t*         _Buffer,
                           int              _Radix
        );

    
    __declspec(dllimport) __int64 __cdecl _wtoi64(
         wchar_t const* _String
        );

    
    __declspec(dllimport) __int64 __cdecl _wtoi64_l(
           wchar_t const* _String,
         _locale_t      _Locale
        );

    
    __declspec(dllimport) __int64 __cdecl _wcstoi64(
                           wchar_t const* _String,
          wchar_t**      _EndPtr,
                             int            _Radix
        );

    
    __declspec(dllimport) __int64 __cdecl _wcstoi64_l(
                           wchar_t const* _String,
          wchar_t**      _EndPtr,
                             int            _Radix,
                         _locale_t      _Locale
        );

    
    __declspec(dllimport) unsigned __int64 __cdecl _wcstoui64(
                           wchar_t const* _String,
          wchar_t**      _EndPtr,
                             int            _Radix
        );

    
    __declspec(dllimport) unsigned __int64 __cdecl _wcstoui64_l(
                           wchar_t const* _String,
          wchar_t**      _EndPtr,
                             int            _Radix,
                         _locale_t      _Locale
        );

    
    

    
    
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wfullpath(
         wchar_t*       _Buffer,
                                   wchar_t const* _Path,
                                     size_t         _BufferCount
        );

    

    
    __declspec(dllimport) errno_t __cdecl _wmakepath_s(
         wchar_t*       _Buffer,
                                 size_t         _BufferCount,
                           wchar_t const* _Drive,
                           wchar_t const* _Dir,
                           wchar_t const* _Filename,
                           wchar_t const* _Ext
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmakepath_s(wchar_t (&_Buffer)[_Size], wchar_t const* _Drive, wchar_t const* _Dir, wchar_t const* _Filename, wchar_t const* _Ext) throw() { return _wmakepath_s(_Buffer, _Size, _Drive, _Dir, _Filename, _Ext); } }








__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wmakepath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) void __cdecl _wmakepath( wchar_t *_Buffer, wchar_t const* _Drive, wchar_t const* _Dir, wchar_t const* _Filename, wchar_t const* _Ext);








    __declspec(dllimport) void __cdecl _wperror(
         wchar_t const* _ErrorMessage
        );

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsplitpath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) void __cdecl _wsplitpath(
                           wchar_t const* _FullPath,
          wchar_t*       _Drive,
          wchar_t*       _Dir,
          wchar_t*       _Filename,
          wchar_t*       _Ext
        );

    __declspec(dllimport) errno_t __cdecl _wsplitpath_s(
                                     wchar_t const* _FullPath,
            wchar_t*       _Drive,
                                       size_t         _DriveCount,
              wchar_t*       _Dir,
                                       size_t         _DirCount,
         wchar_t*       _Filename,
                                       size_t         _FilenameCount,
              wchar_t*       _Ext,
                                       size_t         _ExtCount
        );

    extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _wsplitpath_s( wchar_t const* _Path, wchar_t (&_Drive)[_DriveSize], wchar_t (&_Dir)[_DirSize], wchar_t (&_Name)[_NameSize], wchar_t (&_Ext)[_ExtSize] ) throw() { return _wsplitpath_s(_Path, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }




        
        

        
        __declspec(dllimport) errno_t __cdecl _wdupenv_s(
              wchar_t**      _Buffer,
                                                                               size_t*        _BufferCount,
                                                                                  wchar_t const* _VarName
            );

        

         __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wdupenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        __declspec(dllimport) wchar_t* __cdecl _wgetenv(
             wchar_t const* _VarName
            );

        
        
        __declspec(dllimport) errno_t __cdecl _wgetenv_s(
                                        size_t*        _RequiredCount,
             wchar_t*       _Buffer,
                                         size_t         _BufferCount,
                                       wchar_t const* _VarName
            );

        extern "C++" { template <size_t _Size> inline errno_t __cdecl _wgetenv_s(size_t* _RequiredCount, wchar_t (&_Buffer)[_Size], wchar_t const* _VarName) throw() { return _wgetenv_s(_RequiredCount, _Buffer, _Size, _VarName); } }







        
        __declspec(dllimport) int __cdecl _wputenv(
             wchar_t const* _EnvString
            );

        
        __declspec(dllimport) errno_t __cdecl _wputenv_s(
             wchar_t const* _Name,
             wchar_t const* _Value
            );

        __declspec(dllimport) errno_t __cdecl _wsearchenv_s(
                                   wchar_t const* _Filename,
                                   wchar_t const* _VarName,
             wchar_t*       _Buffer,
                                     size_t         _BufferCount
            );

        extern "C++" { template <size_t _Size> inline errno_t __cdecl _wsearchenv_s(wchar_t const* _Filename, wchar_t const* _VarName, wchar_t (&_ResultPath)[_Size]) throw() { return _wsearchenv_s(_Filename, _VarName, _ResultPath, _Size); } }






        __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsearchenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) void __cdecl _wsearchenv(wchar_t const* _Filename, wchar_t const* _VarName, wchar_t *_ResultPath);






        __declspec(dllimport) int __cdecl _wsystem(
             wchar_t const* _Command
            );

#line 476 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdlib.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 16 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"


#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {




    
#line 29 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"









__declspec(dllimport) void __cdecl _swab(
      char* _Buf1,
      char* _Buf2,
                                                                 int   _SizeInBytes
    );













    __declspec(dllimport) __declspec(noreturn) void __cdecl exit( int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl _exit( int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl _Exit( int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl quick_exit( int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl abort(void);
#line 62 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"





__declspec(dllimport) unsigned int __cdecl _set_abort_behavior(
     unsigned int _Flags,
     unsigned int _Mask
    );




    

    typedef int (__cdecl * _onexit_t)(void);
    


#line 82 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"


    
    
#line 87 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"

























































    int       __cdecl atexit(void (__cdecl*)(void));
    _onexit_t __cdecl _onexit( _onexit_t _Func);
#line 147 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"

int __cdecl at_quick_exit(void (__cdecl*)(void));









    
    typedef void (__cdecl* _purecall_handler)(void);

    
    typedef void (__cdecl* _invalid_parameter_handler)(
        wchar_t const*,
        wchar_t const*,
        wchar_t const*,
        unsigned int,
        uintptr_t
        );

    
     _purecall_handler __cdecl _set_purecall_handler(
         _purecall_handler _Handler
        );

     _purecall_handler __cdecl _get_purecall_handler(void);

    
    __declspec(dllimport) _invalid_parameter_handler __cdecl _set_invalid_parameter_handler(
         _invalid_parameter_handler _Handler
        );

    __declspec(dllimport) _invalid_parameter_handler __cdecl _get_invalid_parameter_handler(void);

    __declspec(dllimport) _invalid_parameter_handler __cdecl _set_thread_local_invalid_parameter_handler(
         _invalid_parameter_handler _Handler
        );

    __declspec(dllimport) _invalid_parameter_handler __cdecl _get_thread_local_invalid_parameter_handler(void);
#line 190 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"












#line 203 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"









 __declspec(dllimport) int __cdecl _set_error_mode( int _Mode);




    __declspec(dllimport) int* __cdecl _errno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_errno( int _Value);
    __declspec(dllimport) errno_t __cdecl _get_errno( int* _Value);

    __declspec(dllimport) unsigned long* __cdecl __doserrno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_doserrno( unsigned long _Value);
    __declspec(dllimport) errno_t __cdecl _get_doserrno( unsigned long * _Value);

    
    __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) char** __cdecl __sys_errlist(void);
    

    __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) int * __cdecl __sys_nerr(void);
    

    __declspec(dllimport) void __cdecl perror( char const* _ErrMsg);
#line 238 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"




__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_pgmptr" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char**    __cdecl __p__pgmptr (void);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_wpgmptr" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t** __cdecl __p__wpgmptr(void);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_fmode" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) int*      __cdecl __p__fmode  (void);








    
    
    
#line 257 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"


__declspec(dllimport) errno_t __cdecl _get_pgmptr ( char**    _Value);


__declspec(dllimport) errno_t __cdecl _get_wpgmptr( wchar_t** _Value);

__declspec(dllimport) errno_t __cdecl _set_fmode  (              int       _Mode );

__declspec(dllimport) errno_t __cdecl _get_fmode  (             int*      _PMode);








typedef struct _div_t
{
    int quot;
    int rem;
} div_t;

typedef struct _ldiv_t
{
    long quot;
    long rem;
} ldiv_t;

typedef struct _lldiv_t
{
    long long quot;
    long long rem;
} lldiv_t;

 int       __cdecl abs   ( int       _Number);
 long      __cdecl labs  ( long      _Number);
 long long __cdecl llabs ( long long _Number);
 __int64   __cdecl _abs64( __int64   _Number);

 unsigned short   __cdecl _byteswap_ushort( unsigned short   _Number);
 unsigned long    __cdecl _byteswap_ulong ( unsigned long    _Number);
 unsigned __int64 __cdecl _byteswap_uint64( unsigned __int64 _Number);

 __declspec(dllimport) div_t   __cdecl div  ( int       _Numerator,  int       _Denominator);
 __declspec(dllimport) ldiv_t  __cdecl ldiv ( long      _Numerator,  long      _Denominator);
 __declspec(dllimport) lldiv_t __cdecl lldiv( long long _Numerator,  long long _Denominator);



#pragma warning(push)
#pragma warning(disable: 6540)

unsigned int __cdecl _rotl(
     unsigned int _Value,
     int          _Shift
    );


unsigned long __cdecl _lrotl(
     unsigned long _Value,
     int           _Shift
    );

unsigned __int64 __cdecl _rotl64(
     unsigned __int64 _Value,
     int              _Shift
    );

unsigned int __cdecl _rotr(
     unsigned int _Value,
     int          _Shift
    );


unsigned long __cdecl _lrotr(
     unsigned long _Value,
     int           _Shift
    );

unsigned __int64 __cdecl _rotr64(
     unsigned __int64 _Value,
     int              _Shift
    );

#pragma warning(pop)






__declspec(dllimport) void __cdecl srand( unsigned int _Seed);

 __declspec(dllimport) int __cdecl rand(void);



#line 357 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"




extern "C++"
{
    inline long abs(long const _X) throw()
    {
        return labs(_X);
    }

    inline long long abs(long long const _X) throw()
    {
        return llabs(_X);
    }

    inline ldiv_t div(long const _A1, long const _A2) throw()
    {
        return ldiv(_A1, _A2);
    }

    inline lldiv_t div(long long const _A1, long long const _A2) throw()
    {
        return lldiv(_A1, _A2);
    }
}
#line 384 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"










    #pragma pack(push, 4)
    typedef struct
    {
        unsigned char ld[10];
    } _LDOUBLE;
    #pragma pack(pop)

    











#line 414 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"

typedef struct
{
    double x;
} _CRT_DOUBLE;

typedef struct
{
    float f;
} _CRT_FLOAT;





typedef struct
{
    long double x;
} _LONGDOUBLE;



#pragma pack(push, 4)
typedef struct
{
    unsigned char ld12[12];
} _LDBL12;
#pragma pack(pop)








                    __declspec(dllimport) double    __cdecl atof   ( char const* _String);
  __declspec(dllimport) int       __cdecl atoi   ( char const* _String);
                    __declspec(dllimport) long      __cdecl atol   ( char const* _String);
                    __declspec(dllimport) long long __cdecl atoll  ( char const* _String);
                    __declspec(dllimport) __int64   __cdecl _atoi64( char const* _String);

 __declspec(dllimport) double    __cdecl _atof_l  ( char const* _String,  _locale_t _Locale);
 __declspec(dllimport) int       __cdecl _atoi_l  ( char const* _String,  _locale_t _Locale);
 __declspec(dllimport) long      __cdecl _atol_l  ( char const* _String,  _locale_t _Locale);
 __declspec(dllimport) long long __cdecl _atoll_l ( char const* _String,  _locale_t _Locale);
 __declspec(dllimport) __int64   __cdecl _atoi64_l( char const* _String,  _locale_t _Locale);

 __declspec(dllimport) int __cdecl _atoflt ( _CRT_FLOAT*  _Result,  char const* _String);
 __declspec(dllimport) int __cdecl _atodbl ( _CRT_DOUBLE* _Result,  char*       _String);
 __declspec(dllimport) int __cdecl _atoldbl( _LDOUBLE*    _Result,  char*       _String);


__declspec(dllimport) int __cdecl _atoflt_l(
        _CRT_FLOAT* _Result,
       char const* _String,
     _locale_t   _Locale
    );


__declspec(dllimport) int __cdecl _atodbl_l(
        _CRT_DOUBLE* _Result,
       char*        _String,
     _locale_t    _Locale
    );



__declspec(dllimport) int __cdecl _atoldbl_l(
        _LDOUBLE* _Result,
       char*     _String,
     _locale_t _Locale
    );


__declspec(dllimport) float __cdecl strtof(
                       char const* _String,
      char**      _EndPtr
    );


__declspec(dllimport) float __cdecl _strtof_l(
                       char const* _String,
      char**      _EndPtr,
                     _locale_t   _Locale
    );


__declspec(dllimport) double __cdecl strtod(
                       char const* _String,
      char**      _EndPtr
    );


__declspec(dllimport) double __cdecl _strtod_l(
                       char const* _String,
      char**      _EndPtr,
                     _locale_t   _Locale
    );


__declspec(dllimport) long double __cdecl strtold(
                       char const* _String,
      char**      _EndPtr
    );


__declspec(dllimport) long double __cdecl _strtold_l(
                       char const* _String,
      char**      _EndPtr,
                     _locale_t   _Locale
    );


__declspec(dllimport) long __cdecl strtol(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix
    );


__declspec(dllimport) long __cdecl _strtol_l(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix,
                     _locale_t   _Locale
    );


__declspec(dllimport) long long __cdecl strtoll(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix
    );


__declspec(dllimport) long long __cdecl _strtoll_l(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix,
                     _locale_t   _Locale
    );


__declspec(dllimport) unsigned long __cdecl strtoul(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix
    );


__declspec(dllimport) unsigned long __cdecl _strtoul_l(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix,
                     _locale_t   _Locale
    );


__declspec(dllimport) unsigned long long __cdecl strtoull(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix
    );


__declspec(dllimport) unsigned long long __cdecl _strtoull_l(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix,
                     _locale_t   _Locale
    );


__declspec(dllimport) __int64 __cdecl _strtoi64(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix
    );


__declspec(dllimport) __int64 __cdecl _strtoi64_l(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix,
                     _locale_t   _Locale
    );


__declspec(dllimport) unsigned __int64 __cdecl _strtoui64(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix
    );


__declspec(dllimport) unsigned __int64 __cdecl _strtoui64_l(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix,
                     _locale_t   _Locale
    );










__declspec(dllimport) errno_t __cdecl _itoa_s(
                             int    _Value,
     char*  _Buffer,
                             size_t _BufferCount,
                             int    _Radix
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _itoa_s(int _Value, char (&_Buffer)[_Size], int _Radix) throw() { return _itoa_s(_Value, _Buffer, _Size, _Radix); } }







__declspec(deprecated("This function or variable may be unsafe. Consider using " "_itoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _itoa(int _Value, char *_Buffer, int _Radix);








__declspec(dllimport) errno_t __cdecl _ltoa_s(
                             long   _Value,
     char*  _Buffer,
                             size_t _BufferCount,
                             int    _Radix
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltoa_s(long _Value, char (&_Buffer)[_Size], int _Radix) throw() { return _ltoa_s(_Value, _Buffer, _Size, _Radix); } }






__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _ltoa(long _Value, char *_Buffer, int _Radix);








__declspec(dllimport) errno_t __cdecl _ultoa_s(
                             unsigned long _Value,
     char*         _Buffer,
                             size_t        _BufferCount,
                             int           _Radix
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultoa_s(unsigned long _Value, char (&_Buffer)[_Size], int _Radix) throw() { return _ultoa_s(_Value, _Buffer, _Size, _Radix); } }






__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _ultoa(unsigned long _Value, char *_Buffer, int _Radix);








__declspec(dllimport) errno_t __cdecl _i64toa_s(
                             __int64 _Value,
     char*   _Buffer,
                             size_t  _BufferCount,
                             int     _Radix
    );


__declspec(deprecated("This function or variable may be unsafe. Consider using " "_i64toa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _i64toa(
                       __int64 _Value,
      char*   _Buffer,
                       int     _Radix
    );



__declspec(dllimport) errno_t __cdecl _ui64toa_s(
                             unsigned __int64 _Value,
     char*            _Buffer,
                             size_t           _BufferCount,
                             int              _Radix
    );

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ui64toa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _ui64toa(
                       unsigned __int64 _Value,
      char*            _Buffer,
                       int              _Radix
    );















__declspec(dllimport) errno_t __cdecl _ecvt_s(
     char* _Buffer,
      size_t                       _BufferCount,
      double                       _Value,
      int                          _DigitCount,
     int*                         _PtDec,
     int*                         _PtSign
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ecvt_s(char (&_Buffer)[_Size], double _Value, int _DigitCount, int* _PtDec, int* _PtSign) throw() { return _ecvt_s(_Buffer, _Size, _Value, _DigitCount, _PtDec, _PtSign); } }








 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ecvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _ecvt(
      double _Value,
      int    _DigitCount,
     int*   _PtDec,
     int*   _PtSign
    );



__declspec(dllimport) errno_t __cdecl _fcvt_s(
     char*  _Buffer,
                             size_t _BufferCount,
                             double _Value,
                             int    _FractionalDigitCount,
                            int*   _PtDec,
                            int*   _PtSign
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _fcvt_s(char (&_Buffer)[_Size], double _Value, int _FractionalDigitCount, int* _PtDec, int* _PtSign) throw() { return _fcvt_s(_Buffer, _Size, _Value, _FractionalDigitCount, _PtDec, _PtSign); } }










 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _fcvt(
      double _Value,
      int    _FractionalDigitCount,
     int*   _PtDec,
     int*   _PtSign
    );


__declspec(dllimport) errno_t __cdecl _gcvt_s(
     char*  _Buffer,
                             size_t _BufferCount,
                             double _Value,
                             int    _DigitCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _gcvt_s(char (&_Buffer)[_Size], double _Value, int _DigitCount) throw() { return _gcvt_s(_Buffer, _Size, _Value, _DigitCount); } }







__declspec(deprecated("This function or variable may be unsafe. Consider using " "_gcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _gcvt(
                       double _Value,
                       int    _DigitCount,
      char*  _Buffer
    );











    

#line 833 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"
        
    #line 835 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"

    


        
    #line 841 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"

    
    __declspec(dllimport) int __cdecl ___mb_cur_max_func(void);

    
    __declspec(dllimport) int __cdecl ___mb_cur_max_l_func(_locale_t _Locale);
#line 848 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"




__declspec(dllimport) int __cdecl mblen(
      char const* _Ch,
                                            size_t      _MaxCount
    );


__declspec(dllimport) int __cdecl _mblen_l(
      char const* _Ch,
                                            size_t      _MaxCount,
                                        _locale_t   _Locale
    );



__declspec(dllimport) size_t __cdecl _mbstrlen(
     char const* _String
    );



__declspec(dllimport) size_t __cdecl _mbstrlen_l(
       char const* _String,
     _locale_t   _Locale
    );



__declspec(dllimport) size_t __cdecl _mbstrnlen(
     char const* _String,
       size_t      _MaxCount
    );



__declspec(dllimport) size_t __cdecl _mbstrnlen_l(
       char const* _String,
         size_t      _MaxCount,
     _locale_t   _Locale
    );


__declspec(dllimport) int __cdecl mbtowc(
                    wchar_t*    _DstCh,
     char const* _SrcCh,
                                     size_t      _SrcSizeInBytes
    );


__declspec(dllimport) int __cdecl _mbtowc_l(
                    wchar_t*    _DstCh,
     char const* _SrcCh,
                                     size_t      _SrcSizeInBytes,
                                 _locale_t   _Locale
    );


__declspec(dllimport) errno_t __cdecl mbstowcs_s(
                                                     size_t*     _PtNumOfCharConverted,
     wchar_t*    _DstBuf,
                                                          size_t      _SizeInWords,
                                    char const* _SrcBuf,
                                                          size_t      _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl mbstowcs_s(size_t* _PtNumOfCharConverted, wchar_t (&_Dest)[_Size], char const* _Source, size_t _MaxCount) throw() { return mbstowcs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }







__declspec(deprecated("This function or variable may be unsafe. Consider using " "mbstowcs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl mbstowcs( wchar_t *_Dest, char const* _Source, size_t _MaxCount);







__declspec(dllimport) errno_t __cdecl _mbstowcs_s_l(
                                                     size_t*     _PtNumOfCharConverted,
     wchar_t*    _DstBuf,
                                                          size_t      _SizeInWords,
                                    char const* _SrcBuf,
                                                          size_t      _MaxCount,
                                                      _locale_t   _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _mbstowcs_s_l(size_t* _PtNumOfCharConverted, wchar_t (&_Dest)[_Size], char const* _Source, size_t _MaxCount, _locale_t _Locale) throw() { return _mbstowcs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }








__declspec(deprecated("This function or variable may be unsafe. Consider using " "_mbstowcs_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl _mbstowcs_l( wchar_t *_Dest, char const* _Source, size_t _MaxCount, _locale_t _Locale);











__declspec(deprecated("This function or variable may be unsafe. Consider using " "wctomb_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) int __cdecl wctomb(
     char*   _MbCh,
                               wchar_t _WCh
    );

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctomb_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) int __cdecl _wctomb_l(
      char*     _MbCh,
                         wchar_t   _WCh,
                     _locale_t _Locale
    );



    
    __declspec(dllimport) errno_t __cdecl wctomb_s(
                                                        int*    _SizeConverted,
         char*   _MbCh,
                                                             rsize_t _SizeInBytes,
                                                             wchar_t _WCh
        );

#line 986 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"


__declspec(dllimport) errno_t __cdecl _wctomb_s_l(
                            int*     _SizeConverted,
     char*     _MbCh,
                                 size_t    _SizeInBytes,
                                 wchar_t   _WCh,
                             _locale_t _Locale);


__declspec(dllimport) errno_t __cdecl wcstombs_s(
                                                              size_t*        _PtNumOfCharConverted,
     char*          _Dst,
                                                                   size_t         _DstSizeInBytes,
                                                                 wchar_t const* _Src,
                                                                   size_t         _MaxCountInBytes
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcstombs_s(size_t* _PtNumOfCharConverted, char (&_Dest)[_Size], wchar_t const* _Source, size_t _MaxCount) throw() { return wcstombs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }







__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstombs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl wcstombs( char *_Dest, wchar_t const* _Source, size_t _MaxCount);







__declspec(dllimport) errno_t __cdecl _wcstombs_s_l(
                                                              size_t*        _PtNumOfCharConverted,
     char*          _Dst,
                                                                   size_t         _DstSizeInBytes,
                                                                 wchar_t const* _Src,
                                                                   size_t         _MaxCountInBytes,
                                                               _locale_t      _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcstombs_s_l(size_t* _PtNumOfCharConverted, char (&_Dest)[_Size], wchar_t const* _Source, size_t _MaxCount, _locale_t _Locale) throw() { return _wcstombs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }








__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcstombs_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl _wcstombs_l( char *_Dest, wchar_t const* _Source, size_t _MaxCount, _locale_t _Locale);





























__declspec(dllimport) __declspec(allocator) char* __cdecl _fullpath(
     char*       _Buffer,
                               char const* _Path,
                                 size_t      _BufferCount
    );




__declspec(dllimport) errno_t __cdecl _makepath_s(
     char*       _Buffer,
                             size_t      _BufferCount,
                       char const* _Drive,
                       char const* _Dir,
                       char const* _Filename,
                       char const* _Ext
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _makepath_s(char (&_Buffer)[_Size], char const* _Drive, char const* _Dir, char const* _Filename, char const* _Ext) throw() { return _makepath_s(_Buffer, _Size, _Drive, _Dir, _Filename, _Ext); } }








__declspec(deprecated("This function or variable may be unsafe. Consider using " "_makepath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) void __cdecl _makepath( char *_Buffer, char const* _Drive, char const* _Dir, char const* _Filename, char const* _Ext);








__declspec(deprecated("This function or variable may be unsafe. Consider using " "_splitpath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) void __cdecl _splitpath(
                       char const* _FullPath,
      char*       _Drive,
      char*       _Dir,
      char*       _Filename,
      char*       _Ext
    );


__declspec(dllimport) errno_t __cdecl _splitpath_s(
                                 char const* _FullPath,
        char*       _Drive,
                                   size_t      _DriveCount,
          char*       _Dir,
                                   size_t      _DirCount,
     char*       _Filename,
                                   size_t      _FilenameCount,
          char*       _Ext,
                                   size_t      _ExtCount
    );

extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _splitpath_s( char const* _Dest, char (&_Drive)[_DriveSize], char (&_Dir)[_DirSize], char (&_Name)[_NameSize], char (&_Ext)[_ExtSize] ) throw() { return _splitpath_s(_Dest, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }





__declspec(dllimport) errno_t __cdecl getenv_s(
                                size_t*     _RequiredCount,
     char*       _Buffer,
                                 rsize_t     _BufferCount,
                               char const* _VarName
    );

#line 1140 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"




__declspec(dllimport) int*       __cdecl __p___argc (void);
__declspec(dllimport) char***    __cdecl __p___argv (void);
__declspec(dllimport) wchar_t*** __cdecl __p___wargv(void);






    
    
    
#line 1157 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"

__declspec(dllimport) char***    __cdecl __p__environ (void);
__declspec(dllimport) wchar_t*** __cdecl __p__wenviron(void);


    
#line 1164 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"







    
    
#line 1174 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"









     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_dupenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl getenv(
         char const* _VarName
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl getenv_s(size_t* _RequiredCount, char (&_Buffer)[_Size], char const* _VarName) throw() { return getenv_s(_RequiredCount, _Buffer, _Size, _VarName); } }






    


#line 1199 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"

    
    __declspec(dllimport) errno_t __cdecl _dupenv_s(
          char**      _Buffer,
                                                                           size_t*     _BufferCount,
                                                                              char const* _VarName
        );

    

#line 1210 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"

    __declspec(dllimport) int __cdecl system(
         char const* _Command
        );

    
    
    #pragma warning(push)
    #pragma warning(disable: 6540)

    
    __declspec(dllimport) int __cdecl _putenv(
         char const* _EnvString
        );

    
    __declspec(dllimport) errno_t __cdecl _putenv_s(
         char const* _Name,
         char const* _Value
        );

    #pragma warning(pop)

    __declspec(dllimport) errno_t __cdecl _searchenv_s(
                               char const* _Filename,
                               char const* _VarName,
         char*       _Buffer,
                                 size_t      _BufferCount
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _searchenv_s(char const* _Filename, char const* _VarName, char (&_Buffer)[_Size]) throw() { return _searchenv_s(_Filename, _VarName, _Buffer, _Size); } }






    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_searchenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) void __cdecl _searchenv(char const* _Filename, char const* _VarName, char *_Buffer);






    
    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "SetErrorMode" " " "instead. See online help for details."))
    __declspec(dllimport) void __cdecl _seterrormode(
         int _Mode
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "Beep" " " "instead. See online help for details."))
    __declspec(dllimport) void __cdecl _beep(
         unsigned _Frequency,
         unsigned _Duration
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "Sleep" " " "instead. See online help for details."))
    __declspec(dllimport) void __cdecl _sleep(
         unsigned long _Duration
        );

#line 1272 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"









    




    
    

    #pragma warning(push)
    #pragma warning(disable: 4141) 

     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ecvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ecvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl ecvt(
          double _Value,
          int    _DigitCount,
         int*   _PtDec,
         int*   _PtSign
        );

     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fcvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl fcvt(
          double _Value,
          int    _FractionalDigitCount,
         int*   _PtDec,
         int*   _PtSign
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_gcvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl gcvt(
                           double _Value,
                           int    _DigitCount,
          char*  _DstBuf
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_itoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_itoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl itoa(
                           int   _Value,
          char* _Buffer,
                           int   _Radix
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ltoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl ltoa(
                           long  _Value,
          char* _Buffer,
                           int   _Radix
        );


    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_swab" ". See online help for details."))
    __declspec(dllimport) void __cdecl swab(
         char* _Buf1,
         char* _Buf2,
                                    int   _SizeInBytes
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ultoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl ultoa(
                           unsigned long _Value,
          char*         _Buffer,
                           int           _Radix
        );

    

     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_putenv" ". See online help for details."))
    __declspec(dllimport) int __cdecl putenv(
         char const* _EnvString
        );

    #pragma warning(pop)

    _onexit_t __cdecl onexit( _onexit_t _Func);

#line 1356 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#line 1363 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"
#pragma external_header(pop)
#line 14 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cstdlib"

#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )





[[nodiscard]]  inline double abs( double _Xx) noexcept   {
    return :: fabs(_Xx);
}

[[nodiscard]]  inline float abs( float _Xx) noexcept   {
    return :: fabsf(_Xx);
}

[[nodiscard]]  inline long double abs( long double _Xx) noexcept   {
    return :: fabsl(_Xx);
}

namespace std {
 using :: size_t;
 using :: div_t;
 using :: ldiv_t;
 using :: abort;
 using :: abs;
 using :: atexit;
 using :: atof;
 using :: atoi;
 using :: atol;
 using :: bsearch;
 using :: calloc;
 using :: div;
 using :: exit;
 using :: free;
 using :: labs;
 using :: ldiv;
 using :: malloc;
 using :: mblen;
 using :: mbstowcs;
 using :: mbtowc;
 using :: qsort;
 using :: rand;
 using :: realloc;
 using :: srand;
 using :: strtod;
 using :: strtol;
 using :: strtoul;
 using :: wcstombs;
 using :: wctomb;

 using :: lldiv_t;

 using :: getenv;
 using :: system;

 using :: atoll;
 using :: llabs;
 using :: lldiv;
 using :: strtof;
 using :: strtold;
 using :: strtoll;
 using :: strtoull;

 using :: _Exit;
 using :: at_quick_exit;
 using :: quick_exit;
}



#pragma warning(pop)
#pragma pack(pop)

#line 90 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cstdlib"
#line 91 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cstdlib"
#pragma external_header(pop)
#line 13 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"
#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xtr1common"





#pragma once





#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




namespace std {
 template <class _Ty, _Ty _Val>
struct integral_constant {
    static constexpr _Ty value = _Val;

    using value_type = _Ty;
    using type       = integral_constant;

    constexpr operator value_type() const noexcept {
        return value;
    }

    [[nodiscard]] constexpr value_type operator()() const noexcept {
        return value;
    }
};

 template <bool _Val>
using bool_constant = integral_constant<bool, _Val>;

 using true_type  = bool_constant<true>;
 using false_type = bool_constant<false>;

 template <bool _Test, class _Ty = void>
struct enable_if {}; 

template <class _Ty>
struct enable_if<true, _Ty> { 
    using type = _Ty;
};

 template <bool _Test, class _Ty = void>
using enable_if_t = typename enable_if<_Test, _Ty>::type;

 template <bool _Test, class _Ty1, class _Ty2>
struct conditional { 
    using type = _Ty1;
};

template <class _Ty1, class _Ty2>
struct conditional<false, _Ty1, _Ty2> {
    using type = _Ty2;
};

 template <bool _Test, class _Ty1, class _Ty2>
using conditional_t = typename conditional<_Test, _Ty1, _Ty2>::type;








 template <class, class>
inline constexpr bool is_same_v = false; 
template <class _Ty>
inline constexpr bool is_same_v<_Ty, _Ty> = true;

 template <class _Ty1, class _Ty2>
struct is_same : bool_constant<is_same_v<_Ty1, _Ty2>> {};
#line 81 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xtr1common"

 template <class _Ty>
struct remove_const { 
    using type = _Ty;
};

template <class _Ty>
struct remove_const<const _Ty> {
    using type = _Ty;
};

 template <class _Ty>
using remove_const_t = typename remove_const<_Ty>::type;

 template <class _Ty>
struct remove_volatile { 
    using type = _Ty;
};

template <class _Ty>
struct remove_volatile<volatile _Ty> {
    using type = _Ty;
};

 template <class _Ty>
using remove_volatile_t = typename remove_volatile<_Ty>::type;

 template <class _Ty>
struct remove_cv { 
    using type = _Ty;

    template <template <class> class _Fn>
    using _Apply = _Fn<_Ty>; 
};

template <class _Ty>
struct remove_cv<const _Ty> {
    using type = _Ty;

    template <template <class> class _Fn>
    using _Apply = const _Fn<_Ty>;
};

template <class _Ty>
struct remove_cv<volatile _Ty> {
    using type = _Ty;

    template <template <class> class _Fn>
    using _Apply = volatile _Fn<_Ty>;
};

template <class _Ty>
struct remove_cv<const volatile _Ty> {
    using type = _Ty;

    template <template <class> class _Fn>
    using _Apply = const volatile _Fn<_Ty>;
};

 template <class _Ty>
using remove_cv_t = typename remove_cv<_Ty>::type;

template <bool _First_value, class _First, class... _Rest>
struct _Disjunction { 
    using type = _First;
};

template <class _False, class _Next, class... _Rest>
struct _Disjunction<false, _False, _Next, _Rest...> { 
    using type = typename _Disjunction<_Next::value, _Next, _Rest...>::type;
};

 template <class... _Traits>
struct disjunction : false_type {}; 

template <class _First, class... _Rest>
struct disjunction<_First, _Rest...> : _Disjunction<_First::value, _First, _Rest...>::type {
    
};

 template <class... _Traits>
inline constexpr bool disjunction_v = disjunction<_Traits...>::value;

template <class _Ty, class... _Types>
inline constexpr bool _Is_any_of_v = 
    disjunction_v<is_same<_Ty, _Types>...>;

[[nodiscard]] constexpr bool _Is_constant_evaluated() noexcept { 
    return __builtin_is_constant_evaluated();
}


 [[nodiscard]] constexpr bool is_constant_evaluated() noexcept {
    return __builtin_is_constant_evaluated();
}
#line 177 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xtr1common"

 template <class _Ty>
inline constexpr bool is_integral_v = _Is_any_of_v<remove_cv_t<_Ty>, bool, char, signed char, unsigned char,
    wchar_t,

    char8_t,
#line 184 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xtr1common"
    char16_t, char32_t, short, unsigned short, int, unsigned int, long, unsigned long, long long, unsigned long long>;

 template <class _Ty>
struct is_integral : bool_constant<is_integral_v<_Ty>> {};

 template <class _Ty>
inline constexpr bool is_floating_point_v = _Is_any_of_v<remove_cv_t<_Ty>, float, double, long double>;

 template <class _Ty>
struct is_floating_point : bool_constant<is_floating_point_v<_Ty>> {};

 template <class _Ty>
inline constexpr bool is_arithmetic_v = 
    is_integral_v<_Ty> || is_floating_point_v<_Ty>;

 template <class _Ty>
struct is_arithmetic : bool_constant<is_arithmetic_v<_Ty>> {};

 template <class _Ty>
struct remove_reference {
    using type                 = _Ty;
    using _Const_thru_ref_type = const _Ty;
};

template <class _Ty>
struct remove_reference<_Ty&> {
    using type                 = _Ty;
    using _Const_thru_ref_type = const _Ty&;
};

template <class _Ty>
struct remove_reference<_Ty&&> {
    using type                 = _Ty;
    using _Const_thru_ref_type = const _Ty&&;
};

 template <class _Ty>
using remove_reference_t = typename remove_reference<_Ty>::type;

template <class _Ty>
using _Const_thru_ref = typename remove_reference<_Ty>::_Const_thru_ref_type;

template <class _Ty>
using _Remove_cvref_t [[msvc::known_semantics]] = remove_cv_t<remove_reference_t<_Ty>>;


 template <class _Ty>
using remove_cvref_t = _Remove_cvref_t<_Ty>;

 template <class _Ty>
struct remove_cvref {
    using type = remove_cvref_t<_Ty>;
};
#line 238 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xtr1common"

}


#pragma warning(pop)
#pragma pack(pop)
#line 245 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xtr1common"
#line 246 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xtr1common"
#pragma external_header(pop)
#line 14 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"





#line 21 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"


#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin0.h"












#pragma once





#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin0.inl.h"













#pragma once





#pragma warning(push)
#pragma warning(disable: 4514 4820 )


extern "C" {
#line 26 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin0.inl.h"


























 



#line 57 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin0.inl.h"


#line 60 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin0.inl.h"






#line 67 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin0.inl.h"




#line 72 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin0.inl.h"




#line 77 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin0.inl.h"




#line 82 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin0.inl.h"

 




#line 89 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin0.inl.h"




#line 94 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin0.inl.h"




#line 99 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin0.inl.h"




#line 104 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin0.inl.h"




#line 109 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin0.inl.h"




#line 114 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin0.inl.h"









unsigned char _BitScanForward(unsigned long * _Index, unsigned long _Mask);
unsigned char _BitScanForward64(unsigned long * _Index, unsigned __int64 _Mask);

unsigned char _BitScanReverse(unsigned long * _Index, unsigned long _Mask);
unsigned char _BitScanReverse64(unsigned long * _Index, unsigned __int64 _Mask);

unsigned char _bittest(long const *, long);


long _InterlockedAnd(long volatile * _Value, long _Mask);
short _InterlockedAnd16(short volatile * _Value, short _Mask);



__int64 _InterlockedAnd64(__int64 volatile * _Value, __int64 _Mask);
__int64 _interlockedand64(__int64 volatile * _Value, __int64 _Mask);



char _InterlockedAnd8(char volatile * _Value, char _Mask);






long _InterlockedCompareExchange(long volatile * _Destination, long _Exchange, long _Comparand);

short _InterlockedCompareExchange16(short volatile * _Destination, short _Exchange, short _Comparand);



__int64 _InterlockedCompareExchange64(__int64 volatile * _Destination, __int64 _Exchange, __int64 _Comparand);



char _InterlockedCompareExchange8(char volatile * _Destination, char _Exchange, char _Comparand);






unsigned char _InterlockedCompareExchange128(__int64 volatile * _Destination, __int64 _ExchangeHigh, __int64 _ExchangeLow, __int64 * _ComparandResult);



long _InterlockedDecrement(long volatile * _Addend);

short _InterlockedDecrement16(short volatile * _Addend);
__int64 _InterlockedDecrement64(__int64 volatile * _Addend);
__int64 _interlockeddecrement64(__int64 volatile * _Addend);
long _InterlockedExchange(long volatile * _Target, long _Value);

short _InterlockedExchange16(short volatile * _Target, short _Value);



__int64 _InterlockedExchange64(__int64 volatile * _Target, __int64 _Value);
__int64 _interlockedexchange64(__int64 volatile * _Target, __int64 _Value);



char _InterlockedExchange8(char volatile * _Target, char _Value);



long _InterlockedExchangeAdd(long volatile * _Addend, long _Value);
short _InterlockedExchangeAdd16(short volatile * _Addend, short _Value);



__int64 _InterlockedExchangeAdd64(__int64 volatile * _Addend, __int64 _Value);
__int64 _interlockedexchangeadd64(__int64 volatile * _Addend, __int64 _Value);



char _InterlockedExchangeAdd8(char volatile * _Addend, char _Value);









long _InterlockedIncrement(long volatile * _Addend);

short _InterlockedIncrement16(short volatile * _Addend);
__int64 _InterlockedIncrement64(__int64 volatile * _Addend);
__int64 _interlockedincrement64(__int64 volatile * _Addend);

long _InterlockedOr(long volatile * _Value, long _Mask);
short _InterlockedOr16(short volatile * _Value, short _Mask);



__int64 _InterlockedOr64(__int64 volatile * _Value, __int64 _Mask);
__int64 _interlockedor64(__int64 volatile * _Value, __int64 _Mask);



char _InterlockedOr8(char volatile * _Value, char _Mask);






long _InterlockedXor(long volatile * _Value, long _Mask);
short _InterlockedXor16(short volatile * _Value, short _Mask);



__int64 _InterlockedXor64(__int64 volatile * _Value, __int64 _Mask);
__int64 _interlockedxor64(__int64 volatile * _Value, __int64 _Mask);



char _InterlockedXor8(char volatile * _Value, char _Mask);






void _ReadWriteBarrier(void);
__int16 __iso_volatile_load16(const volatile __int16 *);
__int32 __iso_volatile_load32(const volatile __int32 *);
__int64 __iso_volatile_load64(const volatile __int64 *);
__int8 __iso_volatile_load8(const volatile __int8 *);
void __iso_volatile_store16(volatile __int16 *, __int16);
void __iso_volatile_store32(volatile __int32 *, __int32);
void __iso_volatile_store64(volatile __int64 *, __int64);
void __iso_volatile_store8(volatile __int8 *, __int8);


void _mm_pause(void);
unsigned int __lzcnt(unsigned int);
unsigned short __lzcnt16(unsigned short);
unsigned __int64 __lzcnt64(unsigned __int64);
unsigned int __popcnt(unsigned int);
unsigned short __popcnt16(unsigned short);
unsigned __int64 __popcnt64(unsigned __int64);
unsigned int __cdecl _rotl( unsigned int _Value, int _Shift);
unsigned short __cdecl _rotl16(unsigned short _Value, unsigned char _Shift);
unsigned __int64 __cdecl _rotl64( unsigned __int64 _Value, int _Shift);
unsigned char __cdecl _rotl8(unsigned char _Value, unsigned char _Shift);
unsigned int __cdecl _rotr( unsigned int _Value, int _Shift);
unsigned short __cdecl _rotr16(unsigned short _Value, unsigned char _Shift);
unsigned __int64 __cdecl _rotr64( unsigned __int64 _Value, int _Shift);
unsigned char __cdecl _rotr8(unsigned char _Value, unsigned char _Shift);
unsigned __int64 __shiftleft128(unsigned __int64 _LowPart, unsigned __int64 _HighPart, unsigned char _Shift);
unsigned __int64 __shiftright128(unsigned __int64 _LowPart, unsigned __int64 _HighPart, unsigned char _Shift);

unsigned int _tzcnt_u32(unsigned int);
unsigned __int64 _tzcnt_u64(unsigned __int64);
#line 282 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin0.inl.h"
unsigned __int64 _umul128(unsigned __int64 _Multiplier, unsigned __int64 _Multiplicand, unsigned __int64 * _HighProduct);

unsigned __int64 __cdecl _udiv128(unsigned __int64 _HighDividend, unsigned __int64 _LowDividend, unsigned __int64 _Divisor, unsigned __int64* _Remainder);
unsigned char __cdecl _addcarry_u64(unsigned char, unsigned __int64, unsigned __int64, unsigned __int64 *);
unsigned char __cdecl _subborrow_u64(unsigned char, unsigned __int64, unsigned __int64, unsigned __int64 *);
double __ceil(double);
float __ceilf(float);
double __floor(double);
float __floorf(float);
double __round(double);
float __roundf(float);
double __trunc(double);
float __truncf(float);
double __copysign(double, double);
float __copysignf(float, float);
unsigned __signbitvalue(double);
unsigned __signbitvaluef(float);







#line 307 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin0.inl.h"











constexpr void * __cdecl __builtin_assume_aligned(const void *, size_t, ...) noexcept;


#line 322 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin0.inl.h"
#line 323 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin0.inl.h"








}
#line 333 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin0.inl.h"
#pragma warning(pop) 
#line 335 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin0.inl.h"
#pragma external_header(pop)
#line 20 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin0.h"
#line 21 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin0.h"
#pragma external_header(pop)
#line 24 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"
#line 25 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"


#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"





#pragma once





#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\__msvc_iter_core.hpp"





#pragma once




#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"





#pragma once




#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"





#pragma once




#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cstdint"





#pragma once





#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\stdint.h"







#pragma once






#pragma warning(push)
#pragma warning(disable: 4514 4820 )

typedef signed char        int8_t;
typedef short              int16_t;
typedef int                int32_t;
typedef long long          int64_t;
typedef unsigned char      uint8_t;
typedef unsigned short     uint16_t;
typedef unsigned int       uint32_t;
typedef unsigned long long uint64_t;

typedef signed char        int_least8_t;
typedef short              int_least16_t;
typedef int                int_least32_t;
typedef long long          int_least64_t;
typedef unsigned char      uint_least8_t;
typedef unsigned short     uint_least16_t;
typedef unsigned int       uint_least32_t;
typedef unsigned long long uint_least64_t;

typedef signed char        int_fast8_t;
typedef int                int_fast16_t;
typedef int                int_fast32_t;
typedef long long          int_fast64_t;
typedef unsigned char      uint_fast8_t;
typedef unsigned int       uint_fast16_t;
typedef unsigned int       uint_fast32_t;
typedef unsigned long long uint_fast64_t;

typedef long long          intmax_t;
typedef unsigned long long uintmax_t;










































    
    
    




#line 97 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\stdint.h"







































#pragma warning(pop) 

#line 139 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\stdint.h"
#pragma external_header(pop)
#line 13 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cstdint"

#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




namespace std {
 using :: int8_t;
 using :: int16_t;
 using :: int32_t;
 using :: int64_t;
 using :: uint8_t;
 using :: uint16_t;
 using :: uint32_t;
 using :: uint64_t;

 using :: int_least8_t;
 using :: int_least16_t;
 using :: int_least32_t;
 using :: int_least64_t;
 using :: uint_least8_t;
 using :: uint_least16_t;
 using :: uint_least32_t;
 using :: uint_least64_t;

 using :: int_fast8_t;
 using :: int_fast16_t;
 using :: int_fast32_t;
 using :: int_fast64_t;
 using :: uint_fast8_t;
 using :: uint_fast16_t;
 using :: uint_fast32_t;
 using :: uint_fast64_t;

 using :: intmax_t;
 using :: intptr_t;
 using :: uintmax_t;
 using :: uintptr_t;



































#line 89 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cstdint"
}



#pragma warning(pop)
#pragma pack(pop)

#line 97 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cstdint"
#line 98 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cstdint"
#pragma external_header(pop)
#line 12 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"
#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstddef"





#pragma once




#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cstddef"





#pragma once








#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




namespace std {
 using :: ptrdiff_t;
 using :: size_t;
 using max_align_t = double; 
 using nullptr_t   = decltype(nullptr);


 enum class byte : unsigned char {};

 template <class _IntType, enable_if_t<is_integral_v<_IntType>, int> = 0>
[[nodiscard]] constexpr byte operator<<(const byte _Arg, const _IntType _Shift) noexcept {
    
    return static_cast<byte>(static_cast<unsigned char>(static_cast<unsigned int>(_Arg) << _Shift));
}

 template <class _IntType, enable_if_t<is_integral_v<_IntType>, int> = 0>
[[nodiscard]] constexpr byte operator>>(const byte _Arg, const _IntType _Shift) noexcept {
    
    return static_cast<byte>(static_cast<unsigned char>(static_cast<unsigned int>(_Arg) >> _Shift));
}

 [[nodiscard]] constexpr byte operator|(const byte _Left, const byte _Right) noexcept {
    
    return static_cast<byte>(
        static_cast<unsigned char>(static_cast<unsigned int>(_Left) | static_cast<unsigned int>(_Right)));
}

 [[nodiscard]] constexpr byte operator&(const byte _Left, const byte _Right) noexcept {
    
    return static_cast<byte>(
        static_cast<unsigned char>(static_cast<unsigned int>(_Left) & static_cast<unsigned int>(_Right)));
}

 [[nodiscard]] constexpr byte operator^(const byte _Left, const byte _Right) noexcept {
    
    return static_cast<byte>(
        static_cast<unsigned char>(static_cast<unsigned int>(_Left) ^ static_cast<unsigned int>(_Right)));
}

 [[nodiscard]] constexpr byte operator~(const byte _Arg) noexcept {
    
    return static_cast<byte>(static_cast<unsigned char>(~static_cast<unsigned int>(_Arg)));
}

 template <class _IntType, enable_if_t<is_integral_v<_IntType>, int> = 0>
constexpr byte& operator<<=(byte& _Arg, const _IntType _Shift) noexcept {
    return _Arg = _Arg << _Shift;
}

 template <class _IntType, enable_if_t<is_integral_v<_IntType>, int> = 0>
constexpr byte& operator>>=(byte& _Arg, const _IntType _Shift) noexcept {
    return _Arg = _Arg >> _Shift;
}

 constexpr byte& operator|=(byte& _Left, const byte _Right) noexcept {
    return _Left = _Left | _Right;
}

 constexpr byte& operator&=(byte& _Left, const byte _Right) noexcept {
    return _Left = _Left & _Right;
}

 constexpr byte& operator^=(byte& _Left, const byte _Right) noexcept {
    return _Left = _Left ^ _Right;
}

 template <class _IntType, enable_if_t<is_integral_v<_IntType>, int> = 0>
[[nodiscard]] constexpr _IntType to_integer(const byte _Arg) noexcept {
    return static_cast<_IntType>(_Arg);
}
#line 93 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cstddef"

}

using ::std:: max_align_t; 



#pragma warning(pop)
#pragma pack(pop)

#line 104 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cstddef"
#line 105 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cstddef"
#pragma external_header(pop)
#line 12 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstddef"

#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\initializer_list"





#pragma once






#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




namespace std {
 template <class _Elem>
class initializer_list {
public:
    using value_type      = _Elem;
    using reference       = const _Elem&;
    using const_reference = const _Elem&;
    using size_type       = size_t;

    using iterator       = const _Elem*;
    using const_iterator = const _Elem*;

    constexpr initializer_list() noexcept : _First(nullptr), _Last(nullptr) {}

    constexpr initializer_list(const _Elem* _First_arg, const _Elem* _Last_arg) noexcept
        : _First(_First_arg), _Last(_Last_arg) {}

    [[nodiscard]] constexpr const _Elem* begin() const noexcept {
        return _First;
    }

    [[nodiscard]] constexpr const _Elem* end() const noexcept {
        return _Last;
    }

    [[nodiscard]] constexpr size_t size() const noexcept {
        return static_cast<size_t>(_Last - _First);
    }

private:
    const _Elem* _First;
    const _Elem* _Last;
};

 template <class _Elem>
[[nodiscard]] constexpr const _Elem* begin(initializer_list<_Elem> _Ilist) noexcept {
    return _Ilist.begin();
}

 template <class _Elem>
[[nodiscard]] constexpr const _Elem* end(initializer_list<_Elem> _Ilist) noexcept {
    return _Ilist.end();
}
}


#pragma warning(pop)
#pragma pack(pop)
#line 69 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\initializer_list"
#line 70 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\initializer_list"
#pragma external_header(pop)
#line 14 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstddef"


#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




namespace std {
template <class>

inline constexpr bool _Always_false = false;















#line 43 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstddef"

#pragma warning(push)
#pragma warning(disable : 5215) 
#pragma warning(disable : 5216) 






template <class _Ty>
[[nodiscard]] _Ty _Fake_copy_init(_Ty) noexcept;









#pragma warning(pop)

 template <class _Ty = void>
struct plus {
    using _Unnameable_first_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]  = _Ty;
    using _Unnameable_second_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ty;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]          = _Ty;

    [[nodiscard]] constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left + _Right;
    }
};

 template <class _Ty = void>
struct minus {
    using _Unnameable_first_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]  = _Ty;
    using _Unnameable_second_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ty;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]          = _Ty;

    [[nodiscard]] constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left - _Right;
    }
};

 template <class _Ty = void>
struct multiplies {
    using _Unnameable_first_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]  = _Ty;
    using _Unnameable_second_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ty;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]          = _Ty;

    [[nodiscard]] constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left * _Right;
    }
};

 template <class _Ty = void>
struct equal_to {
    using _Unnameable_first_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]  = _Ty;
    using _Unnameable_second_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ty;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]          = bool;

    [[nodiscard]] constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
        noexcept(noexcept(_Fake_copy_init<bool>(_Left == _Right)))   {
        return _Left == _Right;
    }
};

 template <class _Ty = void>
struct not_equal_to {
    using _Unnameable_first_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]  = _Ty;
    using _Unnameable_second_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ty;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]          = bool;

    [[nodiscard]] constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
        noexcept(noexcept(_Fake_copy_init<bool>(_Left != _Right)))   {
        return _Left != _Right;
    }
};

 template <class _Ty = void>
struct greater {
    using _Unnameable_first_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]  = _Ty;
    using _Unnameable_second_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ty;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]          = bool;

    [[nodiscard]] constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
        noexcept(noexcept(_Fake_copy_init<bool>(_Left > _Right)))   {
        return _Left > _Right;
    }
};

 template <class _Ty = void>
struct less {
    using _Unnameable_first_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]  = _Ty;
    using _Unnameable_second_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ty;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]          = bool;

    [[nodiscard]] constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
        noexcept(noexcept(_Fake_copy_init<bool>(_Left < _Right)))   {
        return _Left < _Right;
    }
};

 template <class _Ty = void>
struct greater_equal {
    using _Unnameable_first_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]  = _Ty;
    using _Unnameable_second_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ty;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]          = bool;

    [[nodiscard]] constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
        noexcept(noexcept(_Fake_copy_init<bool>(_Left >= _Right)))   {
        return _Left >= _Right;
    }
};

 template <class _Ty = void>
struct less_equal {
    using _Unnameable_first_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]  = _Ty;
    using _Unnameable_second_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ty;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]          = bool;

    [[nodiscard]] constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
        noexcept(noexcept(_Fake_copy_init<bool>(_Left <= _Right)))   {
        return _Left <= _Right;
    }
};

template <>
struct plus<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) + static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) + static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) + static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct minus<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) - static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) - static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) - static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct multiplies<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) * static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) * static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) * static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct equal_to<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct not_equal_to<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) != static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) != static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) != static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct greater<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) > static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) > static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) > static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct less<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct greater_equal<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) >= static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) >= static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) >= static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct less_equal<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) <= static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) <= static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) <= static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

 template <class _Ty>
[[nodiscard]] constexpr _Ty* addressof(_Ty& _Val) noexcept {
    return __builtin_addressof(_Val);
}

 template <class _Ty>
const _Ty* addressof(const _Ty&&) = delete;

template <class _Ptrty>
[[nodiscard]] constexpr auto _Unfancy(_Ptrty _Ptr) noexcept { 
    return ::std:: addressof(*_Ptr);
}

template <class _Ty>
[[nodiscard]] constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { 
    return _Ptr;
}
}








#line 306 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstddef"




#line 311 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstddef"

#line 313 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstddef"








#line 322 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstddef"






#line 329 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstddef"

























#line 355 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstddef"


























#line 382 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstddef"









































#line 424 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstddef"



#pragma warning(pop)
#pragma pack(pop)
#line 430 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstddef"
#line 431 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstddef"
#pragma external_header(pop)
#line 13 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




namespace std {
 template <class _Ty, _Ty... _Vals>
struct integer_sequence { 
    static_assert(is_integral_v<_Ty>, "integer_sequence<T, I...> requires T to be an integral type.");

    using value_type = _Ty;

    [[nodiscard]] static constexpr size_t size() noexcept {
        return sizeof...(_Vals);
    }
};

 template <class _Ty, _Ty _Size>
using make_integer_sequence = __make_integer_seq<integer_sequence, _Ty, _Size>;

 template <size_t... _Vals>
using index_sequence = integer_sequence<size_t, _Vals...>;

 template <size_t _Size>
using make_index_sequence = make_integer_sequence<size_t, _Size>;

 template <class... _Types>
using index_sequence_for = make_index_sequence<sizeof...(_Types)>;

template <bool _First_value, class _First, class... _Rest>
struct _Conjunction { 
    using type = _First;
};

template <class _True, class _Next, class... _Rest>
struct _Conjunction<true, _True, _Next, _Rest...> { 
    using type = typename _Conjunction<_Next::value, _Next, _Rest...>::type;
};

 template <class... _Traits>
struct conjunction : true_type {}; 

template <class _First, class... _Rest>
struct conjunction<_First, _Rest...> : _Conjunction<_First::value, _First, _Rest...>::type {
    
};

 template <class... _Traits>
inline constexpr bool conjunction_v = conjunction<_Traits...>::value;

 template <class _Trait>
struct negation : bool_constant<!static_cast<bool>(_Trait::value)> {}; 

 template <class _Trait>
inline constexpr bool negation_v = negation<_Trait>::value;

 template <class _Ty>
inline constexpr bool is_void_v = is_same_v<remove_cv_t<_Ty>, void>;

 template <class _Ty>
struct is_void : bool_constant<is_void_v<_Ty>> {};

 template <class... _Types>
using void_t = void;

template <class _Ty>
struct _Identity {
    using type = _Ty;
};
template <class _Ty>
using _Identity_t [[msvc::known_semantics]] = typename _Identity<_Ty>::type;


 template <class _Ty>
struct add_const { 
    using type = const _Ty;
};

 template <class _Ty>
using add_const_t = typename add_const<_Ty>::type;

 template <class _Ty>
struct add_volatile { 
    using type = volatile _Ty;
};

 template <class _Ty>
using add_volatile_t = typename add_volatile<_Ty>::type;

 template <class _Ty>
struct add_cv { 
    using type = const volatile _Ty;
};

 template <class _Ty>
using add_cv_t = typename add_cv<_Ty>::type;

template <class _Ty, class = void>
struct _Add_reference { 
    using _Lvalue = _Ty;
    using _Rvalue = _Ty;
};

template <class _Ty>
struct _Add_reference<_Ty, void_t<_Ty&>> { 
    using _Lvalue = _Ty&;
    using _Rvalue = _Ty&&;
};

 template <class _Ty>
struct add_lvalue_reference {
    using type = typename _Add_reference<_Ty>::_Lvalue;
};

 template <class _Ty>
using add_lvalue_reference_t = typename _Add_reference<_Ty>::_Lvalue;

 template <class _Ty>
struct add_rvalue_reference {
    using type = typename _Add_reference<_Ty>::_Rvalue;
};

 template <class _Ty>
using add_rvalue_reference_t = typename _Add_reference<_Ty>::_Rvalue;

 template <class _Ty>
add_rvalue_reference_t<_Ty> declval() noexcept {
    static_assert(_Always_false<_Ty>, "Calling declval is ill-formed, see N4917 22.2.6 [declval]/2.");
}

 template <class _Ty>
struct remove_extent { 
    using type = _Ty;
};

template <class _Ty, size_t _Ix>
struct remove_extent<_Ty[_Ix]> {
    using type = _Ty;
};

template <class _Ty>
struct remove_extent<_Ty[]> {
    using type = _Ty;
};

 template <class _Ty>
using remove_extent_t = typename remove_extent<_Ty>::type;

 template <class _Ty>
struct remove_all_extents { 
    using type = _Ty;
};

template <class _Ty, size_t _Ix>
struct remove_all_extents<_Ty[_Ix]> {
    using type = typename remove_all_extents<_Ty>::type;
};

template <class _Ty>
struct remove_all_extents<_Ty[]> {
    using type = typename remove_all_extents<_Ty>::type;
};

 template <class _Ty>
using remove_all_extents_t = typename remove_all_extents<_Ty>::type;

 template <class _Ty>
struct remove_pointer {
    using type = _Ty;
};

template <class _Ty>
struct remove_pointer<_Ty*> {
    using type = _Ty;
};

template <class _Ty>
struct remove_pointer<_Ty* const> {
    using type = _Ty;
};

template <class _Ty>
struct remove_pointer<_Ty* volatile> {
    using type = _Ty;
};

template <class _Ty>
struct remove_pointer<_Ty* const volatile> {
    using type = _Ty;
};

 template <class _Ty>
using remove_pointer_t = typename remove_pointer<_Ty>::type;

template <class _Ty, class = void>
struct _Add_pointer { 
    using type = _Ty;
};

template <class _Ty>
struct _Add_pointer<_Ty, void_t<remove_reference_t<_Ty>*>> { 
    using type = remove_reference_t<_Ty>*;
};

 template <class _Ty>
struct add_pointer {
    using type = typename _Add_pointer<_Ty>::type;
};

 template <class _Ty>
using add_pointer_t = typename _Add_pointer<_Ty>::type;

 template <class>
inline constexpr bool is_array_v = false; 

template <class _Ty, size_t _Nx>
inline constexpr bool is_array_v<_Ty[_Nx]> = true;

template <class _Ty>
inline constexpr bool is_array_v<_Ty[]> = true;

 template <class _Ty>
struct is_array : bool_constant<is_array_v<_Ty>> {};


 template <class>
inline constexpr bool is_bounded_array_v = false;

template <class _Ty, size_t _Nx>
inline constexpr bool is_bounded_array_v<_Ty[_Nx]> = true;

 template <class _Ty>
struct is_bounded_array : bool_constant<is_bounded_array_v<_Ty>> {};

 template <class>
inline constexpr bool is_unbounded_array_v = false;

template <class _Ty>
inline constexpr bool is_unbounded_array_v<_Ty[]> = true;

 template <class _Ty>
struct is_unbounded_array : bool_constant<is_unbounded_array_v<_Ty>> {};
#line 259 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

 template <class>
inline constexpr bool is_lvalue_reference_v = false; 

template <class _Ty>
inline constexpr bool is_lvalue_reference_v<_Ty&> = true;

 template <class _Ty>
struct is_lvalue_reference : bool_constant<is_lvalue_reference_v<_Ty>> {};

 template <class>
inline constexpr bool is_rvalue_reference_v = false; 

template <class _Ty>
inline constexpr bool is_rvalue_reference_v<_Ty&&> = true;

 template <class _Ty>
struct is_rvalue_reference : bool_constant<is_rvalue_reference_v<_Ty>> {};

 template <class>
inline constexpr bool is_reference_v = false; 

template <class _Ty>
inline constexpr bool is_reference_v<_Ty&> = true;

template <class _Ty>
inline constexpr bool is_reference_v<_Ty&&> = true;

 template <class _Ty>
struct is_reference : bool_constant<is_reference_v<_Ty>> {};

 template <class>
inline constexpr bool is_pointer_v = false; 

template <class _Ty>
inline constexpr bool is_pointer_v<_Ty*> = true;

template <class _Ty>
inline constexpr bool is_pointer_v<_Ty* const> = true;

template <class _Ty>
inline constexpr bool is_pointer_v<_Ty* volatile> = true;

template <class _Ty>
inline constexpr bool is_pointer_v<_Ty* const volatile> = true;

 template <class _Ty>
struct is_pointer : bool_constant<is_pointer_v<_Ty>> {};

 template <class _Ty>
inline constexpr bool is_null_pointer_v =
    is_same_v<remove_cv_t<_Ty>, nullptr_t>; 

 template <class _Ty>
struct is_null_pointer : bool_constant<is_null_pointer_v<_Ty>> {};

 template <class _Ty>
struct is_union : bool_constant<__is_union(_Ty)> {}; 

 template <class _Ty>
inline constexpr bool is_union_v = __is_union(_Ty);

 template <class _Ty>
struct is_class : bool_constant<__is_class(_Ty)> {}; 

 template <class _Ty>
inline constexpr bool is_class_v = __is_class(_Ty);

 template <class _Ty>
inline constexpr bool is_fundamental_v = is_arithmetic_v<_Ty> || is_void_v<_Ty> || is_null_pointer_v<_Ty>;

 template <class _Ty>
struct is_fundamental : bool_constant<is_fundamental_v<_Ty>> {}; 

 template <class _From, class _To>
struct is_convertible : bool_constant<__is_convertible_to(_From, _To)> {
    
};

 template <class _From, class _To>
inline constexpr bool is_convertible_v = __is_convertible_to(_From, _To);


template <class _Ty>
struct is_convertible<_Ty&, volatile _Ty&> : true_type {};

template <class _Ty>
struct is_convertible<volatile _Ty&, volatile _Ty&> : true_type {};

template <class _Ty>
struct is_convertible<_Ty&, const volatile _Ty&> : true_type {};

template <class _Ty>
struct is_convertible<volatile _Ty&, const volatile _Ty&> : true_type {};

template <class _Ty>
inline constexpr bool is_convertible_v<_Ty&, volatile _Ty&> = true;

template <class _Ty>
inline constexpr bool is_convertible_v<volatile _Ty&, volatile _Ty&> = true;

template <class _Ty>
inline constexpr bool is_convertible_v<_Ty&, const volatile _Ty&> = true;

template <class _Ty>
inline constexpr bool is_convertible_v<volatile _Ty&, const volatile _Ty&> = true;
#line 366 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

 template <class _Ty>
struct is_enum : bool_constant<__is_enum(_Ty)> {}; 

 template <class _Ty>
inline constexpr bool is_enum_v = __is_enum(_Ty);







#line 380 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

 template <class _Ty>
struct is_compound : bool_constant<!is_fundamental_v<_Ty>> {}; 

 template <class _Ty>
inline constexpr bool is_compound_v = !is_fundamental_v<_Ty>;

template <class... _Types>
struct _Arg_types {}; 

template <class _Ty1>
struct _Arg_types<_Ty1> {
    using _Unnameable_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ty1;
};

template <class _Ty1, class _Ty2>
struct _Arg_types<_Ty1, _Ty2> {
    using _Unnameable_first_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]  = _Ty1;
    using _Unnameable_second_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ty2;
};

template <class _Ty>
struct _Is_memfunptr { 
    using _Bool_type = false_type; 
};











template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)> : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...)> : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const> : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const> : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile> : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile> : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile> : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile> : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) &> : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) &> : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const &> : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const &> : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile &> : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile &> : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile &> : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile &> : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) &&> : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) &&> : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const &&> : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const &&> : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile &&> : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile &&> : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile &&> : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile &&> : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) noexcept> : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) noexcept> : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const noexcept> : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const noexcept> : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile noexcept> : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile noexcept> : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile noexcept> : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile noexcept> : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) & noexcept> : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) & noexcept> : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const & noexcept> : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const & noexcept> : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile & noexcept> : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile & noexcept> : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile & noexcept> : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile & noexcept> : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) && noexcept> : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) && noexcept> : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const && noexcept> : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const && noexcept> : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile && noexcept> : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile && noexcept> : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile && noexcept> : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile && noexcept> : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; };












template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...)> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) &> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const&> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile&> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile&> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) &&> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const&&> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile&&> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile&&> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) noexcept> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const noexcept> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile noexcept> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile noexcept> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) &noexcept> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const& noexcept> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile& noexcept> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile& noexcept> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) &&noexcept> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const&& noexcept> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile&& noexcept> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile&& noexcept> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; };
















#line 447 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"





 template <class _Ty>
inline constexpr bool is_member_function_pointer_v = _Is_memfunptr<remove_cv_t<_Ty>>::_Bool_type::value;
#line 455 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

 template <class _Ty>
struct is_member_function_pointer : bool_constant<is_member_function_pointer_v<_Ty>> {};

 template <class>
inline constexpr bool is_const_v = false; 

template <class _Ty>
inline constexpr bool is_const_v<const _Ty> = true;

 template <class _Ty>
struct is_const : bool_constant<is_const_v<_Ty>> {};

 template <class>
inline constexpr bool is_volatile_v = false; 

template <class _Ty>
inline constexpr bool is_volatile_v<volatile _Ty> = true;

 template <class _Ty>
struct is_volatile : bool_constant<is_volatile_v<_Ty>> {};

 template <class _Ty>
inline constexpr bool is_function_v = 
    !is_const_v<const _Ty> && !is_reference_v<_Ty>;

 template <class _Ty>
struct is_function : bool_constant<is_function_v<_Ty>> {};

 template <class _Ty>
inline constexpr bool is_object_v = 
    is_const_v<const _Ty> && !is_void_v<_Ty>;

 template <class _Ty>
struct is_object : bool_constant<is_object_v<_Ty>> {};

template <class>
struct _Is_member_object_pointer {
    static constexpr bool value = false;
};

template <class _Ty1, class _Ty2>
struct _Is_member_object_pointer<_Ty1 _Ty2::*> {
    static constexpr bool value = !is_function_v<_Ty1>;
    using _Class_type           = _Ty2;
};





 template <class _Ty>
inline constexpr bool is_member_object_pointer_v = _Is_member_object_pointer<remove_cv_t<_Ty>>::value;
#line 509 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

 template <class _Ty>
struct is_member_object_pointer : bool_constant<is_member_object_pointer_v<_Ty>> {};





 template <class _Ty>
inline constexpr bool is_member_pointer_v = is_member_object_pointer_v<_Ty> || is_member_function_pointer_v<_Ty>;
#line 520 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

 template <class _Ty>
struct is_member_pointer : bool_constant<is_member_pointer_v<_Ty>> {}; 

 template <class _Ty>
inline constexpr bool is_scalar_v = 
    is_arithmetic_v<_Ty> || is_enum_v<_Ty> || is_pointer_v<_Ty> || is_member_pointer_v<_Ty> || is_null_pointer_v<_Ty>;

 template <class _Ty>
struct is_scalar : bool_constant<is_scalar_v<_Ty>> {};

 template <class _Ty>
struct [[deprecated("warning STL4025: " "std::is_pod and std::is_pod_v are deprecated in C++20. " "The std::is_trivially_copyable and/or std::is_standard_layout traits likely suit your use case. " "You can define _SILENCE_CXX20_IS_POD_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] is_pod : bool_constant<__is_pod(_Ty)> {}; 

 template <class _Ty>
[[deprecated("warning STL4025: " "std::is_pod and std::is_pod_v are deprecated in C++20. " "The std::is_trivially_copyable and/or std::is_standard_layout traits likely suit your use case. " "You can define _SILENCE_CXX20_IS_POD_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] inline constexpr bool is_pod_v = __is_pod(_Ty);

 template <class _Ty>
struct is_empty : bool_constant<__is_empty(_Ty)> {}; 

 template <class _Ty>
inline constexpr bool is_empty_v = __is_empty(_Ty);

 template <class _Ty>
struct is_polymorphic : bool_constant<__is_polymorphic(_Ty)> {}; 

 template <class _Ty>
inline constexpr bool is_polymorphic_v = __is_polymorphic(_Ty);

 template <class _Ty>
struct is_abstract : bool_constant<__is_abstract(_Ty)> {}; 

 template <class _Ty>
inline constexpr bool is_abstract_v = __is_abstract(_Ty);

 template <class _Ty>
struct is_final : bool_constant<__is_final(_Ty)> {}; 

 template <class _Ty>
inline constexpr bool is_final_v = __is_final(_Ty);

 template <class _Ty>
struct is_standard_layout : bool_constant<__is_standard_layout(_Ty)> {}; 

 template <class _Ty>
inline constexpr bool is_standard_layout_v = __is_standard_layout(_Ty);









#line 576 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"


 template <class _Ty>
struct is_trivial : bool_constant<__is_trivially_constructible(_Ty) && __is_trivially_copyable(_Ty)> {
    
};

 template <class _Ty>
inline constexpr bool is_trivial_v = __is_trivially_constructible(_Ty) && __is_trivially_copyable(_Ty);






#line 592 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

 template <class _Ty>
struct is_trivially_copyable : bool_constant<__is_trivially_copyable(_Ty)> {
    
};

 template <class _Ty>
inline constexpr bool is_trivially_copyable_v = __is_trivially_copyable(_Ty);

 template <class _Ty>
struct has_virtual_destructor : bool_constant<__has_virtual_destructor(_Ty)> {
    
};

 template <class _Ty>
inline constexpr bool has_virtual_destructor_v = __has_virtual_destructor(_Ty);


 template <class _Ty>
struct has_unique_object_representations : bool_constant<__has_unique_object_representations(_Ty)> {
    
};

 template <class _Ty>
inline constexpr bool has_unique_object_representations_v = __has_unique_object_representations(_Ty);



template <class _Ty>
struct _Is_aggregate_impl : bool_constant<__is_aggregate(_Ty)> {};

 template <class _Ty>
inline constexpr bool is_aggregate_v = disjunction_v<is_array<_Ty>, _Is_aggregate_impl<_Ty>>;

 template <class _Ty>
struct is_aggregate : bool_constant<is_aggregate_v<_Ty>> {};






#line 635 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"
#line 636 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

 template <class _Ty, class... _Args>
struct is_constructible : bool_constant<__is_constructible(_Ty, _Args...)> {
    
};

 template <class _Ty, class... _Args>
inline constexpr bool is_constructible_v = __is_constructible(_Ty, _Args...);

 template <class _Ty>
struct is_copy_constructible : bool_constant<__is_constructible(_Ty, add_lvalue_reference_t<const _Ty>)> {
    
};

 template <class _Ty>
inline constexpr bool is_copy_constructible_v = __is_constructible(_Ty, add_lvalue_reference_t<const _Ty>);

 template <class _Ty>
struct is_default_constructible : bool_constant<__is_constructible(_Ty)> {
    
};

 template <class _Ty>
inline constexpr bool is_default_constructible_v = __is_constructible(_Ty);

template <class _Ty, class = void>
struct _Is_implicitly_default_constructible : false_type {
    
};

template <class _Ty>
void _Implicitly_default_construct(const _Ty&);

template <class _Ty>
struct _Is_implicitly_default_constructible<_Ty, void_t<decltype(_Implicitly_default_construct<_Ty>({}))>> : true_type {
};

 template <class _Ty>
struct is_move_constructible : bool_constant<__is_constructible(_Ty, _Ty)> {
    
};

 template <class _Ty>
inline constexpr bool is_move_constructible_v = __is_constructible(_Ty, _Ty);

 template <class _To, class _From>
struct is_assignable : bool_constant<__is_assignable(_To, _From)> {}; 

 template <class _To, class _From>
inline constexpr bool is_assignable_v = __is_assignable(_To, _From);


template <class _To, class _From>
struct _Is_assignable_no_precondition_check : bool_constant<__is_assignable_no_precondition_check(_To, _From)> {};



#line 694 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

 template <class _Ty>
struct is_copy_assignable
    : bool_constant<__is_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)> {
    
};

 template <class _Ty>
inline constexpr bool is_copy_assignable_v =
    __is_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);


template <class _Ty>
struct _Is_copy_assignable_no_precondition_check
    : bool_constant<__is_assignable_no_precondition_check(
          add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)> {};

template <class _Ty>
inline constexpr bool _Is_copy_assignable_unchecked_v =
    __is_assignable_no_precondition_check(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);






#line 721 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

 template <class _Ty>
struct is_move_assignable : bool_constant<__is_assignable(add_lvalue_reference_t<_Ty>, _Ty)> {
    
};

 template <class _Ty>
inline constexpr bool is_move_assignable_v = __is_assignable(add_lvalue_reference_t<_Ty>, _Ty);


template <class _Ty>
struct _Is_move_assignable_no_precondition_check
    : bool_constant<__is_assignable_no_precondition_check(add_lvalue_reference_t<_Ty>, _Ty)> {};

template <class _Ty>
inline constexpr bool _Is_move_assignable_unchecked_v =
    __is_assignable_no_precondition_check(add_lvalue_reference_t<_Ty>, _Ty);






#line 745 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

 template <class _Ty>
struct is_destructible : bool_constant<__is_destructible(_Ty)> {
    
};

 template <class _Ty>
inline constexpr bool is_destructible_v = __is_destructible(_Ty);

 template <class _Ty, class... _Args>
struct is_trivially_constructible : bool_constant<__is_trivially_constructible(_Ty, _Args...)> {
    
};

 template <class _Ty, class... _Args>
inline constexpr bool is_trivially_constructible_v = __is_trivially_constructible(_Ty, _Args...);

 template <class _Ty>
struct is_trivially_copy_constructible
    : bool_constant<__is_trivially_constructible(_Ty, add_lvalue_reference_t<const _Ty>)> {
    
};

 template <class _Ty>
inline constexpr bool is_trivially_copy_constructible_v =
    __is_trivially_constructible(_Ty, add_lvalue_reference_t<const _Ty>);

 template <class _Ty>
struct is_trivially_default_constructible : bool_constant<__is_trivially_constructible(_Ty)> {
    
};

 template <class _Ty>
inline constexpr bool is_trivially_default_constructible_v = __is_trivially_constructible(_Ty);

 template <class _Ty>
struct is_trivially_move_constructible : bool_constant<__is_trivially_constructible(_Ty, _Ty)> {
    
};

 template <class _Ty>
inline constexpr bool is_trivially_move_constructible_v = __is_trivially_constructible(_Ty, _Ty);

 template <class _To, class _From>
struct is_trivially_assignable : bool_constant<__is_trivially_assignable(_To, _From)> {
    
};

 template <class _To, class _From>
inline constexpr bool is_trivially_assignable_v = __is_trivially_assignable(_To, _From);

 template <class _Ty>
struct is_trivially_copy_assignable
    : bool_constant<__is_trivially_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)> {
    
};

 template <class _Ty>
inline constexpr bool is_trivially_copy_assignable_v =
    __is_trivially_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);

 template <class _Ty>
struct is_trivially_move_assignable : bool_constant<__is_trivially_assignable(add_lvalue_reference_t<_Ty>, _Ty)> {
    
};

 template <class _Ty>
inline constexpr bool is_trivially_move_assignable_v = __is_trivially_assignable(add_lvalue_reference_t<_Ty>, _Ty);

 template <class _Ty>
struct is_trivially_destructible : bool_constant<__is_trivially_destructible(_Ty)> {
    
};

 template <class _Ty>
inline constexpr bool is_trivially_destructible_v = __is_trivially_destructible(_Ty);

 template <class _Ty, class... _Args>
struct is_nothrow_constructible : bool_constant<__is_nothrow_constructible(_Ty, _Args...)> {
    
};

 template <class _Ty, class... _Args>
inline constexpr bool is_nothrow_constructible_v = __is_nothrow_constructible(_Ty, _Args...);

 template <class _Ty>
struct is_nothrow_copy_constructible
    : bool_constant<__is_nothrow_constructible(_Ty, add_lvalue_reference_t<const _Ty>)> {
    
    
};

 template <class _Ty>
inline constexpr bool is_nothrow_copy_constructible_v =
    __is_nothrow_constructible(_Ty, add_lvalue_reference_t<const _Ty>);

 template <class _Ty>
struct is_nothrow_default_constructible : bool_constant<__is_nothrow_constructible(_Ty)> {
    
};

 template <class _Ty>
inline constexpr bool is_nothrow_default_constructible_v = __is_nothrow_constructible(_Ty);

 template <class _Ty>
struct is_nothrow_move_constructible : bool_constant<__is_nothrow_constructible(_Ty, _Ty)> {
    
};

 template <class _Ty>
inline constexpr bool is_nothrow_move_constructible_v = __is_nothrow_constructible(_Ty, _Ty);

 template <class _To, class _From>
struct is_nothrow_assignable : bool_constant<__is_nothrow_assignable(_To, _From)> {
    
};

 template <class _To, class _From>
inline constexpr bool is_nothrow_assignable_v = __is_nothrow_assignable(_To, _From);

 template <class _Ty>
struct is_nothrow_copy_assignable
    : bool_constant<__is_nothrow_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)> {
    
};

 template <class _Ty>
inline constexpr bool is_nothrow_copy_assignable_v =
    __is_nothrow_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);

 template <class _Ty>
struct is_nothrow_move_assignable : bool_constant<__is_nothrow_assignable(add_lvalue_reference_t<_Ty>, _Ty)> {
    
};

 template <class _Ty>
inline constexpr bool is_nothrow_move_assignable_v = __is_nothrow_assignable(add_lvalue_reference_t<_Ty>, _Ty);

 template <class _Ty>
struct is_nothrow_destructible : bool_constant<__is_nothrow_destructible(_Ty)> {
    
    
};

 template <class _Ty>
inline constexpr bool is_nothrow_destructible_v = __is_nothrow_destructible(_Ty);

template <class _Ty, bool = is_integral_v<_Ty>>
struct _Sign_base { 
    using _Uty = remove_cv_t<_Ty>;

    static constexpr bool _Signed   = static_cast<_Uty>(-1) < static_cast<_Uty>(0);
    static constexpr bool _Unsigned = !_Signed;
};

template <class _Ty>
struct _Sign_base<_Ty, false> { 
                                
    static constexpr bool _Signed   = is_floating_point_v<_Ty>;
    static constexpr bool _Unsigned = false;
};

 template <class _Ty>
struct is_signed : bool_constant<_Sign_base<_Ty>::_Signed> {}; 

 template <class _Ty>
inline constexpr bool is_signed_v = _Sign_base<_Ty>::_Signed;

 template <class _Ty>
struct is_unsigned : bool_constant<_Sign_base<_Ty>::_Unsigned> {}; 

 template <class _Ty>
inline constexpr bool is_unsigned_v = _Sign_base<_Ty>::_Unsigned;

template <class _Ty>
inline constexpr bool _Is_nonbool_integral = is_integral_v<_Ty> && !is_same_v<remove_cv_t<_Ty>, bool>;

template <bool>
struct _Select { 
    template <class _Ty1, class>
    using _Apply = _Ty1;
};

template <>
struct _Select<false> {
    template <class, class _Ty2>
    using _Apply = _Ty2;
};

template <size_t>
struct _Make_signed2; 

template <>
struct _Make_signed2<1> {
    template <class>
    using _Apply = signed char;
};

template <>
struct _Make_signed2<2> {
    template <class>
    using _Apply = short;
};

template <>
struct _Make_signed2<4> {
    template <class _Ty>
    using _Apply = 
        typename _Select<is_same_v<_Ty, long> || is_same_v<_Ty, unsigned long>>::template _Apply<long, int>;
};

template <>
struct _Make_signed2<8> {
    template <class>
    using _Apply = long long;
};

template <class _Ty>
using _Make_signed1 = 
    typename _Make_signed2<sizeof(_Ty)>::template _Apply<_Ty>;

 template <class _Ty>
struct make_signed { 
    static_assert(_Is_nonbool_integral<_Ty> || is_enum_v<_Ty>,
        "make_signed<T> requires that T shall be a (possibly cv-qualified) "
        "integral type or enumeration but not a bool type.");

    using type = typename remove_cv<_Ty>::template _Apply<_Make_signed1>;
};

 template <class _Ty>
using make_signed_t = typename make_signed<_Ty>::type;

template <size_t>
struct _Make_unsigned2; 

template <>
struct _Make_unsigned2<1> {
    template <class>
    using _Apply = unsigned char;
};

template <>
struct _Make_unsigned2<2> {
    template <class>
    using _Apply = unsigned short;
};

template <>
struct _Make_unsigned2<4> {
    template <class _Ty>
    using _Apply = 
        typename _Select<is_same_v<_Ty, long> || is_same_v<_Ty, unsigned long>>::template _Apply<unsigned long,
            unsigned int>;
};

template <>
struct _Make_unsigned2<8> {
    template <class>
    using _Apply = unsigned long long;
};

template <class _Ty>
using _Make_unsigned1 = 
    typename _Make_unsigned2<sizeof(_Ty)>::template _Apply<_Ty>;

 template <class _Ty>
struct make_unsigned { 
    static_assert(_Is_nonbool_integral<_Ty> || is_enum_v<_Ty>,
        "make_unsigned<T> requires that T shall be a (possibly cv-qualified) "
        "integral type or enumeration but not a bool type.");

    using type = typename remove_cv<_Ty>::template _Apply<_Make_unsigned1>;
};

 template <class _Ty>
using make_unsigned_t = typename make_unsigned<_Ty>::type;

template <class _Rep>
constexpr make_unsigned_t<_Rep> _Unsigned_value(_Rep _Val) { 
    return static_cast<make_unsigned_t<_Rep>>(_Val);
}

 template <class _Ty>
struct alignment_of : integral_constant<size_t, alignof(_Ty)> {}; 

 template <class _Ty>
inline constexpr size_t alignment_of_v = alignof(_Ty);

template <class _Ty, size_t _Len>
union _Align_type { 
    _Ty _Val;
    char _Pad[_Len];
};

template <size_t _Len, size_t _Align, class _Ty, bool _Ok>
struct _Aligned; 

template <size_t _Len, size_t _Align, class _Ty>
struct _Aligned<_Len, _Align, _Ty, true> {
    using type = _Align_type<_Ty, _Len>;
};

template <size_t _Len, size_t _Align>
struct _Aligned<_Len, _Align, double, false> {






    static_assert(_Always_false<_Aligned>,
        "You've instantiated std::aligned_storage<Len, Align> with an extended alignment (in other "
        "words, Align > alignof(max_align_t)). Before VS 2017 15.8, the member \"type\" would "
        "non-conformingly have an alignment of only alignof(max_align_t). VS 2017 15.8 was fixed to "
        "handle this correctly, but the fix inherently changes layout and breaks binary compatibility "
        "(*only* for uses of aligned_storage with extended alignments). "
        "To suppress this error, please define either "
        "(1) _ENABLE_EXTENDED_ALIGNED_STORAGE to confirm that you want a type with an extended alignment, or "
        "(2) _DISABLE_EXTENDED_ALIGNED_STORAGE to get the old non-conforming behavior.");
#line 1066 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"
    using type = _Align_type<max_align_t, _Len>;
#line 1068 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"
};

template <size_t _Len, size_t _Align>
struct _Aligned<_Len, _Align, int, false> {
    using _Next                 = double;
    static constexpr bool _Fits = _Align <= alignof(_Next);
    using type                  = typename _Aligned<_Len, _Align, _Next, _Fits>::type;
};

template <size_t _Len, size_t _Align>
struct _Aligned<_Len, _Align, short, false> {
    using _Next                 = int;
    static constexpr bool _Fits = _Align <= alignof(_Next);
    using type                  = typename _Aligned<_Len, _Align, _Next, _Fits>::type;
};

template <size_t _Len, size_t _Align>
struct _Aligned<_Len, _Align, char, false> {
    using _Next                 = short;
    static constexpr bool _Fits = _Align <= alignof(_Next);
    using type                  = typename _Aligned<_Len, _Align, _Next, _Fits>::type;
};


template <size_t _Len, size_t _Align = alignof(max_align_t)>
struct _Aligned_storage { 
    using _Next                 = char;
    static constexpr bool _Fits = _Align <= alignof(_Next);
    using type                  = typename _Aligned<_Len, _Align, _Next, _Fits>::type;
};

template <size_t _Len, size_t _Align = alignof(max_align_t)>
using _Aligned_storage_t = typename _Aligned_storage<_Len, _Align>::type;

 template <size_t _Len, size_t _Align = alignof(max_align_t)>
struct  aligned_storage { 
    using type = _Aligned_storage_t<_Len, _Align>;
};

 template <size_t _Len, size_t _Align = alignof(max_align_t)>
using aligned_storage_t  = _Aligned_storage_t<_Len, _Align>;

template <size_t... _Vals>
struct _Maximum;

template <>
struct _Maximum<> : integral_constant<size_t, 0> {}; 

template <size_t _Val>
struct _Maximum<_Val> : integral_constant<size_t, _Val> {}; 

template <size_t _First, size_t _Second, size_t... _Rest>
struct _Maximum<_First, _Second, _Rest...> : _Maximum<(_First < _Second ? _Second : _First), _Rest...>::type {
    
};

 template <size_t _Len, class... _Types>
struct  aligned_union {
    
    static constexpr size_t _Max_len        = _Maximum<_Len, sizeof(_Types)...>::value; 
    static constexpr size_t alignment_value = _Maximum<alignof(_Types)...>::value;

    using type = _Aligned_storage_t<_Max_len, alignment_value>;
};

__pragma(warning(push)) __pragma(warning(disable : 4996))
 template <size_t _Len, class... _Types>
using aligned_union_t  = typename aligned_union<_Len, _Types...>::type;
__pragma(warning(pop))

template <class _Ty, bool = is_enum_v<_Ty>>
struct _Underlying_type {
    using type = __underlying_type(_Ty);
};

template <class _Ty>
struct _Underlying_type<_Ty, false> {};

 template <class _Ty>
struct underlying_type : _Underlying_type<_Ty> {}; 

 template <class _Ty>
using underlying_type_t = typename _Underlying_type<_Ty>::type;

 template <class _Ty>
inline constexpr size_t rank_v = 0; 

template <class _Ty, size_t _Nx>
inline constexpr size_t rank_v<_Ty[_Nx]> = rank_v<_Ty> + 1;

template <class _Ty>
inline constexpr size_t rank_v<_Ty[]> = rank_v<_Ty> + 1;

 template <class _Ty>
struct rank : integral_constant<size_t, rank_v<_Ty>> {};

 template <class _Ty, unsigned int _Ix = 0>
inline constexpr size_t extent_v = 0; 

template <class _Ty, size_t _Nx>
inline constexpr size_t extent_v<_Ty[_Nx], 0> = _Nx;

template <class _Ty, unsigned int _Ix, size_t _Nx>
inline constexpr size_t extent_v<_Ty[_Nx], _Ix> = extent_v<_Ty, _Ix - 1>;

template <class _Ty, unsigned int _Ix>
inline constexpr size_t extent_v<_Ty[], _Ix> = extent_v<_Ty, _Ix - 1>;

 template <class _Ty, unsigned int _Ix = 0>
struct extent : integral_constant<size_t, extent_v<_Ty, _Ix>> {};

 template <class _Base, class _Derived>
struct is_base_of : bool_constant<__is_base_of(_Base, _Derived)> {
    
};

 template <class _Base, class _Derived>
inline constexpr bool is_base_of_v = __is_base_of(_Base, _Derived);

 template <class _Ty>
struct decay { 
    using _Ty1 = remove_reference_t<_Ty>;
    using _Ty2 = typename _Select<is_function_v<_Ty1>>::template _Apply<add_pointer<_Ty1>, remove_cv<_Ty1>>;
    using type = typename _Select<is_array_v<_Ty1>>::template _Apply<add_pointer<remove_extent_t<_Ty1>>, _Ty2>::type;
};

 template <class _Ty>
using decay_t = typename decay<_Ty>::type;

template <class _Ty1, class _Ty2>
using _Conditional_type = decltype(false ? ::std:: declval<_Ty1>() : ::std:: declval<_Ty2>());


template <class _Ty1, class _Ty2, class = void>
struct _Const_lvalue_cond_oper {};



template <class _Ty1, class _Ty2>
struct _Const_lvalue_cond_oper<_Ty1, _Ty2, void_t<_Conditional_type<const _Ty1&, const _Ty2&>>> {
    using type = remove_cvref_t<_Conditional_type<const _Ty1&, const _Ty2&>>;
};

template <class _Ty1, class _Ty2, class = void>
struct _Decayed_cond_oper : _Const_lvalue_cond_oper<_Ty1, _Ty2> {};



#line 1217 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

template <class _Ty1, class _Ty2>
struct _Decayed_cond_oper<_Ty1, _Ty2, void_t<_Conditional_type<_Ty1, _Ty2>>> {
    using type = decay_t<_Conditional_type<_Ty1, _Ty2>>;
};

 template <class... _Ty>
struct common_type;

 template <class... _Ty>
using common_type_t = typename common_type<_Ty...>::type;

template <>
struct common_type<> {};

template <class _Ty1>
struct common_type<_Ty1> : common_type<_Ty1, _Ty1> {};

template <class _Ty1, class _Ty2, class _Decayed1 = decay_t<_Ty1>, class _Decayed2 = decay_t<_Ty2>>
struct _Common_type2 : common_type<_Decayed1, _Decayed2> {};

template <class _Ty1, class _Ty2>
struct _Common_type2<_Ty1, _Ty2, _Ty1, _Ty2> : _Decayed_cond_oper<_Ty1, _Ty2> {};

template <class _Ty1, class _Ty2>
struct common_type<_Ty1, _Ty2> : _Common_type2<_Ty1, _Ty2> {};

template <class _Void, class _Ty1, class _Ty2, class... _Rest>
struct _Common_type3 {};

template <class _Ty1, class _Ty2, class... _Rest>
struct _Common_type3<void_t<common_type_t<_Ty1, _Ty2>>, _Ty1, _Ty2, _Rest...>
    : common_type<common_type_t<_Ty1, _Ty2>, _Rest...> {};

template <class _Ty1, class _Ty2, class... _Rest>
struct common_type<_Ty1, _Ty2, _Rest...> : _Common_type3<void, _Ty1, _Ty2, _Rest...> {};

template <class _Ty>
_Ty _Returns_exactly() noexcept; 


 template <class, class, template <class> class, template <class> class>
struct basic_common_reference {};

template <class _From>
struct _Copy_cv_impl {
    template <class _To>
    using _Apply = _To;
};
template <class _From>
struct _Copy_cv_impl<const _From> {
    template <class _To>
    using _Apply = const _To;
};
template <class _From>
struct _Copy_cv_impl<volatile _From> {
    template <class _To>
    using _Apply = volatile _To;
};
template <class _From>
struct _Copy_cv_impl<const volatile _From> {
    template <class _To>
    using _Apply = const volatile _To;
};
template <class _From, class _To>
using _Copy_cv = 
    typename _Copy_cv_impl<_From>::template _Apply<_To>;

template <class _Ty1>
struct _Add_qualifiers { 
    template <class _Ty2>
    using _Apply = _Copy_cv<_Ty1, _Ty2>;
};
template <class _Ty1>
struct _Add_qualifiers<_Ty1&> {
    template <class _Ty2>
    using _Apply = add_lvalue_reference_t<_Copy_cv<_Ty1, _Ty2>>;
};
template <class _Ty1>
struct _Add_qualifiers<_Ty1&&> {
    template <class _Ty2>
    using _Apply = add_rvalue_reference_t<_Copy_cv<_Ty1, _Ty2>>;
};


template <class _Ty1, class _Ty2>
using _Cond_res_if_right = 
    decltype(false ? _Returns_exactly<_Ty1>() : _Returns_exactly<_Ty2>());

template <class _Ty>
using _Is_scalar_or_array = disjunction<is_scalar<_Ty>, is_array<_Ty>>;

template <class _Ty1, class _Ty2, class = void>
struct _Cond_res_workaround {};

template <class _Ty1, class _Ty2>
struct _Cond_res_workaround<_Ty1, _Ty2, void_t<_Cond_res_if_right<_Ty1, _Ty2>>> {
    using _Uty = remove_cvref_t<_Ty1>;
    using type = conditional_t<conjunction_v<is_same<_Uty, remove_cvref_t<_Ty2>>, _Is_scalar_or_array<_Uty>,
                                   disjunction<conjunction<is_lvalue_reference<_Ty1>, is_rvalue_reference<_Ty2>>,
                                       conjunction<is_rvalue_reference<_Ty1>, is_lvalue_reference<_Ty2>>>>,
        decay_t<_Copy_cv<remove_reference_t<_Ty1>, remove_reference_t<_Ty2>>>, _Cond_res_if_right<_Ty1, _Ty2>>;
};

template <class _Ty1, class _Ty2>
using _Cond_res = typename _Cond_res_workaround<_Ty1, _Ty2>::type;




#line 1328 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

 template <class...>
struct common_reference;

 template <class... _Types>
using common_reference_t = typename common_reference<_Types...>::type;


template <>
struct common_reference<> {};


template <class _Ty>
struct common_reference<_Ty> {
    using type = _Ty;
};





template <class _Ty1, class _Ty2, class = void>
struct _Common_reference2C : common_type<_Ty1, _Ty2> {};


template <class _Ty1, class _Ty2>
struct _Common_reference2C<_Ty1, _Ty2, void_t<_Cond_res<_Ty1, _Ty2>>> {
    using type = _Cond_res<_Ty1, _Ty2>;
};


template <class _Ty1, class _Ty2>
using _Basic_specialization = typename basic_common_reference<remove_cvref_t<_Ty1>, remove_cvref_t<_Ty2>,
    _Add_qualifiers<_Ty1>::template _Apply, _Add_qualifiers<_Ty2>::template _Apply>::type;

template <class _Ty1, class _Ty2, class = void>
struct _Common_reference2B : _Common_reference2C<_Ty1, _Ty2> {};

template <class _Ty1, class _Ty2>
struct _Common_reference2B<_Ty1, _Ty2, void_t<_Basic_specialization<_Ty1, _Ty2>>> {
    using type = _Basic_specialization<_Ty1, _Ty2>;
};


template <class _Ty1, class _Ty2, class = void>
struct _Common_reference2A : _Common_reference2B<_Ty1, _Ty2> {};

template <class _Ty1, class _Ty2, class _Result = _Cond_res<_Copy_cv<_Ty1, _Ty2>&, _Copy_cv<_Ty2, _Ty1>&>,
    enable_if_t<is_lvalue_reference_v<_Result>, int> = 0>
using _LL_common_ref = _Result;

template <class _Ty1, class _Ty2>
struct _Common_reference2A<_Ty1&, _Ty2&, void_t<_LL_common_ref<_Ty1, _Ty2>>> {
    using type = _LL_common_ref<_Ty1, _Ty2>; 
};

template <class _Ty1, class _Ty2>
struct _Common_reference2A<_Ty1&&, _Ty2&, enable_if_t<is_convertible_v<_Ty1&&, _LL_common_ref<const _Ty1, _Ty2>>>> {
    using type =
        _LL_common_ref<const _Ty1, _Ty2>; 
};

template <class _Ty1, class _Ty2>
struct _Common_reference2A<_Ty1&, _Ty2&&, enable_if_t<is_convertible_v<_Ty2&&, _LL_common_ref<const _Ty2, _Ty1>>>> {
    using type =
        _LL_common_ref<const _Ty2, _Ty1>; 
};

template <class _Ty1, class _Ty2>
using _RR_common_ref = remove_reference_t<_LL_common_ref<_Ty1, _Ty2>>&&;

template <class _Ty1, class _Ty2>
struct _Common_reference2A<_Ty1&&, _Ty2&&,
    enable_if_t<is_convertible_v<_Ty1&&, _RR_common_ref<_Ty1, _Ty2>>
                && is_convertible_v<_Ty2&&, _RR_common_ref<_Ty1, _Ty2>>>> {
    using type = _RR_common_ref<_Ty1, _Ty2>; 
};

template <class _Ty1, class _Ty2>
struct common_reference<_Ty1, _Ty2> : _Common_reference2A<_Ty1, _Ty2> {};


template <class _Void, class _Ty1, class _Ty2, class... _Types>
struct _Fold_common_reference {};
template <class _Ty1, class _Ty2, class... _Types>
struct _Fold_common_reference<void_t<common_reference_t<_Ty1, _Ty2>>, _Ty1, _Ty2, _Types...>
    : common_reference<common_reference_t<_Ty1, _Ty2>, _Types...> {};

template <class _Ty1, class _Ty2, class _Ty3, class... _Rest>
struct common_reference<_Ty1, _Ty2, _Ty3, _Rest...> : _Fold_common_reference<void, _Ty1, _Ty2, _Ty3, _Rest...> {};
#line 1419 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"


 template <class _Ty>
struct type_identity {
    using type = _Ty;
};
 template <class _Ty>
using type_identity_t = typename type_identity<_Ty>::type;
#line 1428 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

template <class _Type, template <class...> class _Template>
inline constexpr bool _Is_specialization_v = false; 
template <template <class...> class _Template, class... _Types>
inline constexpr bool _Is_specialization_v<_Template<_Types...>, _Template> = true;

template <class _Type, template <class...> class _Template>
struct _Is_specialization : bool_constant<_Is_specialization_v<_Type, _Template>> {};

 template <class _Ty>
[[nodiscard]] [[msvc::intrinsic]] constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {
    return static_cast<_Ty&&>(_Arg);
}

 template <class _Ty>
[[nodiscard]] [[msvc::intrinsic]] constexpr _Ty&& forward(remove_reference_t<_Ty>&& _Arg) noexcept {
    static_assert(!is_lvalue_reference_v<_Ty>, "bad forward call");
    return static_cast<_Ty&&>(_Arg);
}

 template <class _Ty>
[[nodiscard]] [[msvc::intrinsic]] constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {
    return static_cast<remove_reference_t<_Ty>&&>(_Arg);
}

 template <class _Ty>
[[nodiscard]] [[msvc::intrinsic]] constexpr 
    conditional_t<!is_nothrow_move_constructible_v<_Ty> && is_copy_constructible_v<_Ty>, const _Ty&, _Ty&&>
    move_if_noexcept(_Ty& _Arg) noexcept {
    return ::std:: move(_Arg);
}

 template <class _Ty>
class reference_wrapper;






enum class _Invoker_strategy {
    _Functor,
    _Pmf_object,
    _Pmf_refwrap,
    _Pmf_pointer,
    _Pmd_object,
    _Pmd_refwrap,
    _Pmd_pointer
};

struct _Invoker_functor {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Functor;

    template <class _Callable, class... _Types>
    static constexpr auto _Call(_Callable&& _Obj, _Types&&... _Args) noexcept(
        noexcept(static_cast<_Callable&&>(_Obj)(static_cast<_Types&&>(_Args)...)))
        -> decltype(static_cast<_Callable&&>(_Obj)(static_cast<_Types&&>(_Args)...)) {
        return static_cast<_Callable&&>(_Obj)(static_cast<_Types&&>(_Args)...);
    }
};

struct _Invoker_pmf_object {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmf_object;

    template <class _Decayed, class _Ty1, class... _Types2>
    static constexpr auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2) noexcept(
        noexcept((static_cast<_Ty1&&>(_Arg1).*_Pmf)(static_cast<_Types2&&>(_Args2)...)))
        -> decltype((static_cast<_Ty1&&>(_Arg1).*_Pmf)(static_cast<_Types2&&>(_Args2)...)) {
        return (static_cast<_Ty1&&>(_Arg1).*_Pmf)(static_cast<_Types2&&>(_Args2)...);
    }
};

struct _Invoker_pmf_refwrap {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmf_refwrap;

    template <class _Decayed, class _Refwrap, class... _Types2>
    static constexpr auto _Call(_Decayed _Pmf, _Refwrap _Rw, _Types2&&... _Args2) noexcept(
        noexcept((_Rw.get().*_Pmf)(static_cast<_Types2&&>(_Args2)...)))
        -> decltype((_Rw.get().*_Pmf)(static_cast<_Types2&&>(_Args2)...)) {
        return (_Rw.get().*_Pmf)(static_cast<_Types2&&>(_Args2)...);
    }
};

struct _Invoker_pmf_pointer {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmf_pointer;

    template <class _Decayed, class _Ty1, class... _Types2>
    static constexpr auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2) noexcept(
        noexcept(((*static_cast<_Ty1&&>(_Arg1)).*_Pmf)(static_cast<_Types2&&>(_Args2)...)))
        -> decltype(((*static_cast<_Ty1&&>(_Arg1)).*_Pmf)(static_cast<_Types2&&>(_Args2)...)) {
        return ((*static_cast<_Ty1&&>(_Arg1)).*_Pmf)(static_cast<_Types2&&>(_Args2)...);
    }
};

struct _Invoker_pmd_object {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmd_object;

    template <class _Decayed, class _Ty1>
    static constexpr auto _Call(_Decayed _Pmd, _Ty1&& _Arg1) noexcept -> decltype(static_cast<_Ty1&&>(_Arg1).*_Pmd) {
        return static_cast<_Ty1&&>(_Arg1).*_Pmd;
    }
};

struct _Invoker_pmd_refwrap {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmd_refwrap;

    template <class _Decayed, class _Refwrap>
    static constexpr auto _Call(_Decayed _Pmd, _Refwrap _Rw) noexcept -> decltype(_Rw.get().*_Pmd) {
        return _Rw.get().*_Pmd;
    }
};

struct _Invoker_pmd_pointer {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmd_pointer;

    template <class _Decayed, class _Ty1>
    static constexpr auto _Call(_Decayed _Pmd, _Ty1&& _Arg1) noexcept(noexcept((*static_cast<_Ty1&&>(_Arg1)).*_Pmd))
        -> decltype((*static_cast<_Ty1&&>(_Arg1)).*_Pmd) {
        return (*static_cast<_Ty1&&>(_Arg1)).*_Pmd;
    }
};

template <class _Callable, class _Ty1, class _Removed_cvref = _Remove_cvref_t<_Callable>,
    bool _Is_pmf = is_member_function_pointer_v<_Removed_cvref>,
    bool _Is_pmd = is_member_object_pointer_v<_Removed_cvref>>
struct _Invoker1;

template <class _Callable, class _Ty1, class _Removed_cvref>
struct _Invoker1<_Callable, _Ty1, _Removed_cvref, true, false>
    : conditional_t<is_base_of_v<typename _Is_memfunptr<_Removed_cvref>::_Class_type, remove_reference_t<_Ty1>>,
          _Invoker_pmf_object,
          conditional_t<_Is_specialization_v<_Remove_cvref_t<_Ty1>, reference_wrapper>, _Invoker_pmf_refwrap,
              _Invoker_pmf_pointer>> {}; 

template <class _Callable, class _Ty1, class _Removed_cvref>
struct _Invoker1<_Callable, _Ty1, _Removed_cvref, false, true>
    : conditional_t<
          is_base_of_v<typename _Is_member_object_pointer<_Removed_cvref>::_Class_type, remove_reference_t<_Ty1>>,
          _Invoker_pmd_object,
          conditional_t<_Is_specialization_v<_Remove_cvref_t<_Ty1>, reference_wrapper>, _Invoker_pmd_refwrap,
              _Invoker_pmd_pointer>> {}; 

template <class _Callable, class _Ty1, class _Removed_cvref>
struct _Invoker1<_Callable, _Ty1, _Removed_cvref, false, false> : _Invoker_functor {};

 template <class _Callable>
constexpr auto invoke(_Callable&& _Obj) noexcept(noexcept(static_cast<_Callable&&>(_Obj)()))
    -> decltype(static_cast<_Callable&&>(_Obj)()) {
    return static_cast<_Callable&&>(_Obj)();
}

 template <class _Callable, class _Ty1, class... _Types2>
constexpr auto invoke(_Callable&& _Obj, _Ty1&& _Arg1, _Types2&&... _Args2) noexcept(
    noexcept(_Invoker1<_Callable, _Ty1>::_Call(
        static_cast<_Callable&&>(_Obj), static_cast<_Ty1&&>(_Arg1), static_cast<_Types2&&>(_Args2)...)))
    -> decltype(_Invoker1<_Callable, _Ty1>::_Call(
        static_cast<_Callable&&>(_Obj), static_cast<_Ty1&&>(_Arg1), static_cast<_Types2&&>(_Args2)...)) {
    if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Functor) {
        return static_cast<_Callable&&>(_Obj)(static_cast<_Ty1&&>(_Arg1), static_cast<_Types2&&>(_Args2)...);
    } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmf_object) {
        return (static_cast<_Ty1&&>(_Arg1).*_Obj)(static_cast<_Types2&&>(_Args2)...);
    } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmf_refwrap) {
        return (_Arg1.get().*_Obj)(static_cast<_Types2&&>(_Args2)...);
    } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmf_pointer) {
        return ((*static_cast<_Ty1&&>(_Arg1)).*_Obj)(static_cast<_Types2&&>(_Args2)...);
    } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmd_object) {
        return static_cast<_Ty1&&>(_Arg1).*_Obj;
    } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmd_refwrap) {
        return _Arg1.get().*_Obj;
    } else {
        static_assert(_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmd_pointer, "bug in invoke");
        return (*static_cast<_Ty1&&>(_Arg1)).*_Obj;
    }
}

#pragma warning(push)
#pragma warning(disable : 4242) 
#pragma warning(disable : 4244) 
#pragma warning(disable : 4365) 

template <class _From, class _To, bool = is_convertible_v<_From, _To>, bool = is_void_v<_To>>
inline constexpr bool _Is_nothrow_convertible_v = noexcept(_Fake_copy_init<_To>(::std:: declval<_From>()));

#pragma warning(pop)

template <class _From, class _To, bool _IsVoid>
inline constexpr bool _Is_nothrow_convertible_v<_From, _To, false, _IsVoid> = false;

template <class _From, class _To>
inline constexpr bool _Is_nothrow_convertible_v<_From, _To, true, true> = true;

template <class _From, class _To>
struct _Is_nothrow_convertible : bool_constant<_Is_nothrow_convertible_v<_From, _To>> {
    
};


 template <class _From, class _To>
inline constexpr bool is_nothrow_convertible_v = _Is_nothrow_convertible_v<_From, _To>;

 template <class _From, class _To>
using is_nothrow_convertible = _Is_nothrow_convertible<_From, _To>;
#line 1631 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

template <class _From, class _To, class = void>
struct _Invoke_convertible : false_type {};

template <class _From, class _To>
struct _Invoke_convertible<_From, _To, void_t<decltype(::std:: _Fake_copy_init<_To>(::std:: _Returns_exactly<_From>()))>>
    : true_type {};

template <class _From, class _To>
struct _Invoke_nothrow_convertible
    : bool_constant<noexcept(::std:: _Fake_copy_init<_To>(::std:: _Returns_exactly<_From>()))> {};

template <class _Result, bool _Nothrow>
struct _Invoke_traits_common {
    using type                  = _Result;
    using _Is_invocable         = true_type;
    using _Is_nothrow_invocable = bool_constant<_Nothrow>;
    template <class _Rx>
    using _Is_invocable_r = bool_constant<disjunction_v<is_void<_Rx>, _Invoke_convertible<type, _Rx>>>;
    template <class _Rx>
    using _Is_nothrow_invocable_r = bool_constant<conjunction_v<_Is_nothrow_invocable,
        disjunction<is_void<_Rx>,
            conjunction<_Invoke_convertible<type, _Rx>, _Invoke_nothrow_convertible<type, _Rx>>>>>;
};

template <class _Void, class _Callable>
struct _Invoke_traits_zero {
    
    using _Is_invocable         = false_type;
    using _Is_nothrow_invocable = false_type;
    template <class _Rx>
    using _Is_invocable_r = false_type;
    template <class _Rx>
    using _Is_nothrow_invocable_r = false_type;
};

template <class _Callable>
using _Decltype_invoke_zero = decltype(::std:: declval<_Callable>()());

template <class _Callable>
struct _Invoke_traits_zero<void_t<_Decltype_invoke_zero<_Callable>>, _Callable>
    : _Invoke_traits_common<_Decltype_invoke_zero<_Callable>, noexcept(::std:: declval<_Callable>()())> {};

template <class _Void, class... _Types>
struct _Invoke_traits_nonzero {
    
    using _Is_invocable         = false_type;
    using _Is_nothrow_invocable = false_type;
    template <class _Rx>
    using _Is_invocable_r = false_type;
    template <class _Rx>
    using _Is_nothrow_invocable_r = false_type;
};

template <class _Callable, class _Ty1, class... _Types2>
using _Decltype_invoke_nonzero = decltype(_Invoker1<_Callable, _Ty1>::_Call(
    ::std:: declval<_Callable>(), ::std:: declval<_Ty1>(), ::std:: declval<_Types2>()...));

template <class _Callable, class _Ty1, class... _Types2>
struct _Invoke_traits_nonzero<void_t<_Decltype_invoke_nonzero<_Callable, _Ty1, _Types2...>>, _Callable, _Ty1,
    _Types2...> : _Invoke_traits_common<_Decltype_invoke_nonzero<_Callable, _Ty1, _Types2...>,
                      noexcept(_Invoker1<_Callable, _Ty1>::_Call(
                          ::std:: declval<_Callable>(), ::std:: declval<_Ty1>(), ::std:: declval<_Types2>()...))> {};

template <class _Callable, class... _Args>
using _Select_invoke_traits = conditional_t<sizeof...(_Args) == 0, _Invoke_traits_zero<void, _Callable>,
    _Invoke_traits_nonzero<void, _Callable, _Args...>>;





















#line 1720 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

template <class _Callable, class... _Args>
using _Invoke_result_t = typename _Select_invoke_traits<_Callable, _Args...>::type;

template <class _Rx, class _Callable, class... _Args>
using _Is_invocable_r_ = typename _Select_invoke_traits<_Callable, _Args...>::template _Is_invocable_r<_Rx>;

template <class _Rx, class _Callable, class... _Args>
struct _Is_invocable_r : _Is_invocable_r_<_Rx, _Callable, _Args...> {
    
};


 template <class _Callable, class... _Args>
struct invoke_result : _Select_invoke_traits<_Callable, _Args...> {
    
};

 template <class _Callable, class... _Args>
using invoke_result_t = typename _Select_invoke_traits<_Callable, _Args...>::type;

 template <class _Callable, class... _Args>
struct is_invocable : _Select_invoke_traits<_Callable, _Args...>::_Is_invocable {
    
};

 template <class _Callable, class... _Args>
inline constexpr bool is_invocable_v = _Select_invoke_traits<_Callable, _Args...>::_Is_invocable::value;

 template <class _Callable, class... _Args>
struct is_nothrow_invocable : _Select_invoke_traits<_Callable, _Args...>::_Is_nothrow_invocable {
    
};

 template <class _Callable, class... _Args>
inline constexpr bool is_nothrow_invocable_v = _Select_invoke_traits<_Callable, _Args...>::_Is_nothrow_invocable::value;

 template <class _Rx, class _Callable, class... _Args>
struct is_invocable_r : _Is_invocable_r_<_Rx, _Callable, _Args...> {
    
};

 template <class _Rx, class _Callable, class... _Args>
inline constexpr bool is_invocable_r_v = _Is_invocable_r_<_Rx, _Callable, _Args...>::value;

 template <class _Rx, class _Callable, class... _Args>
struct is_nothrow_invocable_r : _Select_invoke_traits<_Callable, _Args...>::template _Is_nothrow_invocable_r<_Rx> {
    
};

 template <class _Rx, class _Callable, class... _Args>
inline constexpr bool is_nothrow_invocable_r_v =
    _Select_invoke_traits<_Callable, _Args...>::template _Is_nothrow_invocable_r<_Rx>::value;
#line 1774 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"




 template <class _Ty1, class _Ty2>
struct is_layout_compatible : bool_constant<__is_layout_compatible(_Ty1, _Ty2)> {};

 template <class _Ty1, class _Ty2>
inline constexpr bool is_layout_compatible_v = __is_layout_compatible(_Ty1, _Ty2);

 template <class _Base, class _Derived>
struct is_pointer_interconvertible_base_of : bool_constant<__is_pointer_interconvertible_base_of(_Base, _Derived)> {};

 template <class _Base, class _Derived>
inline constexpr bool is_pointer_interconvertible_base_of_v = __is_pointer_interconvertible_base_of(_Base, _Derived);

 template <class _ClassTy, class _MemberTy>
[[nodiscard]] constexpr bool is_pointer_interconvertible_with_class(_MemberTy _ClassTy::*_Pm) noexcept {
    return __is_pointer_interconvertible_with_class(_ClassTy, _Pm);
}

 template <class _ClassTy1, class _ClassTy2, class _MemberTy1, class _MemberTy2>
[[nodiscard]] constexpr bool is_corresponding_member(_MemberTy1 _ClassTy1::*_Pm1, _MemberTy2 _ClassTy2::*_Pm2) noexcept {
    return __is_corresponding_member(_ClassTy1, _ClassTy2, _Pm1, _Pm2);
}
#line 1800 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"
#line 1801 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"
#line 1802 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

template <class _Ty>
struct _Function_args {}; 







template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...)> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...)> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) volatile> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) volatile> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const volatile> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const volatile> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) &> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) &> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const &> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const &> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) volatile &> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) volatile &> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const volatile &> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const volatile &> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) &&> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) &&> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const &&> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const &&> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) volatile &&> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) volatile &&> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const volatile &&> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const volatile &&> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) volatile noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) volatile noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const volatile noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const volatile noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) & noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) & noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const & noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const & noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) volatile & noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) volatile & noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const volatile & noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const volatile & noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) && noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) && noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const && noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const && noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) volatile && noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) volatile && noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const volatile && noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const volatile && noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; };








template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...)> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) volatile> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const volatile> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) &> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const&> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) volatile&> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const volatile&> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) &&> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const&&> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) volatile&&> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const volatile&&> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) noexcept> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const noexcept> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) volatile noexcept> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const volatile noexcept> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) &noexcept> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const& noexcept> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) volatile& noexcept> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const volatile& noexcept> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) &&noexcept> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const&& noexcept> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) volatile&& noexcept> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const volatile&& noexcept> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; };


template <class _Ty, class = void>
struct _Weak_result_type {}; 

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ty>
struct _Weak_result_type<_Ty, void_t<typename _Ty::result_type>> { 
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = typename _Ty::result_type;
};
__pragma(warning(pop))

template <class _Ty, class = void>
struct _Weak_argument_type : _Weak_result_type<_Ty> {}; 

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ty>
struct _Weak_argument_type<_Ty, void_t<typename _Ty::argument_type>> : _Weak_result_type<_Ty> {
    
    using _Unnameable_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = typename _Ty::argument_type;
};
__pragma(warning(pop))

template <class _Ty, class = void>
struct _Weak_binary_args : _Weak_argument_type<_Ty> {}; 

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ty>
struct _Weak_binary_args<_Ty, void_t<typename _Ty::first_argument_type,
                                  typename _Ty::second_argument_type>>
    : _Weak_argument_type<_Ty> { 
    using _Unnameable_first_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]  = typename _Ty::first_argument_type;
    using _Unnameable_second_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = typename _Ty::second_argument_type;
};
__pragma(warning(pop))

template <class _Ty>
using _Weak_types = conditional_t<is_function_v<remove_pointer_t<_Ty>>, _Function_args<remove_pointer_t<_Ty>>,
    conditional_t<is_member_function_pointer_v<_Ty>, _Is_memfunptr<remove_cv_t<_Ty>>, _Weak_binary_args<_Ty>>>;

template <class _Ty>
void _Refwrap_ctor_fun(_Identity_t<_Ty&>) noexcept; 
template <class _Ty>
void _Refwrap_ctor_fun(_Identity_t<_Ty&&>) = delete;

template <class _Ty, class _Uty, class = void>
struct _Refwrap_has_ctor_from : false_type {};

template <class _Ty, class _Uty>
struct _Refwrap_has_ctor_from<_Ty, _Uty, void_t<decltype(::std:: _Refwrap_ctor_fun<_Ty>(::std:: declval<_Uty>()))>>
    : true_type {}; 

 template <class _Ty>
class reference_wrapper


#line 1879 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"
{
public:
    static_assert(is_object_v<_Ty> || is_function_v<_Ty>,
        "reference_wrapper<T> requires T to be an object type or a function type.");

    using type = _Ty;

    template <class _Uty, enable_if_t<conjunction_v<negation<is_same<_Remove_cvref_t<_Uty>, reference_wrapper>>,
                                          _Refwrap_has_ctor_from<_Ty, _Uty>>,
                              int> = 0>
    constexpr reference_wrapper(_Uty&& _Val) noexcept(
        noexcept(::std:: _Refwrap_ctor_fun<_Ty>(::std:: declval<_Uty>()))) { 
        _Ty& _Ref = static_cast<_Uty&&>(_Val);
        _Ptr      = ::std:: addressof(_Ref);
    }

    constexpr operator _Ty&() const noexcept {
        return *_Ptr;
    }

    [[nodiscard]] constexpr _Ty& get() const noexcept {
        return *_Ptr;
    }

private:
    _Ty* _Ptr{};

public:
    template <class... _Types>
    constexpr auto operator()(_Types&&... _Args) const
        noexcept(noexcept(::std:: invoke(*_Ptr, static_cast<_Types&&>(_Args)...)))
            -> decltype(::std:: invoke(*_Ptr, static_cast<_Types&&>(_Args)...)) {
        return ::std:: invoke(*_Ptr, static_cast<_Types&&>(_Args)...);
    }
};


template <class _Ty>
reference_wrapper(_Ty&) -> reference_wrapper<_Ty>;
#line 1919 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

 template <class _Ty>
[[nodiscard]] constexpr reference_wrapper<_Ty> ref(_Ty& _Val) noexcept {
    return reference_wrapper<_Ty>(_Val);
}

 template <class _Ty>
void ref(const _Ty&&) = delete;

 template <class _Ty>
[[nodiscard]] constexpr reference_wrapper<_Ty> ref(reference_wrapper<_Ty> _Val) noexcept {
    return _Val;
}

 template <class _Ty>
[[nodiscard]] constexpr reference_wrapper<const _Ty> cref(const _Ty& _Val) noexcept {
    return reference_wrapper<const _Ty>(_Val);
}

 template <class _Ty>
void cref(const _Ty&&) = delete;

 template <class _Ty>
[[nodiscard]] constexpr reference_wrapper<const _Ty> cref(reference_wrapper<_Ty> _Val) noexcept {
    return _Val;
}


 template <class _Ty>
struct unwrap_reference {
    using type = _Ty;
};
template <class _Ty>
struct unwrap_reference<reference_wrapper<_Ty>> {
    using type = _Ty&;
};
 template <class _Ty>
using unwrap_reference_t = typename unwrap_reference<_Ty>::type;

 template <class _Ty>
using unwrap_ref_decay_t = unwrap_reference_t<decay_t<_Ty>>;
 template <class _Ty>
struct unwrap_ref_decay {
    using type = unwrap_ref_decay_t<_Ty>;
};
#line 1965 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

template <class _Ty>
struct _Is_swappable;

template <class _Ty>
struct _Is_nothrow_swappable;


 template <class _Ty, enable_if_t<is_move_constructible_v<_Ty> && is_move_assignable_v<_Ty>, int> = 0>


#line 1977 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"
constexpr void swap(_Ty&, _Ty&) noexcept(is_nothrow_move_constructible_v<_Ty>&& is_nothrow_move_assignable_v<_Ty>);

 template <class _Ty, size_t _Size, enable_if_t<_Is_swappable<_Ty>::value, int> = 0>
constexpr void swap(_Ty (&)[_Size], _Ty (&)[_Size]) noexcept(_Is_nothrow_swappable<_Ty>::value);

template <class _Ty1, class _Ty2, class = void>
struct _Swappable_with_helper : false_type {}; 

template <class _Ty1, class _Ty2>
struct _Swappable_with_helper<_Ty1, _Ty2, void_t<decltype(swap(::std:: declval<_Ty1>(), ::std:: declval<_Ty2>()))>>
    : true_type {}; 

template <class _Ty1, class _Ty2>
struct _Is_swappable_with
    : bool_constant<conjunction_v<_Swappable_with_helper<_Ty1, _Ty2>, _Swappable_with_helper<_Ty2, _Ty1>>> {
    
};

template <class _Ty>
struct _Is_swappable : _Is_swappable_with<add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<_Ty>>::type {
    
};

template <class _Ty1, class _Ty2>
struct _Swap_cannot_throw : bool_constant<noexcept(swap(::std:: declval<_Ty1>(), ::std:: declval<_Ty2>()))
                                          && noexcept(swap(::std:: declval<_Ty2>(), ::std:: declval<_Ty1>()))> {
    
    
};

template <class _Ty1, class _Ty2>
struct _Is_nothrow_swappable_with
    : bool_constant<conjunction_v<_Is_swappable_with<_Ty1, _Ty2>, _Swap_cannot_throw<_Ty1, _Ty2>>> {
    
    
};

template <class _Ty>
struct _Is_nothrow_swappable
    : _Is_nothrow_swappable_with<add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<_Ty>>::type {
    
};


 template <class _Ty1, class _Ty2>
struct is_swappable_with : _Is_swappable_with<_Ty1, _Ty2>::type {
    
    
};

 template <class _Ty1, class _Ty2>
inline constexpr bool is_swappable_with_v =
    conjunction_v<_Swappable_with_helper<_Ty1, _Ty2>, _Swappable_with_helper<_Ty2, _Ty1>>;

 template <class _Ty>
struct is_swappable : _Is_swappable<_Ty>::type {}; 

 template <class _Ty>
inline constexpr bool is_swappable_v = _Is_swappable<_Ty>::value;

 template <class _Ty1, class _Ty2>
struct is_nothrow_swappable_with : _Is_nothrow_swappable_with<_Ty1, _Ty2>::type {
    
    
};

 template <class _Ty1, class _Ty2>
inline constexpr bool is_nothrow_swappable_with_v = _Is_nothrow_swappable_with<_Ty1, _Ty2>::value;

 template <class _Ty>
struct is_nothrow_swappable : _Is_nothrow_swappable<_Ty>::type {
    
};

 template <class _Ty>
inline constexpr bool is_nothrow_swappable_v = _Is_nothrow_swappable<_Ty>::value;
#line 2054 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

namespace _Has_ADL_swap_detail {


#line 2059 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"
    void swap();
#line 2061 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

    template <class, class = void>
    struct _Has_ADL_swap : false_type {};
    template <class _Ty>
    struct _Has_ADL_swap<_Ty, void_t<decltype(swap(::std:: declval<_Ty&>(), ::std:: declval<_Ty&>()))>> : true_type {};
} 
using _Has_ADL_swap_detail::_Has_ADL_swap;

template <class _Ty>
inline constexpr bool _Is_trivially_swappable_v = conjunction_v<is_trivially_destructible<_Ty>,
    is_trivially_move_constructible<_Ty>, is_trivially_move_assignable<_Ty>, negation<_Has_ADL_swap<_Ty>>>;


template <>
inline constexpr bool _Is_trivially_swappable_v<byte> = true;
#line 2077 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

template <class _Ty>
struct _Is_trivially_swappable : bool_constant<_Is_trivially_swappable_v<_Ty>> {
    
};


































template <class _Bitmask>
[[nodiscard]] constexpr bool _Bitmask_includes_any(_Bitmask _Left, _Bitmask _Elements) noexcept {
    return (_Left & _Elements) != _Bitmask{};
}

template <class _Bitmask>
[[nodiscard]] constexpr bool _Bitmask_includes_all(_Bitmask _Left, _Bitmask _Elements) noexcept {
    return (_Left & _Elements) == _Elements;
}




inline constexpr size_t _FNV_offset_basis = 14695981039346656037ULL;
inline constexpr size_t _FNV_prime        = 1099511628211ULL;



#line 2135 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

[[nodiscard]] inline size_t _Fnv1a_append_bytes(size_t _Val, const unsigned char* const _First,
    const size_t _Count) noexcept { 
    for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {
        _Val ^= static_cast<size_t>(_First[_Idx]);
        _Val *= _FNV_prime;
    }

    return _Val;
}

template <class _Ty>
[[nodiscard]] size_t _Fnv1a_append_range(const size_t _Val, const _Ty* const _First,
    const _Ty* const _Last) noexcept { 
    static_assert(is_trivial_v<_Ty>, "Only trivial types can be directly hashed.");
    const auto _Firstb = reinterpret_cast<const unsigned char*>(_First);
    const auto _Lastb  = reinterpret_cast<const unsigned char*>(_Last);
    return _Fnv1a_append_bytes(_Val, _Firstb, static_cast<size_t>(_Lastb - _Firstb));
}

template <class _Kty>
[[nodiscard]] size_t _Fnv1a_append_value(
    const size_t _Val, const _Kty& _Keyval) noexcept { 
    static_assert(is_trivial_v<_Kty>, "Only trivial types can be directly hashed.");
    return _Fnv1a_append_bytes(_Val, &reinterpret_cast<const unsigned char&>(_Keyval), sizeof(_Kty));
}

template <class _Kty>
[[nodiscard]] size_t _Hash_representation(const _Kty& _Keyval) noexcept { 
    return _Fnv1a_append_value(_FNV_offset_basis, _Keyval);
}

template <class _Kty>
[[nodiscard]] size_t _Hash_array_representation(
    const _Kty* const _First, const size_t _Count) noexcept { 
    static_assert(is_trivial_v<_Kty>, "Only trivial types can be directly hashed.");
    return _Fnv1a_append_bytes(
        _FNV_offset_basis, reinterpret_cast<const unsigned char*>(_First), _Count * sizeof(_Kty));
}

 template <class _Kty>
struct hash;

template <class _Kty, bool _Enabled>
struct _Conditionally_enabled_hash { 
    using _Unnameable_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Kty;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]   = size_t;

    [[nodiscard]] size_t operator()(const _Kty& _Keyval) const
        noexcept(noexcept(hash<_Kty>::_Do_hash(_Keyval)))   {
        return hash<_Kty>::_Do_hash(_Keyval);
    }
};

template <class _Kty>
struct _Conditionally_enabled_hash<_Kty, false> { 
    _Conditionally_enabled_hash()                                              = delete;
    _Conditionally_enabled_hash(const _Conditionally_enabled_hash&)            = delete;
    _Conditionally_enabled_hash(_Conditionally_enabled_hash&&)                 = delete;
    _Conditionally_enabled_hash& operator=(const _Conditionally_enabled_hash&) = delete;
    _Conditionally_enabled_hash& operator=(_Conditionally_enabled_hash&&)      = delete;
};

 template <class _Kty>
struct hash : _Conditionally_enabled_hash<_Kty, !is_const_v<_Kty> && !is_volatile_v<_Kty>
                                                    && (is_enum_v<_Kty> || is_integral_v<_Kty> || is_pointer_v<_Kty>)> {
    
    static size_t _Do_hash(const _Kty& _Keyval) noexcept {
        return _Hash_representation(_Keyval);
    }
};

template <>
struct hash<float> {
    using _Unnameable_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = float;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]   = size_t;
    [[nodiscard]] size_t operator()(const float _Keyval) const noexcept {
        return _Hash_representation(_Keyval == 0.0F ? 0.0F : _Keyval); 
    }
};

template <>
struct hash<double> {
    using _Unnameable_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = double;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]   = size_t;
    [[nodiscard]] size_t operator()(const double _Keyval) const noexcept {
        return _Hash_representation(_Keyval == 0.0 ? 0.0 : _Keyval); 
    }
};

template <>
struct hash<long double> {
    using _Unnameable_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = long double;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]   = size_t;
    [[nodiscard]] size_t operator()(const long double _Keyval) const noexcept {
        return _Hash_representation(_Keyval == 0.0L ? 0.0L : _Keyval); 
    }
};

template <>
struct hash<nullptr_t> {
    using _Unnameable_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = nullptr_t;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]   = size_t;
    [[nodiscard]] size_t operator()(nullptr_t) const noexcept {
        void* _Null{};
        return _Hash_representation(_Null);
    }
};

template <class _Kty, class = void>
struct _Is_nothrow_hashable : false_type {}; 

template <class _Kty>
struct _Is_nothrow_hashable<_Kty, void_t<decltype(hash<_Kty>{}(::std:: declval<const _Kty&>()))>>
    : bool_constant<noexcept(hash<_Kty>{}(::std:: declval<const _Kty&>()))> {};



template <class _FloatingType>
struct _Floating_type_traits;

template <>
struct _Floating_type_traits<float> {
    static constexpr int32_t _Mantissa_bits           = 24; 
    static constexpr int32_t _Exponent_bits           = 8; 
    static constexpr int32_t _Maximum_binary_exponent = 127; 
    static constexpr int32_t _Minimum_binary_exponent = -126; 
    static constexpr int32_t _Exponent_bias           = 127;
    static constexpr int32_t _Sign_shift              = 31; 
    static constexpr int32_t _Exponent_shift          = 23; 

    using _Uint_type = uint32_t;

    static constexpr uint32_t _Exponent_mask             = 0x000000FFu; 
    static constexpr uint32_t _Normal_mantissa_mask      = 0x00FFFFFFu; 
    static constexpr uint32_t _Denormal_mantissa_mask    = 0x007FFFFFu; 
    static constexpr uint32_t _Special_nan_mantissa_mask = 0x00400000u; 
    static constexpr uint32_t _Shifted_sign_mask         = 0x80000000u; 
    static constexpr uint32_t _Shifted_exponent_mask     = 0x7F800000u; 
};

template <>
struct _Floating_type_traits<double> {
    static constexpr int32_t _Mantissa_bits           = 53; 
    static constexpr int32_t _Exponent_bits           = 11; 
    static constexpr int32_t _Maximum_binary_exponent = 1023; 
    static constexpr int32_t _Minimum_binary_exponent = -1022; 
    static constexpr int32_t _Exponent_bias           = 1023;
    static constexpr int32_t _Sign_shift              = 63; 
    static constexpr int32_t _Exponent_shift          = 52; 

    using _Uint_type = uint64_t;

    static constexpr uint64_t _Exponent_mask             = 0x00000000000007FFu; 
    static constexpr uint64_t _Normal_mantissa_mask      = 0x001FFFFFFFFFFFFFu; 
    static constexpr uint64_t _Denormal_mantissa_mask    = 0x000FFFFFFFFFFFFFu; 
    static constexpr uint64_t _Special_nan_mantissa_mask = 0x0008000000000000u; 
    static constexpr uint64_t _Shifted_sign_mask         = 0x8000000000000000u; 
    static constexpr uint64_t _Shifted_exponent_mask     = 0x7FF0000000000000u; 
};

template <>
struct _Floating_type_traits<long double> : _Floating_type_traits<double> {};




































































#line 2367 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

}



#pragma warning(pop)
#pragma pack(pop)

#line 2376 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"
#line 2377 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"
#pragma external_header(pop)
#line 12 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"



#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\concepts"





#pragma once











#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




namespace std {

template <class _Ty1, class _Ty2>
concept _Same_impl = 



    is_same_v<_Ty1, _Ty2>;
#line 34 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\concepts"

 template <class _Ty1, class _Ty2>
concept same_as = _Same_impl<_Ty1, _Ty2> && _Same_impl<_Ty2, _Ty1>;

 template <class _Derived, class _Base>
concept derived_from = __is_base_of(_Base, _Derived)
    && __is_convertible_to(const volatile _Derived*, const volatile _Base*);

 template <class _From, class _To>

concept convertible_to = is_convertible_v<_From, _To>


#line 48 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\concepts"
    && requires {
        static_cast<_To>(::std:: declval<_From>());
    };

template <class _From, class _To>
concept _Implicitly_convertible_to = is_convertible_v<_From, _To>;

 template <class _Ty1, class _Ty2>
concept common_reference_with =
    requires {
        typename common_reference_t<_Ty1, _Ty2>;
        typename common_reference_t<_Ty2, _Ty1>;
    }
    && same_as<common_reference_t<_Ty1, _Ty2>, common_reference_t<_Ty2, _Ty1>>
    && convertible_to<_Ty1, common_reference_t<_Ty1, _Ty2>>
    && convertible_to<_Ty2, common_reference_t<_Ty1, _Ty2>>;

 template <class _Ty1, class _Ty2>
concept common_with =
    requires {
        typename common_type_t<_Ty1, _Ty2>;
        typename common_type_t<_Ty2, _Ty1>;
    }
    && same_as<common_type_t<_Ty1, _Ty2>, common_type_t<_Ty2, _Ty1>>
    && requires {
        static_cast<common_type_t<_Ty1, _Ty2>>(::std:: declval<_Ty1>());
        static_cast<common_type_t<_Ty1, _Ty2>>(::std:: declval<_Ty2>());
    }
    && common_reference_with<add_lvalue_reference_t<const _Ty1>, add_lvalue_reference_t<const _Ty2>>
    && common_reference_with<add_lvalue_reference_t<common_type_t<_Ty1, _Ty2>>,
        common_reference_t<add_lvalue_reference_t<const _Ty1>, add_lvalue_reference_t<const _Ty2>>>;

 template <class _Ty>
concept integral = is_integral_v<_Ty>;

 template <class _Ty>
concept signed_integral = integral<_Ty> && static_cast<_Ty>(-1) < static_cast<_Ty>(0);

 template <class _Ty>
concept unsigned_integral = integral<_Ty> && !signed_integral<_Ty>;

 template <class _Ty>
concept floating_point = is_floating_point_v<_Ty>;

 template <class _LTy, class _RTy>
concept assignable_from = is_lvalue_reference_v<_LTy>
    && common_reference_with<const remove_reference_t<_LTy>&, const remove_reference_t<_RTy>&>
    && requires(_LTy _Left, _RTy&& _Right) {
        { _Left = static_cast<_RTy&&>(_Right) } -> same_as<_LTy>;
    };



 template <class _Ty>
concept destructible = __is_nothrow_destructible(_Ty);

 template <class _Ty, class... _ArgTys>
concept constructible_from = destructible<_Ty>
    && __is_constructible(_Ty, _ArgTys...);

 template <class _Ty>
concept default_initializable = constructible_from<_Ty>
    && requires {
        _Ty{};
        ::new (static_cast<void*>(nullptr)) _Ty; 
    };

 template <class _Ty>
concept move_constructible = constructible_from<_Ty, _Ty> && convertible_to<_Ty, _Ty>;

template <class _Ty>
concept _Has_class_or_enum_type = __is_class(remove_reference_t<_Ty>) || __is_enum(remove_reference_t<_Ty>)
    || __is_union(remove_reference_t<_Ty>);

namespace ranges {
    namespace _Swap {
        template <class _Ty>
        void swap(_Ty&, _Ty&) = delete;

        template <class _Ty1, class _Ty2>
        concept _Use_ADL_swap = (_Has_class_or_enum_type<_Ty1> || _Has_class_or_enum_type<_Ty2>)
            && requires(_Ty1&& __t, _Ty2&& __u) {
                swap(static_cast<_Ty1&&>(__t), static_cast<_Ty2&&>(__u)); 
            };

        struct _Cpo {
            template <class _Ty1, class _Ty2>
                requires _Use_ADL_swap<_Ty1, _Ty2>
            constexpr void operator()(_Ty1&& __t, _Ty2&& __u) const
                noexcept(noexcept(swap(static_cast<_Ty1&&>(__t), static_cast<_Ty2&&>(__u)))) { 
                swap(static_cast<_Ty1&&>(__t), static_cast<_Ty2&&>(__u)); 
            }

            template <class _Ty>
                requires (!_Use_ADL_swap<_Ty&, _Ty&> && move_constructible<_Ty> && assignable_from<_Ty&, _Ty>)
            constexpr void operator()(_Ty& __x, _Ty& __y) const
                noexcept(is_nothrow_move_constructible_v<_Ty> && is_nothrow_move_assignable_v<_Ty>) {
                _Ty __tmp(static_cast<_Ty&&>(__x));
                __x = static_cast<_Ty&&>(__y);
                __y = static_cast<_Ty&&>(__tmp);
            }

            template <class _Ty1, class _Ty2, size_t _Size>
            constexpr void operator()(_Ty1 (&__t)[_Size], _Ty2 (&__u)[_Size]) const
                noexcept(noexcept((*this)(__t[0], __u[0])))
                requires requires { (*this)(__t[0], __u[0]); } {
                for (size_t __i = 0; __i < _Size; ++__i) {
                    (*this)(__t[__i], __u[__i]);
                }
            }
        };
    } 

    inline namespace _Cpos {
         inline constexpr _Swap::_Cpo swap;
    }
} 

 template <class _Ty>
concept swappable = requires(_Ty& __x, _Ty& __y) {
    ::std::ranges:: swap(__x, __y);
};

 template <class _Ty1, class _Ty2>
concept swappable_with = common_reference_with<_Ty1, _Ty2>
    && requires(_Ty1&& __t, _Ty2&& __u) {
        ::std::ranges:: swap(static_cast<_Ty1&&>(__t), static_cast<_Ty1&&>(__t));
        ::std::ranges:: swap(static_cast<_Ty2&&>(__u), static_cast<_Ty2&&>(__u));
        ::std::ranges:: swap(static_cast<_Ty1&&>(__t), static_cast<_Ty2&&>(__u));
        ::std::ranges:: swap(static_cast<_Ty2&&>(__u), static_cast<_Ty1&&>(__t));
    };

 template <class _Ty>
concept copy_constructible = move_constructible<_Ty>
    && constructible_from<_Ty, _Ty&> && convertible_to<_Ty&, _Ty>
    && constructible_from<_Ty, const _Ty&> && convertible_to<const _Ty&, _Ty>
    && constructible_from<_Ty, const _Ty> && convertible_to<const _Ty, _Ty>;

template <class _Ty>
concept _Boolean_testable_impl = convertible_to<_Ty, bool>;

template <class _Ty>
concept _Boolean_testable = _Boolean_testable_impl<_Ty>
    && requires(_Ty&& __t) {
        { !static_cast<_Ty&&>(__t) } -> _Boolean_testable_impl;
    };

template <class _Ty1, class _Ty2>
concept _Half_equality_comparable =
    requires(const remove_reference_t<_Ty1>& __x, const remove_reference_t<_Ty2>& __y) {
        { __x == __y } -> _Boolean_testable;
        { __x != __y } -> _Boolean_testable;
    };

template <class _Ty1, class _Ty2>
concept _Weakly_equality_comparable_with =
    _Half_equality_comparable<_Ty1, _Ty2> && _Half_equality_comparable<_Ty2, _Ty1>;

 template <class _Ty>
concept equality_comparable = _Half_equality_comparable<_Ty, _Ty>;












#line 221 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\concepts"

 template <class _Ty1, class _Ty2>
concept equality_comparable_with = equality_comparable<_Ty1> && equality_comparable<_Ty2>


#line 227 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\concepts"
    && common_reference_with<const remove_reference_t<_Ty1>&, const remove_reference_t<_Ty2>&>
#line 229 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\concepts"
    && equality_comparable<common_reference_t<const remove_reference_t<_Ty1>&, const remove_reference_t<_Ty2>&>>
    && _Weakly_equality_comparable_with<_Ty1, _Ty2>;

template <class _Ty1, class _Ty2>
concept _Half_ordered = requires(const remove_reference_t<_Ty1>& __t, const remove_reference_t<_Ty2>& __u) {
    { __t <  __u } -> _Boolean_testable;
    { __t >  __u } -> _Boolean_testable;
    { __t <= __u } -> _Boolean_testable;
    { __t >= __u } -> _Boolean_testable;
};

template <class _Ty1, class _Ty2>
concept _Partially_ordered_with = _Half_ordered<_Ty1, _Ty2> && _Half_ordered<_Ty2, _Ty1>;

 template <class _Ty>
concept totally_ordered = equality_comparable<_Ty> && _Half_ordered<_Ty, _Ty>;

 template <class _Ty1, class _Ty2>
concept totally_ordered_with = totally_ordered<_Ty1> && totally_ordered<_Ty2>
    && equality_comparable_with<_Ty1, _Ty2>
    && totally_ordered<common_reference_t<const remove_reference_t<_Ty1>&, const remove_reference_t<_Ty2>&>>
    && _Partially_ordered_with<_Ty1, _Ty2>;

 template <class _Ty>
concept movable = is_object_v<_Ty>
    && move_constructible<_Ty>
    && assignable_from<_Ty&, _Ty>
    && swappable<_Ty>;

 template <class _Ty>
concept copyable = copy_constructible<_Ty>
    && movable<_Ty>
    && assignable_from<_Ty&, _Ty&>
    && assignable_from<_Ty&, const _Ty&>
    && assignable_from<_Ty&, const _Ty>;

 template <class _Ty>
concept semiregular = copyable<_Ty> && default_initializable<_Ty>;

 template <class _Ty>
concept regular = semiregular<_Ty> && equality_comparable<_Ty>;

 template <class _FTy, class... _ArgTys>
concept invocable = requires(_FTy&& _Fn, _ArgTys&&... _Args) {
    ::std:: invoke(static_cast<_FTy&&>(_Fn), static_cast<_ArgTys&&>(_Args)...);
};

 template <class _FTy, class... _ArgTys>
concept regular_invocable = invocable<_FTy, _ArgTys...>;

 template <class _FTy, class... _ArgTys>
concept predicate = regular_invocable<_FTy, _ArgTys...>
    && _Boolean_testable<invoke_result_t<_FTy, _ArgTys...>>;

 template <class _FTy, class _Ty1, class _Ty2>
concept relation =
       predicate<_FTy, _Ty1, _Ty1>
    && predicate<_FTy, _Ty2, _Ty2>
    && predicate<_FTy, _Ty1, _Ty2>
    && predicate<_FTy, _Ty2, _Ty1>;

 template <class _FTy, class _Ty1, class _Ty2>
concept equivalence_relation = relation<_FTy, _Ty1, _Ty2>;

 template <class _FTy, class _Ty1, class _Ty2>
concept strict_weak_order = relation<_FTy, _Ty1, _Ty2>;



template <class _Ty>
struct _Choice_t {
    _Ty _Strategy  = _Ty{};
    bool _No_throw = false;
};

}



#pragma warning(pop)
#pragma pack(pop)
#line 311 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\concepts"
#line 312 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\concepts"
#line 313 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\concepts"
#pragma external_header(pop)
#line 16 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"
#line 17 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"


#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\compare"





#pragma once







#line 15 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\compare"

#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\bit"





#pragma once






#line 14 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\bit"


#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\isa_availability.h"














enum ISA_AVAILABILITY
{
    __ISA_AVAILABLE_X86   = 0,
    __ISA_AVAILABLE_SSE2  = 1,
    __ISA_AVAILABLE_SSE42 = 2,
    __ISA_AVAILABLE_AVX   = 3,
    __ISA_AVAILABLE_ENFSTRG = 4,
    __ISA_AVAILABLE_AVX2 = 5,
    __ISA_AVAILABLE_AVX512 = 6,

    __ISA_AVAILABLE_ARMNT   = 0,   
    __ISA_AVAILABLE_NEON    = 1,   
    __ISA_AVAILABLE_NEON_ARM64 = 2,
                                   
};








#line 39 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\isa_availability.h"

 


 

#line 46 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\isa_availability.h"

#line 48 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\isa_availability.h"
#pragma external_header(pop)
#line 17 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\bit"
#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"





#pragma once




#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cfloat"





#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\float.h"








#pragma once





#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {




    


        


            
        #line 32 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\float.h"
    #line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\float.h"
#line 34 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\float.h"



















    






        
    #line 62 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\float.h"
#line 63 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\float.h"
























































































































































#line 216 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\float.h"

    

#line 220 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\float.h"











__declspec(dllimport) unsigned int __cdecl _clearfp(void);

#pragma warning(push)
#pragma warning(disable: 4141) 

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_controlfp_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) unsigned int __cdecl _controlfp(
     unsigned int _NewValue,
     unsigned int _Mask
    );

#pragma warning(pop)


__declspec(dllimport) void __cdecl _set_controlfp(
     unsigned int _NewValue,
     unsigned int _Mask
    );


__declspec(dllimport) errno_t __cdecl _controlfp_s(
     unsigned int* _CurrentState,
          unsigned int  _NewValue,
          unsigned int  _Mask
    );


__declspec(dllimport) unsigned int __cdecl _statusfp(void);


__declspec(dllimport) void __cdecl _fpreset(void);















__declspec(dllimport) unsigned int __cdecl _control87(
     unsigned int _NewValue,
     unsigned int _Mask
    );













__declspec(dllimport) int* __cdecl __fpecode(void);




__declspec(dllimport) int __cdecl __fpe_flt_rounds(void);












 __declspec(dllimport) double __cdecl _copysign( double _Number,  double _Sign);
 __declspec(dllimport) double __cdecl _chgsign( double _X);
 __declspec(dllimport) double __cdecl _scalb( double _X,  long _Y);
 __declspec(dllimport) double __cdecl _logb( double _X);
 __declspec(dllimport) double __cdecl _nextafter( double _X,  double _Y);
 __declspec(dllimport) int    __cdecl _finite( double _X);
 __declspec(dllimport) int    __cdecl _isnan( double _X);
 __declspec(dllimport) int    __cdecl _fpclass( double _X);


     __declspec(dllimport) float __cdecl _scalbf( float _X,  long _Y);
#line 324 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\float.h"










    
    
    

    
    __declspec(dllimport) void __cdecl fpreset(void);

    
    

    
    

    
    
    

    
    
    
    
    
    
    

    
    
    

    
    
    
    
    

    
    
    
    

    

    
    
    
    
    
    

    
    
    
    

    
    
    
    
    
    

    
    
    
    

    

#line 403 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\float.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#line 410 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\float.h"
#pragma external_header(pop)
#line 12 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cfloat"
#line 13 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cfloat"
#pragma external_header(pop)
#line 12 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"

#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cwchar"





#pragma once





#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cstdio"





#pragma once





#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"







#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"









#pragma once


#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_stdio_config.h"







#pragma once



#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {



#line 21 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_stdio_config.h"




#line 26 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_stdio_config.h"
    
#line 28 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_stdio_config.h"


    

#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_stdio_config.h"
        
    

#line 37 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_stdio_config.h"
#line 38 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_stdio_config.h"














    








#line 62 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_stdio_config.h"




#line 67 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_stdio_config.h"

    
        


            #pragma detect_mismatch("_CRT_STDIO_ISO_WIDE_SPECIFIERS", "0")
        #line 74 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_stdio_config.h"
    #line 75 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_stdio_config.h"
#line 76 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_stdio_config.h"






#line 83 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_stdio_config.h"


    
    
     
    
    __declspec(noinline) __inline unsigned __int64* __cdecl __local_stdio_printf_options(void)
    {
        static unsigned __int64 _OptionsStorage;
        return &_OptionsStorage;
    }

    
    
     
    
    __declspec(noinline) __inline unsigned __int64* __cdecl __local_stdio_scanf_options(void)
    {
        static unsigned __int64 _OptionsStorage;
        return &_OptionsStorage;
    }
#line 105 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_stdio_config.h"



#line 109 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_stdio_config.h"




















} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {







    
    typedef struct _iobuf
    {
        void* _Placeholder;
    } FILE;
#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

__declspec(dllimport) FILE* __cdecl __acrt_iob_func(unsigned _Ix);










    
    
    
    
    
    
    __declspec(dllimport) wint_t __cdecl fgetwc(
         FILE* _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _fgetwchar(void);

    
    __declspec(dllimport) wint_t __cdecl fputwc(
            wchar_t _Character,
         FILE*   _Stream);

    
    __declspec(dllimport) wint_t __cdecl _fputwchar(
         wchar_t _Character
        );

    
    __declspec(dllimport) wint_t __cdecl getwc(
         FILE* _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl getwchar(void);


    
    
    __declspec(dllimport) wchar_t* __cdecl fgetws(
         wchar_t* _Buffer,
                                 int      _BufferCount,
                              FILE*    _Stream
        );

    
    __declspec(dllimport) int __cdecl fputws(
          wchar_t const* _Buffer,
         FILE*          _Stream
        );

    
    
    __declspec(dllimport) wchar_t* __cdecl _getws_s(
         wchar_t* _Buffer,
                                 size_t   _BufferCount
        );

    extern "C++" { template <size_t _Size> inline wchar_t* __cdecl _getws_s(wchar_t (&_Buffer)[_Size]) throw() { return _getws_s(_Buffer, _Size); } }





    
    __declspec(dllimport) wint_t __cdecl putwc(
            wchar_t _Character,
         FILE*   _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl putwchar(
         wchar_t _Character
        );

    
    __declspec(dllimport) int __cdecl _putws(
         wchar_t const* _Buffer
        );

    
    __declspec(dllimport) wint_t __cdecl ungetwc(
            wint_t _Character,
         FILE*  _Stream
        );

    
    __declspec(dllimport) FILE * __cdecl _wfdopen(
           int            _FileHandle,
         wchar_t const* _Mode
        );

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wfopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) FILE* __cdecl _wfopen(
         wchar_t const* _FileName,
         wchar_t const* _Mode
        );

    
    __declspec(dllimport) errno_t __cdecl _wfopen_s(
         FILE**         _Stream,
                            wchar_t const* _FileName,
                            wchar_t const* _Mode
        );

    
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wfreopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) FILE* __cdecl _wfreopen(
          wchar_t const* _FileName,
          wchar_t const* _Mode,
         FILE*          _OldStream
        );

    
    __declspec(dllimport) errno_t __cdecl _wfreopen_s(
         FILE**         _Stream,
                            wchar_t const* _FileName,
                            wchar_t const* _Mode,
                           FILE*          _OldStream
        );

    
    __declspec(dllimport) FILE* __cdecl _wfsopen(
         wchar_t const* _FileName,
         wchar_t const* _Mode,
           int            _ShFlag
        );

    __declspec(dllimport) void __cdecl _wperror(
         wchar_t const* _ErrorMessage
        );

    

        
        __declspec(dllimport) FILE* __cdecl _wpopen(
             wchar_t const* _Command,
             wchar_t const* _Mode
            );

    #line 181 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    __declspec(dllimport) int __cdecl _wremove(
         wchar_t const* _FileName
        );

    
    

    
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wtempnam(
         wchar_t const* _Directory,
         wchar_t const* _FilePrefix
        );

    

    
    
    __declspec(dllimport) errno_t __cdecl _wtmpnam_s(
         wchar_t* _Buffer,
                                 size_t   _BufferCount
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _wtmpnam_s(wchar_t (&_Buffer)[_Size]) throw() { return _wtmpnam_s(_Buffer, _Size); } }





    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wtmpnam_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wtmpnam( wchar_t *_Buffer);







    
    
    
    
    
    
    __declspec(dllimport) wint_t __cdecl _fgetwc_nolock(
         FILE* _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _fputwc_nolock(
            wchar_t _Character,
         FILE*   _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _getwc_nolock(
         FILE* _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _putwc_nolock(
            wchar_t _Character,
         FILE*   _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _ungetwc_nolock(
            wint_t _Character,
         FILE*  _Stream
        );

    



#line 256 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"



    
    





    
    
    
    
    
    
    __declspec(dllimport) int __cdecl __stdio_common_vfwprintf(
                                            unsigned __int64 _Options,
                                         FILE*            _Stream,
          wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __stdio_common_vfwprintf_s(
                                            unsigned __int64 _Options,
                                         FILE*            _Stream,
          wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __stdio_common_vfwprintf_p(
                                            unsigned __int64 _Options,
                                         FILE*            _Stream,
          wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __inline int __cdecl _vfwprintf_l(
                                         FILE*          const _Stream,
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 308 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwprintf((*__local_stdio_printf_options()) , _Stream, _Format, _Locale, _ArgList);
    }
    #line 312 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl vfwprintf(
                               FILE*          const _Stream,
          wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 322 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_l(_Stream, _Format, 0 , _ArgList);
    }
    #line 326 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vfwprintf_s_l(
                                         FILE*          const _Stream,
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 337 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwprintf_s((*__local_stdio_printf_options()) , _Stream, _Format, _Locale, _ArgList);
    }
    #line 341 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl vfwprintf_s(
                                   FILE*          const _Stream,
              wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 353 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwprintf_s_l(_Stream, _Format, 0 , _ArgList);
        }
    #line 357 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    #line 359 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vfwprintf_p_l(
                                         FILE*          const _Stream,
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 370 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwprintf_p((*__local_stdio_printf_options()) , _Stream, _Format, _Locale, _ArgList);
    }
    #line 374 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vfwprintf_p(
                               FILE*          const _Stream,
          wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 384 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_p_l(_Stream, _Format, 0 , _ArgList);
    }
    #line 388 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwprintf_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 398 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_l((__acrt_iob_func(1)) , _Format, _Locale, _ArgList);
    }
    #line 402 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl vwprintf(
          wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 411 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_l((__acrt_iob_func(1)) , _Format, 0 , _ArgList);
    }
    #line 415 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwprintf_s_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 425 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_s_l((__acrt_iob_func(1)) , _Format, _Locale, _ArgList);
    }
    #line 429 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl vwprintf_s(
              wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 440 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwprintf_s_l((__acrt_iob_func(1)) , _Format, 0 , _ArgList);
        }
    #line 444 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    #line 446 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwprintf_p_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 456 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_p_l((__acrt_iob_func(1)) , _Format, _Locale, _ArgList);
    }
    #line 460 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwprintf_p(
          wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 469 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_p_l((__acrt_iob_func(1)) , _Format, 0 , _ArgList);
    }
    #line 473 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwprintf_l(
                                         FILE*          const _Stream,
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 483 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfwprintf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 492 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl fwprintf(
                               FILE*          const _Stream,
          wchar_t const* const _Format,
        ...)
    

#line 501 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vfwprintf_l(_Stream, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 510 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwprintf_s_l(
                                         FILE*          const _Stream,
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 520 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfwprintf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 529 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl fwprintf_s(
                                   FILE*          const _Stream,
              wchar_t const* const _Format,
            ...)
    

#line 540 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
            _Result = _vfwprintf_s_l(_Stream, _Format, 0 , _ArgList);
            ((void)(_ArgList = (va_list)0)) ;
            return _Result;
        }
    #line 549 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    #line 551 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwprintf_p_l(
                                         FILE*          const _Stream,
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 561 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfwprintf_p_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 570 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwprintf_p(
                               FILE*          const _Stream,
          wchar_t const* const _Format,
        ...)
    

#line 579 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vfwprintf_p_l(_Stream, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 588 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wprintf_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 597 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfwprintf_l((__acrt_iob_func(1)) , _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 606 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl wprintf(
          wchar_t const* const _Format,
        ...)
    

#line 614 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vfwprintf_l((__acrt_iob_func(1)) , _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 623 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wprintf_s_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 632 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfwprintf_s_l((__acrt_iob_func(1)) , _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 641 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl wprintf_s(
              wchar_t const* const _Format,
            ...)
    

#line 651 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
            _Result = _vfwprintf_s_l((__acrt_iob_func(1)) , _Format, 0 , _ArgList);
            ((void)(_ArgList = (va_list)0)) ;
            return _Result;
        }
    #line 660 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    #line 662 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wprintf_p_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 671 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfwprintf_p_l((__acrt_iob_func(1)) , _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 680 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wprintf_p(
          wchar_t const* const _Format,
        ...)
    

#line 688 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vfwprintf_p_l((__acrt_iob_func(1)) , _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 697 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"


    
    
    
    
    
    
    __declspec(dllimport) int __cdecl __stdio_common_vfwscanf(
                                           unsigned __int64 _Options,
                                        FILE*            _Stream,
          wchar_t const*   _Format,
                                       _locale_t        _Locale,
                                               va_list          _ArgList
        );

    
    __inline int __cdecl _vfwscanf_l(
         FILE*                                const _Stream,
          wchar_t const* const _Format,
                              _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 723 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwscanf(
            (*__local_stdio_scanf_options ()) ,
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 729 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl vfwscanf(
         FILE*                                const _Stream,
          wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 739 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_l(_Stream, _Format, 0 , _ArgList);
    }
    #line 743 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vfwscanf_s_l(
                               FILE*          const _Stream,
          wchar_t const* const _Format,
                              _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 754 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0) ,
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 760 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl vfwscanf_s(
                                   FILE*          const _Stream,
              wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 772 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwscanf_s_l(_Stream, _Format, 0 , _ArgList);
        }
    #line 776 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    #line 778 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    __inline int __cdecl _vwscanf_l(
          wchar_t const* const _Format,
                              _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 787 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_l((__acrt_iob_func(0)) , _Format, _Locale, _ArgList);
    }
    #line 791 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl vwscanf(
          wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 800 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_l((__acrt_iob_func(0)) , _Format, 0 , _ArgList);
    }
    #line 804 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwscanf_s_l(
          wchar_t const* const _Format,
                              _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 814 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_s_l((__acrt_iob_func(0)) , _Format, _Locale, _ArgList);
    }
    #line 818 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl vwscanf_s(
              wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 829 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwscanf_s_l((__acrt_iob_func(0)) , _Format, 0 , _ArgList);
        }
    #line 833 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    #line 835 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _fwscanf_l(
                                        FILE*          const _Stream,
          wchar_t const* const _Format,
                                       _locale_t      const _Locale,
        ...)
    

#line 845 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfwscanf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 854 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "fwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl fwscanf(
                              FILE*          const _Stream,
          wchar_t const* const _Format,
        ...)
    

#line 863 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vfwscanf_l(_Stream, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 872 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwscanf_s_l(
                                          FILE*          const _Stream,
          wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 882 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfwscanf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 891 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl fwscanf_s(
                                    FILE*          const _Stream,
              wchar_t const* const _Format,
            ...)
    

#line 902 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
            _Result = _vfwscanf_s_l(_Stream, _Format, 0 , _ArgList);
            ((void)(_ArgList = (va_list)0)) ;
            return _Result;
        }
    #line 911 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    #line 913 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _wscanf_l(
          wchar_t const* const _Format,
                                       _locale_t      const _Locale,
        ...)
    

#line 922 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfwscanf_l((__acrt_iob_func(0)) , _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 931 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "wscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl wscanf(
          wchar_t const* const _Format,
        ...)
    

#line 939 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vfwscanf_l((__acrt_iob_func(0)) , _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 948 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wscanf_s_l(
          wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 957 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfwscanf_s_l((__acrt_iob_func(0)) , _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 966 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl wscanf_s(
              wchar_t const* const _Format,
            ...)
    

#line 976 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
            _Result = _vfwscanf_s_l((__acrt_iob_func(0)) , _Format, 0 , _ArgList);
            ((void)(_ArgList = (va_list)0)) ;
            return _Result;
        }
    #line 985 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    #line 987 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"



    
    
    
    
    
    
        



    

#line 1003 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __declspec(dllimport) int __cdecl __stdio_common_vswprintf(
                                            unsigned __int64 _Options,
                wchar_t*         _Buffer,
                                            size_t           _BufferCount,
          wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    
    __declspec(dllimport) int __cdecl __stdio_common_vswprintf_s(
                                            unsigned __int64 _Options,
                    wchar_t*         _Buffer,
                                            size_t           _BufferCount,
          wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    
    __declspec(dllimport) int __cdecl __stdio_common_vsnwprintf_s(
                                            unsigned __int64 _Options,
                wchar_t*         _Buffer,
                                            size_t           _BufferCount,
                                            size_t           _MaxCount,
          wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    
    __declspec(dllimport) int __cdecl __stdio_common_vswprintf_p(
                                            unsigned __int64 _Options,
                    wchar_t*         _Buffer,
                                            size_t           _BufferCount,
          wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsnwprintf_l(
          wchar_t*       const _Buffer,
                                                 size_t         const _BufferCount,
               wchar_t const* const _Format,
                                             _locale_t      const _Locale,
                                                     va_list              _ArgList
        )
    

#line 1061 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()) | (1ULL << 0) ,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1069 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _vsnwprintf_s_l(
          wchar_t*       const _Buffer,
                                                      size_t         const _BufferCount,
                                                      size_t         const _MaxCount,
                    wchar_t const* const _Format,
                                                  _locale_t      const _Locale,
                                                          va_list              _ArgList
        )
    

#line 1083 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vsnwprintf_s(
            (*__local_stdio_printf_options()) ,
            _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1091 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _vsnwprintf_s(
          wchar_t*       const _Buffer,
                                                      size_t         const _BufferCount,
                                                      size_t         const _MaxCount,
                              wchar_t const* const _Format,
                                                          va_list              _ArgList
        )
    

#line 1104 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0 , _ArgList);
    }
    #line 1108 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline int __cdecl _snwprintf( wchar_t *_Buffer, size_t _BufferCount, wchar_t const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline int __cdecl _vsnwprintf( wchar_t *_Buffer, size_t _BufferCount, wchar_t const* _Format, va_list _Args);








    
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsnwprintf(
          wchar_t*       _Buffer,
                                                 size_t         _BufferCount,
                         wchar_t const* _Format,
                                                     va_list        _ArgList
        )
    

#line 1129 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
    }
    #line 1133 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { template <size_t _Size> inline int __cdecl _vsnwprintf_s(wchar_t (&_Buffer)[_Size], size_t _BufferCount, wchar_t const* _Format, va_list _ArgList) throw() { return _vsnwprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }








    
    
    __inline int __cdecl _vswprintf_c_l(
          wchar_t*       const _Buffer,
                                                      size_t         const _BufferCount,
                    wchar_t const* const _Format,
                                                  _locale_t      const _Locale,
                                                          va_list              _ArgList
        )
    

#line 1155 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()) ,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1163 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _vswprintf_c(
          wchar_t*       const _Buffer,
                                                      size_t         const _BufferCount,
                              wchar_t const* const _Format,
                                                          va_list              _ArgList
        )
    

#line 1175 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
    }
    #line 1179 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _vswprintf_l(
          wchar_t*       const _Buffer,
                                                      size_t         const _BufferCount,
                    wchar_t const* const _Format,
                                                  _locale_t      const _Locale,
                                                          va_list              _ArgList
        )
    

#line 1192 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }
    #line 1196 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl __vswprintf_l(
                 wchar_t*       const _Buffer,
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 1208 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 1212 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _vswprintf(
          wchar_t*       const _Buffer,
             wchar_t const* const _Format,
                                         va_list              _ArgList
        )
    

#line 1223 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, 0 , _ArgList);
    }
    #line 1227 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl vswprintf(
          wchar_t*       const _Buffer,
                                                      size_t         const _BufferCount,
                    wchar_t const* const _Format,
                                                          va_list              _ArgList
        )
    

#line 1239 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
    }
    #line 1243 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _vswprintf_s_l(
          wchar_t*       const _Buffer,
                                                  size_t         const _BufferCount,
                wchar_t const* const _Format,
                                              _locale_t      const _Locale,
                                                      va_list              _ArgList
        )
    

#line 1256 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf_s(
            (*__local_stdio_printf_options()) ,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1264 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl vswprintf_s(
              wchar_t*       const _Buffer,
                                                      size_t         const _BufferCount,
                              wchar_t const* const _Format,
                                                          va_list              _ArgList
            )
    

#line 1277 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
        }
    #line 1281 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    #line 1283 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { template <size_t _Size> inline int __cdecl vswprintf_s(wchar_t (&_Buffer)[_Size], wchar_t const* _Format, va_list _ArgList) throw() { return vswprintf_s(_Buffer, _Size, _Format, _ArgList); } }







    
    
    __inline int __cdecl _vswprintf_p_l(
          wchar_t*       const _Buffer,
                                                  size_t         const _BufferCount,
                wchar_t const* const _Format,
                                              _locale_t      const _Locale,
                                                      va_list              _ArgList
        )
    

#line 1304 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf_p(
            (*__local_stdio_printf_options()) ,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1312 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _vswprintf_p(
          wchar_t*       const _Buffer,
                                                  size_t         const _BufferCount,
                          wchar_t const* const _Format,
                                                      va_list              _ArgList
        )
    

#line 1324 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
    }
    #line 1328 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _vscwprintf_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 1339 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1) ,
            0 , 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1347 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _vscwprintf(
          wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 1357 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vscwprintf_l(_Format, 0 , _ArgList);
    }
    #line 1361 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _vscwprintf_p_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 1372 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf_p(
            (*__local_stdio_printf_options()) | (1ULL << 1) ,
            0 , 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1380 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _vscwprintf_p(
          wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 1390 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vscwprintf_p_l(_Format, 0 , _ArgList);
    }
    #line 1394 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl __swprintf_l(
                 wchar_t*       const _Buffer,
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 1405 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = __vswprintf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1414 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _swprintf_l(
          wchar_t*       const _Buffer,
                                                      size_t         const _BufferCount,
                    wchar_t const* const _Format,
                                                  _locale_t      const _Locale,
        ...)
    

#line 1426 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1435 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _swprintf(
          wchar_t*       const _Buffer,
             wchar_t const* const _Format,
        ...)
    

#line 1445 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = __vswprintf_l(_Buffer, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1454 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl swprintf(
          wchar_t*       const _Buffer,
                                                      size_t         const _BufferCount,
                              wchar_t const* const _Format,
        ...)
    

#line 1465 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1474 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "__swprintf_l_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline int __cdecl __swprintf_l( wchar_t *_Buffer, wchar_t const* _Format, _locale_t _Locale, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vswprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline int __cdecl __vswprintf_l( wchar_t *_Buffer, wchar_t const* _Format, _locale_t _Locale, va_list _Args);








    __declspec(deprecated("This function or variable may be unsafe. Consider using " "swprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline int __cdecl _swprintf( wchar_t *_Buffer, wchar_t const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "vswprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline int __cdecl _vswprintf( wchar_t *_Buffer, wchar_t const* _Format, va_list _Args);






    
    
    __inline int __cdecl _swprintf_s_l(
          wchar_t*       const _Buffer,
                                                  size_t         const _BufferCount,
                wchar_t const* const _Format,
                                              _locale_t      const _Locale,
        ...)
    

#line 1502 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1511 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl swprintf_s(
              wchar_t*       const _Buffer,
                                                      size_t         const _BufferCount,
                              wchar_t const* const _Format,
            ...)
    

#line 1523 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
            _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
            ((void)(_ArgList = (va_list)0)) ;
            return _Result;
        }
    #line 1532 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    #line 1534 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { template <size_t _Size> inline int __cdecl swprintf_s(wchar_t (&_Buffer)[_Size], wchar_t const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return vswprintf_s(_Buffer, _Size, _Format, _ArgList); } }






    
    
    __inline int __cdecl _swprintf_p_l(
          wchar_t*       const _Buffer,
                                                  size_t         const _BufferCount,
                wchar_t const* const _Format,
                                              _locale_t      const _Locale,
        ...)
    

#line 1553 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1562 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _swprintf_p(
          wchar_t*       const _Buffer,
                                                  size_t         const _BufferCount,
                          wchar_t const* const _Format,
        ...)
    

#line 1573 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1582 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _swprintf_c_l(
          wchar_t*       const _Buffer,
                                                      size_t         const _BufferCount,
                    wchar_t const* const _Format,
                                                  _locale_t      const _Locale,
        ...)
    

#line 1594 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1603 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _swprintf_c(
          wchar_t*       const _Buffer,
                                                      size_t         const _BufferCount,
                              wchar_t const* const _Format,
        ...)
    

#line 1614 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1623 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snwprintf_l(
          wchar_t*       const _Buffer,
                                                 size_t         const _BufferCount,
               wchar_t const* const _Format,
                                             _locale_t      const _Locale,
        ...)
    

#line 1635 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;

        _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1646 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _snwprintf(
          wchar_t*       _Buffer,
                                                 size_t         _BufferCount,
                         wchar_t const* _Format,
        ...)
    

#line 1657 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;

        _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);

        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1668 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _snwprintf_s_l(
          wchar_t*       const _Buffer,
                                                      size_t         const _BufferCount,
                                                      size_t         const _MaxCount,
                    wchar_t const* const _Format,
                                                  _locale_t      const _Locale,
        ...)
    

#line 1681 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1690 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _snwprintf_s(
          wchar_t*       const _Buffer,
                                                      size_t         const _BufferCount,
                                                      size_t         const _MaxCount,
                              wchar_t const* const _Format,
        ...)
    

#line 1702 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1711 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { template <size_t _Size> inline int __cdecl _snwprintf_s(wchar_t (&_Buffer)[_Size], size_t _BufferCount, wchar_t const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return _vsnwprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }







    
    __inline int __cdecl _scwprintf_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 1728 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vscwprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1737 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _scwprintf(
          wchar_t const* const _Format,
        ...)
    

#line 1746 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vscwprintf_l(_Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1755 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _scwprintf_p_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 1765 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vscwprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1774 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _scwprintf_p(
          wchar_t const* const _Format,
        ...)
    

#line 1783 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vscwprintf_p_l(_Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1792 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"


    
        
        
        #pragma warning(push)
        #pragma warning(disable: 4141 6054)

        

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "swprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
            inline int swprintf(
                         wchar_t*       const _Buffer,
                  wchar_t const* const _Format,
                ...) throw()
            {
                int _Result;
                va_list _ArgList;
                ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
                _Result = vswprintf(_Buffer, 2147483647 , _Format, _ArgList);
                ((void)(_ArgList = (va_list)0)) ;
                return _Result;
            }

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "vswprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
            inline int __cdecl vswprintf(
                         wchar_t*       const _Buffer,
                  wchar_t const* const _Format,
                                              va_list              _ArgList
                ) throw()
            {
                return vswprintf(_Buffer, 2147483647 , _Format, _ArgList);
            }

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_swprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
            inline int _swprintf_l(
                                   wchar_t*       const _Buffer,
                  wchar_t const* const _Format,
                                                _locale_t      const _Locale,
                ...) throw()
            {
                int _Result;
                va_list _ArgList;
                ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
                _Result = _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
                ((void)(_ArgList = (va_list)0)) ;
                return _Result;
            }

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vswprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
            inline int __cdecl _vswprintf_l(
                                   wchar_t*       const _Buffer,
                  wchar_t const* const _Format,
                                                _locale_t      const _Locale,
                                                        va_list              _ArgList
                ) throw()
            {
                return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
            }

        #line 1853 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

        #pragma warning(pop)
    #line 1856 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    




#line 1863 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"


    
    
    
    
    
    
    __declspec(dllimport) int __cdecl __stdio_common_vswscanf(
                                           unsigned __int64 _Options,
                wchar_t const*   _Buffer,
                                           size_t           _BufferCount,
          wchar_t const*   _Format,
                                       _locale_t        _Locale,
                                               va_list          _ArgList
        );

    
    
    __inline int __cdecl _vswscanf_l(
                                wchar_t const* const _Buffer,
          wchar_t const* const _Format,
                              _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 1891 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()) ,
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 1897 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl vswscanf(
                                wchar_t const* _Buffer,
          wchar_t const* _Format,
                                      va_list        _ArgList
        )
    

#line 1908 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswscanf_l(_Buffer, _Format, 0 , _ArgList);
    }
    #line 1912 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _vswscanf_s_l(
                                wchar_t const* const _Buffer,
          wchar_t const* const _Format,
                              _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 1924 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0) ,
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 1930 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    

        
        
        __inline int __cdecl vswscanf_s(
                                    wchar_t const* const _Buffer,
              wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 1943 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vswscanf_s_l(_Buffer, _Format, 0 , _ArgList);
        }
    #line 1947 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    #line 1949 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { template <size_t _Size> inline int __cdecl vswscanf_s(wchar_t (&_Buffer)[_Size], wchar_t const* _Format, va_list _ArgList) throw() { return vswscanf_s(_Buffer, _Size, _Format, _ArgList); } }







    
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsnwscanf_l(
                wchar_t const* const _Buffer,
                                           size_t         const _BufferCount,
          wchar_t const* const _Format,
                                       _locale_t      const _Locale,
                                               va_list              _ArgList
        )
    

#line 1970 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()) ,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }
    #line 1976 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _vsnwscanf_s_l(
                  wchar_t const* const _Buffer,
                                             size_t         const _BufferCount,
          wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                 va_list              _ArgList
        )
    

#line 1989 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0) ,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }
    #line 1995 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_swscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _swscanf_l(
                                         wchar_t const* const _Buffer,
          wchar_t const* const _Format,
                                       _locale_t            _Locale,
        ...)
    

#line 2006 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vswscanf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2015 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "swscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl swscanf(
                               wchar_t const* const _Buffer,
          wchar_t const* const _Format,
        ...)
    

#line 2025 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vswscanf_l(_Buffer, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2034 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _swscanf_s_l(
                                           wchar_t const* const _Buffer,
          wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 2045 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vswscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2054 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    

        
        
        __inline int __cdecl swscanf_s(
                                     wchar_t const* const _Buffer,
              wchar_t const* const _Format,
            ...)
    

#line 2066 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
            _Result = _vswscanf_s_l(_Buffer, _Format, 0 , _ArgList);
            ((void)(_ArgList = (va_list)0)) ;
            return _Result;
        }
    #line 2075 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    #line 2077 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snwscanf_l(
                wchar_t const* const _Buffer,
                                           size_t         const _BufferCount,
          wchar_t const* const _Format,
                                       _locale_t      const _Locale,
        ...)
    

#line 2089 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;

        _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2100 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snwscanf(
          wchar_t const* const _Buffer,
                                     size_t         const _BufferCount,
              wchar_t const* const _Format,
        ...)
    

#line 2111 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;

        _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);

        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2122 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _snwscanf_s_l(
                  wchar_t const* const _Buffer,
                                             size_t         const _BufferCount,
          wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 2134 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2143 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _snwscanf_s(
           wchar_t const* const _Buffer,
                                      size_t         const _BufferCount,
             wchar_t const* const _Format,
        ...)
    

#line 2154 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2163 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    


#line 2168 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {

 





























    
#line 53 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"



 











    
    
#line 71 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"


typedef __int64 fpos_t;





    
    __declspec(dllimport) errno_t __cdecl _get_stream_buffer_pointers(
              FILE*   _Stream,
         char*** _Base,
         char*** _Pointer,
         int**   _Count
        );


    
    
    
    
    
    

        
        __declspec(dllimport) errno_t __cdecl clearerr_s(
             FILE* _Stream
            );

        
        
        __declspec(dllimport) errno_t __cdecl fopen_s(
             FILE**      _Stream,
                                    char const* _FileName,
                                    char const* _Mode
            );

        
        
        __declspec(dllimport) size_t __cdecl fread_s(
               void*  _Buffer,
                                   size_t _BufferSize,
                                                                           size_t _ElementSize,
                                                                           size_t _ElementCount,
                                                                        FILE*  _Stream
            );

        
        __declspec(dllimport) errno_t __cdecl freopen_s(
             FILE**      _Stream,
                                char const* _FileName,
                                char const* _Mode,
                               FILE*       _OldStream
            );

        
        __declspec(dllimport) char* __cdecl gets_s(
             char*   _Buffer,
                              rsize_t _Size
            );

        
        __declspec(dllimport) errno_t __cdecl tmpfile_s(
              FILE** _Stream
            );

        
        
        __declspec(dllimport) errno_t __cdecl tmpnam_s(
             char*   _Buffer,
                              rsize_t _Size
            );

    #line 145 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    __declspec(dllimport) void __cdecl clearerr(
         FILE* _Stream
        );

    
    
    __declspec(dllimport) int __cdecl fclose(
         FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _fcloseall(void);

    
    __declspec(dllimport) FILE* __cdecl _fdopen(
           int         _FileHandle,
         char const* _Mode
        );

    
    __declspec(dllimport) int __cdecl feof(
         FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl ferror(
         FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl fflush(
         FILE* _Stream
        );

    
    
    __declspec(dllimport) int __cdecl fgetc(
         FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _fgetchar(void);

    
    
    __declspec(dllimport) int __cdecl fgetpos(
         FILE*   _Stream,
           fpos_t* _Position
        );

    
    
    __declspec(dllimport) char* __cdecl fgets(
         char* _Buffer,
                              int   _MaxCount,
                           FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _fileno(
         FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _flushall(void);

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "fopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) FILE* __cdecl fopen(
         char const* _FileName,
         char const* _Mode
        );


    
    
    __declspec(dllimport) int __cdecl fputc(
            int   _Character,
         FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _fputchar(
         int _Character
        );

    
    
    __declspec(dllimport) int __cdecl fputs(
          char const* _Buffer,
         FILE*       _Stream
        );

    
    __declspec(dllimport) size_t __cdecl fread(
         void*  _Buffer,
                                                     size_t _ElementSize,
                                                     size_t _ElementCount,
                                                  FILE*  _Stream
        );

    
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "freopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) FILE* __cdecl freopen(
          char const* _FileName,
          char const* _Mode,
         FILE*       _Stream
        );

    
    __declspec(dllimport) FILE* __cdecl _fsopen(
         char const* _FileName,
         char const* _Mode,
           int         _ShFlag
        );

    
    
    __declspec(dllimport) int __cdecl fsetpos(
         FILE*         _Stream,
            fpos_t const* _Position
        );

    
    
    __declspec(dllimport) int __cdecl fseek(
         FILE* _Stream,
            long  _Offset,
            int   _Origin
        );

    
    
    __declspec(dllimport) int __cdecl _fseeki64(
         FILE*   _Stream,
            __int64 _Offset,
            int     _Origin
        );

    
    
    __declspec(dllimport) long __cdecl ftell(
         FILE* _Stream
        );

    
    
    __declspec(dllimport) __int64 __cdecl _ftelli64(
         FILE* _Stream
        );

    
    __declspec(dllimport) size_t __cdecl fwrite(
         void const* _Buffer,
                                                   size_t      _ElementSize,
                                                   size_t      _ElementCount,
                                                FILE*       _Stream
        );

    
    
    __declspec(dllimport) int __cdecl getc(
         FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl getchar(void);

    
    __declspec(dllimport) int __cdecl _getmaxstdio(void);

    extern "C++" { template <size_t _Size> inline char* __cdecl gets_s(char (&_Buffer)[_Size]) throw() { return gets_s(_Buffer, _Size); } }



    
    __declspec(dllimport) int __cdecl _getw(
         FILE* _Stream
        );

    __declspec(dllimport) void __cdecl perror(
         char const* _ErrorMessage
        );

    

        
        
        __declspec(dllimport) int __cdecl _pclose(
             FILE* _Stream
            );

        
        __declspec(dllimport) FILE* __cdecl _popen(
             char const* _Command,
             char const* _Mode
            );

    #line 344 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    
    __declspec(dllimport) int __cdecl putc(
            int   _Character,
         FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl putchar(
         int _Character
        );

    
    __declspec(dllimport) int __cdecl puts(
         char const* _Buffer
        );

    
    
    __declspec(dllimport) int __cdecl _putw(
            int   _Word,
         FILE* _Stream
        );

    __declspec(dllimport) int __cdecl remove(
         char const* _FileName
        );

    
    __declspec(dllimport) int __cdecl rename(
         char const* _OldFileName,
         char const* _NewFileName
        );

    __declspec(dllimport) int __cdecl _unlink(
         char const* _FileName
        );

    

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_unlink" ". See online help for details."))
        __declspec(dllimport) int __cdecl unlink(
             char const* _FileName
            );

    #line 391 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    __declspec(dllimport) void __cdecl rewind(
         FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _rmtmp(void);

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "setvbuf" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) void __cdecl setbuf(
                                                     FILE* _Stream,
          char* _Buffer
        );

    
    __declspec(dllimport) int __cdecl _setmaxstdio(
         int _Maximum
        );

    
    
    __declspec(dllimport) int __cdecl setvbuf(
                              FILE*  _Stream,
           char*  _Buffer,
                                 int    _Mode,
                                 size_t _Size
        );

    


#line 423 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __declspec(dllimport) __declspec(allocator) char* __cdecl _tempnam(
         char const* _DirectoryName,
         char const* _FilePrefix
        );

    

#line 433 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "tmpfile_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) FILE* __cdecl tmpfile(void);

    extern "C++" { template <size_t _Size> inline errno_t __cdecl tmpnam_s(char (&_Buffer)[_Size]) throw() { return tmpnam_s(_Buffer, _Size); } }





__declspec(deprecated("This function or variable may be unsafe. Consider using " "tmpnam_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl tmpnam( char *_Buffer);





    
    
    __declspec(dllimport) int __cdecl ungetc(
            int   _Character,
         FILE* _Stream
        );



    
    
    
    
    
    __declspec(dllimport) void __cdecl _lock_file(
         FILE* _Stream
        );

    __declspec(dllimport) void __cdecl _unlock_file(
         FILE* _Stream
        );

    
    
    __declspec(dllimport) int __cdecl _fclose_nolock(
         FILE* _Stream
        );

    
    
    __declspec(dllimport) int __cdecl _fflush_nolock(
         FILE* _Stream
        );

    
    
    __declspec(dllimport) int __cdecl _fgetc_nolock(
         FILE* _Stream
        );

    
    
    __declspec(dllimport) int __cdecl _fputc_nolock(
            int   _Character,
         FILE* _Stream
        );

    
    __declspec(dllimport) size_t __cdecl _fread_nolock(
         void*  _Buffer,
                                                     size_t _ElementSize,
                                                     size_t _ElementCount,
                                                  FILE*  _Stream
        );

    
    
    __declspec(dllimport) size_t __cdecl _fread_nolock_s(
         void*  _Buffer,
                             size_t _BufferSize,
                                                                     size_t _ElementSize,
                                                                     size_t _ElementCount,
                                                                  FILE*  _Stream
        );

    
    __declspec(dllimport) int __cdecl _fseek_nolock(
         FILE* _Stream,
            long  _Offset,
            int   _Origin
        );

    
    __declspec(dllimport) int __cdecl _fseeki64_nolock(
         FILE*   _Stream,
            __int64 _Offset,
            int     _Origin
        );

    
    __declspec(dllimport) long __cdecl _ftell_nolock(
         FILE* _Stream
        );

    
    __declspec(dllimport) __int64 __cdecl _ftelli64_nolock(
         FILE* _Stream
        );

    
    __declspec(dllimport) size_t __cdecl _fwrite_nolock(
         void const* _Buffer,
                                                   size_t      _ElementSize,
                                                   size_t      _ElementCount,
                                                FILE*       _Stream
        );

    
    __declspec(dllimport) int __cdecl _getc_nolock(
         FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _putc_nolock(
            int   _Character,
         FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _ungetc_nolock(
            int   _Character,
         FILE* _Stream
        );

    
    
    
    



    














#line 586 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"



    __declspec(dllimport) int* __cdecl __p__commode(void);

    


        
    #line 596 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"



    
    

#line 603 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    
    
    
    
    __declspec(dllimport) int __cdecl __stdio_common_vfprintf(
                                            unsigned __int64 _Options,
                                         FILE*            _Stream,
          char const*      _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    __declspec(dllimport) int __cdecl __stdio_common_vfprintf_s(
                                            unsigned __int64 _Options,
                                         FILE*            _Stream,
          char const*      _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __stdio_common_vfprintf_p(
                                            unsigned __int64 _Options,
                                         FILE*            _Stream,
          char const*      _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __inline int __cdecl _vfprintf_l(
          FILE*       const _Stream,
           char const* const _Format,
         _locale_t   const _Locale,
                 va_list           _ArgList
        )
    

#line 644 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfprintf((*__local_stdio_printf_options()) , _Stream, _Format, _Locale, _ArgList);
    }
    #line 648 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vfprintf(
                               FILE*       const _Stream,
          char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 658 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return _vfprintf_l(_Stream, _Format, 0 , _ArgList);
    }
    #line 662 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vfprintf_s_l(
          FILE*       const _Stream,
           char const* const _Format,
         _locale_t   const _Locale,
                 va_list           _ArgList
        )
    

#line 673 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfprintf_s((*__local_stdio_printf_options()) , _Stream, _Format, _Locale, _ArgList);
    }
    #line 677 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl vfprintf_s(
                                   FILE*       const _Stream,
              char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 689 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
        {
            return _vfprintf_s_l(_Stream, _Format, 0 , _ArgList);
        }
    #line 693 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    #line 695 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vfprintf_p_l(
          FILE*       const _Stream,
           char const* const _Format,
         _locale_t   const _Locale,
                 va_list           _ArgList
        )
    

#line 706 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfprintf_p((*__local_stdio_printf_options()) , _Stream, _Format, _Locale, _ArgList);
    }
    #line 710 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vfprintf_p(
                               FILE*       const _Stream,
          char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 720 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return _vfprintf_p_l(_Stream, _Format, 0 , _ArgList);
    }
    #line 724 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vprintf_l(
          char const* const _Format,
                                        _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 734 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return _vfprintf_l((__acrt_iob_func(1)) , _Format, _Locale, _ArgList);
    }
    #line 738 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vprintf(
          char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 747 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return _vfprintf_l((__acrt_iob_func(1)) , _Format, 0 , _ArgList);
    }
    #line 751 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vprintf_s_l(
          char const* const _Format,
                                        _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 761 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return _vfprintf_s_l((__acrt_iob_func(1)) , _Format, _Locale, _ArgList);
    }
    #line 765 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl vprintf_s(
              char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 776 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
        {
            return _vfprintf_s_l((__acrt_iob_func(1)) , _Format, 0 , _ArgList);
        }
    #line 780 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    #line 782 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vprintf_p_l(
          char const* const _Format,
                                        _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 792 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return _vfprintf_p_l((__acrt_iob_func(1)) , _Format, _Locale, _ArgList);
    }
    #line 796 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vprintf_p(
          char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 805 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return _vfprintf_p_l((__acrt_iob_func(1)) , _Format, 0 , _ArgList);
    }
    #line 809 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _fprintf_l(
                                         FILE*       const _Stream,
          char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 819 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfprintf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 828 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl fprintf(
                               FILE*       const _Stream,
          char const* const _Format,
        ...)
    

#line 837 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vfprintf_l(_Stream, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 846 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    __declspec(dllimport) int __cdecl _set_printf_count_output(
         int _Value
        );

    __declspec(dllimport) int __cdecl _get_printf_count_output(void);

    
    __inline int __cdecl _fprintf_s_l(
                                         FILE*       const _Stream,
          char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 862 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfprintf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 871 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl fprintf_s(
                                   FILE*       const _Stream,
              char const* const _Format,
            ...)
    

#line 882 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
            _Result = _vfprintf_s_l(_Stream, _Format, 0 , _ArgList);
            ((void)(_ArgList = (va_list)0)) ;
            return _Result;
        }
    #line 891 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    #line 893 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _fprintf_p_l(
                                         FILE*       const _Stream,
          char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 903 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfprintf_p_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 912 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _fprintf_p(
                               FILE*       const _Stream,
          char const* const _Format,
        ...)
    

#line 921 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vfprintf_p_l(_Stream, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 930 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _printf_l(
          char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 939 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfprintf_l((__acrt_iob_func(1)) , _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 948 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl printf(
          char const* const _Format,
        ...)
    

#line 956 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vfprintf_l((__acrt_iob_func(1)) , _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 965 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _printf_s_l(
          char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 974 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfprintf_s_l((__acrt_iob_func(1)) , _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 983 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl printf_s(
              char const* const _Format,
            ...)
    

#line 993 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
            _Result = _vfprintf_s_l((__acrt_iob_func(1)) , _Format, 0 , _ArgList);
            ((void)(_ArgList = (va_list)0)) ;
            return _Result;
        }
    #line 1002 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    #line 1004 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _printf_p_l(
          char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 1013 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfprintf_p_l((__acrt_iob_func(1)) , _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1022 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _printf_p(
          char const* const _Format,
        ...)
    

#line 1030 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vfprintf_p_l((__acrt_iob_func(1)) , _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1039 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"


    
    
    
    
    
    __declspec(dllimport) int __cdecl __stdio_common_vfscanf(
                                           unsigned __int64 _Options,
                                        FILE*            _Stream,
          char const*      _Format,
                                       _locale_t        _Locale,
                                               va_list          _Arglist
        );

    
    __inline int __cdecl _vfscanf_l(
                               FILE*       const _Stream,
          char const* const _Format,
                              _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 1064 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfscanf(
            (*__local_stdio_scanf_options ()) ,
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 1070 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vfscanf(
                               FILE*       const _Stream,
          char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 1080 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return _vfscanf_l(_Stream, _Format, 0 , _ArgList);
    }
    #line 1084 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vfscanf_s_l(
                               FILE*       const _Stream,
          char const* const _Format,
                              _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 1095 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0) ,
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 1101 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"


    

        
        __inline int __cdecl vfscanf_s(
                                   FILE*       const _Stream,
              char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 1114 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
        {
            return _vfscanf_s_l(_Stream, _Format, 0 , _ArgList);
        }
    #line 1118 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    #line 1120 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscanf_l(
          char const* const _Format,
                              _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 1130 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return _vfscanf_l((__acrt_iob_func(0)) , _Format, _Locale, _ArgList);
    }
    #line 1134 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vscanf(
          char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 1143 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return _vfscanf_l((__acrt_iob_func(0)) , _Format, 0 , _ArgList);
    }
    #line 1147 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscanf_s_l(
          char const* const _Format,
                              _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 1157 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return _vfscanf_s_l((__acrt_iob_func(0)) , _Format, _Locale, _ArgList);
    }
    #line 1161 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl vscanf_s(
              char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 1172 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
        {
            return _vfscanf_s_l((__acrt_iob_func(0)) , _Format, 0 , _ArgList);
        }
    #line 1176 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    #line 1178 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _fscanf_l(
                                        FILE*       const _Stream,
          char const* const _Format,
                                       _locale_t   const _Locale,
        ...)
    

#line 1188 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfscanf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1197 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "fscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl fscanf(
                              FILE*       const _Stream,
          char const* const _Format,
        ...)
    

#line 1206 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vfscanf_l(_Stream, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1215 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _fscanf_s_l(
                                          FILE*       const _Stream,
          char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 1225 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfscanf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1234 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl fscanf_s(
                                    FILE*       const _Stream,
              char const* const _Format,
            ...)
    

#line 1245 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
            _Result = _vfscanf_s_l(_Stream, _Format, 0 , _ArgList);
            ((void)(_ArgList = (va_list)0)) ;
            return _Result;
        }
    #line 1254 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    #line 1256 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_scanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _scanf_l(
          char const* const _Format,
                                       _locale_t   const _Locale,
        ...)
    

#line 1265 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfscanf_l((__acrt_iob_func(0)) , _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1274 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "scanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl scanf(
          char const* const _Format,
        ...)
    

#line 1282 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vfscanf_l((__acrt_iob_func(0)) , _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1291 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _scanf_s_l(
          char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 1300 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfscanf_s_l((__acrt_iob_func(0)) , _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1309 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl scanf_s(
              char const* const _Format,
            ...)
    

#line 1319 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
            _Result = _vfscanf_s_l((__acrt_iob_func(0)) , _Format, 0 , _ArgList);
            ((void)(_ArgList = (va_list)0)) ;
            return _Result;
        }
    #line 1328 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    #line 1330 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"



    
    
    
    
    
    
    __declspec(dllimport) int __cdecl __stdio_common_vsprintf(
                                            unsigned __int64 _Options,
                char*            _Buffer,
                                            size_t           _BufferCount,
          char const*      _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __stdio_common_vsprintf_s(
                                            unsigned __int64 _Options,
                    char*            _Buffer,
                                            size_t           _BufferCount,
          char const*      _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __stdio_common_vsnprintf_s(
                                            unsigned __int64 _Options,
                char*            _Buffer,
                                            size_t           _BufferCount,
                                            size_t           _MaxCount,
          char const*      _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __stdio_common_vsprintf_p(
                                            unsigned __int64 _Options,
                    char*            _Buffer,
                                            size_t           _BufferCount,
          char const*      _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsnprintf_l(
          char*       const _Buffer,
                                                 size_t      const _BufferCount,
               char const* const _Format,
                                             _locale_t   const _Locale,
                                                     va_list           _ArgList
        )
    

#line 1391 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 0) ,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1399 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    
    __inline int __cdecl _vsnprintf(
          char*       const _Buffer,
                                                size_t      const _BufferCount,
                        char const* const _Format,
                                                    va_list           _ArgList
        )
    

#line 1411 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return _vsnprintf_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
    }
    #line 1415 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    








#line 1426 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    
    __inline int __cdecl vsnprintf(
          char*       const _Buffer,
                                                      size_t      const _BufferCount,
                              char const* const _Format,
                                                          va_list           _ArgList
        )
    

#line 1438 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1) ,
            _Buffer, _BufferCount, _Format, 0 , _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1446 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsprintf_l(
          char*       const _Buffer,
                                   char const* const _Format,
                                 _locale_t   const _Locale,
                                         va_list           _ArgList
        )
    

#line 1458 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 1462 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "vsprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl vsprintf(
          char*       const _Buffer,
             char const* const _Format,
                                         va_list           _ArgList
        )
    

#line 1473 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return _vsnprintf_l(_Buffer, (size_t)-1, _Format, 0 , _ArgList);
    }
    #line 1477 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    
    __inline int __cdecl _vsprintf_s_l(
          char*       const _Buffer,
                                                  size_t      const _BufferCount,
                char const* const _Format,
                                              _locale_t   const _Locale,
                                                      va_list           _ArgList
        )
    

#line 1490 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf_s(
            (*__local_stdio_printf_options()) ,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1498 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    

        
        
        __inline int __cdecl vsprintf_s(
              char*       const _Buffer,
                                                      size_t      const _BufferCount,
                              char const* const _Format,
                                                          va_list           _ArgList
            )
    

#line 1512 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
        {
            return _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
        }
    #line 1516 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

        extern "C++" { template <size_t _Size> inline int __cdecl vsprintf_s(char (&_Buffer)[_Size], char const* _Format, va_list _ArgList) throw() { return vsprintf_s(_Buffer, _Size, _Format, _ArgList); } }







    #line 1526 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    
    __inline int __cdecl _vsprintf_p_l(
          char*       const _Buffer,
                                                  size_t      const _BufferCount,
                char const* const _Format,
                                              _locale_t   const _Locale,
                                                      va_list           _ArgList
        )
    

#line 1539 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf_p(
            (*__local_stdio_printf_options()) ,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1547 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    
    __inline int __cdecl _vsprintf_p(
          char*       const _Buffer,
                                                  size_t      const _BufferCount,
                          char const* const _Format,
                                                      va_list           _ArgList
        )
    

#line 1559 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
    }
    #line 1563 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    
    __inline int __cdecl _vsnprintf_s_l(
          char*       const _Buffer,
                                                      size_t      const _BufferCount,
                                                      size_t      const _MaxCount,
                    char const* const _Format,
                                                  _locale_t   const _Locale,
                                                          va_list          _ArgList
        )
    

#line 1577 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsnprintf_s(
            (*__local_stdio_printf_options()) ,
            _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1585 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    
    __inline int __cdecl _vsnprintf_s(
          char*       const _Buffer,
                                                      size_t      const _BufferCount,
                                                      size_t      const _MaxCount,
                              char const* const _Format,
                                                          va_list           _ArgList
        )
    

#line 1598 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0 , _ArgList);
    }
    #line 1602 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    extern "C++" { template <size_t _Size> inline int __cdecl _vsnprintf_s(char (&_Buffer)[_Size], size_t _BufferCount, char const* _Format, va_list _ArgList) throw() { return _vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }








    

        
        
        __inline int __cdecl vsnprintf_s(
              char*       const _Buffer,
                                                          size_t      const _BufferCount,
                                                          size_t      const _MaxCount,
                                  char const* const _Format,
                                                              va_list           _ArgList
            )
    

#line 1626 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
        {
            return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0 , _ArgList);
        }
    #line 1630 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

        extern "C++" { template <size_t _Size> inline int __cdecl vsnprintf_s(char (&_Buffer)[_Size], size_t _BufferCount, char const* _Format, va_list _ArgList) throw() { return vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }








    #line 1641 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscprintf_l(
          char const* const _Format,
                                        _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 1651 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1) ,
            0 , 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1659 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscprintf(
          char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 1668 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return _vscprintf_l(_Format, 0 , _ArgList);
    }
    #line 1672 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscprintf_p_l(
          char const* const _Format,
                                        _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 1682 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf_p(
            (*__local_stdio_printf_options()) | (1ULL << 1) ,
            0 , 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1690 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscprintf_p(
          char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 1699 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return _vscprintf_p_l(_Format, 0 , _ArgList);
    }
    #line 1703 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vsnprintf_c_l(
                  char*       const _Buffer,
                                            size_t      const _BufferCount,
          char const* const _Format,
                                        _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 1715 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) ,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1723 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    
    __inline int __cdecl _vsnprintf_c(
         char*       const _Buffer,
                                   size_t      const _BufferCount,
           char const* const _Format,
                                       va_list           _ArgList
        )
    

#line 1735 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
    }
    #line 1739 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_sprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _sprintf_l(
                 char*       const _Buffer,
          char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 1750 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;

        _Result = _vsprintf_l(_Buffer, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1761 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    
    __inline int __cdecl sprintf(
          char*       const _Buffer,
             char const* const _Format,
        ...)
    

#line 1771 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;

        _Result = _vsprintf_l(_Buffer, _Format, 0 , _ArgList);

        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1782 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "sprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) int __cdecl sprintf( char *_Buffer, char const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "vsprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) int __cdecl vsprintf( char *_Buffer, char const* _Format, va_list _Args);






    
    
    __inline int __cdecl _sprintf_s_l(
          char*       const _Buffer,
                                                  size_t      const _BufferCount,
                char const* const _Format,
                                              _locale_t   const _Locale,
        ...)
    

#line 1801 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1810 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    

        
        
        __inline int __cdecl sprintf_s(
              char*       const _Buffer,
                                                      size_t      const _BufferCount,
                              char const* const _Format,
            ...)
    

#line 1823 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
            _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
            ((void)(_ArgList = (va_list)0)) ;
            return _Result;
        }
    #line 1832 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    #line 1834 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    extern "C++" { template <size_t _Size> inline int __cdecl sprintf_s(char (&_Buffer)[_Size], char const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return vsprintf_s(_Buffer, _Size, _Format, _ArgList); } }






    
    
    __inline int __cdecl _sprintf_p_l(
          char*       const _Buffer,
                                                  size_t      const _BufferCount,
                char const* const _Format,
                                              _locale_t   const _Locale,
        ...)
    

#line 1853 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1862 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    
    __inline int __cdecl _sprintf_p(
          char*       const _Buffer,
                                                  size_t      const _BufferCount,
                          char const* const _Format,
        ...)
    

#line 1873 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1882 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snprintf_l(
          char*       const _Buffer,
                                                 size_t      const _BufferCount,
               char const* const _Format,
                                             _locale_t   const _Locale,
        ...)
    

#line 1894 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;

        _Result = _vsnprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1905 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    








#line 1916 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    
    __inline int __cdecl snprintf(
          char*       const _Buffer,
                                                      size_t      const _BufferCount,
                              char const* const _Format,
        ...)
    

#line 1927 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1936 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    
    __inline int __cdecl _snprintf(
          char*       const _Buffer,
                                                 size_t      const _BufferCount,
                         char const* const _Format,
        ...)
    

#line 1947 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1956 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) int __cdecl _snprintf( char *_Buffer, size_t _BufferCount, char const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) int __cdecl _vsnprintf( char *_Buffer, size_t _BufferCount, char const* _Format, va_list _Args);








    
    
    __inline int __cdecl _snprintf_c_l(
                  char*       const _Buffer,
                                            size_t      const _BufferCount,
          char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 1977 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1986 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    
    __inline int __cdecl _snprintf_c(
         char*       const _Buffer,
                                   size_t      const _BufferCount,
           char const* const _Format,
        ...)
    

#line 1997 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2006 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    
    __inline int __cdecl _snprintf_s_l(
          char*       const _Buffer,
                                                      size_t      const _BufferCount,
                                                      size_t      const _MaxCount,
                    char const* const _Format,
                                                  _locale_t   const _Locale,
        ...)
    

#line 2019 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2028 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    
    __inline int __cdecl _snprintf_s(
          char*       const _Buffer,
                                                      size_t      const _BufferCount,
                                                      size_t      const _MaxCount,
                              char const* const _Format,
        ...)
    

#line 2040 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2049 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    extern "C++" { template <size_t _Size> inline int __cdecl _snprintf_s(char (&_Buffer)[_Size], size_t _BufferCount, char const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return _vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }







    
    __inline int __cdecl _scprintf_l(
          char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 2066 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vscprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2075 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _scprintf(
          char const* const _Format,
        ...)
    

#line 2083 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vscprintf_l(_Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2092 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _scprintf_p_l(
          char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 2101 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vscprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2110 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _scprintf_p(
          char const* const _Format,
        ...)
    

#line 2118 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vscprintf_p(_Format, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2127 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    
    
    
    
    __declspec(dllimport) int __cdecl __stdio_common_vsscanf(
                                           unsigned __int64 _Options,
                char const*      _Buffer,
                                           size_t           _BufferCount,
          char const*      _Format,
                                       _locale_t        _Locale,
                                               va_list          _ArgList
        );

    
    __inline int __cdecl _vsscanf_l(
                                char const* const _Buffer,
          char const* const _Format,
                              _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 2152 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) ,
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 2158 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vsscanf(
                                char const* const _Buffer,
          char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 2168 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return _vsscanf_l(_Buffer, _Format, 0 , _ArgList);
    }
    #line 2172 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vsscanf_s_l(
                                char const* const _Buffer,
          char const* const _Format,
                              _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 2183 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0) ,
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 2189 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    

        #pragma warning(push)
        #pragma warning(disable: 6530) 

        
        __inline int __cdecl vsscanf_s(
                                    char const* const _Buffer,
              char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 2204 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
        {
            return _vsscanf_s_l(_Buffer, _Format, 0 , _ArgList);
        }
    #line 2208 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

        extern "C++" { template <size_t _Size> inline int __cdecl vsscanf_s(char const (&_Buffer)[_Size], char const* _Format, va_list _ArgList) throw() { return vsscanf_s(_Buffer, _Size, _Format, _ArgList); } }






        #pragma warning(pop)

    #line 2219 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_sscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _sscanf_l(
                                         char const* const _Buffer,
          char const* const _Format,
                                       _locale_t   const _Locale,
        ...)
    

#line 2229 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vsscanf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2238 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "sscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl sscanf(
                               char const* const _Buffer,
          char const* const _Format,
        ...)
    

#line 2247 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vsscanf_l(_Buffer, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2256 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _sscanf_s_l(
                                           char const* const _Buffer,
          char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 2266 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vsscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2275 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl sscanf_s(
                                     char const* const _Buffer,
              char const* const _Format,
            ...)
    

#line 2286 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;

            _Result = vsscanf_s(_Buffer, _Format, _ArgList);

            ((void)(_ArgList = (va_list)0)) ;
            return _Result;
        }
    #line 2297 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    #line 2299 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    #pragma warning(push)
    #pragma warning(disable: 6530) 

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snscanf_l(
          char const* const _Buffer,
                                           size_t      const _BufferCount,
          char const* const _Format,
                                       _locale_t   const _Locale,
        ...)
    

#line 2313 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) ,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2326 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snscanf(
          char const* const _Buffer,
                                           size_t      const _BufferCount,
                    char const* const _Format,
        ...)
    

#line 2336 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) ,
            _Buffer, _BufferCount, _Format, 0 , _ArgList);

        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2349 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"


    
    __inline int __cdecl _snscanf_s_l(
            char const* const _Buffer,
                                             size_t      const _BufferCount,
          char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 2361 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0) ,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2374 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _snscanf_s(
          char const* const _Buffer,
                                           size_t      const _BufferCount,
                  char const* const _Format,
        ...)
    

#line 2384 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0) ,
            _Buffer, _BufferCount, _Format, 0 , _ArgList);

        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2397 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    #pragma warning(pop)

    

#line 2403 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"



    
    
    
    
    
    

        

        


#line 2419 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_tempnam" ". See online help for details."))
        __declspec(dllimport) char* __cdecl tempnam(
             char const* _Directory,
             char const* _FilePrefix
            );

        

#line 2429 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fcloseall" ". See online help for details.")) __declspec(dllimport) int   __cdecl fcloseall(void);
             __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fdopen" ". See online help for details."))    __declspec(dllimport) FILE* __cdecl fdopen( int _FileHandle,  char const* _Format);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fgetchar" ". See online help for details."))  __declspec(dllimport) int   __cdecl fgetchar(void);
             __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fileno" ". See online help for details."))    __declspec(dllimport) int   __cdecl fileno( FILE* _Stream);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_flushall" ". See online help for details."))  __declspec(dllimport) int   __cdecl flushall(void);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fputchar" ". See online help for details."))  __declspec(dllimport) int   __cdecl fputchar( int _Ch);
             __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_getw" ". See online help for details."))      __declspec(dllimport) int   __cdecl getw( FILE* _Stream);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_putw" ". See online help for details."))      __declspec(dllimport) int   __cdecl putw( int _Ch,  FILE* _Stream);
             __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_rmtmp" ". See online help for details."))     __declspec(dllimport) int   __cdecl rmtmp(void);

    #line 2441 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
#line 2442 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#line 2449 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
#pragma external_header(pop)
#line 13 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cstdio"

#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )
















namespace std {
#pragma warning(push)
#pragma warning(disable : 4995) 

using :: _Mbstatet;

 using :: size_t;
 using :: fpos_t;
 using :: FILE;
 using :: clearerr;
 using :: fclose;
 using :: feof;
 using :: ferror;
 using :: fflush;
 using :: fgetc;
 using :: fgetpos;
 using :: fgets;
 using :: fopen;
 using :: fprintf;
 using :: fputc;
 using :: fputs;
 using :: fread;
 using :: freopen;
 using :: fscanf;
 using :: fseek;
 using :: fsetpos;
 using :: ftell;
 using :: fwrite;
 using :: getc;
 using :: getchar;
 using :: perror;
 using :: putc;
 using :: putchar;
 using :: printf;
 using :: puts;
 using :: remove;
 using :: rename;
 using :: rewind;
 using :: scanf;
 using :: setbuf;
 using :: setvbuf;
 using :: sprintf;
 using :: sscanf;
 using :: tmpfile;
 using :: tmpnam;
 using :: ungetc;
 using :: vfprintf;
 using :: vprintf;
 using :: vsprintf;

 using :: snprintf;
 using :: vsnprintf;
 using :: vfscanf;
 using :: vscanf;
 using :: vsscanf;

#pragma warning(pop)
}



#pragma warning(pop)
#pragma pack(pop)

#line 98 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cstdio"
#line 99 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cstdio"
#pragma external_header(pop)
#line 13 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cwchar"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\wchar.h"









#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_memcpy_s.h"







#pragma once


#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\errno.h"







#pragma once





#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {




    __declspec(dllimport) int* __cdecl _errno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_errno( int _Value);
    __declspec(dllimport) errno_t __cdecl _get_errno( int* _Value);

    __declspec(dllimport) unsigned long* __cdecl __doserrno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_doserrno( unsigned long _Value);
    __declspec(dllimport) errno_t __cdecl _get_doserrno( unsigned long * _Value);
#line 35 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\errno.h"










































    
    
    
    
    
#line 83 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\errno.h"






    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
#line 131 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\errno.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#line 138 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\errno.h"
#pragma external_header(pop)
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_memcpy_s.h"
#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime_string.h"







#pragma once



#pragma warning(push)
#pragma warning(disable: 4514 4820 )



__pragma(pack(push, 8)) extern "C" {



[[nodiscard]] 
 void const * __cdecl memchr(
     void const* _Buf,
                                int         _Val,
                                size_t      _MaxCount
    );

[[nodiscard]] 
int __cdecl memcmp(
     void const* _Buf1,
     void const* _Buf2,
                        size_t      _Size
    );









void* __cdecl memcpy(
     void* _Dst,
           void const* _Src,
                              size_t      _Size
    );


 void* __cdecl memmove(
     void*       _Dst,
           void const* _Src,
                                  size_t      _Size
    );








void* __cdecl memset(
     void*  _Dst,
                              int    _Val,
                              size_t _Size
    );

[[nodiscard]] 
 char const * __cdecl strchr(
     char const* _Str,
       int         _Val
    );

[[nodiscard]] 
 char const * __cdecl strrchr(
     char const* _Str,
       int         _Ch
    );

[[nodiscard]]  
 char const * __cdecl strstr(
     char const* _Str,
     char const* _SubStr
    );

[[nodiscard]] 

 wchar_t const * __cdecl wcschr(
     wchar_t const* _Str,
       wchar_t        _Ch
    );

[[nodiscard]] 
 wchar_t const * __cdecl wcsrchr(
     wchar_t const* _Str,
       wchar_t        _Ch
    );

[[nodiscard]]  

 wchar_t const * __cdecl wcsstr(
     wchar_t const* _Str,
     wchar_t const* _SubStr
    );



} __pragma(pack(pop))

#line 112 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime_string.h"

#pragma warning(pop) 
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_memcpy_s.h"

#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {


    
#line 23 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_memcpy_s.h"














    
    
    static __inline errno_t __cdecl memcpy_s(
         void*       const _Destination,
                                                             rsize_t     const _DestinationSize,
                                void const* const _Source,
                                                             rsize_t     const _SourceSize
        )
    {
        if (_SourceSize == 0)
        {
            return 0;
        }

        { int _Expr_val=!!(_Destination != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } } ;
        if (_Source == 0 || _DestinationSize < _SourceSize)
        {
            memset(_Destination, 0, _DestinationSize);

            { int _Expr_val=!!(_Source != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } } ;
            { int _Expr_val=!!(_DestinationSize >= _SourceSize); if (!(_Expr_val)) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; } } ;

            
            return 22 ;
        }
        memcpy(_Destination, _Source, _SourceSize);
        return 0;
    }

    
    static __inline errno_t __cdecl memmove_s(
         void*       const _Destination,
                                                             rsize_t     const _DestinationSize,
                                void const* const _Source,
                                                             rsize_t     const _SourceSize
        )
    {
        if (_SourceSize == 0)
        {
            return 0;
        }

        { int _Expr_val=!!(_Destination != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } } ;
        { int _Expr_val=!!(_Source != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } } ;
        { int _Expr_val=!!(_DestinationSize >= _SourceSize); if (!(_Expr_val)) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; } } ;

        memmove(_Destination, _Source, _SourceSize);
        return 0;
    }

#line 88 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_memcpy_s.h"




#pragma warning(pop) 
} __pragma(pack(pop))
#pragma external_header(pop)
#line 16 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\wchar.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"








#pragma once




#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {







    
    
    __declspec(dllimport) errno_t __cdecl _cgetws_s(
         wchar_t* _Buffer,
                                              size_t   _BufferCount,
                                             size_t*  _SizeRead
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _cgetws_s(wchar_t (&_Buffer)[_Size], size_t* _SizeRead) throw() { return _cgetws_s(_Buffer, _Size, _SizeRead); } }






    
    __declspec(dllimport) int __cdecl _cputws(
         wchar_t const* _Buffer
        );

         __declspec(dllimport) wint_t __cdecl _getwch  (void);
         __declspec(dllimport) wint_t __cdecl _getwche (void);
     __declspec(dllimport) wint_t __cdecl _putwch  ( wchar_t _Character);
     __declspec(dllimport) wint_t __cdecl _ungetwch( wint_t  _Character);

         __declspec(dllimport) wint_t __cdecl _getwch_nolock  (void);
         __declspec(dllimport) wint_t __cdecl _getwche_nolock (void);
     __declspec(dllimport) wint_t __cdecl _putwch_nolock  ( wchar_t _Character);
     __declspec(dllimport) wint_t __cdecl _ungetwch_nolock( wint_t  _Character);



    
    
    
    
    
    
    __declspec(dllimport) int __cdecl __conio_common_vcwprintf(
                                            unsigned __int64 _Options,
          wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __conio_common_vcwprintf_s(
                                            unsigned __int64 _Options,
          wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __conio_common_vcwprintf_p(
                                            unsigned __int64 _Options,
          wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __inline int __cdecl _vcwprintf_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                                va_list              _ArgList
        )


#line 96 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwprintf((*__local_stdio_printf_options()) , _Format, _Locale, _ArgList);
    }
#line 100 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf(
          wchar_t const* const _Format,
                                      va_list              _ArgList
        )


#line 109 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwprintf_l(_Format, 0 , _ArgList);
    }
#line 113 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_s_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                                va_list              _ArgList
        )


#line 123 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwprintf_s((*__local_stdio_printf_options()) , _Format, _Locale, _ArgList);
    }
#line 127 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_s(
          wchar_t const* const _Format,
                                      va_list              _ArgList
        )


#line 136 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwprintf_s_l(_Format, 0 , _ArgList);
    }
#line 140 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_p_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                                va_list              _ArgList
        )


#line 150 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwprintf_p((*__local_stdio_printf_options()) , _Format, _Locale, _ArgList);
    }
#line 154 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_p(
          const wchar_t* const _Format,
                                      va_list              _ArgList
        )


#line 163 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwprintf_p_l(_Format, 0 , _ArgList);
    }
#line 167 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)


#line 176 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vcwprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
#line 185 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf(
          wchar_t const* const _Format,
        ...)


#line 193 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vcwprintf_l(_Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
#line 202 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_s_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)


#line 211 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vcwprintf_s_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
#line 220 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_s(
          wchar_t const* const _Format,
        ...)


#line 228 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vcwprintf_s_l(_Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
#line 237 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_p_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)


#line 246 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vcwprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
#line 255 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_p(
          wchar_t const* const _Format,
        ...)


#line 263 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vcwprintf_p_l(_Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
#line 272 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"



    
    
    
    
    
    
    __declspec(dllimport) int __cdecl __conio_common_vcwscanf(
                                           unsigned __int64 _Options,
          wchar_t const*   _Format,
                                       _locale_t        _Locale,
                                               va_list          _ArgList
        );

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vcwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vcwscanf_l(
          wchar_t const* const _Format,
                                       _locale_t      const _Locale,
                                               va_list              _ArgList
        )


#line 297 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwscanf(
            (*__local_stdio_scanf_options ()) ,
            _Format, _Locale, _ArgList);
    }
#line 303 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vcwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vcwscanf(
          wchar_t const* const _Format,
                                               va_list              _ArgList
        )


#line 312 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwscanf_l(_Format, 0 , _ArgList);
    }
#line 316 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwscanf_s_l(
          wchar_t const* const _Format,
                                       _locale_t      const _Locale,
                                               va_list              _ArgList
        )


#line 326 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0) ,
            _Format, _Locale, _ArgList);
    }
#line 332 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwscanf_s(
          wchar_t const* const _Format,
                                               va_list              _ArgList
        )


#line 341 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwscanf_s_l(_Format, 0 , _ArgList);
    }
#line 345 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_cwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _cwscanf_l(
          wchar_t const* const _Format,
                                       _locale_t      const _Locale,
        ...)


#line 354 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;

        _Result = _vcwscanf_l(_Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
#line 365 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_cwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _cwscanf(
          wchar_t const* const _Format,
        ...)


#line 373 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;

        _Result = _vcwscanf_l(_Format, 0 , _ArgList);

        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
#line 384 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwscanf_s_l(
          wchar_t const* const _Format,
                                       _locale_t      const _Locale,
        ...)


#line 393 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vcwscanf_s_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
#line 402 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwscanf_s(
          wchar_t const* const _Format,
        ...)


#line 410 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vcwscanf_s_l(_Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
#line 419 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"

#line 421 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"

} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 17 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\wchar.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wctype.h"








#pragma once



#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {











    

#line 32 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wctype.h"
        
    #line 34 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wctype.h"

    __declspec(dllimport) const unsigned short* __cdecl __pctype_func(void);
    __declspec(dllimport) const wctype_t*       __cdecl __pwctype_func(void);

    



        
        
    #line 45 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wctype.h"
#line 46 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wctype.h"





















 __declspec(dllimport) int __cdecl iswalnum  ( wint_t _C);
 __declspec(dllimport) int __cdecl iswalpha  ( wint_t _C);
 __declspec(dllimport) int __cdecl iswascii  ( wint_t _C);
 __declspec(dllimport) int __cdecl iswblank  ( wint_t _C);
 __declspec(dllimport) int __cdecl iswcntrl  ( wint_t _C);


 __declspec(dllimport) int __cdecl iswdigit  ( wint_t _C);

 __declspec(dllimport) int __cdecl iswgraph  ( wint_t _C);
 __declspec(dllimport) int __cdecl iswlower  ( wint_t _C);
 __declspec(dllimport) int __cdecl iswprint  ( wint_t _C);
 __declspec(dllimport) int __cdecl iswpunct  ( wint_t _C);
 __declspec(dllimport) int __cdecl iswspace  ( wint_t _C);
 __declspec(dllimport) int __cdecl iswupper  ( wint_t _C);
 __declspec(dllimport) int __cdecl iswxdigit ( wint_t _C);
 __declspec(dllimport) int __cdecl __iswcsymf( wint_t _C);
 __declspec(dllimport) int __cdecl __iswcsym ( wint_t _C);

 __declspec(dllimport) int __cdecl _iswalnum_l ( wint_t _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl _iswalpha_l ( wint_t _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl _iswblank_l ( wint_t _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl _iswcntrl_l ( wint_t _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl _iswdigit_l ( wint_t _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl _iswgraph_l ( wint_t _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl _iswlower_l ( wint_t _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl _iswprint_l ( wint_t _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl _iswpunct_l ( wint_t _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl _iswspace_l ( wint_t _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl _iswupper_l ( wint_t _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl _iswxdigit_l( wint_t _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl _iswcsymf_l ( wint_t _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl _iswcsym_l  ( wint_t _C,  _locale_t _Locale);


 __declspec(dllimport) wint_t __cdecl towupper( wint_t _C);
 __declspec(dllimport) wint_t __cdecl towlower( wint_t _C);
 __declspec(dllimport) int    __cdecl iswctype( wint_t _C,  wctype_t _Type);

 __declspec(dllimport) wint_t __cdecl _towupper_l( wint_t _C,  _locale_t _Locale);
 __declspec(dllimport) wint_t __cdecl _towlower_l( wint_t _C,  _locale_t _Locale);
 __declspec(dllimport) int    __cdecl _iswctype_l( wint_t _C,  wctype_t _Type,  _locale_t _Locale);



     __declspec(dllimport) int __cdecl isleadbyte( int _C);
     __declspec(dllimport) int __cdecl _isleadbyte_l( int _C,  _locale_t _Locale);

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "iswctype" " " "instead. See online help for details.")) __declspec(dllimport) int __cdecl is_wctype( wint_t _C,  wctype_t _Type);
#line 117 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wctype.h"


















































































#line 200 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wctype.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 18 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\wchar.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wdirect.h"








#pragma once



#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {







 
__declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wgetcwd(
     wchar_t* _DstBuf,
                                 int      _SizeInWords
    );


 
__declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wgetdcwd(
                                 int      _Drive,
     wchar_t* _DstBuf,
                                 int      _SizeInWords
    );







__declspec(dllimport) int __cdecl _wchdir(
     wchar_t const* _Path
    );


__declspec(dllimport) int __cdecl _wmkdir(
     wchar_t const* _Path
    );


__declspec(dllimport) int __cdecl _wrmdir(
     wchar_t const* _Path
    );



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 19 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\wchar.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wio.h"








#pragma once


#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_share.h"








#pragma once



#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )











    
    
    
    
#line 31 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_share.h"


#pragma warning(pop) 
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wio.h"

#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {










    
    
#line 32 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wio.h"

typedef unsigned long _fsize_t;

struct _wfinddata32_t
{
    unsigned   attrib;
    __time32_t time_create;    
    __time32_t time_access;    
    __time32_t time_write;
    _fsize_t   size;
    wchar_t    name[260];
};

struct _wfinddata32i64_t
{
    unsigned   attrib;
    __time32_t time_create;    
    __time32_t time_access;    
    __time32_t time_write;
    __int64    size;
    wchar_t    name[260];
};

struct _wfinddata64i32_t
{
    unsigned   attrib;
    __time64_t time_create;    
    __time64_t time_access;    
    __time64_t time_write;
    _fsize_t   size;
    wchar_t    name[260];
};

struct _wfinddata64_t
{
    unsigned   attrib;
    __time64_t time_create;    
    __time64_t time_access;    
    __time64_t time_write;
    __int64    size;
    wchar_t    name[260];
};














    
    
    
    
#line 93 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wio.h"


__declspec(dllimport) int __cdecl _waccess(
     wchar_t const* _FileName,
       int            _AccessMode
    );


__declspec(dllimport) errno_t __cdecl _waccess_s(
     wchar_t const* _FileName,
       int            _AccessMode
    );


__declspec(dllimport) int __cdecl _wchmod(
     wchar_t const* _FileName,
       int            _Mode
    );

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) int __cdecl _wcreat(
     wchar_t const* _FileName,
       int            _PermissionMode
    );



__declspec(dllimport) intptr_t __cdecl _wfindfirst32(
     wchar_t const*         _FileName,
      struct _wfinddata32_t* _FindData
    );



__declspec(dllimport) int __cdecl _wfindnext32(
      intptr_t               _FindHandle,
     struct _wfinddata32_t* _FindData
    );

__declspec(dllimport) int __cdecl _wunlink(
     wchar_t const* _FileName
    );


__declspec(dllimport) int __cdecl _wrename(
     wchar_t const* _OldFileName,
     wchar_t const* _NewFileName
    );

__declspec(dllimport) errno_t __cdecl _wmktemp_s(
     wchar_t* _TemplateName,
                                size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmktemp_s(wchar_t (&_TemplateName)[_Size]) throw() { return _wmktemp_s(_TemplateName, _Size); } }





__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wmktemp_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wmktemp( wchar_t *_TemplateName);






__declspec(dllimport) intptr_t __cdecl _wfindfirst32i64(
     wchar_t const*            _FileName,
      struct _wfinddata32i64_t* _FindData
    );



__declspec(dllimport) intptr_t __cdecl _wfindfirst64i32(
     wchar_t const*            _FileName,
      struct _wfinddata64i32_t* _FindData
    );



__declspec(dllimport) intptr_t __cdecl _wfindfirst64(
     wchar_t const*         _FileName,
      struct _wfinddata64_t* _FindData
    );



__declspec(dllimport) int __cdecl _wfindnext32i64(
      intptr_t                  _FindHandle,
     struct _wfinddata32i64_t* _FindData
    );



__declspec(dllimport) int __cdecl _wfindnext64i32(
      intptr_t                  _FindHandle,
     struct _wfinddata64i32_t* _FindData
    );



__declspec(dllimport) int __cdecl _wfindnext64(
      intptr_t               _FindHandle,
     struct _wfinddata64_t* _FindData
    );


__declspec(dllimport) errno_t __cdecl _wsopen_s(
      int*           _FileHandle,
     wchar_t const* _FileName,
       int            _OpenFlag,
       int            _ShareFlag,
       int            _PermissionFlag
    );

__declspec(dllimport) errno_t __cdecl _wsopen_dispatch(
     wchar_t const* _FileName,
       int            _OFlag,
       int            _ShFlag,
       int            _PMode,
      int*           _PFileHandle,
       int            _BSecure
    );





    
    extern "C++"  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    inline int __cdecl _wopen(
         wchar_t const* _FileName,
           int            _OFlag,
           int            _PMode = 0
        )
    {
        int _FileHandle;
        
        errno_t const _Result = _wsopen_dispatch(_FileName, _OFlag, 0x40 , _PMode, &_FileHandle, 0);
        return _Result ? -1 : _FileHandle;
    }

    extern "C++"  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    inline int __cdecl _wsopen(
         wchar_t const* _FileName,
           int            _OFlag,
           int            _ShFlag,
           int            _PMode = 0
        )
    {
        int _FileHandle;
        
        errno_t const _Result = _wsopen_dispatch(_FileName, _OFlag, _ShFlag, _PMode, &_FileHandle, 0);
        return _Result ? -1 : _FileHandle;
    }

















#line 267 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wio.h"

} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 20 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\wchar.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wprocess.h"








#pragma once



#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {




    

        __declspec(dllimport) intptr_t __cdecl _wexecl(
             wchar_t const* _FileName,
             wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wexecle(
             wchar_t const* _FileName,
             wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wexeclp(
             wchar_t const* _FileName,
             wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wexeclpe(
             wchar_t const* _FileName,
             wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wexecv(
             wchar_t const*        _FileName,
             wchar_t const* const* _ArgList
            );

        __declspec(dllimport) intptr_t __cdecl _wexecve(
                 wchar_t const*        _FileName,
                 wchar_t const* const* _ArgList,
             wchar_t const* const* _Env
            );

        __declspec(dllimport) intptr_t __cdecl _wexecvp(
             wchar_t const*        _FileName,
             wchar_t const* const* _ArgList
            );

        __declspec(dllimport) intptr_t __cdecl _wexecvpe(
                 wchar_t const*        _FileName,
                 wchar_t const* const* _ArgList,
             wchar_t const* const* _Env
            );

        __declspec(dllimport) intptr_t __cdecl _wspawnl(
               int            _Mode,
             wchar_t const* _FileName,
             wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wspawnle(
               int            _Mode,
             wchar_t const* _FileName,
             wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wspawnlp(
               int            _Mode,
             wchar_t const* _FileName,
             wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wspawnlpe(
               int            _Mode,
             wchar_t const* _FileName,
             wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wspawnv(
               int                   _Mode,
             wchar_t const*        _FileName,
             wchar_t const* const* _ArgList
            );

        __declspec(dllimport) intptr_t __cdecl _wspawnve(
                   int                   _Mode,
                 wchar_t const*        _FileName,
                 wchar_t const* const* _ArgList,
             wchar_t const* const* _Env
            );

        __declspec(dllimport) intptr_t __cdecl _wspawnvp(
               int                   _Mode,
             wchar_t const*        _FileName,
             wchar_t const* const* _ArgList
            );

        __declspec(dllimport) intptr_t __cdecl _wspawnvpe(
                   int                   _Mode,
                 wchar_t const*        _FileName,
                 wchar_t const* const* _ArgList,
             wchar_t const* const* _Env
            );

        __declspec(dllimport) int __cdecl _wsystem(
             wchar_t const* _Command
            );

    #line 121 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wprocess.h"
#line 122 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wprocess.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 21 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\wchar.h"


#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstring.h"








#pragma once




#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )




__pragma(pack(push, 8)) extern "C" {










    
    __declspec(dllimport) errno_t __cdecl wcscat_s(
         wchar_t* _Destination,
         rsize_t _SizeInWords,
         wchar_t const* _Source
        );

    
    __declspec(dllimport) errno_t __cdecl wcscpy_s(
         wchar_t* _Destination,
         rsize_t _SizeInWords,
         wchar_t const* _Source
        );

    
    __declspec(dllimport) errno_t __cdecl wcsncat_s(
         wchar_t*       _Destination,
                                    rsize_t        _SizeInWords,
              wchar_t const* _Source,
                                    rsize_t        _MaxCount
        );

    
    __declspec(dllimport) errno_t __cdecl wcsncpy_s(
         wchar_t*       _Destination,
                                 rsize_t        _SizeInWords,
           wchar_t const* _Source,
                                 rsize_t        _MaxCount
        );

    
    __declspec(dllimport) wchar_t* __cdecl wcstok_s(
                         wchar_t*       _String,
                                wchar_t const* _Delimiter,
          wchar_t**      _Context
        );

#line 69 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstring.h"











#line 81 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstring.h"


__declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wcsdup(
     wchar_t const* _String
    );



#line 90 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstring.h"



extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscat_s(wchar_t (&_Destination)[_Size], wchar_t const* _Source) throw() { return wcscat_s(_Destination, _Size, _Source); } }






    __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcscat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcscat( wchar_t *_Destination, wchar_t const* _Source);




#line 106 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstring.h"


__declspec(dllimport) int __cdecl wcscmp(
     wchar_t const* _String1,
     wchar_t const* _String2
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscpy_s(wchar_t (&_Destination)[_Size], wchar_t const* _Source) throw() { return wcscpy_s(_Destination, _Size, _Source); } }





__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcscpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcscpy( wchar_t *_Destination, wchar_t const* _Source);






__declspec(dllimport) size_t __cdecl wcscspn(
     wchar_t const* _String,
     wchar_t const* _Control
    );


__declspec(dllimport) size_t __cdecl wcslen(
     wchar_t const* _String
    );










__declspec(dllimport) size_t __cdecl wcsnlen(
     wchar_t const* _Source,
                           size_t         _MaxCount
    );



    
    



    



    static __inline size_t __cdecl wcsnlen_s(
         wchar_t const* _Source,
                               size_t         _MaxCount
        )
    {
        return (_Source == 0) ? 0 : wcsnlen(_Source, _MaxCount);
    }

#line 170 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstring.h"

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncat_s(wchar_t (&_Destination)[_Size], wchar_t const* _Source, size_t _Count) throw() { return wcsncat_s(_Destination, _Size, _Source, _Count); } }






__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsncat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcsncat( wchar_t *_Destination, wchar_t const* _Source, size_t _Count);








__declspec(dllimport) int __cdecl wcsncmp(
     wchar_t const* _String1,
     wchar_t const* _String2,
                           size_t         _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncpy_s(wchar_t (&_Destination)[_Size], wchar_t const* _Source, size_t _Count) throw() { return wcsncpy_s(_Destination, _Size, _Source, _Count); } }






__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsncpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcsncpy( wchar_t *_Destination, wchar_t const* _Source, size_t _Count);








__declspec(dllimport) wchar_t const * __cdecl wcspbrk(
     wchar_t const* _String,
     wchar_t const* _Control
    );


__declspec(dllimport) size_t __cdecl wcsspn(
     wchar_t const* _String,
     wchar_t const* _Control
    );

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl wcstok(
                         wchar_t*       _String,
                                wchar_t const* _Delimiter,
      wchar_t**      _Context
    );



    

#line 232 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstring.h"
        



    #line 237 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstring.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    static __inline wchar_t* __cdecl _wcstok(
         wchar_t*       const _String,
                wchar_t const* const _Delimiter
        )
    {
        return wcstok(_String, _Delimiter, 0);
    }

    

#line 250 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstring.h"

    
        extern "C++"  __declspec(deprecated("wcstok has been changed to conform with the ISO C standard, " "adding an extra context parameter. To use the legacy Microsoft " "wcstok, define _CRT_NON_CONFORMING_WCSTOK."))
        inline wchar_t* __cdecl wcstok(
             wchar_t*       _String,
                    wchar_t const* _Delimiter
            ) throw()
        {
            return wcstok(_String, _Delimiter, 0);
        }
    #line 261 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstring.h"

#line 263 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstring.h"




 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcserror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl _wcserror(
     int _ErrorNumber
    );


__declspec(dllimport) errno_t __cdecl _wcserror_s(
     wchar_t* _Buffer,
                                 size_t   _SizeInWords,
                                 int      _ErrorNumber
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcserror_s(wchar_t (&_Buffer)[_Size], int _Error) throw() { return _wcserror_s(_Buffer, _Size, _Error); } }







 __declspec(deprecated("This function or variable may be unsafe. Consider using " "__wcserror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl __wcserror(
     wchar_t const* _String
    );

 __declspec(dllimport) errno_t __cdecl __wcserror_s(
     wchar_t*       _Buffer,
                                 size_t         _SizeInWords,
                               wchar_t const* _ErrorMessage
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl __wcserror_s(wchar_t (&_Buffer)[_Size], wchar_t const* _ErrorMessage) throw() { return __wcserror_s(_Buffer, _Size, _ErrorMessage); } }





 __declspec(dllimport) int __cdecl _wcsicmp(
     wchar_t const* _String1,
     wchar_t const* _String2
    );

 __declspec(dllimport) int __cdecl _wcsicmp_l(
       wchar_t const* _String1,
       wchar_t const* _String2,
     _locale_t      _Locale
    );

 __declspec(dllimport) int __cdecl _wcsnicmp(
     wchar_t const* _String1,
     wchar_t const* _String2,
                           size_t         _MaxCount
    );

 __declspec(dllimport) int __cdecl _wcsnicmp_l(
     wchar_t const* _String1,
     wchar_t const* _String2,
                           size_t         _MaxCount,
                       _locale_t      _Locale
    );

 __declspec(dllimport) errno_t __cdecl _wcsnset_s(
     wchar_t* _Destination,
                                size_t   _SizeInWords,
                                wchar_t  _Value,
                                size_t   _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsnset_s(wchar_t (&_Destination)[_Size], wchar_t _Value, size_t _MaxCount) throw() { return _wcsnset_s(_Destination, _Size, _Value, _MaxCount); } }






__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsnset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcsnset( wchar_t *_String, wchar_t _Value, size_t _MaxCount);







__declspec(dllimport) wchar_t* __cdecl _wcsrev(
     wchar_t* _String
    );

 __declspec(dllimport) errno_t __cdecl _wcsset_s(
     wchar_t* _Destination,
                                size_t   _SizeInWords,
                                wchar_t  _Value
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsset_s(wchar_t (&_String)[_Size], wchar_t _Value) throw() { return _wcsset_s(_String, _Size, _Value); } }





__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcsset( wchar_t *_String, wchar_t _Value);






 __declspec(dllimport) errno_t __cdecl _wcslwr_s(
     wchar_t* _String,
                                size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s(wchar_t (&_String)[_Size]) throw() { return _wcslwr_s(_String, _Size); } }




__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcslwr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcslwr( wchar_t *_String);





__declspec(dllimport) errno_t __cdecl _wcslwr_s_l(
     wchar_t*  _String,
                                size_t    _SizeInWords,
                            _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s_l(wchar_t (&_String)[_Size], _locale_t _Locale) throw() { return _wcslwr_s_l(_String, _Size, _Locale); } }





__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcslwr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcslwr_l( wchar_t *_String, _locale_t _Locale);







__declspec(dllimport) errno_t __cdecl _wcsupr_s(
     wchar_t* _String,
                         size_t   _Size
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s(wchar_t (&_String)[_Size]) throw() { return _wcsupr_s(_String, _Size); } }




__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsupr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcsupr( wchar_t *_String);





__declspec(dllimport) errno_t __cdecl _wcsupr_s_l(
     wchar_t*  _String,
                         size_t    _Size,
                     _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s_l(wchar_t (&_String)[_Size], _locale_t _Locale) throw() { return _wcsupr_s_l(_String, _Size, _Locale); } }





__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsupr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcsupr_l( wchar_t *_String, _locale_t _Locale);








__declspec(dllimport) size_t __cdecl wcsxfrm(
      wchar_t*       _Destination,
                                        wchar_t const* _Source,
              size_t         _MaxCount
    );



__declspec(dllimport) size_t __cdecl _wcsxfrm_l(
      wchar_t*       _Destination,
                                        wchar_t const* _Source,
              size_t         _MaxCount,
                                      _locale_t      _Locale
    );


__declspec(dllimport) int __cdecl wcscoll(
     wchar_t const* _String1,
     wchar_t const* _String2
    );


__declspec(dllimport) int __cdecl _wcscoll_l(
       wchar_t const* _String1,
       wchar_t const* _String2,
     _locale_t      _Locale
    );


__declspec(dllimport) int __cdecl _wcsicoll(
     wchar_t const* _String1,
     wchar_t const* _String2
    );


__declspec(dllimport) int __cdecl _wcsicoll_l(
       wchar_t const* _String1,
       wchar_t const* _String2,
     _locale_t      _Locale
    );


__declspec(dllimport) int __cdecl _wcsncoll(
     wchar_t const* _String1,
     wchar_t const* _String2,
                           size_t         _MaxCount
    );


__declspec(dllimport) int __cdecl _wcsncoll_l(
     wchar_t const* _String1,
     wchar_t const* _String2,
                           size_t         _MaxCount,
                       _locale_t      _Locale
    );


__declspec(dllimport) int __cdecl _wcsnicoll(
     wchar_t const* _String1,
     wchar_t const* _String2,
                           size_t         _MaxCount
    );


__declspec(dllimport) int __cdecl _wcsnicoll_l(
     wchar_t const* _String1,
     wchar_t const* _String2,
                           size_t         _MaxCount,
                       _locale_t      _Locale
    );









extern "C++" {

    
    
    inline wchar_t* __cdecl wcschr( wchar_t* _String, wchar_t _C)
    {
        return const_cast<wchar_t*>(wcschr(static_cast<wchar_t const*>(_String), _C));
    }

    
    inline wchar_t* __cdecl wcspbrk( wchar_t* _String,  wchar_t const* _Control)
    {
        return const_cast<wchar_t*>(wcspbrk(static_cast<wchar_t const*>(_String), _Control));
    }

    
    inline wchar_t* __cdecl wcsrchr( wchar_t* _String,  wchar_t _C)
    {
        return const_cast<wchar_t*>(wcsrchr(static_cast<wchar_t const*>(_String), _C));
    }

     
    
    inline wchar_t* __cdecl wcsstr( wchar_t* _String,  wchar_t const*_SubStr)
    {
        return const_cast<wchar_t*>(wcsstr(static_cast<wchar_t const*>(_String), _SubStr));
    }

}
#line 555 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstring.h"









    


#line 568 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstring.h"

     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsdup" ". See online help for details."))
    __declspec(dllimport) wchar_t* __cdecl wcsdup(
         wchar_t const* _String
        );

    

#line 577 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstring.h"

    
    

     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl wcsicmp(
         wchar_t const* _String1,
         wchar_t const* _String2
        );

     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsnicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl wcsnicmp(
         wchar_t const* _String1,
         wchar_t const* _String2,
                               size_t         _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsnset" ". See online help for details."))
    
    __declspec(dllimport) wchar_t* __cdecl wcsnset(
         wchar_t* _String,
                                 wchar_t  _Value,
                                 size_t   _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsrev" ". See online help for details."))
    
    __declspec(dllimport) wchar_t* __cdecl wcsrev(
         wchar_t* _String
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsset" ". See online help for details."))
    
    __declspec(dllimport) wchar_t* __cdecl wcsset(
         wchar_t* _String,
              wchar_t  _Value
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcslwr" ". See online help for details."))
    
    __declspec(dllimport) wchar_t* __cdecl wcslwr(
         wchar_t* _String
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsupr" ". See online help for details."))
    
    __declspec(dllimport) wchar_t* __cdecl wcsupr(
         wchar_t* _String
        );

     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsicoll" ". See online help for details."))
    __declspec(dllimport) int __cdecl wcsicoll(
         wchar_t const* _String1,
         wchar_t const* _String2
        );

#line 634 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstring.h"



} __pragma(pack(pop))

#line 640 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstring.h"

#pragma warning(pop) 
#pragma external_header(pop)
#line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\wchar.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wtime.h"








#pragma once



#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {








struct tm
{
    int tm_sec;   
    int tm_min;   
    int tm_hour;  
    int tm_mday;  
    int tm_mon;   
    int tm_year;  
    int tm_wday;  
    int tm_yday;  
    int tm_isdst; 
};







 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wasctime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))


__declspec(dllimport) wchar_t* __cdecl _wasctime(
     struct tm const* _Tm
    );



__declspec(dllimport) errno_t __cdecl _wasctime_s(
      wchar_t*         _Buffer,
                                         size_t           _SizeInWords,
                                                      struct tm const* _Tm
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wasctime_s(wchar_t (&_Buffer)[_Size], struct tm const* _Time) throw() { return _wasctime_s(_Buffer, _Size, _Time); } }








__declspec(dllimport) size_t __cdecl wcsftime(
      wchar_t*         _Buffer,
                              size_t           _SizeInWords,
                            wchar_t const*   _Format,
                              struct tm const* _Tm
    );



__declspec(dllimport) size_t __cdecl _wcsftime_l(
      wchar_t*         _Buffer,
                              size_t           _SizeInWords,
                            wchar_t const*   _Format,
                              struct tm const* _Tm,
                          _locale_t        _Locale
    );


 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctime32_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl _wctime32(
     __time32_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _wctime32_s(
      wchar_t*          _Buffer,
                                    size_t            _SizeInWords,
                                                      __time32_t const* _Time
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime32_s(wchar_t (&_Buffer)[_Size], __time32_t const* _Time) throw() { return _wctime32_s(_Buffer, _Size, _Time); } }







 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctime64_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl _wctime64(
     __time64_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _wctime64_s(
      wchar_t*          _Buffer,
                                    size_t            _SizeInWords,
                                                      __time64_t const* _Time);

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime64_s(wchar_t (&_Buffer)[_Size], __time64_t const* _Time) throw() { return _wctime64_s(_Buffer, _Size, _Time); } }






__declspec(dllimport) errno_t __cdecl _wstrdate_s(
      wchar_t* _Buffer,
                                                                               size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrdate_s(wchar_t (&_Buffer)[_Size]) throw() { return _wstrdate_s(_Buffer, _Size); } }




__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wstrdate_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wstrdate( wchar_t *_Buffer);





__declspec(dllimport) errno_t __cdecl _wstrtime_s(
      wchar_t* _Buffer,
                                                                               size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrtime_s(wchar_t (&_Buffer)[_Size]) throw() { return _wstrtime_s(_Buffer, _Size); } }




__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wstrtime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wstrtime( wchar_t *_Buffer);












    




















        
        static __inline wchar_t * __cdecl _wctime(
             time_t const* const _Time)
        {
            return _wctime64(_Time);
        }

        
        static __inline errno_t __cdecl _wctime_s(
               wchar_t*      const _Buffer,
                                                            size_t        const _SizeInWords,
                                                            time_t const* const _Time
            )
        {
            return _wctime64_s(_Buffer, _SizeInWords, _Time);
        }

    #line 203 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wtime.h"
#line 204 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wtime.h"

} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\wchar.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\sys\\stat.h"







#pragma once


#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\sys\\types.h"







#pragma once



#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )



    

    typedef unsigned short _ino_t; 

    
        typedef _ino_t ino_t;
    #line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\sys\\types.h"
#line 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\sys\\types.h"




    

    typedef unsigned int _dev_t; 

    
        typedef _dev_t dev_t;
    #line 36 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\sys\\types.h"
#line 37 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\sys\\types.h"




    

    typedef long _off_t; 

    
        typedef _off_t off_t;
    #line 48 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\sys\\types.h"
#line 49 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\sys\\types.h"


#pragma warning(pop) 
#pragma external_header(pop)
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\sys\\stat.h"

#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {






struct _stat32
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    _off_t         st_size;
    __time32_t     st_atime;
    __time32_t     st_mtime;
    __time32_t     st_ctime;
};

struct _stat32i64
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    __int64        st_size;
    __time32_t     st_atime;
    __time32_t     st_mtime;
    __time32_t     st_ctime;
};

struct _stat64i32
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    _off_t         st_size;
    __time64_t     st_atime;
    __time64_t     st_mtime;
    __time64_t     st_ctime;
};

struct _stat64
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    __int64        st_size;
    __time64_t     st_atime;
    __time64_t     st_mtime;
    __time64_t     st_ctime;
};




    struct stat
    {
        _dev_t         st_dev;
        _ino_t         st_ino;
        unsigned short st_mode;
        short          st_nlink;
        short          st_uid;
        short          st_gid;
        _dev_t         st_rdev;
        _off_t         st_size;
        time_t         st_atime;
        time_t         st_mtime;
        time_t         st_ctime;
    };
#line 102 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\sys\\stat.h"


















    
    
    
    
    
    
    
#line 128 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\sys\\stat.h"
















    
    
    
    
    
    
#line 151 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\sys\\stat.h"



__declspec(dllimport) int __cdecl _fstat32(
      int             _FileHandle,
     struct _stat32* _Stat
    );

__declspec(dllimport) int __cdecl _fstat32i64(
      int                _FileHandle,
     struct _stat32i64* _Stat
    );

__declspec(dllimport) int __cdecl _fstat64i32(
      int                _FileHandle,
     struct _stat64i32* _Stat
    );

__declspec(dllimport) int __cdecl _fstat64(
      int             _FileHandle,
     struct _stat64* _Stat
    );

__declspec(dllimport) int __cdecl _stat32(
     char const*     _FileName,
      struct _stat32* _Stat
    );

__declspec(dllimport) int __cdecl _stat32i64(
     char const*        _FileName,
      struct _stat32i64* _Stat
    );

__declspec(dllimport) int __cdecl _stat64i32(
     char const*        _FileName,
      struct _stat64i32* _Stat
    );

__declspec(dllimport) int __cdecl _stat64(
     char const*     _FileName,
      struct _stat64* _Stat
    );

__declspec(dllimport) int __cdecl _wstat32(
     wchar_t const*  _FileName,
      struct _stat32* _Stat
    );

__declspec(dllimport) int __cdecl _wstat32i64(
     wchar_t const*     _FileName,
      struct _stat32i64* _Stat
    );

__declspec(dllimport) int __cdecl _wstat64i32(
     wchar_t const*     _FileName,
      struct _stat64i32* _Stat
    );

__declspec(dllimport) int __cdecl _wstat64(
     wchar_t const*  _FileName,
      struct _stat64* _Stat
    );




    















        static __inline int __cdecl fstat(int const _FileHandle, struct stat* const _Stat)
        {
            static_assert((sizeof(struct stat) == sizeof(struct _stat64i32)), "sizeof(struct stat) == sizeof(struct _stat64i32)") ;
            return _fstat64i32(_FileHandle, (struct _stat64i32*)_Stat);
        }
        static __inline int __cdecl stat(char const* const _FileName, struct stat* const _Stat)
        {
            static_assert((sizeof(struct stat) == sizeof(struct _stat64i32)), "sizeof(struct stat) == sizeof(struct _stat64i32)") ;
            return _stat64i32(_FileName, (struct _stat64i32*)_Stat);
        }

    #line 245 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\sys\\stat.h"
#line 246 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\sys\\stat.h"

} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 26 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\wchar.h"



#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {








typedef wchar_t _Wint_t;





      
    __declspec(dllimport) wchar_t* __cdecl _wsetlocale(
               int            _Category,
         wchar_t const* _Locale
        );

    
    __declspec(dllimport) _locale_t __cdecl _wcreate_locale(
           int            _Category,
         wchar_t const* _Locale
        );



    __declspec(dllimport) wint_t __cdecl btowc(
         int _Ch
        );

    __declspec(dllimport) size_t __cdecl mbrlen(
          char const* _Ch,
                                                   size_t      _SizeInBytes,
                                                mbstate_t*  _State
        );

    __declspec(dllimport) size_t __cdecl mbrtowc(
                                wchar_t*    _DstCh,
          char const* _SrcCh,
                                                   size_t      _SizeInBytes,
                                                mbstate_t*  _State
        );

    
    __declspec(dllimport) errno_t __cdecl mbsrtowcs_s(
                                 size_t*      _Retval,
                 wchar_t*     _Dst,
                                      size_t       _Size,
                         char const** _PSrc,
                                      size_t       _N,
                                   mbstate_t*   _State
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl mbsrtowcs_s(size_t* _Retval, wchar_t (&_Dest)[_Size], char const** _PSource, size_t _Count, mbstate_t* _State) throw() { return mbsrtowcs_s(_Retval, _Dest, _Size, _PSource, _Count, _State); } }









    __declspec(deprecated("This function or variable may be unsafe. Consider using " "mbsrtowcs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl mbsrtowcs( wchar_t *_Dest, char const** _PSrc, size_t _Count, mbstate_t* _State);







    
    __declspec(dllimport) errno_t __cdecl wcrtomb_s(
                                size_t*    _Retval,
         char*      _Dst,
                                     size_t     _SizeInBytes,
                                     wchar_t    _Ch,
                              mbstate_t* _State
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl wcrtomb_s(size_t* _Retval, char (&_Dest)[_Size], wchar_t _Source, mbstate_t* _State) throw() { return wcrtomb_s(_Retval, _Dest, _Size, _Source, _State); } }








    __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcrtomb_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl wcrtomb( char *_Dest, wchar_t _Source, mbstate_t* _State);






    
    __declspec(dllimport) errno_t __cdecl wcsrtombs_s(
                                                 size_t*         _Retval,
         char*           _Dst,
                                                      size_t          _SizeInBytes,
                                  wchar_t const** _Src,
                                                      size_t          _Size,
                                               mbstate_t*      _State
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsrtombs_s(size_t* _Retval, char (&_Dest)[_Size], wchar_t const** _PSrc, size_t _Count, mbstate_t* _State) throw() { return wcsrtombs_s(_Retval, _Dest, _Size, _PSrc, _Count, _State); } }









    __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsrtombs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl wcsrtombs( char *_Dest, wchar_t const** _PSource, size_t _Count, mbstate_t* _State);







    __declspec(dllimport) int __cdecl wctob(
         wint_t _WCh
        );

    

        
        errno_t __cdecl wmemcpy_s(
             wchar_t*       _S1,
                                     rsize_t        _N1,
                       wchar_t const* _S2,
                                     rsize_t        _N
            );

        
        errno_t __cdecl wmemmove_s(
             wchar_t*       _S1,
                                     rsize_t        _N1,
                       wchar_t const* _S2,
                                     rsize_t        _N
            );

    #line 183 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\wchar.h"

    __inline int __cdecl fwide(
         FILE* _F,
             int   _M
        )
    {
        (void)_F ;
        return (_M);
    }

    __inline int __cdecl mbsinit(
         mbstate_t const* _P
        )
    {
        return _P == 0 || _P->_Wchar == 0;
    }

    __inline wchar_t const * __cdecl wmemchr(
         wchar_t const* _S,
                   wchar_t        _C,
                   size_t         _N
        )
    {
        for (; 0 < _N; ++_S, --_N)
            if (*_S == _C)
                return (wchar_t const *)_S;

        return 0;
    }

    __inline int __cdecl wmemcmp(
         wchar_t const* _S1,
         wchar_t const* _S2,
                   size_t         _N
        )
    {
        for (; 0 < _N; ++_S1, ++_S2, --_N)
            if (*_S1 != *_S2)
                return *_S1 < *_S2 ? -1 : 1;

        return 0;
    }

    
    
    __inline 
    wchar_t* __cdecl wmemcpy(
         wchar_t*       _S1,
               wchar_t const* _S2,
                         size_t         _N
        )
    {
        #pragma warning(suppress: 6386) 
        return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));
    }

    __inline 
    wchar_t* __cdecl wmemmove(
         wchar_t*       _S1,
               wchar_t const* _S2,
                             size_t         _N
        )
    {
        #pragma warning(suppress: 6386) 
        return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));
    }

    
    
    __inline wchar_t* __cdecl wmemset(
         wchar_t* _S,
                         wchar_t  _C,
                         size_t   _N
        )
    {
        wchar_t *_Su = _S;
        for (; 0 < _N; ++_Su, --_N)
        {
            *_Su = _C;
        }
        return _S;
    }

    

        extern "C++" inline wchar_t* __cdecl wmemchr(
             wchar_t* _S,
                       wchar_t  _C,
                       size_t   _N
            )
        {
            wchar_t const* const _SC = _S;
            return const_cast<wchar_t*>(wmemchr(_SC, _C, _N));
        }

    #line 279 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\wchar.h"

#line 281 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\wchar.h"


} __pragma(pack(pop))

#pragma warning(pop) 
#line 287 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\wchar.h"
#pragma external_header(pop)
#line 14 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cwchar"

#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




using _Mbstatet = mbstate_t;

namespace std {
#pragma warning(push)
#pragma warning(disable : 4995) 

using :: _Mbstatet;

 using :: mbstate_t;
 using :: size_t;
 using :: tm;
 using :: wint_t;

 using :: btowc;
 using :: fgetwc;
 using :: fgetws;
 using :: fputwc;
 using :: fputws;
 using :: fwide;
 using :: fwprintf;
 using :: fwscanf;
 using :: getwc;
 using :: getwchar;
 using :: mbrlen;
 using :: mbrtowc;
 using :: mbsrtowcs;
 using :: mbsinit;
 using :: putwc;
 using :: putwchar;
 using :: swprintf;
 using :: swscanf;
 using :: ungetwc;
 using :: vfwprintf;
 using :: vswprintf;
 using :: vwprintf;
 using :: wcrtomb;
 using :: wprintf;
 using :: wscanf;
 using :: wcsrtombs;
 using :: wcstol;
 using :: wcscat;
 using :: wcschr;
 using :: wcscmp;
 using :: wcscoll;
 using :: wcscpy;
 using :: wcscspn;
 using :: wcslen;
 using :: wcsncat;
 using :: wcsncmp;
 using :: wcsncpy;
 using :: wcspbrk;
 using :: wcsrchr;
 using :: wcsspn;
 using :: wcstod;
 using :: wcstoul;
 using :: wcsstr;
 using :: wcstok;
 using :: wcsxfrm;
 using :: wctob;
 using :: wmemchr;
 using :: wmemcmp;
 using :: wmemcpy;
 using :: wmemmove;
 using :: wmemset;
 using :: wcsftime;

 using :: vfwscanf;
 using :: vswscanf;
 using :: vwscanf;
 using :: wcstof;
 using :: wcstold;
 using :: wcstoll;
 using :: wcstoull;

#pragma warning(pop)
}



#pragma warning(pop)
#pragma pack(pop)

#line 105 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cwchar"
#line 106 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cwchar"
#pragma external_header(pop)
#line 14 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"







#line 23 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"

#line 25 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"



#line 29 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"

#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




namespace std {
 enum float_denorm_style { 
    denorm_indeterminate = -1,
    denorm_absent        = 0,
    denorm_present       = 1
};

 enum float_round_style { 
    round_indeterminate       = -1,
    round_toward_zero         = 0,
    round_to_nearest          = 1,
    round_toward_infinity     = 2,
    round_toward_neg_infinity = 3
};

struct _Num_base { 
    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr bool has_denorm_loss          = false;
    static constexpr bool has_infinity             = false;
    static constexpr bool has_quiet_NaN            = false;
    static constexpr bool has_signaling_NaN        = false;
    static constexpr bool is_bounded               = false;
    static constexpr bool is_exact                 = false;
    static constexpr bool is_iec559                = false;
    static constexpr bool is_integer               = false;
    static constexpr bool is_modulo                = false;
    static constexpr bool is_signed                = false;
    static constexpr bool is_specialized           = false;
    static constexpr bool tinyness_before          = false;
    static constexpr bool traps                    = false;
    static constexpr float_round_style round_style = round_toward_zero;
    static constexpr int digits                    = 0;
    static constexpr int digits10                  = 0;
    static constexpr int max_digits10              = 0;
    static constexpr int max_exponent              = 0;
    static constexpr int max_exponent10            = 0;
    static constexpr int min_exponent              = 0;
    static constexpr int min_exponent10            = 0;
    static constexpr int radix                     = 0;
};

 template <class _Ty>
class numeric_limits : public _Num_base { 
public:
    [[nodiscard]] static constexpr _Ty(min)() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty(max)() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty lowest() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty epsilon() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty round_error() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty denorm_min() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty infinity() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty quiet_NaN() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty signaling_NaN() noexcept {
        return _Ty();
    }
};

template <class _Ty>
class numeric_limits<const _Ty> : public numeric_limits<_Ty> {}; 

template <class _Ty>
class numeric_limits<volatile _Ty> : public numeric_limits<_Ty> {}; 

template <class _Ty>
class numeric_limits<const volatile _Ty> : public numeric_limits<_Ty> {}; 

struct _Num_int_base : _Num_base { 
    static constexpr bool is_bounded     = true;
    static constexpr bool is_exact       = true;
    static constexpr bool is_integer     = true;
    static constexpr bool is_specialized = true;
    static constexpr int radix           = 2;
};

struct _Num_float_base : _Num_base { 
    static constexpr float_denorm_style has_denorm = denorm_present;
    static constexpr bool has_infinity             = true;
    static constexpr bool has_quiet_NaN            = true;
    static constexpr bool has_signaling_NaN        = true;
    static constexpr bool is_bounded               = true;
    static constexpr bool is_iec559                = true;
    static constexpr bool is_signed                = true;
    static constexpr bool is_specialized           = true;
    static constexpr float_round_style round_style = round_to_nearest;
    static constexpr int radix                     = 2 ;
};

template <>
class numeric_limits<bool> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr bool(min)() noexcept {
        return false;
    }

    [[nodiscard]] static constexpr bool(max)() noexcept {
        return true;
    }

    [[nodiscard]] static constexpr bool lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr bool epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr bool round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr bool denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr bool infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr bool quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr bool signaling_NaN() noexcept {
        return 0;
    }

    static constexpr int digits = 1;
};

template <>
class numeric_limits<char> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr char(min)() noexcept {
        return (-128) ;
    }

    [[nodiscard]] static constexpr char(max)() noexcept {
        return 127 ;
    }

    [[nodiscard]] static constexpr char lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr char epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_signed = (-128) != 0;
    static constexpr bool is_modulo = (-128) == 0;
    static constexpr int digits     = 8 - ((-128) != 0);
    static constexpr int digits10   = 2;
};

template <>
class numeric_limits<signed char> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr signed char(min)() noexcept {
        return (-128) ;
    }

    [[nodiscard]] static constexpr signed char(max)() noexcept {
        return 127 ;
    }

    [[nodiscard]] static constexpr signed char lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr signed char epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr signed char round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr signed char denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr signed char infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr signed char quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr signed char signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_signed = true;
    static constexpr int digits     = 7;
    static constexpr int digits10   = 2;
};

template <>
class numeric_limits<unsigned char> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr unsigned char(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned char(max)() noexcept {
        return 0xff ;
    }

    [[nodiscard]] static constexpr unsigned char lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr unsigned char epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned char round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned char denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned char infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned char quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned char signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 8;
    static constexpr int digits10   = 2;
};


template <>
class numeric_limits<char8_t> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr char8_t(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char8_t(max)() noexcept {
        return 0xff ;
    }

    [[nodiscard]] static constexpr char8_t lowest() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char8_t epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char8_t round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char8_t denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char8_t infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char8_t quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char8_t signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 8;
    static constexpr int digits10   = 2;
};
#line 368 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"

template <>
class numeric_limits<char16_t> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr char16_t(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char16_t(max)() noexcept {
        return 0xffff ;
    }

    [[nodiscard]] static constexpr char16_t lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr char16_t epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char16_t round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char16_t denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char16_t infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char16_t quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char16_t signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 16;
    static constexpr int digits10   = 4;
};

template <>
class numeric_limits<char32_t> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr char32_t(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char32_t(max)() noexcept {
        return 0xffffffff ;
    }

    [[nodiscard]] static constexpr char32_t lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr char32_t epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char32_t round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char32_t denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char32_t infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char32_t quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char32_t signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 32;
    static constexpr int digits10   = 9;
};

template <>
class numeric_limits<wchar_t> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr wchar_t(min)() noexcept {
        return 0x0000 ;
    }

    [[nodiscard]] static constexpr wchar_t(max)() noexcept {
        return 0xffff ;
    }

    [[nodiscard]] static constexpr wchar_t lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr wchar_t epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr wchar_t round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr wchar_t denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr wchar_t infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr wchar_t quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr wchar_t signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 16;
    static constexpr int digits10   = 4;
};

template <>
class numeric_limits<short> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr short(min)() noexcept {
        return (-32768) ;
    }

    [[nodiscard]] static constexpr short(max)() noexcept {
        return 32767 ;
    }

    [[nodiscard]] static constexpr short lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr short epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr short round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr short denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr short infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr short quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr short signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_signed = true;
    static constexpr int digits     = 15;
    static constexpr int digits10   = 4;
};

template <>
class numeric_limits<int> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr int(min)() noexcept {
        return (-2147483647 - 1) ;
    }

    [[nodiscard]] static constexpr int(max)() noexcept {
        return 2147483647 ;
    }

    [[nodiscard]] static constexpr int lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr int epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr int round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr int denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr int infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr int quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr int signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_signed = true;
    static constexpr int digits     = 31;
    static constexpr int digits10   = 9;
};

template <>
class numeric_limits<long> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr long(min)() noexcept {
        return (-2147483647L - 1) ;
    }

    [[nodiscard]] static constexpr long(max)() noexcept {
        return 2147483647L ;
    }

    [[nodiscard]] static constexpr long lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr long epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long signaling_NaN() noexcept {
        return 0;
    }

    static_assert(sizeof(int) == sizeof(long), "LLP64 assumption");
    static constexpr bool is_signed = true;
    static constexpr int digits     = 31;
    static constexpr int digits10   = 9;
};

template <>
class numeric_limits<long long> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr long long(min)() noexcept {
        return (-9223372036854775807i64 - 1) ;
    }

    [[nodiscard]] static constexpr long long(max)() noexcept {
        return 9223372036854775807i64 ;
    }

    [[nodiscard]] static constexpr long long lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr long long epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long long round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long long denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long long infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long long quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long long signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_signed = true;
    static constexpr int digits     = 63;
    static constexpr int digits10   = 18;
};


template <>
class numeric_limits<unsigned short> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr unsigned short(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned short(max)() noexcept {
        return 0xffff ;
    }

    [[nodiscard]] static constexpr unsigned short lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr unsigned short epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned short round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned short denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned short infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned short quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned short signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 16;
    static constexpr int digits10   = 4;
};
#line 723 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"

template <>
class numeric_limits<unsigned int> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr unsigned int(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned int(max)() noexcept {
        return 0xffffffff ;
    }

    [[nodiscard]] static constexpr unsigned int lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr unsigned int epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned int round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned int denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned int infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned int quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned int signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 32;
    static constexpr int digits10   = 9;
};

template <>
class numeric_limits<unsigned long> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr unsigned long(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long(max)() noexcept {
        return 0xffffffffUL ;
    }

    [[nodiscard]] static constexpr unsigned long lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr unsigned long epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long signaling_NaN() noexcept {
        return 0;
    }

    static_assert(sizeof(unsigned int) == sizeof(unsigned long), "LLP64 assumption");
    static constexpr bool is_modulo = true;
    static constexpr int digits     = 32;
    static constexpr int digits10   = 9;
};

template <>
class numeric_limits<unsigned long long> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr unsigned long long(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long long(max)() noexcept {
        return 0xffffffffffffffffui64 ;
    }

    [[nodiscard]] static constexpr unsigned long long lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr unsigned long long epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long long round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long long denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long long infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long long quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long long signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 64;
    static constexpr int digits10   = 19;
};

template <>
class numeric_limits<float> : public _Num_float_base {
public:
    [[nodiscard]] static constexpr float(min)() noexcept {
        return 1.175494351e-38F ;
    }

    [[nodiscard]] static constexpr float(max)() noexcept {
        return 3.402823466e+38F ;
    }

    [[nodiscard]] static constexpr float lowest() noexcept {
        return -(max) ();
    }

    [[nodiscard]] static constexpr float epsilon() noexcept {
        return 1.192092896e-07F ;
    }

    [[nodiscard]] static constexpr float round_error() noexcept {
        return 0.5F;
    }

    [[nodiscard]] static constexpr float denorm_min() noexcept {
        return 1.401298464e-45F ;
    }

    [[nodiscard]] static constexpr float infinity() noexcept {
        return __builtin_huge_valf();
    }

    [[nodiscard]] static constexpr float quiet_NaN() noexcept {
        return __builtin_nanf("0");
    }

    [[nodiscard]] static constexpr float signaling_NaN() noexcept {
        return __builtin_nansf("1");
    }

    static constexpr int digits         = 24 ;
    static constexpr int digits10       = 6 ;
    static constexpr int max_digits10   = 9;
    static constexpr int max_exponent   = 128 ;
    static constexpr int max_exponent10 = 38 ;
    static constexpr int min_exponent   = (-125) ;
    static constexpr int min_exponent10 = (-37) ;
};

template <>
class numeric_limits<double> : public _Num_float_base {
public:
    [[nodiscard]] static constexpr double(min)() noexcept {
        return 2.2250738585072014e-308 ;
    }

    [[nodiscard]] static constexpr double(max)() noexcept {
        return 1.7976931348623158e+308 ;
    }

    [[nodiscard]] static constexpr double lowest() noexcept {
        return -(max) ();
    }

    [[nodiscard]] static constexpr double epsilon() noexcept {
        return 2.2204460492503131e-016 ;
    }

    [[nodiscard]] static constexpr double round_error() noexcept {
        return 0.5;
    }

    [[nodiscard]] static constexpr double denorm_min() noexcept {
        return 4.9406564584124654e-324 ;
    }

    [[nodiscard]] static constexpr double infinity() noexcept {
        return __builtin_huge_val();
    }

    [[nodiscard]] static constexpr double quiet_NaN() noexcept {
        return __builtin_nan("0");
    }

    [[nodiscard]] static constexpr double signaling_NaN() noexcept {
        return __builtin_nans("1");
    }

    static constexpr int digits         = 53 ;
    static constexpr int digits10       = 15 ;
    static constexpr int max_digits10   = 17;
    static constexpr int max_exponent   = 1024 ;
    static constexpr int max_exponent10 = 308 ;
    static constexpr int min_exponent   = (-1021) ;
    static constexpr int min_exponent10 = (-307) ;
};

template <>
class numeric_limits<long double> : public _Num_float_base {
public:
    [[nodiscard]] static constexpr long double(min)() noexcept {
        return 2.2250738585072014e-308 ;
    }

    [[nodiscard]] static constexpr long double(max)() noexcept {
        return 1.7976931348623158e+308 ;
    }

    [[nodiscard]] static constexpr long double lowest() noexcept {
        return -(max) ();
    }

    [[nodiscard]] static constexpr long double epsilon() noexcept {
        return 2.2204460492503131e-016 ;
    }

    [[nodiscard]] static constexpr long double round_error() noexcept {
        return 0.5L;
    }

    [[nodiscard]] static constexpr long double denorm_min() noexcept {
        return 4.9406564584124654e-324 ;
    }

    [[nodiscard]] static constexpr long double infinity() noexcept {
        return __builtin_huge_val();
    }

    [[nodiscard]] static constexpr long double quiet_NaN() noexcept {
        return __builtin_nan("0");
    }

    [[nodiscard]] static constexpr long double signaling_NaN() noexcept {
        return __builtin_nans("1");
    }

    static constexpr int digits         = 53 ;
    static constexpr int digits10       = 15 ;
    static constexpr int max_digits10   = 2 + 53 * 301L / 1000;
    static constexpr int max_exponent   = 1024 ;
    static constexpr int max_exponent10 = 308 ;
    static constexpr int min_exponent   = (-1021) ;
    static constexpr int min_exponent10 = (-307) ;
};




template <class _Ty>
[[nodiscard]] constexpr int _Countl_zero_fallback(_Ty _Val) noexcept {
    _Ty _Yy = 0;

    unsigned int _Nn = numeric_limits<_Ty>::digits;
    unsigned int _Cc = numeric_limits<_Ty>::digits / 2;
    do {
        _Yy = static_cast<_Ty>(_Val >> _Cc);
        if (_Yy != 0) {
            _Nn -= _Cc;
            _Val = _Yy;
        }
        _Cc >>= 1;
    } while (_Cc != 0);
    return static_cast<int>(_Nn) - static_cast<int>(_Val);
}




template <class _Ty>
[[nodiscard]] constexpr int _Countr_zero_fallback(const _Ty _Val) noexcept {
    constexpr int _Digits = numeric_limits<_Ty>::digits;
    return _Digits - _Countl_zero_fallback(static_cast<_Ty>(static_cast<_Ty>(~_Val) & static_cast<_Ty>(_Val - 1)));
}



template <class _Ty>
[[nodiscard]] constexpr int _Popcount_fallback(_Ty _Val) noexcept {
    constexpr int _Digits = numeric_limits<_Ty>::digits;







#line 1043 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"
    
    _Val = static_cast<_Ty>(_Val - ((_Val >> 1) & static_cast<_Ty>(0x5555'5555'5555'5555ull)));
    _Val = static_cast<_Ty>((_Val & static_cast<_Ty>(0x3333'3333'3333'3333ull))
                            + ((_Val >> 2) & static_cast<_Ty>(0x3333'3333'3333'3333ull)));
    _Val = static_cast<_Ty>((_Val + (_Val >> 4)) & static_cast<_Ty>(0x0F0F'0F0F'0F0F'0F0Full));
    
    _Val = static_cast<_Ty>(_Val * static_cast<_Ty>(0x0101'0101'0101'0101ull));
    
    return static_cast<int>(_Val >> (_Digits - 8));
}





#line 1060 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"


extern "C" {
extern int __isa_available;
}







#line 1073 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"

template <class _Ty>
[[nodiscard]] int _Countr_zero_tzcnt(const _Ty _Val) noexcept {
    constexpr int _Digits = numeric_limits<_Ty>::digits;
    constexpr _Ty _Max    = (numeric_limits<_Ty>::max)();

    if constexpr (_Digits <= 32) {
        
        
        
        return static_cast<int>(_tzcnt_u32 (static_cast<unsigned int>(~_Max | _Val)));
    } else {









        return static_cast<int>(_tzcnt_u64 (_Val));
#line 1096 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"
    }
}




template <class _Ty>
[[nodiscard]] int _Countr_zero_bsf(const _Ty _Val) noexcept {
    constexpr int _Digits = numeric_limits<_Ty>::digits;
    constexpr _Ty _Max    = (numeric_limits<_Ty>::max)();

    unsigned long _Result;
    if constexpr (_Digits <= 32) {
        
        
        
        if (!_BitScanForward(&_Result, static_cast<unsigned int>(~_Max | _Val))) {
            return _Digits;
        }
    } else {













        if (!_BitScanForward64(&_Result, _Val)) {
            return _Digits;
        }
#line 1133 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"
    }
    return static_cast<int>(_Result);
}

template <class _Ty>
[[nodiscard]] int _Checked_x86_x64_countr_zero(const _Ty _Val) noexcept {



    const bool _Definitely_have_tzcnt = __isa_available >= __ISA_AVAILABLE_AVX2;
    if (_Definitely_have_tzcnt) {
        return _Countr_zero_tzcnt(_Val);
    } else {
        return _Countr_zero_bsf(_Val);
    }
#line 1149 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"
}

#line 1152 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"





#line 1159 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"


template <class _Ty>
[[nodiscard]] int _Unchecked_x86_x64_popcount(const _Ty _Val) noexcept {
    constexpr int _Digits = numeric_limits<_Ty>::digits;
    if constexpr (_Digits <= 16) {
        return static_cast<int>(__popcnt16(_Val));
    } else if constexpr (_Digits == 32) {
        return static_cast<int>(__popcnt(_Val));
    } else {



        return static_cast<int>(__popcnt64(_Val));
#line 1174 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"
    }
}

template <class _Ty>
[[nodiscard]] int _Checked_x86_x64_popcount(const _Ty _Val) noexcept {

    const bool _Definitely_have_popcnt = __isa_available >= __ISA_AVAILABLE_SSE42;
    if (!_Definitely_have_popcnt) {
        return _Popcount_fallback(_Val);
    }
#line 1185 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"
    return _Unchecked_x86_x64_popcount(_Val);
}
#line 1188 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"






#line 1195 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"

template <class _Ty>
constexpr bool _Is_standard_unsigned_integer =
    _Is_any_of_v<remove_cv_t<_Ty>, unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>;

template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> = 0>
[[nodiscard]] constexpr int _Countr_zero(const _Ty _Val) noexcept {


    if (!::std:: is_constant_evaluated())
#line 1206 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"
    {
        return _Checked_x86_x64_countr_zero(_Val);
    }
#line 1210 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"
    return _Countr_zero_fallback(_Val);
}

template <class _Ty, class _Fn>
constexpr decltype(auto) _Select_countr_zero_impl(_Fn _Callback) {
    

    if (!::std:: is_constant_evaluated()) {



        const bool _Definitely_have_tzcnt = __isa_available >= __ISA_AVAILABLE_AVX2;
        if (_Definitely_have_tzcnt) {
            return _Callback([](_Ty _Val) { return _Countr_zero_tzcnt(_Val); });
        } else {
            return _Callback([](_Ty _Val) { return _Countr_zero_bsf(_Val); });
        }
#line 1228 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"
    }
#line 1230 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"
    
    return _Callback([](_Ty _Val) { return _Countr_zero_fallback(_Val); });
}

template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> _Enabled = 0>
[[nodiscard]] constexpr int _Popcount(const _Ty _Val) noexcept {


    if (!::std:: is_constant_evaluated())
#line 1240 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"
    {

        return _Checked_x86_x64_popcount(_Val);


#line 1246 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"
    }
#line 1248 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"
    return _Popcount_fallback(_Val);
}

template <class _Ty, class _Fn>
constexpr decltype(auto) _Select_popcount_impl(_Fn _Callback) {
    


    if (!::std:: is_constant_evaluated())
#line 1258 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"
    {


        const bool _Definitely_have_popcnt = __isa_available >= __ISA_AVAILABLE_SSE42;
        if (!_Definitely_have_popcnt) {
            return _Callback([](_Ty _Val) { return _Popcount_fallback(_Val); });
        }
#line 1266 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"
        return _Callback([](_Ty _Val) { return _Unchecked_x86_x64_popcount(_Val); });


#line 1270 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"
    }
#line 1272 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"
    return _Callback([](_Ty _Val) { return _Popcount_fallback(_Val); });
}





}


#pragma warning(pop)
#pragma pack(pop)
#line 1285 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"
#line 1286 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"
#pragma external_header(pop)
#line 18 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\bit"


#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




namespace std {

 template <class _To, class _From,
    enable_if_t<conjunction_v<bool_constant<sizeof(_To) == sizeof(_From)>, is_trivially_copyable<_To>,
                    is_trivially_copyable<_From>>,
        int> = 0>
[[nodiscard]] constexpr _To bit_cast(const _From& _Val) noexcept {
    return __builtin_bit_cast(_To, _Val);
}

 template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> = 0>
[[nodiscard]] constexpr int countl_zero(_Ty _Val) noexcept;

 template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> = 0>
[[nodiscard]] constexpr bool has_single_bit(const _Ty _Val) noexcept {
    return _Val != 0 && (_Val & (_Val - 1)) == 0;
}

inline void _Precondition_violation_in_bit_ceil() noexcept {}

 template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> = 0>
[[nodiscard]] constexpr _Ty bit_ceil(const _Ty _Val) noexcept   {
    if (_Val <= 1u) {
        return _Ty{1};
    }

    const int _Num = numeric_limits<_Ty>::digits - ::std:: countl_zero(static_cast<_Ty>(_Val - 1));

    if constexpr (sizeof(_Ty) < sizeof(unsigned int)) { 
        if (::std:: is_constant_evaluated()) {
            
            
            
            
            
            
            
            
            
            if (_Num == numeric_limits<_Ty>::digits) {
                _Precondition_violation_in_bit_ceil();
            }
        }
    }

    return static_cast<_Ty>(_Ty{1} << _Num);
}

 template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> = 0>
[[nodiscard]] constexpr _Ty bit_floor(const _Ty _Val) noexcept {
    if (_Val == 0) {
        return 0;
    }

    return static_cast<_Ty>(_Ty{1} << (numeric_limits<_Ty>::digits - 1 - ::std:: countl_zero(_Val)));
}

 template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> = 0>
[[nodiscard]] constexpr int bit_width(const _Ty _Val) noexcept {
    return numeric_limits<_Ty>::digits - ::std:: countl_zero(_Val);
}

 template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> = 0>
[[nodiscard]] constexpr _Ty rotr(_Ty _Val, int _Rotation) noexcept;

 template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> = 0>
[[nodiscard]] constexpr _Ty rotl(const _Ty _Val, const int _Rotation) noexcept {
    constexpr auto _Digits = numeric_limits<_Ty>::digits;

    if (!::std:: is_constant_evaluated()) {
        if constexpr (_Digits == 64) {
            return _rotl64(_Val, _Rotation);
        } else if constexpr (_Digits == 32) {
            return _rotl(_Val, _Rotation);
        } else if constexpr (_Digits == 16) {
            return _rotl16(_Val, static_cast<unsigned char>(_Rotation));
        } else {
             ;
            return _rotl8(_Val, static_cast<unsigned char>(_Rotation));
        }
    }

    const auto _Remainder = _Rotation % _Digits;
    if (_Remainder > 0) {
        return static_cast<_Ty>(
            static_cast<_Ty>(_Val << _Remainder) | static_cast<_Ty>(_Val >> (_Digits - _Remainder)));
    } else if (_Remainder == 0) {
        return _Val;
    } else { 
        return ::std:: rotr(_Val, -_Remainder);
    }
}

 template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> _Enabled>
[[nodiscard]] constexpr _Ty rotr(const _Ty _Val, const int _Rotation) noexcept {
    constexpr auto _Digits = numeric_limits<_Ty>::digits;

    if (!::std:: is_constant_evaluated()) {
        if constexpr (_Digits == 64) {
            return _rotr64(_Val, _Rotation);
        } else if constexpr (_Digits == 32) {
            return _rotr(_Val, _Rotation);
        } else if constexpr (_Digits == 16) {
            return _rotr16(_Val, static_cast<unsigned char>(_Rotation));
        } else {
             ;
            return _rotr8(_Val, static_cast<unsigned char>(_Rotation));
        }
    }

    const auto _Remainder = _Rotation % _Digits;
    if (_Remainder > 0) {
        return static_cast<_Ty>(
            static_cast<_Ty>(_Val >> _Remainder) | static_cast<_Ty>(_Val << (_Digits - _Remainder)));
    } else if (_Remainder == 0) {
        return _Val;
    } else { 
        return ::std:: rotl(_Val, -_Remainder);
    }
}



extern "C" {
extern int __isa_available;
}

template <class _Ty>
[[nodiscard]] int _Countl_zero_lzcnt(const _Ty _Val) noexcept {
    constexpr int _Digits = numeric_limits<_Ty>::digits;

    if constexpr (_Digits <= 16) {
        return static_cast<int>(__lzcnt16(_Val) - (16 - _Digits));
    } else if constexpr (_Digits == 32) {
        return static_cast<int>(__lzcnt(_Val));
    } else {









        return static_cast<int>(__lzcnt64(_Val));
#line 174 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\bit"
    }
}

template <class _Ty>
[[nodiscard]] int _Countl_zero_bsr(const _Ty _Val) noexcept {
    constexpr int _Digits = numeric_limits<_Ty>::digits;

    unsigned long _Result;
    if constexpr (_Digits <= 32) {
        if (!_BitScanReverse(&_Result, _Val)) {
            return _Digits;
        }
    } else {











        if (!_BitScanReverse64(&_Result, _Val)) {
            return _Digits;
        }
#line 202 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\bit"
    }
    return static_cast<int>(_Digits - 1 - _Result);
}

template <class _Ty>
[[nodiscard]] int _Checked_x86_x64_countl_zero(const _Ty _Val) noexcept {



    const bool _Definitely_have_lzcnt = __isa_available >= __ISA_AVAILABLE_AVX2;
    if (_Definitely_have_lzcnt) {
        return _Countl_zero_lzcnt(_Val);
    } else {
        return _Countl_zero_bsr(_Val);
    }
#line 218 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\bit"
}
#line 220 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\bit"










































#line 263 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\bit"



























#line 291 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\bit"

 template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> _Enabled>
[[nodiscard]] constexpr int countl_zero(const _Ty _Val) noexcept {

    if (!::std:: is_constant_evaluated()) {
        return _Checked_x86_x64_countl_zero(_Val);
    }




#line 303 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\bit"

    return _Countl_zero_fallback(_Val);
}

 template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> = 0>
[[nodiscard]] constexpr int countl_one(const _Ty _Val) noexcept {
    return ::std:: countl_zero(static_cast<_Ty>(~_Val));
}

 template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> = 0>
[[nodiscard]] constexpr int countr_zero(const _Ty _Val) noexcept {
    return _Countr_zero(_Val);
}

 template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> _Enabled = 0>
[[nodiscard]] constexpr int countr_one(const _Ty _Val) noexcept {
    return _Countr_zero(static_cast<_Ty>(~_Val));
}

 template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> = 0>
[[nodiscard]] constexpr int popcount(const _Ty _Val) noexcept {
    return _Popcount(_Val);
}
















#line 343 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\bit"

 enum class endian { little = 0, big = 1, native = little };

}


#pragma warning(pop)
#pragma pack(pop)
#line 352 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\bit"
#line 353 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\bit"
#line 354 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\bit"
#pragma external_header(pop)
#line 17 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\compare"



#line 21 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\compare"

#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




namespace std {
using _Literal_zero = decltype(nullptr);
using _Compare_t    = signed char;


enum class _Compare_eq : _Compare_t { equal = 0, equivalent = equal };
enum class _Compare_ord : _Compare_t { less = -1, greater = 1 };
enum class _Compare_ncmp : _Compare_t { unordered = -128 };

 struct partial_ordering {
    static const partial_ordering less;
    static const partial_ordering equivalent;
    static const partial_ordering greater;
    static const partial_ordering unordered;

    [[nodiscard]] friend constexpr bool operator==(const partial_ordering _Val, _Literal_zero) noexcept {
        return _Val._Value == 0;
    }

    [[nodiscard]] friend constexpr bool operator==(partial_ordering, partial_ordering) noexcept = default;

    [[nodiscard]] friend constexpr bool operator<(const partial_ordering _Val, _Literal_zero) noexcept {
        return _Val._Value == static_cast<_Compare_t>(_Compare_ord::less);
    }

    [[nodiscard]] friend constexpr bool operator>(const partial_ordering _Val, _Literal_zero) noexcept {
        return _Val._Value > 0;
    }

    [[nodiscard]] friend constexpr bool operator<=(const partial_ordering _Val, _Literal_zero) noexcept {
        
        
        
        return static_cast<signed char>(0 - static_cast<unsigned int>(_Val._Value)) >= 0;
    }

    [[nodiscard]] friend constexpr bool operator>=(const partial_ordering _Val, _Literal_zero) noexcept {
        return _Val._Value >= 0;
    }

    [[nodiscard]] friend constexpr bool operator<(_Literal_zero, const partial_ordering _Val) noexcept {
        return _Val > 0;
    }

    [[nodiscard]] friend constexpr bool operator>(_Literal_zero, const partial_ordering _Val) noexcept {
        return _Val < 0;
    }

    [[nodiscard]] friend constexpr bool operator<=(_Literal_zero, const partial_ordering _Val) noexcept {
        return _Val >= 0;
    }

    [[nodiscard]] friend constexpr bool operator>=(_Literal_zero, const partial_ordering _Val) noexcept {
        return _Val <= 0;
    }

    [[nodiscard]] friend constexpr partial_ordering operator<=>(const partial_ordering _Val, _Literal_zero) noexcept {
        return _Val;
    }

    [[nodiscard]] friend constexpr partial_ordering operator<=>(_Literal_zero, const partial_ordering _Val) noexcept {
        
        
        
        return {static_cast<_Compare_t>(0 - static_cast<unsigned int>(_Val._Value))};
    }

    _Compare_t _Value;
};

inline constexpr partial_ordering partial_ordering::less{static_cast<_Compare_t>(_Compare_ord::less)};
inline constexpr partial_ordering partial_ordering::equivalent{static_cast<_Compare_t>(_Compare_eq::equivalent)};
inline constexpr partial_ordering partial_ordering::greater{static_cast<_Compare_t>(_Compare_ord::greater)};
inline constexpr partial_ordering partial_ordering::unordered{static_cast<_Compare_t>(_Compare_ncmp::unordered)};

 struct weak_ordering {
    static const weak_ordering less;
    static const weak_ordering equivalent;
    static const weak_ordering greater;

    constexpr operator partial_ordering() const noexcept {
        return {static_cast<_Compare_t>(_Value)};
    }

    [[nodiscard]] friend constexpr bool operator==(const weak_ordering _Val, _Literal_zero) noexcept {
        return _Val._Value == 0;
    }

    [[nodiscard]] friend constexpr bool operator==(weak_ordering, weak_ordering) noexcept = default;

    [[nodiscard]] friend constexpr bool operator<(const weak_ordering _Val, _Literal_zero) noexcept {
        return _Val._Value < 0;
    }

    [[nodiscard]] friend constexpr bool operator>(const weak_ordering _Val, _Literal_zero) noexcept {
        return _Val._Value > 0;
    }

    [[nodiscard]] friend constexpr bool operator<=(const weak_ordering _Val, _Literal_zero) noexcept {
        return _Val._Value <= 0;
    }

    [[nodiscard]] friend constexpr bool operator>=(const weak_ordering _Val, _Literal_zero) noexcept {
        return _Val._Value >= 0;
    }

    [[nodiscard]] friend constexpr bool operator<(_Literal_zero, const weak_ordering _Val) noexcept {
        return _Val > 0;
    }

    [[nodiscard]] friend constexpr bool operator>(_Literal_zero, const weak_ordering _Val) noexcept {
        return _Val < 0;
    }

    [[nodiscard]] friend constexpr bool operator<=(_Literal_zero, const weak_ordering _Val) noexcept {
        return _Val >= 0;
    }

    [[nodiscard]] friend constexpr bool operator>=(_Literal_zero, const weak_ordering _Val) noexcept {
        return _Val <= 0;
    }

    [[nodiscard]] friend constexpr weak_ordering operator<=>(const weak_ordering _Val, _Literal_zero) noexcept {
        return _Val;
    }

    [[nodiscard]] friend constexpr weak_ordering operator<=>(_Literal_zero, const weak_ordering _Val) noexcept {
        return {static_cast<_Compare_t>(-_Val._Value)};
    }

    _Compare_t _Value;
};

inline constexpr weak_ordering weak_ordering::less{static_cast<_Compare_t>(_Compare_ord::less)};
inline constexpr weak_ordering weak_ordering::equivalent{static_cast<_Compare_t>(_Compare_eq::equivalent)};
inline constexpr weak_ordering weak_ordering::greater{static_cast<_Compare_t>(_Compare_ord::greater)};

 struct strong_ordering {
    static const strong_ordering less;
    static const strong_ordering equal;
    static const strong_ordering equivalent;
    static const strong_ordering greater;

    constexpr operator partial_ordering() const noexcept {
        return {static_cast<_Compare_t>(_Value)};
    }

    constexpr operator weak_ordering() const noexcept {
        return {static_cast<_Compare_t>(_Value)};
    }

    [[nodiscard]] friend constexpr bool operator==(const strong_ordering _Val, _Literal_zero) noexcept {
        return _Val._Value == 0;
    }

    [[nodiscard]] friend constexpr bool operator==(strong_ordering, strong_ordering) noexcept = default;

    [[nodiscard]] friend constexpr bool operator<(const strong_ordering _Val, _Literal_zero) noexcept {
        return _Val._Value < 0;
    }

    [[nodiscard]] friend constexpr bool operator>(const strong_ordering _Val, _Literal_zero) noexcept {
        return _Val._Value > 0;
    }

    [[nodiscard]] friend constexpr bool operator<=(const strong_ordering _Val, _Literal_zero) noexcept {
        return _Val._Value <= 0;
    }

    [[nodiscard]] friend constexpr bool operator>=(const strong_ordering _Val, _Literal_zero) noexcept {
        return _Val._Value >= 0;
    }

    [[nodiscard]] friend constexpr bool operator<(_Literal_zero, const strong_ordering _Val) noexcept {
        return _Val > 0;
    }

    [[nodiscard]] friend constexpr bool operator>(_Literal_zero, const strong_ordering _Val) noexcept {
        return _Val < 0;
    }

    [[nodiscard]] friend constexpr bool operator<=(_Literal_zero, const strong_ordering _Val) noexcept {
        return _Val >= 0;
    }

    [[nodiscard]] friend constexpr bool operator>=(_Literal_zero, const strong_ordering _Val) noexcept {
        return _Val <= 0;
    }

    [[nodiscard]] friend constexpr strong_ordering operator<=>(const strong_ordering _Val, _Literal_zero) noexcept {
        return _Val;
    }

    [[nodiscard]] friend constexpr strong_ordering operator<=>(_Literal_zero, const strong_ordering _Val) noexcept {
        return {static_cast<_Compare_t>(-_Val._Value)};
    }

    _Compare_t _Value;
};

inline constexpr strong_ordering strong_ordering::less{static_cast<_Compare_t>(_Compare_ord::less)};
inline constexpr strong_ordering strong_ordering::equal{static_cast<_Compare_t>(_Compare_eq::equal)};
inline constexpr strong_ordering strong_ordering::equivalent{static_cast<_Compare_t>(_Compare_eq::equivalent)};
inline constexpr strong_ordering strong_ordering::greater{static_cast<_Compare_t>(_Compare_ord::greater)};

 [[nodiscard]] constexpr bool is_eq(const partial_ordering _Comp) noexcept {
    return _Comp == 0;
}

 [[nodiscard]] constexpr bool is_neq(const partial_ordering _Comp) noexcept {
    return _Comp != 0;
}

 [[nodiscard]] constexpr bool is_lt(const partial_ordering _Comp) noexcept {
    return _Comp < 0;
}

 [[nodiscard]] constexpr bool is_lteq(const partial_ordering _Comp) noexcept {
    return _Comp <= 0;
}

 [[nodiscard]] constexpr bool is_gt(const partial_ordering _Comp) noexcept {
    return _Comp > 0;
}

 [[nodiscard]] constexpr bool is_gteq(const partial_ordering _Comp) noexcept {
    return _Comp >= 0;
}

enum _Comparison_category : unsigned char {
    _Comparison_category_none    = 1,
    _Comparison_category_partial = 2,
    _Comparison_category_weak    = 4,
    _Comparison_category_strong  = 0,
};

template <class... _Types>
inline constexpr unsigned char _Classify_category =
    _Comparison_category{(_Classify_category<_Types> | ... | _Comparison_category_strong)};
template <class _Ty>
inline constexpr unsigned char _Classify_category<_Ty> = _Comparison_category_none;
template <>
inline constexpr unsigned char _Classify_category<partial_ordering> = _Comparison_category_partial;
template <>
inline constexpr unsigned char _Classify_category<weak_ordering> = _Comparison_category_weak;
template <>
inline constexpr unsigned char _Classify_category<strong_ordering> = _Comparison_category_strong;

 template <class... _Types>
using common_comparison_category_t =
    conditional_t<(_Classify_category<_Types...> & _Comparison_category_none) != 0, void,
        conditional_t<(_Classify_category<_Types...> & _Comparison_category_partial) != 0, partial_ordering,
            conditional_t<(_Classify_category<_Types...> & _Comparison_category_weak) != 0, weak_ordering,
                strong_ordering>>>;

 template <class... _Types>
struct common_comparison_category {
    using type = common_comparison_category_t<_Types...>;
};


template <class _Ty, class _Cat>
concept _Compares_as = same_as<common_comparison_category_t<_Ty, _Cat>, _Cat>;

 template <class _Ty, class _Cat = partial_ordering>
concept three_way_comparable = _Half_equality_comparable<_Ty, _Ty> && _Half_ordered<_Ty, _Ty>
                            && requires(const remove_reference_t<_Ty>& __a, const remove_reference_t<_Ty>& __b) {
                                   { __a <=> __b } -> _Compares_as<_Cat>;
                               };

 template <class _Ty1, class _Ty2, class _Cat = partial_ordering>
concept three_way_comparable_with =
    three_way_comparable<_Ty1, _Cat> && three_way_comparable<_Ty2, _Cat>


#line 305 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\compare"
    && common_reference_with<const remove_reference_t<_Ty1>&, const remove_reference_t<_Ty2>&>
#line 307 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\compare"
    && three_way_comparable<common_reference_t<const remove_reference_t<_Ty1>&, const remove_reference_t<_Ty2>&>, _Cat>
    && _Weakly_equality_comparable_with<_Ty1, _Ty2> && _Partially_ordered_with<_Ty1, _Ty2>
    && requires(const remove_reference_t<_Ty1>& __t, const remove_reference_t<_Ty2>& __u) {
           { __t <=> __u } -> _Compares_as<_Cat>;
           { __u <=> __t } -> _Compares_as<_Cat>;
       };

 template <class _Ty1, class _Ty2 = _Ty1>
using compare_three_way_result_t =
    decltype(::std:: declval<const remove_reference_t<_Ty1>&>() <=> ::std:: declval<const remove_reference_t<_Ty2>&>());

 template <class _Ty1, class _Ty2 = _Ty1>
struct compare_three_way_result {};

template <class _Ty1, class _Ty2>
    requires requires { typename compare_three_way_result_t<_Ty1, _Ty2>; }
struct compare_three_way_result<_Ty1, _Ty2> {
    using type = compare_three_way_result_t<_Ty1, _Ty2>;
};

 struct compare_three_way {
    template <class _Ty1, class _Ty2>
        requires three_way_comparable_with<_Ty1, _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(::std:: forward<_Ty1>(_Left) <=> ::std:: forward<_Ty2>(_Right)))   {
        return ::std:: forward<_Ty1>(_Left) <=> ::std:: forward<_Ty2>(_Right);
    }

    using is_transparent = int;
};

struct _Synth_three_way {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(const _Ty1& _Left, const _Ty2& _Right) const
        requires requires {
                     { _Left < _Right } -> _Boolean_testable;
                     { _Right < _Left } -> _Boolean_testable;
                 }
    {
        if constexpr (three_way_comparable_with<_Ty1, _Ty2>) {
            return _Left <=> _Right;
        } else {
            if (_Left < _Right) {
                return weak_ordering::less;
            } else if (_Right < _Left) {
                return weak_ordering::greater;
            } else {
                return weak_ordering::equivalent;
            }
        }
    }
};

template <class _Ty1, class _Ty2 = _Ty1>
using _Synth_three_way_result = decltype(_Synth_three_way{}(::std:: declval<_Ty1&>(), ::std:: declval<_Ty2&>()));



namespace _Strong_order {


#line 369 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\compare"
    void strong_order();
#line 371 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\compare"

    template <class _Ty1, class _Ty2>
    concept _Has_ADL = requires(_Ty1& _Left, _Ty2& _Right) {
                           static_cast<strong_ordering>(strong_order(_Left, _Right)); 
                       };

    template <class _Ty1, class _Ty2>
    concept _Can_compare_three_way =
        requires(_Ty1& _Left, _Ty2& _Right) { static_cast<strong_ordering>(compare_three_way{}(_Left, _Right)); };

    class _Cpo {
    private:
        enum class _St { _None, _Adl, _Floating, _Three };

        template <class _Ty1, class _Ty2>
        [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
            if constexpr (!same_as<decay_t<_Ty1>, decay_t<_Ty2>>) {
                return {_St::_None};
            } else if constexpr (_Has_ADL<_Ty1, _Ty2>) {
                return {_St::_Adl, noexcept(static_cast<strong_ordering>(
                                       strong_order(::std:: declval<_Ty1&>(), ::std:: declval<_Ty2&>())))}; 
            } else if constexpr (floating_point<decay_t<_Ty1>>) {
                return {_St::_Floating, true};
            } else if constexpr (_Can_compare_three_way<_Ty1, _Ty2>) {
                return {_St::_Three, noexcept(static_cast<strong_ordering>(
                                         compare_three_way{}(::std:: declval<_Ty1&>(), ::std:: declval<_Ty2&>())))};
            } else {
                return {_St::_None};
            }
        }

        template <class _Ty1, class _Ty2>
        static constexpr _Choice_t<_St> _Choice = _Choose<_Ty1, _Ty2>();

    public:
        template <class _Ty1, class _Ty2>
            requires (_Choice<_Ty1&, _Ty2&>._Strategy != _St::_None)
        [[nodiscard]] constexpr strong_ordering operator()(_Ty1&& _Left, _Ty2&& _Right) const
            noexcept(_Choice<_Ty1&, _Ty2&>._No_throw) {
            constexpr _St _Strat = _Choice<_Ty1&, _Ty2&>._Strategy;
            if constexpr (_Strat == _St::_Adl) {
                return static_cast<strong_ordering>(strong_order(_Left, _Right)); 
            } else if constexpr (_Strat == _St::_Floating) {
                using _Floating_type = decay_t<_Ty1>;
                using _Traits        = _Floating_type_traits<_Floating_type>;
                using _Uint_type     = typename _Traits::_Uint_type;
                using _Sint_type     = make_signed_t<_Uint_type>;

                const auto _Left_uint  = ::std:: bit_cast<_Uint_type>(_Left);
                const auto _Right_uint = ::std:: bit_cast<_Uint_type>(_Right);

                
                if (_Left_uint == _Right_uint) {
                    return strong_ordering::equal;
                }

                
                const _Uint_type _Left_shifted_sign  = _Left_uint & _Traits::_Shifted_sign_mask;
                const _Uint_type _Right_shifted_sign = _Right_uint & _Traits::_Shifted_sign_mask;

                
                
                
                const _Uint_type _Left_sign  = _Left_shifted_sign >> _Traits::_Sign_shift;
                const _Uint_type _Right_sign = _Right_shifted_sign >> _Traits::_Sign_shift;

                const _Uint_type _Left_xor  = _Left_shifted_sign - _Left_sign;
                const _Uint_type _Right_xor = _Right_shifted_sign - _Right_sign;

                const _Uint_type _Left_ones_complement_uint  = _Left_uint ^ _Left_xor;
                const _Uint_type _Right_ones_complement_uint = _Right_uint ^ _Right_xor;

                const auto _Left_ones_complement  = static_cast<_Sint_type>(_Left_ones_complement_uint);
                const auto _Right_ones_complement = static_cast<_Sint_type>(_Right_ones_complement_uint);

                
                return _Left_ones_complement <=> _Right_ones_complement;
            } else if constexpr (_Strat == _St::_Three) {
                return static_cast<strong_ordering>(compare_three_way{}(_Left, _Right));
            } else {
                static_assert(_Always_false<_Ty1>, "should be unreachable");
            }
        }
    };
} 

inline namespace _Cpos {
     inline constexpr _Strong_order::_Cpo strong_order;
}

namespace _Weak_order {


#line 465 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\compare"
    void weak_order();
#line 467 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\compare"

    template <class _Ty1, class _Ty2>
    concept _Has_ADL = requires(_Ty1& _Left, _Ty2& _Right) {
                           static_cast<weak_ordering>(weak_order(_Left, _Right)); 
                       };

    template <class _Ty1, class _Ty2>
    concept _Can_compare_three_way =
        requires(_Ty1& _Left, _Ty2& _Right) { static_cast<weak_ordering>(compare_three_way{}(_Left, _Right)); };

    


#line 481 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\compare"
    void strong_order();
#line 483 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\compare"

    class _Cpo {
    private:
        enum class _St { _None, _Adl, _Floating, _Three, _Strong };

        template <class _Ty1, class _Ty2>
        [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
            if constexpr (!same_as<decay_t<_Ty1>, decay_t<_Ty2>>) {
                return {_St::_None};
            } else if constexpr (_Has_ADL<_Ty1, _Ty2>) {
                return {_St::_Adl, noexcept(static_cast<weak_ordering>(
                                       weak_order(::std:: declval<_Ty1&>(), ::std:: declval<_Ty2&>())))}; 
            } else if constexpr (floating_point<decay_t<_Ty1>>) {
                return {_St::_Floating, true};
            } else if constexpr (_Can_compare_three_way<_Ty1, _Ty2>) {
                return {_St::_Three, noexcept(static_cast<weak_ordering>(
                                         compare_three_way{}(::std:: declval<_Ty1&>(), ::std:: declval<_Ty2&>())))};
            } else if constexpr (_Strong_order::_Has_ADL<_Ty1, _Ty2>) {
                
                return {_St::_Strong, noexcept(static_cast<weak_ordering>(static_cast<strong_ordering>(strong_order(
                                          ::std:: declval<_Ty1&>(), ::std:: declval<_Ty2&>()))))}; 
            } else {
                return {_St::_None};
            }
        }

        template <class _Ty1, class _Ty2>
        static constexpr _Choice_t<_St> _Choice = _Choose<_Ty1, _Ty2>();

    public:
        template <class _Ty1, class _Ty2>
            requires (_Choice<_Ty1&, _Ty2&>._Strategy != _St::_None)
        [[nodiscard]] constexpr weak_ordering operator()(_Ty1&& _Left, _Ty2&& _Right) const
            noexcept(_Choice<_Ty1&, _Ty2&>._No_throw) {
            constexpr _St _Strat = _Choice<_Ty1&, _Ty2&>._Strategy;
            if constexpr (_Strat == _St::_Adl) {
                return static_cast<weak_ordering>(weak_order(_Left, _Right)); 
            } else if constexpr (_Strat == _St::_Floating) {
                using _Floating_type = decay_t<_Ty1>;
                using _Traits        = _Floating_type_traits<_Floating_type>;
                using _Uint_type     = typename _Traits::_Uint_type;
                using _Sint_type     = make_signed_t<_Uint_type>;

                auto _Left_uint  = ::std:: bit_cast<_Uint_type>(_Left);
                auto _Right_uint = ::std:: bit_cast<_Uint_type>(_Right);

                
                if (_Left_uint == _Right_uint) {
                    return weak_ordering::equivalent;
                }

                
                const _Uint_type _Left_shifted_sign  = _Left_uint & _Traits::_Shifted_sign_mask;
                const _Uint_type _Right_shifted_sign = _Right_uint & _Traits::_Shifted_sign_mask;

                
                
                constexpr _Uint_type _Infinity_plus_one = _Traits::_Shifted_exponent_mask + 1;

                const _Uint_type _Left_magnitude  = _Left_uint & ~_Traits::_Shifted_sign_mask;
                const _Uint_type _Right_magnitude = _Right_uint & ~_Traits::_Shifted_sign_mask;

                if (_Left_magnitude > _Infinity_plus_one) {
                    _Left_uint = _Left_shifted_sign | _Infinity_plus_one;
                }

                if (_Right_magnitude > _Infinity_plus_one) {
                    _Right_uint = _Right_shifted_sign | _Infinity_plus_one;
                }

                
                
                
                const _Uint_type _Left_sign  = _Left_shifted_sign >> _Traits::_Sign_shift;
                const _Uint_type _Right_sign = _Right_shifted_sign >> _Traits::_Sign_shift;

                const _Uint_type _Left_xor  = _Left_shifted_sign - _Left_sign;
                const _Uint_type _Right_xor = _Right_shifted_sign - _Right_sign;

                const _Uint_type _Left_twos_complement_uint  = (_Left_uint ^ _Left_xor) + _Left_sign;
                const _Uint_type _Right_twos_complement_uint = (_Right_uint ^ _Right_xor) + _Right_sign;

                const auto _Left_twos_complement  = static_cast<_Sint_type>(_Left_twos_complement_uint);
                const auto _Right_twos_complement = static_cast<_Sint_type>(_Right_twos_complement_uint);

                
                return static_cast<weak_ordering>(_Left_twos_complement <=> _Right_twos_complement);
            } else if constexpr (_Strat == _St::_Three) {
                return static_cast<weak_ordering>(compare_three_way{}(_Left, _Right));
            } else if constexpr (_Strat == _St::_Strong) {
                
                return static_cast<weak_ordering>(
                    static_cast<strong_ordering>(strong_order(_Left, _Right))); 
            } else {
                static_assert(_Always_false<_Ty1>, "should be unreachable");
            }
        }
    };
} 

inline namespace _Cpos {
     inline constexpr _Weak_order::_Cpo weak_order;
}

namespace _Partial_order {


#line 591 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\compare"
    void partial_order();
#line 593 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\compare"

    template <class _Ty1, class _Ty2>
    concept _Has_ADL = requires(_Ty1& _Left, _Ty2& _Right) {
                           static_cast<partial_ordering>(partial_order(_Left, _Right)); 
                       };

    template <class _Ty1, class _Ty2>
    concept _Can_compare_three_way =
        requires(_Ty1& _Left, _Ty2& _Right) { static_cast<partial_ordering>(compare_three_way{}(_Left, _Right)); };

    
    



#line 609 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\compare"
    void weak_order();
    void strong_order();
#line 612 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\compare"

    class _Cpo {
    private:
        enum class _St { _None, _Adl, _Three, _Weak, _Strong };

        template <class _Ty1, class _Ty2>
        [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
            if constexpr (!same_as<decay_t<_Ty1>, decay_t<_Ty2>>) {
                return {_St::_None};
            } else if constexpr (_Has_ADL<_Ty1, _Ty2>) {
                return {_St::_Adl, noexcept(static_cast<partial_ordering>(partial_order(
                                       ::std:: declval<_Ty1&>(), ::std:: declval<_Ty2&>())))}; 
            } else if constexpr (_Can_compare_three_way<_Ty1, _Ty2>) {
                return {_St::_Three, noexcept(static_cast<partial_ordering>(
                                         compare_three_way{}(::std:: declval<_Ty1&>(), ::std:: declval<_Ty2&>())))};
            } else if constexpr (_Weak_order::_Has_ADL<_Ty1, _Ty2>) {
                
                return {_St::_Weak, noexcept(static_cast<partial_ordering>(static_cast<weak_ordering>(
                                        weak_order(::std:: declval<_Ty1&>(), ::std:: declval<_Ty2&>()))))}; 
            } else if constexpr (_Strong_order::_Has_ADL<_Ty1, _Ty2>) {
                
                return {_St::_Strong, noexcept(static_cast<partial_ordering>(static_cast<strong_ordering>(strong_order(
                                          ::std:: declval<_Ty1&>(), ::std:: declval<_Ty2&>()))))}; 
            } else {
                return {_St::_None};
            }
        }

        template <class _Ty1, class _Ty2>
        static constexpr _Choice_t<_St> _Choice = _Choose<_Ty1, _Ty2>();

    public:
        template <class _Ty1, class _Ty2>
            requires (_Choice<_Ty1&, _Ty2&>._Strategy != _St::_None)
        [[nodiscard]] constexpr partial_ordering operator()(_Ty1&& _Left, _Ty2&& _Right) const
            noexcept(_Choice<_Ty1&, _Ty2&>._No_throw) {
            constexpr _St _Strat = _Choice<_Ty1&, _Ty2&>._Strategy;
            if constexpr (_Strat == _St::_Adl) {
                return static_cast<partial_ordering>(  partial_order(_Left, _Right));
            } else if constexpr (_Strat == _St::_Three) {
                return static_cast<partial_ordering>(compare_three_way{}(_Left, _Right));
            } else if constexpr (_Strat == _St::_Weak) {
                
                return static_cast<partial_ordering>(
                    static_cast<weak_ordering>(weak_order(_Left, _Right))); 
            } else if constexpr (_Strat == _St::_Strong) {
                
                return static_cast<partial_ordering>(
                    static_cast<strong_ordering>(strong_order(_Left, _Right))); 
            } else {
                static_assert(_Always_false<_Ty1>, "should be unreachable");
            }
        }
    };
} 

inline namespace _Cpos {
     inline constexpr _Partial_order::_Cpo partial_order;
}

template <class _Ty1, class _Ty2>
concept _Can_fallback_eq_lt = requires(_Ty1& _Left, _Ty2& _Right) {
                                  { _Left == _Right } -> _Boolean_testable;
                                  { _Left < _Right } -> _Boolean_testable;
                              };

template <class _Ty1, class _Ty2>
concept _Can_strong_order = requires(_Ty1& _Left, _Ty2& _Right) { ::std:: strong_order(_Left, _Right); };

namespace _Compare_strong_order_fallback {
    class _Cpo {
    private:
        enum class _St { _None, _Strong, _Fallback };

        template <class _Ty1, class _Ty2>
        [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
            if constexpr (!same_as<decay_t<_Ty1>, decay_t<_Ty2>>) {
                return {_St::_None};
            } else if constexpr (_Can_strong_order<_Ty1, _Ty2>) {
                return {_St::_Strong, noexcept(::std:: strong_order(::std:: declval<_Ty1&>(), ::std:: declval<_Ty2&>()))};
            } else if constexpr (_Can_fallback_eq_lt<_Ty1, _Ty2>) {
                return {_St::_Fallback,
                    noexcept(::std:: declval<_Ty1&>() == ::std:: declval<_Ty2&>()  ? strong_ordering::equal
                             : ::std:: declval<_Ty1&>() < ::std:: declval<_Ty2&>() ? strong_ordering::less
                                                                             : strong_ordering::greater)};
            } else {
                return {_St::_None};
            }
        }

        template <class _Ty1, class _Ty2>
        static constexpr _Choice_t<_St> _Choice = _Choose<_Ty1, _Ty2>();

    public:
        template <class _Ty1, class _Ty2>
            requires (_Choice<_Ty1&, _Ty2&>._Strategy != _St::_None)
        [[nodiscard]] constexpr strong_ordering operator()(_Ty1&& _Left, _Ty2&& _Right) const
            noexcept(_Choice<_Ty1&, _Ty2&>._No_throw) {
            constexpr _St _Strat = _Choice<_Ty1&, _Ty2&>._Strategy;
            if constexpr (_Strat == _St::_Strong) {
                return ::std:: strong_order(_Left, _Right);
            } else if constexpr (_Strat == _St::_Fallback) {
                return _Left == _Right ? strong_ordering::equal
                     : _Left < _Right  ? strong_ordering::less
                                       : strong_ordering::greater;
            } else {
                static_assert(_Always_false<_Ty1>, "should be unreachable");
            }
        }
    };
} 

inline namespace _Cpos {
     inline constexpr _Compare_strong_order_fallback::_Cpo compare_strong_order_fallback;
}

template <class _Ty1, class _Ty2>
concept _Can_weak_order = requires(_Ty1& _Left, _Ty2& _Right) { ::std:: weak_order(_Left, _Right); };

namespace _Compare_weak_order_fallback {
    class _Cpo {
    private:
        enum class _St { _None, _Weak, _Fallback };

        template <class _Ty1, class _Ty2>
        [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
            if constexpr (!same_as<decay_t<_Ty1>, decay_t<_Ty2>>) {
                return {_St::_None};
            } else if constexpr (_Can_weak_order<_Ty1, _Ty2>) {
                return {_St::_Weak, noexcept(::std:: weak_order(::std:: declval<_Ty1&>(), ::std:: declval<_Ty2&>()))};
            } else if constexpr (_Can_fallback_eq_lt<_Ty1, _Ty2>) {
                return {
                    _St::_Fallback, noexcept(::std:: declval<_Ty1&>() == ::std:: declval<_Ty2&>()  ? weak_ordering::equivalent
                                             : ::std:: declval<_Ty1&>() < ::std:: declval<_Ty2&>() ? weak_ordering::less
                                                                                             : weak_ordering::greater)};
            } else {
                return {_St::_None};
            }
        }

        template <class _Ty1, class _Ty2>
        static constexpr _Choice_t<_St> _Choice = _Choose<_Ty1, _Ty2>();

    public:
        template <class _Ty1, class _Ty2>
            requires (_Choice<_Ty1&, _Ty2&>._Strategy != _St::_None)
        [[nodiscard]] constexpr weak_ordering operator()(_Ty1&& _Left, _Ty2&& _Right) const
            noexcept(_Choice<_Ty1&, _Ty2&>._No_throw) {
            constexpr _St _Strat = _Choice<_Ty1&, _Ty2&>._Strategy;
            if constexpr (_Strat == _St::_Weak) {
                return ::std:: weak_order(_Left, _Right);
            } else if constexpr (_Strat == _St::_Fallback) {
                return _Left == _Right ? weak_ordering::equivalent
                     : _Left < _Right  ? weak_ordering::less
                                       : weak_ordering::greater;
            } else {
                static_assert(_Always_false<_Ty1>, "should be unreachable");
            }
        }
    };
} 

inline namespace _Cpos {
     inline constexpr _Compare_weak_order_fallback::_Cpo compare_weak_order_fallback;
}

template <class _Ty1, class _Ty2>
concept _Can_partial_order = requires(_Ty1& _Left, _Ty2& _Right) { ::std:: partial_order(_Left, _Right); };

namespace _Compare_partial_order_fallback {
    template <class _Ty1, class _Ty2>
    concept _Can_fallback_eq_lt_twice = requires(_Ty1& _Left, _Ty2& _Right) {
                                            { _Left == _Right } -> _Boolean_testable;
                                            { _Left < _Right } -> _Boolean_testable;
                                            { _Right < _Left } -> _Boolean_testable;
                                        };

    class _Cpo {
    private:
        enum class _St { _None, _Partial, _Fallback };

        template <class _Ty1, class _Ty2>
        [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
            if constexpr (!same_as<decay_t<_Ty1>, decay_t<_Ty2>>) {
                return {_St::_None};
            } else if constexpr (_Can_partial_order<_Ty1, _Ty2>) {
                return {_St::_Partial, noexcept(::std:: partial_order(::std:: declval<_Ty1&>(), ::std:: declval<_Ty2&>()))};
            } else if constexpr (_Can_fallback_eq_lt_twice<_Ty1, _Ty2>) {
                return {_St::_Fallback,
                    noexcept(::std:: declval<_Ty1&>() == ::std:: declval<_Ty2&>()  ? partial_ordering::equivalent
                             : ::std:: declval<_Ty1&>() < ::std:: declval<_Ty2&>() ? partial_ordering::less
                             : ::std:: declval<_Ty2&>() < ::std:: declval<_Ty1&>() ? partial_ordering::greater
                                                                             : partial_ordering::unordered)};
            } else {
                return {_St::_None};
            }
        }

        template <class _Ty1, class _Ty2>
        static constexpr _Choice_t<_St> _Choice = _Choose<_Ty1, _Ty2>();

    public:
        template <class _Ty1, class _Ty2>
            requires (_Choice<_Ty1&, _Ty2&>._Strategy != _St::_None)
        [[nodiscard]] constexpr partial_ordering operator()(_Ty1&& _Left, _Ty2&& _Right) const
            noexcept(_Choice<_Ty1&, _Ty2&>._No_throw) {
            constexpr _St _Strat = _Choice<_Ty1&, _Ty2&>._Strategy;
            if constexpr (_Strat == _St::_Partial) {
                return ::std:: partial_order(_Left, _Right);
            } else if constexpr (_Strat == _St::_Fallback) {
                return _Left == _Right ? partial_ordering::equivalent
                     : _Left < _Right  ? partial_ordering::less
                     : _Right < _Left  ? partial_ordering::greater
                                       : partial_ordering::unordered;
            } else {
                static_assert(_Always_false<_Ty1>, "should be unreachable");
            }
        }
    };
} 

inline namespace _Cpos {
     inline constexpr _Compare_partial_order_fallback::_Cpo compare_partial_order_fallback;
}

#line 838 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\compare"
}



#pragma warning(pop)
#pragma pack(pop)
#line 845 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\compare"

#line 847 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\compare"
#line 848 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\compare"
#pragma external_header(pop)
#line 20 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"
#line 21 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"

#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




namespace std {
 template <class _Ty, class _Pr>
[[nodiscard]] constexpr const _Ty&(max) (const _Ty& _Left, const _Ty& _Right, _Pr _Pred) noexcept(
    noexcept(_Pred(_Left, _Right)))   {
    
    return _Pred(_Left, _Right) ? _Right : _Left;
}

#pragma warning(push)
#pragma warning(disable : 28285) 
 template <class _Ty>
[[nodiscard]]  constexpr const _Ty& 
    (max) (const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Left < _Right))   {
    
    return _Left < _Right ? _Right : _Left;
}
#pragma warning(pop)

 template <class _Ty, class _Pr>
[[nodiscard]] constexpr _Ty(max)(initializer_list<_Ty>, _Pr); 

 template <class _Ty>
[[nodiscard]] constexpr _Ty(max)(initializer_list<_Ty>); 

 template <class _Ty, class _Pr>
[[nodiscard]] constexpr const _Ty&(min) (const _Ty& _Left, const _Ty& _Right, _Pr _Pred) noexcept(
    noexcept(_Pred(_Right, _Left)))   {
    
    return _Pred(_Right, _Left) ? _Right : _Left;
}

#pragma warning(push)
#pragma warning(disable : 28285) 
 template <class _Ty>
[[nodiscard]]  constexpr const _Ty& 
    (min) (const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Right < _Left))   {
    
    return _Right < _Left ? _Right : _Left;
}
#pragma warning(pop)

 template <class _Ty, class _Pr>
[[nodiscard]] constexpr _Ty(min)(initializer_list<_Ty>, _Pr); 

 template <class _Ty>
[[nodiscard]] constexpr _Ty(min)(initializer_list<_Ty>); 

 template <class _FwdIt1, class _FwdIt2>
constexpr void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right) { 
    swap(*_Left, *_Right);
}

 template <class _Ty, size_t _Size, enable_if_t<_Is_swappable<_Ty>::value, int> _Enabled>
constexpr void swap(_Ty (&_Left)[_Size], _Ty (&_Right)[_Size]) noexcept(_Is_nothrow_swappable<_Ty>::value) {
    if (&_Left != &_Right) {
        _Ty* _First1 = _Left;
        _Ty* _Last1  = _First1 + _Size;
        _Ty* _First2 = _Right;
        for (; _First1 != _Last1; ++_First1, ++_First2) {
            ::std:: iter_swap(_First1, _First2);
        }
    }
}


 template <class _Ty, enable_if_t<is_move_constructible_v<_Ty> && is_move_assignable_v<_Ty>, int> _Enabled>


#line 98 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"
constexpr void swap(_Ty& _Left, _Ty& _Right) noexcept(
    is_nothrow_move_constructible_v<_Ty>&& is_nothrow_move_assignable_v<_Ty>) {
    _Ty _Tmp = ::std:: move(_Left);
    _Left    = ::std:: move(_Right);
    _Right   = ::std:: move(_Tmp);
}

template <class _Ty>
constexpr void _Swap_adl(_Ty& _Left, _Ty& _Right) noexcept(_Is_nothrow_swappable<_Ty>::value) {
    swap(_Left, _Right);
}

 struct piecewise_construct_t { 
    explicit piecewise_construct_t() = default;
};

 inline constexpr piecewise_construct_t piecewise_construct{};

template <class _Ty, class _Alloc, class = void>
struct _Has_allocator_type : false_type {}; 

template <class _Ty, class _Alloc>
struct _Has_allocator_type<_Ty, _Alloc, void_t<typename _Ty::allocator_type>>
    : is_convertible<_Alloc, typename _Ty::allocator_type>::type {}; 

 struct allocator_arg_t { 
    explicit allocator_arg_t() = default;
};

 inline constexpr allocator_arg_t allocator_arg{};

 template <class _Ty, class _Alloc>
struct uses_allocator : _Has_allocator_type<_Ty, _Alloc>::type {
    
};

 template <class _Ty, class _Alloc>
inline constexpr bool uses_allocator_v = uses_allocator<_Ty, _Alloc>::value;

 template <class... _Types>
class tuple;

 template <class _Ty1, class _Ty2>
struct pair;

 template <class _Ty, size_t _Size>
class array;

 template <class _Tuple>
struct tuple_size;

 template <class _Ty>
inline constexpr size_t tuple_size_v = tuple_size<_Ty>::value;

 template <size_t _Index, class _Tuple>
struct tuple_element;

 template <size_t _Index, class _Tuple>
using tuple_element_t = typename tuple_element<_Index, _Tuple>::type;

   template <size_t _Index, class... _Types>
[[nodiscard]] constexpr auto&& _Tuple_get(tuple<_Types...>&& _Tuple) noexcept;

 template <size_t _Index, class... _Types>
[[nodiscard]] constexpr tuple_element_t<_Index, tuple<_Types...>>& get(tuple<_Types...>& _Tuple) noexcept;

 template <size_t _Index, class... _Types>
[[nodiscard]] constexpr const tuple_element_t<_Index, tuple<_Types...>>& get(const tuple<_Types...>& _Tuple) noexcept;

 template <size_t _Index, class... _Types>
[[nodiscard]] constexpr tuple_element_t<_Index, tuple<_Types...>>&& get(tuple<_Types...>&& _Tuple) noexcept;

 template <size_t _Index, class... _Types>
[[nodiscard]] constexpr const tuple_element_t<_Index, tuple<_Types...>>&& get(const tuple<_Types...>&& _Tuple) noexcept;

 template <size_t _Idx, class _Ty, size_t _Size>
[[nodiscard]] constexpr _Ty& get(array<_Ty, _Size>& _Arr) noexcept;

 template <size_t _Idx, class _Ty, size_t _Size>
[[nodiscard]] constexpr const _Ty& get(const array<_Ty, _Size>& _Arr) noexcept;

 template <size_t _Idx, class _Ty, size_t _Size>
[[nodiscard]] constexpr _Ty&& get(array<_Ty, _Size>&& _Arr) noexcept;

 template <size_t _Idx, class _Ty, size_t _Size>
[[nodiscard]] constexpr const _Ty&& get(const array<_Ty, _Size>&& _Arr) noexcept;


template <class _Ty1, class _Ty2>
concept _Different_from = (!same_as<remove_cvref_t<_Ty1>, remove_cvref_t<_Ty2>>);

template <class>
inline constexpr bool _Is_std_array_v = false;

template <class _Ty, size_t _Size>
inline constexpr bool _Is_std_array_v<array<_Ty, _Size>> = true;

template <class>
inline constexpr bool _Is_subrange_v = false;


















#line 216 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"
#line 217 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"

 template <class _Ty1, class _Ty2>
struct pair { 
    using first_type  = _Ty1;
    using second_type = _Ty2;

    template <class _Uty1 = _Ty1, class _Uty2 = _Ty2,
        enable_if_t<conjunction_v<is_default_constructible<_Uty1>, is_default_constructible<_Uty2>>, int> = 0>
    constexpr explicit(
        !conjunction_v<_Is_implicitly_default_constructible<_Uty1>, _Is_implicitly_default_constructible<_Uty2>>)
        pair() noexcept(
            is_nothrow_default_constructible_v<_Uty1>&& is_nothrow_default_constructible_v<_Uty2>) 
        : first(), second() {}

    template <class _Uty1 = _Ty1, class _Uty2 = _Ty2,
        enable_if_t<conjunction_v<is_copy_constructible<_Uty1>, is_copy_constructible<_Uty2>>, int> = 0>
    constexpr explicit(!conjunction_v<is_convertible<const _Uty1&, _Uty1>, is_convertible<const _Uty2&, _Uty2>>)
        pair(const _Ty1& _Val1, const _Ty2& _Val2) noexcept(
            is_nothrow_copy_constructible_v<_Uty1>&& is_nothrow_copy_constructible_v<_Uty2>) 
        : first(_Val1), second(_Val2) {}



#line 241 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"
    template <class _Other1, class _Other2,
#line 243 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"
        enable_if_t<conjunction_v<is_constructible<_Ty1, _Other1>, is_constructible<_Ty2, _Other2>>, int> = 0>
    constexpr explicit(!conjunction_v<is_convertible<_Other1, _Ty1>, is_convertible<_Other2, _Ty2>>)
        pair(_Other1&& _Val1, _Other2&& _Val2) noexcept(
            is_nothrow_constructible_v<_Ty1, _Other1>&& is_nothrow_constructible_v<_Ty2, _Other2>) 
        : first(::std:: forward<_Other1>(_Val1)), second(::std:: forward<_Other2>(_Val2)) {
    }

    pair(const pair&) = default;
    pair(pair&&)      = default;








#line 261 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"

    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<is_constructible<_Ty1, const _Other1&>, is_constructible<_Ty2, const _Other2&>>,
            int> = 0>
    constexpr explicit(!conjunction_v<is_convertible<const _Other1&, _Ty1>, is_convertible<const _Other2&, _Ty2>>)
        pair(const pair<_Other1, _Other2>& _Right) noexcept(is_nothrow_constructible_v<_Ty1, const _Other1&>&&
                is_nothrow_constructible_v<_Ty2, const _Other2&>) 
        : first(_Right.first), second(_Right.second) {}

    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<is_constructible<_Ty1, _Other1>, is_constructible<_Ty2, _Other2>>, int> = 0>
    constexpr explicit(!conjunction_v<is_convertible<_Other1, _Ty1>, is_convertible<_Other2, _Ty2>>)
        pair(pair<_Other1, _Other2>&& _Right) noexcept(
            is_nothrow_constructible_v<_Ty1, _Other1>&& is_nothrow_constructible_v<_Ty2, _Other2>) 
        : first(::std:: forward<_Other1>(_Right.first)), second(::std:: forward<_Other2>(_Right.second)) {}

























#line 302 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"

    template <class _Tuple1, class _Tuple2, size_t... _Indices1, size_t... _Indices2>
    constexpr pair(_Tuple1& _Val1, _Tuple2& _Val2, index_sequence<_Indices1...>, index_sequence<_Indices2...>)
        : first(_Tuple_get<_Indices1>(::std:: move(_Val1))...), second(_Tuple_get<_Indices2>(::std:: move(_Val2))...) {}

    template <class... _Types1, class... _Types2>
    constexpr pair(piecewise_construct_t, tuple<_Types1...> _Val1, tuple<_Types2...> _Val2)
        : pair(_Val1, _Val2, index_sequence_for<_Types1...>{}, index_sequence_for<_Types2...>{}) {}

    pair& operator=(const volatile pair&) = delete;

    template <class _Myself = pair,
        enable_if_t<conjunction_v<_Is_copy_assignable_no_precondition_check<typename _Myself::first_type>,
                        _Is_copy_assignable_no_precondition_check<typename _Myself::second_type>>,
            int>            = 0>
    constexpr pair& operator=(_Identity_t<const _Myself&> _Right) noexcept(
        conjunction_v<is_nothrow_copy_assignable<_Ty1>, is_nothrow_copy_assignable<_Ty2>>)   {
        first  = _Right.first;
        second = _Right.second;
        return *this;
    }













#line 337 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"

    template <class _Myself = pair,
        enable_if_t<conjunction_v<_Is_move_assignable_no_precondition_check<typename _Myself::first_type>,
                        _Is_move_assignable_no_precondition_check<typename _Myself::second_type>>,
            int>            = 0>
    constexpr pair& operator=(_Identity_t<_Myself&&> _Right) noexcept(
        conjunction_v<is_nothrow_move_assignable<_Ty1>, is_nothrow_move_assignable<_Ty2>>)   {
        first  = ::std:: forward<_Ty1>(_Right.first);
        second = ::std:: forward<_Ty2>(_Right.second);
        return *this;
    }













#line 362 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"

    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<negation<is_same<pair, pair<_Other1, _Other2>>>, is_assignable<_Ty1&, const _Other1&>,
                        is_assignable<_Ty2&, const _Other2&>>,
            int> = 0>
    constexpr pair& operator=(const pair<_Other1, _Other2>& _Right) noexcept(
        is_nothrow_assignable_v<_Ty1&, const _Other1&>&&
            is_nothrow_assignable_v<_Ty2&, const _Other2&>)   {
        first  = _Right.first;
        second = _Right.second;
        return *this;
    }













#line 388 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"

    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<negation<is_same<pair, pair<_Other1, _Other2>>>, is_assignable<_Ty1&, _Other1>,
                        is_assignable<_Ty2&, _Other2>>,
            int> = 0>
    constexpr pair& operator=(pair<_Other1, _Other2>&& _Right) noexcept(
        is_nothrow_assignable_v<_Ty1&, _Other1>&& is_nothrow_assignable_v<_Ty2&, _Other2>)   {
        first  = ::std:: forward<_Other1>(_Right.first);
        second = ::std:: forward<_Other2>(_Right.second);
        return *this;
    }







































#line 439 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"

    constexpr void swap(pair& _Right) noexcept(
        _Is_nothrow_swappable<_Ty1>::value&& _Is_nothrow_swappable<_Ty2>::value) {
        if (this != ::std:: addressof(_Right)) {
            _Swap_adl(first, _Right.first);
            _Swap_adl(second, _Right.second);
        }
    }










#line 458 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"

    _Ty1 first; 
    _Ty2 second; 
};


template <class _Ty1, class _Ty2>
pair(_Ty1, _Ty2) -> pair<_Ty1, _Ty2>;
#line 467 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"

 template <class _Ty1, class _Ty2,
    enable_if_t<_Is_swappable<_Ty1>::value && _Is_swappable<_Ty2>::value, int> = 0>
constexpr void swap(pair<_Ty1, _Ty2>& _Left, pair<_Ty1, _Ty2>& _Right) noexcept(noexcept(_Left.swap(_Right))) {
    _Left.swap(_Right);
}








#line 482 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"

 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool operator==(const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right) {
    return _Left.first == _Right.first && _Left.second == _Right.second;
}


 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr common_comparison_category_t<_Synth_three_way_result<_Ty1>, _Synth_three_way_result<_Ty2>>
    operator<=>(const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right) {
    if (auto _Result = _Synth_three_way{}(_Left.first, _Right.first); _Result != 0) {
        return _Result;
    }
    return _Synth_three_way{}(_Left.second, _Right.second);
}



























#line 525 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"


template <class _Ty1, class _Ty2, class _Uty1, class _Uty2, template <class> class _TQual,
    template <class> class _UQual>
    requires requires {
                 typename pair<common_reference_t<_TQual<_Ty1>, _UQual<_Uty1>>,
                     common_reference_t<_TQual<_Ty2>, _UQual<_Uty2>>>;
             }
struct basic_common_reference<pair<_Ty1, _Ty2>, pair<_Uty1, _Uty2>, _TQual, _UQual> {
    using type = pair<common_reference_t<_TQual<_Ty1>, _UQual<_Uty1>>, common_reference_t<_TQual<_Ty2>, _UQual<_Uty2>>>;
};

template <class _Ty1, class _Ty2, class _Uty1, class _Uty2>
    requires requires { typename pair<common_type_t<_Ty1, _Uty1>, common_type_t<_Ty2, _Uty2>>; }
struct common_type<pair<_Ty1, _Ty2>, pair<_Uty1, _Uty2>> {
    using type = pair<common_type_t<_Ty1, _Uty1>, common_type_t<_Ty2, _Uty2>>;
};
#line 543 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"

template <class _Ty>
struct _Unrefwrap_helper { 
    using type = _Ty;
};

template <class _Ty>
struct _Unrefwrap_helper<reference_wrapper<_Ty>> { 
    using type = _Ty&;
};


template <class _Ty>
using _Unrefwrap_t = typename _Unrefwrap_helper<decay_t<_Ty>>::type;

 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr pair<_Unrefwrap_t<_Ty1>, _Unrefwrap_t<_Ty2>> make_pair(_Ty1&& _Val1, _Ty2&& _Val2) noexcept(
    is_nothrow_constructible_v<_Unrefwrap_t<_Ty1>, _Ty1>&&
        is_nothrow_constructible_v<_Unrefwrap_t<_Ty2>, _Ty2>)   {
    
    using _Mypair = pair<_Unrefwrap_t<_Ty1>, _Unrefwrap_t<_Ty2>>;
    return _Mypair(::std:: forward<_Ty1>(_Val1), ::std:: forward<_Ty2>(_Val2));
}

namespace [[deprecated("warning STL4027: " "The namespace std::rel_ops and its contents are deprecated in C++20. " "Their use is superseded by C++20's <=> operator and automatic rewrites of relational expressions. " "You can define _SILENCE_CXX20_REL_OPS_DEPRECATION_WARNING or " "_SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] rel_ops {
     template <class _Ty>
    [[deprecated("warning STL4027: " "The namespace std::rel_ops and its contents are deprecated in C++20. " "Their use is superseded by C++20's <=> operator and automatic rewrites of relational expressions. " "You can define _SILENCE_CXX20_REL_OPS_DEPRECATION_WARNING or " "_SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] [[nodiscard]] bool operator!=(const _Ty& _Left, const _Ty& _Right) {
        return !(_Left == _Right);
    }

     template <class _Ty>
    [[deprecated("warning STL4027: " "The namespace std::rel_ops and its contents are deprecated in C++20. " "Their use is superseded by C++20's <=> operator and automatic rewrites of relational expressions. " "You can define _SILENCE_CXX20_REL_OPS_DEPRECATION_WARNING or " "_SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] [[nodiscard]] bool operator>(const _Ty& _Left, const _Ty& _Right) {
        return _Right < _Left;
    }

     template <class _Ty>
    [[deprecated("warning STL4027: " "The namespace std::rel_ops and its contents are deprecated in C++20. " "Their use is superseded by C++20's <=> operator and automatic rewrites of relational expressions. " "You can define _SILENCE_CXX20_REL_OPS_DEPRECATION_WARNING or " "_SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] [[nodiscard]] bool operator<=(const _Ty& _Left, const _Ty& _Right) {
        return !(_Right < _Left);
    }

     template <class _Ty>
    [[deprecated("warning STL4027: " "The namespace std::rel_ops and its contents are deprecated in C++20. " "Their use is superseded by C++20's <=> operator and automatic rewrites of relational expressions. " "You can define _SILENCE_CXX20_REL_OPS_DEPRECATION_WARNING or " "_SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] [[nodiscard]] bool operator>=(const _Ty& _Left, const _Ty& _Right) {
        return !(_Left < _Right);
    }
} 

template <class _Tuple, class = void>
struct _Tuple_size_sfinae {}; 

template <class _Tuple>
struct _Tuple_size_sfinae<_Tuple, void_t<decltype(tuple_size<_Tuple>::value)>>
    : integral_constant<size_t, tuple_size<_Tuple>::value> {}; 

template <class _Tuple>
struct tuple_size<const _Tuple> : _Tuple_size_sfinae<_Tuple> {}; 

template <class _Tuple>
struct [[deprecated("warning STL4030: " "Some operations on volatile-qualified types in the STL are deprecated in C++20. " "You can define _SILENCE_CXX20_VOLATILE_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] tuple_size<volatile _Tuple> : _Tuple_size_sfinae<_Tuple> {}; 

template <class _Tuple>
struct [[deprecated("warning STL4030: " "Some operations on volatile-qualified types in the STL are deprecated in C++20. " "You can define _SILENCE_CXX20_VOLATILE_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] tuple_size<const volatile _Tuple> : _Tuple_size_sfinae<_Tuple> {}; 

template <size_t _Index, class _Tuple>
struct [[msvc::known_semantics]] tuple_element<_Index, const _Tuple> : tuple_element<_Index, _Tuple> {
    using _Mybase = tuple_element<_Index, _Tuple>;
    using type    = add_const_t<typename _Mybase::type>;
};

template <size_t _Index, class _Tuple>
struct [[deprecated("warning STL4030: " "Some operations on volatile-qualified types in the STL are deprecated in C++20. " "You can define _SILENCE_CXX20_VOLATILE_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] [[msvc::known_semantics]] tuple_element<_Index, volatile _Tuple>
    : tuple_element<_Index, _Tuple> {
    using _Mybase = tuple_element<_Index, _Tuple>;
    using type    = add_volatile_t<typename _Mybase::type>;
};

template <size_t _Index, class _Tuple>
struct [[deprecated("warning STL4030: " "Some operations on volatile-qualified types in the STL are deprecated in C++20. " "You can define _SILENCE_CXX20_VOLATILE_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] [[msvc::known_semantics]] tuple_element<_Index, const volatile _Tuple>
    : tuple_element<_Index, _Tuple> {
    using _Mybase = tuple_element<_Index, _Tuple>;
    using type    = add_cv_t<typename _Mybase::type>;
};

template <class _Ty, size_t _Size>
struct tuple_size<array<_Ty, _Size>> : integral_constant<size_t, _Size> {}; 

template <size_t _Idx, class _Ty, size_t _Size>
struct [[msvc::known_semantics]] tuple_element<_Idx, array<_Ty, _Size>> {
    static_assert(_Idx < _Size, "array index out of bounds");

    using type = _Ty;
};

template <class... _Types>
struct tuple_size<tuple<_Types...>> : integral_constant<size_t, sizeof...(_Types)> {}; 

template <size_t _Index>
struct [[msvc::known_semantics]] tuple_element<_Index, tuple<>> { 
    static_assert(_Always_false<integral_constant<size_t, _Index>>, "tuple index out of bounds");
};

template <class _This, class... _Rest>
struct [[msvc::known_semantics]] tuple_element<0, tuple<_This, _Rest...>> { 
    using type = _This;
    
    using _Ttype = tuple<_This, _Rest...>;
};

template <size_t _Index, class _This, class... _Rest>
struct [[msvc::known_semantics]] tuple_element<_Index, tuple<_This, _Rest...>>
    : tuple_element<_Index - 1, tuple<_Rest...>> {}; 

template <class _Ty1, class _Ty2>
struct tuple_size<pair<_Ty1, _Ty2>> : integral_constant<size_t, 2> {}; 

template <size_t _Idx, class _Ty1, class _Ty2>
struct [[msvc::known_semantics]] tuple_element<_Idx, pair<_Ty1, _Ty2>> {
    static_assert(_Idx < 2, "pair index out of bounds");

    using type = conditional_t<_Idx == 0, _Ty1, _Ty2>;
};

 template <size_t _Idx, class _Ty1, class _Ty2>
[[nodiscard]] constexpr tuple_element_t<_Idx, pair<_Ty1, _Ty2>>& get(pair<_Ty1, _Ty2>& _Pr) noexcept {
    
    if constexpr (_Idx == 0) {
        return _Pr.first;
    } else {
        return _Pr.second;
    }
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr _Ty1& get(pair<_Ty1, _Ty2>& _Pr) noexcept {
    
    return _Pr.first;
}

 template <class _Ty2, class _Ty1>
[[nodiscard]] constexpr _Ty2& get(pair<_Ty1, _Ty2>& _Pr) noexcept {
    
    return _Pr.second;
}

 template <size_t _Idx, class _Ty1, class _Ty2>
[[nodiscard]] constexpr const tuple_element_t<_Idx, pair<_Ty1, _Ty2>>& get(const pair<_Ty1, _Ty2>& _Pr) noexcept {
    
    if constexpr (_Idx == 0) {
        return _Pr.first;
    } else {
        return _Pr.second;
    }
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr const _Ty1& get(const pair<_Ty1, _Ty2>& _Pr) noexcept {
    
    return _Pr.first;
}

 template <class _Ty2, class _Ty1>
[[nodiscard]] constexpr const _Ty2& get(const pair<_Ty1, _Ty2>& _Pr) noexcept {
    
    return _Pr.second;
}

 template <size_t _Idx, class _Ty1, class _Ty2>
[[nodiscard]] constexpr tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept {
    
    if constexpr (_Idx == 0) {
        return ::std:: forward<_Ty1>(_Pr.first);
    } else {
        return ::std:: forward<_Ty2>(_Pr.second);
    }
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr _Ty1&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept {
    
    return ::std:: forward<_Ty1>(_Pr.first);
}

 template <class _Ty2, class _Ty1>
[[nodiscard]] constexpr _Ty2&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept {
    
    return ::std:: forward<_Ty2>(_Pr.second);
}

 template <size_t _Idx, class _Ty1, class _Ty2>
[[nodiscard]] constexpr const tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&& get(const pair<_Ty1, _Ty2>&& _Pr) noexcept {
    
    if constexpr (_Idx == 0) {
        return ::std:: forward<const _Ty1>(_Pr.first);
    } else {
        return ::std:: forward<const _Ty2>(_Pr.second);
    }
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr const _Ty1&& get(const pair<_Ty1, _Ty2>&& _Pr) noexcept {
    
    return ::std:: forward<const _Ty1>(_Pr.first);
}

 template <class _Ty2, class _Ty1>
[[nodiscard]] constexpr const _Ty2&& get(const pair<_Ty1, _Ty2>&& _Pr) noexcept {
    
    return ::std:: forward<const _Ty2>(_Pr.second);
}

 template <class _Ty, class _Other = _Ty>
constexpr _Ty exchange(_Ty& _Val, _Other&& _New_val) noexcept(
    conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {
    
    _Ty _Old_val = static_cast<_Ty&&>(_Val);
    _Val         = static_cast<_Other&&>(_New_val);
    return _Old_val;
}

 template <class _Ty>
[[nodiscard]] constexpr add_const_t<_Ty>& as_const(_Ty& _Val) noexcept { 
    return _Val;
}

 template <class _Ty>
void as_const(const _Ty&&) = delete;


 struct in_place_t { 
    explicit in_place_t() = default;
};
 inline constexpr in_place_t in_place{};

 template <class>
struct in_place_type_t { 
    explicit in_place_type_t() = default;
};
 template <class _Ty>
inline constexpr in_place_type_t<_Ty> in_place_type{};

 template <size_t>
struct in_place_index_t { 
    explicit in_place_index_t() = default;
};
 template <size_t _Idx>
inline constexpr in_place_index_t<_Idx> in_place_index{};
#line 789 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"


template <class _Ty>
inline constexpr bool _Is_standard_integer = is_integral_v<_Ty>
                                          && !_Is_any_of_v<remove_cv_t<_Ty>, bool, char,

                                              wchar_t,
#line 797 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"

                                              char8_t,
#line 800 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"
                                              char16_t, char32_t>;

 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool cmp_equal(const _Ty1 _Left, const _Ty2 _Right) noexcept {
    static_assert(_Is_standard_integer<_Ty1> && _Is_standard_integer<_Ty2>,
        "The integer comparison functions only accept standard and extended integer types.");
    if constexpr (is_signed_v<_Ty1> == is_signed_v<_Ty2>) {
        return _Left == _Right;
    } else if constexpr (is_signed_v<_Ty2>) {
        return _Left == static_cast<make_unsigned_t<_Ty2>>(_Right) && _Right >= 0;
    } else {
        return static_cast<make_unsigned_t<_Ty1>>(_Left) == _Right && _Left >= 0;
    }
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool cmp_not_equal(const _Ty1 _Left, const _Ty2 _Right) noexcept {
    return !::std:: cmp_equal(_Left, _Right);
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool cmp_less(const _Ty1 _Left, const _Ty2 _Right) noexcept {
    static_assert(_Is_standard_integer<_Ty1> && _Is_standard_integer<_Ty2>,
        "The integer comparison functions only accept standard and extended integer types.");
    if constexpr (is_signed_v<_Ty1> == is_signed_v<_Ty2>) {
        return _Left < _Right;
    } else if constexpr (is_signed_v<_Ty2>) {
        return _Right > 0 && _Left < static_cast<make_unsigned_t<_Ty2>>(_Right);
    } else {
        return _Left < 0 || static_cast<make_unsigned_t<_Ty1>>(_Left) < _Right;
    }
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool cmp_greater(const _Ty1 _Left, const _Ty2 _Right) noexcept {
    return ::std:: cmp_less(_Right, _Left);
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool cmp_less_equal(const _Ty1 _Left, const _Ty2 _Right) noexcept {
    return !::std:: cmp_less(_Right, _Left);
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool cmp_greater_equal(const _Ty1 _Left, const _Ty2 _Right) noexcept {
    return !::std:: cmp_less(_Left, _Right);
}

template <class _Ty>
[[nodiscard]] consteval _Ty _Min_limit() noexcept { 
    static_assert(_Is_standard_integer<_Ty>); 
    if constexpr (is_signed_v<_Ty>) {
        constexpr auto _Unsigned_max = static_cast<make_unsigned_t<_Ty>>(-1);
        return static_cast<_Ty>((_Unsigned_max >> 1) + 1); 
    } else {
        return 0;
    }
}

template <class _Ty>
[[nodiscard]] consteval _Ty _Max_limit() noexcept { 
    static_assert(_Is_standard_integer<_Ty>); 
    if constexpr (is_signed_v<_Ty>) {
        constexpr auto _Unsigned_max = static_cast<make_unsigned_t<_Ty>>(-1);
        return static_cast<_Ty>(_Unsigned_max >> 1);
    } else {
        return static_cast<_Ty>(-1);
    }
}

 template <class _Rx, class _Ty>
[[nodiscard]] constexpr bool in_range(const _Ty _Value) noexcept {
    static_assert(_Is_standard_integer<_Rx> && _Is_standard_integer<_Ty>,
        "The integer comparison functions only accept standard and extended integer types.");

    constexpr auto _Ty_min = _Min_limit<_Ty>();
    constexpr auto _Rx_min = _Min_limit<_Rx>();

    if constexpr (::std:: cmp_less(_Ty_min, _Rx_min)) {
        if (_Value < _Ty{_Rx_min}) {
            return false;
        }
    }

    constexpr auto _Ty_max = _Max_limit<_Ty>();
    constexpr auto _Rx_max = _Max_limit<_Rx>();

    if constexpr (::std:: cmp_greater(_Ty_max, _Rx_max)) {
        if (_Value > _Ty{_Rx_max}) {
            return false;
        }
    }

    return true;
}


template <class _Ty>
using _With_reference = _Ty&;

template <class _Ty>
concept _Can_reference = requires { typename _With_reference<_Ty>; };






#line 909 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"
#line 910 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"





































#line 948 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"







#line 956 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"

}



#pragma warning(pop)
#pragma pack(pop)
#line 964 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"
#line 965 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"
#pragma external_header(pop)
#line 12 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\__msvc_iter_core.hpp"

#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




namespace std {

 struct input_iterator_tag {};

 struct output_iterator_tag {};

 struct forward_iterator_tag : input_iterator_tag {};

 struct bidirectional_iterator_tag : forward_iterator_tag {};

 struct random_access_iterator_tag : bidirectional_iterator_tag {};


 struct contiguous_iterator_tag : random_access_iterator_tag {};

template <class _Ty>
concept _Dereferenceable = requires(_Ty& __t) {
                               { *__t } -> _Can_reference;
                           };

template <class _Ty>
concept _Has_member_iterator_concept = requires { typename _Ty::iterator_concept; };

template <class _Ty>
concept _Has_member_iterator_category = requires { typename _Ty::iterator_category; };

template <class _Ty>
concept _Has_member_value_type = requires { typename _Ty::value_type; };

template <class _Ty>
concept _Has_member_element_type = requires { typename _Ty::element_type; };

template <class _Ty>
concept _Has_member_difference_type = requires { typename _Ty::difference_type; };

template <class _Ty>
concept _Has_member_pointer = requires { typename _Ty::pointer; };

template <class _Ty>
concept _Has_member_reference = requires { typename _Ty::reference; };

 template <class>
struct incrementable_traits {};

template <class _Ty>
    requires is_object_v<_Ty>
struct incrementable_traits<_Ty*> {
    using difference_type = ptrdiff_t;
};

template <class _Ty>
struct incrementable_traits<const _Ty> : incrementable_traits<_Ty> {};

template <_Has_member_difference_type _Ty>
struct incrementable_traits<_Ty> {
    using difference_type = typename _Ty::difference_type;
};

template <class _Ty>
concept _Can_difference = requires(const _Ty& __a, const _Ty& __b) {
                              { __a - __b } -> integral;
                          };

template <class _Ty>
    requires (!_Has_member_difference_type<_Ty> && _Can_difference<_Ty>)
struct incrementable_traits<_Ty> {
    using difference_type = make_signed_t<decltype(::std:: declval<_Ty>() - ::std:: declval<_Ty>())>;
};

template <class _Ty>
concept _Is_from_primary = _Same_impl<typename _Ty::_From_primary, _Ty>;

 template <class>
struct iterator_traits;

 template <class _Ty>
using iter_difference_t = typename conditional_t<_Is_from_primary<iterator_traits<remove_cvref_t<_Ty>>>,
    incrementable_traits<remove_cvref_t<_Ty>>, iterator_traits<remove_cvref_t<_Ty>>>::difference_type;

template <class>
struct _Cond_value_type {};

template <class _Ty>
    requires is_object_v<_Ty>
struct _Cond_value_type<_Ty> {
    using value_type = remove_cv_t<_Ty>;
};

 template <class>
struct indirectly_readable_traits {};

template <class _Ty>
struct indirectly_readable_traits<_Ty*> : _Cond_value_type<_Ty> {};

template <class _Ty>
    requires is_array_v<_Ty>
struct indirectly_readable_traits<_Ty> {
    using value_type = remove_cv_t<remove_extent_t<_Ty>>;
};

template <class _Ty>
struct indirectly_readable_traits<const _Ty> : indirectly_readable_traits<_Ty> {};

template <_Has_member_value_type _Ty>
struct indirectly_readable_traits<_Ty> : _Cond_value_type<typename _Ty::value_type> {};

template <_Has_member_element_type _Ty>
struct indirectly_readable_traits<_Ty> : _Cond_value_type<typename _Ty::element_type> {};

template <_Has_member_value_type _Ty>
    requires _Has_member_element_type<_Ty>
struct indirectly_readable_traits<_Ty> {};

template <_Has_member_value_type _Ty>
    requires _Has_member_element_type<_Ty>
          && same_as<remove_cv_t<typename _Ty::value_type>, remove_cv_t<typename _Ty::element_type>>
struct indirectly_readable_traits<_Ty> : _Cond_value_type<typename _Ty::value_type> {};

 template <class _Ty>
using iter_value_t = typename conditional_t<_Is_from_primary<iterator_traits<remove_cvref_t<_Ty>>>,
    indirectly_readable_traits<remove_cvref_t<_Ty>>, iterator_traits<remove_cvref_t<_Ty>>>::value_type;

 template <_Dereferenceable _Ty>
using iter_reference_t = decltype(*::std:: declval<_Ty&>());

template <class>
struct _Iterator_traits_base {};

template <class _It>
concept _Has_iter_types = _Has_member_difference_type<_It> && _Has_member_value_type<_It> 
                       && _Has_member_reference<_It> && _Has_member_iterator_category<_It>;

template <bool _Has_member_typedef>
struct _Old_iter_traits_pointer {
    template <class _It>
    using _Apply = typename _It::pointer;
};

template <>
struct _Old_iter_traits_pointer<false> {
    template <class>
    using _Apply = void;
};

template <_Has_iter_types _It>
struct _Iterator_traits_base<_It> {
    using iterator_category = typename _It::iterator_category;
    using value_type        = typename _It::value_type;
    using difference_type   = typename _It::difference_type;
    using pointer           = typename _Old_iter_traits_pointer<_Has_member_pointer<_It>>::template _Apply<_It>;
    using reference         = typename _It::reference;
};

template <bool _Has_member_typedef>
struct _Iter_traits_difference {
    template <class _It>
    using _Apply = typename incrementable_traits<_It>::difference_type;
};

template <>
struct _Iter_traits_difference<false> {
    template <class>
    using _Apply = void;
};


template <class _It>
concept _Cpp17_iterator =
    requires(_It __i) {
        { *__i } -> _Can_reference;
        { ++__i } -> same_as<_It&>;
        { *__i++ } -> _Can_reference;
    }
    && copyable<_It>;

template <class _It>
concept _Cpp17_input_iterator = _Cpp17_iterator<_It>
    && equality_comparable<_It>
    && _Has_member_difference_type<incrementable_traits<_It>>
    && _Has_member_value_type<indirectly_readable_traits<_It>>
    && requires(_It __i) {
        typename common_reference_t<iter_reference_t<_It>&&, typename indirectly_readable_traits<_It>::value_type&>;
        typename common_reference_t<decltype(*__i++)&&, typename indirectly_readable_traits<_It>::value_type&>;
        requires signed_integral<typename incrementable_traits<_It>::difference_type>;
    };

template <class _It>
    requires (!_Has_iter_types<_It> && _Cpp17_iterator<_It> && !_Cpp17_input_iterator<_It>)
struct _Iterator_traits_base<_It> {
    using iterator_category = output_iterator_tag;
    using value_type = void;
    using difference_type =
        typename _Iter_traits_difference<_Has_member_difference_type<incrementable_traits<_It>>>::template _Apply<_It>;
    using pointer    = void;
    using reference  = void;
};


enum class _Itraits_pointer_strategy { _Use_void, _Use_member, _Use_decltype };

template <_Itraits_pointer_strategy>
struct _Iter_traits_pointer;

template <>
struct _Iter_traits_pointer<_Itraits_pointer_strategy::_Use_void> {
    template <class>
    using _Apply = void;
};

template <>
struct _Iter_traits_pointer<_Itraits_pointer_strategy::_Use_member> {
    template <class _It>
    using _Apply = typename _It::pointer;
};

template <>
struct _Iter_traits_pointer<_Itraits_pointer_strategy::_Use_decltype> {
    template <class _It>
    using _Apply = decltype(::std:: declval<_It&>().operator->());
};

template <class _Ty>
concept _Has_member_arrow = requires(_Ty&& __t) { static_cast<_Ty&&>(__t).operator->(); };

template <bool _Has_member_typedef>
struct _Iter_traits_reference {
    template <class _It>
    using _Apply = typename _It::reference;
};

template <>
struct _Iter_traits_reference<false> {
    template <class _It>
    using _Apply = iter_reference_t<_It>;
};

template <bool _Is_random>
struct _Iter_traits_category4 {
    using type = random_access_iterator_tag;
};

template <>
struct _Iter_traits_category4<false> {
    using type = bidirectional_iterator_tag;
};


template <class _It>
concept _Cpp17_random_delta = totally_ordered<_It>
    && requires(_It __i, typename incrementable_traits<_It>::difference_type __n) {
        { __i += __n } -> same_as<_It&>;
        { __i -= __n } -> same_as<_It&>;
        { __i +  __n } -> same_as<_It>;
        { __n +  __i } -> same_as<_It>;
        { __i -  __n } -> same_as<_It>;
        { __i -  __i } -> same_as<decltype(__n)>;
        {  __i[__n]  } -> convertible_to<iter_reference_t<_It>>;
    };


template <bool _Is_bidi>
struct _Iter_traits_category3 {
    template <class _It>
    using _Apply = typename _Iter_traits_category4<_Cpp17_random_delta<_It>>::type;
};

template <>
struct _Iter_traits_category3<false> {
    template <class>
    using _Apply = forward_iterator_tag;
};

template <class _It>
concept _Cpp17_bidi_delta = requires(_It __i) {
                                { --__i } -> same_as<_It&>;
                                { __i-- } -> convertible_to<const _It&>;
                                requires same_as<decltype(*__i--), iter_reference_t<_It>>;
                            };

template <bool _Is_forward>
struct _Iter_traits_category2 {
    template <class _It>
    using _Apply = typename _Iter_traits_category3<_Cpp17_bidi_delta<_It>>::template _Apply<_It>;
};

template <>
struct _Iter_traits_category2<false> {
    template <class>
    using _Apply = input_iterator_tag;
};


template <class _It>
concept _Cpp17_forward_delta = constructible_from<_It> && is_reference_v<iter_reference_t<_It>>
    && same_as<remove_cvref_t<iter_reference_t<_It>>, typename indirectly_readable_traits<_It>::value_type>
    && requires(_It __i) {
        { __i++ } -> convertible_to<const _It&>;
        requires same_as<decltype(*__i++), iter_reference_t<_It>>;
    };


template <bool _Has_member_typedef>
struct _Iter_traits_category {
    template <class _It>
    using _Apply = typename _It::iterator_category;
};

template <>
struct _Iter_traits_category<false> {
    template <class _It>
    using _Apply = typename _Iter_traits_category2<_Cpp17_forward_delta<_It>>::template _Apply<_It>;
};


template <class _It>
    requires (!_Has_iter_types<_It> && _Cpp17_input_iterator<_It>)
struct _Iterator_traits_base<_It> {
    using iterator_category = typename _Iter_traits_category<_Has_member_iterator_category<_It>>::template _Apply<_It>;
    using value_type        = typename indirectly_readable_traits<_It>::value_type;
    using difference_type   = typename incrementable_traits<_It>::difference_type;
    using pointer           = typename _Iter_traits_pointer<(
        _Has_member_pointer<_It> ? _Itraits_pointer_strategy::_Use_member
                                 : _Has_member_arrow<_It&> ? _Itraits_pointer_strategy::_Use_decltype
                                                       : _Itraits_pointer_strategy::_Use_void)>::template _Apply<_It>;
    using reference         = typename _Iter_traits_reference<_Has_member_reference<_It>>::template _Apply<_It>;
};


 template <class _Ty>
struct iterator_traits : _Iterator_traits_base<_Ty> {
    using _From_primary = iterator_traits;
};

template <class _Ty>
    requires is_object_v<_Ty>
struct iterator_traits<_Ty*> {
    using iterator_concept  = contiguous_iterator_tag;
    using iterator_category = random_access_iterator_tag;
    using value_type        = remove_cv_t<_Ty>;
    using difference_type   = ptrdiff_t;
    using pointer           = _Ty*;
    using reference         = _Ty&;
};

template <class _Ty>
inline constexpr bool _Integer_class = requires {
                                           typename _Ty::_Signed_type;
                                           typename _Ty::_Unsigned_type;
                                       };

template <class _Ty>
concept _Integer_like = _Is_nonbool_integral<remove_cv_t<_Ty>> || _Integer_class<_Ty>;

template <class _Ty>
concept _Signed_integer_like = _Integer_like<_Ty> && static_cast<_Ty>(-1) < static_cast<_Ty>(0);


 template <class _Ty>
concept weakly_incrementable = movable<_Ty>
    && requires(_Ty __i) {
        typename iter_difference_t<_Ty>;
        requires _Signed_integer_like<iter_difference_t<_Ty>>;
        { ++__i } -> same_as<_Ty&>;
        __i++;
    }



    ;

 template <class _It>
concept input_or_output_iterator = requires(_It __i) { { *__i } -> _Can_reference; }
    && weakly_incrementable<_It>;

 template <class _Se, class _It>
concept sentinel_for = semiregular<_Se>
    && input_or_output_iterator<_It>
    && _Weakly_equality_comparable_with<_Se, _It>;


 template <class _Se, class _It>
inline constexpr bool disable_sized_sentinel_for = false;


 template <class _Se, class _It>
concept sized_sentinel_for = sentinel_for<_Se, _It>
    && !disable_sized_sentinel_for<remove_cv_t<_Se>, remove_cv_t<_It>>
    && requires(const _It& __i, const _Se& __s) {
        { __s - __i } -> same_as<iter_difference_t<_It>>;
        { __i - __s } -> same_as<iter_difference_t<_It>>;
    };


namespace ranges {
     enum class subrange_kind : bool { unsized, sized };

     template <input_or_output_iterator _It, sentinel_for<_It> _Se = _It,
        subrange_kind _Ki = sized_sentinel_for<_Se, _It> ? subrange_kind::sized : subrange_kind::unsized>
        requires (_Ki == subrange_kind::sized || !sized_sentinel_for<_Se, _It>)
    class subrange;

     template <size_t _Idx, class _It, class _Se, subrange_kind _Ki>
        requires ((_Idx == 0 && copyable<_It>) || _Idx == 1)
    [[nodiscard]] constexpr auto get(const subrange<_It, _Se, _Ki>& _Val);

     template <size_t _Idx, class _It, class _Se, subrange_kind _Ki>
        requires (_Idx < 2)
    [[nodiscard]] constexpr auto get(subrange<_It, _Se, _Ki>&& _Val);
} 

 using ranges::get;

template <class _It, class _Se, ranges::subrange_kind _Ki>
inline constexpr bool _Is_subrange_v<ranges::subrange<_It, _Se, _Ki>> = true;

template <class _It, class _Se, ranges::subrange_kind _Ki>
struct tuple_size<ranges::subrange<_It, _Se, _Ki>> : integral_constant<size_t, 2> {};

template <class _It, class _Se, ranges::subrange_kind _Ki>
struct tuple_element<0, ranges::subrange<_It, _Se, _Ki>> {
    using type = _It;
};

template <class _It, class _Se, ranges::subrange_kind _Ki>
struct tuple_element<1, ranges::subrange<_It, _Se, _Ki>> {
    using type = _Se;
};

template <class _It, class _Se, ranges::subrange_kind _Ki>
struct tuple_element<0, const ranges::subrange<_It, _Se, _Ki>> {
    using type = _It;
};

template <class _It, class _Se, ranges::subrange_kind _Ki>
struct tuple_element<1, const ranges::subrange<_It, _Se, _Ki>> {
    using type = _Se;
};

































#line 491 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\__msvc_iter_core.hpp"
}



#pragma warning(pop)
#pragma pack(pop)
#line 498 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\__msvc_iter_core.hpp"
#line 499 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\__msvc_iter_core.hpp"
#pragma external_header(pop)
#line 13 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"


#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cstring"





#pragma once





#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\string.h"







#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_memory.h"










#pragma once





#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )




__pragma(pack(push, 8)) extern "C" {




__declspec(dllimport) int __cdecl _memicmp(
     void const* _Buf1,
     void const* _Buf2,
                            size_t      _Size
    );


__declspec(dllimport) int __cdecl _memicmp_l(
     void const* _Buf1,
     void const* _Buf2,
                            size_t      _Size,
                        _locale_t   _Locale
    );





    












#line 60 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_memory.h"

    












#line 75 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_memory.h"

#line 77 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_memory.h"





    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_memccpy" ". See online help for details."))
    __declspec(dllimport) void* __cdecl memccpy(
         void*       _Dst,
           void const* _Src,
                                  int         _Val,
                                  size_t      _Size
        );

     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_memicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl memicmp(
         void const* _Buf1,
         void const* _Buf2,
                                size_t      _Size
        );

#line 98 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_memory.h"





    extern "C++" 
    inline void* __cdecl memchr(
         void*  _Pv,
                             int    _C,
                             size_t _N
        )
    {
        void const* const _Pvc = _Pv;
        return const_cast<void*>(memchr(_Pvc, _C, _N));
    }

#line 115 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_memory.h"



} __pragma(pack(pop))

#line 121 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_memory.h"

#pragma warning(pop) 
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\string.h"





#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {







    
    __declspec(dllimport) errno_t __cdecl strcpy_s(
         char*       _Destination,
                                 rsize_t     _SizeInBytes,
                               char const* _Source
        );

    
    __declspec(dllimport) errno_t __cdecl strcat_s(
         char*       _Destination,
                                    rsize_t     _SizeInBytes,
                                  char const* _Source
        );

    
    __declspec(dllimport) errno_t __cdecl strerror_s(
         char*  _Buffer,
                                 size_t _SizeInBytes,
                                 int    _ErrorNumber);

    
    __declspec(dllimport) errno_t __cdecl strncat_s(
         char*       _Destination,
                                    rsize_t     _SizeInBytes,
              char const* _Source,
                                    rsize_t     _MaxCount
        );

    
    __declspec(dllimport) errno_t __cdecl strncpy_s(
         char*       _Destination,
                                 rsize_t     _SizeInBytes,
           char const* _Source,
                                 rsize_t     _MaxCount
        );

    
    __declspec(dllimport) char*  __cdecl strtok_s(
                         char*       _String,
                                char const* _Delimiter,
          char**      _Context
        );

#line 75 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\string.h"

__declspec(dllimport) void* __cdecl _memccpy(
     void*       _Dst,
                                  void const* _Src,
                                  int         _Val,
                                  size_t      _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strcat_s(char (&_Destination)[_Size], char const* _Source) throw() { return strcat_s(_Destination, _Size, _Source); } }







    __declspec(deprecated("This function or variable may be unsafe. Consider using " "strcat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) char* __cdecl strcat( char *_Destination, char const* _Source);





#line 98 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\string.h"


int __cdecl strcmp(
     char const* _Str1,
     char const* _Str2
    );


__declspec(dllimport) int __cdecl _strcmpi(
     char const* _String1,
     char const* _String2
    );


__declspec(dllimport) int __cdecl strcoll(
     char const* _String1,
     char const* _String2
    );


__declspec(dllimport) int __cdecl _strcoll_l(
       char const* _String1,
       char const* _String2,
     _locale_t   _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strcpy_s(char (&_Destination)[_Size], char const* _Source) throw() { return strcpy_s(_Destination, _Size, _Source); } }





__declspec(deprecated("This function or variable may be unsafe. Consider using " "strcpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) char* __cdecl strcpy( char *_Destination, char const* _Source);






__declspec(dllimport) size_t __cdecl strcspn(
     char const* _Str,
     char const* _Control
    );




#line 146 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\string.h"


__declspec(dllimport) __declspec(allocator) char* __cdecl _strdup(
     char const* _Source
    );



#line 155 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\string.h"



 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_strerror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char*  __cdecl _strerror(
     char const* _ErrorMessage
    );


__declspec(dllimport) errno_t __cdecl _strerror_s(
     char*       _Buffer,
                             size_t      _SizeInBytes,
                       char const* _ErrorMessage
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strerror_s(char (&_Buffer)[_Size], char const* _ErrorMessage) throw() { return _strerror_s(_Buffer, _Size, _ErrorMessage); } }






 __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl strerror(
     int _ErrorMessage
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strerror_s(char (&_Buffer)[_Size], int _ErrorMessage) throw() { return strerror_s(_Buffer, _Size, _ErrorMessage); } }






__declspec(dllimport) int __cdecl _stricmp(
     char const* _String1,
     char const* _String2
    );


__declspec(dllimport) int __cdecl _stricoll(
     char const* _String1,
     char const* _String2
    );


__declspec(dllimport) int __cdecl _stricoll_l(
       char const* _String1,
       char const* _String2,
     _locale_t   _Locale
    );


__declspec(dllimport) int __cdecl _stricmp_l(
       char const* _String1,
       char const* _String2,
     _locale_t   _Locale
    );


size_t __cdecl strlen(
     char const* _Str
    );


__declspec(dllimport) errno_t __cdecl _strlwr_s(
     char*  _String,
                         size_t _Size
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s(char (&_String)[_Size]) throw() { return _strlwr_s(_String, _Size); } }




__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strlwr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strlwr( char *_String);





__declspec(dllimport) errno_t __cdecl _strlwr_s_l(
     char*     _String,
                         size_t    _Size,
                     _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s_l(char (&_String)[_Size], _locale_t _Locale) throw() { return _strlwr_s_l(_String, _Size, _Locale); } }





__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strlwr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strlwr_l( char *_String, _locale_t _Locale);






extern "C++" { template <size_t _Size> inline errno_t __cdecl strncat_s(char (&_Destination)[_Size], char const* _Source, size_t _Count) throw() { return strncat_s(_Destination, _Size, _Source, _Count); } }






__declspec(deprecated("This function or variable may be unsafe. Consider using " "strncat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl strncat( char *_Destination, char const* _Source, size_t _Count);








__declspec(dllimport) int __cdecl strncmp(
     char const* _Str1,
     char const* _Str2,
                           size_t      _MaxCount
    );


__declspec(dllimport) int __cdecl _strnicmp(
     char const* _String1,
     char const* _String2,
                           size_t      _MaxCount
    );


__declspec(dllimport) int __cdecl _strnicmp_l(
     char const* _String1,
     char const* _String2,
                           size_t      _MaxCount,
                       _locale_t   _Locale
    );


__declspec(dllimport) int __cdecl _strnicoll(
     char const* _String1,
     char const* _String2,
                           size_t      _MaxCount
    );


__declspec(dllimport) int __cdecl _strnicoll_l(
     char const* _String1,
     char const* _String2,
                           size_t      _MaxCount,
                       _locale_t   _Locale
    );


__declspec(dllimport) int __cdecl _strncoll(
     char const* _String1,
     char const* _String2,
                           size_t      _MaxCount
    );


__declspec(dllimport) int __cdecl _strncoll_l(
     char const* _String1,
     char const* _String2,
                           size_t      _MaxCount,
                       _locale_t   _Locale
    );

__declspec(dllimport) size_t __cdecl __strncnt(
     char const* _String,
                        size_t      _Count
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strncpy_s(char (&_Destination)[_Size], char const* _Source, size_t _Count) throw() { return strncpy_s(_Destination, _Size, _Source, _Count); } }






__declspec(deprecated("This function or variable may be unsafe. Consider using " "strncpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl strncpy( char *_Destination, char const* _Source, size_t _Count);
















__declspec(dllimport) size_t __cdecl strnlen(
     char const* _String,
                           size_t      _MaxCount
    );



    
    



    



    static __inline size_t __cdecl strnlen_s(
         char const* _String,
                               size_t      _MaxCount
        )
    {
        return _String == 0 ? 0 : strnlen(_String, _MaxCount);
    }

#line 376 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\string.h"


__declspec(dllimport) errno_t __cdecl _strnset_s(
     char*  _String,
                                size_t _SizeInBytes,
                                int    _Value,
                                size_t _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strnset_s(char (&_Destination)[_Size], int _Value, size_t _Count) throw() { return _strnset_s(_Destination, _Size, _Value, _Count); } }






__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strnset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strnset( char *_Destination, int _Value, size_t _Count);








__declspec(dllimport) char const * __cdecl strpbrk(
     char const* _Str,
     char const* _Control
    );

__declspec(dllimport) char* __cdecl _strrev(
     char* _Str
    );


__declspec(dllimport) errno_t __cdecl _strset_s(
     char*  _Destination,
                                    size_t _DestinationSize,
                                    int    _Value
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strset_s(char (&_Destination)[_Size], int _Value) throw() { return _strset_s(_Destination, _Size, _Value); } }





__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) char* __cdecl _strset( char *_Destination, int _Value);






__declspec(dllimport) size_t __cdecl strspn(
     char const* _Str,
     char const* _Control
    );

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "strtok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl strtok(
     char*       _String,
            char const* _Delimiter
    );


__declspec(dllimport) errno_t __cdecl _strupr_s(
     char*  _String,
                         size_t _Size
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s(char (&_String)[_Size]) throw() { return _strupr_s(_String, _Size); } }




__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strupr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strupr( char *_String);





__declspec(dllimport) errno_t __cdecl _strupr_s_l(
     char*     _String,
                         size_t    _Size,
                     _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s_l(char (&_String)[_Size], _locale_t _Locale) throw() { return _strupr_s_l(_String, _Size, _Locale); } }





__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strupr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strupr_l( char *_String, _locale_t _Locale);








__declspec(dllimport) size_t __cdecl strxfrm(
      char*       _Destination,
                                        char const* _Source,
               size_t      _MaxCount
    );



__declspec(dllimport) size_t __cdecl _strxfrm_l(
      char*       _Destination,
                                        char const* _Source,
               size_t      _MaxCount,
                                      _locale_t   _Locale
    );




extern "C++"
{
    
    inline char* __cdecl strchr( char* const _String,  int const _Ch)
    {
        return const_cast<char*>(strchr(static_cast<char const*>(_String), _Ch));
    }

    
    inline char* __cdecl strpbrk( char* const _String,  char const* const _Control)
    {
        return const_cast<char*>(strpbrk(static_cast<char const*>(_String), _Control));
    }

    
    inline char* __cdecl strrchr( char* const _String,  int const _Ch)
    {
        return const_cast<char*>(strrchr(static_cast<char const*>(_String), _Ch));
    }

     
    inline char* __cdecl strstr( char* const _String,  char const* const _SubString)
    {
        return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));
    }
}
#line 524 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\string.h"





    
    
     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strdup" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strdup(
         char const* _String
        );
    

    
     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strcmpi" ". See online help for details."))
    __declspec(dllimport) int __cdecl strcmpi(
         char const* _String1,
         char const* _String2
        );

     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_stricmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl stricmp(
         char const* _String1,
         char const* _String2
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strlwr" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strlwr(
         char* _String
        );

     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strnicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl strnicmp(
         char const* _String1,
         char const* _String2,
                               size_t      _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strnset" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strnset(
         char*  _String,
                                 int    _Value,
                                 size_t _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strrev" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strrev(
         char* _String
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strset" ". See online help for details."))
    char* __cdecl strset(
         char* _String,
              int   _Value);

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strupr" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strupr(
         char* _String
        );

#line 585 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\string.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#line 592 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\string.h"
#line 593 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\string.h"
#pragma external_header(pop)
#line 13 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cstring"

#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




namespace std {
#pragma warning(push)
#pragma warning(disable : 4995) 

 using :: size_t;
 using :: memchr;
 using :: memcmp;
 using :: memcpy;
 using :: memmove;
 using :: memset;
 using :: strcat;
 using :: strchr;
 using :: strcmp;
 using :: strcoll;
 using :: strcpy;
 using :: strcspn;
 using :: strerror;
 using :: strlen;
 using :: strncat;
 using :: strncmp;
 using :: strncpy;
 using :: strpbrk;
 using :: strrchr;
 using :: strspn;
 using :: strstr;
 using :: strtok;
 using :: strxfrm;

#pragma warning(pop)
}



#pragma warning(pop)
#pragma pack(pop)

#line 58 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cstring"
#line 59 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cstring"
#pragma external_header(pop)
#line 16 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )














#line 35 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"


#line 38 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"






#line 45 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"


extern "C" {







__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_1(void* _First, void* _Last) noexcept;
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_2(void* _First, void* _Last) noexcept;
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_4(void* _First, void* _Last) noexcept;
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_8(void* _First, void* _Last) noexcept;
__declspec(noalias) void __cdecl __std_swap_ranges_trivially_swappable_noalias(
    void* _First1, void* _Last1, void* _First2) noexcept;

__declspec(noalias) size_t
    __stdcall __std_count_trivial_1(const void* _First, const void* _Last, uint8_t _Val) noexcept;
__declspec(noalias) size_t
    __stdcall __std_count_trivial_2(const void* _First, const void* _Last, uint16_t _Val) noexcept;
__declspec(noalias) size_t
    __stdcall __std_count_trivial_4(const void* _First, const void* _Last, uint32_t _Val) noexcept;
__declspec(noalias) size_t
    __stdcall __std_count_trivial_8(const void* _First, const void* _Last, uint64_t _Val) noexcept;

const void* __stdcall __std_find_trivial_1(const void* _First, const void* _Last, uint8_t _Val) noexcept;
const void* __stdcall __std_find_trivial_2(const void* _First, const void* _Last, uint16_t _Val) noexcept;
const void* __stdcall __std_find_trivial_4(const void* _First, const void* _Last, uint32_t _Val) noexcept;
const void* __stdcall __std_find_trivial_8(const void* _First, const void* _Last, uint64_t _Val) noexcept;

const void* __stdcall __std_find_trivial_unsized_1(const void* _First, uint8_t _Val) noexcept;
const void* __stdcall __std_find_trivial_unsized_2(const void* _First, uint16_t _Val) noexcept;
const void* __stdcall __std_find_trivial_unsized_4(const void* _First, uint32_t _Val) noexcept;
const void* __stdcall __std_find_trivial_unsized_8(const void* _First, uint64_t _Val) noexcept;

const void* __stdcall __std_min_element_1(const void* _First, const void* _Last, bool _Signed) noexcept;
const void* __stdcall __std_min_element_2(const void* _First, const void* _Last, bool _Signed) noexcept;
const void* __stdcall __std_min_element_4(const void* _First, const void* _Last, bool _Signed) noexcept;
const void* __stdcall __std_min_element_8(const void* _First, const void* _Last, bool _Signed) noexcept;

const void* __stdcall __std_max_element_1(const void* _First, const void* _Last, bool _Signed) noexcept;
const void* __stdcall __std_max_element_2(const void* _First, const void* _Last, bool _Signed) noexcept;
const void* __stdcall __std_max_element_4(const void* _First, const void* _Last, bool _Signed) noexcept;
const void* __stdcall __std_max_element_8(const void* _First, const void* _Last, bool _Signed) noexcept;
}

template <class _Ty, class _TVal>
__declspec(noalias) size_t __std_count_trivial(_Ty* _First, _Ty* _Last, const _TVal _Val) noexcept {
    if constexpr (::std:: is_pointer_v<_TVal> || ::std:: is_null_pointer_v<_TVal>) {
        return __std_count_trivial(_First, _Last, reinterpret_cast<uintptr_t>(_Val));
    } else if constexpr (sizeof(_Ty) == 1) {
        return __std_count_trivial_1(_First, _Last, static_cast<uint8_t>(_Val));
    } else if constexpr (sizeof(_Ty) == 2) {
        return __std_count_trivial_2(_First, _Last, static_cast<uint16_t>(_Val));
    } else if constexpr (sizeof(_Ty) == 4) {
        return __std_count_trivial_4(_First, _Last, static_cast<uint32_t>(_Val));
    } else if constexpr (sizeof(_Ty) == 8) {
        return __std_count_trivial_8(_First, _Last, static_cast<uint64_t>(_Val));
    } else {
        static_assert(::std:: _Always_false<_Ty>, "Unexpected size");
    }
}

template <class _Ty, class _TVal>
_Ty* __std_find_trivial(_Ty* _First, _Ty* _Last, const _TVal _Val) noexcept {
    if constexpr (::std:: is_pointer_v<_TVal> || ::std:: is_null_pointer_v<_TVal>) {
        return __std_find_trivial(_First, _Last, reinterpret_cast<uintptr_t>(_Val));
    } else if constexpr (sizeof(_Ty) == 1) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(__std_find_trivial_1(_First, _Last, static_cast<uint8_t>(_Val))));
    } else if constexpr (sizeof(_Ty) == 2) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(__std_find_trivial_2(_First, _Last, static_cast<uint16_t>(_Val))));
    } else if constexpr (sizeof(_Ty) == 4) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(__std_find_trivial_4(_First, _Last, static_cast<uint32_t>(_Val))));
    } else if constexpr (sizeof(_Ty) == 8) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(__std_find_trivial_8(_First, _Last, static_cast<uint64_t>(_Val))));
    } else {
        static_assert(::std:: _Always_false<_Ty>, "Unexpected size");
    }
}

template <class _Ty, class _TVal>
_Ty* __std_find_trivial_unsized(_Ty* _First, const _TVal _Val) noexcept {
    if constexpr (::std:: is_pointer_v<_TVal> || ::std:: is_null_pointer_v<_TVal>) {
        return __std_find_trivial_unsized(_First, reinterpret_cast<uintptr_t>(_Val));
    } else if constexpr (sizeof(_Ty) == 1) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(__std_find_trivial_unsized_1(_First, static_cast<uint8_t>(_Val))));
    } else if constexpr (sizeof(_Ty) == 2) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(__std_find_trivial_unsized_2(_First, static_cast<uint16_t>(_Val))));
    } else if constexpr (sizeof(_Ty) == 4) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(__std_find_trivial_unsized_4(_First, static_cast<uint32_t>(_Val))));
    } else if constexpr (sizeof(_Ty) == 8) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(__std_find_trivial_unsized_8(_First, static_cast<uint64_t>(_Val))));
    } else {
        static_assert(::std:: _Always_false<_Ty>, "Unexpected size");
    }
}

template <class _Ty>
_Ty* __std_min_element(_Ty* _First, _Ty* _Last) noexcept {
    constexpr bool _Signed = ::std:: is_signed_v<_Ty>;

    if constexpr (sizeof(_Ty) == 1) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(__std_min_element_1(_First, _Last, _Signed)));
    } else if constexpr (sizeof(_Ty) == 2) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(__std_min_element_2(_First, _Last, _Signed)));
    } else if constexpr (sizeof(_Ty) == 4) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(__std_min_element_4(_First, _Last, _Signed)));
    } else if constexpr (sizeof(_Ty) == 8) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(__std_min_element_8(_First, _Last, _Signed)));
    } else {
        static_assert(::std:: _Always_false<_Ty>, "Unexpected size");
    }
}

template <class _Ty>
_Ty* __std_max_element(_Ty* _First, _Ty* _Last) noexcept {
    constexpr bool _Signed = ::std:: is_signed_v<_Ty>;

    if constexpr (sizeof(_Ty) == 1) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(__std_max_element_1(_First, _Last, _Signed)));
    } else if constexpr (sizeof(_Ty) == 2) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(__std_max_element_2(_First, _Last, _Signed)));
    } else if constexpr (sizeof(_Ty) == 4) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(__std_max_element_4(_First, _Last, _Signed)));
    } else if constexpr (sizeof(_Ty) == 8) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(__std_max_element_8(_First, _Last, _Signed)));
    } else {
        static_assert(::std:: _Always_false<_Ty>, "Unexpected size");
    }
}

#line 186 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

namespace std {

template <class _To, class _From,
    enable_if_t<conjunction_v<bool_constant<sizeof(_To) == sizeof(_From)>, is_trivially_copyable<_To>,
                    is_trivially_copyable<_From>>,
        int> = 0>
[[nodiscard]] constexpr _To _Bit_cast(const _From& _Val) noexcept {
    return __builtin_bit_cast(_To, _Val);
}

template <class _Ty>
struct _Get_first_parameter;

template <template <class, class...> class _Ty, class _First, class... _Rest>
struct _Get_first_parameter<_Ty<_First, _Rest...>> { 
    using type = _First;
};

template <class _Newfirst, class _Ty>
struct _Replace_first_parameter;

template <class _Newfirst, template <class, class...> class _Ty, class _First, class... _Rest>
struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...>> { 
    using type = _Ty<_Newfirst, _Rest...>;
};

template <class _Ty, class = void>
struct _Get_ptr_difference_type {
    using type = ptrdiff_t;
};

template <class _Ty>
struct _Get_ptr_difference_type<_Ty, void_t<typename _Ty::difference_type>> {
    using type = typename _Ty::difference_type;
};

template <class _Ty, class _Other, class = void>
struct _Get_rebind_alias {
    using type = typename _Replace_first_parameter<_Other, _Ty>::type;
};

template <class _Ty, class _Other>
struct _Get_rebind_alias<_Ty, _Other, void_t<typename _Ty::template rebind<_Other>>> {
    using type = typename _Ty::template rebind<_Other>;
};

template <class _Iter>
[[nodiscard]] constexpr void* _Voidify_iter(_Iter _It) noexcept {
    if constexpr (is_pointer_v<_Iter>) {
        return const_cast<void*>(static_cast<const volatile void*>(_It));
    } else {
        return const_cast<void*>(static_cast<const volatile void*>(::std:: addressof(*_It)));
    }
}






 template <class _Ty, class... _Types,
    void_t<decltype(::new(::std:: declval<void*>()) _Ty(::std:: declval<_Types>()...))>* = nullptr>
#line 250 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
constexpr _Ty* construct_at(_Ty* const _Location, _Types&&... _Args) noexcept(
    noexcept(::new(_Voidify_iter(_Location)) _Ty(::std:: forward<_Types>(_Args)...)))   {
    [[msvc::constexpr]] return ::new (_Voidify_iter(_Location)) _Ty(::std:: forward<_Types>(_Args)...);
}
#line 255 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

template <class _Ty, class... _Types>
constexpr void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(
    is_nothrow_constructible_v<_Ty, _Types...>) {

    if (::std:: is_constant_evaluated()) {
        ::std:: construct_at(::std:: addressof(_Obj), ::std:: forward<_Types>(_Args)...);
    } else
#line 264 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
    {
        ::new (_Voidify_iter(::std:: addressof(_Obj))) _Ty(::std:: forward<_Types>(_Args)...);
    }
}

template <class _Ty>
void _Default_construct_in_place(_Ty& _Obj) noexcept(is_nothrow_default_constructible_v<_Ty>) {
    ::new (_Voidify_iter(::std:: addressof(_Obj))) _Ty;
}

template <class _Ty, class _Elem>
struct _Ptr_traits_base {
    using pointer         = _Ty;
    using element_type    = _Elem;
    using difference_type = typename _Get_ptr_difference_type<_Ty>::type;

    template <class _Other>
    using rebind = typename _Get_rebind_alias<_Ty, _Other>::type;

    using _Reftype = conditional_t<is_void_v<_Elem>, char, _Elem>&;

    [[nodiscard]] static constexpr pointer pointer_to(_Reftype _Val) noexcept(
        noexcept(_Ty::pointer_to(_Val)))   { 
        return _Ty::pointer_to(_Val);
    }
};

template <class, class = void, class = void>
struct _Ptr_traits_sfinae_layer {};

template <class _Ty, class _Uty>
struct _Ptr_traits_sfinae_layer<_Ty, _Uty, void_t<typename _Get_first_parameter<_Ty>::type>>
    : _Ptr_traits_base<_Ty, typename _Get_first_parameter<_Ty>::type> {};

template <class _Ty>
struct _Ptr_traits_sfinae_layer<_Ty, void_t<typename _Ty::element_type>, void>
    : _Ptr_traits_base<_Ty, typename _Ty::element_type> {};

 template <class _Ty>
struct pointer_traits : _Ptr_traits_sfinae_layer<_Ty> {};

template <class _Ty>
struct pointer_traits<_Ty*> {
    using pointer         = _Ty*;
    using element_type    = _Ty;
    using difference_type = ptrdiff_t;

    template <class _Other>
    using rebind = _Other*;

    using _Reftype = conditional_t<is_void_v<_Ty>, char, _Ty>&;

    [[nodiscard]] static constexpr pointer pointer_to(_Reftype _Val) noexcept {
        return ::std:: addressof(_Val);
    }
};



template <class _Ty>
concept _Has_to_address = requires(const _Ty& _Val) {
                              typename pointer_traits<_Ty>;
                              pointer_traits<_Ty>::to_address(_Val);
                          };







#line 336 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

 template <class _Ty>
[[nodiscard]] constexpr _Ty* to_address(_Ty* const _Val) noexcept {
    static_assert(!is_function_v<_Ty>,
        "N4810 20.10.4 [pointer.conversion]/2: The program is ill-formed if T is a function type.");
    return _Val;
}

 template <class _Ptr>
[[nodiscard]] constexpr auto to_address(const _Ptr& _Val) noexcept {
    if constexpr (_Has_to_address<_Ptr>) {
        return pointer_traits<_Ptr>::to_address(_Val);
    } else {
        return ::std:: to_address(_Val.operator->()); 
    }
}

 struct identity {
    template <class _Ty>
    [[nodiscard]] constexpr _Ty&& operator()(_Ty&& _Left) const noexcept {
        return ::std:: forward<_Ty>(_Left);
    }

    using is_transparent = int;
};
#line 362 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

template <class _Fx>
struct _Ref_fn { 
    template <class... _Args>
    constexpr decltype(auto) operator()(_Args&&... _Vals) { 
        if constexpr (is_member_pointer_v<_Fx>) {
            return ::std:: invoke(_Fn, ::std:: forward<_Args>(_Vals)...);
        } else {
            return _Fn(::std:: forward<_Args>(_Vals)...);
        }
    }

    _Fx& _Fn;
};

template <class _Fn>
constexpr auto _Pass_fn(_Fn& _Func) noexcept {
    constexpr bool _Pass_by_value = conjunction_v<bool_constant<sizeof(_Fn) <= sizeof(void*)>,
        is_trivially_copy_constructible<_Fn>, is_trivially_destructible<_Fn>>;
    if constexpr (_Pass_by_value) {
        return _Func;
    } else {
        return _Ref_fn<_Fn>{_Func}; 
    }
}












#line 400 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

struct _Unused_parameter { 
    constexpr _Unused_parameter() noexcept = default;
    template <class _Ty>
    constexpr _Unused_parameter(_Ty&&) noexcept {}
};

template <class _Ty>
using _Algorithm_int_t = conditional_t<is_integral_v<_Ty>, _Ty, ptrdiff_t>;


template <class _Ty>
concept _Destructible_object = is_object_v<_Ty> && destructible<_Ty>;

template <template <class...> class _Template, class... _Args>
void _Derived_from_specialization_impl(const _Template<_Args...>&);

template <class _Ty, template <class...> class _Template>
concept _Derived_from_specialization_of =
    requires(const _Ty& _Obj) {
        ::std:: _Derived_from_specialization_impl<_Template>(_Obj); 
    };

namespace ranges {
    namespace _Iter_move {


#line 428 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        void iter_move();
#line 430 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

        
        template <class _Ty>
        concept _Has_ADL = _Has_class_or_enum_type<_Ty> && requires(_Ty&& __t) {
            iter_move(static_cast<_Ty&&>(__t)); 
        };

        template <class _Ty>
        concept _Can_deref = requires(_Ty&& __t) {
            *static_cast<_Ty&&>(__t);
        };
        

        class _Cpo {
        private:
            enum class _St { _None, _Custom, _Fallback };

            template <class _Ty>
            [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
                if constexpr (_Has_ADL<_Ty>) {
                    return {_St::_Custom, noexcept(iter_move(::std:: declval<_Ty>()))}; 
                } else if constexpr (_Can_deref<_Ty>) {
                    return {_St::_Fallback, noexcept(*::std:: declval<_Ty>())};
                } else {
                    return {_St::_None};
                }
            }

            template <class _Ty>
            static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();

        public:
            template <class _Ty>
                requires (_Choice<_Ty>._Strategy != _St::_None)
            [[nodiscard]] constexpr decltype(auto) operator()(_Ty&& _Val) const noexcept(_Choice<_Ty>._No_throw) {
                constexpr _St _Strat = _Choice<_Ty>._Strategy;

                if constexpr (_Strat == _St::_Custom) {
                    return iter_move(static_cast<_Ty&&>(_Val)); 
                } else if constexpr (_Strat == _St::_Fallback) {
                    using _Ref = decltype(*static_cast<_Ty&&>(_Val));
                    if constexpr (is_lvalue_reference_v<_Ref>) {
                        return ::std:: move(*static_cast<_Ty&&>(_Val));
                    } else {
                        return *static_cast<_Ty&&>(_Val);
                    }
                } else {
                    static_assert(_Always_false<_Ty>, "should be unreachable");
                }
            }
        };
    } 

    inline namespace _Cpos {
         inline constexpr _Iter_move::_Cpo iter_move;
    }
} 




 template <class _Ty>
    requires _Dereferenceable<_Ty> && requires(_Ty& __t) {
        { ::std::ranges:: iter_move(__t) } -> _Can_reference;
    }
using iter_rvalue_reference_t = decltype(::std::ranges:: iter_move(::std:: declval<_Ty&>()));

template <class _It>
concept _Indirectly_readable_impl = requires(const _It __i) {
    typename iter_value_t<_It>;
    typename iter_reference_t<_It>;
    typename iter_rvalue_reference_t<_It>;
    { *__i } -> same_as<iter_reference_t<_It>>;
    { ::std::ranges:: iter_move(__i) } -> same_as<iter_rvalue_reference_t<_It>>;
} && common_reference_with<iter_reference_t<_It>&&, iter_value_t<_It>&>
  && common_reference_with<iter_reference_t<_It>&&, iter_rvalue_reference_t<_It>&&>
  && common_reference_with<iter_rvalue_reference_t<_It>&&, const iter_value_t<_It>&>;

 template <class _It>
concept indirectly_readable = _Indirectly_readable_impl<remove_cvref_t<_It>>;


 template <indirectly_readable _Ty>
using iter_common_reference_t = common_reference_t<iter_reference_t<_Ty>, iter_value_t<_Ty>&>;

 template <class _It, class _Ty>
concept indirectly_writable =
    requires(_It && __i, _Ty&& __t) {
        *__i                                                                = static_cast<_Ty&&>(__t);
        *static_cast<_It&&>(__i)                                            = static_cast<_Ty&&>(__t);
        const_cast<const iter_reference_t<_It>&&>(*__i)                     = static_cast<_Ty&&>(__t);
        const_cast<const iter_reference_t<_It>&&>(*static_cast<_It&&>(__i)) = static_cast<_Ty&&>(__t);
    };

template <bool _Is_integer_class>
struct _Make_unsigned_like_impl {
    template <class _Ty>
    using _Apply = typename _Ty::_Unsigned_type;
};
template <>
struct _Make_unsigned_like_impl<false> {
    template <class _Ty>
    using _Apply = make_unsigned_t<_Ty>;
};

template <class _Ty>
using _Make_unsigned_like_t = typename _Make_unsigned_like_impl<_Integer_class<_Ty>>::template _Apply<_Ty>;

template <_Integer_like _Ty>
[[nodiscard]] constexpr auto _To_unsigned_like(const _Ty _Value) noexcept {
    return static_cast<_Make_unsigned_like_t<_Ty>>(_Value);
}

template <bool _Is_integer_class>
struct _Make_signed_like_impl {
    template <class _Ty>
    using _Apply = typename _Ty::_Signed_type;
};
template <>
struct _Make_signed_like_impl<false> {
    template <class _Ty>
    using _Apply = make_signed_t<_Ty>;
};

template <class _Ty>
using _Make_signed_like_t = typename _Make_signed_like_impl<_Integer_class<_Ty>>::template _Apply<_Ty>;

 template <class _Ty>
concept incrementable = regular<_Ty> && weakly_incrementable<_Ty> && requires(_Ty __t) {
                                                                         { __t++ } -> same_as<_Ty>;
                                                                     };

template <bool _Iterator_category_present>
struct _Iter_concept_impl2 {
    template <class _It, class _Traits>
    using _Apply = typename _Traits::iterator_category;
};
template <>
struct _Iter_concept_impl2<false> {
    template <class _It, class _Traits>
        requires _Is_from_primary<iterator_traits<_It>>
    using _Apply = random_access_iterator_tag;
};

template <bool _Iterator_concept_present>
struct _Iter_concept_impl1 {
    template <class _It, class _Traits>
    using _Apply = typename _Traits::iterator_concept;
};
template <>
struct _Iter_concept_impl1<false> {
    template <class _It, class _Traits>
    using _Apply = typename _Iter_concept_impl2<_Has_member_iterator_category<_Traits>>::template _Apply<_It, _Traits>;
};

template <class _It, class _Traits = conditional_t<_Is_from_primary<iterator_traits<_It>>, _It, iterator_traits<_It>>>
using _Iter_concept =
    typename _Iter_concept_impl1<_Has_member_iterator_concept<_Traits>>::template _Apply<_It, _Traits>;


 template <class _It>
concept input_iterator = input_or_output_iterator<_It> && indirectly_readable<_It>
    && requires { typename _Iter_concept<_It>; }
    && derived_from<_Iter_concept<_It>, input_iterator_tag>;

 template <class _It, class _Ty>
concept output_iterator = input_or_output_iterator<_It> && indirectly_writable<_It, _Ty>
    && requires(_It __i, _Ty&& __t) {
        *__i++ = static_cast<_Ty&&>(__t);
    };

 template <class _It>
concept forward_iterator = input_iterator<_It> && derived_from<_Iter_concept<_It>, forward_iterator_tag>
    && incrementable<_It> && sentinel_for<_It, _It>;

 template <class _It>
concept bidirectional_iterator = forward_iterator<_It> && derived_from<_Iter_concept<_It>, bidirectional_iterator_tag>
    && requires(_It __i) {
        { --__i } -> same_as<_It&>;
        { __i-- } -> same_as<_It>;
    };

 template <class _It>
concept random_access_iterator = bidirectional_iterator<_It>
    && derived_from<_Iter_concept<_It>, random_access_iterator_tag> && totally_ordered<_It>
    && sized_sentinel_for<_It, _It> && requires(_It __i, const _It __j, const iter_difference_t<_It> __n) {
        { __i += __n } -> same_as<_It&>;
        { __j + __n } -> same_as<_It>;
        { __n + __j } -> same_as<_It>;
        { __i -= __n } -> same_as<_It&>;
        { __j - __n } -> same_as<_It>;
        { __j[__n] } -> same_as<iter_reference_t<_It>>;
    };

 template <class _It>
concept contiguous_iterator = random_access_iterator<_It>
    && derived_from<_Iter_concept<_It>, contiguous_iterator_tag>
    && is_lvalue_reference_v<iter_reference_t<_It>>
    && same_as<iter_value_t<_It>, remove_cvref_t<iter_reference_t<_It>>>
    && requires(const _It& __i) {
        { ::std:: to_address(__i) } -> same_as<add_pointer_t<iter_reference_t<_It>>>;
    };

 template <class _Fn, class _It>
concept indirectly_unary_invocable = indirectly_readable<_It>
    && copy_constructible<_Fn>
    && invocable<_Fn&, iter_value_t<_It>&>
    && invocable<_Fn&, iter_reference_t<_It>>
    && invocable<_Fn&, iter_common_reference_t<_It>>
    && common_reference_with<
        invoke_result_t<_Fn&, iter_value_t<_It>&>,
        invoke_result_t<_Fn&, iter_reference_t<_It>>>;

 template <class _Fn, class _It>
concept indirectly_regular_unary_invocable = indirectly_readable<_It>
    && copy_constructible<_Fn>
    && regular_invocable<_Fn&, iter_value_t<_It>&>
    && regular_invocable<_Fn&, iter_reference_t<_It>>
    && regular_invocable<_Fn&, iter_common_reference_t<_It>>
    && common_reference_with<
        invoke_result_t<_Fn&, iter_value_t<_It>&>,
        invoke_result_t<_Fn&, iter_reference_t<_It>>>;

 template <class _Fn, class _It>
concept indirect_unary_predicate = indirectly_readable<_It>
    && copy_constructible<_Fn>
    && predicate<_Fn&, iter_value_t<_It>&>
    && predicate<_Fn&, iter_reference_t<_It>>
    && predicate<_Fn&, iter_common_reference_t<_It>>;

 template <class _Fn, class _It1, class _It2>
concept indirect_binary_predicate = indirectly_readable<_It1>
    && indirectly_readable<_It2>
    && copy_constructible<_Fn>
    && predicate<_Fn&, iter_value_t<_It1>&, iter_value_t<_It2>&>
    && predicate<_Fn&, iter_value_t<_It1>&, iter_reference_t<_It2>>
    && predicate<_Fn&, iter_reference_t<_It1>, iter_value_t<_It2>&>
    && predicate<_Fn&, iter_reference_t<_It1>, iter_reference_t<_It2>>
    && predicate<_Fn&, iter_common_reference_t<_It1>, iter_common_reference_t<_It2>>;

 template <class _Fn, class _It1, class _It2 = _It1>
concept indirect_equivalence_relation = indirectly_readable<_It1>
    && indirectly_readable<_It2>
    && copy_constructible<_Fn>
    && equivalence_relation<_Fn&, iter_value_t<_It1>&, iter_value_t<_It2>&>
    && equivalence_relation<_Fn&, iter_value_t<_It1>&, iter_reference_t<_It2>>
    && equivalence_relation<_Fn&, iter_reference_t<_It1>, iter_value_t<_It2>&>
    && equivalence_relation<_Fn&, iter_reference_t<_It1>, iter_reference_t<_It2>>
    && equivalence_relation<_Fn&, iter_common_reference_t<_It1>, iter_common_reference_t<_It2>>;

 template <class _Fn, class _It1, class _It2 = _It1>
concept indirect_strict_weak_order = indirectly_readable<_It1>
    && indirectly_readable<_It2>
    && copy_constructible<_Fn>
    && strict_weak_order<_Fn&, iter_value_t<_It1>&, iter_value_t<_It2>&>
    && strict_weak_order<_Fn&, iter_value_t<_It1>&, iter_reference_t<_It2>>
    && strict_weak_order<_Fn&, iter_reference_t<_It1>, iter_value_t<_It2>&>
    && strict_weak_order<_Fn&, iter_reference_t<_It1>, iter_reference_t<_It2>>
    && strict_weak_order<_Fn&, iter_common_reference_t<_It1>, iter_common_reference_t<_It2>>;

 template <class _Fn, class... _Its>
    requires (indirectly_readable<_Its> && ...)
        && invocable<_Fn, iter_reference_t<_Its>...>
using indirect_result_t = invoke_result_t<_Fn, iter_reference_t<_Its>...>;


 template <indirectly_readable _It, indirectly_regular_unary_invocable<_It> _Proj>
struct projected {
    using value_type = remove_cvref_t<indirect_result_t<_Proj&, _It>>;
    indirect_result_t<_Proj&, _It> operator*() const {
        :: abort();
    }
};

template <weakly_incrementable _It, class _Proj>
struct incrementable_traits<projected<_It, _Proj>> {
    using difference_type = iter_difference_t<_It>;
};

 template <class _In, class _Out>
concept indirectly_movable = indirectly_readable<_In> && indirectly_writable<_Out, iter_rvalue_reference_t<_In>>;


 template <class _In, class _Out>
concept indirectly_movable_storable = indirectly_movable<_In, _Out>
    && indirectly_writable<_Out, iter_value_t<_In>>
    && movable<iter_value_t<_In>>
    && constructible_from<iter_value_t<_In>, iter_rvalue_reference_t<_In>>
    && assignable_from<iter_value_t<_In>&, iter_rvalue_reference_t<_In> >;


 template <class _In, class _Out>
concept indirectly_copyable = indirectly_readable<_In> && indirectly_writable<_Out, iter_reference_t<_In>>;


 template <class _In, class _Out>
concept indirectly_copyable_storable = indirectly_copyable<_In, _Out>
    && indirectly_writable<_Out, iter_value_t<_In>&>
    && indirectly_writable<_Out, const iter_value_t<_In>&>
    && indirectly_writable<_Out, iter_value_t<_In>&&>
    && indirectly_writable<_Out, const iter_value_t<_In>&&>
    && copyable<iter_value_t<_In>>
    && constructible_from<iter_value_t<_In>, iter_reference_t<_In>>
    && assignable_from<iter_value_t<_In>&, iter_reference_t<_In>>;


namespace ranges {
    namespace _Iter_swap {
        template <class _Ty1, class _Ty2>
        void iter_swap(_Ty1, _Ty2) = delete;

        
        template <class _Ty1, class _Ty2>
        concept _Has_ADL = (_Has_class_or_enum_type<_Ty1> || _Has_class_or_enum_type<_Ty2>)
            && requires(_Ty1&& __t1, _Ty2&& __t2) {
                iter_swap(static_cast<_Ty1&&>(__t1), static_cast<_Ty2&&>(__t2)); 
            };

        template <class _Ty1, class _Ty2>
        concept _Can_swap_references = indirectly_readable<remove_reference_t<_Ty1>>
            && indirectly_readable<remove_reference_t<_Ty2>>
            && swappable_with<iter_reference_t<_Ty1>, iter_reference_t<_Ty2>>;

        template <class _Ty1, class _Ty2>
        concept _Symmetric_indirectly_movable_storable =
               indirectly_movable_storable<remove_reference_t<_Ty1>, remove_reference_t<_Ty2>>
            && indirectly_movable_storable<remove_reference_t<_Ty2>, remove_reference_t<_Ty1>>;
        

        template <class _Xty, class _Yty>
        [[nodiscard]] constexpr iter_value_t<remove_reference_t<_Xty>> _Iter_exchange_move(_Xty&& _XVal,
            _Yty&& _YVal) noexcept(noexcept(iter_value_t<remove_reference_t<_Xty>>(::std::ranges:: iter_move(_XVal)))) {
            iter_value_t<remove_reference_t<_Xty>> _Tmp(::std::ranges:: iter_move(_XVal));
            *_XVal = ::std::ranges:: iter_move(_YVal);
            return _Tmp;
        }

        class _Cpo {
        private:
            enum class _St { _None, _Custom, _Swap, _Exchange };

            template <class _Ty1, class _Ty2>
            [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
                if constexpr (_Has_ADL<_Ty1, _Ty2>) {
                    return {_St::_Custom,
                        noexcept(iter_swap(::std:: declval<_Ty1>(), ::std:: declval<_Ty2>()))}; 
                } else if constexpr (_Can_swap_references<_Ty1, _Ty2>) {
                    return {_St::_Swap, noexcept(::std::ranges:: swap(*::std:: declval<_Ty1>(), *::std:: declval<_Ty2>()))};
                } else if constexpr (_Symmetric_indirectly_movable_storable<_Ty1, _Ty2>) {
                    constexpr auto _Nothrow = noexcept(*::std:: declval<_Ty1>() = _Iter_swap::_Iter_exchange_move(
                                                           ::std:: declval<_Ty2>(), ::std:: declval<_Ty1>()));
                    return {_St::_Exchange, _Nothrow};
                } else {
                    return {_St::_None};
                }
            }

            template <class _Ty1, class _Ty2>
            static constexpr _Choice_t<_St> _Choice = _Choose<_Ty1, _Ty2>();

        public:
            template <class _Ty1, class _Ty2>
                requires (_Choice<_Ty1, _Ty2>._Strategy != _St::_None)
            constexpr void operator()(_Ty1&& _Val1, _Ty2&& _Val2) const noexcept(_Choice<_Ty1, _Ty2>._No_throw) {
                constexpr _St _Strat = _Choice<_Ty1, _Ty2>._Strategy;

                if constexpr (_Strat == _St::_Custom) {
                    (void) iter_swap(static_cast<_Ty1&&>(_Val1), static_cast<_Ty2&&>(_Val2)); 
                } else if constexpr (_Strat == _St::_Swap) {
                    ::std::ranges:: swap(*static_cast<_Ty1&&>(_Val1), *static_cast<_Ty2&&>(_Val2));
                } else if constexpr (_Strat == _St::_Exchange) {
                    *static_cast<_Ty1&&>(_Val1) =
                        _Iter_swap::_Iter_exchange_move(static_cast<_Ty2&&>(_Val2), static_cast<_Ty1&&>(_Val1));
                } else {
                    static_assert(_Always_false<_Ty1>, "should be unreachable");
                }
            }
        };
    } 

    inline namespace _Cpos {
         inline constexpr _Iter_swap::_Cpo iter_swap;
    }
} 


 template <class _It1, class _It2 = _It1>
concept indirectly_swappable = indirectly_readable<_It1> && indirectly_readable<_It2>
    && requires(const _It1 __i1, const _It2 __i2) {
        ::std::ranges:: iter_swap(__i1, __i1);
        ::std::ranges:: iter_swap(__i2, __i2);
        ::std::ranges:: iter_swap(__i1, __i2);
        ::std::ranges:: iter_swap(__i2, __i1);
    };


 template <class _It1, class _It2, class _Rel, class _Proj1 = identity, class _Proj2 = identity>
concept indirectly_comparable = indirect_binary_predicate<_Rel, projected<_It1, _Proj1>, projected<_It2, _Proj2>>;

 template <class _It>
concept permutable = forward_iterator<_It> && indirectly_movable_storable<_It, _It> && indirectly_swappable<_It, _It>;

namespace ranges {
     struct less;
} 

 template <class _It1, class _It2, class _Out, class _Pr = ranges::less, class _Pj1 = identity,
    class _Pj2 = identity>
concept mergeable = input_iterator<_It1> && input_iterator<_It2> 
                 && weakly_incrementable<_Out> 
                 && indirectly_copyable<_It1, _Out> 
                 && indirectly_copyable<_It2, _Out> 
                 && indirect_strict_weak_order<_Pr, projected<_It1, _Pj1>, projected<_It2, _Pj2>>;

 template <class _It, class _Pr = ranges::less, class _Proj = identity>
concept sortable = permutable<_It> && indirect_strict_weak_order<_Pr, projected<_It, _Proj>>;

template <class _Iter>
using _Iter_ref_t = iter_reference_t<_Iter>;

template <class _Iter>
using _Iter_value_t = iter_value_t<_Iter>;

template <class _Iter>
using _Iter_diff_t = iter_difference_t<_Iter>;













#line 869 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

template <class... _Iters>
using _Common_diff_t = common_type_t<_Iter_diff_t<_Iters>...>;

template <class _Iter>
using _Iter_cat_t = typename iterator_traits<_Iter>::iterator_category;

template <class _Ty, class = void>
inline constexpr bool _Is_iterator_v = false;

template <class _Ty>
inline constexpr bool _Is_iterator_v<_Ty, void_t<_Iter_cat_t<_Ty>>> = true;

template <class _Ty>
struct _Is_iterator : bool_constant<_Is_iterator_v<_Ty>> {};

template <class _Iter>
inline constexpr bool _Is_cpp17_input_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, input_iterator_tag>;

template <class _Iter>
inline constexpr bool _Is_ranges_input_iter_v =

    (input_iterator<_Iter> && sentinel_for<_Iter, _Iter>) ||
#line 893 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
    _Is_cpp17_input_iter_v<_Iter>;

template <class _Iter>
inline constexpr bool _Is_cpp17_fwd_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, forward_iterator_tag>;

template <class _Iter>
inline constexpr bool _Is_ranges_fwd_iter_v =

    forward_iterator<_Iter> ||
#line 903 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
    _Is_cpp17_fwd_iter_v<_Iter>;

template <class _Iter>
inline constexpr bool _Is_cpp17_bidi_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, bidirectional_iterator_tag>;

template <class _Iter>
inline constexpr bool _Is_ranges_bidi_iter_v =

    bidirectional_iterator<_Iter> ||
#line 913 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
    _Is_cpp17_bidi_iter_v<_Iter>;

template <class _Iter>
inline constexpr bool _Is_cpp17_random_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, random_access_iterator_tag>;

template <class _Iter>
inline constexpr bool _Is_ranges_random_iter_v =

    random_access_iterator<_Iter> ||
#line 923 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
    _Is_cpp17_random_iter_v<_Iter>;





template <class, class = void>
struct _Is_checked_helper {}; 







#line 939 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

template <class _Iter, class = void>
inline constexpr bool _Allow_inheriting_unwrap_v = true;

template <class _Iter>
inline constexpr bool _Allow_inheriting_unwrap_v<_Iter, void_t<typename _Iter::_Prevent_inheriting_unwrap>> =
    is_same_v<_Iter, typename _Iter::_Prevent_inheriting_unwrap>;

template <class _Iter, class _Sentinel = _Iter, class = void>
inline constexpr bool _Range_verifiable_v = false;

template <class _Iter, class _Sentinel>
inline constexpr bool _Range_verifiable_v<_Iter, _Sentinel,
    void_t<decltype(_Verify_range(::std:: declval<const _Iter&>(), ::std:: declval<const _Sentinel&>()))>> =
    _Allow_inheriting_unwrap_v<_Iter>;

template <class _Iter, class _Sentinel>
constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {
    
    if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
        _Verify_range(_First, _Last);
    }
}

template <class _Iter, class = void>
inline constexpr bool _Unwrappable_v = false;

template <class _Iter>
inline constexpr bool _Unwrappable_v<_Iter,
    void_t<decltype(::std:: declval<_Remove_cvref_t<_Iter>&>()._Seek_to(::std:: declval<_Iter>()._Unwrapped()))>> =
    _Allow_inheriting_unwrap_v<_Remove_cvref_t<_Iter>>;

template <class _Iter, class = void>
inline constexpr bool _Has_nothrow_unwrapped = false;
template <class _Iter>
inline constexpr bool _Has_nothrow_unwrapped<_Iter, void_t<decltype(::std:: declval<_Iter>()._Unwrapped())>> =
    noexcept(::std:: declval<_Iter>()._Unwrapped());

template <class _Iter>
[[nodiscard]] constexpr decltype(auto) _Get_unwrapped(_Iter&& _It) noexcept(
    !_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {
    
    if constexpr (is_pointer_v<decay_t<_Iter>>) { 
        return _It + 0;
    } else if constexpr (_Unwrappable_v<_Iter>) {
        return static_cast<_Iter&&>(_It)._Unwrapped();
    } else {
        return static_cast<_Iter&&>(_It);
    }
}

template <class _Iter>
using _Unwrapped_t = _Remove_cvref_t<decltype(_Get_unwrapped(::std:: declval<_Iter>()))>;

template <class _Iter, class = bool>
inline constexpr bool _Do_unwrap_when_unverified_v = false;

template <class _Iter>
inline constexpr bool
    _Do_unwrap_when_unverified_v<_Iter, decltype(static_cast<bool>(_Iter::_Unwrap_when_unverified))> =
        static_cast<bool>(_Iter::_Unwrap_when_unverified);

template <class _Iter>
inline constexpr bool _Unwrappable_for_unverified_v =
    _Unwrappable_v<_Iter> && _Do_unwrap_when_unverified_v<_Remove_cvref_t<_Iter>>;

template <class _Iter>
[[nodiscard]] constexpr decltype(auto) _Get_unwrapped_unverified(_Iter&& _It) {
    
    if constexpr (is_pointer_v<decay_t<_Iter>>) { 
        return _It + 0;
    } else if constexpr (_Unwrappable_for_unverified_v<_Iter>) {
        return static_cast<_Iter&&>(_It)._Unwrapped();
    } else {
        return static_cast<_Iter&&>(_It);
    }
}

template <class _Iter>
using _Unwrapped_unverified_t = _Remove_cvref_t<decltype(_Get_unwrapped_unverified(::std:: declval<_Iter>()))>;

struct _Distance_unknown {
    constexpr _Distance_unknown operator-() const noexcept {
        return {};
    }
};

template <class _Diff>
inline constexpr _Diff _Max_possible_v{static_cast<_Make_unsigned_like_t<_Diff>>(-1) >> 1};

template <class _Diff>
inline constexpr _Diff _Min_possible_v{-_Max_possible_v<_Diff> - 1};

template <class _Iter, class = void>
inline constexpr bool _Offset_verifiable_v = false;

template <class _Iter>
inline constexpr bool
    _Offset_verifiable_v<_Iter, void_t<decltype(::std:: declval<const _Iter&>()._Verify_offset(_Iter_diff_t<_Iter>{}))>> =
        true;

template <class _Iter>
inline constexpr bool _Unwrappable_for_offset_v =
    _Unwrappable_v<_Iter> && _Offset_verifiable_v<_Remove_cvref_t<_Iter>>;

template <class _Iter, class _Diff>
[[nodiscard]] constexpr decltype(auto) _Get_unwrapped_n(_Iter&& _It, const _Diff _Off) {
    if constexpr (is_pointer_v<decay_t<_Iter>>) {
        return _It + 0;
    } else if constexpr (_Unwrappable_for_offset_v<_Iter> && is_integral_v<_Diff>) {
        
        using _IDiff     = _Iter_diff_t<_Remove_cvref_t<_Iter>>;
        using _CDiff     = common_type_t<_Diff, _IDiff>;
        const auto _COff = static_cast<_CDiff>(_Off);

        

;
        (void) _COff;

        _It._Verify_offset(static_cast<_IDiff>(_Off));
        return static_cast<_Iter&&>(_It)._Unwrapped();
    } else if constexpr (_Unwrappable_for_unverified_v<_Iter>) {
        
        return static_cast<_Iter&&>(_It)._Unwrapped();
    } else {
        
        return static_cast<_Iter&&>(_It);
    }
}

template <class _Iter, class _UIter, class = void>
inline constexpr bool _Wrapped_seekable_v = false;

template <class _Iter, class _UIter>
inline constexpr bool
    _Wrapped_seekable_v<_Iter, _UIter, void_t<decltype(::std:: declval<_Iter&>()._Seek_to(::std:: declval<_UIter>()))>> =
        true;

template <class _Iter, class _UIter>
constexpr void _Seek_wrapped(_Iter& _It, _UIter&& _UIt) {
    if constexpr (_Wrapped_seekable_v<_Iter, _UIter>) {
        _It._Seek_to(::std:: forward<_UIter>(_UIt));
    } else {
        _It = ::std:: forward<_UIter>(_UIt);
    }
}


template <class _Ty, class = void>
struct _Is_allocator : false_type {}; 

template <class _Ty>
struct _Is_allocator<_Ty, void_t<typename _Ty::value_type, decltype(::std:: declval<_Ty&>().deallocate(
                                                               ::std:: declval<_Ty&>().allocate(size_t{1}), size_t{1}))>>
    : true_type {}; 


template <class _Iter>
using _Guide_key_t = remove_const_t<typename iterator_traits<_Iter>::value_type::first_type>;

template <class _Iter>
using _Guide_val_t = typename iterator_traits<_Iter>::value_type::second_type;

template <class _Iter>
using _Guide_pair_t = pair<add_const_t<typename iterator_traits<_Iter>::value_type::first_type>,
    typename iterator_traits<_Iter>::value_type::second_type>;

 template <class _Ty>
struct is_execution_policy : false_type {};

 template <class _Ty>
inline constexpr bool is_execution_policy_v = is_execution_policy<_Ty>::value;



template <class _ExPo>
using _Enable_if_execution_policy_t = typename remove_reference_t<_ExPo>::_Standard_execution_policy;




#line 1122 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

template <class _Checked, class _Iter>
[[nodiscard]] constexpr auto _Idl_distance(const _Iter& _First, const _Iter& _Last) {
    
    if constexpr (_Is_ranges_random_iter_v<_Iter>) {
        return static_cast<_Iter_diff_t<_Checked>>(_Last - _First);
    } else {
        return _Distance_unknown{};
    }
}

template <class _Elem, bool _Is_enum = is_enum_v<_Elem>>
struct _Unwrap_enum { 
    using type = underlying_type_t<_Elem>;
};

template <class _Elem>
struct _Unwrap_enum<_Elem, false> { 
    using type = _Elem;
};

template <class _Elem>
using _Unwrap_enum_t = typename _Unwrap_enum<_Elem>::type;



















































#line 1197 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"


 template <class _InIt, class _Diff>
constexpr void advance(_InIt& _Where, _Diff _Off) { 
    if constexpr (_Is_ranges_random_iter_v<_InIt>) {
        _Where += _Off;
    } else {
        if constexpr (is_signed_v<_Diff> && !_Is_ranges_bidi_iter_v<_InIt>) {
             ;
        }

        decltype(auto) _UWhere      = _Get_unwrapped_n(::std:: move(_Where), _Off);
        constexpr bool _Need_rewrap = !is_reference_v<decltype(_Get_unwrapped_n(::std:: move(_Where), _Off))>;

        if constexpr (is_signed_v<_Diff> && _Is_ranges_bidi_iter_v<_InIt>) {
            for (; _Off < 0; ++_Off) {
                --_UWhere;
            }
        }

        for (; 0 < _Off; --_Off) {
            ++_UWhere;
        }

        if constexpr (_Need_rewrap) {
            _Seek_wrapped(_Where, ::std:: move(_UWhere));
        }
    }
}

 template <class _InIt>
[[nodiscard]] constexpr _Iter_diff_t<_InIt> distance(_InIt _First, _InIt _Last) {
    if constexpr (_Is_ranges_random_iter_v<_InIt>) {
        return _Last - _First; 
    } else {
        _Adl_verify_range(_First, _Last);
        auto _UFirst             = _Get_unwrapped(_First);
        const auto _ULast        = _Get_unwrapped(_Last);
        _Iter_diff_t<_InIt> _Off = 0;
        for (; _UFirst != _ULast; ++_UFirst) {
            ++_Off;
        }

        return _Off;
    }
}

template <class _InIt>
constexpr _InIt _Next_iter(_InIt _First) { 
    return ++_First;
}

 template <class _InIt>
[[nodiscard]] constexpr _InIt next(_InIt _First, _Iter_diff_t<_InIt> _Off = 1) { 
    static_assert(_Is_ranges_input_iter_v<_InIt>, "next requires input iterator");

    ::std:: advance(_First, _Off);
    return _First;
}

template <class _BidIt>
constexpr _BidIt _Prev_iter(_BidIt _First) { 
    return --_First;
}

 template <class _BidIt>
[[nodiscard]] constexpr _BidIt prev(_BidIt _First, _Iter_diff_t<_BidIt> _Off = 1) { 
    static_assert(_Is_ranges_bidi_iter_v<_BidIt>, "prev requires bidirectional iterator");

    ::std:: advance(_First, -_Off);
    return _First;
}

template <class _Iter, class _Pointer, bool = is_pointer_v<_Remove_cvref_t<_Iter>>>
inline constexpr bool _Has_nothrow_operator_arrow = _Is_nothrow_convertible_v<_Iter, _Pointer>;

template <class _Iter, class _Pointer>
inline constexpr bool _Has_nothrow_operator_arrow<_Iter, _Pointer, false> =
    noexcept(_Fake_copy_init<_Pointer>(::std:: declval<_Iter>().operator->()));

 template <class _BidIt>
class reverse_iterator {
public:
    using iterator_type = _BidIt;


    using iterator_concept =
        conditional_t<random_access_iterator<_BidIt>, random_access_iterator_tag, bidirectional_iterator_tag>;
    using iterator_category = conditional_t<derived_from<_Iter_cat_t<_BidIt>, random_access_iterator_tag>,
        random_access_iterator_tag, _Iter_cat_t<_BidIt>>;


#line 1290 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
    using value_type      = _Iter_value_t<_BidIt>;
    using difference_type = _Iter_diff_t<_BidIt>;
    using pointer         = typename iterator_traits<_BidIt>::pointer;
    using reference       = _Iter_ref_t<_BidIt>;

    template <class>
    friend class reverse_iterator;

    constexpr reverse_iterator() = default;

    constexpr explicit reverse_iterator(_BidIt _Right) noexcept(
        is_nothrow_move_constructible_v<_BidIt>) 
        : current(::std:: move(_Right)) {}

    
    template <class _Other>

        requires (!is_same_v<_Other, _BidIt>) && convertible_to<const _Other&, _BidIt>
#line 1309 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
    constexpr reverse_iterator(const reverse_iterator<_Other>& _Right) noexcept(
        is_nothrow_constructible_v<_BidIt, const _Other&>) 
        : current(_Right.current) {}

    template <class _Other>

        requires (!is_same_v<_Other, _BidIt>) && convertible_to<const _Other&, _BidIt>
            && assignable_from<_BidIt&, const _Other&>
#line 1318 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
    constexpr reverse_iterator& operator=(const reverse_iterator<_Other>& _Right) noexcept(
        is_nothrow_assignable_v<_BidIt&, const _Other&>)   {
        current = _Right.current;
        return *this;
    }
    

    [[nodiscard]] constexpr _BidIt base() const noexcept(is_nothrow_copy_constructible_v<_BidIt>)   {
        return current;
    }

    [[nodiscard]] constexpr reference operator*() const
        noexcept(is_nothrow_copy_constructible_v<_BidIt>&& noexcept(*--(::std:: declval<_BidIt&>())))   {
        _BidIt _Tmp = current;
        return *--_Tmp;
    }

    [[nodiscard]] constexpr pointer operator->() const
        noexcept(is_nothrow_copy_constructible_v<_BidIt>&& noexcept(--(::std:: declval<_BidIt&>()))
                 && _Has_nothrow_operator_arrow<_BidIt&, pointer>)  

        requires (is_pointer_v<_BidIt> || requires(const _BidIt __i) { __i.operator->(); })
#line 1341 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
    {
        _BidIt _Tmp = current;
        --_Tmp;
        if constexpr (is_pointer_v<_BidIt>) {
            return _Tmp;
        } else {
            return _Tmp.operator->();
        }
    }

    constexpr reverse_iterator& operator++() noexcept(noexcept(--current))   {
        --current;
        return *this;
    }

    constexpr reverse_iterator operator++(int) noexcept(
        is_nothrow_copy_constructible_v<_BidIt>&& noexcept(--current))   {
        reverse_iterator _Tmp = *this;
        --current;
        return _Tmp;
    }

    constexpr reverse_iterator& operator--() noexcept(noexcept(++current))   {
        ++current;
        return *this;
    }

    constexpr reverse_iterator operator--(int) noexcept(
        is_nothrow_copy_constructible_v<_BidIt>&& noexcept(++current))   {
        reverse_iterator _Tmp = *this;
        ++current;
        return _Tmp;
    }

    [[nodiscard]] constexpr reverse_iterator operator+(const difference_type _Off) const
        noexcept(noexcept(reverse_iterator(current - _Off)))   {
        return reverse_iterator(current - _Off);
    }

    constexpr reverse_iterator& operator+=(const difference_type _Off) noexcept(
        noexcept(current -= _Off))   {
        current -= _Off;
        return *this;
    }

    [[nodiscard]] constexpr reverse_iterator operator-(const difference_type _Off) const
        noexcept(noexcept(reverse_iterator(current + _Off)))   {
        return reverse_iterator(current + _Off);
    }

    constexpr reverse_iterator& operator-=(const difference_type _Off) noexcept(
        noexcept(current += _Off))   {
        current += _Off;
        return *this;
    }

    [[nodiscard]] constexpr reference operator[](const difference_type _Off) const
        noexcept(noexcept(_Fake_copy_init<reference>(current[_Off])))   {
        return current[static_cast<difference_type>(-_Off - 1)];
    }


    [[nodiscard]] friend constexpr iter_rvalue_reference_t<_BidIt> iter_move(const reverse_iterator& _It) noexcept(
        is_nothrow_copy_constructible_v<_BidIt>&& noexcept(::std::ranges:: iter_move(--::std:: declval<_BidIt&>()))) {
        auto _Tmp = _It.current;
        --_Tmp;
        return ::std::ranges:: iter_move(_Tmp);
    }

    template <indirectly_swappable<_BidIt> _BidIt2>
    friend constexpr void iter_swap(const reverse_iterator& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
        is_nothrow_copy_constructible_v<_BidIt>&& is_nothrow_copy_constructible_v<_BidIt2>&& noexcept(
            ::std::ranges:: iter_swap(--::std:: declval<_BidIt&>(), --::std:: declval<_BidIt2&>()))) {
        auto _LTmp = _Left.current;
        auto _RTmp = _Right.base();
        --_LTmp;
        --_RTmp;
        ::std::ranges:: iter_swap(_LTmp, _RTmp);
    }
#line 1421 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

    using _Prevent_inheriting_unwrap = reverse_iterator;

    template <class _BidIt2, enable_if_t<_Range_verifiable_v<_BidIt, _BidIt2>, int> = 0>
    friend constexpr void _Verify_range(
        const reverse_iterator& _First, const reverse_iterator<_BidIt2>& _Last) noexcept {
        _Verify_range(_Last._Get_current(), _First.current); 
    }

    template <class _BidIt2 = _BidIt, enable_if_t<_Offset_verifiable_v<_BidIt2>, int> = 0>
    constexpr void _Verify_offset(const difference_type _Off) const noexcept {
        do { if (_Off != _Min_possible_v<difference_type>) { } else { do {; ::_invalid_parameter_noinfo_noreturn(); } while (false); }; } while (false) ;
        current._Verify_offset(-_Off);
    }

    template <class _BidIt2 = _BidIt, enable_if_t<_Unwrappable_v<const _BidIt2&>, int> = 0>
    [[nodiscard]] constexpr reverse_iterator<_Unwrapped_t<const _BidIt2&>> _Unwrapped() const& noexcept(
        noexcept(static_cast<reverse_iterator<_Unwrapped_t<const _BidIt2&>>>(current._Unwrapped()))) {
        return static_cast<reverse_iterator<_Unwrapped_t<const _BidIt2&>>>(current._Unwrapped());
    }
    template <class _BidIt2 = _BidIt, enable_if_t<_Unwrappable_v<_BidIt2>, int> = 0>
    [[nodiscard]] constexpr reverse_iterator<_Unwrapped_t<_BidIt2>> _Unwrapped() && noexcept(
        noexcept(static_cast<reverse_iterator<_Unwrapped_t<_BidIt2>>>(::std:: move(current)._Unwrapped()))) {
        return static_cast<reverse_iterator<_Unwrapped_t<_BidIt2>>>(::std:: move(current)._Unwrapped());
    }

    static constexpr bool _Unwrap_when_unverified = _Do_unwrap_when_unverified_v<_BidIt>;

    template <class _Src, enable_if_t<_Wrapped_seekable_v<_BidIt, const _Src&>, int> = 0>
    constexpr void _Seek_to(const reverse_iterator<_Src>& _It) noexcept(noexcept(current._Seek_to(_It.current))) {
        current._Seek_to(_It.current);
    }

    [[nodiscard]] constexpr const _BidIt& _Get_current() const noexcept {
        return current;
    }

protected:
    _BidIt current{};
};

 template <class _BidIt1, class _BidIt2>
[[nodiscard]] constexpr bool
    operator==(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
        noexcept(_Fake_copy_init<bool>(_Left._Get_current() == _Right._Get_current())))  

    
    requires requires {
        { _Left._Get_current() == _Right._Get_current() } -> _Implicitly_convertible_to<bool>;
    }

#line 1473 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
{
    return _Left._Get_current() == _Right._Get_current();
}

 template <class _BidIt1, class _BidIt2>
[[nodiscard]] constexpr bool
    operator!=(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
        noexcept(_Fake_copy_init<bool>(_Left._Get_current() != _Right._Get_current())))  

    
    requires requires {
        { _Left._Get_current() != _Right._Get_current() } -> _Implicitly_convertible_to<bool>;
    }

#line 1488 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
{
    return _Left._Get_current() != _Right._Get_current();
}

 template <class _BidIt1, class _BidIt2>
[[nodiscard]] constexpr bool
    operator<(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
        noexcept(_Fake_copy_init<bool>(_Left._Get_current() > _Right._Get_current())))  

    
    requires requires {
        { _Left._Get_current() > _Right._Get_current() } -> _Implicitly_convertible_to<bool>;
    }

#line 1503 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
{
    return _Left._Get_current() > _Right._Get_current();
}

 template <class _BidIt1, class _BidIt2>
[[nodiscard]] constexpr bool
    operator>(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
        noexcept(_Fake_copy_init<bool>(_Left._Get_current() < _Right._Get_current())))  

    
    requires requires {
        { _Left._Get_current() < _Right._Get_current() } -> _Implicitly_convertible_to<bool>;
    }

#line 1518 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
{
    return _Left._Get_current() < _Right._Get_current();
}

 template <class _BidIt1, class _BidIt2>
[[nodiscard]] constexpr bool
    operator<=(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
        noexcept(_Fake_copy_init<bool>(_Left._Get_current() >= _Right._Get_current())))  

    
    requires requires {
        { _Left._Get_current() >= _Right._Get_current() } -> _Implicitly_convertible_to<bool>;
    }

#line 1533 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
{
    return _Left._Get_current() >= _Right._Get_current();
}

 template <class _BidIt1, class _BidIt2>
[[nodiscard]] constexpr bool
    operator>=(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
        noexcept(_Fake_copy_init<bool>(_Left._Get_current() <= _Right._Get_current())))  

    
    requires requires {
        { _Left._Get_current() <= _Right._Get_current() } -> _Implicitly_convertible_to<bool>;
    }

#line 1548 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
{
    return _Left._Get_current() <= _Right._Get_current();
}


 template <class _BidIt1, three_way_comparable_with<_BidIt1> _BidIt2>
[[nodiscard]] constexpr compare_three_way_result_t<_BidIt1, _BidIt2>
    operator<=>(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
        noexcept(_Right._Get_current() <=> _Left._Get_current()))   {
    return _Right._Get_current() <=> _Left._Get_current();
}
#line 1560 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

 template <class _BidIt1, class _BidIt2>
[[nodiscard]] constexpr auto
    operator-(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
        noexcept(_Right._Get_current() - _Left._Get_current()))  
    -> decltype(_Right._Get_current() - _Left._Get_current()) {
    return _Right._Get_current() - _Left._Get_current();
}

 template <class _BidIt>
[[nodiscard]] constexpr reverse_iterator<_BidIt> operator+(typename reverse_iterator<_BidIt>::difference_type _Off,
    const reverse_iterator<_BidIt>& _Right) noexcept(noexcept(_Right + _Off))   {
    return _Right + _Off;
}

 template <class _BidIt>
[[nodiscard]] constexpr reverse_iterator<_BidIt> make_reverse_iterator(_BidIt _Iter) noexcept(
    is_nothrow_move_constructible_v<_BidIt>)   {
    return reverse_iterator<_BidIt>(::std:: move(_Iter));
}


template <class _BidIt1, class _BidIt2>
    requires (!sized_sentinel_for<_BidIt1, _BidIt2>)
inline constexpr bool disable_sized_sentinel_for<reverse_iterator<_BidIt1>, reverse_iterator<_BidIt2>> = true;
#line 1586 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

 template <class _Container>
[[nodiscard]] constexpr auto begin(_Container& _Cont) noexcept(noexcept(_Cont.begin()))  
    -> decltype(_Cont.begin()) {
    return _Cont.begin();
}

 template <class _Container>
[[nodiscard]] constexpr auto begin(const _Container& _Cont) noexcept(noexcept(_Cont.begin()))  
    -> decltype(_Cont.begin()) {
    return _Cont.begin();
}

 template <class _Container>
[[nodiscard]] constexpr auto end(_Container& _Cont) noexcept(noexcept(_Cont.end()))  
    -> decltype(_Cont.end()) {
    return _Cont.end();
}

 template <class _Container>
[[nodiscard]] constexpr auto end(const _Container& _Cont) noexcept(noexcept(_Cont.end()))  
    -> decltype(_Cont.end()) {
    return _Cont.end();
}

 template <class _Ty, size_t _Size>
[[nodiscard]] constexpr _Ty* begin(_Ty (&_Array)[_Size]) noexcept {
    return _Array;
}

 template <class _Ty, size_t _Size>
[[nodiscard]] constexpr _Ty* end(_Ty (&_Array)[_Size]) noexcept {
    return _Array + _Size;
}

 template <class _Container>
[[nodiscard]] constexpr auto cbegin(const _Container& _Cont) noexcept(noexcept(::std:: begin(_Cont)))
    -> decltype(::std:: begin(_Cont)) {
    return ::std:: begin(_Cont);
}

 template <class _Container>
[[nodiscard]] constexpr auto cend(const _Container& _Cont) noexcept(noexcept(::std:: end(_Cont)))
    -> decltype(::std:: end(_Cont)) {
    return ::std:: end(_Cont);
}

 template <class _Container>
[[nodiscard]] constexpr auto rbegin(_Container& _Cont) noexcept(noexcept(_Cont.rbegin()))  
    -> decltype(_Cont.rbegin()) {
    return _Cont.rbegin();
}

 template <class _Container>
[[nodiscard]] constexpr auto rbegin(const _Container& _Cont) noexcept(noexcept(_Cont.rbegin()))  
    -> decltype(_Cont.rbegin()) {
    return _Cont.rbegin();
}

 template <class _Container>
[[nodiscard]] constexpr auto rend(_Container& _Cont) noexcept(noexcept(_Cont.rend()))  
    -> decltype(_Cont.rend()) {
    return _Cont.rend();
}

 template <class _Container>
[[nodiscard]] constexpr auto rend(const _Container& _Cont) noexcept(noexcept(_Cont.rend()))  
    -> decltype(_Cont.rend()) {
    return _Cont.rend();
}

 template <class _Ty, size_t _Size>
[[nodiscard]] constexpr reverse_iterator<_Ty*> rbegin(_Ty (&_Array)[_Size]) noexcept   {
    return reverse_iterator<_Ty*>(_Array + _Size);
}

 template <class _Ty, size_t _Size>
[[nodiscard]] constexpr reverse_iterator<_Ty*> rend(_Ty (&_Array)[_Size]) noexcept   {
    return reverse_iterator<_Ty*>(_Array);
}

 template <class _Elem>
[[nodiscard]] constexpr reverse_iterator<const _Elem*> rbegin(initializer_list<_Elem> _Ilist) noexcept
  {
    return reverse_iterator<const _Elem*>(_Ilist.end());
}

 template <class _Elem>
[[nodiscard]] constexpr reverse_iterator<const _Elem*> rend(initializer_list<_Elem> _Ilist) noexcept
  {
    return reverse_iterator<const _Elem*>(_Ilist.begin());
}

 template <class _Container>
[[nodiscard]] constexpr auto crbegin(const _Container& _Cont) noexcept(noexcept(::std:: rbegin(_Cont)))  
    -> decltype(::std:: rbegin(_Cont)) {
    return ::std:: rbegin(_Cont);
}

 template <class _Container>
[[nodiscard]] constexpr auto crend(const _Container& _Cont) noexcept(noexcept(::std:: rend(_Cont)))  
    -> decltype(::std:: rend(_Cont)) {
    return ::std:: rend(_Cont);
}

 template <class _Container>
[[nodiscard]] constexpr auto size(const _Container& _Cont) noexcept(noexcept(_Cont.size()))  
    -> decltype(_Cont.size()) {
    return _Cont.size();
}

 template <class _Ty, size_t _Size>
[[nodiscard]] constexpr size_t size(const _Ty (&)[_Size]) noexcept {
    return _Size;
}


 template <class _Container>
[[nodiscard]] constexpr auto ssize(const _Container& _Cont) noexcept(noexcept(
    static_cast<common_type_t<ptrdiff_t, make_signed_t<decltype(_Cont.size())>>>(_Cont.size())))  
    -> common_type_t<ptrdiff_t, make_signed_t<decltype(_Cont.size())>> {
    using _Common = common_type_t<ptrdiff_t, make_signed_t<decltype(_Cont.size())>>;
    return static_cast<_Common>(_Cont.size());
}

 template <class _Ty, ptrdiff_t _Size>
[[nodiscard]] constexpr ptrdiff_t ssize(const _Ty (&)[_Size]) noexcept {
    return _Size;
}
#line 1716 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

 template <class _Container>
[[nodiscard("This function returns a bool indicating whether the container or container-like object is empty and " "has no other effects. It is not useful to call this function and discard the return value.")]] constexpr auto empty(const _Container& _Cont) noexcept(
    noexcept(_Cont.empty()))  
    -> decltype(_Cont.empty()) {
    return _Cont.empty();
}

 template <class _Ty, size_t _Size>
[[nodiscard("This function returns a bool indicating whether the container or container-like object is empty and " "has no other effects. It is not useful to call this function and discard the return value.")]] constexpr bool empty(const _Ty (&)[_Size]) noexcept {
    return false;
}

 template <class _Elem>
[[nodiscard("This function returns a bool indicating whether the container or container-like object is empty and " "has no other effects. It is not useful to call this function and discard the return value.")]] constexpr bool empty(initializer_list<_Elem> _Ilist) noexcept {
    return _Ilist.size() == 0;
}

 template <class _Container>
[[nodiscard]] constexpr auto data(_Container& _Cont) noexcept(noexcept(_Cont.data()))  
    -> decltype(_Cont.data()) {
    return _Cont.data();
}

 template <class _Container>
[[nodiscard]] constexpr auto data(const _Container& _Cont) noexcept(noexcept(_Cont.data()))  
    -> decltype(_Cont.data()) {
    return _Cont.data();
}

 template <class _Ty, size_t _Size>
[[nodiscard]] constexpr _Ty* data(_Ty (&_Array)[_Size]) noexcept {
    return _Array;
}

 template <class _Elem>
[[nodiscard]] constexpr const _Elem* data(initializer_list<_Elem> _Ilist) noexcept {
    return _Ilist.begin();
}















































































































































































































































































































































#line 2091 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

namespace ranges {
    template <class>
    inline constexpr bool _Has_complete_elements = false;

    template <class _Ty>
        requires requires(_Ty& __t) { sizeof(__t[0]); }
    inline constexpr bool _Has_complete_elements<_Ty> = true;

     template <class>
    inline constexpr bool enable_borrowed_range = false;

    template <class _Rng>
    concept _Should_range_access = is_lvalue_reference_v<_Rng> || enable_borrowed_range<remove_cvref_t<_Rng>>;

    namespace _Begin {


#line 2110 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        void begin();
#line 2112 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

        template <class _Ty>
        concept _Has_member = requires(_Ty __t) {
                                  { _Fake_copy_init(__t.begin()) } -> input_or_output_iterator;
                              };

        template <class _Ty>
        concept _Has_ADL = _Has_class_or_enum_type<_Ty> 
                        && requires(_Ty __t) {
                               { _Fake_copy_init(begin(__t)) } -> input_or_output_iterator; 
                           };

        class _Cpo {
        private:
            enum class _St { _None, _Array, _Member, _Non_member };

            template <class _Ty>
            [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
                 ;
                if constexpr (is_array_v<remove_reference_t<_Ty>>) {
                    static_assert(_Has_complete_elements<_Ty>,
                        "The range access customization point objects "
                        "std::ranges::begin, std::ranges::end, std::ranges::rbegin, std::ranges::rend, "
                        "and std::ranges::data do not accept arrays with incomplete element types.");
                    return {_St::_Array, true};
                } else if constexpr (_Has_member<_Ty>) {
                    return {_St::_Member, noexcept(_Fake_copy_init(::std:: declval<_Ty>().begin()))};
                } else if constexpr (_Has_ADL<_Ty>) {
                    return {_St::_Non_member, noexcept(_Fake_copy_init(begin(::std:: declval<_Ty>())))}; 
                } else {
                    return {_St::_None};
                }
            }

            template <class _Ty>
            static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();

        public:
            template <_Should_range_access _Ty>
                requires (_Choice<_Ty&>._Strategy != _St::_None)
            [[nodiscard]] constexpr auto operator()(_Ty&& _Val) const noexcept(_Choice<_Ty&>._No_throw) {
                constexpr _St _Strat = _Choice<_Ty&>._Strategy;

                if constexpr (_Strat == _St::_Array) {
                    return _Val;
                } else if constexpr (_Strat == _St::_Member) {
                    return _Val.begin();
                } else if constexpr (_Strat == _St::_Non_member) {
                    return begin(_Val); 
                } else {
                    static_assert(_Always_false<_Ty>, "Should be unreachable");
                }
            }
        };
    } 

    inline namespace _Cpos {
         inline constexpr _Begin::_Cpo begin;
    }

     template <class _Ty>
    using iterator_t = decltype(::std::ranges:: begin(::std:: declval<_Ty&>()));

    namespace _End {


#line 2179 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        void end();
#line 2181 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

        template <class _Ty>
        concept _Has_member = requires(_Ty __t) {
                                  { _Fake_copy_init(__t.end()) } -> sentinel_for<iterator_t<_Ty>>;
                              };

        template <class _Ty>
        concept _Has_ADL = _Has_class_or_enum_type<_Ty> 
                        && requires(_Ty __t) {
                               { _Fake_copy_init(end(__t)) } -> sentinel_for<iterator_t<_Ty>>; 
                           };

        class _Cpo {
        private:
            enum class _St { _None, _Array, _Member, _Non_member };

            template <class _Ty>
            [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
                 ;
                using _UnRef = remove_reference_t<_Ty>;

                if constexpr (is_array_v<_UnRef>) {
                    static_assert(_Has_complete_elements<_UnRef>,
                        "The range access customization point objects "
                        "std::ranges::begin, std::ranges::end, std::ranges::rbegin, std::ranges::rend, "
                        "and std::ranges::data do not accept arrays with incomplete element types.");
                    if constexpr (extent_v<_UnRef> != 0) {
                        return {_St::_Array, true};
                    } else {
                        return {_St::_None};
                    }
                } else if constexpr (_Has_member<_Ty>) {
                    return {_St::_Member, noexcept(_Fake_copy_init(::std:: declval<_Ty>().end()))};
                } else if constexpr (_Has_ADL<_Ty>) {
                    return {_St::_Non_member, noexcept(_Fake_copy_init(end(::std:: declval<_Ty>())))}; 
                } else {
                    return {_St::_None};
                }
            }

            template <class _Ty>
            static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();

        public:
            template <_Should_range_access _Ty>
                requires (_Choice<_Ty&>._Strategy != _St::_None)
            [[nodiscard]] constexpr auto operator()(_Ty&& _Val) const noexcept(_Choice<_Ty&>._No_throw) {
                constexpr _St _Strat = _Choice<_Ty&>._Strategy;

                if constexpr (_Strat == _St::_Array) {
                    
                    return _Val + extent_v<remove_reference_t<_Ty&>>;
                } else if constexpr (_Strat == _St::_Member) {
                    return _Val.end();
                } else if constexpr (_Strat == _St::_Non_member) {
                    return end(_Val); 
                } else {
                    static_assert(_Always_false<_Ty>, "should be unreachable");
                }
            }
        };
    } 

    inline namespace _Cpos {
         inline constexpr _End::_Cpo end;
    }

     template <class _Rng>
    concept range = requires(_Rng & __r) {
                        ::std::ranges:: begin(__r);
                        ::std::ranges:: end(__r);
                    };

     template <class _Rng>
    concept input_range = range<_Rng> && input_iterator<iterator_t<_Rng>>;

     template <range _Rng>
    using sentinel_t = decltype(::std::ranges:: end(::std:: declval<_Rng&>()));

    template <class _Wrapped>
    concept _Weakly_unwrappable =
        same_as<typename remove_cvref_t<_Wrapped>::_Prevent_inheriting_unwrap, remove_cvref_t<_Wrapped>>
        && requires(_Wrapped&& _Wr) { ::std:: forward<_Wrapped>(_Wr)._Unwrapped(); };

    template <class _Sent>
    concept _Weakly_unwrappable_sentinel = _Weakly_unwrappable<const remove_reference_t<_Sent>&>;

    template <class _Iter>
    concept _Weakly_unwrappable_iterator = 
        _Weakly_unwrappable<_Iter> 
        && requires(
            _Iter&& _It, remove_cvref_t<_Iter>& _MutIt) { _MutIt._Seek_to(::std:: forward<_Iter>(_It)._Unwrapped()); };

    template <class _Sent, class _Iter>
    concept _Unwrappable_sentinel_for = 
        _Weakly_unwrappable_sentinel<_Sent> 
        && _Weakly_unwrappable_iterator<_Iter> 
        && requires(_Iter&& _It, const remove_reference_t<_Sent>& _Se) {
               { _Se._Unwrapped() } -> sentinel_for<decltype(::std:: forward<_Iter>(_It)._Unwrapped())>;
           };

    template <class _Sent, class _Iter>
    [[nodiscard]] constexpr decltype(auto) _Unwrap_iter(_Iter&& _It) noexcept(
        !_Unwrappable_sentinel_for<_Sent, _Iter> || _Has_nothrow_unwrapped<_Iter>) {
         ;
        if constexpr (is_pointer_v<remove_cvref_t<_Iter>>) {
            return _It + 0;
        } else if constexpr (_Unwrappable_sentinel_for<_Sent, _Iter>) {
            return static_cast<_Iter&&>(_It)._Unwrapped();
        } else {
            return static_cast<_Iter&&>(_It);
        }
    }

    template <class _Iter, class _Sent>
    [[nodiscard]] constexpr decltype(auto) _Unwrap_sent(_Sent&& _Se) noexcept(
        !_Unwrappable_sentinel_for<_Sent, _Iter> || _Has_nothrow_unwrapped<_Sent>) {
         ;
        if constexpr (is_pointer_v<remove_cvref_t<_Sent>>) {
            return _Se + 0;
        } else if constexpr (_Unwrappable_sentinel_for<_Sent, _Iter>) {
            return static_cast<_Sent&&>(_Se)._Unwrapped();
        } else {
            return static_cast<_Sent&&>(_Se);
        }
    }

    template <range _Rng, class _Iter>
    [[nodiscard]] constexpr decltype(auto) _Unwrap_range_iter(_Iter&& _It) noexcept(
        noexcept(_Unwrap_iter<sentinel_t<_Rng>>(static_cast<_Iter&&>(_It)))) {
         ;
        return _Unwrap_iter<sentinel_t<_Rng>>(static_cast<_Iter&&>(_It));
    }

    template <range _Rng, class _Sent>
    [[nodiscard]] constexpr decltype(auto) _Unwrap_range_sent(_Sent&& _Se) noexcept(
        noexcept(_Unwrap_sent<iterator_t<_Rng>>(static_cast<_Sent&&>(_Se)))) {
         ;
        return _Unwrap_sent<iterator_t<_Rng>>(static_cast<_Sent&&>(_Se));
    }

    template <class _Iter, class _Sent>
    using _Unwrap_iter_t = remove_cvref_t<decltype(_Unwrap_iter<_Sent>(::std:: declval<_Iter>()))>;
    template <class _Sent, class _Iter>
    using _Unwrap_sent_t = remove_cvref_t<decltype(_Unwrap_sent<_Iter>(::std:: declval<_Sent>()))>;

    template <range _Rng>
    using _Unwrapped_iterator_t = _Unwrap_iter_t<iterator_t<_Rng>, sentinel_t<_Rng>>;
    template <range _Rng>
    using _Unwrapped_sentinel_t = _Unwrap_sent_t<sentinel_t<_Rng>, iterator_t<_Rng>>;

    namespace _Unchecked_begin {
        template <class _Ty>
        concept _Has_member = requires(_Ty& __t) {
                                  { __t._Unchecked_begin() } -> input_or_output_iterator;
                              };

        template <class _Ty>
        concept _Can_begin = requires(_Ty& __t) { _Unwrap_range_iter<_Ty>(::std::ranges:: begin(__t)); };

        class _Cpo {
        private:
            enum class _St { _None, _Member, _Unwrap };

            template <class _Ty>
            [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
                 ;
                if constexpr (_Has_member<_Ty>) {
                    
;
                    return {_St::_Member, noexcept(_Fake_copy_init(::std:: declval<_Ty>()._Unchecked_begin()))};
                } else if constexpr (_Can_begin<_Ty>) {
                    return {_St::_Unwrap,
                        noexcept(_Fake_copy_init(_Unwrap_range_iter<_Ty>(::std::ranges:: begin(::std:: declval<_Ty>()))))};
                } else {
                    return {_St::_None};
                }
            }

            template <class _Ty>
            static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();

        public:
            template <_Should_range_access _Ty>
                requires (_Choice<_Ty&>._Strategy != _St::_None)
            [[nodiscard]] constexpr auto operator()(_Ty&& _Val) const noexcept(_Choice<_Ty&>._No_throw) {
                constexpr _St _Strat = _Choice<_Ty&>._Strategy;

                if constexpr (_Strat == _St::_Member) {
                    return _Val._Unchecked_begin();
                } else if constexpr (_Strat == _St::_Unwrap) {
                    return _Unwrap_range_iter<_Ty>(::std::ranges:: begin(_Val));
                } else {
                    static_assert(_Always_false<_Ty>, "Should be unreachable");
                }
            }
        };
    } 

    inline namespace _Cpos {
        inline constexpr _Unchecked_begin::_Cpo _Ubegin;
    }

    namespace _Unchecked_end {
        template <class _Ty>
        concept _Has_member = _Unchecked_begin::_Has_member<_Ty>
                           && requires(_Ty& __t) {
                                  __t._Unchecked_begin(); 
                                  { __t._Unchecked_end() } -> sentinel_for<decltype(__t._Unchecked_begin())>;
                              };

        template <class _Ty>
        concept _Can_end = requires(_Ty& __t) { _Unwrap_range_sent<_Ty>(::std::ranges:: end(__t)); };

        class _Cpo {
        private:
            enum class _St { _None, _Member, _Unwrap };

            template <class _Ty>
            [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
                 ;
                if constexpr (_Has_member<_Ty>) {
                    return {_St::_Member, noexcept(::std:: declval<_Ty>()._Unchecked_end())};
                } else if constexpr (_Can_end<_Ty>) {
                    return {_St::_Unwrap, noexcept(_Unwrap_range_sent<_Ty>(::std::ranges:: end(::std:: declval<_Ty>())))};
                } else {
                    return {_St::_None};
                }
            }

            template <class _Ty>
            static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();

        public:
            template <_Should_range_access _Ty>
                requires (_Choice<_Ty&>._Strategy != _St::_None)
            [[nodiscard]] constexpr auto operator()(_Ty&& _Val) const noexcept(_Choice<_Ty&>._No_throw) {
                constexpr _St _Strat = _Choice<_Ty&>._Strategy;

                if constexpr (_Strat == _St::_Member) {
                    return _Val._Unchecked_end();
                } else if constexpr (_Strat == _St::_Unwrap) {
                    return _Unwrap_range_sent<_Ty>(::std::ranges:: end(_Val));
                } else {
                    static_assert(_Always_false<_Ty>, "Should be unreachable");
                }
            }
        };
    } 

    inline namespace _Cpos {
        inline constexpr _Unchecked_end::_Cpo _Uend;
    }

     template <class _Rng>
    concept borrowed_range = range<_Rng> && _Should_range_access<_Rng>;

     template <range _Rng>
    using range_difference_t = iter_difference_t<iterator_t<_Rng>>;

     template <range _Rng>
    using range_value_t = iter_value_t<iterator_t<_Rng>>;

     template <range _Rng>
    using range_reference_t = iter_reference_t<iterator_t<_Rng>>;

     template <range _Rng>
    using range_rvalue_reference_t = iter_rvalue_reference_t<iterator_t<_Rng>>;






































#line 2488 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

    struct _Cbegin_fn {






#line 2497 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        template <class _Ty, class _CTy = _Const_thru_ref<_Ty>>
        [[nodiscard]] constexpr auto operator()(_Ty&& _Val) const
            noexcept(noexcept(::std::ranges:: begin(static_cast<_CTy&&>(_Val))))
            requires requires { ::std::ranges:: begin(static_cast<_CTy&&>(_Val)); }
        {
            return ::std::ranges:: begin(static_cast<_CTy&&>(_Val));
        }
#line 2505 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
    };

    inline namespace _Cpos {
         inline constexpr _Cbegin_fn cbegin;
    }

    struct _Cend_fn {






#line 2519 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        template <class _Ty, class _CTy = _Const_thru_ref<_Ty>>
        [[nodiscard]] constexpr auto operator()(_Ty&& _Val) const
            noexcept(noexcept(::std::ranges:: end(static_cast<_CTy&&>(_Val))))
            requires requires { ::std::ranges:: end(static_cast<_CTy&&>(_Val)); }
        {
            return ::std::ranges:: end(static_cast<_CTy&&>(_Val));
        }
#line 2527 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
    };

    inline namespace _Cpos {
         inline constexpr _Cend_fn cend;
    }

    namespace _Rbegin {


#line 2537 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        void rbegin();
#line 2539 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

        template <class _Ty>
        concept _Has_member = requires(_Ty __t) {
                                  { _Fake_copy_init(__t.rbegin()) } -> input_or_output_iterator;
                              };

        template <class _Ty>
        concept _Has_ADL = _Has_class_or_enum_type<_Ty> 
                        && requires(_Ty __t) {
                               { _Fake_copy_init(rbegin(__t)) } -> input_or_output_iterator; 
                           };

        template <class _Ty>
        concept _Can_make_reverse = requires(_Ty __t) {
                                        { ::std::ranges:: begin(__t) } -> bidirectional_iterator;
                                        { ::std::ranges:: end(__t) } -> same_as<decltype(::std::ranges:: begin(__t))>;
                                    };

        class _Cpo {
        private:
            enum class _St { _None, _Member, _Non_member, _Make_reverse };

            template <class _Ty>
            [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
                 ;
                if constexpr (_Has_member<_Ty>) {
                    return {_St::_Member, noexcept(_Fake_copy_init(::std:: declval<_Ty>().rbegin()))};
                } else if constexpr (_Has_ADL<_Ty>) {
                    return {
                        _St::_Non_member, noexcept(_Fake_copy_init(rbegin(::std:: declval<_Ty>())))}; 
                } else if constexpr (_Can_make_reverse<_Ty>) {
                    return {_St::_Make_reverse, noexcept(::std:: make_reverse_iterator(::std::ranges:: end(::std:: declval<_Ty>())))};
                } else {
                    return {_St::_None};
                }
            }

            template <class _Ty>
            static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();

        public:
            template <_Should_range_access _Ty>
                requires (_Choice<_Ty&>._Strategy != _St::_None)
            [[nodiscard]] constexpr auto operator()(_Ty&& _Val) const noexcept(_Choice<_Ty&>._No_throw) {
                constexpr _St _Strat = _Choice<_Ty&>._Strategy;

                if constexpr (_Strat == _St::_Member) {
                    return _Val.rbegin();
                } else if constexpr (_Strat == _St::_Non_member) {
                    return rbegin(_Val); 
                } else if constexpr (_Strat == _St::_Make_reverse) {
                    return ::std:: make_reverse_iterator(::std::ranges:: end(_Val));
                } else {
                    static_assert(_Always_false<_Ty>, "should be unreachable");
                }
            }
        };
    } 

    inline namespace _Cpos {
         inline constexpr _Rbegin::_Cpo rbegin;
    }

    namespace _Rend {


#line 2606 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        void rend();
#line 2608 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

        template <class _Ty>
        concept _Has_member = requires(_Ty __t) {
                                  { _Fake_copy_init(__t.rend()) } -> sentinel_for<decltype(::std::ranges:: rbegin(__t))>;
                              };

        template <class _Ty>
        concept _Has_ADL = _Has_class_or_enum_type<_Ty> 
                        && requires(_Ty __t) {
                               
                               { _Fake_copy_init(rend(__t)) } -> sentinel_for<decltype(::std::ranges:: rbegin(__t))>;
                           };

        template <class _Ty>
        concept _Can_make_reverse = requires(_Ty __t) {
                                        { ::std::ranges:: begin(__t) } -> bidirectional_iterator;
                                        { ::std::ranges:: end(__t) } -> same_as<decltype(::std::ranges:: begin(__t))>;
                                    };

        class _Cpo {
        private:
            enum class _St { _None, _Member, _Non_member, _Make_reverse };

            template <class _Ty>
            [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
                 ;
                if constexpr (_Has_member<_Ty>) {
                    return {_St::_Member, noexcept(_Fake_copy_init(::std:: declval<_Ty>().rend()))};
                } else if constexpr (_Has_ADL<_Ty>) {
                    return {_St::_Non_member, noexcept(_Fake_copy_init(rend(::std:: declval<_Ty>())))}; 
                } else if constexpr (_Can_make_reverse<_Ty>) {
                    return {
                        _St::_Make_reverse, noexcept(::std:: make_reverse_iterator(::std::ranges:: begin(::std:: declval<_Ty>())))};
                } else {
                    return {_St::_None};
                }
            }

            template <class _Ty>
            static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();

        public:
            template <_Should_range_access _Ty>
                requires (_Choice<_Ty&>._Strategy != _St::_None)
            [[nodiscard]] constexpr auto operator()(_Ty&& _Val) const noexcept(_Choice<_Ty&>._No_throw) {
                constexpr _St _Strat = _Choice<_Ty&>._Strategy;

                if constexpr (_Strat == _St::_Member) {
                    return _Val.rend();
                } else if constexpr (_Strat == _St::_Non_member) {
                    return rend(_Val); 
                } else if constexpr (_Strat == _St::_Make_reverse) {
                    return ::std:: make_reverse_iterator(::std::ranges:: begin(_Val));
                } else {
                    static_assert(_Always_false<_Ty>, "should be unreachable");
                }
            }
        };
    } 

    inline namespace _Cpos {
         inline constexpr _Rend::_Cpo rend;
    }





















#line 2693 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

    struct _Crbegin_fn {






#line 2702 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        template <class _Ty, class _CTy = _Const_thru_ref<_Ty>>
        [[nodiscard]] constexpr auto operator()(_Ty&& _Val) const
            noexcept(noexcept(::std::ranges:: rbegin(static_cast<_CTy&&>(_Val))))
            requires requires { ::std::ranges:: rbegin(static_cast<_CTy&&>(_Val)); }
        {
            return ::std::ranges:: rbegin(static_cast<_CTy&&>(_Val));
        }
#line 2710 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
    };

    inline namespace _Cpos {
         inline constexpr _Crbegin_fn crbegin;
    }

    struct _Crend_fn {






#line 2724 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        template <class _Ty, class _CTy = _Const_thru_ref<_Ty>>
        [[nodiscard]] constexpr auto operator()(_Ty&& _Val) const
            noexcept(noexcept(::std::ranges:: rend(static_cast<_CTy&&>(_Val))))
            requires requires { ::std::ranges:: rend(static_cast<_CTy&&>(_Val)); }
        {
            return ::std::ranges:: rend(static_cast<_CTy&&>(_Val));
        }
#line 2732 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
    };

    inline namespace _Cpos {
         inline constexpr _Crend_fn crend;
    }

     template <class>
    inline constexpr bool disable_sized_range = false;

    namespace _Size {


#line 2745 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        void size();
#line 2747 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

        template <class _Ty, class _UnCV>
        concept _Has_member = (!disable_sized_range<_UnCV>) 
                           && requires(_Ty __t) {
                                  { _Fake_copy_init(__t.size()) } -> _Integer_like;
                              };

        template <class _Ty, class _UnCV>
        concept _Has_ADL = _Has_class_or_enum_type<_Ty> && (!disable_sized_range<_UnCV>) 
                        && requires(_Ty __t) {
                               { _Fake_copy_init(size(__t)) } -> _Integer_like; 
                           };

        template <class _Ty>
        concept _Can_difference = requires(_Ty __t) {
                                      { ::std::ranges:: begin(__t) } -> forward_iterator;
                                      { ::std::ranges:: end(__t) } -> sized_sentinel_for<decltype(::std::ranges:: begin(__t))>;
                                  };

        class _Cpo {
        private:
            enum class _St { _None, _Array, _Member, _Non_member, _Subtract };

            template <class _Ty>
            [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
                 ;
                using _UnCV = remove_cvref_t<_Ty>;

                if constexpr (is_array_v<_UnCV>) {
                    if constexpr (extent_v<_UnCV> != 0) {
                        return {_St::_Array, true};
                    } else {
                        return {_St::_None};
                    }
                } else if constexpr (_Has_member<_Ty, _UnCV>) {
                    return {_St::_Member, noexcept(_Fake_copy_init(::std:: declval<_Ty>().size()))};
                } else if constexpr (_Has_ADL<_Ty, _UnCV>) {
                    return {_St::_Non_member, noexcept(_Fake_copy_init(size(::std:: declval<_Ty>())))}; 
                } else if constexpr (_Can_difference<_Ty>) {
                    return {_St::_Subtract,
                        noexcept(::std::ranges:: end(::std:: declval<_Ty>()) - ::std::ranges:: begin(::std:: declval<_Ty>()))};
                } else {
                    return {_St::_None};
                }
            }

            template <class _Ty>
            static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();

        public:
            template <class _Ty>
                requires (_Choice<_Ty&>._Strategy != _St::_None)
            [[nodiscard]] constexpr auto operator()(_Ty&& _Val) const noexcept(_Choice<_Ty&>._No_throw) {
                constexpr _St _Strat = _Choice<_Ty&>._Strategy;

                if constexpr (_Strat == _St::_Array) {
                    
                    return extent_v<remove_cvref_t<_Ty&>>;
                } else if constexpr (_Strat == _St::_Member) {
                    return _Val.size();
                } else if constexpr (_Strat == _St::_Non_member) {
                    return size(_Val); 
                } else if constexpr (_Strat == _St::_Subtract) {
                    const auto _Delta = ::std::ranges:: end(_Val) - ::std::ranges:: begin(_Val);
                    return static_cast<_Make_unsigned_like_t<remove_cv_t<decltype(_Delta)>>>(_Delta);
                } else {
                    static_assert(_Always_false<_Ty>, "should be unreachable");
                }
            }
        };
    } 

    inline namespace _Cpos {
         inline constexpr _Size::_Cpo size;
    }

    namespace _Empty {
        template <class _Ty>
        concept _Has_member = requires(_Ty __t) { static_cast<bool>(__t.empty()); };

        template <class _Ty>
        concept _Has_size = requires(_Ty __t) { ::std::ranges:: size(__t); };

        template <class _Ty>
        concept _Can_begin_end = requires(_Ty __t) {
                                     { ::std::ranges:: begin(__t) } -> forward_iterator;
                                     ::std::ranges:: end(__t);
                                 };

        class _Cpo {
        private:
            enum class _St { _None, _Member, _Size, _Compare };

            template <class _Ty>
            [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
                 ;
                if constexpr (is_unbounded_array_v<remove_reference_t<_Ty>>) {
                    return {_St::_None};
                } else if constexpr (_Has_member<_Ty>) {
                    return {_St::_Member, noexcept(static_cast<bool>(::std:: declval<_Ty>().empty()))};
                } else if constexpr (_Has_size<_Ty>) {
                    return {_St::_Size, noexcept(::std::ranges:: size(::std:: declval<_Ty>()))};
                } else if constexpr (_Can_begin_end<_Ty>) {
                    constexpr auto _Nothrow = noexcept(
                        static_cast<bool>(::std::ranges:: begin(::std:: declval<_Ty>()) == ::std::ranges:: end(::std:: declval<_Ty>())));
                    return {_St::_Compare, _Nothrow};
                } else {
                    return {_St::_None};
                }
            }

            template <class _Ty>
            static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();

        public:
            
            template <class _Ty>
                requires (_Choice<_Ty&>._Strategy != _St::_None)
            [[nodiscard]] constexpr bool operator()(_Ty&& _Val) const noexcept(_Choice<_Ty&>._No_throw) {
                constexpr _St _Strat = _Choice<_Ty&>._Strategy;

                if constexpr (_Strat == _St::_Member) {
                    return static_cast<bool>(_Val.empty());
                } else if constexpr (_Strat == _St::_Size) {
                    return ::std::ranges:: size(_Val) == 0;
                } else if constexpr (_Strat == _St::_Compare) {
                    return static_cast<bool>(::std::ranges:: begin(_Val) == ::std::ranges:: end(_Val));
                } else {
                    static_assert(_Always_false<_Ty>, "should be unreachable");
                }
            }
            
        };
    } 

    inline namespace _Cpos {
         inline constexpr _Empty::_Cpo empty;
    }

    namespace _Data {
        template <class _Ty>
        concept _Points_to_object = is_pointer_v<_Ty> && is_object_v<remove_pointer_t<_Ty>>;

        template <class _Ty>
        concept _Has_member = requires(_Ty __t) {
                                  { _Fake_copy_init(__t.data()) } -> _Points_to_object;
                              };

        template <class _Ty>
        concept _Has_contiguous_iterator = requires(_Ty __t) {
                                               { ::std::ranges:: begin(__t) } -> contiguous_iterator;
                                           };

        class _Cpo {
        private:
            enum class _St { _None, _Member, _Address };

            template <class _Ty>
            [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
                 ;
                if constexpr (_Has_member<_Ty>) {
                    return {_St::_Member, noexcept(::std:: declval<_Ty>().data())};
                } else if constexpr (_Has_contiguous_iterator<_Ty>) {
                    return {_St::_Address, noexcept(::std:: to_address(::std::ranges:: begin(::std:: declval<_Ty>())))};
                } else {
                    return {_St::_None};
                }
            }

            template <class _Ty>
            static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();

        public:
            template <_Should_range_access _Ty>
                requires (_Choice<_Ty&>._Strategy != _St::_None)
            [[nodiscard]] constexpr auto operator()(_Ty&& _Val) const noexcept(_Choice<_Ty&>._No_throw) {
                constexpr _St _Strat = _Choice<_Ty&>._Strategy;

                if constexpr (_Strat == _St::_Member) {
                    return _Val.data();
                } else if constexpr (_Strat == _St::_Address) {
                    return ::std:: to_address(::std::ranges:: begin(_Val));
                } else {
                    static_assert(_Always_false<_Ty>, "should be unreachable");
                }
            }
        };
    } 

    inline namespace _Cpos {
         inline constexpr _Data::_Cpo data;
    }







#line 2947 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

    struct _Cdata_fn {






#line 2956 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        template <class _Ty, class _CTy = _Const_thru_ref<_Ty>>
        [[nodiscard]] constexpr auto operator()(_Ty&& _Val) const
            noexcept(noexcept(::std::ranges:: data(static_cast<_CTy&&>(_Val))))
            requires requires { ::std::ranges:: data(static_cast<_CTy&&>(_Val)); }
        {
            return ::std::ranges:: data(static_cast<_CTy&&>(_Val));
        }
#line 2964 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
    };

    inline namespace _Cpos {
         inline constexpr _Cdata_fn cdata;
    }

     template <class _Rng>
    concept sized_range = range<_Rng> && requires(_Rng & __r) { ::std::ranges:: size(__r); };

     template <sized_range _Rng>
    using range_size_t = decltype(::std::ranges:: size(::std:: declval<_Rng&>()));

     struct view_base {};

    template <class _Ty, template <class...> class _Template>
    concept _Strictly_derived_from_specialization_of =
        is_object_v<_Ty> && _Derived_from_specialization_of<_Ty, _Template>;

     template <class _Derived>
        requires is_class_v<_Derived> && same_as<_Derived, remove_cv_t<_Derived>>
    class view_interface;

     template <class _Ty>
    inline constexpr bool enable_view =
        derived_from<_Ty, view_base> || _Strictly_derived_from_specialization_of<_Ty, view_interface>;

     template <class _Ty>
    concept view = range<_Ty> && movable<_Ty> && enable_view<_Ty>;

     template <class _Rng, class _Ty>
    concept output_range = range<_Rng> && output_iterator<iterator_t<_Rng>, _Ty>;

     template <class _Rng>
    concept forward_range = range<_Rng> && forward_iterator<iterator_t<_Rng>>;

     template <class _Rng>
    concept bidirectional_range = range<_Rng> && bidirectional_iterator<iterator_t<_Rng>>;

     template <class _Rng>
    concept random_access_range = range<_Rng> && random_access_iterator<iterator_t<_Rng>>;

     template <class _Rng>
    concept contiguous_range = range<_Rng> && contiguous_iterator<iterator_t<_Rng>>
                            && requires(_Rng & __r) {
                                   { ::std::ranges:: data(__r) } -> same_as<add_pointer_t<range_reference_t<_Rng>>>;
                               };

    class _Not_quite_object {
    public:
        
        
        
        
        

        struct _Construct_tag {
            explicit _Construct_tag() = default;
        };

        _Not_quite_object() = delete;

        constexpr explicit _Not_quite_object(_Construct_tag) noexcept {}

        _Not_quite_object(const _Not_quite_object&)            = delete;
        _Not_quite_object& operator=(const _Not_quite_object&) = delete;

        void operator&() const = delete;

    protected:
        ~_Not_quite_object() = default;
    };

    class _Advance_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_or_output_iterator _It>
        constexpr void operator()(_It& _Where, iter_difference_t<_It> _Off) const {
            if constexpr (random_access_iterator<_It>) {
                _Where += _Off;
            } else {
                if constexpr (!bidirectional_iterator<_It>) {
                     ;
                }

                decltype(auto) _UWhere      = _Get_unwrapped_n(::std:: move(_Where), _Off);
                constexpr bool _Need_rewrap = !is_reference_v<decltype(_Get_unwrapped_n(::std:: move(_Where), _Off))>;

                if constexpr (bidirectional_iterator<_It>) {
                    for (; _Off < 0; ++_Off) {
                        --_UWhere;
                    }
                }

                for (; _Off > 0; --_Off) {
                    ++_UWhere;
                }

                if constexpr (_Need_rewrap) {
                    _Seek_wrapped(_Where, ::std:: move(_UWhere));
                }
            }
        }

        template <input_or_output_iterator _It, sentinel_for<_It> _Se>
        constexpr void operator()(_It& _Where, _Se _Last) const {
            if constexpr (assignable_from<_It&, _Se>) {
                _Where = static_cast<_Se&&>(_Last);
            } else if constexpr (sized_sentinel_for<_Se, _It>) {
                (*this)(_Where, _Last - _Where);
            } else {
                _Adl_verify_range(_Where, _Last);

                decltype(auto) _UWhere      = _Unwrap_iter<_Se>(static_cast<_It&&>(_Where));
                constexpr bool _Need_rewrap = !is_reference_v<decltype(_Unwrap_iter<_Se>(static_cast<_It&&>(_Where)))>;
                decltype(auto) _ULast       = _Unwrap_sent<_It>(static_cast<_Se&&>(_Last));

                while (_UWhere != _ULast) {
                    ++_UWhere;
                }

                if constexpr (_Need_rewrap) {
                    _Seek_wrapped(_Where, ::std:: move(_UWhere));
                }
            }
        }

        template <input_or_output_iterator _It, sentinel_for<_It> _Se>
        constexpr iter_difference_t<_It> operator()(_It& _Where, iter_difference_t<_It> _Off, _Se _Last) const {
            if constexpr (sized_sentinel_for<_Se, _It>) {
                const iter_difference_t<_It> _Delta = _Last - _Where;
                if ((_Off < 0 && _Off <= _Delta) || (_Off > 0 && _Off >= _Delta)) {
                    if constexpr (assignable_from<_It&, _Se>) {
                        _Where = static_cast<_Se&&>(_Last);
                    } else {
                        (*this)(_Where, _Delta);
                    }
                    return _Off - _Delta;
                }

                (*this)(_Where, _Off);
                return 0;
            } else {
                
                if constexpr (bidirectional_iterator<_It>) {
                    for (; _Off < 0 && _Where != _Last; ++_Off) {
                        --_Where;
                    }
                } else {
                     ;
                }

                for (; _Off > 0 && _Where != _Last; --_Off) {
                    ++_Where;
                }

                return _Off;
            }
        }
    };

     inline constexpr _Advance_fn advance{_Not_quite_object::_Construct_tag{}};

    class _Distance_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <class _It, sentinel_for<_It> _Se>
            requires (!sized_sentinel_for<_Se, _It>)
        [[nodiscard]] constexpr iter_difference_t<_It> operator()(_It _First, _Se _Last) const
            noexcept(noexcept(_Distance_unchecked(
                _Get_unwrapped(::std:: move(_First)), _Get_unwrapped(::std:: move(_Last)))))   {
            _Adl_verify_range(_First, _Last);
            return _Distance_unchecked(_Unwrap_iter<_Se>(::std:: move(_First)), _Unwrap_sent<_It>(::std:: move(_Last)));
        }

        template <class _It, sized_sentinel_for<decay_t<_It>> _Se>
        [[nodiscard]] constexpr iter_difference_t<decay_t<_It>> operator()(_It&& _First, const _Se _Last) const
            noexcept(noexcept(_Last - static_cast<const decay_t<_It>&>(_First)))   {
            return _Last - static_cast<const decay_t<_It>&>(_First);
        }

        template <range _Rng>
        [[nodiscard]] constexpr range_difference_t<_Rng> operator()(_Rng&& _Range) const
            noexcept(_Nothrow_size<_Rng>)   {
            if constexpr (sized_range<_Rng>) {
                return static_cast<range_difference_t<_Rng>>(::std::ranges:: size(_Range));
            } else {
                return _Distance_unchecked(_Ubegin(_Range), _Uend(_Range));
            }
        }

    private:
        template <class _It, class _Se>
        [[nodiscard]] static constexpr iter_difference_t<_It> _Distance_unchecked(_It _First, const _Se _Last) noexcept(
            noexcept(++_First != _Last)) {
             ;

            iter_difference_t<_It> _Count = 0;
            for (; _First != _Last; ++_First) {
                ++_Count;
            }

            return _Count;
        }

        template <class _Rng>
        static constexpr bool _Nothrow_size =
            noexcept(_Distance_unchecked(_Ubegin(::std:: declval<_Rng&>()), _Uend(::std:: declval<_Rng&>())));

        template <sized_range _Rng>
        static constexpr bool _Nothrow_size<_Rng> = noexcept(::std::ranges:: size(::std:: declval<_Rng&>()));
    };

     inline constexpr _Distance_fn distance{_Not_quite_object::_Construct_tag{}};

    class _Ssize_fn {
    public:
        
        template <class _Rng>
        [[nodiscard]] constexpr auto operator()(_Rng&& _Range) const requires requires { ::std::ranges:: size(_Range); } {
            using _Sty = _Make_signed_like_t<decltype(::std::ranges:: size(_Range))>;
            using _Ty  = common_type_t<conditional_t<is_integral_v<_Sty>, ptrdiff_t, _Sty>, _Sty>;
            return static_cast<_Ty>(::std::ranges:: size(_Range));
        }
        
    };

    inline namespace _Cpos {
         inline constexpr _Ssize_fn ssize;
    }

    class _Next_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_or_output_iterator _It>
        [[nodiscard]] constexpr _It operator()(_It _Where) const {
            ++_Where;
            return _Where;
        }

        template <input_or_output_iterator _It>
        [[nodiscard]] constexpr _It operator()(_It _Where, const iter_difference_t<_It> _Off) const {
            ::std::ranges:: advance(_Where, _Off);
            return _Where;
        }

        template <input_or_output_iterator _It, sentinel_for<_It> _Se>
        [[nodiscard]] constexpr _It operator()(_It _Where, _Se _Last) const {
            ::std::ranges:: advance(_Where, static_cast<_Se&&>(_Last));
            return _Where;
        }

        template <input_or_output_iterator _It, sentinel_for<_It> _Se>
        [[nodiscard]] constexpr _It operator()(_It _Where, const iter_difference_t<_It> _Off, _Se _Last) const {
            ::std::ranges:: advance(_Where, _Off, static_cast<_Se&&>(_Last));
            return _Where;
        }
    };

     inline constexpr _Next_fn next{_Not_quite_object::_Construct_tag{}};

    class _Prev_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <bidirectional_iterator _It>
        [[nodiscard]] constexpr _It operator()(_It _Where) const {
            --_Where;
            return _Where;
        }

        template <bidirectional_iterator _It>
        [[nodiscard]] constexpr _It operator()(_It _Where, const iter_difference_t<_It> _Off) const {
             ;
            ::std::ranges:: advance(_Where, -_Off);
            return _Where;
        }

        template <bidirectional_iterator _It>
        [[nodiscard]] constexpr _It operator()(_It _Where, const iter_difference_t<_It> _Off, _It _Last) const {
             ;
            ::std::ranges:: advance(_Where, -_Off, static_cast<_It&&>(_Last));
            return _Where;
        }
    };

     inline constexpr _Prev_fn prev{_Not_quite_object::_Construct_tag{}};

    template <forward_iterator _It, sentinel_for<_It> _Se>
    [[nodiscard]] constexpr _It _Find_last_iterator(
        const _It& _First, const _Se& _Last, const iter_difference_t<_It> _Count) {
        
         ;
        if constexpr (is_same_v<_It, _Se>) {
            return _Last;
        } else {
            return ::std::ranges:: next(_First, _Count);
        }
    }

     struct equal_to {
        
        template <class _Ty1, class _Ty2>
            requires equality_comparable_with<_Ty1, _Ty2>
        [[nodiscard]] constexpr bool operator()(_Ty1&& _Left, _Ty2&& _Right) const noexcept(noexcept(
            static_cast<bool>(static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right))))   {
            return static_cast<bool>(static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right));
        }
        

        using is_transparent = int;
    };

     struct less {
        
        template <class _Ty1, class _Ty2>
            requires totally_ordered_with<_Ty1, _Ty2>
        [[nodiscard]] constexpr bool operator()(_Ty1&& _Left, _Ty2&& _Right) const noexcept(noexcept(
            static_cast<bool>(static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right))))   {
            return static_cast<bool>(static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right));
        }
        

        using is_transparent = int;
    };

     struct greater {
        
        template <class _Ty1, class _Ty2>
            requires totally_ordered_with<_Ty1, _Ty2>
        [[nodiscard]] constexpr bool operator()(_Ty1&& _Left, _Ty2&& _Right) const noexcept(noexcept(
            static_cast<bool>(static_cast<_Ty2&&>(_Right) < static_cast<_Ty1&&>(_Left))))   {
            return static_cast<bool>(static_cast<_Ty2&&>(_Right) < static_cast<_Ty1&&>(_Left));
        }
        

        using is_transparent = int;
    };

     template <class _Rng>
    concept common_range = range<_Rng> && same_as<iterator_t<_Rng>, sentinel_t<_Rng>>;

    template <class _It, class _Se>
    concept _Bidi_common = is_same_v<_It, _Se> && bidirectional_iterator<_It>;
    template <class _Rng>
    concept _Bidi_common_range = common_range<_Rng> && bidirectional_iterator<iterator_t<_Rng>>;

    template <class _Ty>
    concept _Can_empty = requires(_Ty __t) { ::std::ranges:: empty(__t); };

     template <class _Derived>
        requires is_class_v<_Derived> && same_as<_Derived, remove_cv_t<_Derived>>
    class view_interface {
    private:
        [[nodiscard]] constexpr _Derived& _Cast() noexcept {
            static_assert(derived_from<_Derived, view_interface>,
                "view_interface's template argument D must derive from view_interface<D> (N4849 [view.interface]/2).");
            static_assert(view<_Derived>,
                "view_interface's template argument must model the view concept (N4849 [view.interface]/2).");
            return static_cast<_Derived&>(*this);
        }

        [[nodiscard]] constexpr const _Derived& _Cast() const noexcept {
            static_assert(derived_from<_Derived, view_interface>,
                "view_interface's template argument D must derive from view_interface<D> (N4849 [view.interface]/2).");
            static_assert(view<_Derived>,
                "view_interface's template argument must model the view concept (N4849 [view.interface]/2).");
            return static_cast<const _Derived&>(*this);
        }

    public:





        [[nodiscard]] constexpr bool empty()
            requires sized_range<_Derived> || forward_range<_Derived>
#line 3345 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        {
            auto& _Self = _Cast();
            if constexpr (sized_range<_Derived>) {
                return ::std::ranges:: size(_Self) == 0;
            } else {
                return ::std::ranges:: begin(_Self) == ::std::ranges:: end(_Self);
            }
        }






        [[nodiscard]] constexpr bool empty() const
            requires sized_range<const _Derived> || forward_range<const _Derived>
#line 3362 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        {
            auto& _Self = _Cast();
            if constexpr (sized_range<const _Derived>) {
                return ::std::ranges:: size(_Self) == 0;
            } else {
                return ::std::ranges:: begin(_Self) == ::std::ranges:: end(_Self);
            }
        }

















































#line 3420 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"






        constexpr explicit operator bool()
            requires _Can_empty<_Derived>
#line 3429 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        {
            return !::std::ranges:: empty(_Cast());
        }






        constexpr explicit operator bool() const
            requires _Can_empty<const _Derived>
#line 3441 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        {
            return !::std::ranges:: empty(_Cast());
        }






        [[nodiscard]] constexpr auto data()
            requires contiguous_iterator<iterator_t<_Derived>>
#line 3453 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        {
            return ::std:: to_address(::std::ranges:: begin(_Cast()));
        }






        [[nodiscard]] constexpr auto data() const
            requires range<const _Derived> && contiguous_iterator<iterator_t<const _Derived>>
#line 3465 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        {
            return ::std:: to_address(::std::ranges:: begin(_Cast()));
        }






        [[nodiscard]] constexpr auto size()
            requires forward_range<_Derived> && sized_sentinel_for<sentinel_t<_Derived>, iterator_t<_Derived>>
#line 3477 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        {
            auto& _Self = _Cast();
            return ::std:: _To_unsigned_like(::std::ranges:: end(_Self) - ::std::ranges:: begin(_Self));
        }






        [[nodiscard]] constexpr auto size() const
            requires forward_range<const _Derived>
                  && sized_sentinel_for<sentinel_t<const _Derived>, iterator_t<const _Derived>>
#line 3491 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        {
            auto& _Self = _Cast();
            return ::std:: _To_unsigned_like(::std::ranges:: end(_Self) - ::std::ranges:: begin(_Self));
        }






        [[nodiscard]] constexpr decltype(auto) front()
            requires forward_range<_Derived>
#line 3504 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        {
            auto& _Self = _Cast();


#line 3509 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
            return *::std::ranges:: begin(_Self);
        }






        [[nodiscard]] constexpr decltype(auto) front() const
            requires forward_range<const _Derived>
#line 3520 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        {
            auto& _Self = _Cast();


#line 3525 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
            return *::std::ranges:: begin(_Self);
        }






        [[nodiscard]] constexpr decltype(auto) back()
            requires bidirectional_range<_Derived> && common_range<_Derived>
#line 3536 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        {
            auto& _Self = _Cast();


#line 3541 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
            auto _Last = ::std::ranges:: end(_Self);
            return *--_Last;
        }






        [[nodiscard]] constexpr decltype(auto) back() const
            requires bidirectional_range<const _Derived> && common_range<const _Derived>
#line 3553 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        {
            auto& _Self = _Cast();


#line 3558 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
            auto _Last = ::std::ranges:: end(_Self);
            return *--_Last;
        }

        template <random_access_range _Rng = _Derived>
        [[nodiscard]] constexpr decltype(auto) operator[](const range_difference_t<_Rng> _Idx) {
            auto& _Self = _Cast();






#line 3572 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
            return ::std::ranges:: begin(_Self)[_Idx];
        }

        template <random_access_range _Rng = const _Derived>
        [[nodiscard]] constexpr decltype(auto) operator[](const range_difference_t<_Rng> _Idx) const {
            auto& _Self = _Cast();






#line 3585 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
            return ::std::ranges:: begin(_Self)[_Idx];
        }
    };
} 



 template <size_t _Index, class... _Types>
[[nodiscard]] constexpr tuple_element_t<_Index, tuple<_Types...>>& get(tuple<_Types...>& _Tuple) noexcept;
 template <size_t _Index, class... _Types>
[[nodiscard]] constexpr const tuple_element_t<_Index, tuple<_Types...>>& get(const tuple<_Types...>& _Tuple) noexcept;
 template <size_t _Index, class... _Types>
[[nodiscard]] constexpr tuple_element_t<_Index, tuple<_Types...>>&& get(tuple<_Types...>&& _Tuple) noexcept;
 template <size_t _Index, class... _Types>
[[nodiscard]] constexpr const tuple_element_t<_Index, tuple<_Types...>>&& get(const tuple<_Types...>&& _Tuple) noexcept;

namespace ranges {
    
    template <class _From, class _To>
    concept _Uses_nonqualification_pointer_conversion =
        is_pointer_v<_From> && is_pointer_v<_To>
        && !convertible_to<remove_pointer_t<_From>(*)[], remove_pointer_t<_To>(*)[]>;

    template <class _From, class _To>
    concept _Convertible_to_non_slicing = convertible_to<_From, _To>
        && !_Uses_nonqualification_pointer_conversion<decay_t<_From>, decay_t<_To>>;

    template <class _Ty>
    concept _Pair_like = !is_reference_v<_Ty> && requires(_Ty __t) {
        typename tuple_size<_Ty>::type;
        requires derived_from<tuple_size<_Ty>, integral_constant<size_t, 2>>;
        typename tuple_element_t<0, remove_const_t<_Ty>>;
        typename tuple_element_t<1, remove_const_t<_Ty>>;
        { ::std:: get<0>(__t) } -> convertible_to<const tuple_element_t<0, _Ty>&>;
        { ::std:: get<1>(__t) } -> convertible_to<const tuple_element_t<1, _Ty>&>;
    };

    template <class _Ty, class _First, class _Second>
    concept _Pair_like_convertible_from = !range<_Ty> && _Pair_like<_Ty>
        && constructible_from<_Ty, _First, _Second>
        && _Convertible_to_non_slicing<_First, tuple_element_t<0, _Ty>>
        && convertible_to<_Second, tuple_element_t<1, _Ty>>;
    

    template <class _It, class _Se, subrange_kind _Ki,
        bool _Store = _Ki == subrange_kind::sized && !sized_sentinel_for<_Se, _It>>
    class _Subrange_base : public view_interface<subrange<_It, _Se, _Ki>> { 
    protected:
        using _Size_type                  = _Make_unsigned_like_t<iter_difference_t<_It>>;
        static constexpr bool _Store_size = true;

        _Size_type _Size = 0;

    public:
        _Subrange_base() = default;
        constexpr explicit _Subrange_base(const _Size_type& _Size_) noexcept : _Size(_Size_) {}
    };

    template <class _It, class _Se, subrange_kind _Ki>
    class _Subrange_base<_It, _Se, _Ki, false> : public view_interface<subrange<_It, _Se, _Ki>> {
    protected:
        using _Size_type                  = _Make_unsigned_like_t<iter_difference_t<_It>>;
        static constexpr bool _Store_size = false;

    public:
        _Subrange_base() = default;
        constexpr explicit _Subrange_base(const _Size_type&) noexcept {}
    };


#pragma warning(push)
#pragma warning(disable : 4324) 
#line 3658 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
     template <input_or_output_iterator _It, sentinel_for<_It> _Se, subrange_kind _Ki>
        requires (_Ki == subrange_kind::sized || !sized_sentinel_for<_Se, _It>)
    class subrange : public _Subrange_base<_It, _Se, _Ki> {
    private:
        using _Mybase = _Subrange_base<_It, _Se, _Ki>;
        using _Mybase::_Store_size;
        using typename _Mybase::_Size_type;

        
          _It _First{};
          _Se _Last{};
        

        template <class _Rng>
        constexpr subrange(true_type, _Rng&& _Val)
            : subrange(::std:: forward<_Rng>(_Val), static_cast<_Size_type>(::std::ranges:: size(_Val))) {
            
             ;
        }

        template <class _Rng>
        constexpr subrange(false_type, _Rng&& _Val) : subrange(::std::ranges:: begin(_Val), ::std::ranges:: end(_Val)) {
            
             ;
        }

    public:
        
        subrange() requires default_initializable<_It> = default;

        template <_Convertible_to_non_slicing<_It> _It2>
        constexpr subrange(_It2 _First_, _Se _Last_) requires (!_Store_size)
            : _First(::std:: move(_First_)), _Last(::std:: move(_Last_)) {}

        template <_Convertible_to_non_slicing<_It> _It2>
        constexpr subrange(_It2 _First_, _Se _Last_, const _Size_type _Size_) requires (_Ki == subrange_kind::sized)
            : _Mybase(_Size_), _First(::std:: move(_First_)), _Last(::std:: move(_Last_)) {
            if constexpr (sized_sentinel_for<_Se, _It>) {
                

;
            }
        }

        template <_Different_from<subrange> _Rng>
            requires borrowed_range<_Rng>
                && _Convertible_to_non_slicing<iterator_t<_Rng>, _It>
                && convertible_to<sentinel_t<_Rng>, _Se>
        constexpr subrange(_Rng&& _Val) requires (!_Store_size || sized_range<_Rng>)
            : subrange{bool_constant<_Store_size>{}, ::std:: forward<_Rng>(_Val)} {}

        template <borrowed_range _Rng>
            requires _Convertible_to_non_slicing<iterator_t<_Rng>, _It> && convertible_to<sentinel_t<_Rng>, _Se>
        constexpr subrange(_Rng&& _Val, const _Size_type _Count) requires (_Ki == subrange_kind::sized)
            : subrange{::std::ranges:: begin(_Val), ::std::ranges:: end(_Val), _Count} {}
        

        template <_Different_from<subrange> _Pair_like>
            requires _Pair_like_convertible_from<_Pair_like, const _It&, const _Se&>
        constexpr operator _Pair_like() const {
            return _Pair_like(_First, _Last);
        }

        [[nodiscard]] constexpr _It begin() const
            requires copyable<_It>
        {
            return _First;
        }
        
        [[nodiscard]] constexpr _It begin() requires (!copyable<_It>) {
            
            return ::std:: move(_First);
        }

        [[nodiscard]] constexpr _Se end() const {
            return _Last;
        }

        [[nodiscard]] constexpr bool empty() const {
            return _First == _Last;
        }

        
        [[nodiscard]] constexpr _Size_type size() const requires (_Ki == subrange_kind::sized) {
            
            if constexpr (_Store_size) {
                return this->_Size;
            } else {
                return static_cast<_Size_type>(_Last - _First);
            }
        }

        [[nodiscard]] constexpr subrange next() const&
            requires forward_iterator<_It>
        {
            auto _Tmp = *this;
            if (_Tmp._First != _Tmp._Last) {
                ++_Tmp._First;
                if constexpr (_Store_size) {
                    --_Tmp._Size;
                }
            }
            return _Tmp;
        }
        [[nodiscard]] constexpr subrange next(const iter_difference_t<_It> _Count) const&
            requires forward_iterator<_It>
        {
            auto _Tmp = *this;
            _Tmp.advance(_Count);
            return _Tmp;
        }

        [[nodiscard]] constexpr subrange next() && {
            if (_First != _Last) {
                ++_First;
                if constexpr (_Store_size) {
                    --this->_Size;
                }
            }
            return ::std:: move(*this);
        }
        [[nodiscard]] constexpr subrange next(const iter_difference_t<_It> _Count) && {
            advance(_Count);
            return ::std:: move(*this);
        }

        [[nodiscard]] constexpr subrange prev() const
            requires bidirectional_iterator<_It>
        {
            auto _Tmp = *this;
            --_Tmp._First;
            if constexpr (_Store_size) {
                ++_Tmp._Size;
            }
            return _Tmp;
        }
        [[nodiscard]] constexpr subrange prev(const iter_difference_t<_It> _Count) const
            requires bidirectional_iterator<_It>
        {
            auto _Tmp = *this;
            _Tmp.advance(-_Count);
            return _Tmp;
        }

        constexpr subrange& advance(const iter_difference_t<_It> _Count) {
            if constexpr (bidirectional_iterator<_It>) {
                if (_Count < 0) {
                    ::std::ranges:: advance(_First, _Count);
                    if constexpr (_Store_size) {
                        this->_Size += static_cast<_Size_type>(-_Count);
                    }
                    return *this;
                }
            }

            const auto _Remainder = ::std::ranges:: advance(_First, _Count, _Last);
            if constexpr (_Store_size) {
                this->_Size -= static_cast<_Size_type>(_Count - _Remainder);
            }
            return *this;
        }
    };

#pragma warning(pop)
#line 3823 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

    template <input_or_output_iterator _It, sentinel_for<_It> _Se>
    subrange(_It, _Se) -> subrange<_It, _Se>;

    template <input_or_output_iterator _It, sentinel_for<_It> _Se>
    subrange(_It, _Se, _Make_unsigned_like_t<iter_difference_t<_It>>) -> subrange<_It, _Se, subrange_kind::sized>;

    template <borrowed_range _Rng>
    subrange(_Rng&&) -> subrange<iterator_t<_Rng>, sentinel_t<_Rng>,
        (sized_range<_Rng> || sized_sentinel_for<sentinel_t<_Rng>, iterator_t<_Rng>>) ? subrange_kind::sized
                                                                                      : subrange_kind::unsized>;

    template <borrowed_range _Rng>
    subrange(_Rng&&, _Make_unsigned_like_t<range_difference_t<_Rng>>)
        -> subrange<iterator_t<_Rng>, sentinel_t<_Rng>, subrange_kind::sized>;

    template <class _It, class _Se, subrange_kind _Ki>
    inline constexpr bool enable_borrowed_range<subrange<_It, _Se, _Ki>> = true;

     template <size_t _Idx, class _It, class _Se, subrange_kind _Ki>
        requires ((_Idx == 0 && copyable<_It>) || _Idx == 1)
    [[nodiscard]] constexpr auto get(const subrange<_It, _Se, _Ki>& _Val) {
        if constexpr (_Idx == 0) {
            return _Val.begin();
        } else {
            return _Val.end();
        }
    }

     template <size_t _Idx, class _It, class _Se, subrange_kind _Ki>
        requires (_Idx < 2)
    [[nodiscard]] constexpr auto get(subrange<_It, _Se, _Ki>&& _Val) {
        if constexpr (_Idx == 0) {
            return _Val.begin();
        } else {
            return _Val.end();
        }
    }

     struct dangling {
        constexpr dangling() noexcept = default;
        template <class... _Args>
        constexpr dangling(_Args&&...) noexcept {}
    };

     template <range _Rng>
    using borrowed_iterator_t = conditional_t<borrowed_range<_Rng>, iterator_t<_Rng>, dangling>;

     template <range _Rng>
    using borrowed_subrange_t = conditional_t<borrowed_range<_Rng>, subrange<iterator_t<_Rng>>, dangling>;
} 
#line 3875 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

struct _Container_proxy;
struct _Iterator_base12;

struct _Default_sentinel {}; 


 template <semiregular>
class move_sentinel;

template <class>
struct _Move_iterator_category {};


template <class _Iter>
    requires requires { typename _Iter_cat_t<_Iter>; }
struct _Move_iterator_category<_Iter> {
    using iterator_category = conditional_t<derived_from<_Iter_cat_t<_Iter>, random_access_iterator_tag>,
        random_access_iterator_tag, _Iter_cat_t<_Iter>>;
};






#line 3902 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

 template <class _Iter>
class move_iterator : public _Move_iterator_category<_Iter> {
public:
    using iterator_type   = _Iter;
    using value_type      = _Iter_value_t<_Iter>;
    using difference_type = _Iter_diff_t<_Iter>;
    using pointer         = _Iter;


private:
    static constexpr auto _Get_iter_concept() {
        if constexpr (random_access_iterator<_Iter>) {
            return random_access_iterator_tag{};
        } else if constexpr (bidirectional_iterator<_Iter>) {
            return bidirectional_iterator_tag{};
        } else if constexpr (forward_iterator<_Iter>) {
            return forward_iterator_tag{};
        } else {
            return input_iterator_tag{};
        }
    }

public:
    using iterator_concept = decltype(_Get_iter_concept());

    using reference = iter_rvalue_reference_t<_Iter>;



#line 3933 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

    constexpr move_iterator() = default;

    constexpr explicit move_iterator(_Iter _Right) noexcept(is_nothrow_move_constructible_v<_Iter>) 
        : _Current(::std:: move(_Right)) {}

    
    template <class _Other>

        requires (!is_same_v<_Other, _Iter>) && convertible_to<const _Other&, _Iter>
#line 3944 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
    constexpr move_iterator(const move_iterator<_Other>& _Right) noexcept(
        is_nothrow_constructible_v<_Iter, const _Other&>) 
        : _Current(_Right.base()) {}

    template <class _Other>

        requires (!is_same_v<_Other, _Iter>) && convertible_to<const _Other&, _Iter>
            && assignable_from<_Iter&, const _Other&>
#line 3953 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
    constexpr move_iterator& operator=(const move_iterator<_Other>& _Right) noexcept(
        is_nothrow_assignable_v<_Iter&, const _Other&>)   {
        _Current = _Right.base();
        return *this;
    }
    


    [[nodiscard]] constexpr const iterator_type& base() const& noexcept {
        return _Current;
    }
    [[nodiscard]] constexpr iterator_type base() && noexcept(is_nothrow_move_constructible_v<_Iter>)   {
        return ::std:: move(_Current);
    }





#line 3973 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

    [[nodiscard]] constexpr reference operator*() const

        noexcept(noexcept(::std::ranges:: iter_move(_Current)))   {
        return ::std::ranges:: iter_move(_Current);
    }




#line 3984 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

    [[deprecated("warning STL4031: " "std::move_iterator::operator->() is deprecated in C++20. " "You can define _SILENCE_CXX20_MOVE_ITERATOR_ARROW_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] [[nodiscard]] constexpr pointer operator->() const
        noexcept(is_nothrow_copy_constructible_v<_Iter>)   {
        return _Current;
    }

    constexpr move_iterator& operator++() noexcept(noexcept(++_Current))   {
        ++_Current;
        return *this;
    }

    constexpr auto operator++(int) noexcept(
        is_nothrow_copy_constructible_v<_Iter>&& noexcept(++_Current))   {

        if constexpr (forward_iterator<_Iter>) {
#line 4000 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
            move_iterator _Tmp = *this;
            ++_Current;
            return _Tmp;

        } else {
            ++_Current;
        }
#line 4008 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
    }

    constexpr move_iterator& operator--() noexcept(noexcept(--_Current))   {
        --_Current;
        return *this;
    }

    constexpr move_iterator operator--(int) noexcept(
        is_nothrow_copy_constructible_v<_Iter>&& noexcept(--_Current))   {
        move_iterator _Tmp = *this;
        --_Current;
        return _Tmp;
    }

    template <class _Iter2 = _Iter>
    [[nodiscard]] auto operator==(_Default_sentinel _Sentinel) const noexcept
        -> decltype(::std:: declval<const _Iter2&>() == _Sentinel) {
        return _Current == _Sentinel;
    }

    template <class _Iter2 = _Iter>
    [[nodiscard]] auto operator!=(_Default_sentinel _Sentinel) const noexcept
        -> decltype(::std:: declval<const _Iter2&>() != _Sentinel) {
        return _Current != _Sentinel;
    }

    [[nodiscard]] constexpr move_iterator operator+(const difference_type _Off) const
        noexcept(noexcept(move_iterator(_Current + _Off)))   {
        return move_iterator(_Current + _Off);
    }

    constexpr move_iterator& operator+=(const difference_type _Off) noexcept(
        noexcept(_Current += _Off))   {
        _Current += _Off;
        return *this;
    }

    [[nodiscard]] constexpr move_iterator operator-(const difference_type _Off) const
        noexcept(noexcept(move_iterator(_Current - _Off)))   {
        return move_iterator(_Current - _Off);
    }

    constexpr move_iterator& operator-=(const difference_type _Off) noexcept(
        noexcept(_Current -= _Off))   {
        _Current -= _Off;
        return *this;
    }

    [[nodiscard]] constexpr reference operator[](const difference_type _Off) const

        noexcept(noexcept(::std::ranges:: iter_move(_Current + _Off)))   {
        return ::std::ranges:: iter_move(_Current + _Off);



#line 4064 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
    }


    template <sentinel_for<_Iter> _Sent>
    [[nodiscard]] friend constexpr bool
        operator==(const move_iterator& _Left, const move_sentinel<_Sent>& _Right) noexcept(
            noexcept(_Fake_copy_init<bool>(_Left._Current == _Right._Get_last())))   {
        return _Left._Current == _Right._Get_last();
    }

    template <sized_sentinel_for<_Iter> _Sent>
    [[nodiscard]] friend constexpr difference_type operator-(const move_sentinel<_Sent>& _Left,
        const move_iterator& _Right) noexcept(noexcept(_Left._Get_last() - _Right._Current))   {
        return _Left._Get_last() - _Right._Current;
    }

    template <sized_sentinel_for<_Iter> _Sent>
    [[nodiscard]] friend constexpr difference_type operator-(const move_iterator& _Left,
        const move_sentinel<_Sent>& _Right) noexcept(noexcept(_Left._Current - _Right._Get_last()))   {
        return _Left._Current - _Right._Get_last();
    }

    [[nodiscard]] friend constexpr reference iter_move(const move_iterator& _It)



        noexcept(noexcept(::std::ranges:: iter_move(_It._Current)))
#line 4092 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
    {
        return ::std::ranges:: iter_move(_It._Current);
    }

    template <indirectly_swappable<_Iter> _Iter2>
    friend constexpr void iter_swap(const move_iterator& _Left, const move_iterator<_Iter2>& _Right)



        noexcept(noexcept(::std::ranges:: iter_swap(_Left._Current, _Right.base())))
#line 4103 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
    {
        ::std::ranges:: iter_swap(_Left._Current, _Right.base());
    }
#line 4107 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

    template <class _Iter2, enable_if_t<_Range_verifiable_v<_Iter, _Iter2>, int> = 0>
    friend constexpr void _Verify_range(const move_iterator& _First, const move_iterator<_Iter2>& _Last) noexcept {
        _Verify_range(_First._Current, _Last._Get_current());
    }

    template <sentinel_for<_Iter> _Sent, enable_if_t<_Range_verifiable_v<_Iter, _Sent>, int> = 0>
    friend constexpr void _Verify_range(const move_iterator& _First, const move_sentinel<_Sent>& _Last) noexcept {
        _Verify_range(_First._Current, _Last._Get_last());
    }
#line 4118 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

    using _Prevent_inheriting_unwrap = move_iterator;

    template <class _Iter2 = iterator_type, enable_if_t<_Offset_verifiable_v<_Iter2>, int> = 0>
    constexpr void _Verify_offset(const difference_type _Off) const noexcept {
        _Current._Verify_offset(_Off);
    }

    template <class _Iter2 = iterator_type, enable_if_t<_Unwrappable_v<const _Iter2&>, int> = 0>
    [[nodiscard]] constexpr move_iterator<_Unwrapped_t<const _Iter2&>> _Unwrapped() const& noexcept(
        noexcept(static_cast<move_iterator<_Unwrapped_t<const _Iter2&>>>(_Current._Unwrapped()))) {
        return static_cast<move_iterator<_Unwrapped_t<const _Iter2&>>>(_Current._Unwrapped());
    }
    template <class _Iter2 = iterator_type, enable_if_t<_Unwrappable_v<_Iter2>, int> = 0>
    [[nodiscard]] constexpr move_iterator<_Unwrapped_t<_Iter2>> _Unwrapped() && noexcept(
        noexcept(static_cast<move_iterator<_Unwrapped_t<_Iter2>>>(::std:: move(_Current)._Unwrapped()))) {
        return static_cast<move_iterator<_Unwrapped_t<_Iter2>>>(::std:: move(_Current)._Unwrapped());
    }

    static constexpr bool _Unwrap_when_unverified = _Do_unwrap_when_unverified_v<iterator_type>;

    template <class _Src, enable_if_t<_Wrapped_seekable_v<iterator_type, const _Src&>, int> = 0>
    constexpr void _Seek_to(const move_iterator<_Src>& _It) noexcept(noexcept(_Current._Seek_to(_It._Get_current()))) {
        _Current._Seek_to(_It._Get_current());
    }
    template <class _Src, enable_if_t<_Wrapped_seekable_v<iterator_type, _Src>, int> = 0>
    constexpr void _Seek_to(move_iterator<_Src>&& _It) noexcept(
        noexcept(_Current._Seek_to(::std:: move(_It)._Get_current()))) {
        _Current._Seek_to(::std:: move(_It)._Get_current());
    }

    [[nodiscard]] constexpr const iterator_type& _Get_current() const& noexcept {
        return _Current;
    }
    [[nodiscard]] constexpr iterator_type&& _Get_current() && noexcept {
        return ::std:: move(_Current);
    }

private:
    iterator_type _Current{};
};

 template <class _Iter1, class _Iter2>
[[nodiscard]] constexpr bool
    operator==(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right) noexcept(
        noexcept(_Fake_copy_init<bool>(_Left.base() == _Right.base())))  

    
    requires requires {
        { _Left.base() == _Right.base() } -> _Implicitly_convertible_to<bool>;
    }

#line 4171 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
{
    return _Left.base() == _Right.base();
}







#line 4182 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

 template <class _Iter1, class _Iter2>
[[nodiscard]] constexpr bool
    operator<(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right) noexcept(
        noexcept(_Fake_copy_init<bool>(_Left.base() < _Right.base())))  

    
    requires requires {
        { _Left.base() < _Right.base() } -> _Implicitly_convertible_to<bool>;
    }

#line 4194 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
{
    return _Left.base() < _Right.base();
}

 template <class _Iter1, class _Iter2>
[[nodiscard]] constexpr bool operator>(const move_iterator<_Iter1>& _Left,
    const move_iterator<_Iter2>& _Right) noexcept(noexcept(_Right < _Left))  

    requires requires { _Right < _Left; }
#line 4204 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
{
    return _Right < _Left;
}

 template <class _Iter1, class _Iter2>
[[nodiscard]] constexpr bool operator<=(const move_iterator<_Iter1>& _Left,
    const move_iterator<_Iter2>& _Right) noexcept(noexcept(_Right < _Left))  

    requires requires { _Right < _Left; }
#line 4214 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
{
    return !(_Right < _Left);
}

 template <class _Iter1, class _Iter2>
[[nodiscard]] constexpr bool operator>=(const move_iterator<_Iter1>& _Left,
    const move_iterator<_Iter2>& _Right) noexcept(noexcept(_Left < _Right))  

    requires requires { _Left < _Right; }
#line 4224 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
{
    return !(_Left < _Right);
}


 template <class _Iter1, three_way_comparable_with<_Iter1> _Iter2>
[[nodiscard]] constexpr compare_three_way_result_t<_Iter1, _Iter2> operator<=>(const move_iterator<_Iter1>& _Left,
    const move_iterator<_Iter2>& _Right) noexcept(noexcept(_Left.base() <=> _Right.base()))   {
    return _Left.base() <=> _Right.base();
}
#line 4235 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

 template <class _Iter1, class _Iter2>
[[nodiscard]] constexpr auto operator-(const move_iterator<_Iter1>& _Left,
    const move_iterator<_Iter2>& _Right) noexcept(noexcept(_Left.base() - _Right.base()))  
    -> decltype(_Left.base() - _Right.base()) {
    return _Left.base() - _Right.base();
}

 template <class _Iter>
[[nodiscard]] constexpr move_iterator<_Iter>
    operator+(typename move_iterator<_Iter>::difference_type _Off, const move_iterator<_Iter>& _Right) noexcept(
        noexcept(move_iterator<_Iter>(_Right.base() + _Off)))  

    
    requires requires {
        { _Right.base() + _Off } -> same_as<_Iter>;
    }

#line 4254 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
{
    return move_iterator<_Iter>(_Right.base() + _Off);
}

 template <class _Iter>
[[nodiscard]] constexpr move_iterator<_Iter> make_move_iterator(_Iter _It) noexcept(
    is_nothrow_move_constructible_v<_Iter>)   {
    return move_iterator<_Iter>(::std:: move(_It));
}


template <class _Iter1, class _Iter2>
    requires (!sized_sentinel_for<_Iter1, _Iter2>)
inline constexpr bool disable_sized_sentinel_for<move_iterator<_Iter1>, move_iterator<_Iter2>> = true;

 struct default_sentinel_t {};

 inline constexpr default_sentinel_t default_sentinel{};

 struct unreachable_sentinel_t;
namespace _Unreachable_sentinel_detail {
    struct _Base {
        template <weakly_incrementable _Winc>
        [[nodiscard]] friend constexpr bool operator==(const unreachable_sentinel_t&, const _Winc&) noexcept {
            return false;
        }
    };
} 
 struct unreachable_sentinel_t : _Unreachable_sentinel_detail::_Base {}; 

 inline constexpr unreachable_sentinel_t unreachable_sentinel{};
#line 4286 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"






template <class _Iter>
inline constexpr bool _Iterator_is_contiguous = contiguous_iterator<_Iter>;

template <class _Iter>
[[nodiscard]] constexpr auto _To_address(const _Iter& _Val) noexcept {
     ;
    return ::std:: to_address(_Val);
}










#line 4311 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

template <class _Iter>
[[nodiscard]] constexpr auto _To_address(const move_iterator<_Iter>& _Val) noexcept {
    return _To_address(_Val.base());
}



template <class _Iter1, class _Iter2>
inline constexpr bool _Iterators_are_contiguous =
    _Iterator_is_contiguous<_Iter1> && _Iterator_is_contiguous<_Iter2>;

template <class _Iter>
inline constexpr bool _Iterator_is_volatile = is_volatile_v<remove_reference_t<_Iter_ref_t<_Iter>>>;

template <class _Source, class _Dest>
inline constexpr bool _Is_pointer_address_convertible = is_void_v<_Source>
                                                          || is_void_v<_Dest>
                                                          
                                                          || is_same_v<remove_cv_t<_Source>, remove_cv_t<_Dest>>

                                                          || is_pointer_interconvertible_base_of_v<_Dest, _Source>
#line 4334 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
    ;

template <class _Source, class _Dest, class _SourceRef, class _DestRef>
struct _Trivial_cat {
    using _USource = _Unwrap_enum_t<_Source>;
    using _UDest   = _Unwrap_enum_t<_Dest>;

    static constexpr bool _Same_size_and_compatible =
        sizeof(_Source) == sizeof(_Dest)
        
        
        
        && is_same_v<bool, _USource> >= is_same_v<bool, _UDest>
        && (is_same_v<_USource, _UDest> || (is_integral_v<_USource> && is_integral_v<_UDest>)
            || (is_floating_point_v<_USource> && is_floating_point_v<_UDest>) );

    static constexpr bool _Bitcopy_constructible =
        _Same_size_and_compatible && is_trivially_constructible_v<_Dest, _SourceRef>;

    static constexpr bool _Bitcopy_assignable =
        _Same_size_and_compatible && is_trivially_assignable_v<_DestRef, _SourceRef>;
};

template <class _Source, class _Dest, class _SourceRef, class _DestRef>
struct _Trivial_cat<_Source*, _Dest*, _SourceRef, _DestRef> {
    static constexpr bool _Bitcopy_constructible =
        _Is_pointer_address_convertible<_Source, _Dest> && is_trivially_constructible_v<_Dest*, _SourceRef>;

    static constexpr bool _Bitcopy_assignable =
        _Is_pointer_address_convertible<_Source, _Dest> && is_trivially_assignable_v<_DestRef, _SourceRef>;
};

struct _False_trivial_cat {
    static constexpr bool _Bitcopy_constructible = false;
    static constexpr bool _Bitcopy_assignable    = false;
};

template <class _SourceIt, class _DestIt,
    bool _Are_contiguous = _Iterators_are_contiguous<_SourceIt, _DestIt> 
                        && !_Iterator_is_volatile<_SourceIt> && !_Iterator_is_volatile<_DestIt>>
struct _Iter_move_cat : _Trivial_cat<_Iter_value_t<_SourceIt>, _Iter_value_t<_DestIt>,
                            remove_reference_t<_Iter_ref_t<_SourceIt>>&&, _Iter_ref_t<_DestIt>> {};

template <class _SourceIt, class _DestIt>
struct _Iter_move_cat<_SourceIt, _DestIt, false> : _False_trivial_cat {};

template <class _SourceIt, class _DestIt>
struct _Iter_move_cat<move_iterator<_SourceIt>, _DestIt, false> : _Iter_move_cat<_SourceIt, _DestIt> {};

template <class _SourceIt, class _DestIt,
    bool _Are_contiguous = _Iterators_are_contiguous<_SourceIt, _DestIt> 
                        && !_Iterator_is_volatile<_SourceIt> && !_Iterator_is_volatile<_DestIt>>
struct _Iter_copy_cat
    : _Trivial_cat<_Iter_value_t<_SourceIt>, _Iter_value_t<_DestIt>, _Iter_ref_t<_SourceIt>, _Iter_ref_t<_DestIt>> {};

template <class _SourceIt, class _DestIt>
struct _Iter_copy_cat<_SourceIt, _DestIt, false> : _False_trivial_cat {};

template <class _SourceIt, class _DestIt>
struct _Iter_copy_cat<move_iterator<_SourceIt>, _DestIt, false> : _Iter_move_cat<_SourceIt, _DestIt> {};

template <class _Iter1, class _Sent1, class _Iter2>
constexpr void _Verify_ranges_do_not_overlap(const _Iter1& _First1, const _Sent1& _Last1, const _Iter2& _First2) {























#line 4421 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
    (void) _First1;
    (void) _Last1;
    (void) _First2;
#line 4425 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
}

template <class _CtgIt, class _OutCtgIt>
_OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {
    auto _FirstPtr              = _To_address(_First);
    auto _LastPtr               = _To_address(_Last);
    auto _DestPtr               = _To_address(_Dest);
    const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
    const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
    char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
    const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);
    :: memmove(_Dest_ch, _First_ch, _Count);
    if constexpr (is_pointer_v<_OutCtgIt>) {
        return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);
    } else {
        return _Dest + (_LastPtr - _FirstPtr);
    }
}

template <class _CtgIt, class _OutCtgIt>
_OutCtgIt _Copy_memmove_n(_CtgIt _First, const size_t _Count, _OutCtgIt _Dest) {
    const auto _Result = _Copy_memmove(_First, _First + _Count, _Dest);
    if constexpr (is_pointer_v<_OutCtgIt>) {
        return _Result;
    } else { 
        return _Dest + static_cast<_Iter_diff_t<_OutCtgIt>>(_Count);
    }
}

template <class _It, bool _RequiresMutable = false>
inline constexpr bool _Is_vb_iterator = false;

template <class _InIt, class _SizeTy, class _OutIt>
constexpr _OutIt _Copy_n_unchecked4(_InIt _First, _SizeTy _Count, _OutIt _Dest) {
    
    

     ;
#line 4464 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

    if constexpr (_Iter_copy_cat<_InIt, _OutIt>::_Bitcopy_assignable) {

        if (!::std:: is_constant_evaluated())
#line 4469 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        {
            return _Copy_memmove_n(_First, static_cast<size_t>(_Count), _Dest);
        }
    }

    for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {
        *_Dest = *_First;
    }

    return _Dest;
}

template <class _InIt, class _Sent, class _OutIt>
using _Sent_copy_cat = conditional_t<

    is_same_v<_Sent, _InIt> || sized_sentinel_for<_Sent, _InIt>,


#line 4488 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
    _Iter_copy_cat<_InIt, _OutIt>, _False_trivial_cat>;

template <class _InIt, class _Sent, class _OutIt>
constexpr _OutIt _Copy_unchecked(_InIt _First, _Sent _Last, _OutIt _Dest) {
    
    
    if constexpr (_Sent_copy_cat<_InIt, _Sent, _OutIt>::_Bitcopy_assignable) {

        if (!::std:: is_constant_evaluated())
#line 4498 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        {

            if constexpr (is_same_v<_InIt, _Sent>)
#line 4502 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
            {
                return _Copy_memmove(_First, _Last, _Dest);
            }

            else {
                return _Copy_memmove_n(_First, static_cast<size_t>(_Last - _First), _Dest);
            }
#line 4510 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        }
    }

    for (; _First != _Last; ++_Dest, (void) ++_First) {
        *_Dest = *_First;
    }

    return _Dest;
}

 template <class _InIt, class _OutIt>
constexpr _OutIt copy(_InIt _First, _InIt _Last, _OutIt _Dest) { 
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    const auto _UDest  = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
    _Seek_wrapped(_Dest, ::std:: _Copy_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}


 template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
_FwdIt2 copy(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last, _FwdIt2 _Dest) noexcept   {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.") ;
    static_assert(_Is_cpp17_fwd_iter_v<_FwdIt2>, "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.") ;
    return ::std:: copy(_First, _Last, _Dest);
}
#line 4540 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"


namespace ranges {
    template <class _To, class _From>
    concept _Convertible_from = convertible_to<_From, _To>;

     template <class _In, class _Out>
    struct in_out_result {
          _In in;
          _Out out;

        template <_Convertible_from<const _In&> _IIn, _Convertible_from<const _Out&> _OOut>
        constexpr operator in_out_result<_IIn, _OOut>() const& {
            return {in, out};
        }

        template <_Convertible_from<_In> _IIn, _Convertible_from<_Out> _OOut>
        constexpr operator in_out_result<_IIn, _OOut>() && {
            return {::std:: move(in), ::std:: move(out)};
        }
    };

    template <forward_iterator _It, class _Se>
        requires sentinel_for<remove_cvref_t<_Se>, _It>
    [[nodiscard]] constexpr _Unwrap_iter_t<_It, _Se> _Get_final_iterator_unwrapped(
        const _Unwrap_iter_t<_It, _Se>& _UFirst, _Se&& _Last) {
        
        
        if constexpr (is_same_v<_Unwrap_iter_t<_It, _Se>, _Unwrap_sent_t<_Se, _It>>) {
            return _Unwrap_sent<_It>(::std:: forward<_Se>(_Last));
        } else {
            return ::std::ranges:: next(_UFirst, _Unwrap_sent<_It>(::std:: forward<_Se>(_Last)));
        }
    }

    template <forward_range _Rng>
    [[nodiscard]] constexpr auto _Get_final_iterator_unwrapped(_Rng& _Range) {
        
        if constexpr (common_range<_Rng>) {
            if constexpr (same_as<decltype(_Uend(_Range)), _Unwrapped_iterator_t<_Rng>>) {
                return _Uend(_Range);
            } else {
                return _Unwrap_range_sent<_Rng>(::std::ranges:: end(_Range));
            }
        } else if constexpr (sized_range<_Rng>) {
            return ::std::ranges:: next(_Ubegin(_Range), ::std::ranges:: distance(_Range));
        } else {
            return ::std::ranges:: next(_Ubegin(_Range), _Uend(_Range));
        }
    }

    template <forward_range _Rng>
    [[nodiscard]] constexpr auto _Get_final_iterator_unwrapped(_Rng& _Range, const _Unwrapped_iterator_t<_Rng>& _Mid) {
        
        
        if constexpr (common_range<_Rng>) {
            if constexpr (same_as<decltype(_Uend(_Range)), _Unwrapped_iterator_t<_Rng>>) {
                return _Uend(_Range);
            } else {
                return _Unwrap_range_sent<_Rng>(::std::ranges:: end(_Range));
            }
        } else if constexpr (sized_range<_Rng>) {
            const auto _Dist = ::std::ranges:: distance(_Range);
            if constexpr (sized_sentinel_for<_Unwrapped_iterator_t<_Rng>, _Unwrapped_iterator_t<_Rng>>) {
                return ::std::ranges:: next(_Mid, _Dist - (_Mid - _Ubegin(_Range)));
            } else {
                return ::std::ranges:: next(_Ubegin(_Range), _Dist);
            }
        } else {
            return ::std::ranges:: next(_Mid, _Uend(_Range));
        }
    }

















#line 4630 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

     template <class _In, class _Out>
    using copy_result = in_out_result<_In, _Out>;

    template <input_iterator _It, sentinel_for<_It> _Se, weakly_incrementable _Out>
        requires indirectly_copyable<_It, _Out>
    [[nodiscard]] constexpr copy_result<_It, _Out> _Copy_unchecked(_It _First, _Se _Last, _Out _Result) {
        if constexpr (_Sent_copy_cat<_It, _Se, _Out>::_Bitcopy_assignable) {
            if (!::std:: is_constant_evaluated()) {
                if constexpr (is_same_v<_It, _Se>) {
                    _Result = _Copy_memmove(::std:: move(_First), _Last, ::std:: move(_Result));
                    return {::std:: move(_Last), ::std:: move(_Result)};
                } else {
                    const auto _Count = static_cast<size_t>(_Last - _First);
                    _Result           = _Copy_memmove_n(_First, _Count, ::std:: move(_Result));
                    _First += _Count;
                    return {::std:: move(_First), ::std:: move(_Result)};
                }
            }
        }

        for (; _First != _Last; ++_First, (void) ++_Result) {
            *_Result = *_First;
        }

        return {::std:: move(_First), ::std:: move(_Result)};
    }

    class _Copy_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It, sentinel_for<_It> _Se, weakly_incrementable _Out>
            requires indirectly_copyable<_It, _Out>
        constexpr copy_result<_It, _Out> operator()(_It _First, _Se _Last, _Out _Result) const {
            _Adl_verify_range(_First, _Last);
            auto _UResult = ::std::ranges:: _Copy_unchecked(
                _Unwrap_iter<_Se>(::std:: move(_First)), _Unwrap_sent<_It>(::std:: move(_Last)), ::std:: move(_Result));
            _Seek_wrapped(_First, ::std:: move(_UResult.in));
            return {::std:: move(_First), ::std:: move(_UResult.out)};
        }

        template <input_range _Rng, weakly_incrementable _Out>
            requires indirectly_copyable<iterator_t<_Rng>, _Out>
        constexpr copy_result<borrowed_iterator_t<_Rng>, _Out> operator()(_Rng&& _Range, _Out _Result) const {
            auto _First = ::std::ranges:: begin(_Range);
            auto _UResult =
                ::std::ranges:: _Copy_unchecked(_Unwrap_range_iter<_Rng>(::std:: move(_First)), _Uend(_Range), ::std:: move(_Result));
            _Seek_wrapped(_First, ::std:: move(_UResult.in));
            return {::std:: move(_First), ::std:: move(_UResult.out)};
        }
    };

     inline constexpr _Copy_fn copy{_Not_quite_object::_Construct_tag {}};
} 
#line 4686 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

 template <class _InIt, class _Diff, class _OutIt>
constexpr _OutIt copy_n(_InIt _First, _Diff _Count_raw, _OutIt _Dest) {
    
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        auto _UFirst = _Get_unwrapped_n(_First, _Count);
        auto _UDest  = _Get_unwrapped_n(_Dest, _Count);
        if constexpr (_Iter_copy_cat<decltype(_UFirst), decltype(_UDest)>::_Bitcopy_assignable) {

            if (!::std:: is_constant_evaluated())
#line 4698 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
            {
                _UDest = _Copy_memmove_n(_UFirst, static_cast<size_t>(_Count), _UDest);
                _Seek_wrapped(_Dest, _UDest);
                return _Dest;
            }
        }

        for (;;) {
            *_UDest = *_UFirst;
            ++_UDest;
            --_Count;
            if (_Count == 0) { 
                               
                break;
            }

            ++_UFirst;
        }

        _Seek_wrapped(_Dest, _UDest);
    }

    return _Dest;
}


 template <class _ExPo, class _FwdIt1, class _Diff, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
_FwdIt2 copy_n(_ExPo&&, _FwdIt1 _First, _Diff _Count_raw, _FwdIt2 _Dest) noexcept   {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.") ;
    static_assert(_Is_cpp17_fwd_iter_v<_FwdIt2>, "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.") ;
    return ::std:: copy_n(_First, _Count_raw, _Dest);
}
#line 4733 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

template <class _CtgIt1, class _CtgIt2>
_CtgIt2 _Copy_backward_memmove(_CtgIt1 _First, _CtgIt1 _Last, _CtgIt2 _Dest) {
    
    auto _FirstPtr              = _To_address(_First);
    auto _LastPtr               = _To_address(_Last);
    auto _DestPtr               = _To_address(_Dest);
    const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
    const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
    char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
    const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);
    auto _Result                = :: memmove(_Dest_ch - _Count, _First_ch, _Count);
    if constexpr (is_pointer_v<_CtgIt2>) {
        return static_cast<_CtgIt2>(_Result);
    } else {
        return _Dest - (_LastPtr - _FirstPtr);
    }
}

template <class _BidIt1, class _BidIt2>
_BidIt2 _Copy_backward_memmove(move_iterator<_BidIt1> _First, move_iterator<_BidIt1> _Last, _BidIt2 _Dest) {
    return _Copy_backward_memmove(_First.base(), _Last.base(), _Dest);
}

template <class _BidIt1, class _BidIt2>
[[nodiscard]] constexpr _BidIt2 _Copy_backward_unchecked(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {
    
    if constexpr (_Iter_copy_cat<_BidIt1, _BidIt2>::_Bitcopy_assignable) {

        if (!::std:: is_constant_evaluated())
#line 4764 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        {
            return _Copy_backward_memmove(_First, _Last, _Dest);
        }
    }

    while (_First != _Last) {
        *--_Dest = *--_Last;
    }

    return _Dest;
}

 template <class _BidIt1, class _BidIt2>
constexpr _BidIt2 copy_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {
    
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    const auto _UDest  = _Get_unwrapped_n(_Dest, -_Idl_distance<_BidIt1>(_UFirst, _ULast));
    _Seek_wrapped(_Dest, _Copy_backward_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}

template <class _InIt, class _OutIt>
constexpr _OutIt _Move_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest) {
    
    
    if constexpr (_Iter_move_cat<_InIt, _OutIt>::_Bitcopy_assignable) {

        if (!::std:: is_constant_evaluated())
#line 4795 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        {
            return _Copy_memmove(_First, _Last, _Dest);
        }
    }

    for (; _First != _Last; ++_Dest, (void) ++_First) {
        *_Dest = ::std:: move(*_First);
    }

    return _Dest;
}

 template <class _InIt, class _OutIt>
constexpr _OutIt move(_InIt _First, _InIt _Last, _OutIt _Dest) {
    
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    const auto _UDest  = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
    _Seek_wrapped(_Dest, ::std:: _Move_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}


 template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
_FwdIt2 move(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last, _FwdIt2 _Dest) noexcept   {
    
    
    static_assert(_Is_cpp17_fwd_iter_v<_FwdIt1>, "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.") ;
    static_assert(_Is_cpp17_fwd_iter_v<_FwdIt2>, "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.") ;
    return ::std:: move(_First, _Last, _Dest);
}
#line 4828 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

template <class _BidIt1, class _BidIt2>
constexpr _BidIt2 _Move_backward_unchecked(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {
    
    
    if constexpr (_Iter_move_cat<_BidIt1, _BidIt2>::_Bitcopy_assignable) {

        if (!::std:: is_constant_evaluated())
#line 4837 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        {
            return _Copy_backward_memmove(_First, _Last, _Dest);
        }
    }

    while (_First != _Last) {
        *--_Dest = ::std:: move(*--_Last);
    }

    return _Dest;
}

 template <class _BidIt1, class _BidIt2>
constexpr _BidIt2 move_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {
    
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    const auto _UDest  = _Get_unwrapped_n(_Dest, -_Idl_distance<_BidIt1>(_UFirst, _ULast));
    _Seek_wrapped(_Dest, _Move_backward_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}


template <class _Ty>
struct _Is_character : false_type {}; 

template <>
struct _Is_character<char> : true_type {}; 

template <>
struct _Is_character<signed char> : true_type {}; 

template <>
struct _Is_character<unsigned char> : true_type {}; 


template <>
struct _Is_character<char8_t> : true_type {}; 
#line 4877 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

template <class _Ty>
struct _Is_character_or_bool : _Is_character<_Ty>::type {};

template <>
struct _Is_character_or_bool<bool> : true_type {};

template <class _Ty>
struct _Is_character_or_byte_or_bool : _Is_character_or_bool<_Ty>::type {};


template <>
struct _Is_character_or_byte_or_bool<byte> : true_type {};
#line 4891 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"



template <class _FwdIt, class _Ty, bool = _Iterator_is_contiguous<_FwdIt>>
inline constexpr bool _Fill_memset_is_safe = conjunction_v<is_scalar<_Ty>,
    _Is_character_or_byte_or_bool<_Unwrap_enum_t<remove_reference_t<_Iter_ref_t<_FwdIt>>>>,
    negation<is_volatile<remove_reference_t<_Iter_ref_t<_FwdIt>>>>, is_assignable<_Iter_ref_t<_FwdIt>, const _Ty&>>;

template <class _FwdIt, class _Ty>
inline constexpr bool _Fill_memset_is_safe<_FwdIt, _Ty, false> = false;

template <class _FwdIt, class _Ty, bool = _Iterator_is_contiguous<_FwdIt>>
inline constexpr bool _Fill_zero_memset_is_safe =
    conjunction_v<is_scalar<_Ty>, is_scalar<_Iter_value_t<_FwdIt>>, negation<is_member_pointer<_Iter_value_t<_FwdIt>>>,
        negation<is_volatile<remove_reference_t<_Iter_ref_t<_FwdIt>>>>, is_assignable<_Iter_ref_t<_FwdIt>, const _Ty&>>;

template <class _FwdIt, class _Ty>
inline constexpr bool _Fill_zero_memset_is_safe<_FwdIt, _Ty, false> = false;

template <class _CtgIt, class _Ty>
void _Fill_memset(_CtgIt _Dest, const _Ty _Val, const size_t _Count) {
    
    _Iter_value_t<_CtgIt> _Dest_val = _Val;
    :: memset(_To_address(_Dest), static_cast<unsigned char>(_Dest_val), _Count);
}

template <class _CtgIt>
void _Fill_zero_memset(_CtgIt _Dest, const size_t _Count) {
    :: memset(_To_address(_Dest), 0, _Count * sizeof(_Iter_value_t<_CtgIt>));
}

template <class _Ty>
[[nodiscard]] bool _Is_all_bits_zero(const _Ty& _Val) {
    
     ;
    if constexpr (is_same_v<_Ty, nullptr_t>) {
        return true;
    } else {
        constexpr _Ty _Zero{};
        return :: memcmp(&_Val, &_Zero, sizeof(_Ty)) == 0;
    }
}

 template <class _FwdIt, class _Ty>
constexpr void fill(const _FwdIt _First, const _FwdIt _Last, const _Ty& _Val) {
    
    _Adl_verify_range(_First, _Last);
    if constexpr (_Is_vb_iterator<_FwdIt, true>) {
        _Fill_vbool(_First, _Last, _Val);
    } else {
        auto _UFirst      = _Get_unwrapped(_First);
        const auto _ULast = _Get_unwrapped(_Last);

        if (!::std:: is_constant_evaluated())
#line 4946 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        {
            if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
                _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
                return;
            } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
                if (_Is_all_bits_zero(_Val)) {
                    _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
                    return;
                }
            }
        }

        for (; _UFirst != _ULast; ++_UFirst) {
            *_UFirst = _Val;
        }
    }
}


 template <class _ExPo, class _FwdIt, class _Ty, _Enable_if_execution_policy_t<_ExPo> = 0>
void fill(_ExPo&&, _FwdIt _First, _FwdIt _Last, const _Ty& _Val) noexcept   {
    
    
    static_assert(_Is_cpp17_fwd_iter_v<_FwdIt>, "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.") ;
    return ::std:: fill(_First, _Last, _Val);
}
#line 4973 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

 template <class _OutIt, class _Diff, class _Ty>
constexpr _OutIt fill_n(_OutIt _Dest, const _Diff _Count_raw, const _Ty& _Val) {
    
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        if constexpr (_Is_vb_iterator<_OutIt, true>) {
            const auto _Last = _Dest + static_cast<typename _OutIt::difference_type>(_Count);
            _Fill_vbool(_Dest, _Last, _Val);
            return _Last;
        } else {
            auto _UDest = _Get_unwrapped_n(_Dest, _Count);

            if (!::std:: is_constant_evaluated())
#line 4988 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
            {
                if constexpr (_Fill_memset_is_safe<decltype(_UDest), _Ty>) {
                    _Fill_memset(_UDest, _Val, static_cast<size_t>(_Count));
                    _Seek_wrapped(_Dest, _UDest + _Count);
                    return _Dest;
                } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UDest), _Ty>) {
                    if (_Is_all_bits_zero(_Val)) {
                        _Fill_zero_memset(_UDest, static_cast<size_t>(_Count));
                        _Seek_wrapped(_Dest, _UDest + _Count);
                        return _Dest;
                    }
                }
            }

            for (; 0 < _Count; --_Count, (void) ++_UDest) {
                *_UDest = _Val;
            }

            _Seek_wrapped(_Dest, _UDest);
        }
    }
    return _Dest;
}


 template <class _ExPo, class _FwdIt, class _Diff, class _Ty, _Enable_if_execution_policy_t<_ExPo> = 0>
_FwdIt fill_n(_ExPo&&, _FwdIt _Dest, _Diff _Count_raw, const _Ty& _Val) noexcept   {
    
    
    static_assert(_Is_cpp17_fwd_iter_v<_FwdIt>, "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.") ;
    return ::std:: fill_n(_Dest, _Count_raw, _Val);
}
#line 5021 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"


namespace ranges {
    class _Fill_n_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <class _Ty, output_iterator<const _Ty&> _It>
        constexpr _It operator()(_It _First, iter_difference_t<_It> _Count, const _Ty& _Value) const {
            if (_Count > 0) {
                auto _UFirst = _Get_unwrapped_n(::std:: move(_First), _Count);
                if (!::std:: is_constant_evaluated()) {
                    if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
                        _Fill_memset(_UFirst, _Value, static_cast<size_t>(_Count));
                        _Seek_wrapped(_First, _UFirst + _Count); 
                        return _First;
                    } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
                        if (_Is_all_bits_zero(_Value)) {
                            _Fill_zero_memset(_UFirst, static_cast<size_t>(_Count));
                            _Seek_wrapped(_First, _UFirst + _Count); 
                            return _First;
                        }
                    }
                }

                for (; _Count > 0; ++_UFirst, (void) --_Count) {
                    *_UFirst = _Value;
                }

                _Seek_wrapped(_First, ::std:: move(_UFirst));
            }

            return _First;
        }
    };

     inline constexpr _Fill_n_fn fill_n{_Not_quite_object::_Construct_tag {}};
} 
#line 5060 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

template <class _Ty1, class _Ty2, class = void>
inline constexpr bool _Can_compare_with_operator_equal = false;

template <class _Ty1, class _Ty2>
inline constexpr bool
    _Can_compare_with_operator_equal<_Ty1, _Ty2, void_t<decltype(::std:: declval<_Ty1&>() == ::std:: declval<_Ty2&>())>> =
        true;

template <class _Ty1, class _Ty2>
inline constexpr bool _Is_pointer_address_comparable =
    _Can_compare_with_operator_equal<_Ty1*, _Ty2*>
    && (_Is_pointer_address_convertible<_Ty1, _Ty2> || _Is_pointer_address_convertible<_Ty2, _Ty1>);








#pragma warning(push)
#pragma warning(disable : 4806) 
template <class _Elem1, class _Elem2,
    bool = sizeof(_Elem1) == sizeof(_Elem2) && is_integral_v<_Elem1>&& is_integral_v<_Elem2>>
inline constexpr bool _Can_memcmp_elements =
    is_same_v<_Elem1, bool> || is_same_v<_Elem2, bool> || static_cast<_Elem1>(-1) == static_cast<_Elem2>(-1);
#pragma warning(pop)





template <>
inline constexpr bool _Can_memcmp_elements<byte, byte, false> = true;
#line 5096 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"



template <class _Ty1, class _Ty2>
inline constexpr bool _Can_memcmp_elements<_Ty1*, _Ty2*, false> = _Is_pointer_address_comparable<_Ty1, _Ty2>;

template <class _Elem1, class _Elem2>
inline constexpr bool _Can_memcmp_elements<_Elem1, _Elem2, false> = false;




template <class _Elem1, class _Elem2, class _Pr>
inline constexpr bool _Can_memcmp_elements_with_pred = false;



template <class _Elem1, class _Elem2, class _Elem3>
inline constexpr bool _Can_memcmp_elements_with_pred<_Elem1, _Elem2, equal_to<_Elem3>> =
    _Iter_copy_cat<_Elem1*, _Elem3*>::_Bitcopy_constructible && _Iter_copy_cat<_Elem2*, _Elem3*>::_Bitcopy_constructible
    && _Can_memcmp_elements<remove_cv_t<_Elem3>, remove_cv_t<_Elem3>>;


template <class _Elem1, class _Elem2>
inline constexpr bool _Can_memcmp_elements_with_pred<_Elem1, _Elem2, equal_to<>> =
    _Can_memcmp_elements<_Elem1, _Elem2>;



template <class _Elem1, class _Elem2>
inline constexpr bool _Can_memcmp_elements_with_pred<_Elem1, _Elem2, ::std::ranges:: equal_to> =
    _Can_memcmp_elements<_Elem1, _Elem2>;
#line 5129 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"




template <class _Iter1, class _Iter2, class _Pr>
inline constexpr bool _Equal_memcmp_is_safe_helper =
    _Iterators_are_contiguous<_Iter1, _Iter2> 
    && !_Iterator_is_volatile<_Iter1> && !_Iterator_is_volatile<_Iter2> 
    && _Can_memcmp_elements_with_pred<_Iter_value_t<_Iter1>, _Iter_value_t<_Iter2>, _Pr>;

template <class _Iter1, class _Iter2, class _Pr>
inline constexpr bool _Equal_memcmp_is_safe =
    _Equal_memcmp_is_safe_helper<remove_const_t<_Iter1>, remove_const_t<_Iter2>, _Pr>;

template <class _CtgIt1, class _CtgIt2>
[[nodiscard]] int _Memcmp_ranges(_CtgIt1 _First1, _CtgIt1 _Last1, _CtgIt2 _First2) {
     ;
    const auto _First1_ch = reinterpret_cast<const char*>(_To_address(_First1));
    const auto _Last1_ch  = reinterpret_cast<const char*>(_To_address(_Last1));
    const auto _First2_ch = reinterpret_cast<const char*>(_To_address(_First2));
    return :: memcmp(_First1_ch, _First2_ch, static_cast<size_t>(_Last1_ch - _First1_ch));
}

template <class _CtgIt1, class _CtgIt2>
[[nodiscard]] int _Memcmp_count(_CtgIt1 _First1, _CtgIt2 _First2, const size_t _Count) {
     ;
    const auto _First1_ch = reinterpret_cast<const char*>(_To_address(_First1));
    const auto _First2_ch = reinterpret_cast<const char*>(_To_address(_First2));
    return :: memcmp(_First1_ch, _First2_ch, _Count * sizeof(_Iter_value_t<_CtgIt1>));
}

 template <class _InIt1, class _InIt2, class _Pr>
[[nodiscard]] constexpr bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped_n(_First2, _Idl_distance<_InIt1>(_UFirst1, _ULast1));
    if constexpr (_Equal_memcmp_is_safe<decltype(_UFirst1), decltype(_UFirst2), _Pr>) {

        if (!::std:: is_constant_evaluated())
#line 5171 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        {
            return _Memcmp_ranges(_UFirst1, _ULast1, _UFirst2) == 0;
        }
    }

    for (; _UFirst1 != _ULast1; ++_UFirst1, (void) ++_UFirst2) {
        if (!_Pred(*_UFirst1, *_UFirst2)) {
            return false;
        }
    }

    return true;
}


 template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] bool equal(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
    _Pr _Pred) noexcept; 
#line 5190 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

 template <class _InIt1, class _InIt2>
[[nodiscard]] constexpr bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2) {
    
    return ::std:: equal(_First1, _Last1, _First2, equal_to<>{});
}


 template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] bool equal(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2) noexcept
  {
    
    return ::std:: equal(::std:: forward<_ExPo>(_Exec), _First1, _Last1, _First2, equal_to{});
}
#line 5205 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

 template <class _InIt1, class _InIt2, class _Pr>
[[nodiscard]] constexpr bool equal(
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);
    if constexpr (_Is_ranges_random_iter_v<_InIt1> && _Is_ranges_random_iter_v<_InIt2>) {
        if (_ULast1 - _UFirst1 != _ULast2 - _UFirst2) {
            return false;
        }

        return ::std:: equal(_UFirst1, _ULast1, _UFirst2, _Pass_fn(_Pred));
    } else {
        for (;;) {
            if (_UFirst1 == _ULast1) {
                return _UFirst2 == _ULast2;
            }

            if (_UFirst2 == _ULast2) {
                return false;
            }

            if (!_Pred(*_UFirst1, *_UFirst2)) {
                return false;
            }

            ++_UFirst1;
            ++_UFirst2;
        }
    }
}


 template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] bool equal(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
    const _FwdIt2 _Last2, _Pr _Pred) noexcept; 
#line 5247 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

 template <class _InIt1, class _InIt2>
[[nodiscard]] constexpr bool equal(
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2) {
    
    return ::std:: equal(_First1, _Last1, _First2, _Last2, equal_to<>{});
}


 template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] bool equal(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
    const _FwdIt2 _Last2) noexcept   {
    
    return ::std:: equal(::std:: forward<_ExPo>(_Exec), _First1, _Last1, _First2, _Last2, equal_to{});
}
#line 5263 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"


namespace ranges {
    template <forward_range _Rng, class _It>
    [[nodiscard]] constexpr iterator_t<_Rng> _Rewrap_iterator(_Rng&& _Range, _It&& _Val) {
         ;

        if constexpr (is_same_v<remove_cvref_t<_It>, iterator_t<_Rng>>) {
            return ::std:: forward<_It>(_Val);
        } else {
            auto _Result = ::std::ranges:: begin(_Range);
            _Result._Seek_to(::std:: forward<_It>(_Val));
            return _Result;
        }
    }

     template <class _In1, class _In2>
    struct in_in_result {
          _In1 in1;
          _In2 in2;

        template <_Convertible_from<const _In1&> _IIn1, _Convertible_from<const _In2&> _IIn2>
        constexpr operator in_in_result<_IIn1, _IIn2>() const& {
            return {in1, in2};
        }

        template <_Convertible_from<_In1> _IIn1, _Convertible_from<_In2> _IIn2>
        constexpr operator in_in_result<_IIn1, _IIn2>() && {
            return {::std:: move(in1), ::std:: move(in2)};
        }
    };

     template <class _In1, class _In2>
    using mismatch_result = in_in_result<_In1, _In2>;

    
    template <input_iterator _It1, input_iterator _It2, class _Pr, class _Pj1, class _Pj2>
        requires indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>
    [[nodiscard]] constexpr mismatch_result<_It1, _It2> _Mismatch_n(
        _It1 _First1, _It2 _First2, iter_difference_t<_It1> _Count, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
        
         ;
        for (; _Count != 0; ++_First1, (void) ++_First2, --_Count) {
            if (!::std:: invoke(_Pred, ::std:: invoke(_Proj1, *_First1), ::std:: invoke(_Proj2, *_First2))) {
                break;
            }
        }

        return {::std:: move(_First1), ::std:: move(_First2)};
    }

    template <input_iterator _It1, sentinel_for<_It1> _Se1, input_iterator _It2, sentinel_for<_It2> _Se2, class _Pr,
        class _Pj1, class _Pj2>
        requires indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>
    [[nodiscard]] constexpr mismatch_result<_It1, _It2> _Mismatch_4(
        _It1 _First1, _Se1 _Last1, _It2 _First2, _Se2 _Last2, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {

        for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void) ++_First2) {
            if (!::std:: invoke(_Pred, ::std:: invoke(_Proj1, *_First1), ::std:: invoke(_Proj2, *_First2))) {
                break;
            }
        }

        return {::std:: move(_First1), ::std:: move(_First2)};
    }

    class _Mismatch_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        
        template <input_iterator _It1, sentinel_for<_It1> _Se1, input_iterator _It2, sentinel_for<_It2> _Se2,
            class _Pr = ranges::equal_to, class _Pj1 = identity, class _Pj2 = identity>
            requires indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>
        [[nodiscard]] constexpr mismatch_result<_It1, _It2> operator()(_It1 _First1, _Se1 _Last1,
            _It2 _First2, _Se2 _Last2, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
            
            _Adl_verify_range(_First1, _Last1);
            _Adl_verify_range(_First2, _Last2);

            if constexpr (sized_sentinel_for<_Se1, _It1> && sized_sentinel_for<_Se2, _It2>) {
                iter_difference_t<_It1> _Count1       = _Last1 - _First1;
                const iter_difference_t<_It2> _Count2 = _Last2 - _First2;
                if (_Count1 > _Count2) {
                    _Count1 = static_cast<decltype(_Count1)>(_Count2);
                }

                auto _Result = ::std::ranges:: _Mismatch_n(_Get_unwrapped(::std:: move(_First1)),
                    _Get_unwrapped(::std:: move(_First2)), _Count1, _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
                _Seek_wrapped(_First1, ::std:: move(_Result.in1));
                _Seek_wrapped(_First2, ::std:: move(_Result.in2));
                return {::std:: move(_First1), ::std:: move(_First2)};
            } else {
                auto _Result = ::std::ranges:: _Mismatch_4(_Unwrap_iter<_Se1>(::std:: move(_First1)),
                    _Unwrap_sent<_It1>(::std:: move(_Last1)), _Unwrap_iter<_Se2>(::std:: move(_First2)),
                    _Unwrap_sent<_It2>(::std:: move(_Last2)), _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
                _Seek_wrapped(_First1, ::std:: move(_Result.in1));
                _Seek_wrapped(_First2, ::std:: move(_Result.in2));
                return {::std:: move(_First1), ::std:: move(_First2)};
            }
        }

        template <input_range _Rng1, input_range _Rng2, class _Pr = ranges::equal_to, class _Pj1 = identity,
            class _Pj2 = identity>
            requires indirectly_comparable<iterator_t<_Rng1>, iterator_t<_Rng2>, _Pr, _Pj1, _Pj2>
        [[nodiscard]] constexpr mismatch_result<borrowed_iterator_t<_Rng1>, borrowed_iterator_t<_Rng2>> operator()(
            _Rng1&& _Range1, _Rng2&& _Range2, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
            if constexpr (sized_range<_Rng1> && sized_range<_Rng2>) {
                range_difference_t<_Rng1> _Count1       = ::std::ranges:: distance(_Range1);
                const range_difference_t<_Rng2> _Count2 = ::std::ranges:: distance(_Range2);
                if (_Count1 > _Count2) {
                    _Count1 = static_cast<range_difference_t<_Rng1>>(_Count2);
                }

                auto _First1 = ::std::ranges:: begin(_Range1);
                auto _First2 = ::std::ranges:: begin(_Range2);
                auto _Result = ::std::ranges:: _Mismatch_n(_Get_unwrapped(::std:: move(_First1)),
                    _Get_unwrapped(::std:: move(_First2)), _Count1, _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
                _Seek_wrapped(_First1, ::std:: move(_Result.in1));
                _Seek_wrapped(_First2, ::std:: move(_Result.in2));
                return {::std:: move(_First1), ::std:: move(_First2)};
            } else {
                auto _First1 = ::std::ranges:: begin(_Range1);
                auto _First2 = ::std::ranges:: begin(_Range2);
                auto _Result = ::std::ranges:: _Mismatch_4(_Unwrap_range_iter<_Rng1>(::std:: move(_First1)), _Uend(_Range1),
                    _Unwrap_range_iter<_Rng2>(::std:: move(_First2)), _Uend(_Range2), _Pass_fn(_Pred), _Pass_fn(_Proj1),
                    _Pass_fn(_Proj2));
                _Seek_wrapped(_First1, ::std:: move(_Result.in1));
                _Seek_wrapped(_First2, ::std:: move(_Result.in2));
                return {::std:: move(_First1), ::std:: move(_First2)};
            }
        }
    };

     inline constexpr _Mismatch_fn mismatch{_Not_quite_object::_Construct_tag {}};
} 
#line 5400 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

template <class _Elem1, class _Elem2>
inline constexpr bool _Lex_compare_memcmp_classify_elements = conjunction_v<_Is_character_or_bool<_Elem1>,
    _Is_character_or_bool<_Elem2>, is_unsigned<_Elem1>, is_unsigned<_Elem2>>;


template <>
inline constexpr bool _Lex_compare_memcmp_classify_elements<byte, byte> = true;
#line 5409 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

template <class _Elem1, class _Elem2, class _Pr>
struct _Lex_compare_memcmp_classify_pred {
    using _Pred = void;
};

template <class _Elem1, class _Elem2, class _Elem3>
struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, less<_Elem3>> {
    using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem3, _Elem3>
                                    && _Iter_copy_cat<_Elem1*, _Elem3*>::_Bitcopy_constructible
                                    && _Iter_copy_cat<_Elem2*, _Elem3*>::_Bitcopy_constructible,
        less<int>, void>;
};

template <class _Elem1, class _Elem2>
struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, less<>> {
    using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>, less<int>, void>;
};

template <class _Elem1, class _Elem2, class _Elem3>
struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, greater<_Elem3>> {
    using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem3, _Elem3>
                                    && _Iter_copy_cat<_Elem1*, _Elem3*>::_Bitcopy_constructible
                                    && _Iter_copy_cat<_Elem2*, _Elem3*>::_Bitcopy_constructible,
        greater<int>, void>;
};

template <class _Elem1, class _Elem2>
struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, greater<>> {
    using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>, greater<int>, void>;
};


template <class _Elem1, class _Elem2>
struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, ::std::ranges:: less> {
    using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>, less<int>, void>;
};

template <class _Elem1, class _Elem2>
struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, ::std::ranges:: greater> {
    using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>, greater<int>, void>;
};
#line 5452 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

template <class _It1, class _It2, class _Pr>
using _Lex_compare_memcmp_classify =
    conditional_t<_Iterators_are_contiguous<_It1, _It2> && !_Iterator_is_volatile<_It1> && !_Iterator_is_volatile<_It2>,
        typename _Lex_compare_memcmp_classify_pred<_Iter_value_t<_It1>, _Iter_value_t<_It2>, _Pr>::_Pred, void>;

 template <class _InIt1, class _InIt2, class _Pr>
[[nodiscard]] constexpr bool lexicographical_compare(
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);

    using _Memcmp_pred = _Lex_compare_memcmp_classify<decltype(_UFirst1), decltype(_UFirst2), _Pr>;
    if constexpr (!is_void_v<_Memcmp_pred>) {

        if (!::std:: is_constant_evaluated())
#line 5474 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        {
            const auto _Num1 = static_cast<size_t>(_ULast1 - _UFirst1);
            const auto _Num2 = static_cast<size_t>(_ULast2 - _UFirst2);
            const int _Ans   = _Memcmp_count(_UFirst1, _UFirst2, (::std:: min)(_Num1, _Num2));
            return _Memcmp_pred{}(_Ans, 0) || (_Ans == 0 && _Num1 < _Num2);
        }
    }

    for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UFirst1, (void) ++_UFirst2) { 
        if (static_cast<bool>(_Pred(*_UFirst1, *_UFirst2)) ) {
            return true;
        } else if (_Pred(*_UFirst2, *_UFirst1)) {
            return false;
        }
    }

    return _UFirst1 == _ULast1 && _UFirst2 != _ULast2;
}

 template <class _InIt1, class _InIt2>
[[nodiscard]] constexpr bool lexicographical_compare(
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2) {
    
    return ::std:: lexicographical_compare(_First1, _Last1, _First2, _Last2, less<>{});
}


 template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] bool lexicographical_compare(_ExPo&&, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
    const _FwdIt2 _Last2, _Pr _Pred) noexcept   {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.") ;
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt2>, "Parallel algorithms require forward iterators or stronger.") ;
    return ::std:: lexicographical_compare(_First1, _Last1, _First2, _Last2, _Pass_fn(_Pred));
}

 template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] bool lexicographical_compare(_ExPo&&, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
    const _FwdIt2 _Last2) noexcept   {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.") ;
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt2>, "Parallel algorithms require forward iterators or stronger.") ;
    return ::std:: lexicographical_compare(_First1, _Last1, _First2, _Last2);
}
#line 5521 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"


template <class _Elem1, class _Elem2, class _Cmp>
struct _Lex_compare_three_way_memcmp_classify_comp {
    using _Comp = void;
};

template <class _Elem1, class _Elem2>
struct _Lex_compare_three_way_memcmp_classify_comp<_Elem1, _Elem2, compare_three_way> {
    using _Comp = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>
                                    && three_way_comparable_with<const _Elem1&, const _Elem2&>,
        compare_three_way, void>;
};

template <class _Elem1, class _Elem2>
struct _Lex_compare_three_way_memcmp_classify_comp<_Elem1, _Elem2, _Strong_order::_Cpo> {
    using _Comp =
        conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2> && _Can_strong_order<_Elem1, _Elem2>,
            _Strong_order::_Cpo, void>;
};

template <class _Elem1, class _Elem2>
struct _Lex_compare_three_way_memcmp_classify_comp<_Elem1, _Elem2, _Weak_order::_Cpo> {
    using _Comp =
        conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2> && _Can_weak_order<_Elem1, _Elem2>,
            _Weak_order::_Cpo, void>;
};

template <class _Elem1, class _Elem2>
struct _Lex_compare_three_way_memcmp_classify_comp<_Elem1, _Elem2, _Partial_order::_Cpo> {
    using _Comp =
        conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2> && _Can_partial_order<_Elem1, _Elem2>,
            _Partial_order::_Cpo, void>;
};

template <class _It1, class _It2, class _Cmp>
using _Lex_compare_three_way_memcmp_classify =
    conditional_t<_Iterators_are_contiguous<_It1, _It2> && !_Iterator_is_volatile<_It1> && !_Iterator_is_volatile<_It2>,
        typename _Lex_compare_three_way_memcmp_classify_comp<_Iter_value_t<_It1>, _Iter_value_t<_It2>, _Cmp>::_Comp,
        void>;

 template <class _InIt1, class _InIt2, class _Cmp>
[[nodiscard]] constexpr auto lexicographical_compare_three_way(const _InIt1 _First1, const _InIt1 _Last1,
    const _InIt2 _First2, const _InIt2 _Last2, _Cmp _Comp) -> decltype(_Comp(*_First1, *_First2)) {
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);

    using _Memcmp_pred = _Lex_compare_three_way_memcmp_classify<decltype(_UFirst1), decltype(_UFirst2), _Cmp>;
    if constexpr (!is_void_v<_Memcmp_pred>) {
        if (!::std:: is_constant_evaluated()) {
            const auto _Num1 = static_cast<size_t>(_ULast1 - _UFirst1);
            const auto _Num2 = static_cast<size_t>(_ULast2 - _UFirst2);
            const int _Ans   = _Memcmp_count(_UFirst1, _UFirst2, (::std:: min)(_Num1, _Num2));
            if (_Ans == 0) {
                return _Num1 <=> _Num2;
            } else {
                return _Memcmp_pred{}(_Ans, 0);
            }
        }
    }

    for (;;) {
        if (_UFirst1 == _ULast1) {
            return _UFirst2 == _ULast2 ? strong_ordering::equal : strong_ordering::less;
        }

        if (_UFirst2 == _ULast2) {
            return strong_ordering::greater;
        }

        if (const auto _CmpResult = _Comp(*_UFirst1, *_UFirst2); _CmpResult != 0) {
            return _CmpResult;
        }

        ++_UFirst1;
        ++_UFirst2;
    }
}

 template <class _InIt1, class _InIt2>
[[nodiscard]] constexpr auto lexicographical_compare_three_way(
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2) {
    return ::std:: lexicographical_compare_three_way(_First1, _Last1, _First2, _Last2, compare_three_way{});
}
#line 5610 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

template <class _Ty, class _Elem>
struct _Vector_alg_in_find_is_safe_object_pointers : false_type {};
template <class _Ty1, class _Ty2>
struct _Vector_alg_in_find_is_safe_object_pointers<_Ty1*, _Ty2*>
    : conjunction<
          
          disjunction<is_object<_Ty1>, is_void<_Ty1>>,
          
          disjunction<is_object<_Ty2>, is_void<_Ty2>>,
          
          disjunction<is_same<remove_cv_t<_Ty1>, remove_cv_t<_Ty2>>, is_void<_Ty1>, is_void<_Ty2>>> {};


template <class _Iter, class _Ty, class _Elem = _Iter_value_t<_Iter>>
inline constexpr bool _Vector_alg_in_find_is_safe =
    
    _Iterator_is_contiguous<_Iter>
    
    && !_Iterator_is_volatile<_Iter>
    
    && disjunction_v<

        
        conjunction<is_same<_Ty, byte>, is_same<_Elem, byte>>,
#line 5636 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
       
       
        conjunction<is_integral<_Ty>, is_integral<_Elem>>,
        
        conjunction<is_pointer<_Ty>, is_same<_Ty, _Elem>>,
        
        conjunction<is_same<_Ty, nullptr_t>, is_pointer<_Elem>>,
        
        
        
        _Vector_alg_in_find_is_safe_object_pointers<_Ty, _Elem>>;

template <class _InIt, class _Ty>
[[nodiscard]] constexpr bool _Could_compare_equal_to_value_type(const _Ty& _Val) {
    
     ;

    if constexpr (disjunction_v<

                      is_same<_Ty, byte>,
#line 5657 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
                      is_same<_Ty, bool>, is_pointer<_Ty>, is_same<_Ty, nullptr_t>>) {
        return true;
    } else {
        using _Elem = _Iter_value_t<_InIt>;
         ;

        if constexpr (is_same_v<_Elem, bool>) {
            return _Val == true || _Val == false;
        } else if constexpr (is_signed_v<_Elem>) {
            
            constexpr _Elem _Min = static_cast<_Elem>(_Elem{1} << (sizeof(_Elem) * 8 - 1));
            constexpr _Elem _Max = static_cast<_Elem>(~_Min);

            if constexpr (is_signed_v<_Ty>) {
                
                return _Min <= _Val && _Val <= _Max;
            } else {
                
                if constexpr (_Elem{-1} == static_cast<_Ty>(-1)) {
                    
                    return _Val <= _Max || static_cast<_Ty>(_Min) <= _Val;
                } else {
                    
                    return _Val <= _Max;
                }
            }
        } else {
            constexpr _Elem _Max = static_cast<_Elem>(~_Elem{0});

            if constexpr (is_unsigned_v<_Ty>) {
                
                return _Val <= _Max;
            } else {
                
                if constexpr (_Ty{-1} == static_cast<_Elem>(-1)) {
                    
                    return _Val <= _Max;
                } else {
                    
                    return 0 <= _Val && _Val <= _Max;
                }
            }
        }
    }
}

template <class _InIt, class _Ty>
[[nodiscard]] constexpr _InIt _Find_unchecked(_InIt _First, const _InIt _Last, const _Ty& _Val) {
    
    
    if constexpr (_Vector_alg_in_find_is_safe<_InIt, _Ty>) {

        if (!::std:: is_constant_evaluated())
#line 5711 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        {
            if (!::std:: _Could_compare_equal_to_value_type<_InIt>(_Val)) {
                return _Last;
            }

            const auto _First_ptr = _To_address(_First);
            const auto _Result    = __std_find_trivial(_First_ptr, _To_address(_Last), _Val);
            if constexpr (is_pointer_v<_InIt>) {
                return _Result;
            } else {
                return _First + (_Result - _First_ptr);
            }












#line 5736 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        }
    }

    for (; _First != _Last; ++_First) {
        if (*_First == _Val) {
            break;
        }
    }

    return _First;
}

 template <class _InIt, class _Ty>
[[nodiscard]] constexpr _InIt find(_InIt _First, const _InIt _Last, const _Ty& _Val) { 
    _Adl_verify_range(_First, _Last);
    if constexpr (_Is_vb_iterator<_InIt> && is_same_v<_Ty, bool>) {
        return _Find_vbool(_First, _Last, _Val);
    } else {
        _Seek_wrapped(_First, ::std:: _Find_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val));
        return _First;
    }
}


 template <class _ExPo, class _FwdIt, class _Ty, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] _FwdIt find(_ExPo&& _Exec, _FwdIt _First, const _FwdIt _Last, const _Ty& _Val) noexcept; 
#line 5763 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"


namespace ranges {
    template <class _Se, class _It>
    concept _Sized_or_unreachable_sentinel_for = sized_sentinel_for<_Se, _It> || same_as<_Se, unreachable_sentinel_t>;

    template <class _Rng>
    concept _Sized_or_infinite_range = range<_Rng>
                                    && (sized_range<_Rng> || same_as<sentinel_t<_Rng>, unreachable_sentinel_t>);

    
    template <input_iterator _It, sentinel_for<_It> _Se, class _Ty, class _Pj = identity>
        requires indirect_binary_predicate<ranges::equal_to, projected<_It, _Pj>, const _Ty*>
    [[nodiscard]] constexpr _It _Find_unchecked(_It _First, const _Se _Last, const _Ty& _Val, _Pj _Proj = {}) {
        constexpr bool _Is_sized = sized_sentinel_for<_Se, _It>;
        if constexpr (_Vector_alg_in_find_is_safe<_It, _Ty> && _Sized_or_unreachable_sentinel_for<_Se, _It>
                      && same_as<_Pj, identity>) {
            if (!::std:: is_constant_evaluated()) {
                if (!::std:: _Could_compare_equal_to_value_type<_It>(_Val)) {
                    if constexpr (_Is_sized) {
                        return ::std::ranges:: next(::std:: move(_First), _Last);
                    } else {
                        
;
                    }
                }

                using _Ptr_t = remove_reference_t<_Iter_ref_t<_It>>*;

                const auto _First_ptr = _To_address(_First);

                _Ptr_t _Result;

                if constexpr (_Is_sized) {
                    const auto _Last_ptr = _First_ptr + (_Last - _First);

                    _Result = __std_find_trivial(_First_ptr, _Last_ptr, _Val);
                } else {
                    _Result = __std_find_trivial_unsized(_First_ptr, _Val);
                }

                if constexpr (is_pointer_v<_It>) {
                    return _Result;
                } else {
                    return ::std::ranges:: next(::std:: move(_First), _Result - _First_ptr);
                }



























#line 5837 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
            }
        }

        for (; _First != _Last; ++_First) {
            if (::std:: invoke(_Proj, *_First) == _Val) {
                break;
            }
        }

        return _First;
    }

    class _Find_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        
        template <input_iterator _It, sentinel_for<_It> _Se, class _Ty, class _Pj = identity>
            requires indirect_binary_predicate<ranges::equal_to, projected<_It, _Pj>, const _Ty*>
        [[nodiscard]] constexpr _It operator()(_It _First, _Se _Last, const _Ty& _Val, _Pj _Proj = {}) const {
            
            _Adl_verify_range(_First, _Last);
            auto _UResult = ::std::ranges:: _Find_unchecked(
                _Unwrap_iter<_Se>(::std:: move(_First)), _Unwrap_sent<_It>(::std:: move(_Last)), _Val, _Pass_fn(_Proj));

            _Seek_wrapped(_First, ::std:: move(_UResult));
            return _First;
        }

        template <input_range _Rng, class _Ty, class _Pj = identity>
            requires indirect_binary_predicate<ranges::equal_to, projected<iterator_t<_Rng>, _Pj>, const _Ty*>
        [[nodiscard]] constexpr borrowed_iterator_t<_Rng> operator()(
            _Rng&& _Range, const _Ty& _Val, _Pj _Proj = {}) const {
            auto _First   = ::std::ranges:: begin(_Range);
            auto _UResult = ::std::ranges:: _Find_unchecked(
                _Unwrap_range_iter<_Rng>(::std:: move(_First)), _Uend(_Range), _Val, _Pass_fn(_Proj));

            _Seek_wrapped(_First, ::std:: move(_UResult));
            return _First;
        }
    };

     inline constexpr _Find_fn find{_Not_quite_object::_Construct_tag {}};
} 
#line 5882 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

 template <class _InIt, class _Ty>
[[nodiscard]] constexpr _Iter_diff_t<_InIt> count(const _InIt _First, const _InIt _Last, const _Ty& _Val) {
    
    _Adl_verify_range(_First, _Last);
    if constexpr (_Is_vb_iterator<_InIt> && is_same_v<_Ty, bool>) {
        return _Count_vbool(_First, _Last, _Val);
    } else {
        auto _UFirst      = _Get_unwrapped(_First);
        const auto _ULast = _Get_unwrapped(_Last);


        if constexpr (_Vector_alg_in_find_is_safe<decltype(_UFirst), _Ty>) {

            if (!::std:: is_constant_evaluated())
#line 5898 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
            {
                if (!::std:: _Could_compare_equal_to_value_type<decltype(_UFirst)>(_Val)) {
                    return 0;
                }

                return static_cast<_Iter_diff_t<_InIt>>(
                    __std_count_trivial(_To_address(_UFirst), _To_address(_ULast), _Val));
            }
        }
#line 5908 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

        _Iter_diff_t<_InIt> _Count = 0;

        for (; _UFirst != _ULast; ++_UFirst) {
            if (*_UFirst == _Val) {
                ++_Count;
            }
        }

        return _Count;
    }
}


 template <class _ExPo, class _FwdIt, class _Ty, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] _Iter_diff_t<_FwdIt> count(
    _ExPo&& _Exec, const _FwdIt _First, const _FwdIt _Last, const _Ty& _Val) noexcept; 
#line 5926 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

template <class _InIt, class _Ty, class _Pr>
[[nodiscard]] constexpr _InIt _Find_pr(_InIt _First, const _InIt _Last, const _Ty& _Val, _Pr _Pred) {
    for (; _First != _Last; ++_First) {
        if (_Pred(*_First, _Val)) {
            break;
        }
    }

    return _First;
}

template <class _InIt, class _Ty, class _Pr>
[[nodiscard]] constexpr _Iter_diff_t<_InIt> _Count_pr(_InIt _First, const _InIt _Last, const _Ty& _Val, _Pr _Pred) {
    _Iter_diff_t<_InIt> _Count = 0;

    for (; _First != _Last; ++_First) {
        if (_Pred(*_First, _Val)) {
            ++_Count;
        }
    }

    return _Count;
}

enum class _TrimResult : unsigned char { _KeepTrimming, _HaveWorkAfterTrimming, _ReturnFalse, _ReturnTrue };

template <class _BidIt1, class _BidIt2, class _Pr>
[[nodiscard]] constexpr _TrimResult _Trim_equal(
    _BidIt1& _First1, _BidIt1& _Back1, _BidIt2& _First2, _BidIt2& _Back2, _Pr _Pred) {
    
    
     ;
     ;
    if (_Pred(*_First1, *_First2)) {
        do {
            ++_First1;
            ++_First2;
            if (_First1 == _Back1) {
                
                return _Pred(*_First1, *_First2) ? _TrimResult::_ReturnTrue : _TrimResult::_ReturnFalse;
            }
        } while (_Pred(*_First1, *_First2));
    } else {
        if (!_Pred(*_Back1, *_Back2)) {
            
            return _TrimResult::_HaveWorkAfterTrimming;
        }
        --_Back1;
        --_Back2;
    }

    for (;;) {
        if (_First1 == _Back1) {
            
            return _TrimResult::_ReturnFalse;
        }

        if (!_Pred(*_Back1, *_Back2)) {
            return _TrimResult::_KeepTrimming;
        }
        --_Back1;
        --_Back2;
    }
}

template <class _BidIt1, class _BidIt2, class _Pr>
[[nodiscard]] constexpr _TrimResult _Trim_reversed(
    _BidIt1& _First1, _BidIt1& _Back1, _BidIt2& _First2, _BidIt2& _Back2, _Pr _Pred) {
    
    
     ;
     ;
    if (_Pred(*_First1, *_Back2)) {
        do {
            ++_First1;
            --_Back2;
            if (_First1 == _Back1) {
                
                return _Pred(*_First1, *_First2) ? _TrimResult::_ReturnTrue : _TrimResult::_ReturnFalse;
            }
        } while (_Pred(*_First1, *_Back2));
    } else {
        if (!_Pred(*_Back1, *_First2)) {
            
            return _TrimResult::_HaveWorkAfterTrimming;
        }
        --_Back1;
        ++_First2;
    }

    for (;;) {
        if (_First1 == _Back1) {
            
            return _TrimResult::_ReturnFalse;
        }

        if (!_Pred(*_Back1, *_First2)) {
            return _TrimResult::_KeepTrimming;
        }
        --_Back1;
        ++_First2;
    }
}

template <class _BidIt1, class _BidIt2, class _Pr>
[[nodiscard]] constexpr _TrimResult _Trim_completely(
    _BidIt1& _First1, _BidIt1& _Back1, _BidIt2& _First2, _BidIt2& _Back2, _Pr _Pred) {
    
    _TrimResult _Res = _TrimResult::_KeepTrimming;

    for (bool _Check_reversed = true; _Res == _TrimResult::_KeepTrimming; _Check_reversed = !_Check_reversed) {
        if (_Check_reversed) {
            _Res = _Trim_reversed(_First1, _Back1, _First2, _Back2, _Pred);
        } else {
            _Res = _Trim_equal(_First1, _Back1, _First2, _Back2, _Pred);
        }
    }

    return _Res;
}

template <class _FwdIt1, class _FwdIt2, class _Pr>
[[nodiscard]] constexpr bool _Check_match_counts(
    _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred) {
    
     ;
     ;
    if constexpr (_Is_ranges_bidi_iter_v<_FwdIt1> && _Is_ranges_bidi_iter_v<_FwdIt2>) {
        do { 
            --_Last1;
            --_Last2;
        } while (_Pred(*_Last1, *_Last2));

        if (_First1 == _Last1) {
            return false;
        }

        const _TrimResult _Res = _Trim_completely(_First1, _Last1, _First2, _Last2, _Pred);

        if (_Res != _TrimResult::_HaveWorkAfterTrimming) {
            return _Res == _TrimResult::_ReturnTrue;
        }

        ++_Last1;
        ++_Last2;
    }

    for (_FwdIt1 _Next1 = _First1; _Next1 != _Last1; ++_Next1) {
        if (_Next1 == _Find_pr(_First1, _Next1, *_Next1, _Pred)) { 
            _Iter_diff_t<_FwdIt2> _Count2 = _Count_pr(_First2, _Last2, *_Next1, _Pred);
            if (_Count2 == 0) {
                return false; 
            }

            _FwdIt1 _Skip1                = _Next_iter(_Next1);
            _Iter_diff_t<_FwdIt1> _Count1 = _Count_pr(_Skip1, _Last1, *_Next1, _Pred) + 1;
            if (_Count2 != _Count1) {
                return false; 
            }
        }
    }

    return true;
}

 template <class _BidIt>
constexpr void reverse(const _BidIt _First, const _BidIt _Last) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst = _Get_unwrapped(_First);
    auto _ULast  = _Get_unwrapped(_Last);

    using _Elem                         = remove_reference_t<_Iter_ref_t<decltype(_UFirst)>>;
    constexpr bool _Allow_vectorization = conjunction_v<bool_constant<_Iterator_is_contiguous<decltype(_UFirst)>>,
        _Is_trivially_swappable<_Elem>, negation<is_volatile<_Elem>>>;
    constexpr size_t _Nx                = sizeof(_Elem);

    if constexpr (_Allow_vectorization && _Nx <= 8 && (_Nx & (_Nx - 1)) == 0) {

        if (!::std:: is_constant_evaluated())
#line 6107 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        {
            if constexpr (_Nx == 1) {
                __std_reverse_trivially_swappable_1(_To_address(_UFirst), _To_address(_ULast));
            } else if constexpr (_Nx == 2) {
                __std_reverse_trivially_swappable_2(_To_address(_UFirst), _To_address(_ULast));
            } else if constexpr (_Nx == 4) {
                __std_reverse_trivially_swappable_4(_To_address(_UFirst), _To_address(_ULast));
            } else {
                __std_reverse_trivially_swappable_8(_To_address(_UFirst), _To_address(_ULast));
            }

            return;
        }
    }
#line 6122 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

    for (; _UFirst != _ULast && _UFirst != --_ULast; ++_UFirst) {
        ::std:: iter_swap(_UFirst, _ULast);
    }
}


 template <class _ExPo, class _BidIt, _Enable_if_execution_policy_t<_ExPo> = 0>
void reverse(_ExPo&&, _BidIt _First, _BidIt _Last) noexcept   {
    
    
    return ::std:: reverse(_First, _Last);
}
#line 6136 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

template <class _BidIt>
constexpr pair<_BidIt, _BidIt> _Reverse_until_sentinel_unchecked(_BidIt _First, _BidIt _Sentinel, _BidIt _Last) {
    
    while (_First != _Sentinel && _Last != _Sentinel) {
        ::std:: iter_swap(_First, --_Last);
        ++_First;
    }

    return pair<_BidIt, _BidIt>(_First, _Last);
}

 template <class _FwdIt>
constexpr _FwdIt rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last) {
    
    
    
    _Adl_verify_range(_First, _Mid);
    _Adl_verify_range(_Mid, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    auto _UMid        = _Get_unwrapped(_Mid);
    const auto _ULast = _Get_unwrapped(_Last);
    if (_UFirst == _UMid) {
        return _Last;
    }

    if (_UMid == _ULast) {
        return _First;
    }

    if constexpr (_Is_cpp17_random_iter_v<_FwdIt>) {
        ::std:: reverse(_UFirst, _UMid);
        ::std:: reverse(_UMid, _ULast);
        ::std:: reverse(_UFirst, _ULast);
        _Seek_wrapped(_First, _UFirst + (_ULast - _UMid));
    } else if constexpr (_Is_cpp17_bidi_iter_v<_FwdIt>) {
        ::std:: reverse(_UFirst, _UMid);
        ::std:: reverse(_UMid, _ULast);
        auto _Tmp = _Reverse_until_sentinel_unchecked(_UFirst, _UMid, _ULast);
        ::std:: reverse(_Tmp.first, _Tmp.second);
        _Seek_wrapped(_First, _UMid != _Tmp.first ? _Tmp.first : _Tmp.second);
    } else {
        auto _UNext = _UMid;
        do { 
            ::std:: iter_swap(_UFirst, _UNext);
            ++_UFirst;
            ++_UNext;
            if (_UFirst == _UMid) {
                _UMid = _UNext;
            }
        } while (_UNext != _ULast);
        _Seek_wrapped(_First, _UFirst);
        while (_UMid != _ULast) { 
            _UNext = _UMid;
            do {
                ::std:: iter_swap(_UFirst, _UNext);
                ++_UFirst;
                ++_UNext;
                if (_UFirst == _UMid) {
                    _UMid = _UNext;
                }
            } while (_UNext != _ULast);
        }
    }

    return _First;
}


 template <class _ExPo, class _FwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
_FwdIt rotate(_ExPo&&, _FwdIt _First, _FwdIt _Mid, _FwdIt _Last) noexcept   {
    
    
    return ::std:: rotate(_First, _Mid, _Last);
}
#line 6212 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

 template <class _InIt, class _Pr>
[[nodiscard]] constexpr _InIt find_if(_InIt _First, const _InIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (_Pred(*_UFirst)) {
            break;
        }
    }

    _Seek_wrapped(_First, _UFirst);
    return _First;
}


namespace ranges {
    template <class _Result, class _Wrapped, class _Unwrapped>
    [[nodiscard]] constexpr _Result _Rewrap_subrange(_Wrapped& _Val, subrange<_Unwrapped>&& _UResult) {
        
        if constexpr (is_same_v<_Result, dangling>) {
            return dangling{};
        } else if constexpr (is_same_v<_Result, subrange<_Unwrapped>>) {
            return ::std:: move(_UResult);
        } else if constexpr (range<_Wrapped>) {
             ;
             ;
             ;

            auto _First = ::std::ranges:: begin(_Val);
            auto _Last  = _First;
            _First._Seek_to(_UResult.begin());
            _Last._Seek_to(_UResult.end());
            return _Result{::std:: move(_First), ::std:: move(_Last)};
        } else {
             ;
             ;

            auto _Last = _Val;
            _Val._Seek_to(_UResult.begin());
            _Last._Seek_to(_UResult.end());
            return _Result{::std:: move(_Val), ::std:: move(_Last)};
        }
    }

    
    template <input_iterator _It, sentinel_for<_It> _Se, class _Pj, indirect_unary_predicate<projected<_It, _Pj>> _Pr>
    [[nodiscard]] constexpr _It _Find_if_unchecked(_It _First, const _Se _Last, _Pr _Pred, _Pj _Proj) {
        for (; _First != _Last; ++_First) {
            if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_First))) {
                break;
            }
        }

        return _First;
    }

    class _Find_if_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It, sentinel_for<_It> _Se, class _Pj = identity,
            indirect_unary_predicate<projected<_It, _Pj>> _Pr>
        [[nodiscard]] constexpr _It operator()(_It _First, _Se _Last, _Pr _Pred, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            auto _UResult = ::std::ranges:: _Find_if_unchecked(_Unwrap_iter<_Se>(::std:: move(_First)),
                _Unwrap_sent<_It>(::std:: move(_Last)), _Pass_fn(_Pred), _Pass_fn(_Proj));

            _Seek_wrapped(_First, ::std:: move(_UResult));
            return _First;
        }

        template <input_range _Rng, class _Pj = identity,
            indirect_unary_predicate<projected<iterator_t<_Rng>, _Pj>> _Pr>
        [[nodiscard]] constexpr borrowed_iterator_t<_Rng> operator()(_Rng&& _Range, _Pr _Pred, _Pj _Proj = {}) const {
            auto _First   = ::std::ranges:: begin(_Range);
            auto _UResult = ::std::ranges:: _Find_if_unchecked(
                _Unwrap_range_iter<_Rng>(::std:: move(_First)), _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj));

            _Seek_wrapped(_First, ::std:: move(_UResult));
            return _First;
        }
    };

     inline constexpr _Find_if_fn find_if{_Not_quite_object::_Construct_tag {}};

    class _Find_if_not_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It, sentinel_for<_It> _Se, class _Pj = identity,
            indirect_unary_predicate<projected<_It, _Pj>> _Pr>
        [[nodiscard]] constexpr _It operator()(_It _First, _Se _Last, _Pr _Pred, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);

            auto _UResult = _Find_if_not_unchecked(_Unwrap_iter<_Se>(::std:: move(_First)),
                _Unwrap_sent<_It>(::std:: move(_Last)), _Pass_fn(_Pred), _Pass_fn(_Proj));

            _Seek_wrapped(_First, ::std:: move(_UResult));
            return _First;
        }

        template <input_range _Rng, class _Pj = identity,
            indirect_unary_predicate<projected<iterator_t<_Rng>, _Pj>> _Pr>
        [[nodiscard]] constexpr borrowed_iterator_t<_Rng> operator()(_Rng&& _Range, _Pr _Pred, _Pj _Proj = {}) const {
            auto _First = ::std::ranges:: begin(_Range);

            auto _UResult = _Find_if_not_unchecked(
                _Unwrap_range_iter<_Rng>(::std:: move(_First)), _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj));

            _Seek_wrapped(_First, ::std:: move(_UResult));
            return _First;
        }

    private:
        template <class _It, class _Se, class _Pj, class _Pr>
        [[nodiscard]] static constexpr _It _Find_if_not_unchecked(_It _First, const _Se _Last, _Pr _Pred, _Pj _Proj) {
             ;
             ;
             ;

            for (; _First != _Last; ++_First) {
                if (!::std:: invoke(_Pred, ::std:: invoke(_Proj, *_First))) {
                    break;
                }
            }

            return _First;
        }
    };

     inline constexpr _Find_if_not_fn find_if_not{_Not_quite_object::_Construct_tag {}};

    class _Adjacent_find_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <forward_iterator _It, sentinel_for<_It> _Se, class _Pj = identity,
            indirect_binary_predicate<projected<_It, _Pj>, projected<_It, _Pj>> _Pr = ranges::equal_to>
        [[nodiscard]] constexpr _It operator()(_It _First, _Se _Last, _Pr _Pred = {}, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);

            auto _UResult = _Adjacent_find_unchecked(_Unwrap_iter<_Se>(::std:: move(_First)),
                _Unwrap_sent<_It>(::std:: move(_Last)), _Pass_fn(_Pred), _Pass_fn(_Proj));

            _Seek_wrapped(_First, ::std:: move(_UResult));
            return _First;
        }

        template <forward_range _Rng, class _Pj = identity,
            indirect_binary_predicate<projected<iterator_t<_Rng>, _Pj>, projected<iterator_t<_Rng>, _Pj>> _Pr =
                ranges::equal_to>
        [[nodiscard]] constexpr borrowed_iterator_t<_Rng> operator()(_Rng&& _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
            auto _UResult = _Adjacent_find_unchecked(_Ubegin(_Range), _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj));

            return _Rewrap_iterator(_Range, ::std:: move(_UResult));
        }

    private:
        template <class _It, class _Se, class _Pj, class _Pr>
        [[nodiscard]] static constexpr _It _Adjacent_find_unchecked(_It _First, const _Se _Last, _Pr _Pred, _Pj _Proj) {
            
             ;
             ;
             ;

            if (_First == _Last) {
                return _First;
            }

            for (auto _Next = _First;; ++_First) {
                if (++_Next == _Last) {
                    return _Next;
                }

                if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_First), ::std:: invoke(_Proj, *_Next))) {
                    return _First;
                }
            }
        }
    };

     inline constexpr _Adjacent_find_fn adjacent_find{_Not_quite_object::_Construct_tag {}};

    
    template <class _It1, class _It2, class _Se2, class _Pr, class _Pj1, class _Pj2>
    concept _Equal_rev_pred_can_memcmp = is_same_v<_Pj1, identity> && is_same_v<_Pj2, identity>
        && sized_sentinel_for<_Se2, _It2> && _Equal_memcmp_is_safe<_It1, _It2, _Pr>;

    template <input_iterator _It1, input_iterator _It2, sentinel_for<_It2> _Se2, class _Pr, class _Pj1, class _Pj2>
        requires indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>
    [[nodiscard]] constexpr pair<bool, _It1> _Equal_rev_pred(
        _It1 _First1, _It2 _First2, const _Se2 _Last2, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
        
        
        
        constexpr bool _Optimize = _Equal_rev_pred_can_memcmp<_It1, _It2, _Se2, _Pr, _Pj1, _Pj2>;
        if constexpr (_Optimize) {
            if (!::std:: is_constant_evaluated()) {
                bool _Ans;
                if constexpr (same_as<_It2, _Se2>) {
                    _Ans = _Memcmp_ranges(_First2, _Last2, _First1) == 0;
                } else {
                    _Ans = _Memcmp_count(_First1, _First2, static_cast<size_t>(_Last2 - _First2)) == 0;
                }

                if (_Ans) {
                    _First1 += (_Last2 - _First2);
                    return {true, ::std:: move(_First1)};
                } else {
                    return {false, _It1 {}};
                }
            }
        }

        for (; _First2 != _Last2; ++_First1, (void) ++_First2) {
            if (!::std:: invoke(_Pred, ::std:: invoke(_Proj1, *_First1), ::std:: invoke(_Proj2, *_First2))) {
                return {false, _It1 {}};
            }
        }

        return {true, ::std:: move(_First1)};
    }

    class _Search_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <forward_iterator _It1, sentinel_for<_It1> _Se1, forward_iterator _It2, sentinel_for<_It2> _Se2,
            class _Pr = ranges::equal_to, class _Pj1 = identity, class _Pj2 = identity>
            requires indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>
        [[nodiscard]] constexpr subrange<_It1> operator()(_It1 _First1, _Se1 _Last1, _It2 _First2, _Se2 _Last2,
            _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
            _Adl_verify_range(_First1, _Last1);
            _Adl_verify_range(_First2, _Last2);
            auto _UFirst1 = _Unwrap_iter<_Se1>(::std:: move(_First1));
            auto _ULast1  = _Unwrap_sent<_It1>(::std:: move(_Last1));
            auto _UFirst2 = _Unwrap_iter<_Se2>(::std:: move(_First2));
            auto _ULast2  = _Unwrap_sent<_It2>(::std:: move(_Last2));

            if constexpr (sized_sentinel_for<_Se1, _It1> && sized_sentinel_for<_Se2, _It2>) {
                const auto _Count1 = _ULast1 - _UFirst1;
                const auto _Count2 = _ULast2 - _UFirst2;
                auto _UResult = _Search_sized(::std:: move(_UFirst1), ::std:: move(_ULast1), _Count1, ::std:: move(_UFirst2),
                    ::std:: move(_ULast2), _Count2, _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
                return _Rewrap_subrange<subrange<_It1>>(_First1, ::std:: move(_UResult));
            } else {
                auto _UResult = _Search_unsized(::std:: move(_UFirst1), ::std:: move(_ULast1), ::std:: move(_UFirst2),
                    ::std:: move(_ULast2), _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
                return _Rewrap_subrange<subrange<_It1>>(_First1, ::std:: move(_UResult));
            }
        }

        template <forward_range _Rng1, forward_range _Rng2, class _Pr = ranges::equal_to, class _Pj1 = identity,
            class _Pj2 = identity>
            requires indirectly_comparable<iterator_t<_Rng1>, iterator_t<_Rng2>, _Pr, _Pj1, _Pj2>
        [[nodiscard]] constexpr borrowed_subrange_t<_Rng1> operator()(
            _Rng1&& _Range1, _Rng2&& _Range2, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
            if constexpr (sized_range<_Rng1> && sized_range<_Rng2>) {
                const auto _Count1 = ::std::ranges:: distance(_Range1);
                const auto _Count2 = ::std::ranges:: distance(_Range2);
                auto _UResult      = _Search_sized(_Ubegin(_Range1), _Uend(_Range1), _Count1, _Ubegin(_Range2),
                         _Uend(_Range2), _Count2, _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
                return _Rewrap_subrange<borrowed_subrange_t<_Rng1>>(_Range1, ::std:: move(_UResult));
            } else {
                auto _UResult = _Search_unsized(_Ubegin(_Range1), _Uend(_Range1), _Ubegin(_Range2), _Uend(_Range2),
                    _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
                return _Rewrap_subrange<borrowed_subrange_t<_Rng1>>(_Range1, ::std:: move(_UResult));
            }
        }

    private:
        template <class _It1, class _Se1, class _It2, class _Se2, class _Pr, class _Pj1, class _Pj2>
        [[nodiscard]] static constexpr subrange<_It1> _Search_sized(_It1 _First1, const _Se1 _Last1,
            iter_difference_t<_It1> _Count1, _It2 _First2, const _Se2 _Last2, const iter_difference_t<_It2> _Count2,
            _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
             ;
             ;
             ;
             ;
             ;
             ;
             ;

            for (; _Count1 >= _Count2; ++_First1, (void) --_Count1) {
                auto [_Match, _Mid1] = ::std::ranges:: _Equal_rev_pred(_First1, _First2, _Last2, _Pred, _Proj1, _Proj2);
                if (_Match) {
                    return {::std:: move(_First1), ::std:: move(_Mid1)};
                }
            }

            _First1 = _Find_last_iterator(_First1, _Last1, _Count1);
            return {_First1, _First1};
        }

        template <class _It1, class _Se1, class _It2, class _Se2, class _Pr, class _Pj1, class _Pj2>
        [[nodiscard]] static constexpr subrange<_It1> _Search_unsized(
            _It1 _First1, const _Se1 _Last1, _It2 _First2, const _Se2 _Last2, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
             ;
             ;
             ;
             ;
             ;

            for (;; ++_First1) {
                auto _Mid1 = _First1;
                for (auto _Mid2 = _First2;; ++_Mid1, (void) ++_Mid2) {
                    if (_Mid2 == _Last2) { 
                        return {::std:: move(_First1), ::std:: move(_Mid1)};
                    }

                    if (_Mid1 == _Last1) { 
                        return {_Mid1, _Mid1};
                    }

                    if (!::std:: invoke(_Pred, ::std:: invoke(_Proj1, *_Mid1), ::std:: invoke(_Proj2, *_Mid2))) { 
                        break;
                    }
                }
            }
        }
    };

     inline constexpr _Search_fn search{_Not_quite_object::_Construct_tag {}};
} 
#line 6539 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

template <class _Iter, class _Pr, class _Elem = _Iter_value_t<_Iter>>
inline constexpr bool _Is_min_max_optimization_safe = 
    _Iterator_is_contiguous<_Iter> 
    && !_Iterator_is_volatile<_Iter> 
    && conjunction_v<disjunction<is_integral<_Elem>, is_pointer<_Elem>>, 
        disjunction< 

            is_same<_Pr, ::std::ranges:: less>, 
#line 6549 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
            is_same<_Pr, less<>>, is_same<_Pr, less<_Elem>>>>; 

template <class _FwdIt, class _Pr>
constexpr _FwdIt _Max_element_unchecked(_FwdIt _First, _FwdIt _Last, _Pr _Pred) { 

    if constexpr (_Is_min_max_optimization_safe<_FwdIt, _Pr>) {
        if (!_Is_constant_evaluated()) {
            const auto _First_ptr = _To_address(_First);
            const auto _Result    = __std_max_element(_First_ptr, _To_address(_Last));
            if constexpr (is_pointer_v<_FwdIt>) {
                return _Result;
            } else {
                return _First + (_Result - _First_ptr);
            }
        }
    }
#line 6566 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

    _FwdIt _Found = _First;
    if (_First != _Last) {
        while (++_First != _Last) {
            if (static_cast<bool>(_Pred(*_Found, *_First)) ) {
                _Found = _First;
            }
        }
    }

    return _Found;
}

 template <class _FwdIt, class _Pr>
[[nodiscard]] constexpr _FwdIt max_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    _Seek_wrapped(_First, ::std:: _Max_element_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pass_fn(_Pred)));
    return _First;
}

 template <class _FwdIt>
[[nodiscard]] constexpr _FwdIt max_element(_FwdIt _First, _FwdIt _Last) { 
    return ::std:: max_element(_First, _Last, less<>{});
}


 template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] _FwdIt max_element(_ExPo&&, _FwdIt _First, _FwdIt _Last, _Pr _Pred) noexcept   {
    
    
    return ::std:: max_element(_First, _Last, _Pass_fn(_Pred));
}

 template <class _ExPo, class _FwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] _FwdIt max_element(_ExPo&&, _FwdIt _First, _FwdIt _Last) noexcept   {
    
    
    return ::std:: max_element(_First, _Last);
}


namespace ranges {
    template <class _It, class _Se, class _Pr, class _Pj>
    [[nodiscard]] constexpr _It _Max_element_unchecked(_It _First, const _Se _Last, _Pr _Pred, _Pj _Proj) {
         ;
         ;
         ;


        if constexpr (is_same_v<_Pj, identity> && _Is_min_max_optimization_safe<_It, _Pr>
                      && sized_sentinel_for<_Se, _It>) {
            if (!::std:: is_constant_evaluated()) {
                const auto _First_ptr = ::std:: to_address(_First);
                const auto _Last_ptr  = _First_ptr + (_Last - _First);
                const auto _Result    = __std_max_element(_First_ptr, _Last_ptr);
                if constexpr (is_pointer_v<_It>) {
                    return _Result;
                } else {
                    return _First + (_Result - _First_ptr);
                }
            }
        }
#line 6629 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

        auto _Found = _First;
        if (_First == _Last) {
            return _Found;
        }

        while (++_First != _Last) {
            if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_Found), ::std:: invoke(_Proj, *_First))) {
                _Found = _First;
            }
        }

        return _Found;
    }

    class _Max_element_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <forward_iterator _It, sentinel_for<_It> _Se, class _Pj = identity,
            indirect_strict_weak_order<projected<_It, _Pj>> _Pr = ranges::less>
        [[nodiscard]] constexpr _It operator()(_It _First, _Se _Last, _Pr _Pred = {}, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            _Seek_wrapped(_First, ::std::ranges:: _Max_element_unchecked(_Unwrap_iter<_Se>(::std:: move(_First)),
                                      _Unwrap_sent<_It>(::std:: move(_Last)), _Pass_fn(_Pred), _Pass_fn(_Proj)));
            return _First;
        }

        template <forward_range _Rng, class _Pj = identity,
            indirect_strict_weak_order<projected<iterator_t<_Rng>, _Pj>> _Pr = ranges::less>
        [[nodiscard]] constexpr borrowed_iterator_t<_Rng> operator()(_Rng&& _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
            auto _First = ::std::ranges:: begin(_Range);
            _Seek_wrapped(_First, ::std::ranges:: _Max_element_unchecked(_Unwrap_range_iter<_Rng>(::std:: move(_First)),
                                      _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj)));
            return _First;
        }
    };

     inline constexpr _Max_element_fn max_element{_Not_quite_object::_Construct_tag {}};
} 
#line 6670 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
#line 6671 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

 template <class _Ty, class _Pr>
[[nodiscard]] constexpr _Ty(max)(initializer_list<_Ty> _Ilist, _Pr _Pred) {
    
    const _Ty* _Res = ::std:: _Max_element_unchecked(_Ilist.begin(), _Ilist.end(), _Pass_fn(_Pred));
    return *_Res;
}

 template <class _Ty>
[[nodiscard]] constexpr _Ty(max)(initializer_list<_Ty> _Ilist) {
    
    return (::std:: max)(_Ilist, less<>{});
}


namespace ranges {
    template <class _It>
    concept _Prefer_iterator_copies = 
                                      
        sizeof(_It) <= 2 * sizeof(iter_value_t<_It>)
        && (is_trivially_copyable_v<_It> || !is_trivially_copyable_v<iter_value_t<_It>>);

    class _Max_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <class _Ty, class _Pj = identity,
            indirect_strict_weak_order<projected<const _Ty*, _Pj>> _Pr = ranges::less>
        [[nodiscard]] constexpr const _Ty& operator()(
            const _Ty& _Left, const _Ty& _Right, _Pr _Pred = {}, _Pj _Proj = {}) const {
            if (::std:: invoke(_Pred, ::std:: invoke(_Proj, _Left), ::std:: invoke(_Proj, _Right))) {
                return _Right;
            } else {
                return _Left;
            }
        }

        template <copyable _Ty, class _Pj = identity,
            indirect_strict_weak_order<projected<const _Ty*, _Pj>> _Pr = ranges::less>
        [[nodiscard]] constexpr _Ty operator()(initializer_list<_Ty> _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
            const auto _First = _Range.begin();
            const auto _Last  = _Range.end();
            
;
            return *::std::ranges:: _Max_element_unchecked(_First, _Last, _Pass_fn(_Pred), _Pass_fn(_Proj));
        }

        template <input_range _Rng, class _Pj = identity,
            indirect_strict_weak_order<projected<iterator_t<_Rng>, _Pj>> _Pr = ranges::less>
            requires indirectly_copyable_storable<iterator_t<_Rng>, range_value_t<_Rng>*>
        [[nodiscard]] constexpr range_value_t<_Rng> operator()(_Rng&& _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
            auto _UFirst = _Ubegin(_Range);
            auto _ULast  = _Uend(_Range);
            
;
            if constexpr (forward_range<_Rng> && _Prefer_iterator_copies<iterator_t<_Rng>>) {
                return static_cast<range_value_t<_Rng>>(*::std::ranges:: _Max_element_unchecked(
                    ::std:: move(_UFirst), ::std:: move(_ULast), _Pass_fn(_Pred), _Pass_fn(_Proj)));
            } else {
                range_value_t<_Rng> _Found(*_UFirst);
                while (++_UFirst != _ULast) {
                    if (::std:: invoke(_Pred, ::std:: invoke(_Proj, _Found), ::std:: invoke(_Proj, *_UFirst))) {
                        _Found = *_UFirst;
                    }
                }

                return _Found;
            }
        }
    };

     inline constexpr _Max_fn max{_Not_quite_object::_Construct_tag {}};
} 
#line 6745 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

template <class _FwdIt, class _Pr>
constexpr _FwdIt _Min_element_unchecked(_FwdIt _First, _FwdIt _Last, _Pr _Pred) { 

    if constexpr (_Is_min_max_optimization_safe<_FwdIt, _Pr>) {
        if (!_Is_constant_evaluated()) {
            const auto _First_ptr = _To_address(_First);
            const auto _Result    = __std_min_element(_First_ptr, _To_address(_Last));
            if constexpr (is_pointer_v<_FwdIt>) {
                return _Result;
            } else {
                return _First + (_Result - _First_ptr);
            }
        }
    }
#line 6761 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

    _FwdIt _Found = _First;
    if (_First != _Last) {
        while (++_First != _Last) {
            if (static_cast<bool>(_Pred(*_First, *_Found)) ) {
                _Found = _First;
            }
        }
    }

    return _Found;
}

 template <class _FwdIt, class _Pr>
[[nodiscard]] constexpr _FwdIt min_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    _Seek_wrapped(_First, ::std:: _Min_element_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pass_fn(_Pred)));
    return _First;
}

 template <class _FwdIt>
[[nodiscard]] constexpr _FwdIt min_element(_FwdIt _First, _FwdIt _Last) { 
    return ::std:: min_element(_First, _Last, less<>{});
}


 template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] _FwdIt min_element(_ExPo&&, _FwdIt _First, _FwdIt _Last, _Pr _Pred) noexcept   {
    
    
    return ::std:: min_element(_First, _Last, _Pass_fn(_Pred));
}

 template <class _ExPo, class _FwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] _FwdIt min_element(_ExPo&&, _FwdIt _First, _FwdIt _Last) noexcept   {
    
    
    return ::std:: min_element(_First, _Last);
}


namespace ranges {
    template <class _It, class _Se, class _Pr, class _Pj>
    [[nodiscard]] constexpr _It _Min_element_unchecked(_It _First, const _Se _Last, _Pr _Pred, _Pj _Proj) {
         ;
         ;
         ;


        if constexpr (is_same_v<_Pj, identity> && _Is_min_max_optimization_safe<_It, _Pr>
                      && sized_sentinel_for<_Se, _It>) {
            if (!::std:: is_constant_evaluated()) {
                const auto _First_ptr = ::std:: to_address(_First);
                const auto _Last_ptr  = _First_ptr + (_Last - _First);
                const auto _Result    = __std_min_element(_First_ptr, _Last_ptr);
                if constexpr (is_pointer_v<_It>) {
                    return _Result;
                } else {
                    return _First + (_Result - _First_ptr);
                }
            }
        }
#line 6824 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

        auto _Found = _First;
        if (_First == _Last) {
            return _Found;
        }

        while (++_First != _Last) {
            if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_First), ::std:: invoke(_Proj, *_Found))) {
                _Found = _First;
            }
        }

        return _Found;
    }

    class _Min_element_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <forward_iterator _It, sentinel_for<_It> _Se, class _Pj = identity,
            indirect_strict_weak_order<projected<_It, _Pj>> _Pr = ranges::less>
        [[nodiscard]] constexpr _It operator()(_It _First, _Se _Last, _Pr _Pred = {}, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            _Seek_wrapped(_First, ::std::ranges:: _Min_element_unchecked(_Unwrap_iter<_Se>(::std:: move(_First)),
                                      _Unwrap_sent<_It>(::std:: move(_Last)), _Pass_fn(_Pred), _Pass_fn(_Proj)));
            return _First;
        }

        template <forward_range _Rng, class _Pj = identity,
            indirect_strict_weak_order<projected<iterator_t<_Rng>, _Pj>> _Pr = ranges::less>
        [[nodiscard]] constexpr borrowed_iterator_t<_Rng> operator()(_Rng&& _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
            auto _First = ::std::ranges:: begin(_Range);
            _Seek_wrapped(_First, ::std::ranges:: _Min_element_unchecked(_Unwrap_range_iter<_Rng>(::std:: move(_First)),
                                      _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj)));
            return _First;
        }
    };

     inline constexpr _Min_element_fn min_element{_Not_quite_object::_Construct_tag {}};
} 
#line 6865 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
#line 6866 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

 template <class _Ty, class _Pr>
[[nodiscard]] constexpr _Ty(min)(initializer_list<_Ty> _Ilist, _Pr _Pred) {
    
    const _Ty* _Res = ::std:: _Min_element_unchecked(_Ilist.begin(), _Ilist.end(), _Pass_fn(_Pred));
    return *_Res;
}

 template <class _Ty>
[[nodiscard]] constexpr _Ty(min)(initializer_list<_Ty> _Ilist) {
    
    return (::std:: min)(_Ilist, less<>{});
}


namespace ranges {
    class _Min_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <class _Ty, class _Pj = identity,
            indirect_strict_weak_order<projected<const _Ty*, _Pj>> _Pr = ranges::less>
        [[nodiscard]] constexpr const _Ty& operator()(
            const _Ty& _Left, const _Ty& _Right, _Pr _Pred = {}, _Pj _Proj = {}) const {
            if (::std:: invoke(_Pred, ::std:: invoke(_Proj, _Right), ::std:: invoke(_Proj, _Left))) {
                return _Right;
            } else {
                return _Left;
            }
        }

        template <copyable _Ty, class _Pj = identity,
            indirect_strict_weak_order<projected<const _Ty*, _Pj>> _Pr = ranges::less>
        [[nodiscard]] constexpr _Ty operator()(initializer_list<_Ty> _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
            const auto _First = _Range.begin();
            const auto _Last  = _Range.end();
            
;
            return *::std::ranges:: _Min_element_unchecked(_First, _Last, _Pass_fn(_Pred), _Pass_fn(_Proj));
        }

        template <input_range _Rng, class _Pj = identity,
            indirect_strict_weak_order<projected<iterator_t<_Rng>, _Pj>> _Pr = ranges::less>
            requires indirectly_copyable_storable<iterator_t<_Rng>, range_value_t<_Rng>*>
        [[nodiscard]] constexpr range_value_t<_Rng> operator()(_Rng&& _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
            auto _UFirst = _Ubegin(_Range);
            auto _ULast  = _Uend(_Range);
            
;
            if constexpr (forward_range<_Rng> && _Prefer_iterator_copies<iterator_t<_Rng>>) {
                return static_cast<range_value_t<_Rng>>(*::std::ranges:: _Min_element_unchecked(
                    ::std:: move(_UFirst), ::std:: move(_ULast), _Pass_fn(_Pred), _Pass_fn(_Proj)));
            } else {
                range_value_t<_Rng> _Found(*_UFirst);
                while (++_UFirst != _ULast) {
                    if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_UFirst), ::std:: invoke(_Proj, _Found))) {
                        _Found = *_UFirst;
                    }
                }

                return _Found;
            }
        }
    };

     inline constexpr _Min_fn min{_Not_quite_object::_Construct_tag {}};
} 
#line 6934 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

 template <class _FwdIt, class _Ty, class _Pr>
[[nodiscard]] constexpr _FwdIt lower_bound(_FwdIt _First, const _FwdIt _Last, const _Ty& _Val, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst                = _Get_unwrapped(_First);
    _Iter_diff_t<_FwdIt> _Count = ::std:: distance(_UFirst, _Get_unwrapped(_Last));

    while (0 < _Count) { 
        const _Iter_diff_t<_FwdIt> _Count2 = _Count / 2;
        const auto _UMid                   = ::std:: next(_UFirst, _Count2);
        if (_Pred(*_UMid, _Val)) { 
            _UFirst = _Next_iter(_UMid);
            _Count -= _Count2 + 1;
        } else {
            _Count = _Count2;
        }
    }

    _Seek_wrapped(_First, _UFirst);
    return _First;
}

 template <class _FwdIt, class _Ty>
[[nodiscard]] constexpr _FwdIt lower_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val) {
    
    return ::std:: lower_bound(_First, _Last, _Val, less<>{});
}

 template <class _FwdIt, class _Ty, class _Pr>
[[nodiscard]] constexpr _FwdIt upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst                = _Get_unwrapped(_First);
    _Iter_diff_t<_FwdIt> _Count = ::std:: distance(_UFirst, _Get_unwrapped(_Last));

    while (0 < _Count) { 
        _Iter_diff_t<_FwdIt> _Count2 = _Count / 2;
        const auto _UMid             = ::std:: next(_UFirst, _Count2);
        if (_Pred(_Val, *_UMid)) {
            _Count = _Count2;
        } else { 
            _UFirst = _Next_iter(_UMid);
            _Count -= _Count2 + 1;
        }
    }

    _Seek_wrapped(_First, _UFirst);
    return _First;
}

 template <class _FwdIt, class _Ty>
[[nodiscard]] constexpr _FwdIt upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val) {
    
    return ::std:: upper_bound(_First, _Last, _Val, less<>{});
}

template <class _FwdIt1, class _FwdIt2>
constexpr _FwdIt2 _Swap_ranges_unchecked(_FwdIt1 _First1, const _FwdIt1 _Last1, _FwdIt2 _First2) {
    


    using _Elem1 = remove_reference_t<_Iter_ref_t<_FwdIt1>>;
    using _Elem2 = remove_reference_t<_Iter_ref_t<_FwdIt2>>;
    if constexpr (is_same_v<_Elem1, _Elem2> && _Is_trivially_swappable_v<_Elem1>
                  && _Iterators_are_contiguous<_FwdIt1, _FwdIt2>) {

        if (!::std:: is_constant_evaluated())
#line 7003 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        {
            __std_swap_ranges_trivially_swappable_noalias(
                _To_address(_First1), _To_address(_Last1), _To_address(_First2));
            return _First2 + (_Last1 - _First1);
        }
    }
#line 7010 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

    for (; _First1 != _Last1; ++_First1, (void) ++_First2) {
        ::std:: iter_swap(_First1, _First2);
    }

    return _First2;
}

extern "C++" [[noreturn]]  void __cdecl _Xbad_alloc();
extern "C++" [[noreturn]]  void __cdecl _Xinvalid_argument( const char*);
extern "C++" [[noreturn]]  void __cdecl _Xlength_error( const char*);
extern "C++" [[noreturn]]  void __cdecl _Xout_of_range( const char*);
extern "C++" [[noreturn]]  void __cdecl _Xoverflow_error( const char*);
extern "C++" [[noreturn]]  void __cdecl _Xruntime_error( const char*);
extern "C++" [[noreturn]]  void __cdecl _XGetLastError();

 template <class _Category, class _Ty, class _Diff = ptrdiff_t, class _Pointer = _Ty*,
    class _Reference = _Ty&>
struct [[deprecated( "warning STL4015: " "The std::iterator class template (used as a base class to provide typedefs) is deprecated in C++17. " "(The <iterator> header is NOT deprecated.) The C++ Standard has never required user-defined iterators to " "derive from std::iterator. To fix this warning, stop deriving from std::iterator and start providing " "publicly accessible typedefs named iterator_category, value_type, difference_type, pointer, and reference. " "Note that value_type is required to be non-const, even for constant iterators. " "You can define _SILENCE_CXX17_ITERATOR_BASE_CLASS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] iterator { 
    using iterator_category = _Category;
    using value_type        = _Ty;
    using difference_type   = _Diff;
    using pointer           = _Pointer;
    using reference         = _Reference;
};

template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
[[nodiscard]] constexpr auto _Float_abs_bits(const _Ty& _Xx) {
    using _Traits    = _Floating_type_traits<_Ty>;
    using _Uint_type = typename _Traits::_Uint_type;
    const auto _Bits = _Bit_cast<_Uint_type>(_Xx);
    return _Bits & ~_Traits::_Shifted_sign_mask;
}

template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
[[nodiscard]] constexpr _Ty _Float_abs(const _Ty _Xx) { 
    return _Bit_cast<_Ty>(_Float_abs_bits(_Xx));
}

template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
[[nodiscard]] constexpr _Ty _Float_copysign(const _Ty _Magnitude, const _Ty _Sign) { 
    using _Traits       = _Floating_type_traits<_Ty>;
    using _Uint_type    = typename _Traits::_Uint_type;
    const auto _Signbit = _Bit_cast<_Uint_type>(_Sign) & _Traits::_Shifted_sign_mask;
    return _Bit_cast<_Ty>(_Float_abs_bits(_Magnitude) | _Signbit);
}

template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
[[nodiscard]] constexpr bool _Is_nan(const _Ty _Xx) { 
    using _Traits = _Floating_type_traits<_Ty>;
    return _Float_abs_bits(_Xx) > _Traits::_Shifted_exponent_mask;
}





template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
[[nodiscard]] constexpr bool _Is_signaling_nan(const _Ty& _Xx) { 
    using _Traits        = _Floating_type_traits<_Ty>;
    const auto _Abs_bits = _Float_abs_bits(_Xx);
    return _Abs_bits > _Traits::_Shifted_exponent_mask && ((_Abs_bits & _Traits::_Special_nan_mantissa_mask) == 0);
}

template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
[[nodiscard]] constexpr bool _Is_inf(const _Ty _Xx) { 
    using _Traits = _Floating_type_traits<_Ty>;
    return _Float_abs_bits(_Xx) == _Traits::_Shifted_exponent_mask;
}

template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
[[nodiscard]] constexpr bool _Is_finite(const _Ty _Xx) { 
    using _Traits = _Floating_type_traits<_Ty>;
    return _Float_abs_bits(_Xx) < _Traits::_Shifted_exponent_mask;
}


 struct monostate {};
#line 7089 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

}


#pragma warning(pop)
#pragma pack(pop)
#line 7096 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
#line 7097 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
#pragma external_header(pop)
#line 28 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"
#line 29 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"

#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




[[nodiscard]]  inline float acos( float _Xx) noexcept   {
    return :: acosf(_Xx);
}

[[nodiscard]]  inline float acosh( float _Xx) noexcept   {
    return :: acoshf(_Xx);
}

[[nodiscard]]  inline float asin( float _Xx) noexcept   {
    return :: asinf(_Xx);
}

[[nodiscard]]  inline float asinh( float _Xx) noexcept   {
    return :: asinhf(_Xx);
}

[[nodiscard]]  inline float atan( float _Xx) noexcept   {
    return :: atanf(_Xx);
}

[[nodiscard]]  inline float atanh( float _Xx) noexcept   {
    return :: atanhf(_Xx);
}

[[nodiscard]]  inline float atan2( float _Yx,  float _Xx) noexcept   {
    return :: atan2f(_Yx, _Xx);
}

[[nodiscard]]  inline float cbrt( float _Xx) noexcept   {
    return :: cbrtf(_Xx);
}

[[nodiscard]]  inline float ceil( float _Xx) noexcept   {

    return __ceilf(_Xx);




#line 77 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"
}

[[nodiscard]]  inline float copysign( float _Number,  float _Sign) noexcept   {

    return __copysignf(_Number, _Sign);




#line 87 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"
}

[[nodiscard]]  inline float cos( float _Xx) noexcept   {
    return :: cosf(_Xx);
}

[[nodiscard]]  inline float cosh( float _Xx) noexcept   {
    return :: coshf(_Xx);
}

[[nodiscard]]  inline float erf( float _Xx) noexcept   {
    return :: erff(_Xx);
}

[[nodiscard]]  inline float erfc( float _Xx) noexcept   {
    return :: erfcf(_Xx);
}

[[nodiscard]]  inline float exp( float _Xx) noexcept   {
    return :: expf(_Xx);
}

[[nodiscard]]  inline float exp2( float _Xx) noexcept   {
    return :: exp2f(_Xx);
}

[[nodiscard]]  inline float expm1( float _Xx) noexcept   {
    return :: expm1f(_Xx);
}

[[nodiscard]]  inline float fabs( float _Xx) noexcept   {
    return :: fabsf(_Xx);
}

[[nodiscard]]  inline float fdim( float _Xx,  float _Yx) noexcept   {
    return :: fdimf(_Xx, _Yx);
}

[[nodiscard]]  inline float floor( float _Xx) noexcept   {

    return __floorf(_Xx);




#line 133 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"
}

[[nodiscard]]  inline float fma( float _Xx,  float _Yx,  float _Zx) noexcept   {
    return :: fmaf(_Xx, _Yx, _Zx);
}

[[nodiscard]]  inline float fmax( float _Xx,  float _Yx) noexcept   {
    return :: fmaxf(_Xx, _Yx);
}

[[nodiscard]]  inline float fmin( float _Xx,  float _Yx) noexcept   {
    return :: fminf(_Xx, _Yx);
}

[[nodiscard]]  inline float fmod( float _Xx,  float _Yx) noexcept   {
    return :: fmodf(_Xx, _Yx);
}

inline float frexp( float _Xx,  int* _Yx) noexcept   {
    return :: frexpf(_Xx, _Yx);
}

[[nodiscard]]  inline float hypot( float _Xx,  float _Yx) noexcept   {
    return :: hypotf(_Xx, _Yx);
}

[[nodiscard]]  inline int ilogb( float _Xx) noexcept   {
    return :: ilogbf(_Xx);
}

[[nodiscard]]  inline float ldexp( float _Xx,  int _Yx) noexcept   {
    return :: ldexpf(_Xx, _Yx);
}

[[nodiscard]]  inline float lgamma( float _Xx) noexcept   {
    return :: lgammaf(_Xx);
}

[[nodiscard]]  inline long long llrint( float _Xx) noexcept   {
    return :: llrintf(_Xx);
}

[[nodiscard]]  inline long long llround( float _Xx) noexcept   {
    return :: llroundf(_Xx);
}

[[nodiscard]]  inline float log( float _Xx) noexcept   {
    return :: logf(_Xx);
}

[[nodiscard]]  inline float log10( float _Xx) noexcept   {
    return :: log10f(_Xx);
}

[[nodiscard]]  inline float log1p( float _Xx) noexcept   {
    return :: log1pf(_Xx);
}

[[nodiscard]]  inline float log2( float _Xx) noexcept   {
    return :: log2f(_Xx);
}

[[nodiscard]]  inline float logb( float _Xx) noexcept   {
    return :: logbf(_Xx);
}

[[nodiscard]]  inline long lrint( float _Xx) noexcept   {
    return :: lrintf(_Xx);
}

[[nodiscard]]  inline long lround( float _Xx) noexcept   {
    return :: lroundf(_Xx);
}

inline float modf( float _Xx,  float* _Yx) noexcept   {
    return :: modff(_Xx, _Yx);
}

[[nodiscard]]  inline float nearbyint( float _Xx) noexcept   {
    return :: nearbyintf(_Xx);
}

[[nodiscard]]  inline float nextafter( float _Xx,  float _Yx) noexcept   {
    return :: nextafterf(_Xx, _Yx);
}

[[nodiscard]]  inline float nexttoward( float _Xx,  long double _Yx) noexcept   {
    return :: nexttowardf(_Xx, _Yx);
}

[[nodiscard]]  inline float pow( float _Xx,  float _Yx) noexcept   {
    return :: powf(_Xx, _Yx);
}

[[nodiscard]]  inline float remainder( float _Xx,  float _Yx) noexcept   {
    return :: remainderf(_Xx, _Yx);
}

inline float remquo( float _Xx,  float _Yx,  int* _Zx) noexcept   {
    return :: remquof(_Xx, _Yx, _Zx);
}

[[nodiscard]]  inline float rint( float _Xx) noexcept   {
    return :: rintf(_Xx);
}

[[nodiscard]]  inline float round( float _Xx) noexcept   {

    return __roundf(_Xx);




#line 247 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"
}

[[nodiscard]]  inline float scalbln( float _Xx,  long _Yx) noexcept   {
    return :: scalblnf(_Xx, _Yx);
}

[[nodiscard]]  inline float scalbn( float _Xx,  int _Yx) noexcept   {
    return :: scalbnf(_Xx, _Yx);
}

[[nodiscard]]  inline float sin( float _Xx) noexcept   {
    return :: sinf(_Xx);
}

[[nodiscard]]  inline float sinh( float _Xx) noexcept   {
    return :: sinhf(_Xx);
}

[[nodiscard]]  inline float sqrt( float _Xx) noexcept   {
    return :: sqrtf(_Xx);
}

[[nodiscard]]  inline float tan( float _Xx) noexcept   {
    return :: tanf(_Xx);
}

[[nodiscard]]  inline float tanh( float _Xx) noexcept   {
    return :: tanhf(_Xx);
}

[[nodiscard]]  inline float tgamma( float _Xx) noexcept   {
    return :: tgammaf(_Xx);
}

[[nodiscard]]  inline float trunc( float _Xx) noexcept   {

    return __truncf(_Xx);




#line 289 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"
}

[[nodiscard]]  inline long double acos( long double _Xx) noexcept   {
    return :: acosl(_Xx);
}

[[nodiscard]]  inline long double acosh( long double _Xx) noexcept   {
    return :: acoshl(_Xx);
}

[[nodiscard]]  inline long double asin( long double _Xx) noexcept   {
    return :: asinl(_Xx);
}

[[nodiscard]]  inline long double asinh( long double _Xx) noexcept   {
    return :: asinhl(_Xx);
}

[[nodiscard]]  inline long double atan( long double _Xx) noexcept   {
    return :: atanl(_Xx);
}

[[nodiscard]]  inline long double atanh( long double _Xx) noexcept   {
    return :: atanhl(_Xx);
}

[[nodiscard]]  inline long double atan2( long double _Yx,  long double _Xx) noexcept
  {
    return :: atan2l(_Yx, _Xx);
}

[[nodiscard]]  inline long double cbrt( long double _Xx) noexcept   {
    return :: cbrtl(_Xx);
}

[[nodiscard]]  inline long double ceil( long double _Xx) noexcept   {

    return __ceil(static_cast<double>(_Xx));




#line 332 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"
}

[[nodiscard]]  inline long double copysign( long double _Number,  long double _Sign) noexcept
  {

    return __copysign(static_cast<double>(_Number), static_cast<double>(_Sign));




#line 343 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"
}

[[nodiscard]]  inline long double cos( long double _Xx) noexcept   {
    return :: cosl(_Xx);
}

[[nodiscard]]  inline long double cosh( long double _Xx) noexcept   {
    return :: coshl(_Xx);
}

[[nodiscard]]  inline long double erf( long double _Xx) noexcept   {
    return :: erfl(_Xx);
}

[[nodiscard]]  inline long double erfc( long double _Xx) noexcept   {
    return :: erfcl(_Xx);
}

[[nodiscard]]  inline long double exp( long double _Xx) noexcept   {
    return :: expl(_Xx);
}

[[nodiscard]]  inline long double exp2( long double _Xx) noexcept   {
    return :: exp2l(_Xx);
}

[[nodiscard]]  inline long double expm1( long double _Xx) noexcept   {
    return :: expm1l(_Xx);
}

[[nodiscard]]  inline long double fabs( long double _Xx) noexcept   {
    return :: fabsl(_Xx);
}

[[nodiscard]]  inline long double fdim( long double _Xx,  long double _Yx) noexcept
  {
    return :: fdiml(_Xx, _Yx);
}

[[nodiscard]]  inline long double floor( long double _Xx) noexcept   {

    return __floor(static_cast<double>(_Xx));




#line 390 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"
}

[[nodiscard]]  inline long double fma(
     long double _Xx,  long double _Yx,  long double _Zx) noexcept   {
    return :: fmal(_Xx, _Yx, _Zx);
}

[[nodiscard]]  inline long double fmax( long double _Xx,  long double _Yx) noexcept
  {
    return :: fmaxl(_Xx, _Yx);
}

[[nodiscard]]  inline long double fmin( long double _Xx,  long double _Yx) noexcept
  {
    return :: fminl(_Xx, _Yx);
}

[[nodiscard]]  inline long double fmod( long double _Xx,  long double _Yx) noexcept
  {
    return :: fmodl(_Xx, _Yx);
}

inline long double frexp( long double _Xx,  int* _Yx) noexcept   {
    return :: frexpl(_Xx, _Yx);
}

[[nodiscard]]  inline long double hypot( long double _Xx,  long double _Yx) noexcept
  {
    return :: hypotl(_Xx, _Yx);
}

[[nodiscard]]  inline int ilogb( long double _Xx) noexcept   {
    return :: ilogbl(_Xx);
}

[[nodiscard]]  inline long double ldexp( long double _Xx,  int _Yx) noexcept   {
    return :: ldexpl(_Xx, _Yx);
}

[[nodiscard]]  inline long double lgamma( long double _Xx) noexcept   {
    return :: lgammal(_Xx);
}

[[nodiscard]]  inline long long llrint( long double _Xx) noexcept   {
    return :: llrintl(_Xx);
}

[[nodiscard]]  inline long long llround( long double _Xx) noexcept   {
    return :: llroundl(_Xx);
}

[[nodiscard]]  inline long double log( long double _Xx) noexcept   {
    return :: logl(_Xx);
}

[[nodiscard]]  inline long double log10( long double _Xx) noexcept   {
    return :: log10l(_Xx);
}

[[nodiscard]]  inline long double log1p( long double _Xx) noexcept   {
    return :: log1pl(_Xx);
}

[[nodiscard]]  inline long double log2( long double _Xx) noexcept   {
    return :: log2l(_Xx);
}

[[nodiscard]]  inline long double logb( long double _Xx) noexcept   {
    return :: logbl(_Xx);
}

[[nodiscard]]  inline long lrint( long double _Xx) noexcept   {
    return :: lrintl(_Xx);
}

[[nodiscard]]  inline long lround( long double _Xx) noexcept   {
    return :: lroundl(_Xx);
}

inline long double modf( long double _Xx,  long double* _Yx) noexcept   {
    return :: modfl(_Xx, _Yx);
}

[[nodiscard]]  inline long double nearbyint( long double _Xx) noexcept   {
    return :: nearbyintl(_Xx);
}

[[nodiscard]]  inline long double nextafter( long double _Xx,  long double _Yx) noexcept
  {
    return :: nextafterl(_Xx, _Yx);
}

[[nodiscard]]  inline long double nexttoward( long double _Xx,  long double _Yx) noexcept
  {
    return :: nexttowardl(_Xx, _Yx);
}

[[nodiscard]]  inline long double pow( long double _Xx,  long double _Yx) noexcept
  {
    return :: powl(_Xx, _Yx);
}

[[nodiscard]]  inline long double remainder( long double _Xx,  long double _Yx) noexcept
  {
    return :: remainderl(_Xx, _Yx);
}

inline long double remquo( long double _Xx,  long double _Yx,  int* _Zx) noexcept   {
    return :: remquol(_Xx, _Yx, _Zx);
}

[[nodiscard]]  inline long double rint( long double _Xx) noexcept   {
    return :: rintl(_Xx);
}

[[nodiscard]]  inline long double round( long double _Xx) noexcept   {

    return __round(static_cast<double>(_Xx));




#line 513 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"
}

[[nodiscard]]  inline long double scalbln( long double _Xx,  long _Yx) noexcept   {
    return :: scalblnl(_Xx, _Yx);
}

[[nodiscard]]  inline long double scalbn( long double _Xx,  int _Yx) noexcept   {
    return :: scalbnl(_Xx, _Yx);
}

[[nodiscard]]  inline long double sin( long double _Xx) noexcept   {
    return :: sinl(_Xx);
}

[[nodiscard]]  inline long double sinh( long double _Xx) noexcept   {
    return :: sinhl(_Xx);
}

[[nodiscard]]  inline long double sqrt( long double _Xx) noexcept   {
    return :: sqrtl(_Xx);
}

[[nodiscard]]  inline long double tan( long double _Xx) noexcept   {
    return :: tanl(_Xx);
}

[[nodiscard]]  inline long double tanh( long double _Xx) noexcept   {
    return :: tanhl(_Xx);
}

[[nodiscard]]  inline long double tgamma( long double _Xx) noexcept   {
    return :: tgammal(_Xx);
}

[[nodiscard]]  inline long double trunc( long double _Xx) noexcept   {

    return __trunc(static_cast<double>(_Xx));




#line 555 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"
}


namespace std {
template <class _Ty1, class _Ty2>
using _Common_float_type_t = conditional_t<is_same_v<_Ty1, long double> || is_same_v<_Ty2, long double>, long double,
    conditional_t<is_same_v<_Ty1, float> && is_same_v<_Ty2, float>, float,
        double>>; 
}

template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0>
double frexp(_Ty _Value,  int* const _Exp) noexcept   {
    return :: frexp(static_cast<double>(_Value), _Exp);
}

template <class _Ty1, class _Ty2, class _Ty3,
    ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2> && ::std:: is_arithmetic_v<_Ty3>, int> = 0>
[[nodiscard]] ::std:: _Common_float_type_t<_Ty1, ::std:: _Common_float_type_t<_Ty2, _Ty3>> fma(
    _Ty1 _Left, _Ty2 _Middle, _Ty3 _Right) noexcept   {
    using _Common = ::std:: _Common_float_type_t<_Ty1, ::std:: _Common_float_type_t<_Ty2, _Ty3>>;
    if constexpr (::std:: is_same_v<_Common, float>) {
        return :: fmaf(static_cast<_Common>(_Left), static_cast<_Common>(_Middle), static_cast<_Common>(_Right));
    } else if constexpr (::std:: is_same_v<_Common, double>) {
        return :: fma(static_cast<_Common>(_Left), static_cast<_Common>(_Middle), static_cast<_Common>(_Right));
    } else {
        return :: fmal(static_cast<_Common>(_Left), static_cast<_Common>(_Middle), static_cast<_Common>(_Right));
    }
}

template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0>
::std:: _Common_float_type_t<_Ty1, _Ty2> remquo(_Ty1 _Left, _Ty2 _Right, int* _Pquo) noexcept   {
    using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>;
    if constexpr (::std:: is_same_v<_Common, float>) {
        return :: remquof(static_cast<_Common>(_Left), static_cast<_Common>(_Right), _Pquo);
    } else if constexpr (::std:: is_same_v<_Common, double>) {
        return :: remquo(static_cast<_Common>(_Left), static_cast<_Common>(_Right), _Pquo);
    } else {
        return :: remquol(static_cast<_Common>(_Left), static_cast<_Common>(_Right), _Pquo);
    }
}
















#line 612 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"




























#line 641 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"


template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double acos(_Ty _Left) noexcept { return :: acos(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double asin(_Ty _Left) noexcept { return :: asin(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double atan(_Ty _Left) noexcept { return :: atan(static_cast<double>(_Left)); }
template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> atan2(_Ty1 _Left, _Ty2 _Right) noexcept { return :: atan2(static_cast<double>(_Left), static_cast<double>(_Right)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double cos(_Ty _Left) noexcept { return :: cos(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double sin(_Ty _Left) noexcept { return :: sin(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double tan(_Ty _Left) noexcept { return :: tan(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double acosh(_Ty _Left) noexcept { return :: acosh(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double asinh(_Ty _Left) noexcept { return :: asinh(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double atanh(_Ty _Left) noexcept { return :: atanh(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double cosh(_Ty _Left) noexcept { return :: cosh(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double sinh(_Ty _Left) noexcept { return :: sinh(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double tanh(_Ty _Left) noexcept { return :: tanh(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double exp(_Ty _Left) noexcept { return :: exp(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double exp2(_Ty _Left) noexcept { return :: exp2(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double expm1(_Ty _Left) noexcept { return :: expm1(static_cast<double>(_Left)); }

template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] int ilogb(_Ty _Left) noexcept { return :: ilogb(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double ldexp(_Ty _Left, int _Arg2) noexcept { return :: ldexp(static_cast<double>(_Left), _Arg2); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double log(_Ty _Left) noexcept { return :: log(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double log10(_Ty _Left) noexcept { return :: log10(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double log1p(_Ty _Left) noexcept { return :: log1p(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double log2(_Ty _Left) noexcept { return :: log2(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double logb(_Ty _Left) noexcept { return :: logb(static_cast<double>(_Left)); }

template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double scalbn(_Ty _Left, int _Arg2) noexcept { return :: scalbn(static_cast<double>(_Left), _Arg2); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double scalbln(_Ty _Left, long _Arg2) noexcept { return :: scalbln(static_cast<double>(_Left), _Arg2); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double cbrt(_Ty _Left) noexcept { return :: cbrt(static_cast<double>(_Left)); }

template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double fabs(_Ty _Left) noexcept { return :: fabs(static_cast<double>(_Left)); }
template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> hypot(_Ty1 _Left, _Ty2 _Right) noexcept { return :: hypot(static_cast<double>(_Left), static_cast<double>(_Right)); }

template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> pow(_Ty1 _Left, _Ty2 _Right) noexcept { return :: pow(static_cast<double>(_Left), static_cast<double>(_Right)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double sqrt(_Ty _Left) noexcept { return :: sqrt(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double erf(_Ty _Left) noexcept { return :: erf(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double erfc(_Ty _Left) noexcept { return :: erfc(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double lgamma(_Ty _Left) noexcept { return :: lgamma(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double tgamma(_Ty _Left) noexcept { return :: tgamma(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double ceil(_Ty _Left) noexcept { return __ceil(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double floor(_Ty _Left) noexcept { return __floor(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double nearbyint(_Ty _Left) noexcept { return :: nearbyint(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double rint(_Ty _Left) noexcept { return :: rint(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] long lrint(_Ty _Left) noexcept { return :: lrint(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] long long llrint(_Ty _Left) noexcept { return :: llrint(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double round(_Ty _Left) noexcept { return __round(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] long lround(_Ty _Left) noexcept { return :: lround(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] long long llround(_Ty _Left) noexcept { return :: llround(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double trunc(_Ty _Left) noexcept { return __trunc(static_cast<double>(_Left)); }
template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> fmod(_Ty1 _Left, _Ty2 _Right) noexcept { return :: fmod(static_cast<double>(_Left), static_cast<double>(_Right)); }
template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> remainder(_Ty1 _Left, _Ty2 _Right) noexcept { return :: remainder(static_cast<double>(_Left), static_cast<double>(_Right)); }

template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> copysign(_Ty1 _Left, _Ty2 _Right) noexcept { return __copysign(static_cast<double>(_Left), static_cast<double>(_Right)); }

template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> nextafter(_Ty1 _Left, _Ty2 _Right) noexcept { return :: nextafter(static_cast<double>(_Left), static_cast<double>(_Right)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double nexttoward(_Ty _Left, long double _Arg2) noexcept { return :: nexttoward(static_cast<double>(_Left), _Arg2); }
template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> fdim(_Ty1 _Left, _Ty2 _Right) noexcept { return :: fdim(static_cast<double>(_Left), static_cast<double>(_Right)); }
template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> fmax(_Ty1 _Left, _Ty2 _Right) noexcept { return :: fmax(static_cast<double>(_Left), static_cast<double>(_Right)); }
template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> fmin(_Ty1 _Left, _Ty2 _Right) noexcept { return :: fmin(static_cast<double>(_Left), static_cast<double>(_Right)); }















namespace std {
 using :: abs;
 using :: acos;
 using :: asin;
 using :: atan;
 using :: atan2;
 using :: ceil;
 using :: cos;
 using :: cosh;
 using :: exp;
 using :: fabs;
 using :: floor;
 using :: fmod;
 using :: frexp;
 using :: ldexp;
 using :: log;
 using :: log10;
 using :: modf;
 using :: pow;
 using :: sin;
 using :: sinh;
 using :: sqrt;
 using :: tan;
 using :: tanh;

 using :: acosf;
 using :: asinf;
 using :: atanf;
 using :: atan2f;
 using :: ceilf;
 using :: cosf;
 using :: coshf;
 using :: expf;
 using :: fabsf;
 using :: floorf;
 using :: fmodf;
 using :: frexpf;
 using :: ldexpf;
 using :: logf;
 using :: log10f;
 using :: modff;
 using :: powf;
 using :: sinf;
 using :: sinhf;
 using :: sqrtf;
 using :: tanf;
 using :: tanhf;

 using :: acosl;
 using :: asinl;
 using :: atanl;
 using :: atan2l;
 using :: ceill;
 using :: cosl;
 using :: coshl;
 using :: expl;
 using :: fabsl;
 using :: floorl;
 using :: fmodl;
 using :: frexpl;
 using :: ldexpl;
 using :: logl;
 using :: log10l;
 using :: modfl;
 using :: powl;
 using :: sinl;
 using :: sinhl;
 using :: sqrtl;
 using :: tanl;
 using :: tanhl;

 using :: float_t;
 using :: double_t;

 using :: acosh;
 using :: asinh;
 using :: atanh;
 using :: cbrt;
 using :: erf;
 using :: erfc;
 using :: expm1;
 using :: exp2;

inline namespace _Binary_hypot {
     using :: hypot;
} 

 using :: ilogb;
 using :: lgamma;
 using :: log1p;
 using :: log2;
 using :: logb;
 using :: llrint;
 using :: lrint;
 using :: nearbyint;
 using :: rint;
 using :: llround;
 using :: lround;
 using :: fdim;
 using :: fma;
 using :: fmax;
 using :: fmin;
 using :: round;
 using :: trunc;
 using :: remainder;
 using :: remquo;
 using :: copysign;
 using :: nan;
 using :: nextafter;
 using :: scalbn;
 using :: scalbln;
 using :: nexttoward;
 using :: tgamma;

 using :: acoshf;
 using :: asinhf;
 using :: atanhf;
 using :: cbrtf;
 using :: erff;
 using :: erfcf;
 using :: expm1f;
 using :: exp2f;
 using :: hypotf;
 using :: ilogbf;
 using :: lgammaf;
 using :: log1pf;
 using :: log2f;
 using :: logbf;
 using :: llrintf;
 using :: lrintf;
 using :: nearbyintf;
 using :: rintf;
 using :: llroundf;
 using :: lroundf;
 using :: fdimf;
 using :: fmaf;
 using :: fmaxf;
 using :: fminf;
 using :: roundf;
 using :: truncf;
 using :: remainderf;
 using :: remquof;
 using :: copysignf;
 using :: nanf;
 using :: nextafterf;
 using :: scalbnf;
 using :: scalblnf;
 using :: nexttowardf;
 using :: tgammaf;

 using :: acoshl;
 using :: asinhl;
 using :: atanhl;
 using :: cbrtl;
 using :: erfl;
 using :: erfcl;
 using :: expm1l;
 using :: exp2l;
 using :: hypotl;
 using :: ilogbl;
 using :: lgammal;
 using :: log1pl;
 using :: log2l;
 using :: logbl;
 using :: llrintl;
 using :: lrintl;
 using :: nearbyintl;
 using :: rintl;
 using :: llroundl;
 using :: lroundl;
 using :: fdiml;
 using :: fmal;
 using :: fmaxl;
 using :: fminl;
 using :: roundl;
 using :: truncl;
 using :: remainderl;
 using :: remquol;
 using :: copysignl;
 using :: nanl;
 using :: nextafterl;
 using :: scalbnl;
 using :: scalblnl;
 using :: nexttowardl;
 using :: tgammal;

 using :: fpclassify;
 using :: signbit;
 using :: isfinite;
 using :: isinf;
 using :: isnan;
 using :: isnormal;
 using :: isgreater;
 using :: isgreaterequal;
 using :: isless;
 using :: islessequal;
 using :: islessgreater;
 using :: isunordered;
}


extern "C" {
[[nodiscard]]  double __stdcall __std_smf_assoc_laguerre(unsigned int, unsigned int, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_assoc_laguerref(unsigned int, unsigned int, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_assoc_legendre(unsigned int, unsigned int, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_assoc_legendref(unsigned int, unsigned int, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_beta(double, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_betaf(float, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_comp_ellint_1(double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_comp_ellint_1f(float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_comp_ellint_2(double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_comp_ellint_2f(float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_comp_ellint_3(double, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_comp_ellint_3f(float, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_cyl_bessel_i(double, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_cyl_bessel_if(float, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_cyl_bessel_j(double, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_cyl_bessel_jf(float, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_cyl_bessel_k(double, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_cyl_bessel_kf(float, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_cyl_neumann(double, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_cyl_neumannf(float, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_ellint_1(double, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_ellint_1f(float, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_ellint_2(double, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_ellint_2f(float, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_ellint_3(double, double, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_ellint_3f(float, float, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_expint(double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_expintf(float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_hermite(unsigned int, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_hermitef(unsigned int, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_laguerre(unsigned int, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_laguerref(unsigned int, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_legendre(unsigned int, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_legendref(unsigned int, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_riemann_zeta(double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_riemann_zetaf(float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_sph_bessel(unsigned int, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_sph_besself(unsigned int, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_sph_legendre(unsigned int, unsigned int, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_sph_legendref(unsigned int, unsigned int, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_sph_neumann(unsigned int, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_sph_neumannf(unsigned int, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_hypot3(double, double, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_hypot3f(float, float, float) noexcept;
}

namespace std {
 [[nodiscard]] inline double assoc_laguerre(
    const unsigned int _Degree, const unsigned int _Order, const double _Value) noexcept   {
    return __std_smf_assoc_laguerre(_Degree, _Order, _Value);
}

 [[nodiscard]] inline float assoc_laguerref(
    const unsigned int _Degree, const unsigned int _Order, const float _Value) noexcept   {
    return __std_smf_assoc_laguerref(_Degree, _Order, _Value);
}

 [[nodiscard]] inline long double assoc_laguerrel(
    const unsigned int _Degree, const unsigned int _Order, const long double _Value) noexcept   {
    return __std_smf_assoc_laguerre(_Degree, _Order, static_cast<double>(_Value));
}

 [[nodiscard]] inline double assoc_legendre(
    const unsigned int _Degree, const unsigned int _Order, const double _Value) noexcept   {
    return __std_smf_assoc_legendre(_Degree, _Order, _Value);
}

 [[nodiscard]] inline float assoc_legendref(
    const unsigned int _Degree, const unsigned int _Order, const float _Value) noexcept   {
    return __std_smf_assoc_legendref(_Degree, _Order, _Value);
}

 [[nodiscard]] inline long double assoc_legendrel(
    const unsigned int _Degree, const unsigned int _Order, const long double _Value) noexcept   {
    return __std_smf_assoc_legendre(_Degree, _Order, static_cast<double>(_Value));
}

 [[nodiscard]] inline double beta(const double _Arg1, const double _Arg2) noexcept   {
    return __std_smf_beta(_Arg1, _Arg2);
}

 [[nodiscard]] inline float betaf(const float _Arg1, const float _Arg2) noexcept   {
    return __std_smf_betaf(_Arg1, _Arg2);
}

 [[nodiscard]] inline long double betal(const long double _Arg1, const long double _Arg2) noexcept
  {
    return __std_smf_beta(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}

 [[nodiscard]] inline double comp_ellint_1(const double _Arg) noexcept   {
    return __std_smf_comp_ellint_1(_Arg);
}

 [[nodiscard]] inline float comp_ellint_1f(const float _Arg) noexcept   {
    return __std_smf_comp_ellint_1f(_Arg);
}

 [[nodiscard]] inline long double comp_ellint_1l(const long double _Arg) noexcept   {
    return __std_smf_comp_ellint_1(static_cast<double>(_Arg));
}

 [[nodiscard]] inline double comp_ellint_2(const double _Arg) noexcept   {
    return __std_smf_comp_ellint_2(_Arg);
}

 [[nodiscard]] inline float comp_ellint_2f(const float _Arg) noexcept   {
    return __std_smf_comp_ellint_2f(_Arg);
}

 [[nodiscard]] inline long double comp_ellint_2l(const long double _Arg) noexcept   {
    return __std_smf_comp_ellint_2(static_cast<double>(_Arg));
}

 [[nodiscard]] inline double comp_ellint_3(const double _Arg1, const double _Arg2) noexcept   {
    return __std_smf_comp_ellint_3(_Arg1, _Arg2);
}

 [[nodiscard]] inline float comp_ellint_3f(const float _Arg1, const float _Arg2) noexcept   {
    return __std_smf_comp_ellint_3f(_Arg1, _Arg2);
}

 [[nodiscard]] inline long double comp_ellint_3l(const long double _Arg1, const long double _Arg2) noexcept
  {
    return __std_smf_comp_ellint_3(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}

 [[nodiscard]] inline double cyl_bessel_i(const double _Arg1, const double _Arg2) noexcept   {
    return __std_smf_cyl_bessel_i(_Arg1, _Arg2);
}

 [[nodiscard]] inline float cyl_bessel_if(const float _Arg1, const float _Arg2) noexcept   {
    return __std_smf_cyl_bessel_if(_Arg1, _Arg2);
}

 [[nodiscard]] inline long double cyl_bessel_il(const long double _Arg1, const long double _Arg2) noexcept
  {
    return __std_smf_cyl_bessel_i(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}

 [[nodiscard]] inline double cyl_bessel_j(const double _Arg1, const double _Arg2) noexcept   {
    return __std_smf_cyl_bessel_j(_Arg1, _Arg2);
}

 [[nodiscard]] inline float cyl_bessel_jf(const float _Arg1, const float _Arg2) noexcept   {
    return __std_smf_cyl_bessel_jf(_Arg1, _Arg2);
}

 [[nodiscard]] inline long double cyl_bessel_jl(const long double _Arg1, const long double _Arg2) noexcept
  {
    return __std_smf_cyl_bessel_j(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}

 [[nodiscard]] inline double cyl_bessel_k(const double _Arg1, const double _Arg2) noexcept   {
    return __std_smf_cyl_bessel_k(_Arg1, _Arg2);
}

 [[nodiscard]] inline float cyl_bessel_kf(const float _Arg1, const float _Arg2) noexcept   {
    return __std_smf_cyl_bessel_kf(_Arg1, _Arg2);
}

 [[nodiscard]] inline long double cyl_bessel_kl(const long double _Arg1, const long double _Arg2) noexcept
  {
    return __std_smf_cyl_bessel_k(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}

 [[nodiscard]] inline double cyl_neumann(const double _Arg1, const double _Arg2) noexcept   {
    return __std_smf_cyl_neumann(_Arg1, _Arg2);
}

 [[nodiscard]] inline float cyl_neumannf(const float _Arg1, const float _Arg2) noexcept   {
    return __std_smf_cyl_neumannf(_Arg1, _Arg2);
}

 [[nodiscard]] inline long double cyl_neumannl(const long double _Arg1, const long double _Arg2) noexcept
  {
    return __std_smf_cyl_neumann(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}

 [[nodiscard]] inline double ellint_1(const double _Arg1, const double _Arg2) noexcept   {
    return __std_smf_ellint_1(_Arg1, _Arg2);
}

 [[nodiscard]] inline float ellint_1f(const float _Arg1, const float _Arg2) noexcept   {
    return __std_smf_ellint_1f(_Arg1, _Arg2);
}

 [[nodiscard]] inline long double ellint_1l(const long double _Arg1, const long double _Arg2) noexcept
  {
    return __std_smf_ellint_1(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}

 [[nodiscard]] inline double ellint_2(const double _Arg1, const double _Arg2) noexcept   {
    return __std_smf_ellint_2(_Arg1, _Arg2);
}

 [[nodiscard]] inline float ellint_2f(const float _Arg1, const float _Arg2) noexcept   {
    return __std_smf_ellint_2f(_Arg1, _Arg2);
}

 [[nodiscard]] inline long double ellint_2l(const long double _Arg1, const long double _Arg2) noexcept
  {
    return __std_smf_ellint_2(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}

 [[nodiscard]] inline double ellint_3(const double _Arg1, const double _Arg2, const double _Arg3) noexcept
  {
    return __std_smf_ellint_3(_Arg1, _Arg2, _Arg3);
}

 [[nodiscard]] inline float ellint_3f(const float _Arg1, const float _Arg2, const float _Arg3) noexcept
  {
    return __std_smf_ellint_3f(_Arg1, _Arg2, _Arg3);
}

 [[nodiscard]] inline long double ellint_3l(
    const long double _Arg1, const long double _Arg2, const long double _Arg3) noexcept   {
    return __std_smf_ellint_3(static_cast<double>(_Arg1), static_cast<double>(_Arg2), static_cast<double>(_Arg3));
}

 [[nodiscard]] inline double expint(const double _Arg) noexcept   {
    return __std_smf_expint(_Arg);
}

 [[nodiscard]] inline float expintf(const float _Arg) noexcept   {
    return __std_smf_expintf(_Arg);
}

 [[nodiscard]] inline long double expintl(const long double _Arg) noexcept   {
    return __std_smf_expint(static_cast<double>(_Arg));
}

 [[nodiscard]] inline double hermite(const unsigned int _Arg1, const double _Arg2) noexcept   {
    return __std_smf_hermite(_Arg1, _Arg2);
}

 [[nodiscard]] inline float hermitef(const unsigned int _Arg1, const float _Arg2) noexcept   {
    return __std_smf_hermitef(_Arg1, _Arg2);
}

 [[nodiscard]] inline long double hermitel(const unsigned int _Arg1, const long double _Arg2) noexcept
  {
    return __std_smf_hermite(_Arg1, static_cast<double>(_Arg2));
}

 [[nodiscard]] inline double laguerre(const unsigned int _Arg1, const double _Arg2) noexcept
  {
    return __std_smf_laguerre(_Arg1, _Arg2);
}

 [[nodiscard]] inline float laguerref(const unsigned int _Arg1, const float _Arg2) noexcept   {
    return __std_smf_laguerref(_Arg1, _Arg2);
}

 [[nodiscard]] inline long double laguerrel(const unsigned int _Arg1, const long double _Arg2) noexcept
  {
    return __std_smf_laguerre(_Arg1, static_cast<double>(_Arg2));
}

 [[nodiscard]] inline double legendre(const unsigned int _Degree, const double _Value) noexcept
  {
    return __std_smf_legendre(_Degree, _Value);
}

 [[nodiscard]] inline float legendref(const unsigned int _Degree, const float _Value) noexcept
  {
    return __std_smf_legendref(_Degree, _Value);
}

 [[nodiscard]] inline long double legendrel(const unsigned int _Degree, const long double _Value) noexcept
  {
    return __std_smf_legendre(_Degree, static_cast<double>(_Value));
}

 [[nodiscard]] inline double riemann_zeta(const double _Arg) noexcept   {
    return __std_smf_riemann_zeta(_Arg);
}
 [[nodiscard]] inline float riemann_zetaf(const float _Arg) noexcept   {
    return __std_smf_riemann_zetaf(_Arg);
}

 [[nodiscard]] inline long double riemann_zetal(const long double _Arg) noexcept   {
    return __std_smf_riemann_zeta(static_cast<double>(_Arg));
}

 [[nodiscard]] inline double sph_bessel(const unsigned int _Arg1, const double _Arg2) noexcept
  {
    return __std_smf_sph_bessel(_Arg1, _Arg2);
}

 [[nodiscard]] inline float sph_besself(const unsigned int _Arg1, const float _Arg2) noexcept
  {
    return __std_smf_sph_besself(_Arg1, _Arg2);
}

 [[nodiscard]] inline long double sph_bessell(const unsigned int _Arg1, const long double _Arg2) noexcept
  {
    return __std_smf_sph_bessel(_Arg1, static_cast<double>(_Arg2));
}

 [[nodiscard]] inline double sph_legendre(
    const unsigned int _Arg1, const unsigned int _Arg2, const double _Theta) noexcept
  {
    return __std_smf_sph_legendre(_Arg1, _Arg2, _Theta);
}

 [[nodiscard]] inline float sph_legendref(
    const unsigned int _Arg1, const unsigned int _Arg2, const float _Theta) noexcept
  {
    return __std_smf_sph_legendref(_Arg1, _Arg2, _Theta);
}

 [[nodiscard]] inline long double sph_legendrel(
    const unsigned int _Arg1, const unsigned int _Arg2, const long double _Theta) noexcept   {
    return __std_smf_sph_legendre(_Arg1, _Arg2, static_cast<double>(_Theta));
}

 [[nodiscard]] inline double sph_neumann(const unsigned int _Arg1, const double _Arg2) noexcept
  {
    return __std_smf_sph_neumann(_Arg1, _Arg2);
}

 [[nodiscard]] inline float sph_neumannf(const unsigned int _Arg1, const float _Arg2) noexcept
  {
    return __std_smf_sph_neumannf(_Arg1, _Arg2);
}

 [[nodiscard]] inline long double sph_neumannl(const unsigned int _Arg1, const long double _Arg2) noexcept
  {
    return __std_smf_sph_neumann(_Arg1, static_cast<double>(_Arg2));
}





























































template <class _Ty, enable_if_t<is_arithmetic_v<_Ty>, int> = 0> [[nodiscard]] auto assoc_laguerre( const unsigned int _Arg1, const unsigned int _Arg2, const _Ty _Arg3) noexcept { using _Common = conditional_t<is_integral_v<_Ty>, double, _Ty>; if constexpr (is_same_v<_Common, float>) { return __std_smf_assoc_laguerref(_Arg1, _Arg2, _Arg3); } else { return static_cast<_Common>(__std_smf_assoc_laguerre(_Arg1, _Arg2, static_cast<double>(_Arg3))); } }
template <class _Ty, enable_if_t<is_arithmetic_v<_Ty>, int> = 0> [[nodiscard]] auto assoc_legendre( const unsigned int _Arg1, const unsigned int _Arg2, const _Ty _Arg3) noexcept { using _Common = conditional_t<is_integral_v<_Ty>, double, _Ty>; if constexpr (is_same_v<_Common, float>) { return __std_smf_assoc_legendref(_Arg1, _Arg2, _Arg3); } else { return static_cast<_Common>(__std_smf_assoc_legendre(_Arg1, _Arg2, static_cast<double>(_Arg3))); } }
template <class _Ty1, class _Ty2, enable_if_t<is_arithmetic_v<_Ty1> && is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] auto beta(const _Ty1 _Arg1, const _Ty2 _Arg2) noexcept { using _Common = _Common_float_type_t<_Ty1, _Ty2>; if constexpr (is_same_v<_Common, float>) { return __std_smf_betaf(_Arg1, _Arg2); } else { return static_cast<_Common>(__std_smf_beta(static_cast<double>(_Arg1), static_cast<double>(_Arg2))); } }
template <class _Ty, enable_if_t<is_arithmetic_v<_Ty>, int> = 0> [[nodiscard]] auto comp_ellint_1(const _Ty _Arg) noexcept { using _Common = conditional_t<is_integral_v<_Ty>, double, _Ty>; if constexpr (is_same_v<_Common, float>) { return __std_smf_comp_ellint_1f(_Arg); } else { return static_cast<_Common>(__std_smf_comp_ellint_1(static_cast<double>(_Arg))); } }
template <class _Ty, enable_if_t<is_arithmetic_v<_Ty>, int> = 0> [[nodiscard]] auto comp_ellint_2(const _Ty _Arg) noexcept { using _Common = conditional_t<is_integral_v<_Ty>, double, _Ty>; if constexpr (is_same_v<_Common, float>) { return __std_smf_comp_ellint_2f(_Arg); } else { return static_cast<_Common>(__std_smf_comp_ellint_2(static_cast<double>(_Arg))); } }
template <class _Ty1, class _Ty2, enable_if_t<is_arithmetic_v<_Ty1> && is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] auto comp_ellint_3(const _Ty1 _Arg1, const _Ty2 _Arg2) noexcept { using _Common = _Common_float_type_t<_Ty1, _Ty2>; if constexpr (is_same_v<_Common, float>) { return __std_smf_comp_ellint_3f(_Arg1, _Arg2); } else { return static_cast<_Common>(__std_smf_comp_ellint_3(static_cast<double>(_Arg1), static_cast<double>(_Arg2))); } }
template <class _Ty1, class _Ty2, enable_if_t<is_arithmetic_v<_Ty1> && is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] auto cyl_bessel_i(const _Ty1 _Arg1, const _Ty2 _Arg2) noexcept { using _Common = _Common_float_type_t<_Ty1, _Ty2>; if constexpr (is_same_v<_Common, float>) { return __std_smf_cyl_bessel_if(_Arg1, _Arg2); } else { return static_cast<_Common>(__std_smf_cyl_bessel_i(static_cast<double>(_Arg1), static_cast<double>(_Arg2))); } }
template <class _Ty1, class _Ty2, enable_if_t<is_arithmetic_v<_Ty1> && is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] auto cyl_bessel_j(const _Ty1 _Arg1, const _Ty2 _Arg2) noexcept { using _Common = _Common_float_type_t<_Ty1, _Ty2>; if constexpr (is_same_v<_Common, float>) { return __std_smf_cyl_bessel_jf(_Arg1, _Arg2); } else { return static_cast<_Common>(__std_smf_cyl_bessel_j(static_cast<double>(_Arg1), static_cast<double>(_Arg2))); } }
template <class _Ty1, class _Ty2, enable_if_t<is_arithmetic_v<_Ty1> && is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] auto cyl_bessel_k(const _Ty1 _Arg1, const _Ty2 _Arg2) noexcept { using _Common = _Common_float_type_t<_Ty1, _Ty2>; if constexpr (is_same_v<_Common, float>) { return __std_smf_cyl_bessel_kf(_Arg1, _Arg2); } else { return static_cast<_Common>(__std_smf_cyl_bessel_k(static_cast<double>(_Arg1), static_cast<double>(_Arg2))); } }
template <class _Ty1, class _Ty2, enable_if_t<is_arithmetic_v<_Ty1> && is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] auto cyl_neumann(const _Ty1 _Arg1, const _Ty2 _Arg2) noexcept { using _Common = _Common_float_type_t<_Ty1, _Ty2>; if constexpr (is_same_v<_Common, float>) { return __std_smf_cyl_neumannf(_Arg1, _Arg2); } else { return static_cast<_Common>(__std_smf_cyl_neumann(static_cast<double>(_Arg1), static_cast<double>(_Arg2))); } }
template <class _Ty1, class _Ty2, enable_if_t<is_arithmetic_v<_Ty1> && is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] auto ellint_1(const _Ty1 _Arg1, const _Ty2 _Arg2) noexcept { using _Common = _Common_float_type_t<_Ty1, _Ty2>; if constexpr (is_same_v<_Common, float>) { return __std_smf_ellint_1f(_Arg1, _Arg2); } else { return static_cast<_Common>(__std_smf_ellint_1(static_cast<double>(_Arg1), static_cast<double>(_Arg2))); } }
template <class _Ty1, class _Ty2, enable_if_t<is_arithmetic_v<_Ty1> && is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] auto ellint_2(const _Ty1 _Arg1, const _Ty2 _Arg2) noexcept { using _Common = _Common_float_type_t<_Ty1, _Ty2>; if constexpr (is_same_v<_Common, float>) { return __std_smf_ellint_2f(_Arg1, _Arg2); } else { return static_cast<_Common>(__std_smf_ellint_2(static_cast<double>(_Arg1), static_cast<double>(_Arg2))); } }
template <class _Ty1, class _Ty2, class _Ty3, enable_if_t<is_arithmetic_v<_Ty1> && is_arithmetic_v<_Ty2> && is_arithmetic_v<_Ty3>, int> = 0> [[nodiscard]] auto ellint_3(const _Ty1 _Arg1, const _Ty2 _Arg2, const _Ty3 _Arg3) noexcept { using _Common = _Common_float_type_t<_Ty1, _Common_float_type_t<_Ty2, _Ty3>>; if constexpr (is_same_v<_Common, float>) { return __std_smf_ellint_3f(_Arg1, _Arg2, _Arg3); } else { return static_cast<_Common>( __std_smf_ellint_3(static_cast<double>(_Arg1), static_cast<double>(_Arg2), static_cast<double>(_Arg3))); } }
template <class _Ty, enable_if_t<is_arithmetic_v<_Ty>, int> = 0> [[nodiscard]] auto expint(const _Ty _Arg) noexcept { using _Common = conditional_t<is_integral_v<_Ty>, double, _Ty>; if constexpr (is_same_v<_Common, float>) { return __std_smf_expintf(_Arg); } else { return static_cast<_Common>(__std_smf_expint(static_cast<double>(_Arg))); } }
template <class _Ty, enable_if_t<is_arithmetic_v<_Ty>, int> = 0> [[nodiscard]] auto hermite(const unsigned int _Arg1, const _Ty _Arg2) noexcept { using _Common = conditional_t<is_integral_v<_Ty>, double, _Ty>; if constexpr (is_same_v<_Common, float>) { return __std_smf_hermitef(_Arg1, _Arg2); } else { return static_cast<_Common>(__std_smf_hermite(_Arg1, static_cast<double>(_Arg2))); } }
template <class _Ty, enable_if_t<is_arithmetic_v<_Ty>, int> = 0> [[nodiscard]] auto laguerre(const unsigned int _Arg1, const _Ty _Arg2) noexcept { using _Common = conditional_t<is_integral_v<_Ty>, double, _Ty>; if constexpr (is_same_v<_Common, float>) { return __std_smf_laguerref(_Arg1, _Arg2); } else { return static_cast<_Common>(__std_smf_laguerre(_Arg1, static_cast<double>(_Arg2))); } }
template <class _Ty, enable_if_t<is_arithmetic_v<_Ty>, int> = 0> [[nodiscard]] auto legendre(const unsigned int _Arg1, const _Ty _Arg2) noexcept { using _Common = conditional_t<is_integral_v<_Ty>, double, _Ty>; if constexpr (is_same_v<_Common, float>) { return __std_smf_legendref(_Arg1, _Arg2); } else { return static_cast<_Common>(__std_smf_legendre(_Arg1, static_cast<double>(_Arg2))); } }
template <class _Ty, enable_if_t<is_arithmetic_v<_Ty>, int> = 0> [[nodiscard]] auto riemann_zeta(const _Ty _Arg) noexcept { using _Common = conditional_t<is_integral_v<_Ty>, double, _Ty>; if constexpr (is_same_v<_Common, float>) { return __std_smf_riemann_zetaf(_Arg); } else { return static_cast<_Common>(__std_smf_riemann_zeta(static_cast<double>(_Arg))); } }
template <class _Ty, enable_if_t<is_arithmetic_v<_Ty>, int> = 0> [[nodiscard]] auto sph_bessel(const unsigned int _Arg1, const _Ty _Arg2) noexcept { using _Common = conditional_t<is_integral_v<_Ty>, double, _Ty>; if constexpr (is_same_v<_Common, float>) { return __std_smf_sph_besself(_Arg1, _Arg2); } else { return static_cast<_Common>(__std_smf_sph_bessel(_Arg1, static_cast<double>(_Arg2))); } }
template <class _Ty, enable_if_t<is_arithmetic_v<_Ty>, int> = 0> [[nodiscard]] auto sph_legendre( const unsigned int _Arg1, const unsigned int _Arg2, const _Ty _Arg3) noexcept { using _Common = conditional_t<is_integral_v<_Ty>, double, _Ty>; if constexpr (is_same_v<_Common, float>) { return __std_smf_sph_legendref(_Arg1, _Arg2, _Arg3); } else { return static_cast<_Common>(__std_smf_sph_legendre(_Arg1, _Arg2, static_cast<double>(_Arg3))); } }
template <class _Ty, enable_if_t<is_arithmetic_v<_Ty>, int> = 0> [[nodiscard]] auto sph_neumann(const unsigned int _Arg1, const _Ty _Arg2) noexcept { using _Common = conditional_t<is_integral_v<_Ty>, double, _Ty>; if constexpr (is_same_v<_Common, float>) { return __std_smf_sph_neumannf(_Arg1, _Arg2); } else { return static_cast<_Common>(__std_smf_sph_neumann(_Arg1, static_cast<double>(_Arg2))); } }







 [[nodiscard]] inline double hypot(const double _Dx, const double _Dy, const double _Dz) {
    return __std_smf_hypot3(_Dx, _Dy, _Dz);
}

 [[nodiscard]] inline float hypot(const float _Dx, const float _Dy, const float _Dz) {
    return __std_smf_hypot3f(_Dx, _Dy, _Dz);
}

 [[nodiscard]] inline long double hypot(const long double _Dx, const long double _Dy, const long double _Dz) {
    return __std_smf_hypot3(static_cast<double>(_Dx), static_cast<double>(_Dy), static_cast<double>(_Dz));
}

 template <class _Ty1, class _Ty2, class _Ty3,
    enable_if_t<is_arithmetic_v<_Ty1> && is_arithmetic_v<_Ty2> && is_arithmetic_v<_Ty3>, int> = 0>
[[nodiscard]] auto hypot(const _Ty1 _Dx, const _Ty2 _Dy, const _Ty3 _Dz) {
    
    
    
    using _Common      = _Common_float_type_t<_Ty1, _Common_float_type_t<_Ty2, _Ty3>>; 
    const auto _Result = __std_smf_hypot3(static_cast<double>(_Dx), static_cast<double>(_Dy), static_cast<double>(_Dz));
    return static_cast<_Common>(_Result);
}


template <class _Ty>
[[nodiscard]] constexpr _Ty _Linear_for_lerp(const _Ty _ArgA, const _Ty _ArgB, const _Ty _ArgT) {
    if (::std:: is_constant_evaluated()) {
        auto _Smaller     = _ArgT;
        auto _Larger      = _ArgB - _ArgA;
        auto _Abs_smaller = _Float_abs(_Smaller);
        auto _Abs_larger  = _Float_abs(_Larger);
        if (_Abs_larger < _Abs_smaller) {
            ::std:: swap(_Smaller, _Larger);
            ::std:: swap(_Abs_smaller, _Abs_larger);
        }

        if (_Abs_smaller > 1) {
            
            
            
            return 2 * (_Ty{0.5} * _ArgA + _Smaller * (_Ty{0.5} * _Larger));
        } else {
            return _ArgA + _Smaller * _Larger;
        }
    }

    return ::std:: fma(_ArgT, _ArgB - _ArgA, _ArgA);
}

template <class _Ty>
[[nodiscard]] constexpr _Ty _Common_lerp(const _Ty _ArgA, const _Ty _ArgB, const _Ty _ArgT) noexcept {
    

    const bool _T_is_finite = _Is_finite(_ArgT);
    if (_T_is_finite && _Is_finite(_ArgA) && _Is_finite(_ArgB)) {
        
        if ((_ArgA <= 0 && _ArgB >= 0) || (_ArgA >= 0 && _ArgB <= 0)) {
            
            return _ArgT * _ArgB + (1 - _ArgT) * _ArgA;
        }

        if (_ArgT == 1) {
            
            return _ArgB;
        }

        
        const auto _Candidate = _Linear_for_lerp(_ArgA, _ArgB, _ArgT);
        
        if ((_ArgT > 1) == (_ArgB > _ArgA)) {
            if (_ArgB > _Candidate) {
                return _ArgB;
            }
        } else {
            if (_Candidate > _ArgB) {
                return _ArgB;
            }
        }

        return _Candidate;
    }

    if (::std:: is_constant_evaluated()) {
        if (_Is_nan(_ArgA)) {
            return _ArgA;
        }

        if (_Is_nan(_ArgB)) {
            return _ArgB;
        }

        if (_Is_nan(_ArgT)) {
            return _ArgT;
        }
    } else {
        
        if (_Is_nan(_ArgA) || _Is_nan(_ArgB)) {
            return (_ArgA + _ArgB) + _ArgT;
        }

        if (_Is_nan(_ArgT)) {
            return _ArgT + _ArgT;
        }
    }

    if (_T_is_finite) {
        
        if (_ArgT < 0) {
            
            return _ArgA - _ArgB;
        } else if (_ArgT <= 1) {
            
            
            
            return _ArgT * _ArgB + (1 - _ArgT) * _ArgA;
        } else {
            
            return _ArgB - _ArgA;
        }
    } else {
        
        return _ArgT * (_ArgB - _ArgA);
    }
}

 [[nodiscard]] constexpr inline float lerp(const float _ArgA, const float _ArgB, const float _ArgT) noexcept {
    return _Common_lerp(_ArgA, _ArgB, _ArgT);
}

 [[nodiscard]] constexpr inline double lerp(
    const double _ArgA, const double _ArgB, const double _ArgT) noexcept {
    return _Common_lerp(_ArgA, _ArgB, _ArgT);
}

 [[nodiscard]] constexpr inline long double lerp(
    const long double _ArgA, const long double _ArgB, const long double _ArgT) noexcept {
    return _Common_lerp(_ArgA, _ArgB, _ArgT);
}

 template <class _Ty1, class _Ty2, class _Ty3,
    enable_if_t<is_arithmetic_v<_Ty1> && is_arithmetic_v<_Ty2> && is_arithmetic_v<_Ty3>, int> = 0>
[[nodiscard]] constexpr auto lerp(const _Ty1 _ArgA, const _Ty2 _ArgB, const _Ty3 _ArgT) noexcept {
    using _Tgt = conditional_t<_Is_any_of_v<long double, _Ty1, _Ty2, _Ty3>, long double, double>;
    return _Common_lerp(static_cast<_Tgt>(_ArgA), static_cast<_Tgt>(_ArgB), static_cast<_Tgt>(_ArgT));
}
#line 1484 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"
}
#line 1486 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"



#pragma warning(pop)
#pragma pack(pop)

#line 1493 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"
#line 1494 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"
#pragma external_header(pop)
#line 13 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xlocnum"


#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iterator"





#pragma once




#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iosfwd"





#pragma once










#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




namespace std {



















#line 45 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iosfwd"


 using streamoff  = long long;
 using streamsize = long long;

 template <class _Statetype>
class fpos { 
public:
      fpos(streamoff _Off = 0) : _Myoff(_Off), _Fpos(0), _Mystate() {}

    fpos(_Statetype _State, fpos_t _Fileposition) : _Myoff(_Fileposition), _Fpos(0), _Mystate(_State) {}

    [[nodiscard]] _Statetype state() const {
        return _Mystate;
    }

    void state(_Statetype _State) {
        _Mystate = _State;
    }

    operator streamoff() const noexcept   {
        
        
        return _Myoff + _Fpos;
    }


    [[deprecated("warning STL4019: " "The member std::fpos::seekpos() is non-Standard, and is preserved only for compatibility with " "workarounds for old versions of Visual C++. It will be removed in a future release, and in this " "release always returns 0. Please use standards-conforming mechanisms to manipulate fpos, such as " "conversions to and from streamoff, or an integral type, instead. If you are receiving this message " "while compiling Boost.IOStreams, a fix has been submitted upstream to make Boost use " "standards-conforming mechanisms, as it does for other compilers. You can define " "_SILENCE_FPOS_SEEKPOS_DEPRECATION_WARNING to suppress this warning, " "or define _REMOVE_FPOS_SEEKPOS to remove std::fpos::seekpos entirely.")]] fpos_t seekpos() const noexcept {
        return {};
    }
#line 76 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iosfwd"

    [[nodiscard]] streamoff operator-(const fpos& _Right) const noexcept   {
        return static_cast<streamoff>(*this) - static_cast<streamoff>(_Right);
    }

    fpos& operator+=(streamoff _Off) noexcept   { 
        _Myoff += _Off;
        return *this;
    }

    fpos& operator-=(streamoff _Off) noexcept   { 
        _Myoff -= _Off;
        return *this;
    }

    [[nodiscard]] fpos operator+(streamoff _Off) const {
        fpos _Tmp = *this;
        _Tmp += _Off;
        return _Tmp;
    }

    [[nodiscard]] fpos operator-(streamoff _Off) const {
        fpos _Tmp = *this;
        _Tmp -= _Off;
        return _Tmp;
    }

    [[nodiscard]] bool operator==(const fpos& _Right) const noexcept   {
        return static_cast<streamoff>(*this) == static_cast<streamoff>(_Right);
    }

    template <class _Int, enable_if_t<is_integral_v<_Int>, int> = 0>
    [[nodiscard]] friend bool operator==(const fpos& _Left, const _Int _Right) noexcept   {
        return static_cast<streamoff>(_Left) == _Right;
    }




















#line 132 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iosfwd"

private:
    streamoff _Myoff; 
    fpos_t _Fpos; 
    _Statetype _Mystate; 
};

 using streampos  = fpos<_Mbstatet>;
 using wstreampos = streampos;

 using u8streampos = streampos;
#line 144 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iosfwd"
 using u16streampos = streampos;
 using u32streampos = streampos;

 extern "C++" class locale;
 template <class _Facet>
const _Facet& __cdecl use_facet(const locale&);

 template <class _Elem>
struct char_traits;
template <>
struct char_traits<char>;

template <>
struct char_traits<char8_t>;
#line 159 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iosfwd"
template <>
struct char_traits<char16_t>;
template <>
struct char_traits<char32_t>;
template <>
struct char_traits<wchar_t>;





 template <class _Ty>
class allocator;
 extern "C++" class ios_base;
 extern "C++" template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_ios;
 template <class _Elem, class _Traits = char_traits<_Elem>>
class istreambuf_iterator;
 template <class _Elem, class _Traits = char_traits<_Elem>>
class ostreambuf_iterator;
 extern "C++" template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_streambuf;

#pragma vtordisp(push, 2) 
 extern "C++" template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_istream;
 extern "C++" template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_ostream;
#pragma vtordisp(pop) 

 extern "C++" template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_iostream;
 template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
class basic_stringbuf;
 template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
class basic_istringstream;
 template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
class basic_ostringstream;
 template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
class basic_stringstream;









#line 209 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iosfwd"
 template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_filebuf;
 template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_ifstream;
 template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_ofstream;
 template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_fstream;

template <class _Elem, class _Traits = char_traits<_Elem>>
class _Basic_syncbuf_impl;
 template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
class basic_syncbuf;
 template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
class basic_osyncstream;
#line 225 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iosfwd"


 extern "C++" template <class _Elem, class _InIt>
class num_get;
 extern "C++" template <class _Elem, class _OutIt>
class num_put;
 template <class _Elem>
class collate;
#line 234 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iosfwd"

 using ios           = basic_ios<char, char_traits<char>>;
 using streambuf     = basic_streambuf<char, char_traits<char>>;
 using istream       = basic_istream<char, char_traits<char>>;
 using ostream       = basic_ostream<char, char_traits<char>>;
 using iostream      = basic_iostream<char, char_traits<char>>;
 using stringbuf     = basic_stringbuf<char, char_traits<char>, allocator<char>>;
 using istringstream = basic_istringstream<char, char_traits<char>, allocator<char>>;
 using ostringstream = basic_ostringstream<char, char_traits<char>, allocator<char>>;
 using stringstream  = basic_stringstream<char, char_traits<char>, allocator<char>>;
 using filebuf       = basic_filebuf<char, char_traits<char>>;
 using ifstream      = basic_ifstream<char, char_traits<char>>;
 using ofstream      = basic_ofstream<char, char_traits<char>>;
 using fstream       = basic_fstream<char, char_traits<char>>;

 using syncbuf     = basic_syncbuf<char>;
 using osyncstream = basic_osyncstream<char>;
#line 252 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iosfwd"





#line 258 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iosfwd"

 using wios           = basic_ios<wchar_t, char_traits<wchar_t>>;
 using wstreambuf     = basic_streambuf<wchar_t, char_traits<wchar_t>>;
 using wistream       = basic_istream<wchar_t, char_traits<wchar_t>>;
 using wostream       = basic_ostream<wchar_t, char_traits<wchar_t>>;
 using wiostream      = basic_iostream<wchar_t, char_traits<wchar_t>>;
 using wstringbuf     = basic_stringbuf<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
 using wistringstream = basic_istringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
 using wostringstream = basic_ostringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
 using wstringstream  = basic_stringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
 using wfilebuf       = basic_filebuf<wchar_t, char_traits<wchar_t>>;
 using wifstream      = basic_ifstream<wchar_t, char_traits<wchar_t>>;
 using wofstream      = basic_ofstream<wchar_t, char_traits<wchar_t>>;
 using wfstream       = basic_fstream<wchar_t, char_traits<wchar_t>>;

 using wsyncbuf     = basic_syncbuf<wchar_t>;
 using wosyncstream = basic_osyncstream<wchar_t>;
#line 276 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iosfwd"





#line 282 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iosfwd"

}



#pragma warning(pop)
#pragma pack(pop)
#line 290 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iosfwd"
#line 291 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iosfwd"
#pragma external_header(pop)
#line 12 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iterator"


#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




namespace std {
 template <class _Container>
class back_insert_iterator { 
public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;
    using pointer           = void;
    using reference         = void;

    using container_type = _Container;


    using difference_type = ptrdiff_t;


#line 37 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iterator"

    constexpr explicit back_insert_iterator(_Container& _Cont) noexcept  
        : container(::std:: addressof(_Cont)) {}

    constexpr back_insert_iterator& operator=(const typename _Container::value_type& _Val) {
        container->push_back(_Val);
        return *this;
    }

    constexpr back_insert_iterator& operator=(typename _Container::value_type&& _Val) {
        container->push_back(::std:: move(_Val));
        return *this;
    }

    [[nodiscard]] constexpr back_insert_iterator& operator*() noexcept   {
        return *this;
    }

    constexpr back_insert_iterator& operator++() noexcept   {
        return *this;
    }

    constexpr back_insert_iterator operator++(int) noexcept   {
        return *this;
    }

protected:
    _Container* container;
};

 template <class _Container>
[[nodiscard]] constexpr back_insert_iterator<_Container> back_inserter(_Container& _Cont) noexcept   {
    
    return back_insert_iterator<_Container>(_Cont);
}

 template <class _Container>
class front_insert_iterator { 
public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;
    using pointer           = void;
    using reference         = void;

    using container_type = _Container;


    using difference_type = ptrdiff_t;


#line 88 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iterator"

    constexpr explicit front_insert_iterator(_Container& _Cont) : container(::std:: addressof(_Cont)) {}

    constexpr front_insert_iterator& operator=(const typename _Container::value_type& _Val) {
        
        container->push_front(_Val);
        return *this;
    }

    constexpr front_insert_iterator& operator=(typename _Container::value_type&& _Val) { 
        container->push_front(::std:: move(_Val));
        return *this;
    }

    [[nodiscard]] constexpr front_insert_iterator& operator*() { 
        return *this;
    }

    constexpr front_insert_iterator& operator++() { 
        return *this;
    }

    constexpr front_insert_iterator operator++(int) { 
        return *this;
    }

protected:
    _Container* container;
};

 template <class _Container>
[[nodiscard]] constexpr front_insert_iterator<_Container> front_inserter(_Container& _Cont) {
    return front_insert_iterator<_Container>(_Cont);
}

 template <class _Container>
class insert_iterator { 
public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;
    using pointer           = void;
    using reference         = void;

    using container_type = _Container;

    using difference_type = ptrdiff_t;
    using _Wrapped_iter   = ranges::iterator_t<_Container>;



#line 139 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iterator"

    constexpr insert_iterator(_Container& _Cont, _Wrapped_iter _Where)
        : container(::std:: addressof(_Cont)), iter(::std:: move(_Where)) {}

    constexpr insert_iterator& operator=(const typename _Container::value_type& _Val) {
        
        iter = container->insert(iter, _Val);
        ++iter;
        return *this;
    }

    constexpr insert_iterator& operator=(typename _Container::value_type&& _Val) { 
        iter = container->insert(iter, ::std:: move(_Val));
        ++iter;
        return *this;
    }

    [[nodiscard]] constexpr insert_iterator& operator*() { 
        return *this;
    }

    constexpr insert_iterator& operator++() { 
        return *this;
    }

    constexpr insert_iterator& operator++(int) { 
        return *this;
    }

protected:
    _Container* container;
    _Wrapped_iter iter;
};







 template <class _Container>
[[nodiscard]] constexpr insert_iterator<_Container> inserter(_Container& _Cont, ::std::ranges:: iterator_t<_Container> _Where) {
    return insert_iterator<_Container>(_Cont, _Where);
}

 template <semiregular _Se>
class move_sentinel {
public:
    constexpr move_sentinel() = default;

    constexpr explicit move_sentinel(_Se _Val) noexcept(is_nothrow_move_constructible_v<_Se>) 
        : _Last{::std:: move(_Val)} {}

    template <class _Se2>
        requires convertible_to<const _Se2&, _Se>
    constexpr move_sentinel(const move_sentinel<_Se2>& _Val) noexcept(
        is_nothrow_constructible_v<_Se, const _Se2&>) 
        : _Last{_Val._Get_last()} {}

    template <class _Se2>
        requires assignable_from<_Se&, const _Se2&>
    constexpr move_sentinel& operator=(const move_sentinel<_Se2>& _Val) noexcept(
        is_nothrow_assignable_v<_Se&, const _Se2&>)   {
        _Last = _Val._Get_last();
        return *this;
    }

    [[nodiscard]] constexpr _Se base() const noexcept(is_nothrow_copy_constructible_v<_Se>)   {
        return _Last;
    }

    [[nodiscard]] constexpr const _Se& _Get_last() const noexcept {
        return _Last;
    }

    using _Prevent_inheriting_unwrap = move_sentinel;

    
    [[nodiscard]] constexpr move_sentinel<_Unwrapped_t<const _Se&>> _Unwrapped() const&
        noexcept(noexcept(move_sentinel<_Unwrapped_t<const _Se&>>{_Last._Unwrapped()}))
        requires ::std::ranges:: _Weakly_unwrappable_sentinel<_Se> {
        
        return move_sentinel<_Unwrapped_t<const _Se&>>{_Last._Unwrapped()};
    }
    
    [[nodiscard]] constexpr move_sentinel<_Unwrapped_t<_Se>> _Unwrapped() &&
        noexcept(noexcept(move_sentinel<_Unwrapped_t<_Se>>{::std:: move(_Last)._Unwrapped()}))
        requires ::std::ranges:: _Weakly_unwrappable_sentinel<_Se> {
        
        return move_sentinel<_Unwrapped_t<_Se>>{::std:: move(_Last)._Unwrapped()};
    }

private:
    _Se _Last{};
};
#line 235 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iterator"

 template <class _Ty, class _Elem = char, class _Traits = char_traits<_Elem>, class _Diff = ptrdiff_t>
class istream_iterator {
public:
    using iterator_category = input_iterator_tag;
    using value_type        = _Ty;
    using difference_type   = _Diff;
    using pointer           = const _Ty*;
    using reference         = const _Ty&;
    using char_type         = _Elem;
    using traits_type       = _Traits;
    using istream_type      = basic_istream<_Elem, _Traits>;

    static_assert(conjunction_v<is_default_constructible<_Ty>, is_copy_constructible<_Ty>, is_copy_assignable<_Ty>>,
        "istream_iterator<T> requires T to be default constructible, copy constructible, and copy assignable. "
        "(N4835 [istream.iterator]/2)");

    constexpr istream_iterator() noexcept(is_nothrow_default_constructible_v<_Ty>)   {}


    constexpr istream_iterator(default_sentinel_t) noexcept(is_nothrow_default_constructible_v<_Ty>) 
    {}
#line 258 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iterator"

    istream_iterator(istream_type& _Istr) : _Myistr(::std:: addressof(_Istr)) {
        _Getval();
    }

    [[nodiscard]] const _Ty& operator*() const noexcept   {
         ;
        return _Myval;
    }

    [[nodiscard]] const _Ty* operator->() const noexcept   {
         ;
        return ::std:: addressof(_Myval);
    }

    istream_iterator& operator++() {
        _Getval();
        return *this;
    }

    istream_iterator operator++(int) {
        istream_iterator _Tmp = *this;
        _Getval();
        return _Tmp;
    }

    [[nodiscard]] bool _Equal(const istream_iterator& _Right) const noexcept {
        return _Myistr == _Right._Myistr;
    }


    [[nodiscard]] friend bool operator==(const istream_iterator& _Left, default_sentinel_t) noexcept   {
        return !_Left._Myistr;
    }
#line 293 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iterator"

private:
    void _Getval() { 
         ;
        if (!(*_Myistr >> _Myval)) {
            _Myistr = nullptr;
        }
    }

    istream_type* _Myistr{nullptr}; 
    _Ty _Myval{}; 
};

 template <class _Ty, class _Elem, class _Traits, class _Diff>
[[nodiscard]] bool operator==(const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Left,
    const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Right) noexcept   {
    return _Left._Equal(_Right);
}







#line 319 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iterator"

 template <class _Ty, class _Elem = char, class _Traits = char_traits<_Elem>>
class ostream_iterator {
public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;

    using difference_type = ptrdiff_t;


#line 330 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iterator"
    using pointer      = void;
    using reference    = void;
    using char_type    = _Elem;
    using traits_type  = _Traits;
    using ostream_type = basic_ostream<_Elem, _Traits>;

    ostream_iterator(ostream_type& _Ostr, const _Elem* const _Delim = nullptr) noexcept  
        : _Mydelim(_Delim), _Myostr(::std:: addressof(_Ostr)) {}

    ostream_iterator& operator=(const _Ty& _Val) { 
        *_Myostr << _Val;
        if (_Mydelim) {
            *_Myostr << _Mydelim;
        }

        return *this;
    }

    [[nodiscard]] ostream_iterator& operator*() noexcept   {
        return *this;
    }

    ostream_iterator& operator++() noexcept   {
        return *this;
    }

    ostream_iterator& operator++(int) noexcept   {
        return *this;
    }

private:
    const _Elem* _Mydelim; 
    ostream_type* _Myostr; 
};

 template <class _Elem, class _Traits>
class istreambuf_iterator {
public:
    using iterator_category = input_iterator_tag;
    using value_type        = _Elem;
    using difference_type   = typename _Traits::off_type;
    using pointer           = const _Elem*;
    using reference         = _Elem;
    using char_type         = _Elem;
    using traits_type       = _Traits;
    using int_type          = typename traits_type::int_type;
    using streambuf_type    = basic_streambuf<_Elem, _Traits>;
    using istream_type      = basic_istream<_Elem, _Traits>;

    constexpr istreambuf_iterator() noexcept : _Strbuf(nullptr), _Got(true), _Val() {}

    constexpr istreambuf_iterator(default_sentinel_t) noexcept : _Strbuf(nullptr), _Got(true), _Val() {}
#line 383 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iterator"

    istreambuf_iterator(istream_type& _Istr) noexcept : _Strbuf(_Istr.rdbuf()), _Got(!_Strbuf), _Val() {}

    istreambuf_iterator(streambuf_type* _Sb) noexcept : _Strbuf(_Sb), _Got(!_Sb), _Val() {}

private:
    class _Istreambuf_proxy {
    public:
        [[nodiscard]] _Elem operator*() const noexcept(is_nothrow_copy_constructible_v<_Elem>)   {
            return _Keep;
        }

    private:
        friend istreambuf_iterator;
        _Istreambuf_proxy(streambuf_type* _Strbuf_, _Elem _Keep_) noexcept(
            is_nothrow_copy_constructible_v<_Elem>) 
            : _Strbuf(_Strbuf_), _Keep(_Keep_) {}

        streambuf_type* _Strbuf;
        _Elem _Keep;
    };

public:
    istreambuf_iterator(const _Istreambuf_proxy& _Px) noexcept : _Strbuf(_Px._Strbuf), _Got(!_Strbuf), _Val() {}

    [[nodiscard]] _Elem operator*() const {
        if (!_Got) {
            _Peek();
        }



#line 416 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iterator"

        return _Val;
    }

    istreambuf_iterator& operator++() {


#line 424 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iterator"

        _Inc();
        return *this;
    }

    _Istreambuf_proxy operator++(int) {
        if (!_Got) {
            _Peek();
        }

        _Istreambuf_proxy _Tmp{_Strbuf, _Val};
        ++*this;
        return _Tmp;
    }

    [[nodiscard]] bool equal(const istreambuf_iterator& _Right) const {
        if (!_Got) {
            _Peek();
        }

        if (!_Right._Got) {
            _Right._Peek();
        }

        return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);
    }


    [[nodiscard]] friend bool operator==(const istreambuf_iterator& _Left, default_sentinel_t) {
        if (!_Left._Got) {
            _Left._Peek();
        }

        return !_Left._Strbuf;
    }
#line 460 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iterator"

private:
    void _Inc() { 
        if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {
            _Strbuf = nullptr;
            _Got    = true;
        } else {
            _Got = false;
        }
    }

    _Elem _Peek() const { 
        int_type _Meta;
        if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {
            _Strbuf = nullptr;
        } else {
            _Val = traits_type::to_char_type(_Meta);
        }

        _Got = true;
        return _Val;
    }

    mutable streambuf_type* _Strbuf; 
    mutable bool _Got; 
    mutable _Elem _Val; 
};

 template <class _Elem, class _Traits>
[[nodiscard]] bool operator==(
    const istreambuf_iterator<_Elem, _Traits>& _Left, const istreambuf_iterator<_Elem, _Traits>& _Right) {
    return _Left.equal(_Right);
}







#line 501 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iterator"

 template <class _Elem, class _Traits>
class ostreambuf_iterator {
public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;

    using difference_type = ptrdiff_t;


#line 512 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iterator"
    using pointer        = void;
    using reference      = void;
    using char_type      = _Elem;
    using traits_type    = _Traits;
    using streambuf_type = basic_streambuf<_Elem, _Traits>;
    using ostream_type   = basic_ostream<_Elem, _Traits>;

    ostreambuf_iterator(streambuf_type* _Sb) noexcept : _Strbuf(_Sb) {}

    ostreambuf_iterator(ostream_type& _Ostr) noexcept : _Strbuf(_Ostr.rdbuf()) {}

    ostreambuf_iterator& operator=(_Elem _Right) { 
        if (!_Strbuf || traits_type::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Right))) {
            _Failed = true;
        }

        return *this;
    }

    [[nodiscard]] ostreambuf_iterator& operator*() noexcept   {
        return *this;
    }

    ostreambuf_iterator& operator++() noexcept   {
        return *this;
    }

    ostreambuf_iterator& operator++(int) noexcept   {
        return *this;
    }

    [[nodiscard]] bool failed() const noexcept {
        return _Failed;
    }

private:
    bool _Failed = false; 
    streambuf_type* _Strbuf;
};


enum class _Variantish_state : unsigned char { _Nothing, _Holds_first, _Holds_second };

struct _Variantish_empty_tag {
    explicit _Variantish_empty_tag() = default;
};

template <class _Ty1, class _Ty2>
class _Variantish {
public:
    constexpr explicit _Variantish(_Variantish_empty_tag) noexcept : _Contains{_Variantish_state::_Nothing} {}

    constexpr _Variantish() noexcept(is_nothrow_default_constructible_v<_Ty1>)
        requires default_initializable<_Ty1>
        : _First{}, _Contains{_Variantish_state::_Holds_first} {}

    template <class... _Types>
    constexpr explicit _Variantish(in_place_type_t<_Ty1>, _Types&&... _Args) noexcept(
        is_nothrow_constructible_v<_Ty1, _Types...>)
        : _First(::std:: forward<_Types>(_Args)...), _Contains{_Variantish_state::_Holds_first} {}

    template <class... _Types>
        requires _Different_from<_Ty1, _Ty2>
    constexpr explicit _Variantish(in_place_type_t<_Ty2>, _Types&&... _Args) noexcept(
        is_nothrow_constructible_v<_Ty2, _Types...>)
        : _Second(::std:: forward<_Types>(_Args)...), _Contains{_Variantish_state::_Holds_second} {}

    
    template <class _Uty1, class _Uty2>
        requires _Different_from<_Variantish<_Uty1, _Uty2>, _Variantish>
    constexpr _Variantish(const _Variantish<_Uty1, _Uty2>& _That) noexcept(
        is_nothrow_constructible_v<_Ty1, const _Uty1&> && is_nothrow_constructible_v<_Ty2, const _Uty2&>)
        : _Contains{_That._Contains} {
        
        switch (_That._Contains) {
        case _Variantish_state::_Holds_first:
            _Construct_in_place(_First, _That._First);
            break;
        case _Variantish_state::_Holds_second:
            _Construct_in_place(_Second, _That._Second);
            break;
        case _Variantish_state::_Nothing:
            break;
        }
    }

    
    constexpr _Variantish(const _Variantish&) requires is_trivially_copy_constructible_v<_Ty1>
        && is_trivially_copy_constructible_v<_Ty2> = default;
    

    constexpr _Variantish(const _Variantish& _That) noexcept(
        is_nothrow_copy_constructible_v<_Ty1>&& is_nothrow_copy_constructible_v<_Ty2>)
        : _Contains{_That._Contains} {
        switch (_Contains) {
        case _Variantish_state::_Holds_first:
            _Construct_in_place(_First, _That._First);
            break;
        case _Variantish_state::_Holds_second:
            _Construct_in_place(_Second, _That._Second);
            break;
        case _Variantish_state::_Nothing:
            break;
        }
    }

    
    constexpr _Variantish(_Variantish&&) requires is_trivially_move_constructible_v<_Ty1>
        && is_trivially_move_constructible_v<_Ty2> = default;
    

    constexpr _Variantish(_Variantish&& _That) noexcept(
        is_nothrow_move_constructible_v<_Ty1>&& is_nothrow_move_constructible_v<_Ty2>)
        : _Contains{_That._Contains} {
        switch (_Contains) {
        case _Variantish_state::_Holds_first:
            _Construct_in_place(_First, ::std:: move(_That._First));
            break;
        case _Variantish_state::_Holds_second:
            _Construct_in_place(_Second, ::std:: move(_That._Second));
            break;
        case _Variantish_state::_Nothing:
            break;
        }
    }

    constexpr ~_Variantish() {
        _Raw_clear();
    }

    
    constexpr ~_Variantish() requires is_trivially_destructible_v<_Ty1> && is_trivially_destructible_v<_Ty2> = default;

    constexpr _Variantish& operator=(const _Variantish&) requires is_trivially_destructible_v<_Ty1>
        && is_trivially_destructible_v<_Ty2>
        && is_trivially_copy_constructible_v<_Ty1>
        && is_trivially_copy_constructible_v<_Ty2>
        && is_trivially_copy_assignable_v<_Ty1>
        && is_trivially_copy_assignable_v<_Ty2> = default;
    

    constexpr _Variantish& operator=(const _Variantish& _That) noexcept(
        is_nothrow_copy_constructible_v<_Ty1>&& is_nothrow_copy_constructible_v<_Ty2>&&
            is_nothrow_copy_assignable_v<_Ty1>&& is_nothrow_copy_assignable_v<_Ty2>) {
        if (_Contains == _That._Contains) {
            switch (_Contains) {
            case _Variantish_state::_Holds_first:
                _First = _That._First;
                break;
            case _Variantish_state::_Holds_second:
                _Second = _That._Second;
                break;
            case _Variantish_state::_Nothing:
                break;
            }

            return *this;
        }

        _Clear();

        switch (_That._Contains) {
        case _Variantish_state::_Holds_first:
            _Construct_in_place(_First, _That._First);
            break;
        case _Variantish_state::_Holds_second:
            _Construct_in_place(_Second, _That._Second);
            break;
        case _Variantish_state::_Nothing:
            break;
        }

        _Contains = _That._Contains;

        return *this;
    }

    
    constexpr _Variantish& operator=(_Variantish&&) requires is_trivially_destructible_v<_Ty1>
        && is_trivially_destructible_v<_Ty2>
        && is_trivially_move_constructible_v<_Ty1>
        && is_trivially_move_constructible_v<_Ty2>
        && is_trivially_move_assignable_v<_Ty1>
        && is_trivially_move_assignable_v<_Ty2> = default;
    

    constexpr _Variantish& operator=(_Variantish&& _That) noexcept(
        is_nothrow_move_constructible_v<_Ty1>&& is_nothrow_move_constructible_v<_Ty2>&&
            is_nothrow_move_assignable_v<_Ty1>&& is_nothrow_move_assignable_v<_Ty2>) {
        if (_Contains == _That._Contains) {
            switch (_Contains) {
            case _Variantish_state::_Holds_first:
                _First = ::std:: move(_That._First);
                break;
            case _Variantish_state::_Holds_second:
                _Second = ::std:: move(_That._Second);
                break;
            case _Variantish_state::_Nothing:
                break;
            }

            return *this;
        }

        _Clear();

        switch (_That._Contains) {
        case _Variantish_state::_Holds_first:
            _Construct_in_place(_First, ::std:: move(_That._First));
            break;
        case _Variantish_state::_Holds_second:
            _Construct_in_place(_Second, ::std:: move(_That._Second));
            break;
        case _Variantish_state::_Nothing:
            break;
        }

        _Contains = _That._Contains;

        return *this;
    }

    
    template <class _Uty1, class _Uty2>
        requires _Different_from<_Variantish<_Uty1, _Uty2>, _Variantish>
    constexpr _Variantish& operator=(const _Variantish<_Uty1, _Uty2>& _That) noexcept(
        is_nothrow_constructible_v<_Ty1, const _Uty1&> && is_nothrow_constructible_v<_Ty2, const _Uty2&>
            && is_nothrow_assignable_v<_Ty1&, const _Uty1&> && is_nothrow_assignable_v<_Ty2&, const _Uty2&>) {
        
        if (_Contains == _That._Contains) {
            switch (_Contains) {
            case _Variantish_state::_Holds_first:
                _First = _That._First;
                break;
            case _Variantish_state::_Holds_second:
                _Second = _That._Second;
                break;
            case _Variantish_state::_Nothing:
                break;
            }

            return *this;
        }

        _Clear();

        switch (_That._Contains) {
        case _Variantish_state::_Holds_first:
            _Construct_in_place(_First, _That._First);
            break;
        case _Variantish_state::_Holds_second:
            _Construct_in_place(_Second, _That._Second);
            break;
        case _Variantish_state::_Nothing:
            break;
        }

        _Contains = _That._Contains;

        return *this;
    }

    
    friend constexpr void swap(_Variantish& _Left, _Variantish& _Right) noexcept(
        is_nothrow_move_constructible_v<_Ty1> && is_nothrow_move_constructible_v<_Ty2>
            && is_nothrow_swappable_v<_Ty1> && is_nothrow_swappable_v<_Ty2>)
        requires (!_Is_trivially_swappable_v<_Ty1> || !_Is_trivially_swappable_v<_Ty2>) {
        
        if (_Left._Contains == _Right._Contains) {
            switch (_Left._Contains) {
            case _Variantish_state::_Holds_first:
                ::std::ranges:: swap(_Left._First, _Right._First);
                break;
            case _Variantish_state::_Holds_second:
                ::std::ranges:: swap(_Left._Second, _Right._Second);
                break;
            case _Variantish_state::_Nothing:
                break;
            }

            return;
        }

        auto _Tmp = ::std:: move(_Left);
        _Left     = ::std:: move(_Right);
        _Right    = ::std:: move(_Tmp);
    }

    constexpr void _Raw_clear() noexcept {
        switch (_Contains) {
        case _Variantish_state::_Holds_first:
            _First.~_Ty1();
            break;
        case _Variantish_state::_Holds_second:
            _Second.~_Ty2();
            break;
        case _Variantish_state::_Nothing:
            break;
        }
    }

    constexpr void _Clear() noexcept {
        _Raw_clear();
        _Contains = _Variantish_state::_Nothing;
    }

    template <class... _Types>
    constexpr void _Emplace_first(_Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty1, _Types...>) {
        _Clear();

        _Construct_in_place(_First, ::std:: forward<_Types>(_Args)...);
        _Contains = _Variantish_state::_Holds_first;
    }

    template <class... _Types>
    constexpr void _Emplace_second(_Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty2, _Types...>) {
        _Clear();

        _Construct_in_place(_Second, ::std:: forward<_Types>(_Args)...);
        _Contains = _Variantish_state::_Holds_second;
    }

    union {
        _Ty1 _First;
        _Ty2 _Second;
    };

    _Variantish_state _Contains;
};


template <class _Iter>
concept _Use_postfix_proxy = !requires(_Iter& __it) { { *__it++ } -> _Can_reference; }
    && indirectly_readable<_Iter>
    && constructible_from<iter_value_t<_Iter>, iter_reference_t<_Iter>>
    && move_constructible<iter_value_t<_Iter>>;


 template <input_or_output_iterator _Iter, sentinel_for<_Iter> _Se>
    requires (!same_as<_Iter, _Se> && copyable<_Iter>)
class common_iterator {
private:
    struct _Proxy_base {
        iter_value_t<_Iter> _Keep;

        constexpr explicit _Proxy_base(iter_reference_t<_Iter>&& _Right) noexcept(
            is_nothrow_constructible_v<iter_value_t<_Iter>, iter_reference_t<_Iter>>) 
            : _Keep(::std:: forward<iter_reference_t<_Iter>>(_Right)) {}
    };

public:
    
    constexpr common_iterator() requires default_initializable<_Iter> = default;
    

    constexpr common_iterator(_Iter _Right) noexcept(is_nothrow_move_constructible_v<_Iter>) 
        : _Val{in_place_type<_Iter>, ::std:: move(_Right)} {}

    constexpr common_iterator(_Se _Right) noexcept(is_nothrow_move_constructible_v<_Se>) 
        : _Val{in_place_type<_Se>, ::std:: move(_Right)} {}

    constexpr explicit common_iterator(_Variantish_empty_tag _Tag) noexcept : _Val{_Tag} {}

    template <class _OIter, class _OSe>
        requires convertible_to<const _OIter&, _Iter> && convertible_to<const _OSe&, _Se>
    constexpr common_iterator(const common_iterator<_OIter, _OSe>& _Right) noexcept(
        is_nothrow_constructible_v<_Iter, const _OIter&>&& is_nothrow_constructible_v<_Se, const _OSe&>) 
        : _Val{_Right._Get_val()} {}

    
    template <class _OIter, class _OSe>
        requires convertible_to<const _OIter&, _Iter> && convertible_to<const _OSe&, _Se>
            && assignable_from<_Iter&, const _OIter&> && assignable_from<_Se&, const _OSe&>
    constexpr common_iterator& operator=(const common_iterator<_OIter, _OSe>& _Right) noexcept(
        is_nothrow_constructible_v<_Iter, const _OIter&> && is_nothrow_constructible_v<_Se, const _OSe&>
            && is_nothrow_assignable_v<_Iter&, const _OIter&>
            && is_nothrow_assignable_v<_Se&, const _OSe&>)   {
        
        _Val = _Right._Get_val();
        return *this;
    }

    [[nodiscard]] constexpr decltype(auto) operator*() {



#line 899 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iterator"
        return *_Val._First;
    }

    [[nodiscard]] constexpr decltype(auto) operator*() const
        requires _Dereferenceable<const _Iter>
    {



#line 909 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iterator"
        return *_Val._First;
    }

    
    [[nodiscard]] constexpr auto operator->() const
        requires indirectly_readable<const _Iter>
            && (_Has_member_arrow<const _Iter&> || is_reference_v<iter_reference_t<_Iter>>
                || constructible_from<iter_value_t<_Iter>, iter_reference_t<_Iter>>) {
        



#line 922 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iterator"
        if constexpr (_Has_member_arrow<const _Iter&> || is_pointer_v<_Iter>) {
            return _Val._First;
        } else if constexpr (is_reference_v<iter_reference_t<_Iter>>) {
            auto&& _Tmp = *_Val._First;
            return ::std:: addressof(_Tmp);
        } else {
            class _Arrow_proxy : private _Proxy_base {
            public:
                friend common_iterator;

                using _Proxy_base::_Proxy_base;

                [[nodiscard]] constexpr const iter_value_t<_Iter>* operator->() const noexcept {
                    return ::std:: addressof(this->_Keep);
                }
            };

            return _Arrow_proxy{*_Val._First};
        }
    }

    constexpr common_iterator& operator++() {



#line 948 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iterator"
        ++_Val._First;
        return *this;
    }

    constexpr decltype(auto) operator++(int) {



#line 957 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iterator"
        if constexpr (forward_iterator<_Iter>) {
            common_iterator _Tmp = *this;
            ++_Val._First;
            return _Tmp;
        } else if constexpr (_Use_postfix_proxy<_Iter>) {
            class _Postfix_proxy : private _Proxy_base {
            public:
                friend common_iterator;

                using _Proxy_base::_Proxy_base;

                [[nodiscard]] constexpr const iter_value_t<_Iter>& operator*() const noexcept {
                    return this->_Keep;
                }
            };

            _Postfix_proxy _Tmp{*_Val._First};
            ++_Val._First;
            return _Tmp;
        } else {
            return _Val._First++;
        }
    }

    template <class _OIter, sentinel_for<_Iter> _OSe>
        requires sentinel_for<_Se, _OIter>
    [[nodiscard]] friend constexpr bool operator==(
        const common_iterator& _Left, const common_iterator<_OIter, _OSe>& _Right) {
        auto& _Right_val = _Right._Get_val();




#line 991 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iterator"

        if (_Left._Val._Contains == _Variantish_state::_Holds_first) {
            if (_Right_val._Contains == _Variantish_state::_Holds_first) {
                if constexpr (equality_comparable_with<_Iter, _OIter>) {
                    return _Left._Val._First == _Right_val._First;
                } else {
                    return true;
                }
            } else {
                return _Left._Val._First == _Right_val._Second;
            }
        } else {
            if (_Right_val._Contains == _Variantish_state::_Holds_first) {
                return _Left._Val._Second == _Right_val._First;
            } else {
                return true;
            }
        }
    }

    template <sized_sentinel_for<_Iter> _OIter, sized_sentinel_for<_Iter> _OSe>
        requires sized_sentinel_for<_Se, _OIter>
    [[nodiscard]] friend constexpr iter_difference_t<_OIter> operator-(
        const common_iterator& _Left, const common_iterator<_OIter, _OSe>& _Right) {
        auto& _Right_val = _Right._Get_val();




#line 1021 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iterator"

        if (_Left._Val._Contains == _Variantish_state::_Holds_first) {
            if (_Right_val._Contains == _Variantish_state::_Holds_first) {
                return _Left._Val._First - _Right_val._First;
            } else {
                return _Left._Val._First - _Right_val._Second;
            }
        } else {
            if (_Right_val._Contains == _Variantish_state::_Holds_first) {
                return _Left._Val._Second - _Right_val._First;
            } else {
                return 0;
            }
        }
    }

    [[nodiscard]] friend constexpr iter_rvalue_reference_t<_Iter> iter_move(const common_iterator& _Right) noexcept(
        noexcept(::std::ranges:: iter_move(_Right._Val._First)))
        requires input_iterator<_Iter>
    {



#line 1045 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iterator"
        return ::std::ranges:: iter_move(_Right._Val._First);
    }

    template <indirectly_swappable<_Iter> _OIter, class _OSe>
    friend constexpr void iter_swap(const common_iterator& _Left, const common_iterator<_OIter, _OSe>& _Right) noexcept(
        noexcept(::std::ranges:: iter_swap(_Left._Val._First, _Right._Get_val()._First))) {
        auto& _Right_val = _Right._Get_val();




#line 1057 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iterator"
        return ::std::ranges:: iter_swap(_Left._Val._First, _Right_val._First);
    }

    [[nodiscard]] constexpr _Variantish<_Iter, _Se>& _Get_val() noexcept {
        return _Val;
    }
    [[nodiscard]] constexpr const _Variantish<_Iter, _Se>& _Get_val() const noexcept {
        return _Val;
    }

private:
    _Variantish<_Iter, _Se> _Val;
};

template <class _Iter, class _Se>
struct incrementable_traits<common_iterator<_Iter, _Se>> {
    using difference_type = iter_difference_t<_Iter>;
};

template <class, class>
struct _Common_iterator_pointer_type {
    using pointer = void;
};

template <class _Iter, class _Se>
    requires _Has_member_arrow<const common_iterator<_Iter, _Se>&>
struct _Common_iterator_pointer_type<_Iter, _Se> {
    using pointer = decltype(::std:: declval<const common_iterator<_Iter, _Se>&>().operator->());
};

template <class _Iter>
concept _Has_forward_category = requires {
                                    typename _Iter_cat_t<_Iter>;
                                    requires derived_from<_Iter_cat_t<_Iter>, forward_iterator_tag>;
                                };

template <input_iterator _Iter, class _Se>
struct iterator_traits<common_iterator<_Iter, _Se>> {
    using iterator_concept  = conditional_t<forward_iterator<_Iter>, forward_iterator_tag, input_iterator_tag>;
    using iterator_category = conditional_t<_Has_forward_category<_Iter>, forward_iterator_tag, input_iterator_tag>;
    using value_type        = iter_value_t<_Iter>;
    using difference_type   = iter_difference_t<_Iter>;
    using pointer           = typename _Common_iterator_pointer_type<_Iter, _Se>::pointer;
    using reference         = iter_reference_t<_Iter>;
};

template <class _Iter>
struct _Counted_iterator_value_type_base {};

template <indirectly_readable _Iter>
struct _Counted_iterator_value_type_base<_Iter> {
    using value_type = iter_value_t<_Iter>;
};

template <class _Iter>
struct _Counted_iterator_category_base : _Counted_iterator_value_type_base<_Iter> {};

template <_Has_member_iterator_category _Iter>
struct _Counted_iterator_category_base<_Iter> : _Counted_iterator_value_type_base<_Iter> {
    using iterator_category = typename _Iter::iterator_category;
};

template <class _Iter>
struct _Counted_iterator_concept_base : _Counted_iterator_category_base<_Iter> {};

template <_Has_member_iterator_concept _Iter>
struct _Counted_iterator_concept_base<_Iter> : _Counted_iterator_category_base<_Iter> {
    using iterator_concept = typename _Iter::iterator_concept;
};

 template <input_or_output_iterator _Iter>
class counted_iterator : public _Counted_iterator_concept_base<_Iter> {
public:
    using iterator_type   = _Iter;
    using difference_type = iter_difference_t<_Iter>;

    
    
    constexpr counted_iterator() requires default_initializable<_Iter> = default;
    

    constexpr counted_iterator(_Iter _Right, const iter_difference_t<_Iter> _Diff) noexcept(
        is_nothrow_move_constructible_v<_Iter>) 
        : _Current(::std:: move(_Right)), _Length(_Diff) {


#line 1144 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iterator"
    }

    template <class _Other>
        requires convertible_to<const _Other&, _Iter>
    constexpr counted_iterator(const counted_iterator<_Other>& _Right) noexcept(
        is_nothrow_constructible_v<_Iter, const _Other&>) 
        : _Current(_Right.base()), _Length(_Right.count()) {}

    template <class _Other>
        requires assignable_from<_Iter&, const _Other&>
    constexpr counted_iterator& operator=(const counted_iterator<_Other>& _Right) noexcept(
        is_nothrow_assignable_v<_Iter&, const _Other&>)   {
        _Current = _Right.base();
        _Length  = _Right.count();
        return *this;
    }

    
    [[nodiscard]] constexpr const _Iter& base() const& noexcept {
        return _Current;
    }

    [[nodiscard]] constexpr _Iter base() && noexcept(is_nothrow_move_constructible_v<_Iter>)   {
        return ::std:: move(_Current);
    }

    [[nodiscard]] constexpr iter_difference_t<_Iter> count() const noexcept {
        return _Length;
    }

    
    [[nodiscard]] constexpr decltype(auto) operator*() noexcept(noexcept(*_Current))   {


#line 1179 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iterator"
        return *_Current;
    }

    [[nodiscard]] constexpr decltype(auto) operator*() const noexcept(noexcept(*_Current))  
        requires _Dereferenceable<const _Iter>
    {


#line 1188 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iterator"
        return *_Current;
    }

    [[nodiscard]] constexpr auto operator->() const noexcept
        requires contiguous_iterator<_Iter>
    {
        return ::std:: to_address(_Current);
    }

    [[nodiscard]] constexpr decltype(auto) operator[](const iter_difference_t<_Iter> _Diff) const
        requires random_access_iterator<_Iter>
    {


#line 1203 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iterator"
        return _Current[_Diff];
    }

    
    constexpr counted_iterator& operator++() {


#line 1211 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iterator"
        ++_Current;
        --_Length;
        return *this;
    }

    constexpr decltype(auto) operator++(int) {


#line 1220 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iterator"
        --_Length;
        try {
        return _Current++;

        } catch (...) {
        ++_Length;

        throw ;
        }
    }

    constexpr counted_iterator operator++(int)
        requires forward_iterator<_Iter>
    {


#line 1237 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iterator"
        counted_iterator _Tmp = *this;
        ++_Current;
        --_Length;
        return _Tmp;
    }

    constexpr counted_iterator& operator--()
        requires bidirectional_iterator<_Iter>
    {
        --_Current;
        ++_Length;
        return *this;
    }

    constexpr counted_iterator operator--(int)
        requires bidirectional_iterator<_Iter>
    {
        counted_iterator _Tmp = *this;
        --_Current;
        ++_Length;
        return _Tmp;
    }

    [[nodiscard]] constexpr counted_iterator operator+(const iter_difference_t<_Iter> _Diff) const
        requires random_access_iterator<_Iter>
    {
        return counted_iterator{_Current + _Diff, static_cast<iter_difference_t<_Iter>>(_Length - _Diff)};
    }

    [[nodiscard]] friend constexpr counted_iterator operator+(
        const iter_difference_t<_Iter> _Diff, const counted_iterator& _Right)
        requires random_access_iterator<_Iter>
    {
        return counted_iterator{_Right._Current + _Diff, static_cast<iter_difference_t<_Iter>>(_Right._Length - _Diff)};
    }

    constexpr counted_iterator& operator+=(const iter_difference_t<_Iter> _Diff)
        requires random_access_iterator<_Iter>
    {


#line 1279 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iterator"
        _Current += _Diff;
        _Length -= _Diff;
        return *this;
    }

    [[nodiscard]] constexpr counted_iterator operator-(const iter_difference_t<_Iter> _Diff) const
        requires random_access_iterator<_Iter>
    {
        return counted_iterator{_Current - _Diff, static_cast<iter_difference_t<_Iter>>(_Length + _Diff)};
    }

    template <common_with<_Iter> _Other>
    [[nodiscard]] friend constexpr iter_difference_t<_Other> operator-(
        const counted_iterator& _Left, const counted_iterator<_Other>& _Right) noexcept   {


#line 1296 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iterator"
        return _Right.count() - _Left._Length;
    }

    [[nodiscard]] friend constexpr iter_difference_t<_Iter> operator-(
        const counted_iterator& _Left, default_sentinel_t) noexcept   {
        return -_Left._Length;
    }

    [[nodiscard]] friend constexpr iter_difference_t<_Iter> operator-(
        default_sentinel_t, const counted_iterator& _Right) noexcept   {
        return _Right._Length;
    }

    constexpr counted_iterator& operator-=(const iter_difference_t<_Iter> _Diff)
        requires random_access_iterator<_Iter>
    {


#line 1315 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iterator"
        _Current -= _Diff;
        _Length += _Diff;
        return *this;
    }

    
    template <common_with<_Iter> _Other>
    [[nodiscard]] friend constexpr bool operator==(
        const counted_iterator& _Left, const counted_iterator<_Other>& _Right) noexcept   {


#line 1327 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iterator"
        return _Left._Length == _Right.count();
    }

    [[nodiscard]] friend constexpr bool operator==(const counted_iterator& _Left, default_sentinel_t) noexcept
      {
        return _Left._Length == 0;
    }

    template <common_with<_Iter> _Other>
    [[nodiscard]] friend constexpr strong_ordering operator<=>(
        const counted_iterator& _Left, const counted_iterator<_Other>& _Right) noexcept   {


#line 1341 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iterator"
        return _Right.count() <=> _Left._Length;
    }

    
    [[nodiscard]] friend constexpr iter_rvalue_reference_t<_Iter> iter_move(const counted_iterator& _Right) noexcept(
        noexcept(::std::ranges:: iter_move(_Right._Current)))
        requires input_iterator<_Iter>
    {
        return ::std::ranges:: iter_move(_Right._Current);
    }

    template <indirectly_swappable<_Iter> _Other>
    friend constexpr void iter_swap(const counted_iterator& _Left, const counted_iterator<_Other>& _Right) noexcept(
        noexcept(::std::ranges:: iter_swap(_Left._Current, _Right.base()))) {
        ::std::ranges:: iter_swap(_Left._Current, _Right.base());
    }































#line 1389 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iterator"

    template <common_with<_Iter> _Other>
    friend constexpr void _Verify_range(const counted_iterator& _Left, const counted_iterator<_Other>& _Right) {
        if constexpr (_Range_verifiable_v<_Iter, _Other>) {
            _Verify_range(_Left._Current, _Right.base());
        }


#line 1398 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iterator"
    }

    constexpr void _Verify_offset(const iter_difference_t<_Iter> _Off) const {


#line 1404 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iterator"
        if constexpr (_Offset_verifiable_v<_Iter>) {
            _Current._Verify_offset(_Off);
        }
    }

    using _Prevent_inheriting_unwrap = counted_iterator;

    [[nodiscard]] constexpr counted_iterator<_Unwrapped_t<const _Iter&>> _Unwrapped() const& noexcept(
        noexcept(counted_iterator<_Unwrapped_t<const _Iter&>>{_Current._Unwrapped(), _Length}))
        requires _Unwrappable_v<const _Iter&>
    {
        return counted_iterator<_Unwrapped_t<const _Iter&>>{_Current._Unwrapped(), _Length};
    }

    [[nodiscard]] constexpr counted_iterator<_Unwrapped_t<_Iter>> _Unwrapped() && noexcept(
        noexcept(counted_iterator<_Unwrapped_t<_Iter>>{::std:: move(_Current)._Unwrapped(), _Length}))
        requires _Unwrappable_v<_Iter>
    {
        return counted_iterator<_Unwrapped_t<_Iter>>{::std:: move(_Current)._Unwrapped(), _Length};
    }

    static constexpr bool _Unwrap_when_unverified = _Do_unwrap_when_unverified_v<_Iter>;

    template <class _Other>
        requires _Wrapped_seekable_v<_Iter, const _Other&>
    constexpr void _Seek_to(const counted_iterator<_Other>& _It) {
        _Current._Seek_to(_It.base());
        _Length = _It.count();
    }

    template <class _Other>
        requires _Wrapped_seekable_v<_Iter, _Other>
    constexpr void _Seek_to(counted_iterator<_Other>&& _It) {
        _Current._Seek_to(::std:: move(_It).base());
        _Length = _It.count();
    }

private:
    _Iter _Current{};
    iter_difference_t<_Iter> _Length = 0;
};

template <input_iterator _Iter>
    requires (!_Is_from_primary<iterator_traits<_Iter>>)
struct iterator_traits<counted_iterator<_Iter>> : iterator_traits<_Iter> {
    using pointer = conditional_t<contiguous_iterator<_Iter>, add_pointer_t<iter_reference_t<_Iter>>, void>;
};
#line 1452 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iterator"

}

namespace stdext {
using ::std:: iterator_traits;
using ::std:: size_t;

template <class _Ptr>
class checked_array_iterator { 
    static_assert(::std:: is_pointer_v<_Ptr>, "checked_array_iterator requires pointers");

public:
    using iterator_category = typename iterator_traits<_Ptr>::iterator_category;
    using value_type        = typename iterator_traits<_Ptr>::value_type;
    using difference_type   = typename iterator_traits<_Ptr>::difference_type;
    using pointer           = typename iterator_traits<_Ptr>::pointer;
    using reference         = typename iterator_traits<_Ptr>::reference;

    constexpr checked_array_iterator() noexcept : _Myarray(nullptr), _Mysize(0), _Myindex(0) {}

    constexpr checked_array_iterator(const _Ptr _Array, const size_t _Size, const size_t _Index = 0) noexcept
        : _Myarray(_Array), _Mysize(_Size), _Myindex(_Index) {
        do { if (_Index <= _Size) { } else { do {; ::_invalid_parameter_noinfo_noreturn(); } while (false); }; } while (false) ;
    }

    [[nodiscard]] constexpr _Ptr base() const noexcept {
        return _Myarray + _Myindex;
    }

    [[nodiscard]] constexpr reference operator*() const noexcept {
        return *operator->();
    }

    [[nodiscard]] constexpr pointer operator->() const noexcept {
        do { if (_Myarray) { } else { do {; ::_invalid_parameter_noinfo_noreturn(); } while (false); }; } while (false) ;
        do { if (_Myindex < _Mysize) { } else { do {; ::_invalid_parameter_noinfo_noreturn(); } while (false); }; } while (false) ;
        return _Myarray + _Myindex;
    }

    constexpr checked_array_iterator& operator++() noexcept {
        do { if (_Myarray) { } else { do {; ::_invalid_parameter_noinfo_noreturn(); } while (false); }; } while (false) ;
        do { if (_Myindex < _Mysize) { } else { do {; ::_invalid_parameter_noinfo_noreturn(); } while (false); }; } while (false) ;
        ++_Myindex;
        return *this;
    }

    constexpr checked_array_iterator operator++(int) noexcept {
        checked_array_iterator _Tmp = *this;
        ++*this;
        return _Tmp;
    }

    constexpr checked_array_iterator& operator--() noexcept {
        do { if (_Myarray) { } else { do {; ::_invalid_parameter_noinfo_noreturn(); } while (false); }; } while (false) ;
        do { if (_Myindex != 0) { } else { do {; ::_invalid_parameter_noinfo_noreturn(); } while (false); }; } while (false) ;
        --_Myindex;
        return *this;
    }

    constexpr checked_array_iterator operator--(int) noexcept {
        checked_array_iterator _Tmp = *this;
        --*this;
        return _Tmp;
    }

    constexpr checked_array_iterator& operator+=(const difference_type _Off) noexcept {
        if (_Off != 0) {
            do { if (_Myarray) { } else { do {; ::_invalid_parameter_noinfo_noreturn(); } while (false); }; } while (false) ;
        }

        if (_Off < 0) {
            do { if (_Myindex >= size_t{0} - static_cast<size_t>(_Off)) { } else { do {; ::_invalid_parameter_noinfo_noreturn(); } while (false); }; } while (false)
;
        }

        if (_Off > 0) {
            do { if (_Mysize - _Myindex >= static_cast<size_t>(_Off)) { } else { do {; ::_invalid_parameter_noinfo_noreturn(); } while (false); }; } while (false)
;
        }

        _Myindex += _Off;
        return *this;
    }

    [[nodiscard]] constexpr checked_array_iterator operator+(const difference_type _Off) const noexcept {
        checked_array_iterator _Tmp = *this;
        _Tmp += _Off;
        return _Tmp;
    }

    [[nodiscard]] friend constexpr checked_array_iterator operator+(
        const difference_type _Off, const checked_array_iterator<_Ptr>& _Next) noexcept {
        return _Next + _Off;
    }

    constexpr checked_array_iterator& operator-=(const difference_type _Off) noexcept {
        if (_Off != 0) {
            do { if (_Myarray) { } else { do {; ::_invalid_parameter_noinfo_noreturn(); } while (false); }; } while (false) ;
        }

        if (_Off > 0) {
            do { if (_Myindex >= static_cast<size_t>(_Off)) { } else { do {; ::_invalid_parameter_noinfo_noreturn(); } while (false); }; } while (false) ;
        }

        if (_Off < 0) {
            do { if (_Mysize - _Myindex >= size_t{0} - static_cast<size_t>(_Off)) { } else { do {; ::_invalid_parameter_noinfo_noreturn(); } while (false); }; } while (false)
;
        }

        _Myindex -= _Off;
        return *this;
    }

    [[nodiscard]] constexpr checked_array_iterator operator-(const difference_type _Off) const noexcept {
        checked_array_iterator _Tmp = *this;
        _Tmp -= _Off;
        return _Tmp;
    }

    [[nodiscard]] constexpr difference_type operator-(const checked_array_iterator& _Right) const noexcept {
        do { if (_Myarray == _Right._Myarray && _Mysize == _Right._Mysize) { } else { do {; ::_invalid_parameter_noinfo_noreturn(); } while (false); }; } while (false)
;
        return static_cast<difference_type>(_Myindex - _Right._Myindex);
    }

    [[nodiscard]] constexpr reference operator[](const difference_type _Off) const noexcept {
        return *(*this + _Off);
    }

    [[nodiscard]] constexpr bool operator==(const checked_array_iterator& _Right) const noexcept {
        do { if (_Myarray == _Right._Myarray && _Mysize == _Right._Mysize) { } else { do {; ::_invalid_parameter_noinfo_noreturn(); } while (false); }; } while (false)
;
        return _Myindex == _Right._Myindex;
    }


    [[nodiscard]] constexpr ::std:: strong_ordering operator<=>(const checked_array_iterator& _Right) const noexcept {
        do { if (_Myarray == _Right._Myarray && _Mysize == _Right._Mysize) { } else { do {; ::_invalid_parameter_noinfo_noreturn(); } while (false); }; } while (false)
;
        return _Myindex <=> _Right._Myindex;
    }






















#line 1616 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iterator"

    friend constexpr void _Verify_range(
        const checked_array_iterator& _First, const checked_array_iterator& _Last) noexcept {
        do { if (_First._Myarray == _Last._Myarray && _First._Mysize == _Last._Mysize) { } else { do {; ::_invalid_parameter_noinfo_noreturn(); } while (false); }; } while (false)
;
        do { if (_First._Myindex <= _Last._Myindex) { } else { do {; ::_invalid_parameter_noinfo_noreturn(); } while (false); }; } while (false) ;
    }

    constexpr void _Verify_offset(const difference_type _Off) const noexcept {
        if (_Off < 0) {
            do { if (_Myindex >= size_t{0} - static_cast<size_t>(_Off)) { } else { do {; ::_invalid_parameter_noinfo_noreturn(); } while (false); }; } while (false)
;
        }

        if (_Off > 0) {
            do { if (_Mysize - _Myindex >= static_cast<size_t>(_Off)) { } else { do {; ::_invalid_parameter_noinfo_noreturn(); } while (false); }; } while (false)
;
        }
    }

    using _Prevent_inheriting_unwrap = checked_array_iterator;

    [[nodiscard]] constexpr _Ptr _Unwrapped() const noexcept {
        return _Myarray + _Myindex;
    }

    constexpr void _Seek_to(_Ptr _It) noexcept {
        _Myindex = static_cast<size_t>(_It - _Myarray);
    }

private:
    _Ptr _Myarray; 
    size_t _Mysize; 
    size_t _Myindex; 
};

template <class _Ptr>
[[nodiscard]] constexpr checked_array_iterator<_Ptr> make_checked_array_iterator(
    const _Ptr _Array, const size_t _Size, const size_t _Index = 0) {
    return checked_array_iterator<_Ptr>(_Array, _Size, _Index);
}

template <class _Ptr>
class unchecked_array_iterator { 
    static_assert(::std:: is_pointer_v<_Ptr>, "unchecked_array_iterator requires pointers");

public:
    using iterator_category = typename iterator_traits<_Ptr>::iterator_category;
    using value_type        = typename iterator_traits<_Ptr>::value_type;
    using difference_type   = typename iterator_traits<_Ptr>::difference_type;
    using pointer           = typename iterator_traits<_Ptr>::pointer;
    using reference         = typename iterator_traits<_Ptr>::reference;

    constexpr unchecked_array_iterator() noexcept : _Myptr(nullptr) {}

    constexpr explicit unchecked_array_iterator(const _Ptr _Src) noexcept : _Myptr(_Src) {}

    [[nodiscard]] constexpr _Ptr base() const noexcept {
        return _Myptr;
    }

    [[nodiscard]] constexpr reference operator*() const noexcept {
        return *_Myptr;
    }

    [[nodiscard]] constexpr pointer operator->() const noexcept {
        return _Myptr;
    }

    constexpr unchecked_array_iterator& operator++() noexcept {
        ++_Myptr;
        return *this;
    }

    constexpr unchecked_array_iterator operator++(int) noexcept {
        unchecked_array_iterator _Tmp = *this;
        ++_Myptr;
        return _Tmp;
    }

    constexpr unchecked_array_iterator& operator--() noexcept {
        --_Myptr;
        return *this;
    }

    constexpr unchecked_array_iterator operator--(int) noexcept {
        unchecked_array_iterator _Tmp = *this;
        --_Myptr;
        return _Tmp;
    }

    constexpr unchecked_array_iterator& operator+=(const difference_type _Off) noexcept {
        _Myptr += _Off;
        return *this;
    }

    [[nodiscard]] constexpr unchecked_array_iterator operator+(const difference_type _Off) const noexcept {
        unchecked_array_iterator _Tmp = *this;
        _Tmp += _Off;
        return _Tmp;
    }

    [[nodiscard]] friend constexpr unchecked_array_iterator operator+(
        const difference_type _Off, const unchecked_array_iterator& _Next) noexcept {
        return _Next + _Off;
    }

    constexpr unchecked_array_iterator& operator-=(const difference_type _Off) noexcept {
        return *this += -_Off;
    }

    [[nodiscard]] constexpr unchecked_array_iterator operator-(const difference_type _Off) const noexcept {
        unchecked_array_iterator _Tmp = *this;
        _Tmp -= _Off;
        return _Tmp;
    }

    [[nodiscard]] constexpr difference_type operator-(const unchecked_array_iterator& _Right) const noexcept {
        return _Myptr - _Right._Myptr;
    }

    [[nodiscard]] constexpr reference operator[](const difference_type _Off) const noexcept {
        return *(*this + _Off);
    }

    [[nodiscard]] constexpr bool operator==(const unchecked_array_iterator& _Right) const noexcept {
        return _Myptr == _Right._Myptr;
    }


    [[nodiscard]] constexpr ::std:: strong_ordering operator<=>(const unchecked_array_iterator& _Right) const noexcept {
        return _Myptr <=> _Right._Myptr;
    }




















#line 1770 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iterator"






#line 1777 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iterator"

    using _Prevent_inheriting_unwrap = unchecked_array_iterator;

    static constexpr bool _Unwrap_when_unverified = true;

    [[nodiscard]] constexpr _Ptr _Unwrapped() const noexcept {
        return _Myptr;
    }

    constexpr void _Seek_to(_Ptr _It) noexcept {
        _Myptr = _It;
    }

private:
    _Ptr _Myptr; 
};

template <class _Ptr>
[[nodiscard]] unchecked_array_iterator<_Ptr> make_unchecked_array_iterator(const _Ptr _It) noexcept {
    return unchecked_array_iterator<_Ptr>(_It);
}
}



#pragma warning(pop)
#pragma pack(pop)
#line 1805 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iterator"
#line 1806 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iterator"
#pragma external_header(pop)
#line 16 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xlocnum"
#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\streambuf"





#pragma once




#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xiosbase"





#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\share.h"







#pragma once




#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\share.h"
#pragma external_header(pop)
#line 12 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xiosbase"
#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\system_error"





#pragma once




#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\__msvc_system_error_abi.hpp"





#pragma once






#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )








#line 25 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\__msvc_system_error_abi.hpp"

extern "C" {
[[nodiscard]] size_t __stdcall __std_get_string_size_without_trailing_whitespace(
    const char* _Str, size_t _Size) noexcept;

[[nodiscard]] size_t __stdcall __std_system_error_allocate_message(
    unsigned long _Message_id, char** _Ptr_str) noexcept;
void __stdcall __std_system_error_deallocate_message(char* _Str) noexcept;
}



#pragma warning(pop)
#pragma pack(pop)

#line 41 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\__msvc_system_error_abi.hpp"
#line 42 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\__msvc_system_error_abi.hpp"
#pragma external_header(pop)
#line 12 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\system_error"
#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cerrno"





#pragma once







#line 15 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cerrno"
#line 16 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cerrno"
#pragma external_header(pop)
#line 13 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\system_error"

#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\stdexcept"





#pragma once




#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\exception"





#pragma once







#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




namespace std {




#line 27 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\exception"
 extern "C++"  int __cdecl uncaught_exceptions() noexcept;

}



#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\malloc.h"







#pragma once






#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {





    


#line 29 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\malloc.h"













typedef struct _heapinfo
{
    int* _pentry;
    size_t _size;
    int _useflag;
} _HEAPINFO;






 
void* __cdecl _alloca( size_t _Size);





    __declspec(dllimport) intptr_t __cdecl _get_heap_handle(void);

    
    __declspec(dllimport) int __cdecl _heapmin(void);

    
        __declspec(dllimport) int __cdecl _heapwalk( _HEAPINFO* _EntryInfo);
    #line 69 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\malloc.h"

    
         __declspec(dllimport) int __cdecl _heapchk(void);
    #line 73 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\malloc.h"

    __declspec(dllimport) int __cdecl _resetstkoflw(void);

    
    
    

    
        
    

#line 85 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\malloc.h"

    static_assert((sizeof(unsigned int) <= 16), "sizeof(unsigned int) <= _ALLOCA_S_MARKER_SIZE") ;


    #pragma warning(push)
    #pragma warning(disable: 6540) 
                                   

    __inline void* _MarkAllocaS(  void* _Ptr, unsigned int _Marker)
    {
        if (_Ptr)
        {
            *((unsigned int*)_Ptr) = _Marker;
            _Ptr = (char*)_Ptr + 16 ;
        }
        return _Ptr;
    }

    __inline size_t _MallocaComputeSize(size_t _Size)
    {
        size_t _MarkedSize = _Size + 16 ;
        return _MarkedSize > _Size ? _MarkedSize : 0;
    }

    #pragma warning(pop)

#line 112 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\malloc.h"

















    
    







#line 139 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\malloc.h"




#line 144 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\malloc.h"
#line 145 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\malloc.h"

    

    #pragma warning(push)
    #pragma warning(disable: 6014) 
    __inline void __cdecl _freea(  void* _Memory)
    {
        unsigned int _Marker;
        if (_Memory)
        {
            _Memory = (char*)_Memory - 16 ;
            _Marker = *(unsigned int*)_Memory;
            if (_Marker == 0xDDDD )
            {
                free(_Memory);
            }
            
            else if (_Marker != 0xCCCC )
            {
                ((void)0) ;
            }
            #line 167 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\malloc.h"
        }
    }
    #pragma warning(pop)

#line 172 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\malloc.h"




    
#line 178 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\malloc.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#line 185 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\malloc.h"
#pragma external_header(pop)
#line 34 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\exception"
#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime_exception.h"







#pragma once

#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\eh.h"







#pragma once



#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_terminate.h"







#pragma once



#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )




__pragma(pack(push, 8)) extern "C" {



typedef void (__cdecl * terminate_handler )(void);
typedef void (__cdecl * terminate_function)(void);








    __declspec(dllimport) __declspec(noreturn) void __cdecl abort();
    __declspec(dllimport) __declspec(noreturn) void __cdecl terminate() throw();

    

        __declspec(dllimport) terminate_handler __cdecl set_terminate(
             terminate_handler _NewTerminateHandler
            ) throw();

        __declspec(dllimport) terminate_handler __cdecl _get_terminate();

    #line 44 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_terminate.h"

#line 46 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_terminate.h"

} __pragma(pack(pop))

#line 50 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_terminate.h"

#pragma warning(pop) 
#pragma external_header(pop)
#line 13 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\eh.h"



#pragma warning(push)
#pragma warning(disable: 4514 4820 )

__pragma(pack(push, 8)) extern "C" {


    
    
    typedef void (__cdecl * unexpected_handler )(void);
    typedef void (__cdecl * unexpected_function)(void);

    




    
         __declspec(noreturn) void __cdecl unexpected() noexcept(false);

        
             unexpected_handler __cdecl set_unexpected(
                 unexpected_handler _NewUnexpectedHandler
                ) noexcept;
             unexpected_handler __cdecl _get_unexpected() noexcept;
        #line 41 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\eh.h"
    #line 42 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\eh.h"
#line 43 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\eh.h"

struct _EXCEPTION_POINTERS;


    
        typedef void (__cdecl* _se_translator_function)(unsigned int, struct _EXCEPTION_POINTERS*);

         _se_translator_function __cdecl _set_se_translator(
             _se_translator_function _NewSETranslator
            );
    #line 54 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\eh.h"

    extern "C++" { 
        class type_info;
    } 

     int __cdecl _is_exception_typeof(
         type_info const&     _Type,
         _EXCEPTION_POINTERS* _ExceptionPtr
        );

     bool __cdecl __uncaught_exception();
     int  __cdecl __uncaught_exceptions();
#line 67 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\eh.h"

} __pragma(pack(pop))

#pragma warning(pop) 

#line 73 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\eh.h"
#pragma external_header(pop)
#line 11 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime_exception.h"







#pragma warning(push)
#pragma warning(disable: 4514 4820 )

#pragma pack(push, 8 )

__pragma(pack(push, 8)) extern "C" {

struct __std_exception_data
{
    char const* _What;
    bool        _DoFree;
};

 void __cdecl __std_exception_copy(
      __std_exception_data const* _From,
     __std_exception_data*       _To
    );

 void __cdecl __std_exception_destroy(
     __std_exception_data* _Data
    );

} __pragma(pack(pop))



namespace std {

#pragma warning(push)
#pragma warning(disable: 4577) 
class exception
{
public:

    exception() noexcept
        : _Data()
    {
    }

    explicit exception(char const* const _Message) noexcept
        : _Data()
    {
        __std_exception_data _InitData = { _Message, true };
        __std_exception_copy(&_InitData, &_Data);
    }

    exception(char const* const _Message, int) noexcept
        : _Data()
    {
        _Data._What = _Message;
    }

    exception(exception const& _Other) noexcept
        : _Data()
    {
        __std_exception_copy(&_Other._Data, &_Data);
    }

    exception& operator=(exception const& _Other) noexcept
    {
        if (this == &_Other)
        {
            return *this;
        }

        __std_exception_destroy(&_Data);
        __std_exception_copy(&_Other._Data, &_Data);
        return *this;
    }

    virtual ~exception() noexcept
    {
        __std_exception_destroy(&_Data);
    }

    [[nodiscard]] virtual char const* what() const
    {
        return _Data._What ? _Data._What : "Unknown exception";
    }

private:

    __std_exception_data _Data;
};

class bad_exception
    : public exception
{
public:

    bad_exception() noexcept
        : exception("bad exception", 1)
    {
    }
};

class bad_alloc
    : public exception
{
public:

    bad_alloc() noexcept
        : exception("bad allocation", 1)
    {
    }

private:

    friend class bad_array_new_length;

    bad_alloc(char const* const _Message) noexcept
        : exception(_Message, 1)
    {
    }
};

class bad_array_new_length
    : public bad_alloc
{
public:

    bad_array_new_length() noexcept
        : bad_alloc("bad array new length")
    {
    }
};

#pragma warning(pop)

} 

#pragma pack(pop)

#pragma warning(pop) 
#line 153 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime_exception.h"
#pragma external_header(pop)
#line 35 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\exception"

namespace std {

 class exception;
 class bad_exception;

 using ::terminate;


 using ::set_terminate;
 using ::terminate_handler;

 [[nodiscard]] inline terminate_handler __cdecl get_terminate() noexcept {
    
    return _get_terminate();
}
#line 52 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\exception"













#line 66 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\exception"

}








































































































































#line 205 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\exception"

extern "C++"  void __cdecl __ExceptionPtrCreate( void*) noexcept;
extern "C++"  void __cdecl __ExceptionPtrDestroy( void*) noexcept;
extern "C++"  void __cdecl __ExceptionPtrCopy( void*,  const void*) noexcept;
extern "C++"  void __cdecl __ExceptionPtrAssign( void*,  const void*) noexcept;
extern "C++"  bool __cdecl __ExceptionPtrCompare(
     const void*,  const void*) noexcept;
extern "C++"  bool __cdecl __ExceptionPtrToBool( const void*) noexcept;
extern "C++"  void __cdecl __ExceptionPtrSwap( void*,  void*) noexcept;
extern "C++"  void __cdecl __ExceptionPtrCurrentException(void*) noexcept;
extern "C++" [[noreturn]]  void __cdecl __ExceptionPtrRethrow( const void*);
extern "C++"  void __cdecl __ExceptionPtrCopyException(
     void*,  const void*,  const void*) noexcept;

namespace std {

 class exception_ptr {
public:
    exception_ptr() noexcept {
        __ExceptionPtrCreate(this);
    }

    exception_ptr(nullptr_t) noexcept {
        __ExceptionPtrCreate(this);
    }

    ~exception_ptr() noexcept {
        __ExceptionPtrDestroy(this);
    }

    exception_ptr(const exception_ptr& _Rhs) noexcept {
        __ExceptionPtrCopy(this, &_Rhs);
    }

    exception_ptr& operator=(const exception_ptr& _Rhs) noexcept {
        __ExceptionPtrAssign(this, &_Rhs);
        return *this;
    }

    exception_ptr& operator=(nullptr_t) noexcept {
        exception_ptr _Ptr;
        __ExceptionPtrAssign(this, &_Ptr);
        return *this;
    }

    explicit operator bool() const noexcept {
        return __ExceptionPtrToBool(this);
    }

    static exception_ptr _Current_exception() noexcept {
        exception_ptr _Retval;
        __ExceptionPtrCurrentException(&_Retval);
        return _Retval;
    }

    static exception_ptr _Copy_exception( void* _Except,  const void* _Ptr) {
        exception_ptr _Retval;
        if (!_Ptr) {
            
            return _Retval;
        }
        __ExceptionPtrCopyException(&_Retval, _Except, _Ptr);
        return _Retval;
    }

    friend void swap(exception_ptr& _Lhs, exception_ptr& _Rhs) noexcept {
        __ExceptionPtrSwap(&_Lhs, &_Rhs);
    }

    [[nodiscard]] friend bool operator==(const exception_ptr& _Lhs, const exception_ptr& _Rhs) noexcept {
        return __ExceptionPtrCompare(&_Lhs, &_Rhs);
    }

    [[nodiscard]] friend bool operator==(const exception_ptr& _Lhs, nullptr_t) noexcept {
        return !_Lhs;
    }

















#line 299 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\exception"

private:




    void* _Data1;
    void* _Data2;



};

 [[nodiscard]] inline exception_ptr current_exception() noexcept {
    return exception_ptr::_Current_exception();
}

 [[noreturn]] inline void rethrow_exception( exception_ptr _Ptr) {
    __ExceptionPtrRethrow(&_Ptr);
}

template <class _Ex>
void* __GetExceptionInfo(_Ex);

 template <class _Ex>
[[nodiscard("This function constructs an object wrapped by a smart pointer and has no other effects; " "it is not useful to call this function and discard the return value.")]] exception_ptr make_exception_ptr(_Ex _Except) noexcept {
    return exception_ptr::_Copy_exception(::std:: addressof(_Except), __GetExceptionInfo(_Except));
}

[[noreturn]] inline void _Throw_bad_array_new_length() {
    throw bad_array_new_length{} ;
}

 class nested_exception { 
public:
    nested_exception() noexcept : _Exc(::std:: current_exception()) {}

    nested_exception(const nested_exception&) noexcept            = default;
    nested_exception& operator=(const nested_exception&) noexcept = default;
    virtual ~nested_exception() noexcept {}

    [[noreturn]] void rethrow_nested() const { 
        if (_Exc) {
            ::std:: rethrow_exception(_Exc);
        } else {
            ::std:: terminate();
        }
    }

    [[nodiscard]] exception_ptr nested_ptr() const noexcept { 
        return _Exc;
    }

private:
    exception_ptr _Exc;
};

template <class _Ty, class _Uty>
struct _With_nested : _Uty, nested_exception { 
    explicit _With_nested(_Ty&& _Arg)
        : _Uty(::std:: forward<_Ty>(_Arg)), nested_exception() {} 
};

 template <class _Ty>
[[noreturn]] void throw_with_nested(_Ty&& _Arg) {
    
    using _Uty = decay_t<_Ty>;

    if constexpr (is_class_v<_Uty> && !is_base_of_v<nested_exception, _Uty> && !is_final_v<_Uty>) {
        
        using _Glued = _With_nested<_Ty, _Uty>;
        throw _Glued(::std:: forward<_Ty>(_Arg)) ;
    } else {
        
        throw ::std:: forward<_Ty>(_Arg) ;
    }
}


 template <class _Ty>
void rethrow_if_nested(const _Ty& _Arg) {
    
    constexpr bool _Can_use_dynamic_cast =
        is_polymorphic_v<_Ty> && (!is_base_of_v<nested_exception, _Ty> || is_convertible_v<_Ty*, nested_exception*>);

    if constexpr (_Can_use_dynamic_cast) {
        const auto _Nested = dynamic_cast<const nested_exception*>(::std:: addressof(_Arg));

        if (_Nested) {
            _Nested->rethrow_nested();
        }
    }
}



#line 396 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\exception"

 class bad_variant_access
    : public exception { 
public:
    bad_variant_access() noexcept = default;

    [[nodiscard]] const char*  what() const noexcept override {
        return "bad variant access";
    }






#line 412 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\exception"
};

[[noreturn]] inline void _Throw_bad_variant_access() {
    throw bad_variant_access{} ;
}

}



#pragma warning(pop)
#pragma pack(pop)

#line 426 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\exception"
#line 427 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\exception"
#pragma external_header(pop)
#line 12 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\stdexcept"
#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"







#pragma once





#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"





#pragma once







#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\new"





#pragma once







#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )





























































namespace std {

 class bad_alloc;
 class bad_array_new_length;


#line 85 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\new"


 struct destroying_delete_t {
    explicit destroying_delete_t() = default;
};
 inline constexpr destroying_delete_t destroying_delete{};
#line 92 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\new"


 template <class _Ty>
[[nodiscard("'std::launder' has a potential effect on the return value (not on the passed argument). " "It is not useful to call 'std::launder' and discard the return value.")]] constexpr _Ty* launder(_Ty* _Ptr) noexcept {
    static_assert(!is_function_v<_Ty> && !is_void_v<_Ty>,
        "N4727 21.6.4 [ptr.launder]/3: The program is ill-formed if T is a function type or cv void.");
    return __builtin_launder(_Ptr);
}


 inline constexpr size_t hardware_constructive_interference_size = 64;
 inline constexpr size_t hardware_destructive_interference_size  = 64;


#line 107 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\new"

#line 109 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\new"

 using new_handler = void(__cdecl *)();

 extern "C++"  new_handler __cdecl set_new_handler( new_handler) noexcept;
 extern "C++" [[nodiscard]]  new_handler __cdecl get_new_handler() noexcept;
}



#pragma warning(pop)
#pragma pack(pop)

#line 122 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\new"
#line 123 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\new"
#pragma external_header(pop)
#line 15 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"
#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xatomic.h"





#pragma once








#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )

















#line 36 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xatomic.h"












#line 49 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xatomic.h"











#line 61 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xatomic.h"




#line 66 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xatomic.h"

namespace std {


 enum class memory_order : int {
    relaxed,
    consume,
    acquire,
    release,
    acq_rel,
    seq_cst,

    
    memory_order_relaxed = relaxed,
    memory_order_consume = consume,
    memory_order_acquire = acquire,
    memory_order_release = release,
    memory_order_acq_rel = acq_rel,
    memory_order_seq_cst = seq_cst
};
 inline constexpr memory_order memory_order_relaxed = memory_order::relaxed;
 inline constexpr memory_order memory_order_consume = memory_order::consume;
 inline constexpr memory_order memory_order_acquire = memory_order::acquire;
 inline constexpr memory_order memory_order_release = memory_order::release;
 inline constexpr memory_order memory_order_acq_rel = memory_order::acq_rel;
 inline constexpr memory_order memory_order_seq_cst = memory_order::seq_cst;









#line 102 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xatomic.h"

   using _Atomic_counter_t = unsigned long;

template <class _Integral, class _Ty>
[[nodiscard]] volatile _Integral* _Atomic_address_as(_Ty& _Source) noexcept {
    
    static_assert(is_integral_v<_Integral>, "Tried to reinterpret memory as non-integral");
    return &reinterpret_cast<volatile _Integral&>(_Source);
}

template <class _Integral, class _Ty>
[[nodiscard]] const volatile _Integral* _Atomic_address_as(const _Ty& _Source) noexcept {
    
    static_assert(is_integral_v<_Integral>, "Tried to reinterpret memory as non-integral");
    return &reinterpret_cast<const volatile _Integral&>(_Source);
}

}



#pragma warning(pop)
#pragma pack(pop)
#line 126 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xatomic.h"
#line 127 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xatomic.h"
#pragma external_header(pop)
#line 16 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"



#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\tuple"





#pragma once






#line 14 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\tuple"



#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




namespace std {
template <bool _Same, class _Dest, class... _Srcs>
inline constexpr bool _Tuple_conditional_explicit_v0 = false;

template <class... _Dests, class... _Srcs>
inline constexpr bool _Tuple_conditional_explicit_v0<true, tuple<_Dests...>, _Srcs...> =
    !conjunction_v<is_convertible<_Srcs, _Dests>...>;

template <class _Dest, class... _Srcs>
inline constexpr bool _Tuple_conditional_explicit_v =
    _Tuple_conditional_explicit_v0<tuple_size_v<_Dest> == sizeof...(_Srcs), _Dest, _Srcs...>;

template <bool _Same, class _Dest, class... _Srcs>
inline constexpr bool _Tuple_constructible_v0 = false;

template <class... _Dests, class... _Srcs>
inline constexpr bool _Tuple_constructible_v0<true, tuple<_Dests...>, _Srcs...> =
    conjunction_v<is_constructible<_Dests, _Srcs>...>;

template <class _Dest, class... _Srcs>
inline constexpr bool _Tuple_constructible_v =
    _Tuple_constructible_v0<tuple_size_v<_Dest> == sizeof...(_Srcs), _Dest, _Srcs...>;

template <class _Dest, class... _Srcs>
struct _Tuple_constructible_val : bool_constant<_Tuple_constructible_v<_Dest, _Srcs...>> {};

template <bool _Same, class _Dest, class... _Srcs>
inline constexpr bool _Tuple_nothrow_constructible_v0 = false;

template <class... _Dests, class... _Srcs>
inline constexpr bool _Tuple_nothrow_constructible_v0<true, tuple<_Dests...>, _Srcs...> =
    conjunction_v<is_nothrow_constructible<_Dests, _Srcs>...>;

template <class _Dest, class... _Srcs>
inline constexpr bool _Tuple_nothrow_constructible_v =
    _Tuple_nothrow_constructible_v0<tuple_size_v<_Dest> == sizeof...(_Srcs), _Dest, _Srcs...>;

template <bool _Same, class _Dest, class... _Srcs>
inline constexpr bool _Tuple_assignable_v0 = false;

template <class... _Dests, class... _Srcs>
inline constexpr bool _Tuple_assignable_v0<true, tuple<_Dests...>, _Srcs...> =
    conjunction_v<is_assignable<_Dests&, _Srcs>...>; 





#line 73 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\tuple"

template <class _Dest, class... _Srcs>
inline constexpr bool _Tuple_assignable_v =
    _Tuple_assignable_v0<tuple_size_v<_Dest> == sizeof...(_Srcs), _Dest, _Srcs...>;

template <class _Dest, class... _Srcs>
struct _Tuple_assignable_val : bool_constant<_Tuple_assignable_v<_Dest, _Srcs...>> {};

template <bool _Same, class _Dest, class... _Srcs>
inline constexpr bool _Tuple_nothrow_assignable_v0 = false;

template <class... _Dests, class... _Srcs>
inline constexpr bool _Tuple_nothrow_assignable_v0<true, tuple<_Dests...>, _Srcs...> =
    conjunction_v<is_nothrow_assignable<_Dests&, _Srcs>...>; 





#line 93 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\tuple"

template <class _Dest, class... _Srcs>
inline constexpr bool _Tuple_nothrow_assignable_v =
    _Tuple_nothrow_assignable_v0<tuple_size_v<_Dest> == sizeof...(_Srcs), _Dest, _Srcs...>;


template <class _Myself, class _OtherTuple, class... _Other>
struct _Tuple_convert_val : true_type {};

template <class _This, class _OtherTuple, class _Uty>
struct _Tuple_convert_val<tuple<_This>, _OtherTuple, _Uty>
    : bool_constant<!disjunction_v<is_same<_This, _Uty>, is_constructible<_This, _OtherTuple>,
          is_convertible<_OtherTuple, _This>>> {};


template <class _Myself, class _This2, class... _Rest2>
struct _Tuple_perfect_val : true_type {};

template <class _Myself, class _This2>
struct _Tuple_perfect_val<_Myself, _This2> : bool_constant<!is_same_v<_Myself, _Remove_cvref_t<_This2>>> {};

template <class _Ty0, class _Ty1, class _Uty0, class _Uty1>
struct _Tuple_perfect_val<tuple<_Ty0, _Ty1>, _Uty0, _Uty1>
    : bool_constant<disjunction_v<negation<is_same<_Remove_cvref_t<_Uty0>, allocator_arg_t>>,
          is_same<_Remove_cvref_t<_Ty0>, allocator_arg_t>>> {};

template <class _Ty0, class _Ty1, class _Ty2, class _Uty0, class _Uty1, class _Uty2>
struct _Tuple_perfect_val<tuple<_Ty0, _Ty1, _Ty2>, _Uty0, _Uty1, _Uty2>
    : bool_constant<disjunction_v<negation<is_same<_Remove_cvref_t<_Uty0>, allocator_arg_t>>,
          is_same<_Remove_cvref_t<_Ty0>, allocator_arg_t>>> {};

struct _Ignore { 
    template <class _Ty>
    constexpr const _Ignore& operator=(const _Ty&) const noexcept   {
        
        return *this;
    }
};

 inline constexpr _Ignore ignore{};






template <class _Ty>
struct _Tuple_val { 
    constexpr _Tuple_val() : _Val() {}

    template <class _Other>
    constexpr _Tuple_val(_Other&& _Arg) : _Val(::std:: forward<_Other>(_Arg)) {}

    template <class _Alloc, class... _Other, enable_if_t<!uses_allocator_v<_Ty, _Alloc>, int> = 0>
    constexpr _Tuple_val(const _Alloc&, allocator_arg_t, _Other&&... _Arg) : _Val(::std:: forward<_Other>(_Arg)...) {}

    template <class _Alloc, class... _Other,
        enable_if_t<conjunction_v<::std:: uses_allocator<_Ty, _Alloc>,
                        ::std:: is_constructible<_Ty, ::std:: allocator_arg_t, const _Alloc&, _Other...>>,
            int> = 0>
    constexpr _Tuple_val(const _Alloc& _Al, allocator_arg_t, _Other&&... _Arg)
        : _Val(allocator_arg, _Al, ::std:: forward<_Other>(_Arg)...) {}

    template <class _Alloc, class... _Other,
        enable_if_t<conjunction_v<::std:: uses_allocator<_Ty, _Alloc>,
                        ::std:: negation<::std:: is_constructible<_Ty, ::std:: allocator_arg_t, const _Alloc&, _Other...>>>,
            int> = 0>
    constexpr _Tuple_val(const _Alloc& _Al, allocator_arg_t, _Other&&... _Arg)
        : _Val(::std:: forward<_Other>(_Arg)..., _Al) {}

    _Ty _Val;
};

struct _Exact_args_t {
    explicit _Exact_args_t() = default;
}; 

struct _Unpack_tuple_t {
    explicit _Unpack_tuple_t() = default;
}; 

struct _Alloc_exact_args_t {
    explicit _Alloc_exact_args_t() = default;
}; 

struct _Alloc_unpack_tuple_t {
    explicit _Alloc_unpack_tuple_t() = default;
}; 

template <>
class tuple<> { 
public:
    constexpr tuple() noexcept = default;  

    constexpr tuple(const tuple&) noexcept   {} 

    template <class _Alloc>
    constexpr tuple(allocator_arg_t, const _Alloc&) noexcept   {}

    template <class _Alloc>
    constexpr tuple(allocator_arg_t, const _Alloc&, const tuple&) noexcept   {}

    template <class _Tag, enable_if_t<is_same_v<_Tag, ::std:: _Exact_args_t>, int> = 0>
    constexpr tuple(_Tag) noexcept   {}

    template <class _Tag, class _Alloc, enable_if_t<is_same_v<_Tag, ::std:: _Alloc_exact_args_t>, int> = 0>
    constexpr tuple(_Tag, const _Alloc&) noexcept   {}

    constexpr tuple& operator=(const tuple&) = default;




#line 207 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\tuple"

    constexpr void swap(tuple&) noexcept {}


#line 212 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\tuple"

    constexpr bool _Equals(const tuple&) const noexcept {
        return true;
    }


    [[nodiscard]] constexpr strong_ordering _Three_way_compare(const tuple&) const noexcept {
        return strong_ordering::equal;
    }




#line 226 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\tuple"
};

template <class _This, class... _Rest>
class tuple<_This, _Rest...> : private tuple<_Rest...> { 
public:
    using _This_type = _This;
    using _Mybase    = tuple<_Rest...>;

    template <class _Tag, class _This2, class... _Rest2, enable_if_t<is_same_v<_Tag, ::std:: _Exact_args_t>, int> = 0>
    constexpr tuple(_Tag, _This2&& _This_arg, _Rest2&&... _Rest_arg)
        : _Mybase(_Exact_args_t{}, ::std:: forward<_Rest2>(_Rest_arg)...), _Myfirst(::std:: forward<_This2>(_This_arg)) {}

    template <class _Tag, class _Tpl, size_t... _Indices, enable_if_t<is_same_v<_Tag, ::std:: _Unpack_tuple_t>, int> = 0>
    constexpr tuple(_Tag, _Tpl&& _Right, index_sequence<_Indices...>);

    template <class _Tag, class _Tpl, enable_if_t<is_same_v<_Tag, ::std:: _Unpack_tuple_t>, int> = 0>
    constexpr tuple(_Tag, _Tpl&& _Right)
        : tuple(_Unpack_tuple_t{}, ::std:: forward<_Tpl>(_Right),
            make_index_sequence<tuple_size_v<remove_reference_t<_Tpl>>>{}) {}

    template <class _Tag, class _Alloc, class _This2, class... _Rest2,
        enable_if_t<is_same_v<_Tag, ::std:: _Alloc_exact_args_t>, int> = 0>
    constexpr tuple(_Tag, const _Alloc& _Al, _This2&& _This_arg, _Rest2&&... _Rest_arg)
        : _Mybase(_Alloc_exact_args_t{}, _Al, ::std:: forward<_Rest2>(_Rest_arg)...),
          _Myfirst(_Al, allocator_arg, ::std:: forward<_This2>(_This_arg)) {}

    template <class _Tag, class _Alloc, class _Tpl, size_t... _Indices,
        enable_if_t<is_same_v<_Tag, ::std:: _Alloc_unpack_tuple_t>, int> = 0>
    constexpr tuple(_Tag, const _Alloc& _Al, _Tpl&& _Right, index_sequence<_Indices...>);

    template <class _Tag, class _Alloc, class _Tpl, enable_if_t<is_same_v<_Tag, ::std:: _Alloc_unpack_tuple_t>, int> = 0>
    constexpr tuple(_Tag, const _Alloc& _Al, _Tpl&& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: forward<_Tpl>(_Right),
            make_index_sequence<tuple_size_v<remove_reference_t<_Tpl>>>{}) {}

    template <class _This2 = _This,
        enable_if_t<conjunction_v<::std:: is_default_constructible<_This2>, ::std:: is_default_constructible<_Rest>...>,
            int>           = 0>
    constexpr explicit(
        !conjunction_v<_Is_implicitly_default_constructible<_This2>, _Is_implicitly_default_constructible<_Rest>...>)
        tuple() noexcept(conjunction_v<is_nothrow_default_constructible<_This2>,
            is_nothrow_default_constructible<_Rest>...>) 
        : _Mybase(), _Myfirst() {}

    template <class _This2 = _This, enable_if_t<_Tuple_constructible_v<tuple, const _This2&, const _Rest&...>, int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, const _This2&, const _Rest&...>) tuple(
        const _This& _This_arg, const _Rest&... _Rest_arg) noexcept(conjunction_v<is_nothrow_copy_constructible<_This2>,
        is_nothrow_copy_constructible<_Rest>...>) 
        : tuple(_Exact_args_t{}, _This_arg, _Rest_arg...) {}

    template <class _This2, class... _Rest2,
        enable_if_t<conjunction_v<::std:: _Tuple_perfect_val<tuple, _This2, _Rest2...>,
                        ::std:: _Tuple_constructible_val<tuple, _This2, _Rest2...>>,
            int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, _This2, _Rest2...>) tuple(_This2&& _This_arg,
        _Rest2&&... _Rest_arg) noexcept(_Tuple_nothrow_constructible_v<tuple, _This2, _Rest2...>) 
        : tuple(_Exact_args_t{}, ::std:: forward<_This2>(_This_arg), ::std:: forward<_Rest2>(_Rest_arg)...) {}

    tuple(const tuple&) = default;
    tuple(tuple&&)      = default;








#line 295 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\tuple"

    template <class... _Other, enable_if_t<conjunction_v<::std:: _Tuple_constructible_val<tuple, const _Other&...>,
                                               ::std:: _Tuple_convert_val<tuple, const tuple<_Other...>&, _Other...>>,
                                   int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, const _Other&...>)
        tuple(const tuple<_Other...>& _Right) noexcept(
            _Tuple_nothrow_constructible_v<tuple, const _Other&...>) 
        : tuple(_Unpack_tuple_t{}, _Right) {}

    template <class... _Other, enable_if_t<conjunction_v<::std:: _Tuple_constructible_val<tuple, _Other...>,
                                               ::std:: _Tuple_convert_val<tuple, tuple<_Other...>, _Other...>>,
                                   int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, _Other...>)
        tuple(tuple<_Other...>&& _Right) noexcept(_Tuple_nothrow_constructible_v<tuple, _Other...>) 
        : tuple(_Unpack_tuple_t{}, ::std:: move(_Right)) {}















#line 326 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\tuple"

    template <class _First, class _Second,
        enable_if_t<_Tuple_constructible_v<tuple, const _First&, const _Second&>, int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, const _First&, const _Second&>)
        tuple(const pair<_First, _Second>& _Right) noexcept(
            _Tuple_nothrow_constructible_v<tuple, const _First&, const _Second&>) 
        : tuple(_Unpack_tuple_t{}, _Right) {}

    template <class _First, class _Second, enable_if_t<_Tuple_constructible_v<tuple, _First, _Second>, int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, _First, _Second>) tuple(
        pair<_First, _Second>&& _Right) noexcept(_Tuple_nothrow_constructible_v<tuple, _First, _Second>) 
        : tuple(_Unpack_tuple_t{}, ::std:: move(_Right)) {}








#line 347 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\tuple"

    template <class _Alloc, class _This2 = _This,
        enable_if_t<conjunction_v<::std:: is_default_constructible<_This2>, ::std:: is_default_constructible<_Rest>...>,
            int> = 0>
    constexpr explicit(
        !conjunction_v<_Is_implicitly_default_constructible<_This2>, _Is_implicitly_default_constructible<_Rest>...>)
        tuple(allocator_arg_t, const _Alloc& _Al)
        : _Mybase(allocator_arg, _Al), _Myfirst(_Al, allocator_arg) {}

    template <class _Alloc, class _This2 = _This,
        enable_if_t<_Tuple_constructible_v<tuple, const _This2&, const _Rest&...>, int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, const _This2&, const _Rest&...>)
        tuple(allocator_arg_t, const _Alloc& _Al, const _This& _This_arg, const _Rest&... _Rest_arg)
        : tuple(_Alloc_exact_args_t{}, _Al, _This_arg, _Rest_arg...) {}

    template <class _Alloc, class _This2, class... _Rest2,
        enable_if_t<conjunction_v<::std:: _Tuple_perfect_val<tuple, _This2, _Rest2...>,
                        ::std:: _Tuple_constructible_val<tuple, _This2, _Rest2...>>,
            int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, _This2, _Rest2...>)
        tuple(allocator_arg_t, const _Alloc& _Al, _This2&& _This_arg, _Rest2&&... _Rest_arg)
        : tuple(_Alloc_exact_args_t{}, _Al, ::std:: forward<_This2>(_This_arg), ::std:: forward<_Rest2>(_Rest_arg)...) {}

    template <class _Alloc, class _This2 = _This,
        enable_if_t<_Tuple_constructible_v<tuple, const _This2&, const _Rest&...>, int> = 0>
    constexpr tuple(allocator_arg_t, const _Alloc& _Al, const tuple& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, _Right) {}

    template <class _Alloc, class _This2 = _This, enable_if_t<_Tuple_constructible_v<tuple, _This2, _Rest...>, int> = 0>
    constexpr tuple(allocator_arg_t, const _Alloc& _Al, tuple&& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: move(_Right)) {}









#line 388 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\tuple"

    template <class _Alloc, class... _Other,
        enable_if_t<conjunction_v<::std:: _Tuple_constructible_val<tuple, const _Other&...>,
                        ::std:: _Tuple_convert_val<tuple, const tuple<_Other...>&, _Other...>>,
            int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, const _Other&...>)
        tuple(allocator_arg_t, const _Alloc& _Al, const tuple<_Other...>& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, _Right) {}

    template <class _Alloc, class... _Other,
        enable_if_t<conjunction_v<::std:: _Tuple_constructible_val<tuple, _Other...>,
                        ::std:: _Tuple_convert_val<tuple, tuple<_Other...>, _Other...>>,
            int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, _Other...>)
        tuple(allocator_arg_t, const _Alloc& _Al, tuple<_Other...>&& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: move(_Right)) {}















#line 420 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\tuple"

    template <class _Alloc, class _First, class _Second,
        enable_if_t<_Tuple_constructible_v<tuple, const _First&, const _Second&>, int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, const _First&, const _Second&>)
        tuple(allocator_arg_t, const _Alloc& _Al, const pair<_First, _Second>& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, _Right) {}

    template <class _Alloc, class _First, class _Second,
        enable_if_t<_Tuple_constructible_v<tuple, _First, _Second>, int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, _First, _Second>)
        tuple(allocator_arg_t, const _Alloc& _Al, pair<_First, _Second>&& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: move(_Right)) {}







#line 440 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\tuple"

    tuple& operator=(const volatile tuple&) = delete;

    template <class _Myself = tuple, class _This2 = _This,
        enable_if_t<conjunction_v<::std:: _Is_copy_assignable_no_precondition_check<_This2>,
                        ::std:: _Is_copy_assignable_no_precondition_check<_Rest>...>,
            int> = 0>
    constexpr tuple& operator=(_Identity_t<const _Myself&> _Right) noexcept(
        conjunction_v<is_nothrow_copy_assignable<_This2>, is_nothrow_copy_assignable<_Rest>...>)   {
        _Myfirst._Val = _Right._Myfirst._Val;
        _Get_rest()   = _Right._Get_rest();
        return *this;
    }













#line 467 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\tuple"

    template <class _Myself = tuple, class _This2 = _This,
        enable_if_t<conjunction_v<::std:: _Is_move_assignable_no_precondition_check<_This2>,
                        ::std:: _Is_move_assignable_no_precondition_check<_Rest>...>,
            int> = 0>
    constexpr tuple& operator=(_Identity_t<_Myself&&> _Right) noexcept(
        conjunction_v<is_nothrow_move_assignable<_This2>, is_nothrow_move_assignable<_Rest>...>) {
        _Myfirst._Val = ::std:: forward<_This>(_Right._Myfirst._Val);
        _Get_rest()   = ::std:: forward<_Mybase>(_Right._Get_rest());
        return *this;
    }













#line 492 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\tuple"

    template <class... _Other, enable_if_t<conjunction_v<::std:: negation<::std:: is_same<tuple, ::std:: tuple<_Other...>>>,
                                               ::std:: _Tuple_assignable_val<tuple, const _Other&...>>,
                                   int> = 0>
    constexpr tuple& operator=(const tuple<_Other...>& _Right) noexcept(
        _Tuple_nothrow_assignable_v<tuple, const _Other&...>)   {
        _Myfirst._Val = _Right._Myfirst._Val;
        _Get_rest()   = _Right._Get_rest();
        return *this;
    }











#line 514 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\tuple"

    template <class... _Other, enable_if_t<conjunction_v<::std:: negation<::std:: is_same<tuple, ::std:: tuple<_Other...>>>,
                                               ::std:: _Tuple_assignable_val<tuple, _Other...>>,
                                   int> = 0>
    constexpr tuple& operator=(tuple<_Other...>&& _Right) noexcept(
        _Tuple_nothrow_assignable_v<tuple, _Other...>)   {
        _Myfirst._Val = ::std:: forward<typename tuple<_Other...>::_This_type>(_Right._Myfirst._Val);
        _Get_rest()   = ::std:: forward<typename tuple<_Other...>::_Mybase>(_Right._Get_rest());
        return *this;
    }











#line 536 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\tuple"

    template <class _First, class _Second,
        enable_if_t<_Tuple_assignable_v<tuple, const _First&, const _Second&>, int> = 0>
    constexpr tuple& operator=(const pair<_First, _Second>& _Right) noexcept(
        _Tuple_nothrow_assignable_v<tuple, const _First&, const _Second&>)   {
        _Myfirst._Val             = _Right.first;
        _Get_rest()._Myfirst._Val = _Right.second;
        return *this;
    }










#line 556 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\tuple"

    template <class _First, class _Second, enable_if_t<_Tuple_assignable_v<tuple, _First, _Second>, int> = 0>
    constexpr tuple& operator=(pair<_First, _Second>&& _Right) noexcept(
        _Tuple_nothrow_assignable_v<tuple, _First, _Second>)   {
        _Myfirst._Val             = ::std:: forward<_First>(_Right.first);
        _Get_rest()._Myfirst._Val = ::std:: forward<_Second>(_Right.second);
        return *this;
    }









#line 574 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\tuple"

    constexpr void swap(tuple& _Right) noexcept(
        conjunction_v<_Is_nothrow_swappable<_This>, _Is_nothrow_swappable<_Rest>...>) {
        _Swap_adl(_Myfirst._Val, _Right._Myfirst._Val);
        _Mybase::swap(_Right._Get_rest());
    }








#line 589 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\tuple"

    constexpr _Mybase& _Get_rest() noexcept { 
        return *this;
    }

    constexpr const _Mybase& _Get_rest() const noexcept { 
        return *this;
    }

    template <class... _Other>
    constexpr bool _Equals(const tuple<_Other...>& _Right) const {
        return _Myfirst._Val == _Right._Myfirst._Val && _Mybase::_Equals(_Right._Get_rest());
    }


    template <class _First, class... _Other>
    [[nodiscard]] constexpr common_comparison_category_t<_Synth_three_way_result<_This, _First>,
        _Synth_three_way_result<_Rest, _Other>...>
        _Three_way_compare(const tuple<_First, _Other...>& _Right) const {
        if (auto _Result = _Synth_three_way{}(_Myfirst._Val, _Right._Myfirst._Val); _Result != 0) {
            return _Result;
        }
        return _Mybase::_Three_way_compare(_Right._Get_rest());
    }






#line 620 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\tuple"

    template <size_t _Index, class... _Types>
    friend constexpr tuple_element_t<_Index, tuple<_Types...>>& get(tuple<_Types...>& _Tuple) noexcept;

    template <size_t _Index, class... _Types>
    friend constexpr const tuple_element_t<_Index, tuple<_Types...>>& get(const tuple<_Types...>& _Tuple) noexcept;

    template <size_t _Index, class... _Types>
    friend constexpr tuple_element_t<_Index, tuple<_Types...>>&& get(tuple<_Types...>&& _Tuple) noexcept;

    template <size_t _Index, class... _Types>
    friend constexpr const tuple_element_t<_Index, tuple<_Types...>>&& get(const tuple<_Types...>&& _Tuple) noexcept;

    template <size_t _Index, class... _Types>
    friend constexpr auto&& _Tuple_get(tuple<_Types...>&& _Tuple) noexcept;

    template <class _Ty, class... _Types>
    friend constexpr _Ty& get(tuple<_Types...>& _Tuple) noexcept;

    template <class _Ty, class... _Types>
    friend constexpr const _Ty& get(const tuple<_Types...>& _Tuple) noexcept;

    template <class _Ty, class... _Types>
    friend constexpr _Ty&& get(tuple<_Types...>&& _Tuple) noexcept;

    template <class _Ty, class... _Types>
    friend constexpr const _Ty&& get(const tuple<_Types...>&& _Tuple) noexcept;

    _Tuple_val<_This> _Myfirst; 
};


template <class... _Types>
tuple(_Types...) -> tuple<_Types...>;

template <class _Ty1, class _Ty2>
tuple(pair<_Ty1, _Ty2>) -> tuple<_Ty1, _Ty2>;

template <class _Alloc, class... _Types>
tuple(allocator_arg_t, _Alloc, _Types...) -> tuple<_Types...>;

template <class _Alloc, class _Ty1, class _Ty2>
tuple(allocator_arg_t, _Alloc, pair<_Ty1, _Ty2>) -> tuple<_Ty1, _Ty2>;

template <class _Alloc, class... _Types>
tuple(allocator_arg_t, _Alloc, tuple<_Types...>) -> tuple<_Types...>;
#line 667 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\tuple"

 template <class... _Types1, class... _Types2>
[[nodiscard]] constexpr bool operator==(const tuple<_Types1...>& _Left, const tuple<_Types2...>& _Right) {
    static_assert(sizeof...(_Types1) == sizeof...(_Types2), "cannot compare tuples of different sizes");
    return _Left._Equals(_Right);
}


 template <class... _Types1, class... _Types2>
[[nodiscard]] constexpr common_comparison_category_t<_Synth_three_way_result<_Types1, _Types2>...> operator<=>(
    const tuple<_Types1...>& _Left, const tuple<_Types2...>& _Right) {
    static_assert(sizeof...(_Types1) == sizeof...(_Types2), "cannot compare tuples of different sizes");
    return _Left._Three_way_compare(_Right);
}




























#line 710 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\tuple"

 template <class... _Types, enable_if_t<conjunction_v<_Is_swappable<_Types>...>, int> = 0>
constexpr void swap(tuple<_Types...>& _Left, tuple<_Types...>& _Right) noexcept(noexcept(_Left.swap(_Right))) {
    _Left.swap(_Right);
}







#line 723 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\tuple"

template <class _Ty, class _Tuple>
struct _Tuple_element {}; 

template <class _This, class... _Rest>
struct _Tuple_element<_This, tuple<_This, _Rest...>> { 
    static_assert(!_Is_any_of_v<_This, _Rest...>, "duplicate type T in get<T>(tuple)");
    using _Ttype = tuple<_This, _Rest...>;
};

template <class _Ty, class _This, class... _Rest>
struct _Tuple_element<_Ty, tuple<_This, _Rest...>> { 
    using _Ttype = typename _Tuple_element<_Ty, tuple<_Rest...>>::_Ttype;
};

 template <size_t _Index, class... _Types>
[[nodiscard]] constexpr tuple_element_t<_Index, tuple<_Types...>>& get(tuple<_Types...>& _Tuple) noexcept {
    using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
    return static_cast<_Ttype&>(_Tuple)._Myfirst._Val;
}

 template <size_t _Index, class... _Types>
[[nodiscard]] constexpr const tuple_element_t<_Index, tuple<_Types...>>& get(const tuple<_Types...>& _Tuple) noexcept {
    using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
    return static_cast<const _Ttype&>(_Tuple)._Myfirst._Val;
}

 template <size_t _Index, class... _Types>
[[nodiscard]] constexpr tuple_element_t<_Index, tuple<_Types...>>&& get(tuple<_Types...>&& _Tuple) noexcept {
    using _Ty    = tuple_element_t<_Index, tuple<_Types...>>;
    using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
    return static_cast<_Ty&&>(static_cast<_Ttype&>(_Tuple)._Myfirst._Val);
}

 template <size_t _Index, class... _Types>
[[nodiscard]] constexpr const tuple_element_t<_Index, tuple<_Types...>>&& get(const tuple<_Types...>&& _Tuple) noexcept {
    using _Ty    = tuple_element_t<_Index, tuple<_Types...>>;
    using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
    return static_cast<const _Ty&&>(static_cast<const _Ttype&>(_Tuple)._Myfirst._Val);
}

   template <size_t _Index, class... _Types>
[[nodiscard]] constexpr auto&& _Tuple_get(tuple<_Types...>&& _Tuple) noexcept {
    
    using _Ty    = tuple_element_t<_Index, tuple<_Types...>>;
    using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
    return static_cast<_Ty&&>(static_cast<_Ttype&>(_Tuple)._Myfirst._Val);
}

 template <class _Ty, class... _Types>
[[nodiscard]] constexpr _Ty& get(tuple<_Types...>& _Tuple) noexcept {
    using _Ttype = typename _Tuple_element<_Ty, tuple<_Types...>>::_Ttype;
    return static_cast<_Ttype&>(_Tuple)._Myfirst._Val;
}

 template <class _Ty, class... _Types>
[[nodiscard]] constexpr const _Ty& get(const tuple<_Types...>& _Tuple) noexcept {
    using _Ttype = typename _Tuple_element<_Ty, tuple<_Types...>>::_Ttype;
    return static_cast<const _Ttype&>(_Tuple)._Myfirst._Val;
}

 template <class _Ty, class... _Types>
[[nodiscard]] constexpr _Ty&& get(tuple<_Types...>&& _Tuple) noexcept {
    using _Ttype = typename _Tuple_element<_Ty, tuple<_Types...>>::_Ttype;
    return static_cast<_Ty&&>(static_cast<_Ttype&>(_Tuple)._Myfirst._Val);
}

 template <class _Ty, class... _Types>
[[nodiscard]] constexpr const _Ty&& get(const tuple<_Types...>&& _Tuple) noexcept {
    using _Ttype = typename _Tuple_element<_Ty, tuple<_Types...>>::_Ttype;
    return static_cast<const _Ty&&>(static_cast<const _Ttype&>(_Tuple)._Myfirst._Val);
}

template <class _This, class... _Rest>
template <class _Tag, class _Tpl, size_t... _Indices, enable_if_t<is_same_v<_Tag, ::std:: _Unpack_tuple_t>, int>>
constexpr tuple<_This, _Rest...>::tuple(_Tag, _Tpl&& _Right, index_sequence<_Indices...>)
    : tuple(_Exact_args_t{}, ::std:: get<_Indices>(::std:: forward<_Tpl>(_Right))...) {}

template <class _This, class... _Rest>
template <class _Tag, class _Alloc, class _Tpl, size_t... _Indices,
    enable_if_t<is_same_v<_Tag, ::std:: _Alloc_unpack_tuple_t>, int>>
constexpr tuple<_This, _Rest...>::tuple(_Tag, const _Alloc& _Al, _Tpl&& _Right, index_sequence<_Indices...>)
    : tuple(_Alloc_exact_args_t{}, _Al, ::std:: get<_Indices>(::std:: forward<_Tpl>(_Right))...) {}

 template <class... _Types>
[[nodiscard]] constexpr tuple<_Unrefwrap_t<_Types>...> make_tuple(_Types&&... _Args) { 
    using _Ttype = tuple<_Unrefwrap_t<_Types>...>;
    return _Ttype(::std:: forward<_Types>(_Args)...);
}

 template <class... _Types>
[[nodiscard]] constexpr tuple<_Types&...> tie(_Types&... _Args) noexcept { 
    using _Ttype = tuple<_Types&...>;
    return _Ttype(_Args...);
}

 template <class... _Types>
[[nodiscard]] constexpr tuple<_Types&&...> forward_as_tuple(_Types&&... _Args) noexcept { 
    return tuple<_Types&&...>(::std:: forward<_Types>(_Args)...);
}

template <class _Ty, class _Kx_arg, class _Ix_arg, size_t _Ix_next, class... _Sequences>
struct _Tuple_cat2;

template <class _Ty, size_t... _Kx, size_t... _Ix, size_t _Ix_next>
struct _Tuple_cat2<_Ty, index_sequence<_Kx...>, index_sequence<_Ix...>, _Ix_next> {
    using _Ret    = tuple<tuple_element_t<_Kx, _Remove_cvref_t<tuple_element_t<_Ix, _Ty>>>...>;
    using _Kx_seq = index_sequence<_Kx...>;
    using _Ix_seq = index_sequence<_Ix...>;
};

template <class _Ty, size_t... _Kx, size_t... _Ix, size_t _Ix_next, size_t... _Kx_next, class... _Rest>
struct _Tuple_cat2<_Ty, index_sequence<_Kx...>, index_sequence<_Ix...>, _Ix_next, index_sequence<_Kx_next...>, _Rest...>
    : _Tuple_cat2<_Ty, index_sequence<_Kx..., _Kx_next...>,
          index_sequence<_Ix..., (_Ix_next + 0 * _Kx_next)...>, 
          _Ix_next + 1, _Rest...> {};

template <class... _Tuples>
using _Tuple_cat1 = _Tuple_cat2<tuple<_Tuples&&...>, index_sequence<>, index_sequence<>, 0,
    make_index_sequence<tuple_size_v<_Remove_cvref_t<_Tuples>>>...>;

template <class _Ret, size_t... _Kx, size_t... _Ix, class _Ty>
constexpr _Ret _Tuple_cat(index_sequence<_Kx...>, index_sequence<_Ix...>, _Ty _Arg) {
    return _Ret{::std:: get<_Kx>(::std:: get<_Ix>(::std:: move(_Arg)))...};
}

 template <class... _Tuples>
[[nodiscard]] constexpr typename _Tuple_cat1<_Tuples...>::_Ret tuple_cat(_Tuples&&... _Tpls) { 
    using _Cat1   = _Tuple_cat1<_Tuples...>;
    using _Ret    = typename _Cat1::_Ret;
    using _Kx_seq = typename _Cat1::_Kx_seq;
    using _Ix_seq = typename _Cat1::_Ix_seq;
    return _Tuple_cat<_Ret>(_Kx_seq{}, _Ix_seq{}, ::std:: forward_as_tuple(::std:: forward<_Tuples>(_Tpls)...));
}


template <class _Callable, class _Tuple, size_t... _Indices>
constexpr decltype(auto) _Apply_impl(_Callable&& _Obj, _Tuple&& _Tpl, index_sequence<_Indices...>) noexcept(
    noexcept(::std:: invoke(::std:: forward<_Callable>(_Obj), ::std:: get<_Indices>(::std:: forward<_Tuple>(_Tpl))...))) {
    return ::std:: invoke(::std:: forward<_Callable>(_Obj), ::std:: get<_Indices>(::std:: forward<_Tuple>(_Tpl))...);
}

 template <class _Callable, class _Tuple>
constexpr decltype(auto) apply(_Callable&& _Obj, _Tuple&& _Tpl) noexcept(
    noexcept(_Apply_impl(::std:: forward<_Callable>(_Obj), ::std:: forward<_Tuple>(_Tpl),
        make_index_sequence<tuple_size_v<remove_reference_t<_Tuple>>>{}))) {
    return _Apply_impl(::std:: forward<_Callable>(_Obj), ::std:: forward<_Tuple>(_Tpl),
        make_index_sequence<tuple_size_v<remove_reference_t<_Tuple>>>{});
}

template <class _Ty, class _Tuple, size_t... _Indices>
constexpr _Ty _Make_from_tuple_impl(_Tuple&& _Tpl, index_sequence<_Indices...>) noexcept(
    is_nothrow_constructible_v<_Ty, decltype(::std:: get<_Indices>(::std:: forward<_Tuple>(_Tpl)))...>) {
    
    static_assert(is_constructible_v<_Ty, decltype(::std:: get<_Indices>(::std:: forward<_Tuple>(_Tpl)))...>,
        "the target type must be constructible from the fields of the argument tuple (N4892 [tuple.apply]/2).");
    return _Ty(::std:: get<_Indices>(::std:: forward<_Tuple>(_Tpl))...);
}

 template <class _Ty, class _Tuple>
[[nodiscard]] constexpr _Ty make_from_tuple(_Tuple&& _Tpl) noexcept(noexcept(_Make_from_tuple_impl<_Ty>(
    ::std:: forward<_Tuple>(_Tpl), make_index_sequence<tuple_size_v<remove_reference_t<_Tuple>>>{})))   {
    
    return _Make_from_tuple_impl<_Ty>(
        ::std:: forward<_Tuple>(_Tpl), make_index_sequence<tuple_size_v<remove_reference_t<_Tuple>>>{});
}
#line 890 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\tuple"

template <class... _Types, class _Alloc>
struct uses_allocator<tuple<_Types...>, _Alloc> : true_type {}; 


template <class... _TTypes, class... _UTypes, template <class> class _TQual, template <class> class _UQual>
    requires requires { typename tuple<common_reference_t<_TQual<_TTypes>, _UQual<_UTypes>>...>; }
struct basic_common_reference<tuple<_TTypes...>, tuple<_UTypes...>, _TQual, _UQual> {
    using type = tuple<common_reference_t<_TQual<_TTypes>, _UQual<_UTypes>>...>;
};

template <class... _TTypes, class... _UTypes>
    requires requires { typename tuple<common_type_t<_TTypes, _UTypes>...>; }
struct common_type<tuple<_TTypes...>, tuple<_UTypes...>> {
    using type = tuple<common_type_t<_TTypes, _UTypes>...>;
};
#line 907 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\tuple"










#line 918 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\tuple"

}



#pragma warning(pop)
#pragma pack(pop)
#line 926 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\tuple"
#line 927 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\tuple"
#pragma external_header(pop)
#line 20 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"
#line 21 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"

#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




namespace std {
template <class _Ty>
struct [[nodiscard]] _Tidy_guard { 
    _Ty* _Target;
    constexpr ~_Tidy_guard() {
        if (_Target) {
            _Target->_Tidy();
        }
    }
};

template <class _Ty>
struct [[nodiscard]] _Tidy_deallocate_guard { 
    _Ty* _Target;
    constexpr ~_Tidy_deallocate_guard() {
        if (_Target) {
            _Target->_Tidy_deallocate();
        }
    }
};

template <class _Keycmp, class _Lhs, class _Rhs>
inline constexpr bool _Nothrow_compare = noexcept(
    static_cast<bool>(::std:: declval<const _Keycmp&>()(::std:: declval<const _Lhs&>(), ::std:: declval<const _Rhs&>())));

template <size_t _Ty_size>
[[nodiscard]] constexpr size_t _Get_size_of_n(const size_t _Count) {
    constexpr bool _Overflow_is_possible = _Ty_size > 1;

    if constexpr (_Overflow_is_possible) {
        constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
        if (_Count > _Max_possible) {
            _Throw_bad_array_new_length(); 
        }
    }

    return _Count * _Ty_size;
}

template <class _Ty>
inline constexpr size_t _New_alignof = (::std:: max)(alignof(_Ty), 16ull );

struct _Default_allocate_traits {
    __declspec(allocator) static



        void* _Allocate(const size_t _Bytes) {
        return ::operator new(_Bytes);
    }


    __declspec(allocator) static



        void* _Allocate_aligned(const size_t _Bytes, const size_t _Align) {







        {
            return ::operator new(_Bytes, align_val_t{_Align});
        }
    }
#line 98 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"
};

constexpr bool _Is_pow_2(const size_t _Value) noexcept {
    return _Value != 0 && (_Value & (_Value - 1)) == 0;
}


inline constexpr size_t _Big_allocation_threshold = 4096;
inline constexpr size_t _Big_allocation_alignment = 32;


 ;


 ;




inline constexpr size_t _Non_user_size           = sizeof(void*) + _Big_allocation_alignment - 1;
#line 119 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"


inline constexpr size_t _Big_allocation_sentinel = 0xFAFAFAFAFAFAFAFAULL;


#line 125 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"

template <class _Traits>
__declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {
    
    const size_t _Block_size = _Non_user_size + _Bytes;
    if (_Block_size <= _Bytes) {
        _Throw_bad_array_new_length(); 
    }

    const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
    do { if (_Ptr_container != 0) { } else { do {; ::_invalid_parameter_noinfo_noreturn(); } while (false); }; } while (false) ; 
    void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));
    static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;




    return _Ptr;
}

inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {
    
    _Bytes += _Non_user_size;

    const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
    const uintptr_t _Ptr_container   = _Ptr_user[-1];

    
    
     ;

    
    



    constexpr uintptr_t _Min_back_shift = sizeof(void*);
#line 163 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"
    const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
    do { if (_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size) { } else { do {; ::_invalid_parameter_noinfo_noreturn(); } while (false); }; } while (false) ;
    _Ptr = reinterpret_cast<void*>(_Ptr_container);
}
#line 168 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"


template <size_t _Align, class _Traits = _Default_allocate_traits,
    enable_if_t<(_Align > 16ull ), int> = 0>
__declspec(allocator) constexpr void* _Allocate(const size_t _Bytes) {
    
    if (_Bytes == 0) {
        return nullptr;
    }


    if (::std:: is_constant_evaluated()) {
        return _Traits::_Allocate(_Bytes);
    } else
#line 183 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"
    {
        size_t _Passed_align = _Align;

        if (_Bytes >= _Big_allocation_threshold) {
            
            _Passed_align = (::std:: max)(_Align, _Big_allocation_alignment);
        }
#line 191 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"
        return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
    }
}

template <size_t _Align, enable_if_t<(_Align > 16ull ), int> = 0>
constexpr void _Deallocate(void* _Ptr, const size_t _Bytes) noexcept {
    

    if (::std:: is_constant_evaluated()) {
        ::operator delete(_Ptr);
    } else
#line 203 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"
    {
        size_t _Passed_align = _Align;

        if (_Bytes >= _Big_allocation_threshold) { 
            _Passed_align = (::std:: max)(_Align, _Big_allocation_alignment);
        }
#line 210 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"
        ::operator delete(_Ptr, _Bytes, align_val_t{_Passed_align});
    }
}




#line 218 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"

template <size_t _Align, class _Traits = _Default_allocate_traits,
    enable_if_t<(!1 || _Align <= 16ull ), int> = 0>
__declspec(allocator) constexpr void* _Allocate(const size_t _Bytes) {
    


    if (!::std:: is_constant_evaluated())
#line 227 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"
    {
        if (_Bytes >= _Big_allocation_threshold) { 
            return _Allocate_manually_vector_aligned<_Traits>(_Bytes);
        }
    }
#line 233 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"

    if (_Bytes != 0) {
        return _Traits::_Allocate(_Bytes);
    }

    return nullptr;
}

template <size_t _Align, enable_if_t<(!1 || _Align <= 16ull ), int> = 0>
constexpr void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {
    

    if (::std:: is_constant_evaluated()) {
        ::operator delete(_Ptr);
    } else
#line 249 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"
    {

        if (_Bytes >= _Big_allocation_threshold) { 
            _Adjust_manually_vector_aligned(_Ptr, _Bytes);
        }
#line 255 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"
        ::operator delete(_Ptr, _Bytes);
    }
}



template <class _Ty, class... _Types>
_Ty* _Global_new(_Types&&... _Args) { 
    struct [[nodiscard]] _Guard_type {
        void* _Result;
        ~_Guard_type() {
            if (_Result) {
                _Deallocate<_New_alignof<_Ty>>(_Result, sizeof(_Ty));
            }
        }
    };

    _Guard_type _Guard{_Allocate<_New_alignof<_Ty>>(sizeof(_Ty))};
    ::new (_Guard._Result) _Ty(::std:: forward<_Types>(_Args)...);
    return static_cast<_Ty*>(::std:: exchange(_Guard._Result, nullptr));
}

template <class _Ptr, class _Ty>
using _Rebind_pointer_t = typename pointer_traits<_Ptr>::template rebind<_Ty>;

template <class _Pointer, enable_if_t<!is_pointer_v<_Pointer>, int> = 0>
constexpr _Pointer _Refancy(typename pointer_traits<_Pointer>::element_type* _Ptr) noexcept {
    return pointer_traits<_Pointer>::pointer_to(*_Ptr);
}

template <class _Pointer, enable_if_t<is_pointer_v<_Pointer>, int> = 0>
constexpr _Pointer _Refancy(_Pointer _Ptr) noexcept {
    return _Ptr;
}

template <class _NoThrowFwdIt, class _NoThrowSentinel>
constexpr void _Destroy_range(_NoThrowFwdIt _First, _NoThrowSentinel _Last) noexcept;

template <class _Ty>
constexpr void _Destroy_in_place(_Ty& _Obj) noexcept {
    if constexpr (is_array_v<_Ty>) {
        _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
    } else {
        _Obj.~_Ty();
    }
}


 template <class _Ty>
constexpr void destroy_at(_Ty* const _Location) noexcept   {

    if constexpr (is_array_v<_Ty>) {
        _Destroy_range(::std:: begin(*_Location), ::std:: end(*_Location));
    } else
#line 310 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"
    {
        _Location->~_Ty();
    }
}
#line 315 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"

template <class _Ptrty>
auto _Const_cast(_Ptrty _Ptr) noexcept { 
    using _Elem       = typename pointer_traits<_Ptrty>::element_type;
    using _Modifiable = remove_const_t<_Elem>;
    using _Dest       = typename pointer_traits<_Ptrty>::template rebind<_Modifiable>;

    return pointer_traits<_Dest>::pointer_to(const_cast<_Modifiable&>(*_Ptr));
}

template <class _Ty>
auto _Const_cast(_Ty* _Ptr) noexcept {
    return const_cast<remove_const_t<_Ty>*>(_Ptr);
}

template <class _Ty, class = void>
struct _Get_pointer_type {
    using type = typename _Ty::value_type*;
};

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ty>
struct _Get_pointer_type<_Ty, void_t<typename _Ty::pointer>> {
    using type = typename _Ty::pointer;
};
__pragma(warning(pop))

template <class _Ty, class = void>
struct _Get_const_pointer_type {
    using _Ptrty = typename _Get_pointer_type<_Ty>::type;
    using _Valty = typename _Ty::value_type;
    using type   = typename pointer_traits<_Ptrty>::template rebind<const _Valty>;
};

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ty>
struct _Get_const_pointer_type<_Ty, void_t<typename _Ty::const_pointer>> {
    using type = typename _Ty::const_pointer;
};
__pragma(warning(pop))

template <class _Ty, class = void>
struct _Get_void_pointer_type {
    using _Ptrty = typename _Get_pointer_type<_Ty>::type;
    using type   = typename pointer_traits<_Ptrty>::template rebind<void>;
};

template <class _Ty>
struct _Get_void_pointer_type<_Ty, void_t<typename _Ty::void_pointer>> {
    using type = typename _Ty::void_pointer;
};

template <class _Ty, class = void>
struct _Get_const_void_pointer_type {
    using _Ptrty = typename _Get_pointer_type<_Ty>::type;
    using type   = typename pointer_traits<_Ptrty>::template rebind<const void>;
};

template <class _Ty>
struct _Get_const_void_pointer_type<_Ty, void_t<typename _Ty::const_void_pointer>> {
    using type = typename _Ty::const_void_pointer;
};

template <class _Ty, class = void>
struct _Get_difference_type {
    using _Ptrty = typename _Get_pointer_type<_Ty>::type;
    using type   = typename pointer_traits<_Ptrty>::difference_type;
};

template <class _Ty>
struct _Get_difference_type<_Ty, void_t<typename _Ty::difference_type>> {
    using type = typename _Ty::difference_type;
};

template <class _Ty, class = void>
struct _Get_size_type {
    using type = make_unsigned_t<typename _Get_difference_type<_Ty>::type>;
};

template <class _Ty>
struct _Get_size_type<_Ty, void_t<typename _Ty::size_type>> {
    using type = typename _Ty::size_type;
};

template <class _Ty, class = void>
struct _Get_propagate_on_container_copy {
    using type = false_type;
};

template <class _Ty>
struct _Get_propagate_on_container_copy<_Ty, void_t<typename _Ty::propagate_on_container_copy_assignment>> {
    using type = typename _Ty::propagate_on_container_copy_assignment;
};

template <class _Ty, class = void>
struct _Get_propagate_on_container_move {
    using type = false_type;
};

template <class _Ty>
struct _Get_propagate_on_container_move<_Ty, void_t<typename _Ty::propagate_on_container_move_assignment>> {
    using type = typename _Ty::propagate_on_container_move_assignment;
};

template <class _Ty, class = void>
struct _Get_propagate_on_container_swap {
    using type = false_type;
};

template <class _Ty>
struct _Get_propagate_on_container_swap<_Ty, void_t<typename _Ty::propagate_on_container_swap>> {
    using type = typename _Ty::propagate_on_container_swap;
};

template <class _Ty, class = void>
struct _Get_is_always_equal {
    using type = bool_constant<is_empty_v<_Ty>>;
};

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ty>
struct _Get_is_always_equal<_Ty, void_t<typename _Ty::is_always_equal>> {
    using type = typename _Ty::is_always_equal;
};
__pragma(warning(pop))

template <class _Ty, class _Other, class = void>
struct _Get_rebind_type {
    using type = typename _Replace_first_parameter<_Other, _Ty>::type;
};

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ty, class _Other>
struct _Get_rebind_type<_Ty, _Other, void_t<typename _Ty::template rebind<_Other>::other>> {
    using type = typename _Ty::template rebind<_Other>::other;
};
__pragma(warning(pop))

 template <class _Ty>
class allocator;

template <class _Alloc, class = void>
struct _Is_default_allocator : false_type {};

template <class _Ty>
struct _Is_default_allocator<allocator<_Ty>, void_t<typename allocator<_Ty>::_From_primary>>
    : is_same<typename allocator<_Ty>::_From_primary, allocator<_Ty>>::type {};

template <class _Void, class... _Types>
struct _Has_no_allocator_construct : true_type {};

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Alloc, class _Ptr, class... _Args>
struct _Has_no_allocator_construct<
    void_t<decltype(::std:: declval<_Alloc&>().construct(::std:: declval<_Ptr>(), ::std:: declval<_Args>()...))>, _Alloc, _Ptr,
    _Args...> : false_type {};
__pragma(warning(pop))

template <class _Alloc, class _Ptr, class... _Args>
using _Uses_default_construct =
    disjunction<_Is_default_allocator<_Alloc>, _Has_no_allocator_construct<void, _Alloc, _Ptr, _Args...>>;

template <class _Alloc, class _Ptr, class = void>
struct _Has_no_alloc_destroy : true_type {};

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Alloc, class _Ptr>
struct _Has_no_alloc_destroy<_Alloc, _Ptr, void_t<decltype(::std:: declval<_Alloc&>().destroy(::std:: declval<_Ptr>()))>>
    : false_type {};
__pragma(warning(pop))

template <class _Alloc, class _Ptr>
using _Uses_default_destroy = disjunction<_Is_default_allocator<_Alloc>, _Has_no_alloc_destroy<_Alloc, _Ptr>>;

template <class _Alloc, class _Size_type, class _Const_void_pointer, class = void>
struct _Has_allocate_hint : false_type {};

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Alloc, class _Size_type, class _Const_void_pointer>
struct _Has_allocate_hint<_Alloc, _Size_type, _Const_void_pointer,
    void_t<decltype(::std:: declval<_Alloc&>().allocate(
        ::std:: declval<const _Size_type&>(), ::std:: declval<const _Const_void_pointer&>()))>> : true_type {};
__pragma(warning(pop))

template <class _Alloc, class = void>
struct _Has_max_size : false_type {};

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Alloc>
struct _Has_max_size<_Alloc, void_t<decltype(::std:: declval<const _Alloc&>().max_size())>> : true_type {};
__pragma(warning(pop))

template <class _Alloc, class = void>
struct _Has_select_on_container_copy_construction : false_type {};

template <class _Alloc>
struct _Has_select_on_container_copy_construction<_Alloc,
    void_t<decltype(::std:: declval<const _Alloc&>().select_on_container_copy_construction())>> : true_type {};

 template <class _Alloc>
struct allocator_traits;

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Alloc>
struct _Normal_allocator_traits { 
    using allocator_type = _Alloc;
    using value_type     = typename _Alloc::value_type;

    using pointer            = typename _Get_pointer_type<_Alloc>::type;
    using const_pointer      = typename _Get_const_pointer_type<_Alloc>::type;
    using void_pointer       = typename _Get_void_pointer_type<_Alloc>::type;
    using const_void_pointer = typename _Get_const_void_pointer_type<_Alloc>::type;

    using size_type       = typename _Get_size_type<_Alloc>::type;
    using difference_type = typename _Get_difference_type<_Alloc>::type;

    using propagate_on_container_copy_assignment = typename _Get_propagate_on_container_copy<_Alloc>::type;
    using propagate_on_container_move_assignment = typename _Get_propagate_on_container_move<_Alloc>::type;
    using propagate_on_container_swap            = typename _Get_propagate_on_container_swap<_Alloc>::type;
    using is_always_equal                        = typename _Get_is_always_equal<_Alloc>::type;

    template <class _Other>
    using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;

    template <class _Other>
    using rebind_traits = allocator_traits<rebind_alloc<_Other>>;

    [[nodiscard("This function allocates memory and returns a raw pointer. " "Discarding the return value will cause a memory leak.")]] static constexpr __declspec(allocator) pointer
        allocate(_Alloc& _Al,  const size_type _Count) {
        return _Al.allocate(_Count);
    }

    [[nodiscard("This function allocates memory and returns a raw pointer. " "Discarding the return value will cause a memory leak.")]] static constexpr __declspec(allocator) pointer
        allocate(_Alloc& _Al,  const size_type _Count, const const_void_pointer _Hint) {
        if constexpr (_Has_allocate_hint<_Alloc, size_type, const_void_pointer>::value) {
            return _Al.allocate(_Count, _Hint);
        } else {
            return _Al.allocate(_Count);
        }
    }

    static constexpr void deallocate(_Alloc& _Al, pointer _Ptr, size_type _Count) {
        _Al.deallocate(_Ptr, _Count);
    }

    template <class _Ty, class... _Types>
    static constexpr void construct(_Alloc& _Al, _Ty* _Ptr, _Types&&... _Args) {
        if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {

            ::std:: construct_at(_Ptr, ::std:: forward<_Types>(_Args)...);


#line 568 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"
        } else {
            _Al.construct(_Ptr, ::std:: forward<_Types>(_Args)...);
        }
    }

    template <class _Ty>
    static constexpr void destroy(_Alloc& _Al, _Ty* _Ptr) {
        if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {

            ::std:: destroy_at(_Ptr);


#line 581 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"
        } else {
            _Al.destroy(_Ptr);
        }
    }

    [[nodiscard]] static constexpr size_type max_size(const _Alloc& _Al) noexcept {
        if constexpr (_Has_max_size<_Alloc>::value) {
            return _Al.max_size();
        } else {
            return (numeric_limits<size_type>::max)() / sizeof(value_type);
        }
    }

    [[nodiscard]] static constexpr _Alloc select_on_container_copy_construction(const _Alloc& _Al) {
        if constexpr (_Has_select_on_container_copy_construction<_Alloc>::value) {
            return _Al.select_on_container_copy_construction();
        } else {
            return _Al;
        }
    }
};
__pragma(warning(pop))

template <class _Alloc>
struct _Default_allocator_traits { 
    using allocator_type = _Alloc;
    using value_type     = typename _Alloc::value_type;

    using pointer            = value_type*;
    using const_pointer      = const value_type*;
    using void_pointer       = void*;
    using const_void_pointer = const void*;

    using size_type       = size_t;
    using difference_type = ptrdiff_t;

    using propagate_on_container_copy_assignment = false_type;
    using propagate_on_container_move_assignment = true_type;
    using propagate_on_container_swap            = false_type;
    using is_always_equal                        = true_type;

    template <class _Other>
    using rebind_alloc = allocator<_Other>;

    template <class _Other>
    using rebind_traits = allocator_traits<allocator<_Other>>;

    [[nodiscard("This function allocates memory and returns a raw pointer. " "Discarding the return value will cause a memory leak.")]] static constexpr __declspec(allocator) pointer
        allocate(_Alloc& _Al,  const size_type _Count) {

        if (::std:: is_constant_evaluated()) {
            return _Al.allocate(_Count);
        } else
#line 635 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"
        {
            (void) _Al;
            return static_cast<pointer>(
                _Allocate<_New_alignof<value_type>>(_Get_size_of_n<sizeof(value_type)>(_Count)));
        }
    }

    [[nodiscard("This function allocates memory and returns a raw pointer. " "Discarding the return value will cause a memory leak.")]] static constexpr __declspec(allocator) pointer
        allocate(_Alloc& _Al,  const size_type _Count, const_void_pointer) {

        if (::std:: is_constant_evaluated()) {
            return _Al.allocate(_Count);
        } else
#line 649 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"
        {
            (void) _Al;
            return static_cast<pointer>(
                _Allocate<_New_alignof<value_type>>(_Get_size_of_n<sizeof(value_type)>(_Count)));
        }
    }

    static constexpr void deallocate(_Alloc& _Al, const pointer _Ptr, const size_type _Count) {
        

        if (::std:: is_constant_evaluated()) {
            _Al.deallocate(_Ptr, _Count);
        } else
#line 663 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"
        {
            (void) _Al;
            _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);
        }
    }

    template <class _Objty, class... _Types>
    static constexpr void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

        if (::std:: is_constant_evaluated()) {
            ::std:: construct_at(_Ptr, ::std:: forward<_Types>(_Args)...);
        } else
#line 676 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"
        {
            ::new (_Voidify_iter(_Ptr)) _Objty(::std:: forward<_Types>(_Args)...);
        }
    }

    template <class _Uty>
    static constexpr void destroy(_Alloc&, _Uty* const _Ptr) {

        ::std:: destroy_at(_Ptr);


#line 688 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"
    }

    [[nodiscard]] static constexpr size_type max_size(const _Alloc&) noexcept {
        return static_cast<size_t>(-1) / sizeof(value_type);
    }

    [[nodiscard]] static constexpr _Alloc select_on_container_copy_construction(const _Alloc& _Al) {
        return _Al;
    }
};

 template <class _Alloc>
struct allocator_traits : conditional_t<_Is_default_allocator<_Alloc>::value, _Default_allocator_traits<_Alloc>,
                              _Normal_allocator_traits<_Alloc>> {};



template <class _Alloc>
inline constexpr bool _Choose_pocca_v = allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value
                                          && !allocator_traits<_Alloc>::is_always_equal::value;

enum class _Pocma_values {
    _Equal_allocators, 
    _Propagate_allocators, 
    _No_propagate_allocators, 
};

template <class _Alloc>
inline constexpr _Pocma_values _Choose_pocma_v =
    allocator_traits<_Alloc>::is_always_equal::value
        ? _Pocma_values::_Equal_allocators
        : (allocator_traits<_Alloc>::propagate_on_container_move_assignment::value
                ? _Pocma_values::_Propagate_allocators
                : _Pocma_values::_No_propagate_allocators);

template <class _Alloc, class _Value_type>
using _Rebind_alloc_t = typename allocator_traits<_Alloc>::template rebind_alloc<_Value_type>;



template <class _Alloc, class _Value_type>
using _Maybe_rebind_alloc_t =
    typename _Select<is_same_v<typename _Alloc::value_type, _Value_type>>::template _Apply<_Alloc&,
        _Rebind_alloc_t<_Alloc, _Value_type>>;

template <class _Alloc> 
inline constexpr bool _Is_simple_alloc_v =
    is_same_v<typename allocator_traits<_Alloc>::size_type, size_t>
    && is_same_v<typename allocator_traits<_Alloc>::difference_type, ptrdiff_t>
    && is_same_v<typename allocator_traits<_Alloc>::pointer, typename _Alloc::value_type*>
    && is_same_v<typename allocator_traits<_Alloc>::const_pointer, const typename _Alloc::value_type*>;

template <class _Value_type>
struct _Simple_types { 
                       
    using value_type      = _Value_type;
    using size_type       = size_t;
    using difference_type = ptrdiff_t;
    using pointer         = value_type*;
    using const_pointer   = const value_type*;
};






















#line 772 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"


inline constexpr size_t _Asan_granularity      = 8;
inline constexpr size_t _Asan_granularity_mask = _Asan_granularity - 1;

struct _Asan_aligned_pointers {
    const void* _First;
    const void* _End;

    [[nodiscard]] constexpr const void* _Clamp_to_end(const void* _Mid) const noexcept {
         ;
        if (_Mid > _End) {
            return _End;
        } else {
            return _Mid;
        }
    }
};

















































































[[nodiscard]] inline _Asan_aligned_pointers _Get_asan_aligned_first_end(
    const void* const _First, const void* const _End) noexcept {
    return {
        reinterpret_cast<const void*>(reinterpret_cast<uintptr_t>(_First) & ~_Asan_granularity_mask),
        reinterpret_cast<const void*>(reinterpret_cast<uintptr_t>(_End) & ~_Asan_granularity_mask),
    };
}




[[nodiscard]] inline const void* _Get_asan_aligned_after(const void* const _End) noexcept {
    return reinterpret_cast<const void*>(
        (reinterpret_cast<uintptr_t>(_End) + _Asan_granularity_mask) & ~_Asan_granularity_mask);
}

template <class _Container, class = void>
inline constexpr size_t _Container_allocation_minimum_asan_alignment = alignof(typename _Container::value_type);

template <class _Container>
inline constexpr size_t _Container_allocation_minimum_asan_alignment<_Container,
    void_t<decltype(_Container::allocator_type::_Minimum_asan_allocation_alignment)>> =
    (::std:: max)(
        alignof(typename _Container::value_type), _Container::allocator_type::_Minimum_asan_allocation_alignment);

 template <class _Ty>
class allocator {
public:
    static_assert(!is_const_v<_Ty>, "The C++ Standard forbids containers of const elements "
                                    "because allocator<const T> is ill-formed.");

    using _From_primary = allocator;

    using value_type = _Ty;







#line 913 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"

    using size_type       = size_t;
    using difference_type = ptrdiff_t;

    using propagate_on_container_move_assignment           = true_type;
    using is_always_equal [[deprecated("warning STL4033: " "std::allocator::is_always_equal is deprecated in C++20 by LWG-3170. " "Prefer std::allocator_traits<allocator<T>>::is_always_equal. " "You can define _SILENCE_CXX20_IS_ALWAYS_EQUAL_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] = true_type;














#line 934 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"

    constexpr allocator() noexcept {}

    constexpr allocator(const allocator&) noexcept = default;
    template <class _Other>
    constexpr allocator(const allocator<_Other>&) noexcept {}
    constexpr ~allocator()                           = default;
    constexpr allocator& operator=(const allocator&) = default;

    constexpr void deallocate(_Ty* const _Ptr, const size_t _Count) {
         ;
        
        _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);
    }

    [[nodiscard("This function allocates memory and returns a raw pointer. " "Discarding the return value will cause a memory leak.")]] constexpr __declspec(allocator) _Ty* allocate( const size_t _Count) {
        static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
        return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
    }






#line 960 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"




















#line 981 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"

    static constexpr size_t _Minimum_asan_allocation_alignment = _Asan_granularity;
};
























#line 1009 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"

 template <class _Ty, class _Other>
[[nodiscard]] constexpr bool operator==(const allocator<_Ty>&, const allocator<_Other>&) noexcept {
    return true;
}






#line 1021 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"



template <class _Alloc>
using _Guide_size_type_t =
    typename allocator_traits<conditional_t<_Is_allocator<_Alloc>::value, _Alloc, allocator<int>>>::size_type;
#line 1028 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"

template <class _Alloc>
using _Alloc_ptr_t = typename allocator_traits<_Alloc>::pointer;

template <class _Alloc>
using _Alloc_size_t = typename allocator_traits<_Alloc>::size_type;

template <class _Alloc>
constexpr void _Pocca(_Alloc& _Left, const _Alloc& _Right) noexcept {
    if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
        _Left = _Right;
    }
}

template <class _Alloc>
constexpr void _Pocma(_Alloc& _Left, _Alloc& _Right) noexcept { 
    if constexpr (allocator_traits<_Alloc>::propagate_on_container_move_assignment::value) {
        _Left = ::std:: move(_Right);
    }
}

template <class _Alloc>
constexpr void _Pocs(_Alloc& _Left, _Alloc& _Right) noexcept {
    if constexpr (allocator_traits<_Alloc>::propagate_on_container_swap::value) {
        _Swap_adl(_Left, _Right);
    } else {
         ;
    }
}

template <class _Alloc>
constexpr void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {
    
    using _Ty = typename _Alloc::value_type;
    if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
        for (; _First != _Last; ++_First) {
            allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
        }
    }
}

template <class _NoThrowFwdIt, class _NoThrowSentinel>
constexpr void _Destroy_range(_NoThrowFwdIt _First, const _NoThrowSentinel _Last) noexcept {
    
    if constexpr (!is_trivially_destructible_v<_Iter_value_t<_NoThrowFwdIt>>) {
        for (; _First != _Last; ++_First) {
            _Destroy_in_place(*_First);
        }
    }
}

template <class _Size_type, class _Unsigned_type>
[[nodiscard]] constexpr _Size_type _Convert_size(const _Unsigned_type _Len) noexcept(
    sizeof(_Unsigned_type) <= sizeof(_Size_type)) {
    
     ;
     ;

    if constexpr (sizeof(_Unsigned_type) > sizeof(_Size_type)) {
        if (_Len > (numeric_limits<_Size_type>::max)()) {
            _Xlength_error("size is too long for _Size_type");
        }
    }

    return static_cast<_Size_type>(_Len);
}

template <class _Alloc>
constexpr void _Deallocate_plain(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {
    
    using _Alloc_traits = allocator_traits<_Alloc>;
    if constexpr (is_same_v<_Alloc_ptr_t<_Alloc>, typename _Alloc::value_type*>) {
        _Alloc_traits::deallocate(_Al, _Ptr, 1);
    } else {
        using _Ptr_traits = pointer_traits<_Alloc_ptr_t<_Alloc>>;
        _Alloc_traits::deallocate(_Al, _Ptr_traits::pointer_to(*_Ptr), 1);
    }
}

template <class _Alloc>
constexpr void _Delete_plain_internal(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {
    
    using _Ty = typename _Alloc::value_type;
    _Ptr->~_Ty();
    _Deallocate_plain(_Al, _Ptr);
}

template <class _Alloc>
struct _Alloc_construct_ptr { 
    using pointer = _Alloc_ptr_t<_Alloc>;
    _Alloc& _Al;
    pointer _Ptr;

    constexpr explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

    [[nodiscard]] constexpr pointer _Release() noexcept { 
        return ::std:: exchange(_Ptr, nullptr);
    }

    constexpr void _Allocate() { 
        _Ptr = nullptr; 
        _Ptr = _Al.allocate(1);
    }

    constexpr ~_Alloc_construct_ptr() { 
        if (_Ptr) {
            _Al.deallocate(_Ptr, 1);
        }
    }

    _Alloc_construct_ptr(const _Alloc_construct_ptr&)            = delete;
    _Alloc_construct_ptr& operator=(const _Alloc_construct_ptr&) = delete;
};

struct _Fake_allocator {};

struct _Container_base0 {
    constexpr void _Orphan_all() noexcept {}
    constexpr void _Swap_proxy_and_iterators(_Container_base0&) noexcept {}
    constexpr void _Alloc_proxy(const _Fake_allocator&) noexcept {}
    constexpr void _Reload_proxy(const _Fake_allocator&, const _Fake_allocator&) noexcept {}
};

struct _Iterator_base0 {
    constexpr void _Adopt(const void*) noexcept {}
    constexpr const _Container_base0* _Getcont() const noexcept {
        return nullptr;
    }

    static constexpr bool _Unwrap_when_unverified = true;
};

struct _Container_base12;
struct _Container_proxy { 
    constexpr _Container_proxy() noexcept = default;
    constexpr _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_) {}

    const _Container_base12* _Mycont       = nullptr;
    mutable _Iterator_base12* _Myfirstiter = nullptr;
};

struct _Container_base12 {
public:
    constexpr _Container_base12() noexcept = default;

    _Container_base12(const _Container_base12&)            = delete;
    _Container_base12& operator=(const _Container_base12&) = delete;

    constexpr void _Orphan_all() noexcept;
    constexpr void _Swap_proxy_and_iterators(_Container_base12&) noexcept;

    template <class _Alloc>
    constexpr void _Alloc_proxy(_Alloc&& _Al) {
        _Container_proxy* const _New_proxy = _Unfancy(_Al.allocate(1));
        _Construct_in_place(*_New_proxy, this);
        _Myproxy            = _New_proxy;
        _New_proxy->_Mycont = this;
    }

    template <class _Alloc>
    constexpr void _Reload_proxy(_Alloc&& _Old_alloc, _Alloc&& _New_alloc) {
        
        _Container_proxy* const _New_proxy = _Unfancy(_New_alloc.allocate(1));
        _Construct_in_place(*_New_proxy, this);
        _New_proxy->_Mycont = this;
        _Delete_plain_internal(_Old_alloc, ::std:: exchange(_Myproxy, _New_proxy));
    }

    _Container_proxy* _Myproxy = nullptr;

private:
    constexpr void _Orphan_all_unlocked_v3() noexcept;
    constexpr void _Swap_proxy_and_iterators_unlocked(_Container_base12&) noexcept;

    void _Orphan_all_locked_v3() noexcept {
        _Lockit _Lock(3 );
        _Orphan_all_unlocked_v3();
    }

    void _Swap_proxy_and_iterators_locked(_Container_base12& _Right) noexcept {
        _Lockit _Lock(3 );
        _Swap_proxy_and_iterators_unlocked(_Right);
    }
};

struct _Iterator_base12 { 
public:
    constexpr _Iterator_base12() noexcept = default; 

    constexpr _Iterator_base12(const _Iterator_base12& _Right) noexcept {
        *this = _Right;
    }

    constexpr _Iterator_base12& operator=(const _Iterator_base12& _Right) noexcept {









#line 1232 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"
        _Myproxy = _Right._Myproxy;
#line 1234 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"
        return *this;
    }























#line 1260 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"
    constexpr void _Adopt(const _Container_base12* _Parent) noexcept {
        if (_Parent) { 
            _Myproxy = _Parent->_Myproxy;
        } else { 
            _Myproxy = nullptr;
        }
    }
#line 1268 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"

    constexpr const _Container_base12* _Getcont() const noexcept {
        return _Myproxy ? _Myproxy->_Mycont : nullptr;
    }

    static constexpr bool _Unwrap_when_unverified = 0 == 0;

    mutable _Container_proxy* _Myproxy    = nullptr;
    mutable _Iterator_base12* _Mynextiter = nullptr;






























































#line 1340 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"
};

constexpr void _Container_base12::_Orphan_all_unlocked_v3() noexcept {
    if (!_Myproxy) { 
        return;
    }

    
    for (auto _Pnext = ::std:: exchange(_Myproxy->_Myfirstiter, nullptr); _Pnext; _Pnext = _Pnext->_Mynextiter) {
        _Pnext->_Myproxy = nullptr;
    }
}

constexpr void _Container_base12::_Orphan_all() noexcept {









#line 1364 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"
}

constexpr void _Container_base12::_Swap_proxy_and_iterators_unlocked(_Container_base12& _Right) noexcept {
    _Container_proxy* _Temp = _Myproxy;
    _Myproxy                = _Right._Myproxy;
    _Right._Myproxy         = _Temp;

    if (_Myproxy) {
        _Myproxy->_Mycont = this;
    }

    if (_Right._Myproxy) {
        _Right._Myproxy->_Mycont = &_Right;
    }
}

constexpr void _Container_base12::_Swap_proxy_and_iterators(_Container_base12& _Right) noexcept {









#line 1391 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"
    _Swap_proxy_and_iterators_unlocked(_Right);
#line 1393 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"
}


using _Container_base = _Container_base0;
using _Iterator_base  = _Iterator_base0;



#line 1402 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"

struct _Leave_proxy_unbound {
    explicit _Leave_proxy_unbound() = default;
}; 

struct _Fake_proxy_ptr_impl { 
    _Fake_proxy_ptr_impl(const _Fake_proxy_ptr_impl&)            = delete;
    _Fake_proxy_ptr_impl& operator=(const _Fake_proxy_ptr_impl&) = delete;
    constexpr _Fake_proxy_ptr_impl(const _Fake_allocator&, _Leave_proxy_unbound) noexcept {}
    constexpr _Fake_proxy_ptr_impl(const _Fake_allocator&, const _Container_base0&) noexcept {}

    constexpr void _Bind(const _Fake_allocator&, _Container_base0*) noexcept {}
    constexpr void _Release() noexcept {}
};

struct _Basic_container_proxy_ptr12 {
    
    _Container_proxy* _Ptr = nullptr;

    constexpr void _Release() noexcept { 
        _Ptr = nullptr;
    }

protected:
    constexpr _Basic_container_proxy_ptr12()                       = default;
    _Basic_container_proxy_ptr12(const _Basic_container_proxy_ptr12&) = delete;
    _Basic_container_proxy_ptr12(_Basic_container_proxy_ptr12&&)      = delete;
};

template <class _Alloc>
struct _Container_proxy_ptr12 : _Basic_container_proxy_ptr12 {
    
    _Alloc& _Al;

    constexpr _Container_proxy_ptr12(_Alloc& _Al_, _Leave_proxy_unbound) : _Al(_Al_) {
        
        _Ptr = _Unfancy(_Al_.allocate(1));
        _Construct_in_place(*_Ptr);
    }

    constexpr _Container_proxy_ptr12(_Alloc& _Al_, _Container_base12& _Mycont) : _Al(_Al_) {
        
        _Ptr = _Unfancy(_Al_.allocate(1));
        _Construct_in_place(*_Ptr, ::std:: addressof(_Mycont));
        _Mycont._Myproxy = _Ptr;
    }

    constexpr void _Bind(_Alloc& _Old_alloc, _Container_base12* _Mycont) noexcept {
        
        
        _Ptr->_Mycont = _Mycont;
        _Delete_plain_internal(_Old_alloc, ::std:: exchange(_Mycont->_Myproxy, ::std:: exchange(_Ptr, nullptr)));
    }

    constexpr ~_Container_proxy_ptr12() {
        if (_Ptr) {
            _Delete_plain_internal(_Al, _Ptr);
        }
    }
};


inline constexpr _Fake_allocator _Fake_alloc{};

template <class _Alloc>
using _Container_proxy_ptr = _Fake_proxy_ptr_impl;




#line 1473 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"

struct _Zero_then_variadic_args_t {
    explicit _Zero_then_variadic_args_t() = default;
}; 

struct _One_then_variadic_args_t {
    explicit _One_then_variadic_args_t() = default;
}; 

template <class _Ty1, class _Ty2, bool = is_empty_v<_Ty1> && !is_final_v<_Ty1>>
class _Compressed_pair final : private _Ty1 { 
public:
    _Ty2 _Myval2;

    using _Mybase = _Ty1; 

    template <class... _Other2>
    constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t, _Other2&&... _Val2) noexcept(
        conjunction_v<is_nothrow_default_constructible<_Ty1>, is_nothrow_constructible<_Ty2, _Other2...>>)
        : _Ty1(), _Myval2(::std:: forward<_Other2>(_Val2)...) {}

    template <class _Other1, class... _Other2>
    constexpr _Compressed_pair(_One_then_variadic_args_t, _Other1&& _Val1, _Other2&&... _Val2) noexcept(
        conjunction_v<is_nothrow_constructible<_Ty1, _Other1>, is_nothrow_constructible<_Ty2, _Other2...>>)
        : _Ty1(::std:: forward<_Other1>(_Val1)), _Myval2(::std:: forward<_Other2>(_Val2)...) {}

    constexpr _Ty1& _Get_first() noexcept {
        return *this;
    }

    constexpr const _Ty1& _Get_first() const noexcept {
        return *this;
    }
};

template <class _Ty1, class _Ty2>
class _Compressed_pair<_Ty1, _Ty2, false> final { 
public:
    _Ty1 _Myval1;
    _Ty2 _Myval2;

    template <class... _Other2>
    constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t, _Other2&&... _Val2) noexcept(
        conjunction_v<is_nothrow_default_constructible<_Ty1>, is_nothrow_constructible<_Ty2, _Other2...>>)
        : _Myval1(), _Myval2(::std:: forward<_Other2>(_Val2)...) {}

    template <class _Other1, class... _Other2>
    constexpr _Compressed_pair(_One_then_variadic_args_t, _Other1&& _Val1, _Other2&&... _Val2) noexcept(
        conjunction_v<is_nothrow_constructible<_Ty1, _Other1>, is_nothrow_constructible<_Ty2, _Other2...>>)
        : _Myval1(::std:: forward<_Other1>(_Val1)), _Myval2(::std:: forward<_Other2>(_Val2)...) {}

    constexpr _Ty1& _Get_first() noexcept {
        return _Myval1;
    }

    constexpr const _Ty1& _Get_first() const noexcept {
        return _Myval1;
    }
};

struct _Move_allocator_tag {
    explicit _Move_allocator_tag() = default;
};

template <class _Ty>
pair<_Ty*, ptrdiff_t> _Get_temporary_buffer(ptrdiff_t _Count) noexcept {
    if (static_cast<size_t>(_Count) <= static_cast<size_t>(-1) / sizeof(_Ty)) {
        for (; 0 < _Count; _Count /= 2) {
            const auto _Size = static_cast<size_t>(_Count) * sizeof(_Ty);
            void* _Pbuf;

            if constexpr (alignof(_Ty) > 16ull ) {
                _Pbuf = ::operator new(_Size, align_val_t{alignof(_Ty)}, nothrow);
            } else
#line 1548 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"
            {
                _Pbuf = ::operator new(_Size, nothrow);
            }

            if (_Pbuf) {
                return {static_cast<_Ty*>(_Pbuf), _Count};
            }
        }
    }

    return {nullptr, 0};
}

template <class _Ty>
void _Return_temporary_buffer(_Ty* const _Pbuf) noexcept {

    if constexpr (alignof(_Ty) > 16ull ) {
        ::operator delete(_Pbuf, align_val_t{alignof(_Ty)});
    } else
#line 1568 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"
    {
        ::operator delete(_Pbuf);
    }
}

template <class _NoThrowFwdIt>
struct [[nodiscard]] _Uninitialized_backout {
    
    _NoThrowFwdIt _First;
    _NoThrowFwdIt _Last;

    constexpr explicit _Uninitialized_backout(_NoThrowFwdIt _Dest) : _First(_Dest), _Last(_Dest) {}

    constexpr _Uninitialized_backout(_NoThrowFwdIt _First_, _NoThrowFwdIt _Last_) : _First(_First_), _Last(_Last_) {}

    _Uninitialized_backout(const _Uninitialized_backout&)            = delete;
    _Uninitialized_backout& operator=(const _Uninitialized_backout&) = delete;

    constexpr ~_Uninitialized_backout() {
        _Destroy_range(_First, _Last);
    }

    template <class... _Types>
    constexpr void _Emplace_back(_Types&&... _Vals) {
        
        _Construct_in_place(*_Last, ::std:: forward<_Types>(_Vals)...);
        ++_Last;
    }

    constexpr _NoThrowFwdIt _Release() { 
        _First = _Last;
        return _Last;
    }
};

template <class _InIt, class _NoThrowFwdIt>
constexpr _NoThrowFwdIt _Uninitialized_move_unchecked(_InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {
    
    if constexpr (_Iter_move_cat<_InIt, _NoThrowFwdIt>::_Bitcopy_constructible) {

        if (!::std:: is_constant_evaluated())
#line 1610 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"
        {
            return _Copy_memmove(_First, _Last, _Dest);
        }
    }
    _Uninitialized_backout<_NoThrowFwdIt> _Backout{_Dest};
    for (; _First != _Last; ++_First) {
        _Backout._Emplace_back(::std:: move(*_First));
    }

    return _Backout._Release();
}


namespace ranges {
    template <class _It>
    concept _No_throw_input_iterator = input_iterator<_It> 
                                    && is_lvalue_reference_v<iter_reference_t<_It>> 
                                    && same_as<remove_cvref_t<iter_reference_t<_It>>, iter_value_t<_It>>;

    template <class _Se, class _It>
    concept _No_throw_sentinel_for = sentinel_for<_Se, _It>;

    template <class _It>
    concept _No_throw_forward_iterator = _No_throw_input_iterator<_It> 
                                      && forward_iterator<_It> 
                                      && _No_throw_sentinel_for<_It, _It>;

    template <class _Rng>
    concept _No_throw_input_range = range<_Rng> 
                                 && _No_throw_input_iterator<iterator_t<_Rng>> 
                                 && _No_throw_sentinel_for<sentinel_t<_Rng>, iterator_t<_Rng>>;

    template <class _Rng>
    concept _No_throw_forward_range = _No_throw_input_range<_Rng> 
                                   && _No_throw_forward_iterator<iterator_t<_Rng>>;

    template <class _InIt, class _OutIt>
    in_out_result<_InIt, _OutIt> _Copy_memcpy_count(_InIt _IFirst, _OutIt _OFirst, const size_t _Count) noexcept {
        const auto _IFirstPtr     = _To_address(_IFirst);
        const auto _OFirstPtr     = _To_address(_OFirst);
        const auto _IFirst_ch     = const_cast<char*>(reinterpret_cast<const volatile char*>(_IFirstPtr));
        const auto _OFirst_ch     = const_cast<char*>(reinterpret_cast<const volatile char*>(_OFirstPtr));
        const size_t _Count_bytes = _Count * sizeof(iter_value_t<_InIt>);
        :: memcpy(_OFirst_ch, _IFirst_ch, _Count_bytes);
        if constexpr (is_pointer_v<_InIt>) {
            _IFirst = reinterpret_cast<_InIt>(_IFirst_ch + _Count_bytes);
        } else {
            _IFirst += static_cast<iter_difference_t<_InIt>>(_Count);
        }

        if constexpr (is_pointer_v<_OutIt>) {
            _OFirst = reinterpret_cast<_OutIt>(_OFirst_ch + _Count_bytes);
        } else {
            _OFirst += static_cast<iter_difference_t<_OutIt>>(_Count);
        }
        return {::std:: move(_IFirst), ::std:: move(_OFirst)};
    }

    template <class _InIt, class _OutIt, class _DistIt>
    in_out_result<_InIt, _OutIt> _Copy_memcpy_distance(
        _InIt _IFirst, _OutIt _OFirst, const _DistIt _DFirst, const _DistIt _DLast) noexcept {
        
        const auto _IFirstPtr   = _To_address(_IFirst);
        const auto _OFirstPtr   = _To_address(_OFirst);
        const auto _DFirstPtr   = _To_address(_DFirst);
        const auto _DLastPtr    = _To_address(_DLast);
        const auto _IFirst_ch   = const_cast<char*>(reinterpret_cast<const volatile char*>(_IFirstPtr));
        const auto _OFirst_ch   = const_cast<char*>(reinterpret_cast<const volatile char*>(_OFirstPtr));
        const auto _DFirst_ch   = const_cast<char*>(reinterpret_cast<const volatile char*>(_DFirstPtr));
        const auto _DLast_ch    = const_cast<char*>(reinterpret_cast<const volatile char*>(_DLastPtr));
        const auto _Count_bytes = static_cast<size_t>(_DLast_ch - _DFirst_ch);
        :: memcpy(_OFirst_ch, _IFirst_ch, _Count_bytes);
        if constexpr (is_pointer_v<_InIt>) {
            _IFirst = reinterpret_cast<_InIt>(_IFirst_ch + _Count_bytes);
        } else {
            _IFirst += _Count_bytes / sizeof(iter_value_t<_InIt>);
        }

        if constexpr (is_pointer_v<_OutIt>) {
            _OFirst = reinterpret_cast<_OutIt>(_OFirst_ch + _Count_bytes);
        } else {
            _OFirst += _Count_bytes / sizeof(iter_value_t<_OutIt>);
        }
        return {::std:: move(_IFirst), ::std:: move(_OFirst)};
    }

    template <class _InIt, class _OutIt>
    in_out_result<_InIt, _OutIt> _Copy_memcpy_common(
        _InIt _IFirst, _InIt _ILast, _OutIt _OFirst, _OutIt _OLast) noexcept {
        const auto _IFirstPtr   = _To_address(_IFirst);
        const auto _ILastPtr    = _To_address(_ILast);
        const auto _OFirstPtr   = _To_address(_OFirst);
        const auto _OLastPtr    = _To_address(_OLast);
        const auto _IFirst_ch   = const_cast<char*>(reinterpret_cast<const volatile char*>(_IFirstPtr));
        const auto _ILast_ch    = const_cast<const char*>(reinterpret_cast<const volatile char*>(_ILastPtr));
        const auto _OFirst_ch   = const_cast<char*>(reinterpret_cast<const volatile char*>(_OFirstPtr));
        const auto _OLast_ch    = const_cast<const char*>(reinterpret_cast<const volatile char*>(_OLastPtr));
        const auto _Count_bytes = static_cast<size_t>((::std:: min)(_ILast_ch - _IFirst_ch, _OLast_ch - _OFirst_ch));
        :: memcpy(_OFirst_ch, _IFirst_ch, _Count_bytes);
        if constexpr (is_pointer_v<_InIt>) {
            _IFirst = reinterpret_cast<_InIt>(_IFirst_ch + _Count_bytes);
        } else {
            _IFirst += static_cast<iter_difference_t<_InIt>>(_Count_bytes / sizeof(iter_value_t<_InIt>));
        }

        if constexpr (is_pointer_v<_OutIt>) {
            _OFirst = reinterpret_cast<_OutIt>(_OFirst_ch + _Count_bytes);
        } else {
            _OFirst += static_cast<iter_difference_t<_OutIt>>(_Count_bytes / sizeof(iter_value_t<_OutIt>));
        }
        return {::std:: move(_IFirst), ::std:: move(_OFirst)};
    }

     template <class _In, class _Out>
    using uninitialized_move_result = in_out_result<_In, _Out>;

    template <input_iterator _It, sentinel_for<_It> _Se, _No_throw_forward_iterator _Out,
        _No_throw_sentinel_for<_Out> _OSe>
        requires (constructible_from<iter_value_t<_Out>, iter_rvalue_reference_t<_It>>)
    uninitialized_move_result<_It, _Out> _Uninitialized_move_unchecked(
        _It _IFirst, _Se _ILast, _Out _OFirst, _OSe _OLast) {
        constexpr bool _Is_sized1 = sized_sentinel_for<_Se, _It>;
        constexpr bool _Is_sized2 = sized_sentinel_for<_OSe, _Out>;
        if constexpr (_Iter_move_cat<_It, _Out>::_Bitcopy_constructible
                      && _Sized_or_unreachable_sentinel_for<_Se, _It> 
                      && _Sized_or_unreachable_sentinel_for<_OSe, _Out>) {
            if constexpr (_Is_sized1 && _Is_sized2) {
                return _Copy_memcpy_common(_IFirst, ::std::ranges:: next(_IFirst, ::std:: move(_ILast)), _OFirst,
                    ::std::ranges:: next(_OFirst, ::std:: move(_OLast)));
            } else if constexpr (_Is_sized1) {
                return _Copy_memcpy_distance(_IFirst, _OFirst, _IFirst, ::std::ranges:: next(_IFirst, ::std:: move(_ILast)));
            } else if constexpr (_Is_sized2) {
                return _Copy_memcpy_distance(_IFirst, _OFirst, _OFirst, ::std::ranges:: next(_OFirst, ::std:: move(_OLast)));
            } else {
                 ;
            }
        } else {
            _Uninitialized_backout _Backout{::std:: move(_OFirst)};

            for (; _IFirst != _ILast && _Backout._Last != _OLast; ++_IFirst) {
                _Backout._Emplace_back(::std::ranges:: iter_move(_IFirst));
            }

            return {::std:: move(_IFirst), _Backout._Release()};
        }
    }
} 
#line 1758 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"

template <class _Alloc>
class [[nodiscard]] _Uninitialized_backout_al {
    
private:
    using pointer = _Alloc_ptr_t<_Alloc>;

public:
    constexpr _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

    _Uninitialized_backout_al(const _Uninitialized_backout_al&)            = delete;
    _Uninitialized_backout_al& operator=(const _Uninitialized_backout_al&) = delete;

    constexpr ~_Uninitialized_backout_al() {
        _Destroy_range(_First, _Last, _Al);
    }

    template <class... _Types>
    constexpr void _Emplace_back(_Types&&... _Vals) { 
        allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), ::std:: forward<_Types>(_Vals)...);
        ++_Last;
    }

    constexpr pointer _Release() { 
        _First = _Last;
        return _Last;
    }

private:
    pointer _First;
    pointer _Last;
    _Alloc& _Al;
};

template <class _InIt, class _Se, class _Alloc>
constexpr _Alloc_ptr_t<_Alloc> _Uninitialized_copy(
    _InIt _First, _Se _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {
    
    
    using _Ptrval = typename _Alloc::value_type*;


    auto _UFirst = ::std::ranges:: _Unwrap_iter<_Se>(::std:: move(_First));
    auto _ULast  = ::std::ranges:: _Unwrap_sent<_InIt>(::std:: move(_Last));





#line 1808 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"

    constexpr bool _Can_memmove = _Sent_copy_cat<decltype(_UFirst), decltype(_ULast), _Ptrval>::_Bitcopy_constructible
                               && _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>::value;

    if constexpr (_Can_memmove) {

        if (!::std:: is_constant_evaluated())
#line 1816 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"
        {
            if constexpr (is_same_v<decltype(_UFirst), decltype(_ULast)>) {
                _Copy_memmove(_To_address(_UFirst), _To_address(_ULast), _Unfancy(_Dest));
                _Dest += _ULast - _UFirst;
            } else {
                const auto _Count = static_cast<size_t>(_ULast - _UFirst);
                _Copy_memmove_n(_To_address(_UFirst), _Count, _Unfancy(_Dest));
                _Dest += _Count;
            }
            return _Dest;
        }
    }

    _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
    for (; _UFirst != _ULast; ++_UFirst) {
        _Backout._Emplace_back(*_UFirst);
    }

    return _Backout._Release();
}

template <class _InIt, class _Alloc>
constexpr _Alloc_ptr_t<_Alloc> _Uninitialized_copy_n(
    _InIt _First, size_t _Count, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {
    
    
    using _Ptrval = typename _Alloc::value_type*;

    auto _UFirst = _Get_unwrapped(::std:: move(_First));

    constexpr bool _Can_memmove =
        conjunction_v<bool_constant<_Iter_copy_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
            _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>;

    if constexpr (_Can_memmove) {

        if (!::std:: is_constant_evaluated())
#line 1854 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"
        {
            _Copy_memmove_n(_UFirst, _Count, _Unfancy(_Dest));
            _Dest += _Count;
            return _Dest;
        }
    }

    _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
    for (; _Count != 0; ++_UFirst, (void) --_Count) {
        _Backout._Emplace_back(*_UFirst);
    }

    return _Backout._Release();
}

template <class _InIt, class _NoThrowFwdIt>
constexpr _NoThrowFwdIt _Uninitialized_copy_unchecked(_InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {
    
    if constexpr (_Iter_copy_cat<_InIt, _NoThrowFwdIt>::_Bitcopy_constructible) {

        if (!::std:: is_constant_evaluated())
#line 1876 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"
        {
            return _Copy_memmove(_First, _Last, _Dest);
        }
    }

    _Uninitialized_backout<_NoThrowFwdIt> _Backout{_Dest};
    for (; _First != _Last; ++_First) {
        _Backout._Emplace_back(*_First);
    }

    return _Backout._Release();
}

 template <class _InIt, class _NoThrowFwdIt>
_NoThrowFwdIt uninitialized_copy(const _InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _UDest       = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
    _Seek_wrapped(_Dest, _Uninitialized_copy_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}

template <class _InIt, class _Alloc>
constexpr _Alloc_ptr_t<_Alloc> _Uninitialized_move(
    const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {
    
    
    using _Ptrval     = typename _Alloc::value_type*;
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
                      _Uses_default_construct<_Alloc, _Ptrval, decltype(::std:: move(*_UFirst))>>) {

        if (!::std:: is_constant_evaluated())
#line 1913 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"
        {
            _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
            return _Dest + (_ULast - _UFirst);
        }
    }

    _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
    for (; _UFirst != _ULast; ++_UFirst) {
        _Backout._Emplace_back(::std:: move(*_UFirst));
    }

    return _Backout._Release();
}

template <class _Alloc>
constexpr _Alloc_ptr_t<_Alloc> _Uninitialized_fill_n(
    _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, const typename _Alloc::value_type& _Val, _Alloc& _Al) {
    
    using _Ty = typename _Alloc::value_type;
    if constexpr (_Fill_memset_is_safe<_Ty*, _Ty> && _Uses_default_construct<_Alloc, _Ty*, _Ty>::value) {

        if (!::std:: is_constant_evaluated())
#line 1936 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"
        {
            _Fill_memset(_Unfancy(_First), _Val, static_cast<size_t>(_Count));
            return _First + _Count;
        }
    } else if constexpr (_Fill_zero_memset_is_safe<_Ty*, _Ty> && _Uses_default_construct<_Alloc, _Ty*, _Ty>::value) {

        if (!::std:: is_constant_evaluated())
#line 1944 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"
        {
            if (_Is_all_bits_zero(_Val)) {
                _Fill_zero_memset(_Unfancy(_First), static_cast<size_t>(_Count));
                return _First + _Count;
            }
        }
    }

    _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
    for (; 0 < _Count; --_Count) {
        _Backout._Emplace_back(_Val);
    }

    return _Backout._Release();
}

 template <class _NoThrowFwdIt, class _Tval>
void uninitialized_fill(const _NoThrowFwdIt _First, const _NoThrowFwdIt _Last, const _Tval& _Val) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    if constexpr (_Fill_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
        _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
    } else {
        if constexpr (_Fill_zero_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
            if (_Is_all_bits_zero(_Val)) {
                _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
                return;
            }
        }

        _Uninitialized_backout<_Unwrapped_t<const _NoThrowFwdIt&>> _Backout{_UFirst};
        while (_Backout._Last != _ULast) {
            _Backout._Emplace_back(_Val);
        }

        _Backout._Release();
    }
}

template <class _NoThrowFwdIt>
inline constexpr bool _Use_memset_value_construct_v =
    conjunction_v<bool_constant<_Iterator_is_contiguous<_NoThrowFwdIt>>, is_scalar<_Iter_value_t<_NoThrowFwdIt>>,
        negation<is_volatile<remove_reference_t<_Iter_ref_t<_NoThrowFwdIt>>>>,
        negation<is_member_pointer<_Iter_value_t<_NoThrowFwdIt>>>>;

template <class _Ptr>
_Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { 
    char* const _First_ch = reinterpret_cast<char*>(_To_address(_First));
    char* const _Last_ch  = reinterpret_cast<char*>(_To_address(_Last));
    :: memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));
    return _Last;
}

template <class _Alloc>
constexpr _Alloc_ptr_t<_Alloc> _Uninitialized_value_construct_n(
    _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {
    
    using _Ptrty = typename _Alloc::value_type*;
    if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {

        if (!::std:: is_constant_evaluated())
#line 2008 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"
        {
            auto _PFirst = _Unfancy(_First);
            _Zero_range(_PFirst, _PFirst + _Count);
            return _First + _Count;
        }
    }

    _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
    for (; 0 < _Count; --_Count) {
        _Backout._Emplace_back();
    }

    return _Backout._Release();
}

template <class _NoThrowFwdIt, class _Diff>
_NoThrowFwdIt _Uninitialized_value_construct_n_unchecked1(_NoThrowFwdIt _UFirst, _Diff _Count) {
    
     ;
    if constexpr (_Use_memset_value_construct_v<_NoThrowFwdIt>) {
        return _Zero_range(_UFirst, _UFirst + _Count);
    } else {
        _Uninitialized_backout<_NoThrowFwdIt> _Backout{_UFirst};
        for (; 0 < _Count; --_Count) {
            _Backout._Emplace_back();
        }

        return _Backout._Release();
    }
}











#line 2050 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"


template <class _Key, class... _Args>
struct _In_place_key_extract_set {
    
    static constexpr bool _Extractable = false;
};

template <class _Key>
struct _In_place_key_extract_set<_Key, _Key> {
    
    static constexpr bool _Extractable = true;
    static const _Key& _Extract(const _Key& _Val) noexcept {
        return _Val;
    }
};


template <class _Key, class... _Args>
struct _In_place_key_extract_map {
    
    static constexpr bool _Extractable = false;
};

template <class _Key, class _Second>
struct _In_place_key_extract_map<_Key, _Key, _Second> {
    
    static constexpr bool _Extractable = true;
    static const _Key& _Extract(const _Key& _Val, const _Second&) noexcept {
        return _Val;
    }
};

template <class _Key, class _First, class _Second>
struct _In_place_key_extract_map<_Key, pair<_First, _Second>> {
    
    static constexpr bool _Extractable = is_same_v<_Key, _Remove_cvref_t<_First>>;
    static const _Key& _Extract(const pair<_First, _Second>& _Val) {
        return _Val.first;
    }
};

#pragma warning(push)
#pragma warning(disable : 4624) 
template <class _Ty>
struct _Wrap {
    _Ty _Value; 
};
#pragma warning(pop)

template <class _Alloc>
struct _Alloc_temporary2 {
    using value_type = typename _Alloc::value_type;
    using _Traits    = allocator_traits<_Alloc>;

    _Alloc& _Al;














    union {
        value_type _Value;
    };

    [[nodiscard]] constexpr value_type& _Get_value() noexcept {
        return _Value;
    }

    [[nodiscard]] constexpr const value_type& _Get_value() const noexcept {
        return _Value;
    }
#line 2132 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"

    template <class... _Args>
    constexpr explicit _Alloc_temporary2(_Alloc& _Al_, _Args&&... _Vals) noexcept(
        noexcept(_Traits::construct(_Al_, ::std:: addressof(_Get_value()), ::std:: forward<_Args>(_Vals)...)))
        : _Al(_Al_) {
        _Traits::construct(_Al, ::std:: addressof(_Get_value()), ::std:: forward<_Args>(_Vals)...);
    }

    _Alloc_temporary2(const _Alloc_temporary2&)            = delete;
    _Alloc_temporary2& operator=(const _Alloc_temporary2&) = delete;

    constexpr ~_Alloc_temporary2() {
        _Traits::destroy(_Al, ::std:: addressof(_Get_value()));
    }
};

template <class _Alloc>
[[nodiscard]] constexpr bool _Allocators_equal(const _Alloc& _Lhs, const _Alloc& _Rhs) noexcept {
    if constexpr (allocator_traits<_Alloc>::is_always_equal::value) {
        return true;
    } else {
        return _Lhs == _Rhs;
    }
}

 template <class _FwdIt, class _Ty>
[[nodiscard("The 'remove' and 'remove_if' algorithms return the iterator past the last element " "that should be kept. You need to call container.erase(result, container.end()) afterwards. " "In C++20, 'std::erase' and 'std::erase_if' are simpler replacements for these two steps.")]] constexpr _FwdIt remove(_FwdIt _First, const _FwdIt _Last, const _Ty& _Val) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    _UFirst           = ::std:: _Find_unchecked(_UFirst, _ULast, _Val);
    auto _UNext       = _UFirst;
    if (_UFirst != _ULast) {
        while (++_UFirst != _ULast) {
            if (!(*_UFirst == _Val)) {
                *_UNext = ::std:: move(*_UFirst);
                ++_UNext;
            }
        }
    }

    _Seek_wrapped(_First, _UNext);
    return _First;
}

 template <class _FwdIt, class _Pr>
[[nodiscard("The 'remove' and 'remove_if' algorithms return the iterator past the last element " "that should be kept. You need to call container.erase(result, container.end()) afterwards. " "In C++20, 'std::erase' and 'std::erase_if' are simpler replacements for these two steps.")]] constexpr _FwdIt remove_if(_FwdIt _First, const _FwdIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    _UFirst           = ::std:: find_if(_UFirst, _ULast, _Pass_fn(_Pred));
    auto _UNext       = _UFirst;
    if (_UFirst != _ULast) {
        while (++_UFirst != _ULast) {
            if (!_Pred(*_UFirst)) {
                *_UNext = ::std:: move(*_UFirst);
                ++_UNext;
            }
        }
    }

    _Seek_wrapped(_First, _UNext);
    return _First;
}

template <class _Container, class _Uty>
constexpr typename _Container::size_type _Erase_remove(_Container& _Cont, const _Uty& _Val) {
    
    auto _First          = _Cont.begin();
    const auto _Last     = _Cont.end();
    const auto _Old_size = _Cont.size();
    _Seek_wrapped(_First, ::std:: remove(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val));
    _Cont.erase(_First, _Last);
    return _Old_size - _Cont.size();
}

template <class _Container, class _Pr>
constexpr typename _Container::size_type _Erase_remove_if(_Container& _Cont, _Pr _Pred) {
    
    auto _First          = _Cont.begin();
    const auto _Last     = _Cont.end();
    const auto _Old_size = _Cont.size();
    _Seek_wrapped(_First, ::std:: remove_if(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pred));
    _Cont.erase(_First, _Last);
    return _Old_size - _Cont.size();
}

template <class _Container, class _Pr>
typename _Container::size_type _Erase_nodes_if(_Container& _Cont, _Pr _Pred) {
    
    auto _First          = _Cont.begin();
    const auto _Last     = _Cont.end();
    const auto _Old_size = _Cont.size();
    while (_First != _Last) {
        if (_Pred(*_First)) {
            _First = _Cont.erase(_First);
        } else {
            ++_First;
        }
    }
    return _Old_size - _Cont.size();
}

template <class _Ty1, class _Ty2>
void _Deduce_as_pair(const pair<_Ty1, _Ty2>&); 

template <class _Ty, class = void>
inline constexpr bool _Is_deducible_as_pair = false;

template <class _Ty>
inline constexpr bool _Is_deducible_as_pair<_Ty, decltype(_Deduce_as_pair(::std:: declval<_Ty>()))> = true;

template <class _Ty>
const _Ty& _Normally_bind(_Identity_t<const _Ty&>); 

template <class _Ty>
_Ty&& _Normally_bind(_Identity_t<_Ty&&>); 

template <class _Ty, class _Uty>
using _Normally_bound_ref = decltype(_Normally_bind<_Ty>(::std:: declval<_Uty>()));

template <class _Ty, class _Uty, class = void>
inline constexpr bool _Is_normally_bindable = false;

template <class _Ty, class _Uty>
inline constexpr bool _Is_normally_bindable<_Ty, _Uty, void_t<_Normally_bound_ref<_Ty, _Uty>>> = true;


 template <class _Ty, class _Alloc, class... _Types, enable_if_t<!_Is_specialization_v<_Ty, pair>, int> = 0>
[[nodiscard]] constexpr auto uses_allocator_construction_args(const _Alloc& _Al, _Types&&... _Args) noexcept {
    if constexpr (!uses_allocator_v<_Ty, _Alloc>) {
        static_assert(is_constructible_v<_Ty, _Types...>,
            "If uses_allocator_v<T, Alloc> does not hold, T must be constructible from Types...");
        (void) _Al;
        return ::std:: forward_as_tuple(::std:: forward<_Types>(_Args)...);
    } else if constexpr (is_constructible_v<_Ty, allocator_arg_t, const _Alloc&, _Types...>) {
        using _ReturnType = tuple<allocator_arg_t, const _Alloc&, _Types&&...>;
        return _ReturnType{allocator_arg, _Al, ::std:: forward<_Types>(_Args)...};
    } else if constexpr (is_constructible_v<_Ty, _Types..., const _Alloc&>) {
        return ::std:: forward_as_tuple(::std:: forward<_Types>(_Args)..., _Al);
    } else {
        static_assert(_Always_false<_Ty>,
            "T must be constructible from either (allocator_arg_t, const Alloc&, Types...) "
            "or (Types..., const Alloc&) if uses_allocator_v<T, Alloc> is true");
    }
}

 template <class _Ty, class _Alloc, enable_if_t<_Is_specialization_v<_Ty, pair>, int> = 0>
[[nodiscard]] constexpr auto uses_allocator_construction_args(const _Alloc& _Al) noexcept;

 template <class _Ty, class _Alloc, class _Uty1, class _Uty2,
    enable_if_t<_Is_specialization_v<_Ty, pair>, int> = 0>
[[nodiscard]] constexpr auto uses_allocator_construction_args(const _Alloc& _Al, _Uty1&& _Val1, _Uty2&& _Val2) noexcept;





#line 2293 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"

 template <class _Ty, class _Alloc, class _Uty1, class _Uty2,
    enable_if_t<_Is_specialization_v<_Ty, pair>, int> = 0>
[[nodiscard]] constexpr auto uses_allocator_construction_args(const _Alloc& _Al, const pair<_Uty1, _Uty2>& _Pair) noexcept;

 template <class _Ty, class _Alloc, class _Uty1, class _Uty2,
    enable_if_t<_Is_specialization_v<_Ty, pair>, int> = 0>
[[nodiscard]] constexpr auto uses_allocator_construction_args(const _Alloc& _Al, pair<_Uty1, _Uty2>&& _Pair) noexcept;






#line 2308 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"

 template <class _Ty, class _Alloc, class _Uty,
    enable_if_t<_Is_specialization_v<_Ty, pair> && !_Is_deducible_as_pair<_Uty&>, int> = 0>
[[nodiscard]] constexpr auto uses_allocator_construction_args(const _Alloc& _Al, _Uty&& _Ux) noexcept;

 template <class _Ty, class _Alloc, class _Tuple1, class _Tuple2,
    enable_if_t<_Is_specialization_v<_Ty, pair>, int> = 0>
[[nodiscard]] constexpr auto uses_allocator_construction_args(
    const _Alloc& _Al, piecewise_construct_t, _Tuple1&& _Tup1, _Tuple2&& _Tup2) noexcept {
    return ::std:: make_tuple(piecewise_construct,
        ::std:: apply(
            [&_Al](auto&&... _Tuple_args) {
                return ::std:: uses_allocator_construction_args<typename _Ty::first_type>(
                    _Al, ::std:: forward<decltype(_Tuple_args)>(_Tuple_args)...);
            },
            ::std:: forward<_Tuple1>(_Tup1)),
        ::std:: apply(
            [&_Al](auto&&... _Tuple_args) {
                return ::std:: uses_allocator_construction_args<typename _Ty::second_type>(
                    _Al, ::std:: forward<decltype(_Tuple_args)>(_Tuple_args)...);
            },
            ::std:: forward<_Tuple2>(_Tup2)));
}

 template <class _Ty, class _Alloc, enable_if_t<_Is_specialization_v<_Ty, pair>, int>>
[[nodiscard]] constexpr auto uses_allocator_construction_args(const _Alloc& _Al) noexcept {
    
    
    return ::std:: make_tuple(piecewise_construct, ::std:: uses_allocator_construction_args<typename _Ty::first_type>(_Al),
        ::std:: uses_allocator_construction_args<typename _Ty::second_type>(_Al));
}

 template <class _Ty, class _Alloc, class _Uty1, class _Uty2,
    enable_if_t<_Is_specialization_v<_Ty, pair>, int>>
[[nodiscard]] constexpr auto uses_allocator_construction_args(const _Alloc& _Al, _Uty1&& _Val1, _Uty2&& _Val2) noexcept {
    
    
    
    return ::std:: make_tuple(piecewise_construct,
        ::std:: uses_allocator_construction_args<typename _Ty::first_type>(_Al, ::std:: forward<_Uty1>(_Val1)),
        ::std:: uses_allocator_construction_args<typename _Ty::second_type>(_Al, ::std:: forward<_Uty2>(_Val2)));
}












#line 2363 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"

 template <class _Ty, class _Alloc, class _Uty1, class _Uty2,
    enable_if_t<_Is_specialization_v<_Ty, pair>, int>>
[[nodiscard]] constexpr auto uses_allocator_construction_args(
    const _Alloc& _Al, const pair<_Uty1, _Uty2>& _Pair) noexcept {
    
    
    
    return ::std:: make_tuple(piecewise_construct,
        ::std:: uses_allocator_construction_args<typename _Ty::first_type>(_Al, _Pair.first),
        ::std:: uses_allocator_construction_args<typename _Ty::second_type>(_Al, _Pair.second));
}

 template <class _Ty, class _Alloc, class _Uty1, class _Uty2,
    enable_if_t<_Is_specialization_v<_Ty, pair>, int>>
[[nodiscard]] constexpr auto uses_allocator_construction_args(const _Alloc& _Al, pair<_Uty1, _Uty2>&& _Pair) noexcept {
    
    
    
    return ::std:: make_tuple(piecewise_construct,
        ::std:: uses_allocator_construction_args<typename _Ty::first_type>(_Al, ::std:: get<0>(::std:: move(_Pair))),
        ::std:: uses_allocator_construction_args<typename _Ty::second_type>(_Al, ::std:: get<1>(::std:: move(_Pair))));
}













#line 2400 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"

 template <class _Ty, class _Alloc, class _Uty,
    enable_if_t<_Is_specialization_v<_Ty, pair> && !_Is_deducible_as_pair<_Uty&>, int>>
[[nodiscard]] constexpr auto uses_allocator_construction_args(const _Alloc& _Al, _Uty&& _Ux) noexcept {
    struct _Pair_remaker {
        const _Alloc& _Al;
        _Uty& _Ux;

        constexpr operator remove_cv_t<_Ty>() const {
            using _Pair_t = remove_cv_t<_Ty>;
            static_assert(_Is_normally_bindable<_Pair_t, _Uty>,
                "The argument must be bindable to a reference to the std::pair type.");

            using _Pair_first_t   = typename _Pair_t::first_type;
            using _Pair_second_t  = typename _Pair_t::second_type;
            using _Pair_ref_t     = _Normally_bound_ref<_Pair_t, _Uty>;
            _Pair_ref_t _Pair_ref = ::std:: forward<_Uty>(_Ux);
            if constexpr (is_same_v<_Pair_ref_t, const _Pair_t&>) {
                
                
                return _Pair_t{piecewise_construct,
                    ::std:: uses_allocator_construction_args<_Pair_first_t>(_Al, _Pair_ref.first),
                    ::std:: uses_allocator_construction_args<_Pair_second_t>(_Al, _Pair_ref.second)};
            } else {
                
                
                return _Pair_t{piecewise_construct,
                    ::std:: uses_allocator_construction_args<_Pair_first_t>(_Al, ::std:: get<0>(::std:: move(_Pair_ref))),
                    ::std:: uses_allocator_construction_args<_Pair_second_t>(_Al, ::std:: get<1>(::std:: move(_Pair_ref)))};
            }
        }
    };

    
    
    return tuple<_Pair_remaker>({_Al, _Ux});
}

 template <class _Ty, class _Alloc, class... _Types>
[[nodiscard]] constexpr _Ty make_obj_using_allocator(const _Alloc& _Al, _Types&&... _Args) {
    return ::std:: make_from_tuple<_Ty>(::std:: uses_allocator_construction_args<_Ty>(_Al, ::std:: forward<_Types>(_Args)...));
}

 template <class _Ty, class _Alloc, class... _Types>
constexpr _Ty* uninitialized_construct_using_allocator(_Ty* _Ptr, const _Alloc& _Al, _Types&&... _Args) {
    return ::std:: apply(
        [&](auto&&... _Construct_args) {
            return ::std:: construct_at(_Ptr, ::std:: forward<decltype(_Construct_args)>(_Construct_args)...);
        },
        ::std:: uses_allocator_construction_args<_Ty>(_Al, ::std:: forward<_Types>(_Args)...));
}
#line 2452 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"




















#line 2473 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"

template <class _Ty,
    bool = is_empty_v<_Ty> && !is_final_v<_Ty>>
class _Ebco_base : private _Ty { 
private:
    using _Mybase = _Ty; 

protected:
    template <class _Other, enable_if_t<!is_same_v<_Remove_cvref_t<_Other>, _Ebco_base>, int> = 0>
    constexpr explicit _Ebco_base(_Other&& _Val) noexcept(is_nothrow_constructible_v<_Ty, _Other>)
        : _Ty(::std:: forward<_Other>(_Val)) {}

    constexpr _Ty& _Get_val() noexcept {
        return *this;
    }

    constexpr const _Ty& _Get_val() const noexcept {
        return *this;
    }
};

template <class _Ty>
class _Ebco_base<_Ty, false> { 
private:
    _Ty _Myval;

protected:
    template <class _Other, enable_if_t<!is_same_v<_Remove_cvref_t<_Other>, _Ebco_base>, int> = 0>
    constexpr explicit _Ebco_base(_Other&& _Val) noexcept(is_nothrow_constructible_v<_Ty, _Other>)
        : _Myval(::std:: forward<_Other>(_Val)) {}

    constexpr _Ty& _Get_val() noexcept {
        return _Myval;
    }

    constexpr const _Ty& _Get_val() const noexcept {
        return _Myval;
    }
};

 inline void* align(size_t _Bound, size_t _Size, void*& _Ptr, size_t& _Space) noexcept   {
    
    size_t _Off = static_cast<size_t>(reinterpret_cast<uintptr_t>(_Ptr) & (_Bound - 1));
    if (_Off != 0) {
        _Off = _Bound - _Off; 
    }

    if (_Space < _Off || _Space - _Off < _Size) {
        return nullptr;
    }

    
    _Ptr = static_cast<char*>(_Ptr) + _Off;
    _Space -= _Off;
    return _Ptr;
}
}



#pragma warning(pop)
#pragma pack(pop)
#line 2536 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"
#line 2537 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmemory"
#pragma external_header(pop)
#line 15 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"


#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xpolymorphic_allocator.h"





#pragma once









#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




namespace std {





































































































#line 126 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xpolymorphic_allocator.h"


namespace pmr {
     class __declspec(novtable) memory_resource {
    public:
        virtual ~memory_resource() noexcept = default;

        [[nodiscard("This function allocates memory and returns a raw pointer. " "Discarding the return value will cause a memory leak.")]] __declspec(allocator) void* allocate( const size_t _Bytes,
            const size_t _Align = alignof(max_align_t)) { 
             ;
            void* _Ptr = do_allocate(_Bytes, _Align);
            return ::operator new(_Bytes, _Ptr);
        }

        void deallocate(void* const _Ptr, const size_t _Bytes, const size_t _Align = alignof(max_align_t)) {
            
             ;
            return do_deallocate(_Ptr, _Bytes, _Align);
        }

        [[nodiscard]] bool is_equal(const memory_resource& _That) const noexcept {
            
            return do_is_equal(_That);
        }

    private:
        virtual void* do_allocate(size_t _Bytes, size_t _Align)               = 0;
        virtual void do_deallocate(void* _Ptr, size_t _Bytes, size_t _Align)  = 0;
        virtual bool do_is_equal(const memory_resource& _That) const noexcept = 0;
    };

     [[nodiscard]] inline bool operator==(
        const memory_resource& _Left, const memory_resource& _Right) noexcept {
        return &_Left == &_Right || _Left.is_equal(_Right);
    }





#line 167 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xpolymorphic_allocator.h"

    extern "C"  memory_resource* __cdecl _Aligned_get_default_resource() noexcept;
    extern "C"  memory_resource* __cdecl _Unaligned_get_default_resource() noexcept;

     [[nodiscard]] inline memory_resource* get_default_resource() noexcept {

        return _Aligned_get_default_resource();


#line 177 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xpolymorphic_allocator.h"
    }


     template <class _Ty = byte>


#line 184 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xpolymorphic_allocator.h"
    class polymorphic_allocator {
    public:
        template <class>
        friend class polymorphic_allocator;

        using value_type = _Ty;

        polymorphic_allocator() noexcept = default;

          polymorphic_allocator(memory_resource* const _Resource_) noexcept 
            : _Resource{_Resource_} { 
            
;
        }

        polymorphic_allocator(const polymorphic_allocator&) = default;

        template <class _Uty>
        polymorphic_allocator(const polymorphic_allocator<_Uty>& _That) noexcept
            : _Resource{_That._Resource} {} 

        polymorphic_allocator& operator=(const polymorphic_allocator&) = delete;

        [[nodiscard("This function allocates memory and returns a raw pointer. " "Discarding the return value will cause a memory leak.")]] __declspec(allocator) _Ty* allocate( const size_t _Count) {
            
            void* const _Vp = _Resource->allocate(_Get_size_of_n<sizeof(_Ty)>(_Count), alignof(_Ty));
            return static_cast<_Ty*>(_Vp);
        }

        void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept   {
            
            
            _Resource->deallocate(_Ptr, _Count * sizeof(_Ty), alignof(_Ty));
        }


        [[nodiscard("This function allocates memory and returns a raw pointer. " "Discarding the return value will cause a memory leak.")]] __declspec(allocator) void* allocate_bytes(
            const size_t _Bytes, const size_t _Align = alignof(max_align_t)) {
            return _Resource->allocate(_Bytes, _Align);
        }

        void deallocate_bytes(void* const _Ptr, const size_t _Bytes,
            const size_t _Align = alignof(max_align_t)) noexcept   {
            _Resource->deallocate(_Ptr, _Bytes, _Align);
        }

        template <class _Uty>
        [[nodiscard("This function allocates memory and returns a raw pointer. " "Discarding the return value will cause a memory leak.")]] __declspec(allocator) _Uty* allocate_object(
             const size_t _Count = 1) {
            void* const _Vp = allocate_bytes(_Get_size_of_n<sizeof(_Uty)>(_Count), alignof(_Uty));
            return static_cast<_Uty*>(_Vp);
        }

        template <class _Uty>
        void deallocate_object(_Uty* const _Ptr, const size_t _Count = 1) noexcept   {
            deallocate_bytes(_Ptr, _Count * sizeof(_Uty), alignof(_Uty));
        }

        template <class _Uty, class... _Types>
        [[nodiscard("This function allocates memory and returns a raw pointer. " "Discarding the return value will cause a memory leak.")]] __declspec(allocator) _Uty* new_object(_Types&&... _Args) {
            _Uty* const _Ptr = allocate_object<_Uty>();
            try {
            construct(_Ptr, ::std:: forward<_Types>(_Args)...);
            } catch (...) {
            deallocate_object(_Ptr);
            throw ;
            }
            return _Ptr;
        }

        template <class _Uty>
        void delete_object(_Uty* const _Ptr) noexcept   {
            _Destroy_in_place(*_Ptr);
            deallocate_object(_Ptr);
        }
#line 260 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xpolymorphic_allocator.h"

        template <class _Uty, class... _Types>
        void construct(_Uty* const _Ptr, _Types&&... _Args) {
            

            ::std:: uninitialized_construct_using_allocator(_Ptr, *this, ::std:: forward<_Types>(_Args)...);



#line 270 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xpolymorphic_allocator.h"
        }

        template <class _Uty>
        [[deprecated("warning STL4032: " "std::pmr::polymorphic_allocator::destroy() is deprecated in C++17 by LWG-3036. " "Prefer std::destroy_at() or std::allocator_traits<polymorphic_allocator>::destroy(). " "You can define _SILENCE_CXX17_POLYMORPHIC_ALLOCATOR_DESTROY_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] void destroy(_Uty* const _Ptr) noexcept   {
            _Destroy_in_place(*_Ptr);
        }

        [[nodiscard]] polymorphic_allocator select_on_container_copy_construction() const noexcept   {
            
            return {};
        }

        [[nodiscard]] memory_resource* resource() const noexcept   {
            
            return _Resource;
        }

        [[nodiscard]] friend bool operator==(
            const polymorphic_allocator& _Lhs, const polymorphic_allocator& _Rhs) noexcept {
            return *_Lhs._Resource == *_Rhs._Resource;
        }






#line 298 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xpolymorphic_allocator.h"

    private:
        memory_resource* _Resource = ::std:: pmr::get_default_resource();
    };

     template <class _Ty1, class _Ty2>
    [[nodiscard]] bool operator==(
        const polymorphic_allocator<_Ty1>& _Left, const polymorphic_allocator<_Ty2>& _Right) noexcept {
        
        return *_Left.resource() == *_Right.resource();
    }







#line 317 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xpolymorphic_allocator.h"

} 

template <class _Ty, class _Ptr>
struct _Has_no_alloc_destroy<pmr::polymorphic_allocator<_Ty>, _Ptr, void> : true_type {
    
    
};

#line 327 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xpolymorphic_allocator.h"

}



#pragma warning(pop)
#pragma pack(pop)
#line 335 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xpolymorphic_allocator.h"
#line 336 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xpolymorphic_allocator.h"
#pragma external_header(pop)
#line 18 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
#line 19 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\__msvc_sanitizer_annotate_container.hpp"





#pragma once





#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )























#line 39 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\__msvc_sanitizer_annotate_container.hpp"








#line 48 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\__msvc_sanitizer_annotate_container.hpp"











#pragma detect_mismatch("annotate_string", "0")
#line 61 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\__msvc_sanitizer_annotate_container.hpp"

#pragma detect_mismatch("annotate_vector", "0")
#line 64 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\__msvc_sanitizer_annotate_container.hpp"













extern "C" {







}







































#line 126 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\__msvc_sanitizer_annotate_container.hpp"

#line 128 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\__msvc_sanitizer_annotate_container.hpp"



#pragma warning(pop)
#pragma pack(pop)

#line 135 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\__msvc_sanitizer_annotate_container.hpp"
#line 136 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\__msvc_sanitizer_annotate_container.hpp"
#pragma external_header(pop)
#line 21 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )








#line 34 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

namespace std {
template <class _Elem, class _Int_type>
struct _Char_traits { 
    using char_type  = _Elem;
    using int_type   = _Int_type;
    using pos_type   = streampos;
    using off_type   = streamoff;
    using state_type = _Mbstatet;

    using comparison_category = strong_ordering;
#line 46 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

    

    static constexpr _Elem* copy( _Elem* const _First1,
         const _Elem* const _First2, const size_t _Count) noexcept   {
        


#line 55 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

        if (::std:: is_constant_evaluated()) {
            
            for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
                _First1[_Idx] = _First2[_Idx];
            }

            return _First1;
        }
#line 65 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

        :: memcpy(_First1, _First2, _Count * sizeof(_Elem));
#line 68 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

        return _First1;
    }

     static constexpr _Elem* _Copy_s(
                                                                                 _Elem* const _First1,
        const size_t _Dest_size,  const _Elem* const _First2, const size_t _Count) noexcept {
        
        do { if (_Count <= _Dest_size) { } else { do {; ::_invalid_parameter_noinfo_noreturn(); } while (false); }; } while (false) ;
        return copy(_First1, _First2, _Count);
    }

    static constexpr _Elem* move( _Elem* const _First1,
         const _Elem* const _First2, const size_t _Count) noexcept   {
        


#line 86 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

        if (::std:: is_constant_evaluated()) {
            
            
            
            
            

            
            
            bool _Loop_forward = true;

            for (const _Elem* _Src = _First2; _Src != _First2 + _Count; ++_Src) {
                if (_First1 == _Src) {
                    _Loop_forward = false;
                    break;
                }
            }

            if (_Loop_forward) {
                for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
                    _First1[_Idx] = _First2[_Idx];
                }
            } else {
                for (size_t _Idx = _Count; _Idx != 0; --_Idx) {
                    _First1[_Idx - 1] = _First2[_Idx - 1];
                }
            }

            return _First1;
        }
#line 118 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

        :: memmove(_First1, _First2, _Count * sizeof(_Elem));
#line 121 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

        return _First1;
    }

    
    

    [[nodiscard]] static constexpr int compare( const _Elem* _First1,
         const _Elem* _First2, size_t _Count) noexcept   {
        
        for (; 0 < _Count; --_Count, ++_First1, ++_First2) {
            if (*_First1 != *_First2) {
                return *_First1 < *_First2 ? -1 : +1;
            }
        }

        return 0;
    }

    [[nodiscard]] static constexpr size_t length( const _Elem* _First) noexcept   {
        
        size_t _Count = 0;
        while (*_First != _Elem()) {
            ++_Count;
            ++_First;
        }

        return _Count;
    }

    [[nodiscard]] static constexpr const _Elem* find(
         const _Elem* _First, size_t _Count, const _Elem& _Ch) noexcept   {
        
        for (; 0 < _Count; --_Count, ++_First) {
            if (*_First == _Ch) {
                return _First;
            }
        }

        return nullptr;
    }

    static constexpr _Elem* assign(
         _Elem* const _First, size_t _Count, const _Elem _Ch) noexcept   {
        

        if (::std:: is_constant_evaluated()) {
            for (_Elem* _Next = _First; _Count > 0; --_Count, ++_Next) {
                ::std:: construct_at(_Next, _Ch);
            }
        } else
#line 173 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        {
            for (_Elem* _Next = _First; _Count > 0; --_Count, ++_Next) {
                *_Next = _Ch;
            }
        }

        return _First;
    }

    static constexpr void assign(_Elem& _Left, const _Elem& _Right) noexcept {

        if (::std:: is_constant_evaluated()) {
            ::std:: construct_at(::std:: addressof(_Left), _Right);
        } else
#line 188 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        {
            _Left = _Right;
        }
    }

    [[nodiscard]] static constexpr bool eq(const _Elem& _Left, const _Elem& _Right) noexcept {
        return _Left == _Right;
    }

    [[nodiscard]] static constexpr bool lt(const _Elem& _Left, const _Elem& _Right) noexcept {
        return _Left < _Right;
    }

    [[nodiscard]] static constexpr _Elem to_char_type(const int_type& _Meta) noexcept {
        return static_cast<_Elem>(_Meta);
    }

    [[nodiscard]] static constexpr int_type to_int_type(const _Elem& _Ch) noexcept {
        return static_cast<int_type>(_Ch);
    }

    [[nodiscard]] static constexpr bool eq_int_type(const int_type& _Left, const int_type& _Right) noexcept {
        return _Left == _Right;
    }

    [[nodiscard]] static constexpr int_type not_eof(const int_type& _Meta) noexcept {
        return _Meta != eof() ? _Meta : !eof();
    }

    [[nodiscard]] static constexpr int_type eof() noexcept {
        return static_cast<int_type>((-1) );
    }
};

template <class _Elem>
struct _WChar_traits : private _Char_traits<_Elem, unsigned short> {
    
private:
    using _Primary_char_traits = _Char_traits<_Elem, unsigned short>;

public:
    using char_type  = _Elem;
    using int_type   = unsigned short;
    using pos_type   = streampos;
    using off_type   = streamoff;
    using state_type = mbstate_t;

    using comparison_category = strong_ordering;
#line 237 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

    using _Primary_char_traits::_Copy_s;
    using _Primary_char_traits::copy;
    using _Primary_char_traits::move;

    [[nodiscard]] static constexpr int compare( const _Elem* const _First1,
         const _Elem* const _First2, const size_t _Count) noexcept   {
        

        if constexpr (is_same_v<_Elem, wchar_t>) {
            return __builtin_wmemcmp(_First1, _First2, _Count);
        } else {
            return _Primary_char_traits::compare(_First1, _First2, _Count);
        }



#line 255 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
    }

    [[nodiscard]] static constexpr size_t length( const _Elem* _First) noexcept   {
        

        if constexpr (is_same_v<_Elem, wchar_t>) {
            return __builtin_wcslen(_First);
        } else {
            return _Primary_char_traits::length(_First);
        }


#line 268 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
    }

    [[nodiscard]] static constexpr const _Elem* find(
         const _Elem* _First, const size_t _Count, const _Elem& _Ch) noexcept   {
        

        if constexpr (is_same_v<_Elem, wchar_t>) {
            return __builtin_wmemchr(_First, _Ch, _Count);
        } else {
            return _Primary_char_traits::find(_First, _Count, _Ch);
        }


#line 282 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
    }

    static constexpr _Elem* assign(
         _Elem* const _First, size_t _Count, const _Elem _Ch) noexcept   {
        

        if (::std:: is_constant_evaluated()) {
            return _Primary_char_traits::assign(_First, _Count, _Ch);
        }
#line 292 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

        return reinterpret_cast<_Elem*>(:: wmemset(reinterpret_cast<wchar_t*>(_First), _Ch, _Count));
    }

    static constexpr void assign(_Elem& _Left, const _Elem& _Right) noexcept {

        if (::std:: is_constant_evaluated()) {
            return _Primary_char_traits::assign(_Left, _Right);
        }
#line 302 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        _Left = _Right;
    }

    [[nodiscard]] static constexpr bool eq(const _Elem& _Left, const _Elem& _Right) noexcept {
        return _Left == _Right;
    }

    [[nodiscard]] static constexpr bool lt(const _Elem& _Left, const _Elem& _Right) noexcept {
        return _Left < _Right;
    }

    [[nodiscard]] static constexpr _Elem to_char_type(const int_type& _Meta) noexcept {
        return _Meta;
    }

    [[nodiscard]] static constexpr int_type to_int_type(const _Elem& _Ch) noexcept {
        return _Ch;
    }

    [[nodiscard]] static constexpr bool eq_int_type(const int_type& _Left, const int_type& _Right) noexcept {
        return _Left == _Right;
    }

    [[nodiscard]] static constexpr int_type not_eof(const int_type& _Meta) noexcept {
        return _Meta != eof() ? _Meta : static_cast<int_type>(!eof());
    }

    [[nodiscard]] static constexpr int_type eof() noexcept {
        return ((wint_t)(0xFFFF)) ;
    }
};

 template <class _Elem>
struct char_traits : _Char_traits<_Elem, long> {}; 

template <>
struct char_traits<char16_t> : _WChar_traits<char16_t> {};

template <>
struct char_traits<char32_t> : _Char_traits<char32_t, unsigned int> {};

template <>
struct char_traits<wchar_t> : _WChar_traits<wchar_t> {};










#line 356 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

template <class _Elem, class _Int_type>
struct _Narrow_char_traits : private _Char_traits<_Elem, _Int_type> {
    
private:
    using _Primary_char_traits = _Char_traits<_Elem, _Int_type>;

public:
    using char_type  = _Elem;
    using int_type   = _Int_type;
    using pos_type   = streampos;
    using off_type   = streamoff;
    using state_type = mbstate_t;

    using comparison_category = strong_ordering;
#line 372 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

    using _Primary_char_traits::_Copy_s;
    using _Primary_char_traits::copy;
    using _Primary_char_traits::move;

    [[nodiscard]] static constexpr int compare( const _Elem* const _First1,
         const _Elem* const _First2, const size_t _Count) noexcept   {
        

        return __builtin_memcmp(_First1, _First2, _Count);


#line 385 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
    }

    [[nodiscard]] static constexpr size_t length( const _Elem* const _First) noexcept   {
        


        if constexpr (is_same_v<_Elem, char8_t>) {

            return __builtin_u8strlen(_First);


#line 397 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        } else
#line 399 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        {
            return __builtin_strlen(_First);
        }


#line 405 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
    }

    [[nodiscard]] static constexpr const _Elem* find( const _Elem* const _First, const size_t _Count,
        const _Elem& _Ch) noexcept   {
        


        if constexpr (is_same_v<_Elem, char8_t>) {

            return __builtin_u8memchr(_First, _Ch, _Count);


#line 418 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        } else
#line 420 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        {
            return __builtin_char_memchr(_First, _Ch, _Count);
        }


#line 426 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
    }

    static constexpr _Elem* assign(
         _Elem* const _First, size_t _Count, const _Elem _Ch) noexcept   {
        

        if (::std:: is_constant_evaluated()) {
            return _Primary_char_traits::assign(_First, _Count, _Ch);
        }
#line 436 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

        return static_cast<_Elem*>(:: memset(_First, _Ch, _Count));
    }

    static constexpr void assign(_Elem& _Left, const _Elem& _Right) noexcept {

        if (::std:: is_constant_evaluated()) {
            return _Primary_char_traits::assign(_Left, _Right);
        }
#line 446 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        _Left = _Right;
    }

    [[nodiscard]] static constexpr bool eq(const _Elem& _Left, const _Elem& _Right) noexcept {
        return _Left == _Right;
    }

    [[nodiscard]] static constexpr bool lt(const _Elem& _Left, const _Elem& _Right) noexcept {
        return static_cast<unsigned char>(_Left) < static_cast<unsigned char>(_Right);
    }

    [[nodiscard]] static constexpr _Elem to_char_type(const int_type& _Meta) noexcept {
        return static_cast<_Elem>(_Meta);
    }

    [[nodiscard]] static constexpr int_type to_int_type(const _Elem& _Ch) noexcept {
        return static_cast<unsigned char>(_Ch);
    }

    [[nodiscard]] static constexpr bool eq_int_type(const int_type& _Left, const int_type& _Right) noexcept {
        return _Left == _Right;
    }

    [[nodiscard]] static constexpr int_type not_eof(const int_type& _Meta) noexcept {
        return _Meta != eof() ? _Meta : !eof();
    }

    [[nodiscard]] static constexpr int_type eof() noexcept {
        return static_cast<int_type>((-1) );
    }
};




template <>
struct char_traits<char> : _Narrow_char_traits<char, int> {}; 


template <>
struct char_traits<char8_t> : _Narrow_char_traits<char8_t, unsigned int> {};
#line 488 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

template <class _Elem, class _Traits, class _SizeT>
basic_ostream<_Elem, _Traits>& _Insert_string(
    basic_ostream<_Elem, _Traits>& _Ostr, const _Elem* const _Data, const _SizeT _Size) {
    
    using _Ostr_t                    = basic_ostream<_Elem, _Traits>;
    typename _Ostr_t::iostate _State = _Ostr_t::goodbit;

    _SizeT _Pad;
    if (_Ostr.width() <= 0 || static_cast<_SizeT>(_Ostr.width()) <= _Size) {
        _Pad = 0;
    } else {
        _Pad = static_cast<_SizeT>(_Ostr.width()) - _Size;
    }

    const typename _Ostr_t::sentry _Ok(_Ostr);

    if (!_Ok) {
        _State |= _Ostr_t::badbit;
    } else { 
        try {
        if ((_Ostr.flags() & _Ostr_t::adjustfield) != _Ostr_t::left) {
            for (; 0 < _Pad; --_Pad) { 
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= _Ostr_t::badbit; 
                    break;
                }
            }
        }

        if (_State == _Ostr_t::goodbit
            && _Ostr.rdbuf()->sputn(_Data, static_cast<streamsize>(_Size)) != static_cast<streamsize>(_Size)) {
            _State |= _Ostr_t::badbit;
        } else {
            for (; 0 < _Pad; --_Pad) { 
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= _Ostr_t::badbit; 
                    break;
                }
            }
        }

        _Ostr.width(0);
        } catch (...) { (_Ostr) .setstate(_Ostr_t::badbit, true); }
    }

    _Ostr.setstate(_State);
    return _Ostr;
}

template <class _Traits>
struct _Char_traits_eq {
    using _Elem = typename _Traits::char_type;

    bool operator()(_Elem _Left, _Elem _Right) const noexcept {
        return _Traits::eq(_Left, _Right);
    }
};

template <class _Traits>
struct _Char_traits_lt {
    using _Elem = typename _Traits::char_type;

    bool operator()(_Elem _Left, _Elem _Right) const noexcept {
        return _Traits::lt(_Left, _Right);
    }
};



template <class _Elem>
inline constexpr bool _Can_memcmp_elements_with_pred<_Elem, _Elem, _Char_traits_eq<char_traits<_Elem>>> =
    _Can_memcmp_elements<_Elem, _Elem>;



template <class _Elem>
struct _Lex_compare_memcmp_classify_pred<_Elem, _Elem, _Char_traits_lt<char_traits<_Elem>>> {
    using _UElem = make_unsigned_t<_Elem>;
    using _Pred  = conditional_t<_Lex_compare_memcmp_classify_elements<_UElem, _UElem>, less<int>, void>;
};

template <class _Traits>
using _Traits_ch_t = typename _Traits::char_type;

template <class _Traits>
using _Traits_ptr_t = const typename _Traits::char_type*;

template <class _Traits>
constexpr bool _Traits_equal( const _Traits_ptr_t<_Traits> _Left, const size_t _Left_size,
     const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept {
    
    return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;
}

template <class _Traits>
constexpr int _Traits_compare( const _Traits_ptr_t<_Traits> _Left, const size_t _Left_size,
     const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept {
    
    const int _Ans = _Traits::compare(_Left, _Right, (::std:: min)(_Left_size, _Right_size));

    if (_Ans != 0) {
        return _Ans;
    }

    if (_Left_size < _Right_size) {
        return -1;
    }

    if (_Left_size > _Right_size) {
        return 1;
    }

    return 0;
}

template <class _Traits>
constexpr size_t _Traits_find( const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
    const size_t _Start_at,  const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size) noexcept {
    
    if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size) {
        
        
        
        
        
        
        
        
        return static_cast<size_t>(-1);
    }

    if (_Needle_size == 0) { 
        return _Start_at;
    }

    const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;
    for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {
        _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);
        if (!_Match_try) { 
            return static_cast<size_t>(-1);
        }

        if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0) { 
            return static_cast<size_t>(_Match_try - _Haystack);
        }
    }
}

template <class _Traits>
constexpr size_t _Traits_find_ch( const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
    const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {
    
    if (_Start_at < _Hay_size) {
        const auto _Found_at = _Traits::find(_Haystack + _Start_at, _Hay_size - _Start_at, _Ch);
        if (_Found_at) {
            return static_cast<size_t>(_Found_at - _Haystack);
        }
    }

    return static_cast<size_t>(-1); 
}

template <class _Traits>
constexpr size_t _Traits_rfind( const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
    const size_t _Start_at,  const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size) noexcept {
    
    if (_Needle_size == 0) {
        return (::std:: min)(_Start_at, _Hay_size); 
    }

    if (_Needle_size <= _Hay_size) { 
        for (auto _Match_try = _Haystack + (::std:: min)(_Start_at, _Hay_size - _Needle_size);; --_Match_try) {
            if (_Traits::eq(*_Match_try, *_Needle) && _Traits::compare(_Match_try, _Needle, _Needle_size) == 0) {
                return static_cast<size_t>(_Match_try - _Haystack); 
            }

            if (_Match_try == _Haystack) {
                break; 
            }
        }
    }

    return static_cast<size_t>(-1); 
}

template <class _Traits>
constexpr size_t _Traits_rfind_ch( const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
    const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {
    
    if (_Hay_size != 0) { 
        for (auto _Match_try = _Haystack + (::std:: min)(_Start_at, _Hay_size - 1);; --_Match_try) {
            if (_Traits::eq(*_Match_try, _Ch)) {
                return static_cast<size_t>(_Match_try - _Haystack); 
            }

            if (_Match_try == _Haystack) {
                break; 
            }
        }
    }

    return static_cast<size_t>(-1); 
}

template <class _Elem, bool = _Is_character<_Elem>::value>
class _String_bitmap { 
public:
    constexpr bool _Mark(const _Elem* _First, const _Elem* const _Last) noexcept {
        
        
        for (; _First != _Last; ++_First) {
            _Matches[static_cast<unsigned char>(*_First)] = true;
        }

        return true;
    }

    constexpr bool _Match(const _Elem _Ch) const noexcept { 
        return _Matches[static_cast<unsigned char>(_Ch)];
    }

private:
    bool _Matches[256] = {};
};

template <class _Elem>
class _String_bitmap<_Elem, false> { 
public:
    static_assert(is_unsigned_v<_Elem>,
        "Standard char_traits is only provided for char, wchar_t, char16_t, and char32_t. See N5687 [char.traits]. "
        "Visual C++ accepts other unsigned integral types as an extension.");

    constexpr bool _Mark(const _Elem* _First, const _Elem* const _Last) noexcept {
        
        
        for (; _First != _Last; ++_First) {
            const auto _Ch = *_First;
            if (_Ch >= 256U) {
                return false;
            }

            _Matches[static_cast<unsigned char>(_Ch)] = true;
        }

        return true;
    }

    constexpr bool _Match(const _Elem _Ch) const noexcept { 
        return _Ch < 256U && _Matches[_Ch];
    }

private:
    bool _Matches[256] = {};
};

template <class _Traits, bool _Special = _Is_specialization_v<_Traits, char_traits>>
constexpr size_t _Traits_find_first_of( const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at,  const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size) noexcept {
    
    if (_Needle_size != 0 && _Start_at < _Hay_size) { 
        if constexpr (_Special) {
            _String_bitmap<typename _Traits::char_type> _Matches;
            if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { 
                                                                    
                return _Traits_find_first_of<_Traits, false>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size);
            }

            const auto _End = _Haystack + _Hay_size;
            for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
                if (_Matches._Match(*_Match_try)) {
                    return static_cast<size_t>(_Match_try - _Haystack); 
                }
            }
        } else {
            const auto _End = _Haystack + _Hay_size;
            for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
                if (_Traits::find(_Needle, _Needle_size, *_Match_try)) {
                    return static_cast<size_t>(_Match_try - _Haystack); 
                }
            }
        }
    }

    return static_cast<size_t>(-1); 
}

template <class _Traits, bool _Special = _Is_specialization_v<_Traits, char_traits>>
constexpr size_t _Traits_find_last_of( const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at,  const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size) noexcept {
    
    if (_Needle_size != 0 && _Hay_size != 0) { 
        if constexpr (_Special) {
            _String_bitmap<typename _Traits::char_type> _Matches;
            if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { 
                                                                    
                return _Traits_find_last_of<_Traits, false>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size);
            }

            for (auto _Match_try = _Haystack + (::std:: min)(_Start_at, _Hay_size - 1);; --_Match_try) {
                if (_Matches._Match(*_Match_try)) {
                    return static_cast<size_t>(_Match_try - _Haystack); 
                }

                if (_Match_try == _Haystack) {
                    break; 
                }
            }
        } else {
            for (auto _Match_try = _Haystack + (::std:: min)(_Start_at, _Hay_size - 1);; --_Match_try) {
                if (_Traits::find(_Needle, _Needle_size, *_Match_try)) {
                    return static_cast<size_t>(_Match_try - _Haystack); 
                }

                if (_Match_try == _Haystack) {
                    break; 
                }
            }
        }
    }

    return static_cast<size_t>(-1); 
}

template <class _Traits, bool _Special = _Is_specialization_v<_Traits, char_traits>>
constexpr size_t _Traits_find_first_not_of( const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at,  const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size) noexcept {
    
    if (_Start_at < _Hay_size) { 
        if constexpr (_Special) {
            _String_bitmap<typename _Traits::char_type> _Matches;
            if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { 
                                                                    
                return _Traits_find_first_not_of<_Traits, false>(
                    _Haystack, _Hay_size, _Start_at, _Needle, _Needle_size);
            }

            const auto _End = _Haystack + _Hay_size;
            for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
                if (!_Matches._Match(*_Match_try)) {
                    return static_cast<size_t>(_Match_try - _Haystack); 
                }
            }
        } else {
            const auto _End = _Haystack + _Hay_size;
            for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
                if (!_Traits::find(_Needle, _Needle_size, *_Match_try)) {
                    return static_cast<size_t>(_Match_try - _Haystack); 
                }
            }
        }
    }

    return static_cast<size_t>(-1); 
}

template <class _Traits>
constexpr size_t _Traits_find_not_ch( const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {
    
    if (_Start_at < _Hay_size) { 
        const auto _End = _Haystack + _Hay_size;
        for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
            if (!_Traits::eq(*_Match_try, _Ch)) {
                return static_cast<size_t>(_Match_try - _Haystack); 
            }
        }
    }

    return static_cast<size_t>(-1); 
}

template <class _Traits, bool _Special = _Is_specialization_v<_Traits, char_traits>>
constexpr size_t _Traits_find_last_not_of( const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at,  const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size) noexcept {
    
    if (_Hay_size != 0) { 
        if constexpr (_Special) {
            _String_bitmap<typename _Traits::char_type> _Matches;
            if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { 
                                                                    
                return _Traits_find_last_not_of<_Traits, false>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size);
            }

            for (auto _Match_try = _Haystack + (::std:: min)(_Start_at, _Hay_size - 1);; --_Match_try) {
                if (!_Matches._Match(*_Match_try)) {
                    return static_cast<size_t>(_Match_try - _Haystack); 
                }

                if (_Match_try == _Haystack) {
                    break; 
                }
            }
        } else {
            for (auto _Match_try = _Haystack + (::std:: min)(_Start_at, _Hay_size - 1);; --_Match_try) {
                if (!_Traits::find(_Needle, _Needle_size, *_Match_try)) {
                    return static_cast<size_t>(_Match_try - _Haystack); 
                }

                if (_Match_try == _Haystack) {
                    break; 
                }
            }
        }
    }

    return static_cast<size_t>(-1); 
}

template <class _Traits>
constexpr size_t _Traits_rfind_not_ch( const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {
    
    if (_Hay_size != 0) { 
        for (auto _Match_try = _Haystack + (::std:: min)(_Start_at, _Hay_size - 1);; --_Match_try) {
            if (!_Traits::eq(*_Match_try, _Ch)) {
                return static_cast<size_t>(_Match_try - _Haystack); 
            }

            if (_Match_try == _Haystack) {
                break; 
            }
        }
    }

    return static_cast<size_t>(-1); 
}

template <class _Ty>
inline constexpr bool _Is_EcharT = _Is_any_of_v<_Ty, char, wchar_t,

    char8_t,
#line 927 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
    char16_t, char32_t>;


 template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_string_view;

template <class _Traits>
class _String_view_iterator {
public:

    using iterator_concept = contiguous_iterator_tag;
#line 939 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
    using iterator_category = random_access_iterator_tag;
    using value_type        = typename _Traits::char_type;
    using difference_type   = ptrdiff_t;
    using pointer           = const value_type*;
    using reference         = const value_type&;

    constexpr _String_view_iterator() noexcept = default;

private:
    friend basic_string_view<value_type, _Traits>;




#line 954 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
    constexpr explicit _String_view_iterator(const pointer _Ptr) noexcept : _Myptr(_Ptr) {}
#line 956 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

public:
    [[nodiscard]] constexpr reference operator*() const noexcept {




#line 964 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        return *_Myptr;
#line 966 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
    }

    [[nodiscard]] constexpr pointer operator->() const noexcept {




#line 974 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        return _Myptr;
#line 976 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
    }

    constexpr _String_view_iterator& operator++() noexcept {




#line 984 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        ++_Myptr;
#line 986 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        return *this;
    }

    constexpr _String_view_iterator operator++(int) noexcept {
        _String_view_iterator _Tmp{*this};
        ++*this;
        return _Tmp;
    }

    constexpr _String_view_iterator& operator--() noexcept {




#line 1001 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        --_Myptr;
#line 1003 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        return *this;
    }

    constexpr _String_view_iterator operator--(int) noexcept {
        _String_view_iterator _Tmp{*this};
        --*this;
        return _Tmp;
    }

    constexpr void _Verify_offset(const difference_type _Off) const noexcept {













#line 1027 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        (void) _Off;
#line 1029 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
    }

    constexpr _String_view_iterator& operator+=(const difference_type _Off) noexcept {



#line 1036 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        _Myptr += _Off;
#line 1038 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

        return *this;
    }

    [[nodiscard]] constexpr _String_view_iterator operator+(const difference_type _Off) const noexcept {
        _String_view_iterator _Tmp{*this};
        _Tmp += _Off;
        return _Tmp;
    }

    [[nodiscard]] friend constexpr _String_view_iterator operator+(
        const difference_type _Off, _String_view_iterator _Right) noexcept {
        _Right += _Off;
        return _Right;
    }

    constexpr _String_view_iterator& operator-=(const difference_type _Off) noexcept {















#line 1071 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        _Myptr -= _Off;
#line 1073 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

        return *this;
    }

    [[nodiscard]] constexpr _String_view_iterator operator-(const difference_type _Off) const noexcept {
        _String_view_iterator _Tmp{*this};
        _Tmp -= _Off;
        return _Tmp;
    }

    [[nodiscard]] constexpr difference_type operator-(const _String_view_iterator& _Right) const noexcept {




#line 1089 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        return _Myptr - _Right._Myptr;
#line 1091 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
    }

    [[nodiscard]] constexpr reference operator[](const difference_type _Off) const noexcept {
        return *(*this + _Off);
    }

    [[nodiscard]] constexpr bool operator==(const _String_view_iterator& _Right) const noexcept {




#line 1103 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        return _Myptr == _Right._Myptr;
#line 1105 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
    }


    [[nodiscard]] constexpr strong_ordering operator<=>(const _String_view_iterator& _Right) const noexcept {




#line 1114 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        return _Myptr <=> _Right._Myptr;
#line 1116 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
    }


























#line 1144 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"







#line 1152 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

    using _Prevent_inheriting_unwrap = _String_view_iterator;

    [[nodiscard]] constexpr pointer _Unwrapped() const noexcept {


#line 1159 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        return _Myptr;
#line 1161 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
    }

    static constexpr bool _Unwrap_when_unverified = 0 == 0;

    constexpr void _Seek_to(pointer _It) noexcept {


#line 1169 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        _Myptr = _It;
#line 1171 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
    }

private:




#line 1179 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
    pointer _Myptr = nullptr;
#line 1181 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
};


template <class _Traits>
struct pointer_traits<_String_view_iterator<_Traits>> {
    using pointer         = _String_view_iterator<_Traits>;
    using element_type    = const typename pointer::value_type;
    using difference_type = typename pointer::difference_type;

    [[nodiscard]] static constexpr element_type* to_address(const pointer& _Iter) noexcept {
        return _Iter._Unwrapped();
    }
};
#line 1195 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

#pragma warning(push)


#pragma warning(disable : 6510)

 template <class _Elem, class _Traits>
class basic_string_view { 
public:
    static_assert(is_same_v<_Elem, typename _Traits::char_type>,
        "Bad char_traits for basic_string_view; N4910 23.3.3.1 [string.view.template.general]/1 "
        "\"The program is ill-formed if traits::char_type is not the same type as charT.\"");

    static_assert(!is_array_v<_Elem> && is_trivial_v<_Elem> && is_standard_layout_v<_Elem>,
        "The character type of basic_string_view must be a non-array trivial standard-layout type. See N4910 "
        "23.1 [strings.general]/1.");

    using traits_type            = _Traits;
    using value_type             = _Elem;
    using pointer                = _Elem*;
    using const_pointer          = const _Elem*;
    using reference              = _Elem&;
    using const_reference        = const _Elem&;
    using const_iterator         = _String_view_iterator<_Traits>;
    using iterator               = const_iterator;
    using const_reverse_iterator = ::std:: reverse_iterator<const_iterator>;
    using reverse_iterator       = const_reverse_iterator;
    using size_type              = size_t;
    using difference_type        = ptrdiff_t;

    static constexpr auto npos{static_cast<size_type>(-1)};

    constexpr basic_string_view() noexcept : _Mydata(), _Mysize(0) {}

    constexpr basic_string_view(const basic_string_view&) noexcept            = default;
    constexpr basic_string_view& operator=(const basic_string_view&) noexcept = default;

      constexpr basic_string_view( const const_pointer _Ntcts) noexcept 
        : _Mydata(_Ntcts), _Mysize(_Traits::length(_Ntcts)) {}



#line 1238 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

    constexpr basic_string_view(
         const const_pointer _Cts, const size_type _Count) noexcept 
        : _Mydata(_Cts), _Mysize(_Count) {


#line 1245 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
    }


    template <contiguous_iterator _Iter, sized_sentinel_for<_Iter> _Sent>
        requires (is_same_v<iter_value_t<_Iter>, _Elem> && !is_convertible_v<_Sent, size_type>)
    constexpr basic_string_view(_Iter _First, _Sent _Last) noexcept(noexcept(_Last - _First)) 
        : _Mydata(::std:: to_address(_First)), _Mysize(static_cast<size_type>(_Last - _First)) {}
















#line 1269 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
#line 1270 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

    [[nodiscard]] constexpr const_iterator begin() const noexcept {


#line 1275 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        return const_iterator(_Mydata);
#line 1277 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
    }

    [[nodiscard]] constexpr const_iterator end() const noexcept {


#line 1283 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        return const_iterator(_Mydata + _Mysize);
#line 1285 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
    }

    [[nodiscard]] constexpr const_iterator cbegin() const noexcept {
        return begin();
    }

    [[nodiscard]] constexpr const_iterator cend() const noexcept {
        return end();
    }

    [[nodiscard]] constexpr const_reverse_iterator rbegin() const noexcept {
        return const_reverse_iterator{end()};
    }

    [[nodiscard]] constexpr const_reverse_iterator rend() const noexcept {
        return const_reverse_iterator{begin()};
    }

    [[nodiscard]] constexpr const_reverse_iterator crbegin() const noexcept {
        return rbegin();
    }

    [[nodiscard]] constexpr const_reverse_iterator crend() const noexcept {
        return rend();
    }

    constexpr const_pointer _Unchecked_begin() const noexcept {
        return _Mydata;
    }

    constexpr const_pointer _Unchecked_end() const noexcept {
        return _Mydata + _Mysize;
    }

    [[nodiscard]] constexpr size_type size() const noexcept {
        return _Mysize;
    }

    [[nodiscard]] constexpr size_type length() const noexcept {
        return _Mysize;
    }

    [[nodiscard]] constexpr bool empty() const noexcept {
        return _Mysize == 0;
    }

    [[nodiscard]] constexpr const_pointer data() const noexcept {
        return _Mydata;
    }

    [[nodiscard]] constexpr size_type max_size() const noexcept {
        
        
        return (::std:: min)(static_cast<size_t>(9223372036854775807i64 ), static_cast<size_t>(-1) / sizeof(_Elem));
    }

    [[nodiscard]] constexpr const_reference operator[](const size_type _Off) const noexcept   {


#line 1345 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        return _Mydata[_Off];
    }

    [[nodiscard]] constexpr const_reference at(const size_type _Off) const {
        
        _Check_offset_exclusive(_Off);
        return _Mydata[_Off];
    }

    [[nodiscard]] constexpr const_reference front() const noexcept   {


#line 1358 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        return _Mydata[0];
    }

    [[nodiscard]] constexpr const_reference back() const noexcept   {


#line 1365 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        return _Mydata[_Mysize - 1];
    }

    constexpr void remove_prefix(const size_type _Count) noexcept   {


#line 1372 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        _Mydata += _Count;
        _Mysize -= _Count;
    }

    constexpr void remove_suffix(const size_type _Count) noexcept   {


#line 1380 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        _Mysize -= _Count;
    }

    constexpr void swap(basic_string_view& _Other) noexcept {
        const basic_string_view _Tmp{_Other}; 
        _Other = *this;
        *this  = _Tmp;
    }

    constexpr size_type copy(
         _Elem* const _Ptr, size_type _Count, const size_type _Off = 0) const {
        
        _Check_offset(_Off);
        _Count = _Clamp_suffix_size(_Off, _Count);
        _Traits::copy(_Ptr, _Mydata + _Off, _Count);
        return _Count;
    }

     constexpr size_type
        _Copy_s( _Elem* const _Dest, const size_type _Dest_size, size_type _Count,
            const size_type _Off = 0) const {
        
        _Check_offset(_Off);
        _Count = _Clamp_suffix_size(_Off, _Count);
        _Traits::_Copy_s(_Dest, _Dest_size, _Mydata + _Off, _Count);
        return _Count;
    }

    [[nodiscard]] constexpr basic_string_view substr(const size_type _Off = 0, size_type _Count = npos) const {
        
        _Check_offset(_Off);
        _Count = _Clamp_suffix_size(_Off, _Count);
        return basic_string_view(_Mydata + _Off, _Count);
    }

    constexpr bool _Equal(const basic_string_view _Right) const noexcept {
        return _Traits_equal<_Traits>(_Mydata, _Mysize, _Right._Mydata, _Right._Mysize);
    }

    [[nodiscard]] constexpr int compare(const basic_string_view _Right) const noexcept {
        return _Traits_compare<_Traits>(_Mydata, _Mysize, _Right._Mydata, _Right._Mysize);
    }

    [[nodiscard]] constexpr int compare(const size_type _Off, const size_type _Nx, const basic_string_view _Right) const {
        
        return substr(_Off, _Nx).compare(_Right);
    }

    [[nodiscard]] constexpr int compare(const size_type _Off, const size_type _Nx, const basic_string_view _Right,
        const size_type _Roff, const size_type _Count) const {
        
        return substr(_Off, _Nx).compare(_Right.substr(_Roff, _Count));
    }

    [[nodiscard]] constexpr int compare( const _Elem* const _Ptr) const { 
        return compare(basic_string_view(_Ptr));
    }

    [[nodiscard]] constexpr int compare(const size_type _Off, const size_type _Nx,  const _Elem* const _Ptr) const {
        
        return substr(_Off, _Nx).compare(basic_string_view(_Ptr));
    }

    [[nodiscard]] constexpr int compare(const size_type _Off, const size_type _Nx,
         const _Elem* const _Ptr, const size_type _Count) const {
        
        return substr(_Off, _Nx).compare(basic_string_view(_Ptr, _Count));
    }


    [[nodiscard]] constexpr bool starts_with(const basic_string_view _Right) const noexcept {
        const auto _Rightsize = _Right._Mysize;
        if (_Mysize < _Rightsize) {
            return false;
        }
        return _Traits::compare(_Mydata, _Right._Mydata, _Rightsize) == 0;
    }

    [[nodiscard]] constexpr bool starts_with(const _Elem _Right) const noexcept {
        return !empty() && _Traits::eq(front(), _Right);
    }

    [[nodiscard]] constexpr bool starts_with(const _Elem* const _Right) const noexcept   {
        return starts_with(basic_string_view(_Right));
    }

    [[nodiscard]] constexpr bool ends_with(const basic_string_view _Right) const noexcept {
        const auto _Rightsize = _Right._Mysize;
        if (_Mysize < _Rightsize) {
            return false;
        }
        return _Traits::compare(_Mydata + (_Mysize - _Rightsize), _Right._Mydata, _Rightsize) == 0;
    }

    [[nodiscard]] constexpr bool ends_with(const _Elem _Right) const noexcept {
        return !empty() && _Traits::eq(back(), _Right);
    }

    [[nodiscard]] constexpr bool ends_with(const _Elem* const _Right) const noexcept   {
        return ends_with(basic_string_view(_Right));
    }
#line 1482 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"













#line 1496 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

    [[nodiscard]] constexpr size_type find(const basic_string_view _Right, const size_type _Off = 0) const noexcept {
        
        return _Traits_find<_Traits>(_Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize);
    }

    [[nodiscard]] constexpr size_type find(const _Elem _Ch, const size_type _Off = 0) const noexcept {
        
        return _Traits_find_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
    }

    [[nodiscard]] constexpr size_type find( const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept   {
        
        return _Traits_find<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Count);
    }

    [[nodiscard]] constexpr size_type find( const _Elem* const _Ptr, const size_type _Off = 0) const noexcept
      {
        
        return _Traits_find<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr));
    }

    [[nodiscard]] constexpr size_type rfind(const basic_string_view _Right, const size_type _Off = npos) const noexcept {
        
        return _Traits_rfind<_Traits>(_Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize);
    }

    [[nodiscard]] constexpr size_type rfind(const _Elem _Ch, const size_type _Off = npos) const noexcept {
        
        return _Traits_rfind_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
    }

    [[nodiscard]] constexpr size_type rfind( const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept   {
        
        return _Traits_rfind<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Count);
    }

    [[nodiscard]] constexpr size_type rfind( const _Elem* const _Ptr, const size_type _Off = npos) const noexcept
      {
        
        return _Traits_rfind<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr));
    }

    [[nodiscard]] constexpr size_type find_first_of(const basic_string_view _Right,
        const size_type _Off = 0) const noexcept { 
        return _Traits_find_first_of<_Traits>(_Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize);
    }

    [[nodiscard]] constexpr size_type find_first_of(const _Elem _Ch, const size_type _Off = 0) const noexcept {
        
        return _Traits_find_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
    }

    [[nodiscard]] constexpr size_type find_first_of( const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept   {
        
        return _Traits_find_first_of<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Count);
    }

    [[nodiscard]] constexpr size_type find_first_of(
         const _Elem* const _Ptr, const size_type _Off = 0) const noexcept   {
        
        return _Traits_find_first_of<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr));
    }

    [[nodiscard]] constexpr size_type find_last_of(const basic_string_view _Right,
        const size_type _Off = npos) const noexcept { 
        return _Traits_find_last_of<_Traits>(_Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize);
    }

    [[nodiscard]] constexpr size_type find_last_of(const _Elem _Ch, const size_type _Off = npos) const noexcept {
        
        return _Traits_rfind_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
    }

    [[nodiscard]] constexpr size_type find_last_of( const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept   {
        
        return _Traits_find_last_of<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Count);
    }

    [[nodiscard]] constexpr size_type find_last_of(
         const _Elem* const _Ptr, const size_type _Off = npos) const noexcept   {
        
        return _Traits_find_last_of<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr));
    }

    [[nodiscard]] constexpr size_type find_first_not_of(const basic_string_view _Right,
        const size_type _Off = 0) const noexcept { 
        return _Traits_find_first_not_of<_Traits>(_Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize);
    }

    [[nodiscard]] constexpr size_type find_first_not_of(const _Elem _Ch, const size_type _Off = 0) const noexcept {
        
        return _Traits_find_not_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
    }

    [[nodiscard]] constexpr size_type find_first_not_of( const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept   {
        
        return _Traits_find_first_not_of<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Count);
    }

    [[nodiscard]] constexpr size_type find_first_not_of(
         const _Elem* const _Ptr, const size_type _Off = 0) const noexcept   {
        
        return _Traits_find_first_not_of<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr));
    }

    [[nodiscard]] constexpr size_type find_last_not_of(const basic_string_view _Right,
        const size_type _Off = npos) const noexcept { 
        return _Traits_find_last_not_of<_Traits>(_Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize);
    }

    [[nodiscard]] constexpr size_type find_last_not_of(const _Elem _Ch, const size_type _Off = npos) const noexcept {
        
        return _Traits_rfind_not_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
    }

    [[nodiscard]] constexpr size_type find_last_not_of( const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept   {
        
        return _Traits_find_last_not_of<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Count);
    }

    [[nodiscard]] constexpr size_type find_last_not_of(
         const _Elem* const _Ptr, const size_type _Off = npos) const noexcept   {
        
        return _Traits_find_last_not_of<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr));
    }

    [[nodiscard]] constexpr bool _Starts_with(const basic_string_view _View) const noexcept {
        return _Mysize >= _View._Mysize && _Traits::compare(_Mydata, _View._Mydata, _View._Mysize) == 0;
    }

private:
    constexpr void _Check_offset(const size_type _Off) const { 
        if (_Mysize < _Off) {
            _Xran();
        }
    }

    constexpr void _Check_offset_exclusive(const size_type _Off) const {
        
        if (_Mysize <= _Off) {
            _Xran();
        }
    }

    constexpr size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
        
        return (::std:: min)(_Size, _Mysize - _Off);
    }

    [[noreturn]] static void _Xran() {
        _Xout_of_range("invalid string_view position");
    }

    const_pointer _Mydata;
    size_type _Mysize;
};

#pragma warning(pop)


template <contiguous_iterator _Iter, sized_sentinel_for<_Iter> _Sent>
basic_string_view(_Iter, _Sent) -> basic_string_view<iter_value_t<_Iter>>;




#line 1670 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

namespace ranges {
    template <class _Elem, class _Traits>
    inline constexpr bool enable_view<basic_string_view<_Elem, _Traits>> = true;
    template <class _Elem, class _Traits>
    inline constexpr bool enable_borrowed_range<basic_string_view<_Elem, _Traits>> = true;
} 
#line 1678 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

 template <class _Elem, class _Traits>
[[nodiscard]] constexpr bool operator==(
    const basic_string_view<_Elem, _Traits> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
    return _Lhs._Equal(_Rhs);
}







#line 1692 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

 template <class _Elem, class _Traits, int = 2> 
[[nodiscard]] constexpr bool operator==(
    const basic_string_view<_Elem, _Traits> _Lhs, const _Identity_t<basic_string_view<_Elem, _Traits>> _Rhs) noexcept {
    return _Lhs._Equal(_Rhs);
}































































































#line 1794 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"


template <class _Traits, class = void>
struct _Get_comparison_category {
    using type = weak_ordering;
};

template <class _Traits>
struct _Get_comparison_category<_Traits, void_t<typename _Traits::comparison_category>> {
    using type = typename _Traits::comparison_category;

    static_assert(_Is_any_of_v<type, partial_ordering, weak_ordering, strong_ordering>,
        "N4910 23.3.5 [string.view.comparison]/4: Mandates: R denotes a comparison category type.");
};

template <class _Traits>
using _Get_comparison_category_t = typename _Get_comparison_category<_Traits>::type;

 template <class _Elem, class _Traits>
[[nodiscard]] constexpr _Get_comparison_category_t<_Traits> operator<=>(
    const basic_string_view<_Elem, _Traits> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
    return static_cast<_Get_comparison_category_t<_Traits>>(_Lhs.compare(_Rhs) <=> 0);
}

 template <class _Elem, class _Traits, int = 2> 
[[nodiscard]] constexpr _Get_comparison_category_t<_Traits> operator<=>(
    const basic_string_view<_Elem, _Traits> _Lhs, const _Identity_t<basic_string_view<_Elem, _Traits>> _Rhs) noexcept {
    return static_cast<_Get_comparison_category_t<_Traits>>(_Lhs.compare(_Rhs) <=> 0);
}
#line 1824 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

 using string_view = basic_string_view<char>;

 using u8string_view = basic_string_view<char8_t>;
#line 1829 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
 using u16string_view = basic_string_view<char16_t>;
 using u32string_view = basic_string_view<char32_t>;
 using wstring_view   = basic_string_view<wchar_t>;


template <class _Elem>
struct hash<basic_string_view<_Elem>> : _Conditionally_enabled_hash<basic_string_view<_Elem>, _Is_EcharT<_Elem>> {
    [[nodiscard]] static size_t _Do_hash(const basic_string_view<_Elem> _Keyval) noexcept {
        return _Hash_array_representation(_Keyval.data(), _Keyval.size());
    }
};

 template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& operator<<(
    basic_ostream<_Elem, _Traits>& _Ostr, const basic_string_view<_Elem, _Traits> _Str) {
    return _Insert_string(_Ostr, _Str.data(), _Str.size());
}


inline namespace literals {
    inline namespace string_view_literals {
         [[nodiscard]] constexpr string_view operator""sv(const char* _Str, size_t _Len) noexcept {
            return string_view(_Str, _Len);
        }

         [[nodiscard]] constexpr wstring_view operator""sv(const wchar_t* _Str, size_t _Len) noexcept {
            return wstring_view(_Str, _Len);
        }


         [[nodiscard]] constexpr basic_string_view<char8_t> operator""sv(
            const char8_t* _Str, size_t _Len) noexcept {
            return basic_string_view<char8_t>(_Str, _Len);
        }
#line 1864 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

         [[nodiscard]] constexpr u16string_view operator""sv(const char16_t* _Str, size_t _Len) noexcept {
            return u16string_view(_Str, _Len);
        }

         [[nodiscard]] constexpr u32string_view operator""sv(const char32_t* _Str, size_t _Len) noexcept {
            return u32string_view(_Str, _Len);
        }
    } 
} 
#line 1875 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

template <class _Mystr>
class _String_const_iterator : public _Iterator_base {
public:

    using iterator_concept = contiguous_iterator_tag;
#line 1882 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
    using iterator_category = random_access_iterator_tag;
    using value_type        = typename _Mystr::value_type;
    using difference_type   = typename _Mystr::difference_type;
    using pointer           = typename _Mystr::const_pointer;
    using reference         = const value_type&;

    constexpr _String_const_iterator() noexcept : _Ptr() {}

    constexpr _String_const_iterator(pointer _Parg, const _Container_base* _Pstring) noexcept : _Ptr(_Parg) {
        this->_Adopt(_Pstring);
    }

    [[nodiscard]] constexpr reference operator*() const noexcept {









#line 1905 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

         ;
        return *_Ptr;
    }

    [[nodiscard]] constexpr pointer operator->() const noexcept {
        return pointer_traits<pointer>::pointer_to(**this);
    }

    constexpr _String_const_iterator& operator++() noexcept {






#line 1922 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

        ++_Ptr;
        return *this;
    }

    constexpr _String_const_iterator operator++(int) noexcept {
        _String_const_iterator _Tmp = *this;
        ++*this;
        return _Tmp;
    }

    constexpr _String_const_iterator& operator--() noexcept {






#line 1941 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

        --_Ptr;
        return *this;
    }

    constexpr _String_const_iterator operator--(int) noexcept {
        _String_const_iterator _Tmp = *this;
        --*this;
        return _Tmp;
    }

    constexpr void _Verify_offset(const difference_type _Off) const noexcept {





















#line 1975 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        (void) _Off;
#line 1977 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
    }

    constexpr _String_const_iterator& operator+=(const difference_type _Off) noexcept {


#line 1983 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        _Ptr += _Off;
        return *this;
    }

    [[nodiscard]] constexpr _String_const_iterator operator+(const difference_type _Off) const noexcept {
        _String_const_iterator _Tmp = *this;
        _Tmp += _Off;
        return _Tmp;
    }

    [[nodiscard]] friend constexpr _String_const_iterator operator+(
        const difference_type _Off, _String_const_iterator _Next) noexcept {
        _Next += _Off;
        return _Next;
    }

    constexpr _String_const_iterator& operator-=(const difference_type _Off) noexcept {
        return *this += -_Off;
    }

    [[nodiscard]] constexpr _String_const_iterator operator-(const difference_type _Off) const noexcept {
        _String_const_iterator _Tmp = *this;
        _Tmp -= _Off;
        return _Tmp;
    }

    [[nodiscard]] constexpr difference_type operator-(const _String_const_iterator& _Right) const noexcept {
        _Compat(_Right);
        return _Ptr - _Right._Ptr;
    }

    [[nodiscard]] constexpr reference operator[](const difference_type _Off) const noexcept {
        return *(*this + _Off);
    }

    [[nodiscard]] constexpr bool operator==(const _String_const_iterator& _Right) const noexcept {
        _Compat(_Right);
        return _Ptr == _Right._Ptr;
    }


    [[nodiscard]] constexpr strong_ordering operator<=>(const _String_const_iterator& _Right) const noexcept {
        _Compat(_Right);
        return _Unfancy(_Ptr) <=> _Unfancy(_Right._Ptr);
    }





















#line 2050 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

    constexpr void _Compat(const _String_const_iterator& _Right) const noexcept {
        



#line 2057 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        (void) _Right;
#line 2059 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
    }







#line 2068 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

    using _Prevent_inheriting_unwrap = _String_const_iterator;

    [[nodiscard]] constexpr const value_type* _Unwrapped() const noexcept {
        return _Unfancy(_Ptr);
    }

    constexpr void _Seek_to(const value_type* _It) noexcept {
        _Ptr = _Refancy<pointer>(const_cast<value_type*>(_It));
    }

    pointer _Ptr; 
};


template <class _Mystr>
struct pointer_traits<_String_const_iterator<_Mystr>> {
    using pointer         = _String_const_iterator<_Mystr>;
    using element_type    = const typename pointer::value_type;
    using difference_type = typename pointer::difference_type;

    [[nodiscard]] static constexpr element_type* to_address(const pointer _Iter) noexcept {






#line 2097 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

        const auto _Rawptr = ::std:: to_address(_Iter._Ptr);







#line 2107 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

        return _Rawptr;
    }
};
#line 2112 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

template <class _Mystr>
class _String_iterator : public _String_const_iterator<_Mystr> {
public:
    using _Mybase = _String_const_iterator<_Mystr>;


    using iterator_concept = contiguous_iterator_tag;
#line 2121 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
    using iterator_category = random_access_iterator_tag;
    using value_type        = typename _Mystr::value_type;
    using difference_type   = typename _Mystr::difference_type;
    using pointer           = typename _Mystr::pointer;
    using reference         = value_type&;

    using _Mybase::_Mybase;

    [[nodiscard]] constexpr reference operator*() const noexcept {
        return const_cast<reference>(_Mybase::operator*());
    }

    [[nodiscard]] constexpr pointer operator->() const noexcept {
        return pointer_traits<pointer>::pointer_to(**this);
    }

    constexpr _String_iterator& operator++() noexcept {
        _Mybase::operator++();
        return *this;
    }

    constexpr _String_iterator operator++(int) noexcept {
        _String_iterator _Tmp = *this;
        _Mybase::operator++();
        return _Tmp;
    }

    constexpr _String_iterator& operator--() noexcept {
        _Mybase::operator--();
        return *this;
    }

    constexpr _String_iterator operator--(int) noexcept {
        _String_iterator _Tmp = *this;
        _Mybase::operator--();
        return _Tmp;
    }

    constexpr _String_iterator& operator+=(const difference_type _Off) noexcept {
        _Mybase::operator+=(_Off);
        return *this;
    }

    [[nodiscard]] constexpr _String_iterator operator+(const difference_type _Off) const noexcept {
        _String_iterator _Tmp = *this;
        _Tmp += _Off;
        return _Tmp;
    }

    [[nodiscard]] friend constexpr _String_iterator operator+(
        const difference_type _Off, _String_iterator _Next) noexcept {
        _Next += _Off;
        return _Next;
    }

    constexpr _String_iterator& operator-=(const difference_type _Off) noexcept {
        _Mybase::operator-=(_Off);
        return *this;
    }

    using _Mybase::operator-;

    [[nodiscard]] constexpr _String_iterator operator-(const difference_type _Off) const noexcept {
        _String_iterator _Tmp = *this;
        _Tmp -= _Off;
        return _Tmp;
    }

    [[nodiscard]] constexpr reference operator[](const difference_type _Off) const noexcept {
        return const_cast<reference>(_Mybase::operator[](_Off));
    }

    using _Prevent_inheriting_unwrap = _String_iterator;

    [[nodiscard]] constexpr value_type* _Unwrapped() const noexcept {
        return const_cast<value_type*>(_Unfancy(this->_Ptr));
    }
};


template <class _Mystr>
struct pointer_traits<_String_iterator<_Mystr>> {
    using pointer         = _String_iterator<_Mystr>;
    using element_type    = typename pointer::value_type;
    using difference_type = typename pointer::difference_type;

    [[nodiscard]] static constexpr element_type* to_address(const pointer _Iter) noexcept {






#line 2215 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

        const auto _Rawptr = ::std:: to_address(_Iter._Ptr);







#line 2225 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

        return const_cast<element_type*>(_Rawptr);
    }
};
#line 2230 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

template <class _Value_type, class _Size_type, class _Difference_type, class _Pointer, class _Const_pointer,
    class _Reference, class _Const_reference>
struct _String_iter_types {
    using value_type      = _Value_type;
    using size_type       = _Size_type;
    using difference_type = _Difference_type;
    using pointer         = _Pointer;
    using const_pointer   = _Const_pointer;
};

template <class _Val_types>
class _String_val : public _Container_base {
public:
    using value_type      = typename _Val_types::value_type;
    using size_type       = typename _Val_types::size_type;
    using difference_type = typename _Val_types::difference_type;
    using pointer         = typename _Val_types::pointer;
    using const_pointer   = typename _Val_types::const_pointer;
    using reference       = value_type&;
    using const_reference = const value_type&;

    constexpr _String_val() noexcept : _Bx() {}

    
    static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
    
    static constexpr size_type _ALLOC_MASK = sizeof(value_type) <= 1 ? 15
                                           : sizeof(value_type) <= 2 ? 7
                                           : sizeof(value_type) <= 4 ? 3
                                           : sizeof(value_type) <= 8 ? 1
                                                                     : 0;

    constexpr value_type* _Myptr() noexcept {
        value_type* _Result = _Bx._Buf;
        if (_Large_string_engaged()) {
            _Result = _Unfancy(_Bx._Ptr);
        }

        return _Result;
    }

    constexpr const value_type* _Myptr() const noexcept {
        const value_type* _Result = _Bx._Buf;
        if (_Large_string_engaged()) {
            _Result = _Unfancy(_Bx._Ptr);
        }

        return _Result;
    }

    constexpr bool _Large_string_engaged() const noexcept {
        return _BUF_SIZE <= _Myres;
    }

    constexpr void _Activate_SSO_buffer() noexcept {
        

        if (::std:: is_constant_evaluated()) {
            for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
                _Bx._Buf[_Idx] = value_type();
            }
        }
#line 2294 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
    }

    constexpr void _Check_offset(const size_type _Off) const {
        
        if (_Mysize < _Off) {
            _Xran();
        }
    }

    constexpr void _Check_offset_exclusive(const size_type _Off) const {
        
        if (_Mysize <= _Off) {
            _Xran();
        }
    }

    [[noreturn]] static void _Xran() {
        _Xout_of_range("invalid string position");
    }

    constexpr size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
        
        return (::std:: min)(_Size, _Mysize - _Off);
    }

    union _Bxty { 
        
        
        constexpr _Bxty() noexcept : _Buf() {} 
        constexpr ~_Bxty() noexcept {} 

        value_type _Buf[_BUF_SIZE];
        pointer _Ptr;
        char _Alias[_BUF_SIZE]; 
    } _Bx;

    size_type _Mysize = 0; 
    size_type _Myres  = 0; 
};


template <class _Ty>
inline constexpr size_t _Size_after_ebco_v = is_empty_v<_Ty> ? 0 : sizeof(_Ty);

struct _String_constructor_concat_tag {
    
    explicit _String_constructor_concat_tag() = default;
};

struct _String_constructor_rvalue_allocator_tag {
    
    explicit _String_constructor_rvalue_allocator_tag() = default;
};

[[noreturn]] inline void _Xlen_string() {
    _Xlength_error("string too long");
}





#line 2357 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

 template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
class basic_string { 
private:
    friend _Tidy_deallocate_guard<basic_string>;
    friend basic_stringbuf<_Elem, _Traits, _Alloc>;

    using _Alty        = _Rebind_alloc_t<_Alloc, _Elem>;
    using _Alty_traits = allocator_traits<_Alty>;

    using _Scary_val = _String_val<conditional_t<_Is_simple_alloc_v<_Alty>, _Simple_types<_Elem>,
        _String_iter_types<_Elem, typename _Alty_traits::size_type, typename _Alty_traits::difference_type,
            typename _Alty_traits::pointer, typename _Alty_traits::const_pointer, _Elem&, const _Elem&>>>;

    static_assert(!1 || is_same_v<_Elem, typename _Alloc::value_type>,
        "basic_string<T, Traits, Allocator>" " requires that Allocator's value_type match " "T" " (See N4659 26.2.1 [container.requirements.general]/16 allocator_type)" " Either fix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0" " to suppress this error." );

    static_assert(is_same_v<_Elem, typename _Traits::char_type>,
        "N4910 23.4.3.2 [string.require]/3 requires that the supplied "
        "char_traits character type match the string's character type.");

    static_assert(!is_array_v<_Elem> && is_trivial_v<_Elem> && is_standard_layout_v<_Elem>,
        "The character type of basic_string must be a non-array trivial standard-layout type. See N4910 "
        "23.1 [strings.general]/1.");

public:
    using traits_type    = _Traits;
    using allocator_type = _Alloc;

    using value_type      = _Elem;
    using size_type       = typename _Alty_traits::size_type;
    using difference_type = typename _Alty_traits::difference_type;
    using pointer         = typename _Alty_traits::pointer;
    using const_pointer   = typename _Alty_traits::const_pointer;
    using reference       = value_type&;
    using const_reference = const value_type&;

    using iterator       = _String_iterator<_Scary_val>;
    using const_iterator = _String_const_iterator<_Scary_val>;

    using reverse_iterator       = ::std:: reverse_iterator<iterator>;
    using const_reverse_iterator = ::std:: reverse_iterator<const_iterator>;

private:
    static constexpr auto _BUF_SIZE   = _Scary_val::_BUF_SIZE;
    static constexpr auto _ALLOC_MASK = _Scary_val::_ALLOC_MASK;

    
    
    
    
    
    
    
    
    
    
    static constexpr bool _Can_memcpy_val = _Is_specialization_v<_Traits, char_traits> && is_trivial_v<pointer>;
    
    static constexpr size_t _Memcpy_val_offset = _Size_after_ebco_v<_Container_base>;
    static constexpr size_t _Memcpy_val_size   = sizeof(_Scary_val) - _Memcpy_val_offset;

    template <class _Iter>
    
    
    using _Is_elem_cptr = bool_constant<_Is_any_of_v<_Iter, const _Elem* const, _Elem* const, const _Elem*, _Elem*>>;


    template <class _StringViewIsh>
    using _Is_string_view_ish =
        enable_if_t<conjunction_v<is_convertible<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>,
                        negation<is_convertible<const _StringViewIsh&, const _Elem*>>>,
            int>;
#line 2431 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"


















































































#line 2514 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

public:
    constexpr
    basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {
        _Mypair._Myval2._Alloc_proxy(_Fake_alloc );
        _Tidy_init();
    }

    constexpr explicit basic_string(const _Alloc& _Al) noexcept : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Mypair._Myval2._Alloc_proxy(_Fake_alloc );
        _Tidy_init();
    }

    constexpr basic_string(const basic_string& _Right)
        : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {
        _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }

    constexpr basic_string(const basic_string& _Right, const _Alloc& _Al)
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }

    constexpr basic_string(const basic_string& _Right, const size_type _Roff, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) { 
        _Right._Mypair._Myval2._Check_offset(_Roff);
        _Construct<_Construct_strategy::_From_ptr>(
            _Right._Mypair._Myval2._Myptr() + _Roff, _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, npos));
    }

    constexpr basic_string(
        const basic_string& _Right, const size_type _Roff, const size_type _Count, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) { 
        _Right._Mypair._Myval2._Check_offset(_Roff);
        _Construct<_Construct_strategy::_From_ptr>(
            _Right._Mypair._Myval2._Myptr() + _Roff, _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count));
    }












#line 2564 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

    constexpr basic_string( const _Elem* const _Ptr,  const size_type _Count)
        : _Mypair(_Zero_then_variadic_args_t{}) {
        _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Count);
    }

    constexpr basic_string(
         const _Elem* const _Ptr,  const size_type _Count, const _Alloc& _Al)
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Count);
    }

    constexpr basic_string( const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {
        _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
    }



#line 2583 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"


    template <class _Alloc2 = _Alloc, enable_if_t<_Is_allocator<_Alloc2>::value, int> = 0>
#line 2587 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
    constexpr basic_string( const _Elem* const _Ptr, const _Alloc& _Al)
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
    }

    constexpr basic_string( const size_type _Count, const _Elem _Ch)
        : _Mypair(_Zero_then_variadic_args_t{}) { 
        _Construct<_Construct_strategy::_From_char>(_Ch, _Count);
    }


    template <class _Alloc2 = _Alloc, enable_if_t<_Is_allocator<_Alloc2>::value, int> = 0>
#line 2600 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
    constexpr basic_string( const size_type _Count, const _Elem _Ch, const _Alloc& _Al)
        : _Mypair(_One_then_variadic_args_t{}, _Al) { 
        _Construct<_Construct_strategy::_From_char>(_Ch, _Count);
    }

    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    constexpr basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Adl_verify_range(_First, _Last);
        auto _UFirst = _Get_unwrapped(_First);
        auto _ULast  = _Get_unwrapped(_Last);
        if (_UFirst == _ULast) {
            _Mypair._Myval2._Alloc_proxy(_Fake_alloc );
            _Tidy_init();
        } else {
            if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
                _Construct<_Construct_strategy::_From_ptr>(
                    _UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
            } else if constexpr (_Is_cpp17_fwd_iter_v<decltype(_UFirst)>) {
                const auto _Length = static_cast<size_t>(::std:: distance(_UFirst, _ULast));
                const auto _Count  = _Convert_size<size_type>(_Length);
                _Construct_from_iter(::std:: move(_UFirst), ::std:: move(_ULast), _Count);
            } else {
                _Construct_from_iter(::std:: move(_UFirst), ::std:: move(_ULast));
            }
        }
    }

private:
    static constexpr void _Start_element_lifetimes(_Elem* const _Ptr, const size_type _Size) {
        
        

        if (::std:: is_constant_evaluated()) {
            for (size_type _Idx = 0; _Idx < _Size; ++_Idx) {
                ::std:: construct_at(_Ptr + _Idx);
            }
        }



#line 2642 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
    }

    enum class _Construct_strategy : uint8_t { _From_char, _From_ptr, _From_string };

    template <_Construct_strategy _Strat, class _Char_or_ptr>
    constexpr void _Construct(const _Char_or_ptr _Arg,  const size_type _Count) {
        auto& _My_data = _Mypair._Myval2;
         ;

        if constexpr (_Strat == _Construct_strategy::_From_char) {
             ;
        } else {
             ;
        }

        if (_Count > max_size()) {
            _Xlen_string(); 
        }

        auto& _Al       = _Getal();
        auto&& _Alproxy = _Fake_alloc ;
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

        if (_Count < _BUF_SIZE) {
            _My_data._Mysize = _Count;
            _My_data._Myres  = _BUF_SIZE - 1;

            if constexpr (_Strat == _Construct_strategy::_From_char) {
                _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
                _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
            } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
                _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);
                _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
            } else { 



                _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
#line 2681 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
            }

            _Proxy._Release();
            return;
        }

        _My_data._Myres               = _BUF_SIZE - 1;
        const size_type _New_capacity = _Calculate_growth(_Count);
        const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); 
        _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

        _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);

        _My_data._Mysize = _Count;
        _My_data._Myres  = _New_capacity;
        if constexpr (_Strat == _Construct_strategy::_From_char) {
            _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
            _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
        } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
            _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
            _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
        } else { 
            _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
        }

         ;
        _Proxy._Release();
    }

    template <class _Iter, class _Sent, class _Size = nullptr_t>
    constexpr void _Construct_from_iter(_Iter _First, const _Sent _Last, _Size _Count = {}) {
        
        
        
        

        auto& _My_data  = _Mypair._Myval2;
        auto& _Al       = _Getal();
        auto&& _Alproxy = _Fake_alloc ;
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

        _My_data._Mysize = 0;
        _My_data._Myres  = _BUF_SIZE - 1;

        if constexpr (is_same_v<_Size, size_type>) {
            if (_Count > max_size()) {
                _Xlen_string(); 
            }

            if (_Count >= _BUF_SIZE) {
                const size_type _New_capacity = _Calculate_growth(_Count);
                const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); 
                _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);
                _My_data._Myres = _New_capacity;

                _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
            }
        }

        _Tidy_deallocate_guard<basic_string> _Guard{this};
        for (; _First != _Last; ++_First) {
            if constexpr (!is_same_v<_Size, size_type>) {
                if (_My_data._Mysize == _My_data._Myres) { 
                    if (_My_data._Mysize == max_size()) {
                        _Xlen_string(); 
                    }

                    const auto _Old_ptr           = _My_data._Myptr();
                    const size_type _New_capacity = _Calculate_growth(_My_data._Mysize);
                    const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); 

                    _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
                    _Traits::copy(_Unfancy(_New_ptr), _Old_ptr, _My_data._Mysize);
                    if (_My_data._Myres >= _BUF_SIZE) { 
                        _Al.deallocate(_My_data._Bx._Ptr, _My_data._Myres + 1);
                        _My_data._Bx._Ptr = _New_ptr;
                    } else {
                        _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);
                    }
                    _My_data._Myres = _New_capacity;
                }
            }

            _Elem* const _Ptr = _My_data._Myptr();
            _Traits::assign(_Ptr[_My_data._Mysize], *_First);
            ++_My_data._Mysize;
        }

        _Elem* const _Ptr = _My_data._Myptr();
        _Traits::assign(_Ptr[_My_data._Mysize], _Elem());
         ;
        _Guard._Target = nullptr;
        _Proxy._Release();
    }

public:
















#line 2794 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

    constexpr basic_string(basic_string&& _Right) noexcept
        : _Mypair(_One_then_variadic_args_t{}, ::std:: move(_Right._Getal())) {
        _Mypair._Myval2._Alloc_proxy(_Fake_alloc );
        _Take_contents(_Right);
    }

    constexpr basic_string(basic_string&& _Right, const _Alloc& _Al) noexcept(
        _Alty_traits::is_always_equal::value) 
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        if constexpr (!_Alty_traits::is_always_equal::value) {
            if (_Getal() != _Right._Getal()) {
                _Construct<_Construct_strategy::_From_string>(
                    _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
                return;
            }
        }

        _Mypair._Myval2._Alloc_proxy(_Fake_alloc );
        _Take_contents(_Right);
    }

    constexpr basic_string(_String_constructor_concat_tag, const basic_string& _Source_of_al,
        const _Elem* const _Left_ptr, const size_type _Left_size, const _Elem* const _Right_ptr,
        const size_type _Right_size)
        : _Mypair(
            _One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Source_of_al._Getal())) {
         ;
         ;
         ;
        const auto _New_size    = static_cast<size_type>(_Left_size + _Right_size);
        size_type _New_capacity = _BUF_SIZE - 1;
        auto& _My_data          = _Mypair._Myval2;
        _Elem* _Ptr             = _My_data._Bx._Buf;
        auto&& _Alproxy         = _Fake_alloc ;
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data); 

        if (_New_capacity < _New_size) {
            _New_capacity           = _Calculate_growth(_New_size, _BUF_SIZE - 1, max_size());
            const pointer _Fancyptr = _Getal().allocate(_New_capacity + 1); 
            _Ptr                    = _Unfancy(_Fancyptr);
            _Construct_in_place(_My_data._Bx._Ptr, _Fancyptr);

            _Start_element_lifetimes(_Ptr, _New_capacity + 1);
        }

        _My_data._Mysize = _New_size;
        _My_data._Myres  = _New_capacity;
        _Traits::copy(_Ptr, _Left_ptr, _Left_size);
        _Traits::copy(_Ptr + static_cast<ptrdiff_t>(_Left_size), _Right_ptr, _Right_size);
        _Traits::assign(_Ptr[_New_size], _Elem());
         ;
        _Proxy._Release();
    }

    constexpr basic_string(_String_constructor_concat_tag, basic_string& _Left, basic_string& _Right)
        : _Mypair(_One_then_variadic_args_t{}, _Left._Getal()) {
        auto& _My_data    = _Mypair._Myval2;
        auto& _Left_data  = _Left._Mypair._Myval2;
        auto& _Right_data = _Right._Mypair._Myval2;
        _Left_data._Orphan_all();
        _Right_data._Orphan_all();
        const auto _Left_size  = _Left_data._Mysize;
        const auto _Right_size = _Right_data._Mysize;

        const auto _Left_capacity  = _Left_data._Myres;
        const auto _Right_capacity = _Right_data._Myres;
        
        const auto _New_size     = static_cast<size_type>(_Left_size + _Right_size);
        const bool _Fits_in_left = _Right_size <= _Left_capacity - _Left_size;
        if (_Fits_in_left && _Right_capacity <= _Left_capacity) {
            
            _My_data._Alloc_proxy(_Fake_alloc ); 
            _Take_contents(_Left);
            const auto _Ptr = _My_data._Myptr();
             ;
            _Traits::copy(_Ptr + _Left_size, _Right_data._Myptr(), _Right_size + 1);
            _My_data._Mysize = _New_size;
            return;
        }

        const bool _Fits_in_right = _Left_size <= _Right_capacity - _Right_size;
        if (_Allocators_equal(_Getal(), _Right._Getal()) && _Fits_in_right) {
            
            
            
            
            
            
            
            
            
             ;
            _My_data._Alloc_proxy(_Fake_alloc ); 
            _Take_contents(_Right);
            const auto _Ptr = _Unfancy(_My_data._Bx._Ptr);
             ;
            _Traits::move(_Ptr + _Left_size, _Ptr, _Right_size + 1);
            _Traits::copy(_Ptr, _Left_data._Myptr(), _Left_size);
            _My_data._Mysize = _New_size;
            return;
        }

        
        const auto _Max = max_size();
        if (_Max - _Left_size < _Right_size) { 
            _Xlen_string();
        }

        const auto _New_capacity = _Calculate_growth(_New_size, _BUF_SIZE - 1, _Max);
        auto&& _Alproxy          = _Fake_alloc ;
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data); 
        const pointer _Fancyptr = _Getal().allocate(_New_capacity + 1); 
        
        _Start_element_lifetimes(_Unfancy(_Fancyptr), _New_capacity + 1);
        _Construct_in_place(_My_data._Bx._Ptr, _Fancyptr);
        _My_data._Mysize = _New_size;
        _My_data._Myres  = _New_capacity;
        const auto _Ptr  = _Unfancy(_Fancyptr);
        _Traits::copy(_Ptr, _Left_data._Myptr(), _Left_size);
        _Traits::copy(_Ptr + _Left_size, _Right_data._Myptr(), _Right_size + 1);
         ;
        _Proxy._Release();
    }


    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    constexpr explicit basic_string(const _StringViewIsh& _Right, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        const basic_string_view<_Elem, _Traits> _As_view = _Right;
        _Construct<_Construct_strategy::_From_ptr>(_As_view.data(), _Convert_size<size_type>(_As_view.size()));
    }

    template <class _Ty, enable_if_t<is_convertible_v<const _Ty&, basic_string_view<_Elem, _Traits>>, int> = 0>
    constexpr basic_string(
        const _Ty& _Right, const size_type _Roff, const size_type _Count, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) { 
        const basic_string_view<_Elem, _Traits> _As_view = _Right;
        const auto _As_sub_view                          = _As_view.substr(_Roff, _Count);
        _Construct<_Construct_strategy::_From_ptr>(_As_sub_view.data(), _Convert_size<size_type>(_As_sub_view.size()));
    }
#line 2936 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"


    basic_string(_String_constructor_rvalue_allocator_tag, _Alloc&& _Al)
        : _Mypair(_One_then_variadic_args_t{}, ::std:: move(_Al)) {
        
        _Mypair._Myval2._Alloc_proxy(_Fake_alloc );
        _Tidy_init();
    }

    [[nodiscard]] bool _Move_assign_from_buffer(_Elem* const _Right, const size_type _Size, const size_type _Res) {
        
        auto& _My_data = _Mypair._Myval2;
         ;
         ; 
        _Traits::assign(_Right[_Size], _Elem());

        const bool _Is_large = _Res > _BUF_SIZE; 
        if (_Is_large) {
             ;
            _Construct_in_place(_My_data._Bx._Ptr, _Refancy<pointer>(_Right));
            _My_data._Mysize = _Size;
            _My_data._Myres  = _Res - 1;
             ;
        } else {
            _Traits::copy(_My_data._Bx._Buf, _Right, _Res);
            _My_data._Mysize = _Size;
            _My_data._Myres  = _BUF_SIZE - 1;
        }

        return _Is_large;
    }

    
    struct _Released_buffer {
        pointer _Ptr;
        size_type _Size;
        size_type _Res;
    };

    [[nodiscard]] _Released_buffer _Release_to_buffer(_Alloc& _Al) {
        
        _Released_buffer _Result;
        auto& _My_data = _Mypair._Myval2;
        _Result._Size  = _My_data._Mysize;
         ;
        if (_My_data._Large_string_engaged()) {
            _Result._Ptr = _My_data._Bx._Ptr;
            _Result._Res = _My_data._Myres + 1;
        } else {
            
            _Result._Ptr = _Al.allocate(_BUF_SIZE + 1);
            _Traits::copy(_Unfancy(_Result._Ptr), _My_data._Bx._Buf, _BUF_SIZE);
            _Result._Res = _BUF_SIZE + 1;
        }
        _My_data._Orphan_all();
        _Tidy_init();
        return _Result;
    }
#line 2995 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

    constexpr basic_string& operator=(basic_string&& _Right) noexcept(
        _Choose_pocma_v<_Alty> != _Pocma_values::_No_propagate_allocators) {
        if (this == ::std:: addressof(_Right)) {
            return *this;
        }

        auto& _Al                 = _Getal();
        auto& _Right_al           = _Right._Getal();
        constexpr auto _Pocma_val = _Choose_pocma_v<_Alty>;
        if constexpr (_Pocma_val == _Pocma_values::_Propagate_allocators) {
            if (_Al != _Right_al) {
                
                _Mypair._Myval2._Orphan_all();
                _Mypair._Myval2._Reload_proxy(_Fake_alloc , _Fake_alloc );
            }
        } else if constexpr (_Pocma_val == _Pocma_values::_No_propagate_allocators) {
            if (_Al != _Right_al) {
                assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
                return *this;
            }
        }

        _Tidy_deallocate();
        _Pocma(_Al, _Right_al);
        _Take_contents(_Right);
        return *this;
    }

    constexpr basic_string& assign(basic_string&& _Right) noexcept(noexcept(*this = ::std:: move(_Right))) {
        *this = ::std:: move(_Right);
        return *this;
    }

private:
    void _Memcpy_val_from(const basic_string& _Right) noexcept {
         ;
        const auto _My_data_mem =
            reinterpret_cast<unsigned char*>(::std:: addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
        const auto _Right_data_mem =
            reinterpret_cast<const unsigned char*>(::std:: addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
        :: memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);
    }

    constexpr void _Take_contents(basic_string& _Right) noexcept {
        
        
        
        
        
        auto& _My_data    = _Mypair._Myval2;
        auto& _Right_data = _Right._Mypair._Myval2;


        if constexpr (_Can_memcpy_val) {

            if (!::std:: is_constant_evaluated())
#line 3053 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
            {







#line 3062 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

                _Memcpy_val_from(_Right);
                _Right._Tidy_init();
                return;
            }
        }
#line 3069 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

        if (_Right_data._Large_string_engaged()) { 
            _Construct_in_place(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);
            _Right_data._Bx._Ptr = nullptr;
            _Swap_proxy_and_iterators(_Right);
        } else { 
            _My_data._Activate_SSO_buffer();
            _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);
            _Right_data._Orphan_all();
        }

        _My_data._Myres  = _Right_data._Myres;
        _My_data._Mysize = _Right_data._Mysize;


        _Right._Tidy_init();
    }





















#line 3108 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

public:
    constexpr basic_string(initializer_list<_Elem> _Ilist, const _Alloc& _Al = allocator_type())
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        auto&& _Alproxy = _Fake_alloc ;
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
        _Tidy_init();
        assign(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
        _Proxy._Release();
    }

    constexpr basic_string& operator=(initializer_list<_Elem> _Ilist) {
        return assign(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
    }

    constexpr basic_string& operator+=(initializer_list<_Elem> _Ilist) {
        return append(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
    }

    constexpr basic_string& assign(initializer_list<_Elem> _Ilist) {
        return assign(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
    }

    constexpr basic_string& append(initializer_list<_Elem> _Ilist) {
        return append(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
    }

    constexpr iterator insert(const const_iterator _Where, const initializer_list<_Elem> _Ilist) {


#line 3139 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
        insert(_Off, _Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
        return begin() + static_cast<difference_type>(_Off);
    }

    constexpr basic_string& replace(
        const const_iterator _First, const const_iterator _Last, const initializer_list<_Elem> _Ilist) {
        
        _Adl_verify_range(_First, _Last);


#line 3151 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        const auto _Offset = static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr());
        const auto _Length = static_cast<size_type>(_Last._Ptr - _First._Ptr);
        return replace(_Offset, _Length, _Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
    }

    constexpr ~basic_string() noexcept {
        _Tidy_deallocate();





#line 3164 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
    }

    static constexpr auto npos{static_cast<size_type>(-1)};

private:
    constexpr void _Copy_assign_val_from_small(const basic_string& _Right) {
        
        _Tidy_deallocate();

        if constexpr (_Can_memcpy_val) {

            if (!::std:: is_constant_evaluated())
#line 3177 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
            {
                _Memcpy_val_from(_Right);
                return;
            }
        }
#line 3183 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

        auto& _My_data    = _Mypair._Myval2;
        auto& _Right_data = _Right._Mypair._Myval2;

        _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);
        _My_data._Mysize = _Right_data._Mysize;
        _My_data._Myres  = _Right_data._Myres;
    }

public:
    constexpr basic_string& operator=(const basic_string& _Right) {
        if (this == ::std:: addressof(_Right)) {
            return *this;
        }

        auto& _Al             = _Getal();
        const auto& _Right_al = _Right._Getal();
        if constexpr (_Choose_pocca_v<_Alty>) {
            if (_Al != _Right_al) {
                auto&& _Alproxy       = _Fake_alloc ;
                auto&& _Right_alproxy = _Fake_alloc ;
                _Container_proxy_ptr<_Alty> _New_proxy(_Right_alproxy, _Leave_proxy_unbound{}); 

                if (_Right._Mypair._Myval2._Large_string_engaged()) {
                    const auto _New_size     = _Right._Mypair._Myval2._Mysize;
                    const auto _New_capacity = _Calculate_growth(_New_size, 0, _Right.max_size());
                    auto _Right_al_non_const = _Right_al;
                    const auto _New_ptr      = _Right_al_non_const.allocate(_New_capacity + 1); 

                    _Start_element_lifetimes(_Unfancy(_New_ptr), _New_size + 1);

                    _Traits::copy(_Unfancy(_New_ptr), _Unfancy(_Right._Mypair._Myval2._Bx._Ptr), _New_size + 1);
                    _Tidy_deallocate();
                    _Mypair._Myval2._Bx._Ptr = _New_ptr;
                    _Mypair._Myval2._Mysize  = _New_size;
                    _Mypair._Myval2._Myres   = _New_capacity;
                } else {
                    _Copy_assign_val_from_small(_Right);
                }

                _Pocca(_Al, _Right_al);
                _New_proxy._Bind(_Alproxy, ::std:: addressof(_Mypair._Myval2));
                return *this;
            }
        }

        _Pocca(_Al, _Right_al);
        assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
        return *this;
    }


    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    constexpr basic_string& operator=(const _StringViewIsh& _Right) {
        return assign(_Right);
    }
#line 3240 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

    constexpr basic_string& operator=( const _Elem* const _Ptr) {
        return assign(_Ptr);
    }



#line 3248 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

    constexpr basic_string& operator=(const _Elem _Ch) { 
         ;
        _Mypair._Myval2._Mysize = 1;
        _Elem* const _Ptr       = _Mypair._Myval2._Myptr();
        _Traits::assign(_Ptr[0], _Ch);
        _Traits::assign(_Ptr[1], _Elem());
        return *this;
    }

    constexpr basic_string& operator+=(const basic_string& _Right) {
        return append(_Right);
    }


    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    constexpr basic_string& operator+=(const _StringViewIsh& _Right) {
        return append(_Right);
    }
#line 3268 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

    constexpr basic_string& operator+=( const _Elem* const _Ptr) { 
        return append(_Ptr);
    }

    constexpr basic_string& operator+=(_Elem _Ch) {
        push_back(_Ch);
        return *this;
    }

    constexpr basic_string& append(const basic_string& _Right) {
        return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }

    constexpr basic_string& append(const basic_string& _Right, const size_type _Roff, size_type _Count = npos) {
        
        _Right._Mypair._Myval2._Check_offset(_Roff);
        _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
        return append(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);
    }


    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    constexpr basic_string& append(const _StringViewIsh& _Right) {
        const basic_string_view<_Elem, _Traits> _As_view = _Right;
        return append(_As_view.data(), _Convert_size<size_type>(_As_view.size()));
    }

    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    constexpr basic_string& append(
        const _StringViewIsh& _Right, const size_type _Roff, const size_type _Count = npos) {
        
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        return append(_As_view.substr(_Roff, _Count));
    }
#line 3304 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

    constexpr basic_string& append(
         const _Elem* const _Ptr,  const size_type _Count) {
        
        const size_type _Old_size = _Mypair._Myval2._Mysize;
        if (_Count <= _Mypair._Myval2._Myres - _Old_size) {
             ;
            _Mypair._Myval2._Mysize = _Old_size + _Count;
            _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
            _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);
            _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());
            return *this;
        }

        return _Reallocate_grow_by(
            _Count,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
                const size_type _Count) {
                _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
                _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
                _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
            },
            _Ptr, _Count);
    }

    constexpr basic_string& append( const _Elem* const _Ptr) { 
        return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
    }

    constexpr basic_string& append( const size_type _Count, const _Elem _Ch) {
        
        const size_type _Old_size = _Mypair._Myval2._Mysize;
        if (_Count <= _Mypair._Myval2._Myres - _Old_size) {
             ;
            _Mypair._Myval2._Mysize = _Old_size + _Count;
            _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
            _Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);
            _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());
            return *this;
        }

        return _Reallocate_grow_by(
            _Count,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Count,
                const _Elem _Ch) {
                _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
                _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
                _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
            },
            _Count, _Ch);
    }

    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    constexpr basic_string& append(const _Iter _First, const _Iter _Last) {
        
        _Adl_verify_range(_First, _Last);
        const auto _UFirst = _Get_unwrapped(_First);
        const auto _ULast  = _Get_unwrapped(_Last);
        if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
            return append(_UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
        } else {
            const basic_string _Right(_UFirst, _ULast, get_allocator());
            return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
        }
    }












#line 3382 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

    constexpr basic_string& assign(const basic_string& _Right) {
        *this = _Right;
        return *this;
    }

    constexpr basic_string& assign(const basic_string& _Right, const size_type _Roff, size_type _Count = npos) {
        
        _Right._Mypair._Myval2._Check_offset(_Roff);
        _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
        return assign(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);
    }


    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    constexpr basic_string& assign(const _StringViewIsh& _Right) {
        const basic_string_view<_Elem, _Traits> _As_view = _Right;
        return assign(_As_view.data(), _Convert_size<size_type>(_As_view.size()));
    }

    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    constexpr basic_string& assign(
        const _StringViewIsh& _Right, const size_type _Roff, const size_type _Count = npos) {
        
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        return assign(_As_view.substr(_Roff, _Count));
    }
#line 3410 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

    constexpr basic_string& assign(
         const _Elem* const _Ptr,  const size_type _Count) {
        
        if (_Count <= _Mypair._Myval2._Myres) {
             ;
            _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
            _Mypair._Myval2._Mysize = _Count;
            _Traits::move(_Old_ptr, _Ptr, _Count);
            _Traits::assign(_Old_ptr[_Count], _Elem());
            return *this;
        }

        return _Reallocate_for(
            _Count,
            [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
                _Traits::copy(_New_ptr, _Ptr, _Count);
                _Traits::assign(_New_ptr[_Count], _Elem());
            },
            _Ptr);
    }

    constexpr basic_string& assign( const _Elem* const _Ptr) {
        return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
    }

    constexpr basic_string& assign( const size_type _Count, const _Elem _Ch) {
        
        if (_Count <= _Mypair._Myval2._Myres) {
             ;
            _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
            _Mypair._Myval2._Mysize = _Count;
            _Traits::assign(_Old_ptr, _Count, _Ch);
            _Traits::assign(_Old_ptr[_Count], _Elem());
            return *this;
        }

        return _Reallocate_for(
            _Count,
            [](_Elem* const _New_ptr, const size_type _Count, const _Elem _Ch) {
                _Traits::assign(_New_ptr, _Count, _Ch);
                _Traits::assign(_New_ptr[_Count], _Elem());
            },
            _Ch);
    }

    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    constexpr basic_string& assign(const _Iter _First, const _Iter _Last) {
        _Adl_verify_range(_First, _Last);
        const auto _UFirst = _Get_unwrapped(_First);
        const auto _ULast  = _Get_unwrapped(_Last);
        if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
            return assign(_UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
        } else {
            basic_string _Right(_UFirst, _ULast, get_allocator());
            if (_Mypair._Myval2._Myres < _Right._Mypair._Myval2._Myres) {
                _Mypair._Myval2._Orphan_all();
                _Swap_data(_Right);
                return *this;
            } else {
                return assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
            }
        }
    }


















#line 3493 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

    constexpr basic_string& insert(const size_type _Off, const basic_string& _Right) {
        
        return insert(_Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }

    constexpr basic_string& insert(
        const size_type _Off, const basic_string& _Right, const size_type _Roff, size_type _Count = npos) {
        
        _Right._Mypair._Myval2._Check_offset(_Roff);
        _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
        return insert(_Off, _Right._Mypair._Myval2._Myptr() + _Roff, _Count);
    }


    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    constexpr basic_string& insert(const size_type _Off, const _StringViewIsh& _Right) {
        
        const basic_string_view<_Elem, _Traits> _As_view = _Right;
        return insert(_Off, _As_view.data(), _Convert_size<size_type>(_As_view.size()));
    }

    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    constexpr basic_string& insert(
        const size_type _Off, const _StringViewIsh& _Right, const size_type _Roff, const size_type _Count = npos) {
        
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        return insert(_Off, _As_view.substr(_Roff, _Count));
    }
#line 3523 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

    constexpr basic_string& insert(
        const size_type _Off,  const _Elem* const _Ptr,  const size_type _Count) {
        
        _Mypair._Myval2._Check_offset(_Off);
        const size_type _Old_size = _Mypair._Myval2._Mysize;

        
        

        const bool _Check_overlap = _Count <= _Mypair._Myval2._Myres - _Old_size && !::std:: is_constant_evaluated();


#line 3537 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

        if (_Check_overlap) {
             ;
            _Mypair._Myval2._Mysize = _Old_size + _Count;
            _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
            _Elem* const _Insert_at = _Old_ptr + _Off;
            
            
            size_type _Ptr_shifted_after;
            if (_Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size) {
                
                _Ptr_shifted_after = _Count; 
            } else if (_Insert_at <= _Ptr) { 
                _Ptr_shifted_after = 0;
            } else { 
                _Ptr_shifted_after = static_cast<size_type>(_Insert_at - _Ptr);
            }

            _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); 
            _Traits::copy(_Insert_at, _Ptr, _Ptr_shifted_after);
            _Traits::copy(
                _Insert_at + _Ptr_shifted_after, _Ptr + _Count + _Ptr_shifted_after, _Count - _Ptr_shifted_after);
            return *this;
        }

        return _Reallocate_grow_by(
            _Count,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
                const _Elem* const _Ptr, const size_type _Count) {
                _Traits::copy(_New_ptr, _Old_ptr, _Off);
                _Traits::copy(_New_ptr + _Off, _Ptr, _Count);
                _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
            },
            _Off, _Ptr, _Count);
    }

    constexpr basic_string& insert(const size_type _Off,  const _Elem* const _Ptr) {
        
        return insert(_Off, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
    }

    constexpr basic_string& insert(
        const size_type _Off,  const size_type _Count, const _Elem _Ch) {
        
        _Mypair._Myval2._Check_offset(_Off);
        const size_type _Old_size = _Mypair._Myval2._Mysize;
        if (_Count <= _Mypair._Myval2._Myres - _Old_size) {
             ;
            _Mypair._Myval2._Mysize = _Old_size + _Count;
            _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
            _Elem* const _Insert_at = _Old_ptr + _Off;
            _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); 
            _Traits::assign(_Insert_at, _Count, _Ch); 
            return *this;
        }

        return _Reallocate_grow_by(
            _Count,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
                const size_type _Count, const _Elem _Ch) {
                _Traits::copy(_New_ptr, _Old_ptr, _Off);
                _Traits::assign(_New_ptr + _Off, _Count, _Ch);
                _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
            },
            _Off, _Count, _Ch);
    }

    constexpr iterator insert(const const_iterator _Where, const _Elem _Ch) { 


#line 3608 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
        insert(_Off, 1, _Ch);
        return begin() + static_cast<difference_type>(_Off);
    }

    constexpr iterator insert(
        const const_iterator _Where,  const size_type _Count, const _Elem _Ch) {
        


#line 3619 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
        insert(_Off, _Count, _Ch);
        return begin() + static_cast<difference_type>(_Off);
    }

    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    constexpr iterator insert(const const_iterator _Where, const _Iter _First, const _Iter _Last) {
        


#line 3630 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
        _Adl_verify_range(_First, _Last);
        const auto _UFirst = _Get_unwrapped(_First);
        const auto _ULast  = _Get_unwrapped(_Last);
        if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
            insert(_Off, _UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
        } else {
            const basic_string _Right(_UFirst, _ULast, get_allocator());
            insert(_Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
        }

        return begin() + static_cast<difference_type>(_Off);
    }



















#line 3663 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

    constexpr basic_string& erase(const size_type _Off = 0) { 
        _Mypair._Myval2._Check_offset(_Off);
        _Eos(_Off);
        return *this;
    }

private:
    constexpr basic_string& _Erase_noexcept(const size_type _Off, size_type _Count) noexcept {
        _Count                    = _Mypair._Myval2._Clamp_suffix_size(_Off, _Count);
        const size_type _Old_size = _Mypair._Myval2._Mysize;
        _Elem* const _My_ptr      = _Mypair._Myval2._Myptr();
        _Elem* const _Erase_at    = _My_ptr + _Off;
        const size_type _New_size = _Old_size - _Count;
        _Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); 
         ;
        _Mypair._Myval2._Mysize = _New_size;
        return *this;
    }

public:
    constexpr basic_string& erase(const size_type _Off, const size_type _Count) {
        
        _Mypair._Myval2._Check_offset(_Off);
        return _Erase_noexcept(_Off, _Count);
    }

    constexpr iterator erase(const const_iterator _Where) noexcept   {


#line 3694 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
        _Erase_noexcept(_Off, 1);
        return begin() + static_cast<difference_type>(_Off);
    }

    constexpr iterator erase(const const_iterator _First, const const_iterator _Last) noexcept
      {
        _Adl_verify_range(_First, _Last);


#line 3705 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        const auto _Off = static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr());
        _Erase_noexcept(_Off, static_cast<size_type>(_Last._Ptr - _First._Ptr));
        return begin() + static_cast<difference_type>(_Off);
    }

    constexpr void clear() noexcept { 
        _Eos(0);
    }

    constexpr basic_string& replace(const size_type _Off, const size_type _Nx, const basic_string& _Right) {
        
        return replace(_Off, _Nx, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }

    constexpr basic_string& replace(const size_type _Off, size_type _Nx, const basic_string& _Right,
        const size_type _Roff, size_type _Count = npos) {
        
        _Right._Mypair._Myval2._Check_offset(_Roff);
        _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
        return replace(_Off, _Nx, _Right._Mypair._Myval2._Myptr() + _Roff, _Count);
    }


    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    constexpr basic_string& replace(const size_type _Off, const size_type _Nx, const _StringViewIsh& _Right) {
        
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        return replace(_Off, _Nx, _As_view.data(), _Convert_size<size_type>(_As_view.size()));
    }

    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    constexpr basic_string& replace(const size_type _Off, const size_type _Nx, const _StringViewIsh& _Right,
        const size_type _Roff, const size_type _Count = npos) {
        
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        return replace(_Off, _Nx, _As_view.substr(_Roff, _Count));
    }
#line 3743 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

    constexpr basic_string& replace(
        const size_type _Off, size_type _Nx,  const _Elem* const _Ptr, const size_type _Count) {
        
        _Mypair._Myval2._Check_offset(_Off);
        _Nx = _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx);
        if (_Nx == _Count) { 
            _Traits::move(_Mypair._Myval2._Myptr() + _Off, _Ptr, _Count);
            return *this;
        }

        const size_type _Old_size    = _Mypair._Myval2._Mysize;
        const size_type _Suffix_size = _Old_size - _Nx - _Off + 1;
        if (_Count < _Nx) { 
            _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
            _Elem* const _Insert_at = _Old_ptr + _Off;
            _Traits::move(_Insert_at, _Ptr, _Count);
            _Traits::move(_Insert_at + _Count, _Insert_at + _Nx, _Suffix_size);

            const auto _New_size = _Old_size - (_Nx - _Count);
             ;
            _Mypair._Myval2._Mysize = _New_size;
            return *this;
        }

        const size_type _Growth = static_cast<size_type>(_Count - _Nx);

        
        

        if (!::std:: is_constant_evaluated())
#line 3775 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        {
            if (_Growth <= _Mypair._Myval2._Myres - _Old_size) { 
                 ;
                _Mypair._Myval2._Mysize = _Old_size + _Growth;
                _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
                _Elem* const _Insert_at = _Old_ptr + _Off;
                _Elem* const _Suffix_at = _Insert_at + _Nx;

                size_type _Ptr_shifted_after; 
                if (_Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size) {
                    _Ptr_shifted_after = _Count;
                } else if (_Suffix_at <= _Ptr) {
                    _Ptr_shifted_after = 0;
                } else {
                    _Ptr_shifted_after = static_cast<size_type>(_Suffix_at - _Ptr);
                }

                _Traits::move(_Suffix_at + _Growth, _Suffix_at, _Suffix_size);
                
                
                
                _Traits::move(_Insert_at, _Ptr, _Ptr_shifted_after);
                
                
                _Traits::copy(
                    _Insert_at + _Ptr_shifted_after, _Ptr + _Growth + _Ptr_shifted_after, _Count - _Ptr_shifted_after);
                return *this;
            }
        }

        return _Reallocate_grow_by(
            _Growth,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
                const size_type _Nx, const _Elem* const _Ptr, const size_type _Count) {
                _Traits::copy(_New_ptr, _Old_ptr, _Off);
                _Traits::copy(_New_ptr + _Off, _Ptr, _Count);
                _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off + _Nx, _Old_size - _Nx - _Off + 1);
            },
            _Off, _Nx, _Ptr, _Count);
    }

    constexpr basic_string& replace(const size_type _Off, const size_type _Nx,  const _Elem* const _Ptr) {
        
        return replace(_Off, _Nx, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
    }

    constexpr basic_string& replace(const size_type _Off, size_type _Nx, const size_type _Count, const _Elem _Ch) {
        
        _Mypair._Myval2._Check_offset(_Off);
        _Nx = _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx);
        if (_Count == _Nx) {
            _Traits::assign(_Mypair._Myval2._Myptr() + _Off, _Count, _Ch);
            return *this;
        }

        const size_type _Old_size = _Mypair._Myval2._Mysize;
        if (_Count < _Nx || _Count - _Nx <= _Mypair._Myval2._Myres - _Old_size) {
            
            
            const auto _New_size = _Old_size + _Count - _Nx;
             ;
            _Mypair._Myval2._Mysize = _New_size;
            _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
            _Elem* const _Insert_at = _Old_ptr + _Off;
            _Traits::move(_Insert_at + _Count, _Insert_at + _Nx, _Old_size - _Nx - _Off + 1);
            _Traits::assign(_Insert_at, _Count, _Ch);
            return *this;
        }

        return _Reallocate_grow_by(
            _Count - _Nx,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
                const size_type _Nx, const size_type _Count, const _Elem _Ch) {
                _Traits::copy(_New_ptr, _Old_ptr, _Off);
                _Traits::assign(_New_ptr + _Off, _Count, _Ch);
                _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off + _Nx, _Old_size - _Nx - _Off + 1);
            },
            _Off, _Nx, _Count, _Ch);
    }

    constexpr basic_string& replace(
        const const_iterator _First, const const_iterator _Last, const basic_string& _Right) {
        
        _Adl_verify_range(_First, _Last);


#line 3862 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
            static_cast<size_type>(_Last._Ptr - _First._Ptr), _Right);
    }


    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    constexpr basic_string& replace(
        const const_iterator _First, const const_iterator _Last, const _StringViewIsh& _Right) {
        
        _Adl_verify_range(_First, _Last);


#line 3875 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
            static_cast<size_type>(_Last._Ptr - _First._Ptr), _Right);
    }
#line 3879 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

    constexpr basic_string& replace(const const_iterator _First, const const_iterator _Last,
         const _Elem* const _Ptr, const size_type _Count) {
        
        _Adl_verify_range(_First, _Last);


#line 3887 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
            static_cast<size_type>(_Last._Ptr - _First._Ptr), _Ptr, _Count);
    }

    constexpr basic_string& replace(
        const const_iterator _First, const const_iterator _Last,  const _Elem* const _Ptr) {
        
        _Adl_verify_range(_First, _Last);


#line 3898 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
            static_cast<size_type>(_Last._Ptr - _First._Ptr), _Ptr);
    }

    constexpr basic_string& replace(
        const const_iterator _First, const const_iterator _Last, const size_type _Count, const _Elem _Ch) {
        
        _Adl_verify_range(_First, _Last);


#line 3909 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
            static_cast<size_type>(_Last._Ptr - _First._Ptr), _Count, _Ch);
    }

    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    constexpr basic_string& replace(
        const const_iterator _First, const const_iterator _Last, const _Iter _First2, const _Iter _Last2) {
        
        _Adl_verify_range(_First, _Last);


#line 3921 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        const auto _Off    = static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr());
        const auto _Length = static_cast<size_type>(_Last._Ptr - _First._Ptr);
        _Adl_verify_range(_First2, _Last2);
        const auto _UFirst2 = _Get_unwrapped(_First2);
        const auto _ULast2  = _Get_unwrapped(_Last2);
        if constexpr (_Is_elem_cptr<decltype(_UFirst2)>::value) {
            return replace(_Off, _Length, _UFirst2, _Convert_size<size_type>(static_cast<size_t>(_ULast2 - _UFirst2)));
        } else {
            const basic_string _Right(_UFirst2, _ULast2, get_allocator());
            return replace(_Off, _Length, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
        }
    }



















#line 3953 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

    [[nodiscard]] constexpr iterator begin() noexcept {
        return iterator(_Refancy<pointer>(_Mypair._Myval2._Myptr()), ::std:: addressof(_Mypair._Myval2));
    }

    [[nodiscard]] constexpr const_iterator begin() const noexcept {
        return const_iterator(_Refancy<const_pointer>(_Mypair._Myval2._Myptr()), ::std:: addressof(_Mypair._Myval2));
    }

    [[nodiscard]] constexpr iterator end() noexcept {
        return iterator(
            _Refancy<pointer>(_Mypair._Myval2._Myptr()) + static_cast<difference_type>(_Mypair._Myval2._Mysize),
            ::std:: addressof(_Mypair._Myval2));
    }

    [[nodiscard]] constexpr const_iterator end() const noexcept {
        return const_iterator(
            _Refancy<const_pointer>(_Mypair._Myval2._Myptr()) + static_cast<difference_type>(_Mypair._Myval2._Mysize),
            ::std:: addressof(_Mypair._Myval2));
    }

    [[nodiscard]] constexpr _Elem* _Unchecked_begin() noexcept {
        return _Mypair._Myval2._Myptr();
    }

    [[nodiscard]] constexpr const _Elem* _Unchecked_begin() const noexcept {
        return _Mypair._Myval2._Myptr();
    }

    [[nodiscard]] constexpr _Elem* _Unchecked_end() noexcept {
        return _Mypair._Myval2._Myptr() + _Mypair._Myval2._Mysize;
    }

    [[nodiscard]] constexpr const _Elem* _Unchecked_end() const noexcept {
        return _Mypair._Myval2._Myptr() + _Mypair._Myval2._Mysize;
    }

    [[nodiscard]] constexpr reverse_iterator rbegin() noexcept {
        return reverse_iterator(end());
    }

    [[nodiscard]] constexpr const_reverse_iterator rbegin() const noexcept {
        return const_reverse_iterator(end());
    }

    [[nodiscard]] constexpr reverse_iterator rend() noexcept {
        return reverse_iterator(begin());
    }

    [[nodiscard]] constexpr const_reverse_iterator rend() const noexcept {
        return const_reverse_iterator(begin());
    }

    [[nodiscard]] constexpr const_iterator cbegin() const noexcept {
        return begin();
    }

    [[nodiscard]] constexpr const_iterator cend() const noexcept {
        return end();
    }

    [[nodiscard]] constexpr const_reverse_iterator crbegin() const noexcept {
        return rbegin();
    }

    [[nodiscard]] constexpr const_reverse_iterator crend() const noexcept {
        return rend();
    }

    constexpr void shrink_to_fit() { 
        auto& _My_data = _Mypair._Myval2;

        if (!_My_data._Large_string_engaged()) { 
            return;
        }

        if (_My_data._Mysize < _BUF_SIZE) {
            _Become_small();
            return;
        }

        const size_type _Target_capacity = (::std:: min)(_My_data._Mysize | _ALLOC_MASK, max_size());
        if (_Target_capacity < _My_data._Myres) { 
            auto& _Al              = _Getal();
            const pointer _New_ptr = _Al.allocate(_Target_capacity + 1); 
             ;

            _Start_element_lifetimes(_Unfancy(_New_ptr), _Target_capacity + 1);

            _My_data._Orphan_all();
            _Traits::copy(_Unfancy(_New_ptr), _Unfancy(_My_data._Bx._Ptr), _My_data._Mysize + 1);
            _Al.deallocate(_My_data._Bx._Ptr, _My_data._Myres + 1);
            _My_data._Bx._Ptr = _New_ptr;
            _My_data._Myres   = _Target_capacity;
             ;
        }
    }

    [[nodiscard]] constexpr reference at(const size_type _Off) {
        _Mypair._Myval2._Check_offset_exclusive(_Off);
        return _Mypair._Myval2._Myptr()[_Off];
    }

    [[nodiscard]] constexpr const_reference at(const size_type _Off) const {
        _Mypair._Myval2._Check_offset_exclusive(_Off);
        return _Mypair._Myval2._Myptr()[_Off];
    }

    [[nodiscard]] constexpr reference operator[](const size_type _Off) noexcept   {


#line 4065 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        return _Mypair._Myval2._Myptr()[_Off];
    }

    [[nodiscard]] constexpr const_reference operator[](const size_type _Off) const noexcept
      {


#line 4073 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        return _Mypair._Myval2._Myptr()[_Off];
    }


      constexpr operator basic_string_view<_Elem, _Traits>() const noexcept {
        
        return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize};
    }
#line 4082 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

    constexpr void push_back(const _Elem _Ch) { 
        const size_type _Old_size = _Mypair._Myval2._Mysize;
        if (_Old_size < _Mypair._Myval2._Myres) {
             ;
            _Mypair._Myval2._Mysize = _Old_size + 1;
            _Elem* const _Ptr       = _Mypair._Myval2._Myptr();
            _Traits::assign(_Ptr[_Old_size], _Ch);
            _Traits::assign(_Ptr[_Old_size + 1], _Elem());
            return;
        }

        _Reallocate_grow_by(
            1,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem _Ch) {
                _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
                _Traits::assign(_New_ptr[_Old_size], _Ch);
                _Traits::assign(_New_ptr[_Old_size + 1], _Elem());
            },
            _Ch);
    }

    constexpr void pop_back() noexcept   {
        const size_type _Old_size = _Mypair._Myval2._Mysize;


#line 4109 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        _Eos(_Old_size - 1);
    }

    [[nodiscard]] constexpr reference front() noexcept   {


#line 4116 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

        return _Mypair._Myval2._Myptr()[0];
    }

    [[nodiscard]] constexpr const_reference front() const noexcept   {


#line 4124 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

        return _Mypair._Myval2._Myptr()[0];
    }

    [[nodiscard]] constexpr reference back() noexcept   {


#line 4132 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

        return _Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize - 1];
    }

    [[nodiscard]] constexpr const_reference back() const noexcept   {


#line 4140 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

        return _Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize - 1];
    }

    [[nodiscard]] constexpr  const _Elem* c_str() const noexcept {
        return _Mypair._Myval2._Myptr();
    }

    [[nodiscard]] constexpr  const _Elem* data() const noexcept {
        return _Mypair._Myval2._Myptr();
    }


    [[nodiscard]] constexpr  _Elem* data() noexcept {
        return _Mypair._Myval2._Myptr();
    }
#line 4157 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

    [[nodiscard]] constexpr size_type length() const noexcept {
        return _Mypair._Myval2._Mysize;
    }

    [[nodiscard]] constexpr size_type size() const noexcept {
        return _Mypair._Myval2._Mysize;
    }

    [[nodiscard]] constexpr size_type max_size() const noexcept {
        const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());
        const size_type _Storage_max = 
            (::std:: max)(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
        return (::std:: min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),
            _Storage_max - 1 
        );
    }

    constexpr void resize( const size_type _New_size, const _Elem _Ch = _Elem()) {
        
        const size_type _Old_size = size();
        if (_New_size <= _Old_size) {
            _Eos(_New_size);
        } else {
            append(_New_size - _Old_size, _Ch);
        }
    }























#line 4208 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

    [[nodiscard]] constexpr size_type capacity() const noexcept {
        return _Mypair._Myval2._Myres;
    }


    constexpr void reserve( const size_type _Newcap) {
        
        if (_Mypair._Myval2._Myres >= _Newcap) { 
            return; 
        }

        const size_type _Old_size = _Mypair._Myval2._Mysize;
        _Reallocate_grow_by(
            _Newcap - _Old_size, [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size) {
                _Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);
            });

        _Mypair._Myval2._Mysize = _Old_size;
    }

    [[deprecated("warning STL4024: " "std::string::reserve() without an argument is deprecated in C++20. " "To shrink the string's capacity, use std::string::shrink_to_fit() instead. Otherwise, provide an " "argument to std::string::reserve(). " "You can define _SILENCE_CXX20_STRING_RESERVE_WITHOUT_ARGUMENT_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] void reserve() {
        if (_Mypair._Myval2._Mysize == 0 && _Mypair._Myval2._Large_string_engaged()) {
            _Become_small();
        }
    }





























#line 4264 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

    [[nodiscard("This member function returns a bool indicating whether the container is empty and has no other effects. " "It is not useful to call this member function and discard the return value. " "Use the 'clear()' member function if you want to erase all elements.")]] constexpr bool empty() const noexcept {
        return _Mypair._Myval2._Mysize == 0;
    }

    constexpr size_type copy(
         _Elem* const _Ptr, size_type _Count, const size_type _Off = 0) const {
        
        _Mypair._Myval2._Check_offset(_Off);
        _Count = _Mypair._Myval2._Clamp_suffix_size(_Off, _Count);
        _Traits::copy(_Ptr, _Mypair._Myval2._Myptr() + _Off, _Count);
        return _Count;
    }

    constexpr  size_type
        _Copy_s( _Elem* const _Dest, const size_type _Dest_size, size_type _Count,
            const size_type _Off = 0) const {
        
        _Mypair._Myval2._Check_offset(_Off);
        _Count = _Mypair._Myval2._Clamp_suffix_size(_Off, _Count);
        _Traits::_Copy_s(_Dest, _Dest_size, _Mypair._Myval2._Myptr() + _Off, _Count);
        return _Count;
    }

    static constexpr void _Swap_bx_large_with_small(_Scary_val& _Starts_large, _Scary_val& _Starts_small) noexcept {
        
        const pointer _Ptr = _Starts_large._Bx._Ptr;
        _Destroy_in_place(_Starts_large._Bx._Ptr);

        _Starts_large._Activate_SSO_buffer();
        _Traits::copy(_Starts_large._Bx._Buf, _Starts_small._Bx._Buf, _BUF_SIZE);

        _Construct_in_place(_Starts_small._Bx._Ptr, _Ptr);
    }

    constexpr void _Swap_data(basic_string& _Right) {
        auto& _My_data    = _Mypair._Myval2;
        auto& _Right_data = _Right._Mypair._Myval2;

        const bool _My_large    = _My_data._Large_string_engaged();
        const bool _Right_large = _Right_data._Large_string_engaged();


        if constexpr (_Can_memcpy_val) {

            if (!::std:: is_constant_evaluated())
#line 4311 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
            {
                const auto _My_data_mem =
                    reinterpret_cast<unsigned char*>(::std:: addressof(_My_data)) + _Memcpy_val_offset;
                const auto _Right_data_mem =
                    reinterpret_cast<unsigned char*>(::std:: addressof(_Right_data)) + _Memcpy_val_offset;
                unsigned char _Temp_mem[_Memcpy_val_size];
                :: memcpy(_Temp_mem, _My_data_mem, _Memcpy_val_size);
                :: memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);
                :: memcpy(_Right_data_mem, _Temp_mem, _Memcpy_val_size);

                return;
            }
        }
#line 4325 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

        if (_My_large && _Right_large) { 
            _Swap_adl(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);
        } else if (_My_large) { 
            _Swap_bx_large_with_small(_My_data, _Right_data);
        } else if (_Right_large) { 
            _Swap_bx_large_with_small(_Right_data, _My_data);
        } else {
            _Elem _Temp_buf[_BUF_SIZE];
            _Traits::copy(_Temp_buf, _My_data._Bx._Buf, _My_data._Mysize + 1);
            _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);
            _Traits::copy(_Right_data._Bx._Buf, _Temp_buf, _My_data._Mysize + 1);
        }

        ::std:: swap(_My_data._Mysize, _Right_data._Mysize);
        ::std:: swap(_My_data._Myres, _Right_data._Myres);
    }

    constexpr void swap(basic_string& _Right) noexcept   {
        if (this != ::std:: addressof(_Right)) {
            _Pocs(_Getal(), _Right._Getal());














#line 4361 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

            _Swap_data(_Right);
        }
    }


    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    [[nodiscard]] constexpr size_type find(const _StringViewIsh& _Right, const size_type _Off = 0) const
        noexcept(_Is_nothrow_convertible_v<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>) {
        
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        return static_cast<size_type>(_Traits_find<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _As_view.data(), _As_view.size()));
    }
#line 4376 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

    [[nodiscard]] constexpr size_type find(const basic_string& _Right, const size_type _Off = 0) const noexcept {
        
        return static_cast<size_type>(_Traits_find<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off,
            _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
    }

    [[nodiscard]] constexpr size_type find( const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept   {
        
        return static_cast<size_type>(
            _Traits_find<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Count));
    }

    [[nodiscard]] constexpr size_type find( const _Elem* const _Ptr, const size_type _Off = 0) const noexcept
      {
        
        return static_cast<size_type>(_Traits_find<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
    }

    [[nodiscard]] constexpr size_type find(const _Elem _Ch, const size_type _Off = 0) const noexcept {
        
        return static_cast<size_type>(
            _Traits_find_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    }


    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    [[nodiscard]] constexpr size_type rfind(const _StringViewIsh& _Right, const size_type _Off = npos) const
        noexcept(_Is_nothrow_convertible_v<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>) {
        
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        return static_cast<size_type>(_Traits_rfind<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _As_view.data(), _As_view.size()));
    }
#line 4413 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

    [[nodiscard]] constexpr size_type rfind(const basic_string& _Right, const size_type _Off = npos) const noexcept {
        
        return static_cast<size_type>(_Traits_rfind<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off,
            _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
    }

    [[nodiscard]] constexpr size_type rfind( const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept   {
        
        return static_cast<size_type>(
            _Traits_rfind<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Count));
    }

    [[nodiscard]] constexpr size_type rfind( const _Elem* const _Ptr, const size_type _Off = npos) const noexcept
      {
        
        return static_cast<size_type>(_Traits_rfind<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
    }

    [[nodiscard]] constexpr size_type rfind(const _Elem _Ch, const size_type _Off = npos) const noexcept {
        
        return static_cast<size_type>(
            _Traits_rfind_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    }


    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    [[nodiscard]] constexpr size_type find_first_of(const _StringViewIsh& _Right, const size_type _Off = 0) const
        noexcept(_Is_nothrow_convertible_v<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>) {
        
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        return static_cast<size_type>(_Traits_find_first_of<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _As_view.data(), _As_view.size()));
    }
#line 4450 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

    [[nodiscard]] constexpr size_type find_first_of(
        const basic_string& _Right, const size_type _Off = 0) const noexcept {
        
        return static_cast<size_type>(_Traits_find_first_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
            _Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
    }

    [[nodiscard]] constexpr size_type find_first_of( const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept   {
        
        return static_cast<size_type>(
            _Traits_find_first_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Count));
    }

    [[nodiscard]] constexpr size_type find_first_of(
         const _Elem* const _Ptr, const size_type _Off = 0) const noexcept
      {
        
        return static_cast<size_type>(_Traits_find_first_of<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
    }

    [[nodiscard]] constexpr size_type find_first_of(const _Elem _Ch, const size_type _Off = 0) const noexcept {
        
        return static_cast<size_type>(
            _Traits_find_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    }


    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    [[nodiscard]] constexpr size_type find_last_of(const _StringViewIsh& _Right, const size_type _Off = npos) const
        noexcept(_Is_nothrow_convertible_v<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>) {
        
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        return static_cast<size_type>(_Traits_find_last_of<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _As_view.data(), _As_view.size()));
    }
#line 4489 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

    [[nodiscard]] constexpr size_type find_last_of(const basic_string& _Right, size_type _Off = npos) const noexcept {
        
        return static_cast<size_type>(_Traits_find_last_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
            _Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
    }

    [[nodiscard]] constexpr size_type find_last_of( const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept   {
        
        return static_cast<size_type>(
            _Traits_find_last_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Count));
    }

    [[nodiscard]] constexpr size_type find_last_of(
         const _Elem* const _Ptr, const size_type _Off = npos) const noexcept   {
        
        return static_cast<size_type>(_Traits_find_last_of<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
    }

    [[nodiscard]] constexpr size_type find_last_of(const _Elem _Ch, const size_type _Off = npos) const noexcept {
        
        return static_cast<size_type>(
            _Traits_rfind_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    }


    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    [[nodiscard]] constexpr size_type find_first_not_of(const _StringViewIsh& _Right, const size_type _Off = 0) const
        noexcept(_Is_nothrow_convertible_v<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>) {
        
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        return static_cast<size_type>(_Traits_find_first_not_of<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _As_view.data(), _As_view.size()));
    }
#line 4526 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

    [[nodiscard]] constexpr size_type find_first_not_of(
        const basic_string& _Right, const size_type _Off = 0) const noexcept {
        
        return static_cast<size_type>(_Traits_find_first_not_of<_Traits>(_Mypair._Myval2._Myptr(),
            _Mypair._Myval2._Mysize, _Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
    }

    [[nodiscard]] constexpr size_type find_first_not_of( const _Elem* const _Ptr,
        const size_type _Off, const size_type _Count) const noexcept   {
        
        return static_cast<size_type>(
            _Traits_find_first_not_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Count));
    }

    [[nodiscard]] constexpr size_type find_first_not_of(
         const _Elem* const _Ptr, size_type _Off = 0) const noexcept
      {
        
        return static_cast<size_type>(_Traits_find_first_not_of<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
    }

    [[nodiscard]] constexpr size_type find_first_not_of(const _Elem _Ch, const size_type _Off = 0) const noexcept {
        
        return static_cast<size_type>(
            _Traits_find_not_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    }


    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    [[nodiscard]] constexpr size_type find_last_not_of(const _StringViewIsh& _Right, const size_type _Off = npos) const
        noexcept(_Is_nothrow_convertible_v<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>) {
        
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        return static_cast<size_type>(_Traits_find_last_not_of<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _As_view.data(), _As_view.size()));
    }
#line 4565 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

    [[nodiscard]] constexpr size_type find_last_not_of(
        const basic_string& _Right, const size_type _Off = npos) const noexcept {
        
        return static_cast<size_type>(_Traits_find_last_not_of<_Traits>(_Mypair._Myval2._Myptr(),
            _Mypair._Myval2._Mysize, _Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
    }

    [[nodiscard]] constexpr size_type find_last_not_of( const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept   {
        
        return static_cast<size_type>(
            _Traits_find_last_not_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Count));
    }

    [[nodiscard]] constexpr size_type find_last_not_of(
         const _Elem* const _Ptr, const size_type _Off = npos) const noexcept   {
        
        return static_cast<size_type>(_Traits_find_last_not_of<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
    }

    [[nodiscard]] constexpr size_type find_last_not_of(const _Elem _Ch, const size_type _Off = npos) const noexcept {
        
        return static_cast<size_type>(
            _Traits_rfind_not_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    }


    [[nodiscard]] bool _Starts_with(const basic_string_view<_Elem, _Traits> _Right) const noexcept {
        
        return basic_string_view<_Elem, _Traits>(*this)._Starts_with(_Right);
    }
#line 4599 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

    [[nodiscard]] constexpr basic_string substr(const size_type _Off = 0, const size_type _Count = npos)


#line 4604 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
        const
#line 4606 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
    {
        
        return basic_string{*this, _Off, _Count};
    }






#line 4617 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

    constexpr bool _Equal(const basic_string& _Right) const noexcept {
        
        return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
            _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }

    constexpr bool _Equal( const _Elem* const _Ptr) const noexcept {
        
        return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));
    }


    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    [[nodiscard]] constexpr int compare(const _StringViewIsh& _Right) const
        noexcept(_Is_nothrow_convertible_v<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>) {
        
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        return _Traits_compare<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _As_view.data(), _As_view.size());
    }

    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    [[nodiscard]] constexpr int compare(const size_type _Off, const size_type _Nx, const _StringViewIsh& _Right) const {
        
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        _Mypair._Myval2._Check_offset(_Off);
        return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr() + _Off, _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx),
            _As_view.data(), _As_view.size());
    }

    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    [[nodiscard]] constexpr int compare(const size_type _Off, const size_type _Nx, const _StringViewIsh& _Right,
        const size_type _Roff, const size_type _Count = npos) const {
        
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        _Mypair._Myval2._Check_offset(_Off);
        const auto _With_substr = _As_view.substr(_Roff, _Count);
        return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr() + _Off, _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx),
            _With_substr.data(), _With_substr.size());
    }
#line 4659 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

    [[nodiscard]] constexpr int compare(const basic_string& _Right) const noexcept {
        
        return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
            _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }

    [[nodiscard]] constexpr int compare(size_type _Off, size_type _Nx, const basic_string& _Right) const {
        
        _Mypair._Myval2._Check_offset(_Off);
        return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr() + _Off, _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx),
            _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }

    [[nodiscard]] constexpr int compare(const size_type _Off, const size_type _Nx, const basic_string& _Right,
        const size_type _Roff, const size_type _Count = npos) const {
        
        _Mypair._Myval2._Check_offset(_Off);
        _Right._Mypair._Myval2._Check_offset(_Roff);
        return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr() + _Off, _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx),
            _Right._Mypair._Myval2._Myptr() + _Roff, _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count));
    }

    [[nodiscard]] constexpr int compare( const _Elem* const _Ptr) const noexcept   {
        
        return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));
    }

    [[nodiscard]] constexpr int compare(
        const size_type _Off, const size_type _Nx,  const _Elem* const _Ptr) const {
        
        _Mypair._Myval2._Check_offset(_Off);
        return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr() + _Off, _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx),
            _Ptr, _Traits::length(_Ptr));
    }

    [[nodiscard]] constexpr int compare(const size_type _Off, const size_type _Nx,
         const _Elem* const _Ptr, const size_type _Count) const {
        
        _Mypair._Myval2._Check_offset(_Off);
        return _Traits_compare<_Traits>(
            _Mypair._Myval2._Myptr() + _Off, _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx), _Ptr, _Count);
    }


    [[nodiscard]] constexpr bool starts_with(const basic_string_view<_Elem, _Traits> _Right) const noexcept {
        return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize}.starts_with(_Right);
    }

    [[nodiscard]] constexpr bool starts_with(const _Elem _Right) const noexcept {
        return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize}.starts_with(_Right);
    }

    [[nodiscard]] constexpr bool starts_with(const _Elem* const _Right) const noexcept   {
        return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize}.starts_with(_Right);
    }

    [[nodiscard]] constexpr bool ends_with(const basic_string_view<_Elem, _Traits> _Right) const noexcept {
        return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize}.ends_with(_Right);
    }

    [[nodiscard]] constexpr bool ends_with(const _Elem _Right) const noexcept {
        return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize}.ends_with(_Right);
    }

    [[nodiscard]] constexpr bool ends_with(const _Elem* const _Right) const noexcept   {
        return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize}.ends_with(_Right);
    }
#line 4728 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"













#line 4742 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

    [[nodiscard]] constexpr allocator_type get_allocator() const noexcept {
        return static_cast<allocator_type>(_Getal());
    }

private:
    [[nodiscard]] static constexpr size_type _Calculate_growth(
        const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {
        const size_type _Masked = _Requested | _ALLOC_MASK;
        if (_Masked > _Max) { 
            return _Max;
        }

        if (_Old > _Max - _Old / 2) { 
            return _Max;
        }

        return (::std:: max)(_Masked, _Old + _Old / 2);
    }

    [[nodiscard]] constexpr size_type _Calculate_growth(const size_type _Requested) const noexcept {
        return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());
    }

    template <class _Fty, class... _ArgTys>
    constexpr basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {
        
        
        if (_New_size > max_size()) {
            _Xlen_string(); 
        }

        const size_type _Old_capacity = _Mypair._Myval2._Myres;
        const size_type _New_capacity = _Calculate_growth(_New_size);
        auto& _Al                     = _Getal();
        const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); 

        _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
        _Mypair._Myval2._Orphan_all();
         ;
        _Mypair._Myval2._Mysize = _New_size;
        _Mypair._Myval2._Myres  = _New_capacity;
        _Fn(_Unfancy(_New_ptr), _New_size, _Args...);
        if (_BUF_SIZE <= _Old_capacity) {
            _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);
            _Mypair._Myval2._Bx._Ptr = _New_ptr;
        } else {
            _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);
        }

         ;
        return *this;
    }

    template <class _Fty, class... _ArgTys>
    constexpr basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {
        
        
        auto& _My_data            = _Mypair._Myval2;
        const size_type _Old_size = _My_data._Mysize;
        if (max_size() - _Old_size < _Size_increase) {
            _Xlen_string(); 
        }

        const size_type _New_size     = _Old_size + _Size_increase;
        const size_type _Old_capacity = _My_data._Myres;
        const size_type _New_capacity = _Calculate_growth(_New_size);
        auto& _Al                     = _Getal();
        const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); 

        _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
        _My_data._Orphan_all();
         ;
        _My_data._Mysize      = _New_size;
        _My_data._Myres       = _New_capacity;
        _Elem* const _Raw_new = _Unfancy(_New_ptr);
        if (_BUF_SIZE <= _Old_capacity) {
            const pointer _Old_ptr = _My_data._Bx._Ptr;
            _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
            _Al.deallocate(_Old_ptr, _Old_capacity + 1);
            _My_data._Bx._Ptr = _New_ptr;
        } else {
            _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);
            _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);
        }

         ;
        return *this;
    }

    constexpr void _Become_small() {
        
        auto& _My_data = _Mypair._Myval2;
         ;
         ;

        _My_data._Orphan_all();
         ;
        const pointer _Ptr = _My_data._Bx._Ptr;
        auto& _Al          = _Getal();
        _Destroy_in_place(_My_data._Bx._Ptr);
        _My_data._Activate_SSO_buffer();
        _Traits::copy(_My_data._Bx._Buf, _Unfancy(_Ptr), _My_data._Mysize + 1);
        _Al.deallocate(_Ptr, _My_data._Myres + 1);
        _My_data._Myres = _BUF_SIZE - 1;
    }

    constexpr void _Eos(const size_type _New_size) { 
         ;
        _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _New_size], _Elem());
    }

    constexpr void _Tidy_init() noexcept {
        
        auto& _My_data   = _Mypair._Myval2;
        _My_data._Mysize = 0;
        _My_data._Myres  = _BUF_SIZE - 1;
        _My_data._Activate_SSO_buffer();

        
        _Traits::assign(_My_data._Bx._Buf[0], _Elem());
    }

    constexpr void _Tidy_deallocate() noexcept { 
        auto& _My_data = _Mypair._Myval2;
        _My_data._Orphan_all();
        if (_My_data._Large_string_engaged()) {
             ;
            const pointer _Ptr = _My_data._Bx._Ptr;
            auto& _Al          = _Getal();
            _Destroy_in_place(_My_data._Bx._Ptr);
            _My_data._Activate_SSO_buffer();
            _Al.deallocate(_Ptr, _My_data._Myres + 1);
        }

        _My_data._Mysize = 0;
        _My_data._Myres  = _BUF_SIZE - 1;
        
        _Traits::assign(_My_data._Bx._Buf[0], _Elem());
    }

public:
    constexpr void _Orphan_all() noexcept { 
        _Mypair._Myval2._Orphan_all();
    }

private:
    constexpr void _Swap_proxy_and_iterators(basic_string& _Right) {
        _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
    }

    constexpr _Alty& _Getal() noexcept {
        return _Mypair._Get_first();
    }

    constexpr const _Alty& _Getal() const noexcept {
        return _Mypair._Get_first();
    }

    _Compressed_pair<_Alty, _Scary_val> _Mypair;
};


template <class _Iter, class _Alloc = allocator<_Iter_value_t<_Iter>>,
    enable_if_t<conjunction_v<_Is_iterator<_Iter>, _Is_allocator<_Alloc>>, int> = 0>
basic_string(_Iter, _Iter, _Alloc = _Alloc())
    -> basic_string<_Iter_value_t<_Iter>, char_traits<_Iter_value_t<_Iter>>, _Alloc>;

template <class _Elem, class _Traits, class _Alloc = allocator<_Elem>,
    enable_if_t<_Is_allocator<_Alloc>::value, int> = 0>
explicit basic_string(basic_string_view<_Elem, _Traits>, const _Alloc& = _Alloc())
    -> basic_string<_Elem, _Traits, _Alloc>;

template <class _Elem, class _Traits, class _Alloc = allocator<_Elem>,
    enable_if_t<_Is_allocator<_Alloc>::value, int> = 0>
basic_string(basic_string_view<_Elem, _Traits>, _Guide_size_type_t<_Alloc>, _Guide_size_type_t<_Alloc>,
    const _Alloc& = _Alloc()) -> basic_string<_Elem, _Traits, _Alloc>;






#line 4926 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
#line 4927 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

 template <class _Elem, class _Traits, class _Alloc>
constexpr void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
    basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept   {
    _Left.swap(_Right);
}

 template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] constexpr basic_string<_Elem, _Traits, _Alloc> operator+(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {
    const auto _Left_size  = _Left.size();
    const auto _Right_size = _Right.size();
    if (_Left.max_size() - _Left_size < _Right_size) {
        _Xlen_string();
    }

    return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, _Right.c_str(), _Right_size};
}

 template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] constexpr basic_string<_Elem, _Traits, _Alloc> operator+(
     const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {
    using _Size_type       = typename basic_string<_Elem, _Traits, _Alloc>::size_type;
    const auto _Left_size  = _Convert_size<_Size_type>(_Traits::length(_Left));
    const auto _Right_size = _Right.size();
    if (_Right.max_size() - _Right_size < _Left_size) {
        _Xlen_string();
    }

    return {_String_constructor_concat_tag{}, _Right, _Left, _Left_size, _Right.c_str(), _Right_size};
}

 template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] constexpr basic_string<_Elem, _Traits, _Alloc> operator+(
    const _Elem _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {
    const auto _Right_size = _Right.size();
    if (_Right_size == _Right.max_size()) {
        _Xlen_string();
    }

    return {_String_constructor_concat_tag{}, _Right, ::std:: addressof(_Left), 1, _Right.c_str(), _Right_size};
}

 template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] constexpr basic_string<_Elem, _Traits, _Alloc> operator+(
    const basic_string<_Elem, _Traits, _Alloc>& _Left,  const _Elem* const _Right) {
    using _Size_type       = typename basic_string<_Elem, _Traits, _Alloc>::size_type;
    const auto _Left_size  = _Left.size();
    const auto _Right_size = _Convert_size<_Size_type>(_Traits::length(_Right));
    if (_Left.max_size() - _Left_size < _Right_size) {
        _Xlen_string();
    }

    return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, _Right, _Right_size};
}

 template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] constexpr basic_string<_Elem, _Traits, _Alloc> operator+(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, const _Elem _Right) {
    const auto _Left_size = _Left.size();
    if (_Left_size == _Left.max_size()) {
        _Xlen_string();
    }

    return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, ::std:: addressof(_Right), 1};
}

 template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] constexpr basic_string<_Elem, _Traits, _Alloc> operator+(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, basic_string<_Elem, _Traits, _Alloc>&& _Right) {
    return ::std:: move(_Right.insert(0, _Left));
}

 template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] constexpr basic_string<_Elem, _Traits, _Alloc> operator+(
    basic_string<_Elem, _Traits, _Alloc>&& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {
    return ::std:: move(_Left.append(_Right));
}

 template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] constexpr basic_string<_Elem, _Traits, _Alloc> operator+(
    basic_string<_Elem, _Traits, _Alloc>&& _Left, basic_string<_Elem, _Traits, _Alloc>&& _Right) {






#line 5016 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
    return {_String_constructor_concat_tag{}, _Left, _Right};
}

 template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] constexpr basic_string<_Elem, _Traits, _Alloc> operator+(
     const _Elem* const _Left, basic_string<_Elem, _Traits, _Alloc>&& _Right) {
    return ::std:: move(_Right.insert(0, _Left));
}

 template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] constexpr basic_string<_Elem, _Traits, _Alloc> operator+(
    const _Elem _Left, basic_string<_Elem, _Traits, _Alloc>&& _Right) {
    return ::std:: move(_Right.insert(0, 1, _Left));
}

 template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] constexpr basic_string<_Elem, _Traits, _Alloc> operator+(
    basic_string<_Elem, _Traits, _Alloc>&& _Left,  const _Elem* const _Right) {
    return ::std:: move(_Left.append(_Right));
}

 template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] constexpr basic_string<_Elem, _Traits, _Alloc> operator+(
    basic_string<_Elem, _Traits, _Alloc>&& _Left, const _Elem _Right) {
    _Left.push_back(_Right);
    return ::std:: move(_Left);
}

 template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] constexpr bool operator==(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept {
    return _Left._Equal(_Right);
}

 template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] constexpr bool operator==(
    const basic_string<_Elem, _Traits, _Alloc>& _Left,  const _Elem* const _Right) {
    return _Left._Equal(_Right);
}


 template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] constexpr _Get_comparison_category_t<_Traits> operator<=>(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept {
    return static_cast<_Get_comparison_category_t<_Traits>>(_Left.compare(_Right) <=> 0);
}

 template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] constexpr _Get_comparison_category_t<_Traits> operator<=>(
    const basic_string<_Elem, _Traits, _Alloc>& _Left,  const _Elem* const _Right) {
    return static_cast<_Get_comparison_category_t<_Traits>>(_Left.compare(_Right) <=> 0);
}





















































































#line 5154 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

 using string  = basic_string<char, char_traits<char>, allocator<char>>;
 using wstring = basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;

 using u8string = basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>>;
#line 5160 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
 using u16string = basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>;
 using u32string = basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>;

template <class _Elem, class _Alloc>
struct hash<basic_string<_Elem, char_traits<_Elem>, _Alloc>>
    : _Conditionally_enabled_hash<basic_string<_Elem, char_traits<_Elem>, _Alloc>, _Is_EcharT<_Elem>> {
    [[nodiscard]] static size_t _Do_hash(const basic_string<_Elem, char_traits<_Elem>, _Alloc>& _Keyval) noexcept {
        return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());
    }
};

 template <class _Elem, class _Traits, class _Alloc>
basic_istream<_Elem, _Traits>& operator>>(
    basic_istream<_Elem, _Traits>& _Istr, basic_string<_Elem, _Traits, _Alloc>& _Str) {
    using _Myis   = basic_istream<_Elem, _Traits>;
    using _Ctype  = typename _Myis::_Ctype;
    using _Mystr  = basic_string<_Elem, _Traits, _Alloc>;
    using _Mysizt = typename _Mystr::size_type;

    typename _Myis::iostate _State = _Myis::goodbit;
    bool _Changed                  = false;
    const typename _Myis::sentry _Ok(_Istr);

    if (_Ok) { 
        const _Ctype& _Ctype_fac = ::std:: use_facet<_Ctype>(_Istr.getloc());
        _Str.erase();

        try {
        _Mysizt _Size;
        if (0 < _Istr.width() && static_cast<_Mysizt>(_Istr.width()) < _Str.max_size()) {
            _Size = static_cast<_Mysizt>(_Istr.width());
        } else {
            _Size = _Str.max_size();
        }

        typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

        for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc()) {
            if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { 
                _State |= _Myis::eofbit;
                break;
            } else if (_Ctype_fac.is(_Ctype::space, _Traits::to_char_type(_Meta))) {
                break; 
            } else { 
                _Str.push_back(_Traits::to_char_type(_Meta));
                _Changed = true;
            }
        }
        } catch (...) { (_Istr) .setstate(_Myis::badbit, true); }
    }

    _Istr.width(0);
    if (!_Changed) {
        _State |= _Myis::failbit;
    }

    _Istr.setstate(_State);
    return _Istr;
}

 template <class _Elem, class _Traits, class _Alloc>
basic_ostream<_Elem, _Traits>& operator<<(
    basic_ostream<_Elem, _Traits>& _Ostr, const basic_string<_Elem, _Traits, _Alloc>& _Str) {
    return _Insert_string(_Ostr, _Str.data(), _Str.size());
}

inline namespace literals {
    inline namespace string_literals {
         [[nodiscard]] constexpr string operator""s(const char* _Str, size_t _Len) {
            return string{_Str, _Len};
        }

         [[nodiscard]] constexpr wstring operator""s(const wchar_t* _Str, size_t _Len) {
            return wstring{_Str, _Len};
        }


         [[nodiscard]] constexpr basic_string<char8_t> operator""s(const char8_t* _Str, size_t _Len) {
            return basic_string<char8_t>{_Str, _Len};
        }
#line 5241 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"

         [[nodiscard]] constexpr u16string operator""s(const char16_t* _Str, size_t _Len) {
            return u16string{_Str, _Len};
        }

         [[nodiscard]] constexpr u32string operator""s(const char32_t* _Str, size_t _Len) {
            return u32string{_Str, _Len};
        }
    } 
} 


 template <class _Elem, class _Traits, class _Alloc, class _Uty>
constexpr typename basic_string<_Elem, _Traits, _Alloc>::size_type erase(
    basic_string<_Elem, _Traits, _Alloc>& _Cont, const _Uty& _Val) {
    return _Erase_remove(_Cont, _Val);
}

 template <class _Elem, class _Traits, class _Alloc, class _Pr>
constexpr typename basic_string<_Elem, _Traits, _Alloc>::size_type erase_if(
    basic_string<_Elem, _Traits, _Alloc>& _Cont, _Pr _Pred) {
    return _Erase_remove_if(_Cont, _Pass_fn(_Pred));
}
#line 5265 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"


namespace pmr {
     template <class _Elem, class _Traits = char_traits<_Elem>>
    using basic_string = ::std:: basic_string<_Elem, _Traits, polymorphic_allocator<_Elem>>;

     using string = basic_string<char>;

     using u8string = basic_string<char8_t>;
#line 5275 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
     using u16string = basic_string<char16_t>;
     using u32string = basic_string<char32_t>;
     using wstring   = basic_string<wchar_t>;
} 
#line 5280 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
}



#pragma warning(pop)
#pragma pack(pop)
#line 5287 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
#line 5288 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstring"
#pragma external_header(pop)
#line 13 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\stdexcept"

#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )



namespace std {
 class logic_error : public exception { 
public:
    using _Mybase = exception;

    explicit logic_error(const string& _Message) : _Mybase(_Message.c_str()) {}

    explicit logic_error(const char* _Message) : _Mybase(_Message) {}






#line 35 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\stdexcept"
};

 class domain_error : public logic_error { 
public:
    using _Mybase = logic_error;

    explicit domain_error(const string& _Message) : _Mybase(_Message.c_str()) {}

    explicit domain_error(const char* _Message) : _Mybase(_Message) {}






#line 51 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\stdexcept"
};

 class invalid_argument : public logic_error { 
public:
    using _Mybase = logic_error;

    explicit invalid_argument(const string& _Message) : _Mybase(_Message.c_str()) {}

    explicit invalid_argument(const char* _Message) : _Mybase(_Message) {}






#line 67 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\stdexcept"
};

 class length_error : public logic_error { 
public:
    using _Mybase = logic_error;

    explicit length_error(const string& _Message) : _Mybase(_Message.c_str()) {}

    explicit length_error(const char* _Message) : _Mybase(_Message) {}






#line 83 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\stdexcept"
};

 class out_of_range : public logic_error { 
public:
    using _Mybase = logic_error;

    explicit out_of_range(const string& _Message) : _Mybase(_Message.c_str()) {}

    explicit out_of_range(const char* _Message) : _Mybase(_Message) {}






#line 99 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\stdexcept"
};

 class runtime_error : public exception { 
public:
    using _Mybase = exception;

    explicit runtime_error(const string& _Message) : _Mybase(_Message.c_str()) {}

    explicit runtime_error(const char* _Message) : _Mybase(_Message) {}






#line 115 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\stdexcept"
};

 class overflow_error : public runtime_error { 
public:
    using _Mybase = runtime_error;

    explicit overflow_error(const string& _Message) : _Mybase(_Message.c_str()) {}

    explicit overflow_error(const char* _Message) : _Mybase(_Message) {}






#line 131 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\stdexcept"
};

 class underflow_error : public runtime_error { 
public:
    using _Mybase = runtime_error;

    explicit underflow_error(const string& _Message) : _Mybase(_Message.c_str()) {}

    explicit underflow_error(const char* _Message) : _Mybase(_Message) {}






#line 147 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\stdexcept"
};

 class range_error : public runtime_error { 
public:
    using _Mybase = runtime_error;

    explicit range_error(const string& _Message) : _Mybase(_Message.c_str()) {}

    explicit range_error(const char* _Message) : _Mybase(_Message) {}






#line 163 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\stdexcept"
};

[[noreturn]] inline void _Throw_range_error(const char* const _Message) {
    throw range_error{_Message} ;
}
}


#pragma warning(pop)
#pragma pack(pop)
#line 174 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\stdexcept"
#line 175 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\stdexcept"
#pragma external_header(pop)
#line 15 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\system_error"
#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xcall_once.h"





#pragma once





#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




namespace std {
 struct once_flag { 
    constexpr once_flag() noexcept : _Opaque(nullptr) {}

    once_flag(const once_flag&)            = delete;
    once_flag& operator=(const once_flag&) = delete;

    void* _Opaque;
};


using _Execute_once_fp_t = int(__stdcall*)(void*, void*, void**);


extern "C++"  int __cdecl _Execute_once(
    once_flag& _Flag, _Execute_once_fp_t _Callback, void* _Pv) noexcept;

template <class _Ty>
union _Immortalizer_impl { 
    constexpr _Immortalizer_impl() noexcept : _Storage{} {}
    _Immortalizer_impl(const _Immortalizer_impl&)            = delete;
    _Immortalizer_impl& operator=(const _Immortalizer_impl&) = delete;
    ~_Immortalizer_impl() {
        
    }

    _Ty _Storage;
};
}



#pragma warning(pop)
#pragma pack(pop)
#line 54 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xcall_once.h"
#line 55 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xcall_once.h"
#pragma external_header(pop)
#line 16 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\system_error"
#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xerrc.h"





#pragma once





#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




namespace std {
 enum class errc { 
    address_family_not_supported       = 102, 
    address_in_use                     = 100, 
    address_not_available              = 101, 
    already_connected                  = 113, 
    argument_list_too_long             = 7, 
    argument_out_of_domain             = 33, 
    bad_address                        = 14, 
    bad_file_descriptor                = 9, 
    bad_message                        = 104, 
    broken_pipe                        = 32, 
    connection_aborted                 = 106, 
    connection_already_in_progress     = 103, 
    connection_refused                 = 107, 
    connection_reset                   = 108, 
    cross_device_link                  = 18, 
    destination_address_required       = 109, 
    device_or_resource_busy            = 16, 
    directory_not_empty                = 41, 
    executable_format_error            = 8, 
    file_exists                        = 17, 
    file_too_large                     = 27, 
    filename_too_long                  = 38, 
    function_not_supported             = 40, 
    host_unreachable                   = 110, 
    identifier_removed                 = 111, 
    illegal_byte_sequence              = 42, 
    inappropriate_io_control_operation = 25, 
    interrupted                        = 4, 
    invalid_argument                   = 22, 
    invalid_seek                       = 29, 
    io_error                           = 5, 
    is_a_directory                     = 21, 
    message_size                       = 115, 
    network_down                       = 116, 
    network_reset                      = 117, 
    network_unreachable                = 118, 
    no_buffer_space                    = 119, 
    no_child_process                   = 10, 
    no_link                            = 121, 
    no_lock_available                  = 39, 
    no_message_available               = 120, 
    no_message                         = 122, 
    no_protocol_option                 = 123, 
    no_space_on_device                 = 28, 
    no_stream_resources                = 124, 
    no_such_device_or_address          = 6, 
    no_such_device                     = 19, 
    no_such_file_or_directory          = 2, 
    no_such_process                    = 3, 
    not_a_directory                    = 20, 
    not_a_socket                       = 128, 
    not_a_stream                       = 125, 
    not_connected                      = 126, 
    not_enough_memory                  = 12, 
    not_supported                      = 129, 
    operation_canceled                 = 105, 
    operation_in_progress              = 112, 
    operation_not_permitted            = 1, 
    operation_not_supported            = 130, 
    operation_would_block              = 140, 
    owner_dead                         = 133, 
    permission_denied                  = 13, 
    protocol_error                     = 134, 
    protocol_not_supported             = 135, 
    read_only_file_system              = 30, 
    resource_deadlock_would_occur      = 36, 
    resource_unavailable_try_again     = 11, 
    result_out_of_range                = 34, 
    state_not_recoverable              = 127, 
    stream_timeout                     = 137, 
    text_file_busy                     = 139, 
    timed_out                          = 138, 
    too_many_files_open_in_system      = 23, 
    too_many_files_open                = 24, 
    too_many_links                     = 31, 
    too_many_symbolic_link_levels      = 114, 
    value_too_large                    = 132, 
    wrong_protocol_type                = 136 
};

}



#pragma warning(pop)
#pragma pack(pop)

#line 109 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xerrc.h"
#line 110 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xerrc.h"
#pragma external_header(pop)
#line 17 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\system_error"

#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"





#pragma once














#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xatomic_wait.h"





#pragma once








#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




inline constexpr unsigned long long _Atomic_wait_no_deadline = 0xFFFF'FFFF'FFFF'FFFF;
inline constexpr unsigned long _Atomic_wait_no_timeout       = 0xFFFF'FFFF; 

extern "C" {
enum class __std_atomic_api_level : unsigned long {
    __not_set,
    __detecting,
    __has_srwlock,
    __has_wait_on_address,
};





__std_atomic_api_level __stdcall __std_atomic_set_api_level(__std_atomic_api_level _Requested_api_level) noexcept;





int __stdcall __std_atomic_wait_direct(
    const void* _Storage, void* _Comparand, size_t _Size, unsigned long _Remaining_timeout) noexcept;
void __stdcall __std_atomic_notify_one_direct(const void* _Storage) noexcept;
void __stdcall __std_atomic_notify_all_direct(const void* _Storage) noexcept;




using _Atomic_wait_indirect_equal_callback_t = bool(__stdcall*)(
    const void* _Storage, void* _Comparand, size_t _Size, void* _Param) noexcept ;

int __stdcall __std_atomic_wait_indirect(const void* _Storage, void* _Comparand, size_t _Size, void* _Param,
    _Atomic_wait_indirect_equal_callback_t _Are_equal, unsigned long _Remaining_timeout) noexcept;
void __stdcall __std_atomic_notify_one_indirect(const void* _Storage) noexcept;
void __stdcall __std_atomic_notify_all_indirect(const void* _Storage) noexcept;




unsigned long long __stdcall __std_atomic_wait_get_deadline(unsigned long long _Timeout) noexcept;
unsigned long __stdcall __std_atomic_wait_get_remaining_timeout(unsigned long long _Deadline) noexcept;

}



#pragma warning(pop)
#pragma pack(pop)
#line 72 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xatomic_wait.h"
#line 73 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xatomic_wait.h"
#pragma external_header(pop)
#line 22 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"
#line 23 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"
#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xthreads.h"





#pragma once





#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xtimec.h"





#pragma once





#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ctime"





#pragma once





#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\time.h"







#pragma once






#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {








typedef long clock_t;

struct _timespec32
{
    __time32_t tv_sec;
    long       tv_nsec;
};

struct _timespec64
{
    __time64_t tv_sec;
    long       tv_nsec;
};


    struct timespec
    {
        time_t tv_sec;  
        long   tv_nsec; 
    };
#line 49 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\time.h"
















 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_daylight" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) int* __cdecl __daylight(void);




 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_dstbias" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) long* __cdecl __dstbias(void);




 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_timezone" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) long* __cdecl __timezone(void);




  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_tzname" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char** __cdecl __tzname(void);



 
__declspec(dllimport) errno_t __cdecl _get_daylight(
     int* _Daylight
    );


__declspec(dllimport) errno_t __cdecl _get_dstbias(
     long* _DaylightSavingsBias
    );

 
__declspec(dllimport) errno_t __cdecl _get_timezone(
     long* _TimeZone
    );


__declspec(dllimport) errno_t __cdecl _get_tzname(
                            size_t* _ReturnValue,
     char*   _Buffer,
                             size_t  _SizeInBytes,
                             int     _Index
    );










 __declspec(deprecated("This function or variable may be unsafe. Consider using " "asctime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl asctime(
     struct tm const* _Tm
    );


    
    
    __declspec(dllimport) errno_t __cdecl asctime_s(
          char*            _Buffer,
                                           size_t           _SizeInBytes,
                                                        struct tm const* _Tm
        );
#line 134 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\time.h"

extern "C++" { template <size_t _Size> inline errno_t __cdecl asctime_s(char (&_Buffer)[_Size], struct tm const* _Time) throw() { return asctime_s(_Buffer, _Size, _Time); } }






__declspec(dllimport) clock_t __cdecl clock(void);



 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ctime32_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _ctime32(
     __time32_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _ctime32_s(
      char*             _Buffer,
                                       size_t            _SizeInBytes,
                                                    __time32_t const* _Time
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ctime32_s(char (&_Buffer)[_Size], __time32_t const* _Time) throw() { return _ctime32_s(_Buffer, _Size, _Time); } }







 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ctime64_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _ctime64(
     __time64_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _ctime64_s(
      char*             _Buffer,
                                         size_t            _SizeInBytes,
                                                      __time64_t const* _Time
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ctime64_s(char (&_Buffer)[_Size], __time64_t const* _Time) throw() { return _ctime64_s(_Buffer, _Size, _Time); } }






__declspec(dllimport) double __cdecl _difftime32(
     __time32_t _Time1,
     __time32_t _Time2
    );


__declspec(dllimport) double __cdecl _difftime64(
     __time64_t _Time1,
     __time64_t _Time2
    );


 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_gmtime32_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) struct tm* __cdecl _gmtime32(
     __time32_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _gmtime32_s(
     struct tm*        _Tm,
      __time32_t const* _Time
    );


 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_gmtime64_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) struct tm* __cdecl _gmtime64(
     __time64_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _gmtime64_s(
     struct tm*        _Tm,
      __time64_t const* _Time
    );


 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_localtime32_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) struct tm* __cdecl _localtime32(
     __time32_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _localtime32_s(
     struct tm*        _Tm,
      __time32_t const* _Time
    );


 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_localtime64_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) struct tm* __cdecl _localtime64(
     __time64_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _localtime64_s(
     struct tm*        _Tm,
      __time64_t const* _Time
    );


__declspec(dllimport) __time32_t __cdecl _mkgmtime32(
     struct tm* _Tm
    );


__declspec(dllimport) __time64_t __cdecl _mkgmtime64(
     struct tm* _Tm
    );


__declspec(dllimport) __time32_t __cdecl _mktime32(
     struct tm* _Tm
    );


__declspec(dllimport) __time64_t __cdecl _mktime64(
     struct tm* _Tm
    );



__declspec(dllimport) size_t __cdecl strftime(
      char*            _Buffer,
                              size_t           _SizeInBytes,
      char const*      _Format,
                              struct tm const* _Tm
    );



__declspec(dllimport) size_t __cdecl _strftime_l(
          char*            _Buffer,
                              size_t           _MaxSize,
      char const*      _Format,
                              struct tm const* _Tm,
                          _locale_t        _Locale
    );


__declspec(dllimport) errno_t __cdecl _strdate_s(
      char*  _Buffer,
                                                                             size_t _SizeInBytes
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strdate_s(char (&_Buffer)[_Size]) throw() { return _strdate_s(_Buffer, _Size); } }




__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strdate_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strdate( char *_Buffer);





__declspec(dllimport) errno_t __cdecl _strtime_s(
      char*  _Buffer,
                                                                             size_t _SizeInBytes
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strtime_s(char (&_Buffer)[_Size]) throw() { return _strtime_s(_Buffer, _Size); } }




__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strtime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strtime( char *_Buffer);




__declspec(dllimport) __time32_t __cdecl _time32(
     __time32_t* _Time
    );

__declspec(dllimport) __time64_t __cdecl _time64(
     __time64_t* _Time
    );



__declspec(dllimport) int __cdecl _timespec32_get(
     struct _timespec32* _Ts,
      int                 _Base
    );



__declspec(dllimport) int __cdecl _timespec64_get(
     struct _timespec64* _Ts,
      int                 _Base
    );










    __declspec(dllimport) void __cdecl _tzset(void);

    
    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "GetLocalTime" " " "instead. See online help for details."))
    __declspec(dllimport) unsigned __cdecl _getsystime(
         struct tm* _Tm
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "SetLocalTime" " " "instead. See online help for details."))
    __declspec(dllimport) unsigned __cdecl _setsystime(
         struct tm* _Tm,
         unsigned   _Milliseconds
        );

#line 361 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\time.h"










    


































































































         __declspec(deprecated("This function or variable may be unsafe. Consider using " "ctime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        static __inline char* __cdecl ctime(
             time_t const* const _Time
            )
        {
            return _ctime64(_Time);
        }

        
        static __inline double __cdecl difftime(
             time_t const _Time1,
             time_t const _Time2
            )
        {
            return _difftime64(_Time1, _Time2);
        }

         __declspec(deprecated("This function or variable may be unsafe. Consider using " "gmtime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        static __inline struct tm* __cdecl gmtime(
             time_t const* const _Time)
        {
            return _gmtime64(_Time);
        }

        __declspec(deprecated("This function or variable may be unsafe. Consider using " "localtime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        static __inline struct tm* __cdecl localtime(
             time_t const* const _Time
            )
        {
            return _localtime64(_Time);
        }

        
        static __inline time_t __cdecl _mkgmtime(
             struct tm* const _Tm
            )
        {
            return _mkgmtime64(_Tm);
        }

        
        static __inline time_t __cdecl mktime(
             struct tm* const _Tm
            )
        {
            return _mktime64(_Tm);
        }

        static __inline time_t __cdecl time(
             time_t* const _Time
            )
        {
            return _time64(_Time);
        }

        
        static __inline int __cdecl timespec_get(
             struct timespec* const _Ts,
              int              const _Base
            )
        {
            return _timespec64_get((struct _timespec64*)_Ts, _Base);
        }

        
            
            static __inline errno_t __cdecl ctime_s(
                  char*         const _Buffer,
                                                   size_t        const _SizeInBytes,
                                                                time_t const* const _Time
                )
            {
                return _ctime64_s(_Buffer, _SizeInBytes, _Time);
            }

            
            static __inline errno_t __cdecl gmtime_s(
                 struct tm*    const _Tm,
                  time_t const* const _Time
                )
            {
                return _gmtime64_s(_Tm, _Time);
            }

            
            static __inline errno_t __cdecl localtime_s(
                 struct tm*    const _Tm,
                  time_t const* const _Time
                )
            {
                return _localtime64_s(_Tm, _Time);
            }
        #line 563 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\time.h"

    #line 565 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\time.h"

#line 567 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\time.h"










    

    
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_tzset" ". See online help for details.")) __declspec(dllimport) void __cdecl tzset(void);
    #line 582 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\time.h"

#line 584 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\time.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#line 591 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\time.h"
#pragma external_header(pop)
#line 13 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ctime"

#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




namespace std {
 using :: clock_t;
 using :: size_t;
 using :: time_t;
 using :: tm;
 using :: asctime;
 using :: clock;
 using :: strftime;

 using :: timespec;
#line 32 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ctime"













































#line 78 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ctime"


 using :: ctime;
 using :: difftime;
 using :: gmtime;
 using :: localtime;
 using :: mktime;
 using :: time;

 using :: timespec_get;
#line 89 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ctime"

#line 91 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ctime"
}



#pragma warning(pop)
#pragma pack(pop)

#line 99 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ctime"
#line 100 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ctime"
#pragma external_header(pop)
#line 13 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xtimec.h"

#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




extern "C" {

struct xtime { 
    __time64_t sec;
    long nsec;
};

 int __cdecl xtime_get(xtime*, int);

 long __cdecl _Xtime_diff_to_millis(const xtime*);
 long __cdecl _Xtime_diff_to_millis2(const xtime*, const xtime*);
 long long __cdecl _Xtime_get_ticks();

 long long __cdecl _Query_perf_counter();
 long long __cdecl _Query_perf_frequency();

}



#pragma warning(pop)
#pragma pack(pop)
#line 44 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xtimec.h"
#line 45 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xtimec.h"
















#pragma external_header(pop)
#line 13 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xthreads.h"

#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




extern "C" {
using _Thrd_id_t = unsigned int;
struct _Thrd_t { 
    void* _Hnd; 
    _Thrd_id_t _Id;
};
















inline constexpr size_t _Mtx_internal_imp_size      = 80;
inline constexpr size_t _Mtx_internal_imp_alignment = 8;
inline constexpr size_t _Cnd_internal_imp_size      = 72;
inline constexpr size_t _Cnd_internal_imp_alignment = 8;





#line 53 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xthreads.h"
#line 54 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xthreads.h"





struct _Mtx_internal_imp_t;
struct _Cnd_internal_imp_t;
using _Mtx_t = _Mtx_internal_imp_t*;
using _Cnd_t = _Cnd_internal_imp_t*;
#line 64 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xthreads.h"

enum { _Thrd_success, _Thrd_nomem, _Thrd_timedout, _Thrd_busy, _Thrd_error };


 int __cdecl _Thrd_detach(_Thrd_t);
 int __cdecl _Thrd_join(_Thrd_t, int*);
 void __cdecl _Thrd_sleep(const xtime*);
 void __cdecl _Thrd_yield();
 unsigned int __cdecl _Thrd_hardware_concurrency();
 _Thrd_id_t __cdecl _Thrd_id();


enum { 
    _Mtx_plain     = 0x01,
    _Mtx_try       = 0x02,
    _Mtx_timed     = 0x04,
    _Mtx_recursive = 0x100
};

 int __cdecl _Mtx_init(_Mtx_t*, int);
 void __cdecl _Mtx_destroy(_Mtx_t);
 void __cdecl _Mtx_init_in_situ(_Mtx_t, int);
 void __cdecl _Mtx_destroy_in_situ(_Mtx_t);
 int __cdecl _Mtx_current_owns(_Mtx_t);
 int __cdecl _Mtx_lock(_Mtx_t);
 int __cdecl _Mtx_trylock(_Mtx_t);
 int __cdecl _Mtx_timedlock(_Mtx_t, const xtime*);
 int __cdecl _Mtx_unlock(_Mtx_t); 

 void* __cdecl _Mtx_getconcrtcs(_Mtx_t);
 void __cdecl _Mtx_clear_owner(_Mtx_t);
 void __cdecl _Mtx_reset_owner(_Mtx_t);



using _Smtx_t = void*;
void __cdecl _Smtx_lock_exclusive(_Smtx_t*);
void __cdecl _Smtx_lock_shared(_Smtx_t*);
int __cdecl _Smtx_try_lock_exclusive(_Smtx_t*);
int __cdecl _Smtx_try_lock_shared(_Smtx_t*);
void __cdecl _Smtx_unlock_exclusive(_Smtx_t*);
void __cdecl _Smtx_unlock_shared(_Smtx_t*);


 int __cdecl _Cnd_init(_Cnd_t*);
 void __cdecl _Cnd_destroy(_Cnd_t);
 void __cdecl _Cnd_init_in_situ(_Cnd_t);
 void __cdecl _Cnd_destroy_in_situ(_Cnd_t);
 int __cdecl _Cnd_wait(_Cnd_t, _Mtx_t); 
 int __cdecl _Cnd_timedwait(_Cnd_t, _Mtx_t, const xtime*);
 int __cdecl _Cnd_broadcast(_Cnd_t); 
 int __cdecl _Cnd_signal(_Cnd_t); 
 void __cdecl _Cnd_register_at_thread_exit(_Cnd_t, _Mtx_t, int*);
 void __cdecl _Cnd_unregister_at_thread_exit(_Mtx_t);
 void __cdecl _Cnd_do_broadcast_at_thread_exit();
}

namespace std {
enum { 
    _DEVICE_OR_RESOURCE_BUSY,
    _INVALID_ARGUMENT,
    _NO_SUCH_PROCESS,
    _NOT_ENOUGH_MEMORY,
    _OPERATION_NOT_PERMITTED,
    _RESOURCE_DEADLOCK_WOULD_OCCUR,
    _RESOURCE_UNAVAILABLE_TRY_AGAIN
};

extern "C++" [[noreturn]]  void __cdecl _Throw_C_error(int _Code);
extern "C++" [[noreturn]]  void __cdecl _Throw_Cpp_error(int _Code);

inline int _Check_C_return(int _Res) { 
    if (_Res != _Thrd_success) {
        _Throw_C_error(_Res);
    }

    return _Res;
}
}


#pragma warning(pop)
#pragma pack(pop)
#line 148 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xthreads.h"
#line 149 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xthreads.h"
















#pragma external_header(pop)
#line 24 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"

#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )







#line 36 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"





extern "C" [[nodiscard]] unsigned char __stdcall __std_atomic_compare_exchange_128(
     long long* _Destination,  long long _ExchangeHigh,  long long _ExchangeLow,
     long long* _ComparandResult) noexcept;
extern "C" [[nodiscard]] char __stdcall __std_atomic_has_cmpxchg16b() noexcept;

#line 47 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"
#line 48 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"




#line 53 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"

#line 55 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"









#line 65 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"

#line 67 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"
#line 68 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"





#line 74 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"













enum {
    _Atomic_memory_order_relaxed,
    _Atomic_memory_order_consume,
    _Atomic_memory_order_acquire,
    _Atomic_memory_order_release,
    _Atomic_memory_order_acq_rel,
    _Atomic_memory_order_seq_cst,
};






#line 102 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"
#line 103 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"

extern "C" inline void _Check_memory_order(const unsigned int _Order) noexcept {
    if (_Order > _Atomic_memory_order_seq_cst) {
         ;
    }
}


























#line 136 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"

























#line 162 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"


























#line 189 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"





#line 195 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"


























#line 222 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"

#line 224 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"














#line 239 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"



#line 243 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"






#line 250 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"


#line 253 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"

#pragma warning(push)
#pragma warning(disable : 6001) 
#pragma warning(disable : 28113) 
                                 
extern "C" inline void _Atomic_thread_fence(const unsigned int _Order) noexcept {
    if (_Order == _Atomic_memory_order_relaxed) {
        return;
    }


    __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop)) ;
    if (_Order == _Atomic_memory_order_seq_cst) {
        volatile long _Guard; 

        
        
        
        (void) _InterlockedIncrement(&_Guard);
        __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop)) ;
    }




#line 279 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"
}
#pragma warning(pop)



extern "C" {
_Smtx_t* __stdcall __std_atomic_get_mutex(const void* _Key) noexcept;
}







#line 295 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"

namespace std {

struct _Form_mask_t {};
inline constexpr _Form_mask_t _Form_mask{};
#line 301 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"

template <class _Ty>
struct _Storage_for {
    
    alignas(_Ty) unsigned char _Storage[sizeof(_Ty)];

    _Storage_for()                               = default;
    _Storage_for(const _Storage_for&)            = delete;
    _Storage_for& operator=(const _Storage_for&) = delete;


    explicit _Storage_for(_Form_mask_t) noexcept {
        :: memset(_Storage, 0xff, sizeof(_Ty));
        __builtin_zero_non_value_bits(_Ptr());
    }
#line 317 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"

    [[nodiscard]] _Ty& _Ref() noexcept {
        return reinterpret_cast<_Ty&>(_Storage);
    }

    [[nodiscard]] _Ty* _Ptr() noexcept {
        return reinterpret_cast<_Ty*>(&_Storage);
    }
};


template <class _Ty>
inline constexpr bool _Might_have_non_value_bits =
    !has_unique_object_representations_v<_Ty> && !is_floating_point_v<_Ty>;
#line 332 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"

 extern "C" inline void atomic_thread_fence(const memory_order _Order) noexcept {
    ::_Atomic_thread_fence(static_cast<unsigned int>(_Order));
}

 extern "C" inline void atomic_signal_fence(const memory_order _Order) noexcept {
    if (_Order != memory_order_relaxed) {
        __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop)) ;
    }
}

 template <class _Ty>
_Ty kill_dependency(_Ty _Arg) noexcept { 
    return _Arg;
}

inline void _Check_store_memory_order(const memory_order _Order) noexcept {
    switch (_Order) {
    case memory_order_relaxed:
    case memory_order_release:
    case memory_order_seq_cst:
        
        break;
    case memory_order_consume:
    case memory_order_acquire:
    case memory_order_acq_rel:
    default:
         ;
        break;
    }
}

inline void _Check_load_memory_order(const memory_order _Order) noexcept {
    switch (_Order) {
    case memory_order_relaxed:
    case memory_order_consume:
    case memory_order_acquire:
    case memory_order_seq_cst:
        
        break;
    case memory_order_release:
    case memory_order_acq_rel:
    default:
         ;
        break;
    }
}

[[nodiscard]] inline memory_order _Combine_cas_memory_orders(
    const memory_order _Success, const memory_order _Failure) noexcept {
    
    
    
    
    
    

    
    
    
    
    static constexpr memory_order _Combined_memory_orders[6][6] = {
        {memory_order_relaxed, memory_order_consume, memory_order_acquire, memory_order_release, memory_order_acq_rel,
            memory_order_seq_cst},
        {memory_order_consume, memory_order_consume, memory_order_acquire, memory_order_acq_rel, memory_order_acq_rel,
            memory_order_seq_cst},
        {memory_order_acquire, memory_order_acquire, memory_order_acquire, memory_order_acq_rel, memory_order_acq_rel,
            memory_order_seq_cst},
        {memory_order_release, memory_order_acq_rel, memory_order_acq_rel, memory_order_release, memory_order_acq_rel,
            memory_order_seq_cst},
        {memory_order_acq_rel, memory_order_acq_rel, memory_order_acq_rel, memory_order_acq_rel, memory_order_acq_rel,
            memory_order_seq_cst},
        {memory_order_seq_cst, memory_order_seq_cst, memory_order_seq_cst, memory_order_seq_cst, memory_order_seq_cst,
            memory_order_seq_cst}};

    _Check_memory_order(static_cast<unsigned int>(_Success));
    _Check_load_memory_order(_Failure);
    return _Combined_memory_orders[static_cast<int>(_Success)][static_cast<int>(_Failure)];
}

template <class _Integral, class _Ty>
[[nodiscard]] _Integral _Atomic_reinterpret_as(const _Ty& _Source) noexcept {
    
    static_assert(is_integral_v<_Integral>, "Tried to reinterpret memory as non-integral");
    if constexpr (is_integral_v<_Ty> && sizeof(_Integral) == sizeof(_Ty)) {
        return static_cast<_Integral>(_Source);
    } else if constexpr (is_pointer_v<_Ty> && sizeof(_Integral) == sizeof(_Ty)) {
        return reinterpret_cast<_Integral>(_Source);
    } else {
        _Integral _Result{}; 
        :: memcpy(&_Result, ::std:: addressof(_Source), sizeof(_Source));
        return _Result;
    }
}


template <class _Ty>
struct _Atomic_padded {
    alignas(sizeof(_Ty)) mutable _Ty _Value; 
};







































#line 472 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"

template <class _Ty>
struct _Atomic_storage_types {
    using _TStorage = _Atomic_padded<_Ty>;
    using _Spinlock = long;
};

template <class _Ty>
struct _Atomic_storage_types<_Ty&> {
    using _TStorage = _Ty&;
    using _Spinlock = _Smtx_t*; 
};


template <class _Ty, size_t = sizeof(remove_reference_t<_Ty>)>


#line 490 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"
struct _Atomic_storage;


template <class _Ty, class _Value_type>
void _Atomic_wait_direct(
    const _Atomic_storage<_Ty>* const _This, _Value_type _Expected_bytes, const memory_order _Order) noexcept {
    const auto _Storage_ptr = ::std:: addressof(_This->_Storage);
    for (;;) {
        const _Value_type _Observed_bytes = _Atomic_reinterpret_as<_Value_type>(_This->load(_Order));
        if (_Expected_bytes != _Observed_bytes) {

            using _TVal = remove_reference_t<_Ty>;
            if constexpr (_Might_have_non_value_bits<_TVal>) {
                _Storage_for<_TVal> _Mask{_Form_mask};
                const _Value_type _Mask_val = _Atomic_reinterpret_as<_Value_type>(_Mask._Ref());

                if (((_Expected_bytes ^ _Observed_bytes) & _Mask_val) == 0) {
                    _Expected_bytes = _Observed_bytes;
                    continue;
                }
            }
#line 512 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"

            return;
        }

        __std_atomic_wait_direct(_Storage_ptr, &_Expected_bytes, sizeof(_Value_type), _Atomic_wait_no_timeout);
    }
}
#line 520 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"


inline void _Atomic_lock_acquire(long& _Spinlock) noexcept {

    
    
    
    int _Current_backoff   = 1;
    const int _Max_backoff = 64;
    while (_InterlockedExchange(&_Spinlock, 1) != 0) {
        while (__iso_volatile_load32(&reinterpret_cast<int&>(_Spinlock)) != 0) {
            for (int _Count_down = _Current_backoff; _Count_down != 0; --_Count_down) {
                _mm_pause();
            }
            _Current_backoff = _Current_backoff < _Max_backoff ? _Current_backoff << 1 : _Max_backoff;
        }
    }








#line 546 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"
}

inline void _Atomic_lock_release(long& _Spinlock) noexcept {

    _InterlockedExchange(&_Spinlock, 0); 






#line 558 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"
}

inline void _Atomic_lock_acquire(_Smtx_t* _Spinlock) noexcept {
    _Smtx_lock_exclusive(_Spinlock);
}

inline void _Atomic_lock_release(_Smtx_t* _Spinlock) noexcept {
    _Smtx_unlock_exclusive(_Spinlock);
}

template <class _Spinlock_t>
class [[nodiscard]] _Atomic_lock_guard {
public:
    explicit _Atomic_lock_guard(_Spinlock_t& _Spinlock_) noexcept : _Spinlock(_Spinlock_) {
        _Atomic_lock_acquire(_Spinlock);
    }

    ~_Atomic_lock_guard() {
        _Atomic_lock_release(_Spinlock);
    }

    _Atomic_lock_guard(const _Atomic_lock_guard&)            = delete;
    _Atomic_lock_guard& operator=(const _Atomic_lock_guard&) = delete;

private:
    _Spinlock_t& _Spinlock;
};


template <class _Spinlock_t>
bool __stdcall _Atomic_wait_compare_non_lock_free(
    const void* _Storage, void* _Comparand, size_t _Size, void* _Spinlock_raw) noexcept {
    _Spinlock_t& _Spinlock = *static_cast<_Spinlock_t*>(_Spinlock_raw);
    _Atomic_lock_acquire(_Spinlock);
    const auto _Cmp_result = :: memcmp(_Storage, _Comparand, _Size);
    _Atomic_lock_release(_Spinlock);
    return _Cmp_result == 0;
}


inline bool __stdcall _Atomic_wait_compare_16_bytes(const void* _Storage, void* _Comparand, size_t, void*) noexcept {
    const auto _Dest              = static_cast<long long*>(const_cast<void*>(_Storage));
    const auto _Cmp               = static_cast<const long long*>(_Comparand);
    alignas(16) long long _Tmp[2] = {_Cmp[0], _Cmp[1]};

    return __std_atomic_compare_exchange_128 (_Dest, _Tmp[1], _Tmp[0], _Tmp) != 0;


#line 607 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"
}
#line 609 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"
#line 610 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"
#line 611 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"

template <class _Ty, size_t  >
struct _Atomic_storage {
    
    

    using _TVal  = remove_reference_t<_Ty>;
    using _Guard = _Atomic_lock_guard<typename _Atomic_storage_types<_Ty>::_Spinlock>;

    _Atomic_storage() = default;

      constexpr _Atomic_storage(conditional_t<is_reference_v<_Ty>, _Ty, const _TVal> _Value) noexcept
        : _Storage(_Value) {
        
    }

    void store(const _TVal _Value, const memory_order _Order = memory_order_seq_cst) noexcept {
        
        _Check_store_memory_order(_Order);
        _Guard _Lock{_Spinlock};
        _Storage = _Value;
    }

    [[nodiscard]] _TVal load(const memory_order _Order = memory_order_seq_cst) const noexcept {
        
        _Check_load_memory_order(_Order);
        _Guard _Lock{_Spinlock};
        _TVal _Local(_Storage);
        return _Local;
    }

    _TVal exchange(const _TVal _Value, const memory_order _Order = memory_order_seq_cst) noexcept {
        
        _Check_memory_order(static_cast<unsigned int>(_Order));
        _Guard _Lock{_Spinlock};
        _TVal _Result(_Storage);
        _Storage = _Value;
        return _Result;
    }

    bool compare_exchange_strong(_TVal& _Expected, const _TVal _Desired,
        const memory_order _Order = memory_order_seq_cst) noexcept { 
        _Check_memory_order(static_cast<unsigned int>(_Order));
        const auto _Storage_ptr  = ::std:: addressof(_Storage);
        const auto _Expected_ptr = ::std:: addressof(_Expected);
        bool _Result;

        __builtin_zero_non_value_bits(_Expected_ptr);
#line 660 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"
        _Guard _Lock{_Spinlock};

        if constexpr (_Might_have_non_value_bits<_TVal>) {
            _Storage_for<_TVal> _Local;
            const auto _Local_ptr = _Local._Ptr();
            :: memcpy(_Local_ptr, _Storage_ptr, sizeof(_TVal));
            __builtin_zero_non_value_bits(_Local_ptr);
            _Result = :: memcmp(_Local_ptr, _Expected_ptr, sizeof(_TVal)) == 0;
        } else {
            _Result = :: memcmp(_Storage_ptr, _Expected_ptr, sizeof(_TVal)) == 0;
        }


#line 674 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"
        if (_Result) {
            :: memcpy(_Storage_ptr, ::std:: addressof(_Desired), sizeof(_TVal));
        } else {
            :: memcpy(_Expected_ptr, _Storage_ptr, sizeof(_TVal));
        }

        return _Result;
    }


    void wait(_TVal _Expected, memory_order = memory_order_seq_cst) const noexcept {
        const auto _Storage_ptr  = ::std:: addressof(_Storage);
        const auto _Expected_ptr = ::std:: addressof(_Expected);
        for (;;) {
            {
                _Guard _Lock{_Spinlock};
                if (:: memcmp(_Storage_ptr, _Expected_ptr, sizeof(_TVal)) != 0) {
                    

                    if constexpr (_Might_have_non_value_bits<_TVal>) {
                        _Storage_for<_TVal> _Local;
                        const auto _Local_ptr = _Local._Ptr();
                        :: memcpy(_Local_ptr, _Storage_ptr, sizeof(_TVal));
                        __builtin_zero_non_value_bits(_Local_ptr);
                        __builtin_zero_non_value_bits(_Expected_ptr);
                        if (:: memcmp(_Local_ptr, _Expected_ptr, sizeof(_TVal)) == 0) {
                            
                            
                            :: memcpy(_Expected_ptr, _Storage_ptr, sizeof(_TVal));
                        } else {
                            
                            return;
                        }
                    } else
#line 709 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"
                    {
                        return;
                    }
                }
            } 

            __std_atomic_wait_indirect(_Storage_ptr, _Expected_ptr, sizeof(_TVal), &_Spinlock,
                &_Atomic_wait_compare_non_lock_free<decltype(_Spinlock)>, _Atomic_wait_no_timeout);
        }
    }

    void notify_one() noexcept {
        __std_atomic_notify_one_indirect(::std:: addressof(_Storage));
    }

    void notify_all() noexcept {
        __std_atomic_notify_all_indirect(::std:: addressof(_Storage));
    }
#line 728 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"


protected:
    void _Init_spinlock_for_ref() noexcept {
        _Spinlock = __std_atomic_get_mutex(::std:: addressof(_Storage));
    }

private:
    
    mutable typename _Atomic_storage_types<_Ty>::_Spinlock _Spinlock{};

public:
    _Ty _Storage{};




#line 746 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"
};

template <class _Ty>
struct _Atomic_storage<_Ty, 1> { 

    using _TVal = remove_reference_t<_Ty>;

    _Atomic_storage() = default;

      constexpr _Atomic_storage(conditional_t<is_reference_v<_Ty>, _Ty, const _TVal> _Value) noexcept
        : _Storage{_Value} {
        
    }

    void store(const _TVal _Value) noexcept { 
        const auto _Mem      = _Atomic_address_as<char>(_Storage);
        const char _As_bytes = _Atomic_reinterpret_as<char>(_Value);
        (void) _InterlockedExchange8(((_Mem)), ((_As_bytes)));
    }

    void store(const _TVal _Value, const memory_order _Order) noexcept { 
        const auto _Mem      = _Atomic_address_as<char>(_Storage);
        const char _As_bytes = _Atomic_reinterpret_as<char>(_Value);
        switch (static_cast<unsigned int>(_Order)) {
            case _Atomic_memory_order_relaxed: __iso_volatile_store8((_Mem), (_As_bytes)); return; case _Atomic_memory_order_release: __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop)); __iso_volatile_store8((_Mem), (_As_bytes)); return; default: case _Atomic_memory_order_consume: case _Atomic_memory_order_acquire: case _Atomic_memory_order_acq_rel:; [[fallthrough]];
        case _Atomic_memory_order_seq_cst:
            store(_Value);
            return;
        }
    }

    [[nodiscard]] _TVal load() const noexcept { 
        const auto _Mem = _Atomic_address_as<char>(_Storage);
        char _As_bytes  = __iso_volatile_load8(_Mem);
        __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop)) ;
        return reinterpret_cast<_TVal&>(_As_bytes);
    }

    [[nodiscard]] _TVal load(const memory_order _Order) const noexcept { 
        const auto _Mem = _Atomic_address_as<char>(_Storage);
        char _As_bytes;


#line 790 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"
        _As_bytes = __iso_volatile_load8(_Mem);
        switch (static_cast<unsigned int>(_Order)) { case _Atomic_memory_order_relaxed: break; case _Atomic_memory_order_consume: case _Atomic_memory_order_acquire: case _Atomic_memory_order_seq_cst: __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop)); break; case _Atomic_memory_order_release: case _Atomic_memory_order_acq_rel: default:; break; }
#line 793 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"
        return reinterpret_cast<_TVal&>(_As_bytes);
    }

    _TVal exchange(const _TVal _Value, const memory_order _Order = memory_order_seq_cst) noexcept {
        
        char _As_bytes;
        _Check_memory_order(static_cast<unsigned int>(_Order)); _As_bytes = _InterlockedExchange8(_Atomic_address_as<char>(_Storage), _Atomic_reinterpret_as<char>(_Value))
;
        return reinterpret_cast<_TVal&>(_As_bytes);
    }

    bool compare_exchange_strong(_TVal& _Expected, const _TVal _Desired,
        const memory_order _Order = memory_order_seq_cst) noexcept { 
        char _Expected_bytes = _Atomic_reinterpret_as<char>(_Expected); 
        char _Prev_bytes;


        if constexpr (_Might_have_non_value_bits<_TVal>) {
            _Storage_for<_TVal> _Mask{_Form_mask};
            const char _Mask_val = _Atomic_reinterpret_as<char>(_Mask._Ref());

            for (;;) {
                _Check_memory_order(static_cast<unsigned int>(_Order)); _Prev_bytes = _InterlockedCompareExchange8(_Atomic_address_as<char>(_Storage), _Atomic_reinterpret_as<char>(_Desired), _Expected_bytes)
;
                if (_Prev_bytes == _Expected_bytes) {
                    return true;
                }

                if ((_Prev_bytes ^ _Expected_bytes) & _Mask_val) {
                    reinterpret_cast<char&>(_Expected) = _Prev_bytes;
                    return false;
                }
                _Expected_bytes = (_Expected_bytes & _Mask_val) | (_Prev_bytes & ~_Mask_val);
            }
        }
#line 829 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"
        _Check_memory_order(static_cast<unsigned int>(_Order)); _Prev_bytes = _InterlockedCompareExchange8(_Atomic_address_as<char>(_Storage), _Atomic_reinterpret_as<char>(_Desired), _Expected_bytes)
;
        if (_Prev_bytes == _Expected_bytes) {
            return true;
        }

        reinterpret_cast<char&>(_Expected) = _Prev_bytes;
        return false;
    }


    void wait(const _TVal _Expected, const memory_order _Order = memory_order_seq_cst) const noexcept {
        _Atomic_wait_direct(this, _Atomic_reinterpret_as<char>(_Expected), _Order);
    }

    void notify_one() noexcept {
        __std_atomic_notify_one_direct(::std:: addressof(_Storage));
    }

    void notify_all() noexcept {
        __std_atomic_notify_all_direct(::std:: addressof(_Storage));
    }
#line 852 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"

    typename _Atomic_storage_types<_Ty>::_TStorage _Storage;
};

template <class _Ty>
struct _Atomic_storage<_Ty, 2> { 

    using _TVal = remove_reference_t<_Ty>;

    _Atomic_storage() = default;

      constexpr _Atomic_storage(conditional_t<is_reference_v<_Ty>, _Ty, const _TVal> _Value) noexcept
        : _Storage{_Value} {
        
    }

    void store(const _TVal _Value) noexcept { 
        const auto _Mem       = _Atomic_address_as<short>(_Storage);
        const short _As_bytes = _Atomic_reinterpret_as<short>(_Value);
        (void) _InterlockedExchange16(((_Mem)), ((_As_bytes)));
    }

    void store(const _TVal _Value, const memory_order _Order) noexcept { 
        const auto _Mem       = _Atomic_address_as<short>(_Storage);
        const short _As_bytes = _Atomic_reinterpret_as<short>(_Value);
        switch (static_cast<unsigned int>(_Order)) {
            case _Atomic_memory_order_relaxed: __iso_volatile_store16((_Mem), (_As_bytes)); return; case _Atomic_memory_order_release: __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop)); __iso_volatile_store16((_Mem), (_As_bytes)); return; default: case _Atomic_memory_order_consume: case _Atomic_memory_order_acquire: case _Atomic_memory_order_acq_rel:; [[fallthrough]];
        case _Atomic_memory_order_seq_cst:
            store(_Value);
            return;
        }
    }

    [[nodiscard]] _TVal load() const noexcept { 
        const auto _Mem = _Atomic_address_as<short>(_Storage);
        short _As_bytes = __iso_volatile_load16(_Mem);
        __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop)) ;
        return reinterpret_cast<_TVal&>(_As_bytes);
    }

    [[nodiscard]] _TVal load(const memory_order _Order) const noexcept { 
        const auto _Mem = _Atomic_address_as<short>(_Storage);
        short _As_bytes;


#line 898 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"
        _As_bytes = __iso_volatile_load16(_Mem);
        switch (static_cast<unsigned int>(_Order)) { case _Atomic_memory_order_relaxed: break; case _Atomic_memory_order_consume: case _Atomic_memory_order_acquire: case _Atomic_memory_order_seq_cst: __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop)); break; case _Atomic_memory_order_release: case _Atomic_memory_order_acq_rel: default:; break; }
#line 901 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"
        return reinterpret_cast<_TVal&>(_As_bytes);
    }

    _TVal exchange(const _TVal _Value, const memory_order _Order = memory_order_seq_cst) noexcept {
        
        short _As_bytes;
        _Check_memory_order(static_cast<unsigned int>(_Order)); _As_bytes = _InterlockedExchange16(_Atomic_address_as<short>(_Storage), _Atomic_reinterpret_as<short>(_Value))
;
        return reinterpret_cast<_TVal&>(_As_bytes);
    }

    bool compare_exchange_strong(_TVal& _Expected, const _TVal _Desired,
        const memory_order _Order = memory_order_seq_cst) noexcept { 
        short _Expected_bytes = _Atomic_reinterpret_as<short>(_Expected); 
        short _Prev_bytes;

        if constexpr (_Might_have_non_value_bits<_Ty>) {
            _Storage_for<_TVal> _Mask{_Form_mask};
            const short _Mask_val = _Atomic_reinterpret_as<short>(_Mask._Ref());

            for (;;) {
                _Check_memory_order(static_cast<unsigned int>(_Order)); _Prev_bytes = _InterlockedCompareExchange16(_Atomic_address_as<short>(_Storage), _Atomic_reinterpret_as<short>(_Desired), _Expected_bytes)
;
                if (_Prev_bytes == _Expected_bytes) {
                    return true;
                }

                if ((_Prev_bytes ^ _Expected_bytes) & _Mask_val) {
                    :: memcpy(::std:: addressof(_Expected), &_Prev_bytes, sizeof(_TVal));
                    return false;
                }
                _Expected_bytes = (_Expected_bytes & _Mask_val) | (_Prev_bytes & ~_Mask_val);
            }
        }
#line 936 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"
        _Check_memory_order(static_cast<unsigned int>(_Order)); _Prev_bytes = _InterlockedCompareExchange16(_Atomic_address_as<short>(_Storage), _Atomic_reinterpret_as<short>(_Desired), _Expected_bytes)
;
        if (_Prev_bytes == _Expected_bytes) {
            return true;
        }

        :: memcpy(::std:: addressof(_Expected), &_Prev_bytes, sizeof(_Ty));
        return false;
    }


    void wait(const _TVal _Expected, const memory_order _Order = memory_order_seq_cst) const noexcept {
        _Atomic_wait_direct(this, _Atomic_reinterpret_as<short>(_Expected), _Order);
    }

    void notify_one() noexcept {
        __std_atomic_notify_one_direct(::std:: addressof(_Storage));
    }

    void notify_all() noexcept {
        __std_atomic_notify_all_direct(::std:: addressof(_Storage));
    }
#line 959 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"

    typename _Atomic_storage_types<_Ty>::_TStorage _Storage;
};

template <class _Ty>
struct _Atomic_storage<_Ty, 4> { 

    using _TVal = remove_reference_t<_Ty>;

    _Atomic_storage() = default;

      constexpr _Atomic_storage(conditional_t<is_reference_v<_Ty>, _Ty, const _TVal> _Value) noexcept
        : _Storage{_Value} {
        
    }

    void store(const _TVal _Value) noexcept { 
        const auto _Mem     = _Atomic_address_as<int>(_Storage);
        const int _As_bytes = _Atomic_reinterpret_as<int>(_Value);
        (void) _InterlockedExchange(reinterpret_cast<volatile long*>((_Mem)), static_cast<long>((_As_bytes)));
    }

    void store(const _TVal _Value, const memory_order _Order) noexcept { 
        const auto _Mem     = _Atomic_address_as<int>(_Storage);
        const int _As_bytes = _Atomic_reinterpret_as<int>(_Value);
        switch (static_cast<unsigned int>(_Order)) {
            case _Atomic_memory_order_relaxed: __iso_volatile_store32((_Mem), (_As_bytes)); return; case _Atomic_memory_order_release: __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop)); __iso_volatile_store32((_Mem), (_As_bytes)); return; default: case _Atomic_memory_order_consume: case _Atomic_memory_order_acquire: case _Atomic_memory_order_acq_rel:; [[fallthrough]];
        case _Atomic_memory_order_seq_cst:
            store(_Value);
            return;
        }
    }

    [[nodiscard]] _TVal load() const noexcept { 
        const auto _Mem = _Atomic_address_as<int>(_Storage);
        int _As_bytes   = __iso_volatile_load32(_Mem);
        __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop)) ;
        return reinterpret_cast<_TVal&>(_As_bytes);
    }

    [[nodiscard]] _TVal load(const memory_order _Order) const noexcept { 
        const auto _Mem = _Atomic_address_as<int>(_Storage);
        int _As_bytes;


#line 1005 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"
        _As_bytes = __iso_volatile_load32(_Mem);
        switch (static_cast<unsigned int>(_Order)) { case _Atomic_memory_order_relaxed: break; case _Atomic_memory_order_consume: case _Atomic_memory_order_acquire: case _Atomic_memory_order_seq_cst: __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop)); break; case _Atomic_memory_order_release: case _Atomic_memory_order_acq_rel: default:; break; }
#line 1008 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"
        return reinterpret_cast<_TVal&>(_As_bytes);
    }

    _TVal exchange(const _TVal _Value, const memory_order _Order = memory_order_seq_cst) noexcept {
        
        long _As_bytes;
        _Check_memory_order(static_cast<unsigned int>(_Order)); _As_bytes = _InterlockedExchange(_Atomic_address_as<long>(_Storage), _Atomic_reinterpret_as<long>(_Value))
;
        return reinterpret_cast<_TVal&>(_As_bytes);
    }

    bool compare_exchange_strong(_TVal& _Expected, const _TVal _Desired,
        const memory_order _Order = memory_order_seq_cst) noexcept { 
        long _Expected_bytes = _Atomic_reinterpret_as<long>(_Expected); 
        long _Prev_bytes;

        if constexpr (_Might_have_non_value_bits<_TVal>) {
            _Storage_for<_TVal> _Mask{_Form_mask};
            const long _Mask_val = _Atomic_reinterpret_as<long>(_Mask);

            for (;;) {
                _Check_memory_order(static_cast<unsigned int>(_Order)); _Prev_bytes = _InterlockedCompareExchange(_Atomic_address_as<long>(_Storage), _Atomic_reinterpret_as<long>(_Desired), _Expected_bytes)
;
                if (_Prev_bytes == _Expected_bytes) {
                    return true;
                }

                if ((_Prev_bytes ^ _Expected_bytes) & _Mask_val) {
                    :: memcpy(::std:: addressof(_Expected), &_Prev_bytes, sizeof(_TVal));
                    return false;
                }
                _Expected_bytes = (_Expected_bytes & _Mask_val) | (_Prev_bytes & ~_Mask_val);
            }
        }
#line 1043 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"
        _Check_memory_order(static_cast<unsigned int>(_Order)); _Prev_bytes = _InterlockedCompareExchange(_Atomic_address_as<long>(_Storage), _Atomic_reinterpret_as<long>(_Desired), _Expected_bytes)
;
        if (_Prev_bytes == _Expected_bytes) {
            return true;
        }

        :: memcpy(::std:: addressof(_Expected), &_Prev_bytes, sizeof(_TVal));
        return false;
    }


    void wait(const _TVal _Expected, const memory_order _Order = memory_order_seq_cst) const noexcept {
        _Atomic_wait_direct(this, _Atomic_reinterpret_as<long>(_Expected), _Order);
    }

    void notify_one() noexcept {
        __std_atomic_notify_one_direct(::std:: addressof(_Storage));
    }

    void notify_all() noexcept {
        __std_atomic_notify_all_direct(::std:: addressof(_Storage));
    }
#line 1066 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"

    typename _Atomic_storage_types<_Ty>::_TStorage _Storage;
};

template <class _Ty>
struct _Atomic_storage<_Ty, 8> { 

    using _TVal = remove_reference_t<_Ty>;

    _Atomic_storage() = default;

      constexpr _Atomic_storage(conditional_t<is_reference_v<_Ty>, _Ty, const _TVal> _Value) noexcept
        : _Storage{_Value} {
        
    }

    void store(const _TVal _Value) noexcept { 
        const auto _Mem           = _Atomic_address_as<long long>(_Storage);
        const long long _As_bytes = _Atomic_reinterpret_as<long long>(_Value);
        (void) _InterlockedExchange64(((_Mem)), ((_As_bytes))); ;
    }

    void store(const _TVal _Value, const memory_order _Order) noexcept { 
        const auto _Mem           = _Atomic_address_as<long long>(_Storage);
        const long long _As_bytes = _Atomic_reinterpret_as<long long>(_Value);
        switch (static_cast<unsigned int>(_Order)) {
            case _Atomic_memory_order_relaxed: __iso_volatile_store64((_Mem), (_As_bytes)); return; case _Atomic_memory_order_release: __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop)); __iso_volatile_store64((_Mem), (_As_bytes)); return; default: case _Atomic_memory_order_consume: case _Atomic_memory_order_acquire: case _Atomic_memory_order_acq_rel:; [[fallthrough]];
        case _Atomic_memory_order_seq_cst:
            store(_Value);
            return;
        }
    }

    [[nodiscard]] _TVal load() const noexcept { 
        const auto _Mem = _Atomic_address_as<long long>(_Storage);



        long long _As_bytes = __iso_volatile_load64(_Mem);
#line 1106 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"
        __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop)) ;
        return reinterpret_cast<_TVal&>(_As_bytes);
    }

    [[nodiscard]] _TVal load(const memory_order _Order) const noexcept { 
        const auto _Mem = _Atomic_address_as<long long>(_Storage);
        long long _As_bytes;


#line 1116 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"




        _As_bytes = __iso_volatile_load64(_Mem);
#line 1122 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"

        switch (static_cast<unsigned int>(_Order)) { case _Atomic_memory_order_relaxed: break; case _Atomic_memory_order_consume: case _Atomic_memory_order_acquire: case _Atomic_memory_order_seq_cst: __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop)); break; case _Atomic_memory_order_release: case _Atomic_memory_order_acq_rel: default:; break; }
#line 1125 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"
        return reinterpret_cast<_TVal&>(_As_bytes);
    }











    _TVal exchange(const _TVal _Value, const memory_order _Order = memory_order_seq_cst) noexcept {
        
        long long _As_bytes;
        _Check_memory_order(static_cast<unsigned int>(_Order)); _As_bytes = _InterlockedExchange64(_Atomic_address_as<long long>(_Storage), _Atomic_reinterpret_as<long long>(_Value))
;
        return reinterpret_cast<_TVal&>(_As_bytes);
    }
#line 1146 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"

    bool compare_exchange_strong(_TVal& _Expected, const _TVal _Desired,
        const memory_order _Order = memory_order_seq_cst) noexcept { 
        long long _Expected_bytes = _Atomic_reinterpret_as<long long>(_Expected); 
        long long _Prev_bytes;


        if constexpr (_Might_have_non_value_bits<_TVal>) {
            _Storage_for<_TVal> _Mask{_Form_mask};
            const long long _Mask_val = _Atomic_reinterpret_as<long long>(_Mask);

            for (;;) {
                _Check_memory_order(static_cast<unsigned int>(_Order)); _Prev_bytes = _InterlockedCompareExchange64(_Atomic_address_as<long long>(_Storage), _Atomic_reinterpret_as<long long>(_Desired), _Expected_bytes)

;
                if (_Prev_bytes == _Expected_bytes) {
                    return true;
                }

                if ((_Prev_bytes ^ _Expected_bytes) & _Mask_val) {
                    :: memcpy(::std:: addressof(_Expected), &_Prev_bytes, sizeof(_TVal));
                    return false;
                }
                _Expected_bytes = (_Expected_bytes & _Mask_val) | (_Prev_bytes & ~_Mask_val);
            }
        }
#line 1173 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"
        _Check_memory_order(static_cast<unsigned int>(_Order)); _Prev_bytes = _InterlockedCompareExchange64(_Atomic_address_as<long long>(_Storage), _Atomic_reinterpret_as<long long>(_Desired), _Expected_bytes)
;
        if (_Prev_bytes == _Expected_bytes) {
            return true;
        }

        :: memcpy(::std:: addressof(_Expected), &_Prev_bytes, sizeof(_TVal));
        return false;
    }


    void wait(const _TVal _Expected, const memory_order _Order = memory_order_seq_cst) const noexcept {
        _Atomic_wait_direct(this, _Atomic_reinterpret_as<long long>(_Expected), _Order);
    }

    void notify_one() noexcept {
        __std_atomic_notify_one_direct(::std:: addressof(_Storage));
    }

    void notify_all() noexcept {
        __std_atomic_notify_all_direct(::std:: addressof(_Storage));
    }
#line 1196 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"

    typename _Atomic_storage_types<_Ty>::_TStorage _Storage;
};


template <class _Ty>
struct _Atomic_storage<_Ty&, 16> { 
    
    using _TVal = remove_reference_t<_Ty&>;

    _Atomic_storage() = default;

      constexpr _Atomic_storage(conditional_t<is_reference_v<_Ty&>, _Ty&, const _TVal> _Value) noexcept
        : _Storage{_Value} {} 

    void store(const _TVal _Value) noexcept { 
        (void) exchange(_Value);
    }

    void store(const _TVal _Value, const memory_order _Order) noexcept { 
        _Check_store_memory_order(_Order);
        (void) exchange(_Value, _Order);
    }

    [[nodiscard]] _TVal load() const noexcept { 
        long long* const _Storage_ptr = const_cast<long long*>(_Atomic_address_as<const long long>(_Storage));
        _Int128 _Result{}; 
        (void) __std_atomic_compare_exchange_128 (_Storage_ptr, 0, 0, &_Result._Low);
        return reinterpret_cast<_TVal&>(_Result);
    }

    [[nodiscard]] _TVal load(const memory_order _Order) const noexcept { 






















#line 1251 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"
        _Check_load_memory_order(_Order);
        return load();
#line 1254 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"
    }

    _TVal exchange(const _TVal _Value) noexcept { 
        _TVal _Result{_Value};
        while (!compare_exchange_strong(_Result, _Value)) { 
        }

        return _Result;
    }

    _TVal exchange(const _TVal _Value, const memory_order _Order) noexcept { 
        _TVal _Result{_Value};
        while (!compare_exchange_strong(_Result, _Value, _Order)) { 
        }

        return _Result;
    }

    bool compare_exchange_strong(_TVal& _Expected, const _TVal _Desired,
        const memory_order _Order = memory_order_seq_cst) noexcept { 
        _Int128 _Desired_bytes{};
        :: memcpy(&_Desired_bytes, ::std:: addressof(_Desired), sizeof(_TVal));
        _Int128 _Expected_temp{};
        :: memcpy(&_Expected_temp, ::std:: addressof(_Expected), sizeof(_TVal));
        unsigned char _Result;

        if constexpr (_Might_have_non_value_bits<_TVal>) {
            _Int128 _Expected_originally{};
            :: memcpy(&_Expected_originally, ::std:: addressof(_Expected), sizeof(_TVal));

            _Storage_for<_TVal> _Mask{_Form_mask};
            _Int128 _Mask_val{};
            :: memcpy(&_Mask_val, _Mask._Ptr(), sizeof(_TVal));
            for (;;) {




#line 1293 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"
                (void) _Order;
                _Result = __std_atomic_compare_exchange_128 (&reinterpret_cast<long long&>(_Storage), _Desired_bytes._High,
                    _Desired_bytes._Low, &_Expected_temp._Low);
#line 1297 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"
                if (_Result) {
                    return true;
                }

                if (((_Expected_temp._Low ^ _Expected_originally._Low) & _Mask_val._Low) != 0
                    || ((_Expected_temp._High ^ _Expected_originally._High) & _Mask_val._High) != 0) {
                    :: memcpy(::std:: addressof(_Expected), &_Expected_temp, sizeof(_TVal));
                    return false;
                }

                _Expected_temp._Low =
                    (_Expected_originally._Low & _Mask_val._Low) | (_Expected_temp._Low & ~_Mask_val._Low);
                _Expected_temp._High =
                    (_Expected_originally._High & _Mask_val._High) | (_Expected_temp._High & ~_Mask_val._High);
            }
        }
#line 1314 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"



#line 1318 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"
        (void) _Order;
        _Result = __std_atomic_compare_exchange_128 (
            &reinterpret_cast<long long&>(_Storage), _Desired_bytes._High, _Desired_bytes._Low, &_Expected_temp._Low);
#line 1322 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"
        if (_Result == 0) {
            :: memcpy(::std:: addressof(_Expected), &_Expected_temp, sizeof(_TVal));
        }

        return _Result != 0;
    }


    void wait(_TVal _Expected, memory_order _Order = memory_order_seq_cst) const noexcept {
        const auto _Storage_ptr  = ::std:: addressof(_Storage);
        const auto _Expected_ptr = ::std:: addressof(_Expected);
        _Int128 _Expected_bytes  = reinterpret_cast<const _Int128&>(_Expected);

        for (;;) {
            const _TVal _Observed   = load(_Order);
            _Int128 _Observed_bytes = reinterpret_cast<const _Int128&>(_Observed);
            if (_Observed_bytes._Low != _Expected_bytes._Low || _Observed_bytes._High != _Expected_bytes._High) {

                if constexpr (_Might_have_non_value_bits<_TVal>) {
                    _Storage_for<_TVal> _Mask{_Form_mask};
                    const _Int128 _Mask_val = reinterpret_cast<const _Int128&>(_Mask._Ref());

                    if (((_Expected_bytes._Low ^ _Observed_bytes._Low) & _Mask_val._Low) == 0
                        && ((_Expected_bytes._High ^ _Observed_bytes._High) & _Mask_val._High) == 0) {
                        _Expected_bytes = _Observed_bytes;
                        continue;
                    }
                }
#line 1351 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"

                return;
            }

            __std_atomic_wait_indirect(_Storage_ptr, _Expected_ptr, sizeof(_TVal), nullptr,
                &_Atomic_wait_compare_16_bytes, _Atomic_wait_no_timeout);
        }
    }

    void notify_one() noexcept {
        __std_atomic_notify_one_indirect(::std:: addressof(_Storage));
    }

    void notify_all() noexcept {
        __std_atomic_notify_all_indirect(::std:: addressof(_Storage));
    }
#line 1368 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"

    struct _Int128 {
        alignas(16) long long _Low;
        long long _High;
    };

    typename _Atomic_storage_types<_Ty&>::_TStorage _Storage;
};
#line 1377 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"

template <class _Ty, size_t = sizeof(_Ty)>
struct _Atomic_integral; 

template <class _Ty>
struct _Atomic_integral<_Ty, 1> : _Atomic_storage<_Ty> { 
    using _Base = _Atomic_storage<_Ty>;
    using typename _Base::_TVal;

    using _Base::_Base;

    _TVal fetch_add(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        char _Result;
        _Check_memory_order(static_cast<unsigned int>(_Order)); _Result = _InterlockedExchangeAdd8(_Atomic_address_as<char>(this->_Storage), static_cast<char>(_Operand))
;
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_and(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        char _Result;
        _Check_memory_order(static_cast<unsigned int>(_Order)); _Result = _InterlockedAnd8(_Atomic_address_as<char>(this->_Storage), static_cast<char>(_Operand))
;
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_or(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        char _Result;
        _Check_memory_order(static_cast<unsigned int>(_Order)); _Result = _InterlockedOr8(_Atomic_address_as<char>(this->_Storage), static_cast<char>(_Operand))
;
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_xor(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        char _Result;
        _Check_memory_order(static_cast<unsigned int>(_Order)); _Result = _InterlockedXor8(_Atomic_address_as<char>(this->_Storage), static_cast<char>(_Operand))
;
        return static_cast<_TVal>(_Result);
    }

    _TVal operator++(int) noexcept {
        return static_cast<_TVal>(_InterlockedExchangeAdd8(_Atomic_address_as<char>(this->_Storage), 1));
    }

    _TVal operator++() noexcept {
        unsigned char _Before =
            static_cast<unsigned char>(_InterlockedExchangeAdd8(_Atomic_address_as<char>(this->_Storage), 1));
        ++_Before;
        return static_cast<_TVal>(_Before);
    }

    _TVal operator--(int) noexcept {
        return static_cast<_TVal>(_InterlockedExchangeAdd8(_Atomic_address_as<char>(this->_Storage), -1));
    }

    _TVal operator--() noexcept {
        unsigned char _Before =
            static_cast<unsigned char>(_InterlockedExchangeAdd8(_Atomic_address_as<char>(this->_Storage), -1));
        --_Before;
        return static_cast<_TVal>(_Before);
    }
};

template <class _Ty>
struct _Atomic_integral<_Ty, 2> : _Atomic_storage<_Ty> { 
    using _Base = _Atomic_storage<_Ty>;
    using typename _Base::_TVal;

    using _Base::_Base;

    _TVal fetch_add(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        short _Result;
        _Check_memory_order(static_cast<unsigned int>(_Order)); _Result = _InterlockedExchangeAdd16(_Atomic_address_as<short>(this->_Storage), static_cast<short>(_Operand))
;
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_and(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        short _Result;
        _Check_memory_order(static_cast<unsigned int>(_Order)); _Result = _InterlockedAnd16(_Atomic_address_as<short>(this->_Storage), static_cast<short>(_Operand))
;
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_or(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        short _Result;
        _Check_memory_order(static_cast<unsigned int>(_Order)); _Result = _InterlockedOr16(_Atomic_address_as<short>(this->_Storage), static_cast<short>(_Operand))
;
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_xor(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        short _Result;
        _Check_memory_order(static_cast<unsigned int>(_Order)); _Result = _InterlockedXor16(_Atomic_address_as<short>(this->_Storage), static_cast<short>(_Operand))
;
        return static_cast<_TVal>(_Result);
    }

    _TVal operator++(int) noexcept {
        unsigned short _After =
            static_cast<unsigned short>(_InterlockedIncrement16(_Atomic_address_as<short>(this->_Storage)));
        --_After;
        return static_cast<_TVal>(_After);
    }

    _TVal operator++() noexcept {
        return static_cast<_TVal>(_InterlockedIncrement16(_Atomic_address_as<short>(this->_Storage)));
    }

    _TVal operator--(int) noexcept {
        unsigned short _After =
            static_cast<unsigned short>(_InterlockedDecrement16(_Atomic_address_as<short>(this->_Storage)));
        ++_After;
        return static_cast<_TVal>(_After);
    }

    _TVal operator--() noexcept {
        return static_cast<_TVal>(_InterlockedDecrement16(_Atomic_address_as<short>(this->_Storage)));
    }
};

template <class _Ty>
struct _Atomic_integral<_Ty, 4> : _Atomic_storage<_Ty> { 
    using _Base = _Atomic_storage<_Ty>;
    using typename _Base::_TVal;

    using _Base::_Base;

    _TVal fetch_add(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        long _Result;
        _Check_memory_order(static_cast<unsigned int>(_Order)); _Result = _InterlockedExchangeAdd(_Atomic_address_as<long>(this->_Storage), static_cast<long>(_Operand))
;
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_and(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        long _Result;
        _Check_memory_order(static_cast<unsigned int>(_Order)); _Result = _InterlockedAnd(_Atomic_address_as<long>(this->_Storage), static_cast<long>(_Operand))
;
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_or(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        long _Result;
        _Check_memory_order(static_cast<unsigned int>(_Order)); _Result = _InterlockedOr(_Atomic_address_as<long>(this->_Storage), static_cast<long>(_Operand))
;
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_xor(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        long _Result;
        _Check_memory_order(static_cast<unsigned int>(_Order)); _Result = _InterlockedXor(_Atomic_address_as<long>(this->_Storage), static_cast<long>(_Operand))
;
        return static_cast<_TVal>(_Result);
    }

    _TVal operator++(int) noexcept {
        unsigned long _After =
            static_cast<unsigned long>(_InterlockedIncrement(_Atomic_address_as<long>(this->_Storage)));
        --_After;
        return static_cast<_TVal>(_After);
    }

    _TVal operator++() noexcept {
        return static_cast<_TVal>(_InterlockedIncrement(_Atomic_address_as<long>(this->_Storage)));
    }

    _TVal operator--(int) noexcept {
        unsigned long _After =
            static_cast<unsigned long>(_InterlockedDecrement(_Atomic_address_as<long>(this->_Storage)));
        ++_After;
        return static_cast<_TVal>(_After);
    }

    _TVal operator--() noexcept {
        return static_cast<_TVal>(_InterlockedDecrement(_Atomic_address_as<long>(this->_Storage)));
    }
};

template <class _Ty>
struct _Atomic_integral<_Ty, 8> : _Atomic_storage<_Ty> { 
    using _Base = _Atomic_storage<_Ty>;
    using typename _Base::_TVal;

    using _Base::_Base;























































    _TVal fetch_add(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        long long _Result;
        _Check_memory_order(static_cast<unsigned int>(_Order)); _Result = _InterlockedExchangeAdd64(_Atomic_address_as<long long>(this->_Storage), static_cast<long long>(_Operand))
;
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_and(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        long long _Result;
        _Check_memory_order(static_cast<unsigned int>(_Order)); _Result = _InterlockedAnd64(_Atomic_address_as<long long>(this->_Storage), static_cast<long long>(_Operand))
;
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_or(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        long long _Result;
        _Check_memory_order(static_cast<unsigned int>(_Order)); _Result = _InterlockedOr64(_Atomic_address_as<long long>(this->_Storage), static_cast<long long>(_Operand))
;
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_xor(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        long long _Result;
        _Check_memory_order(static_cast<unsigned int>(_Order)); _Result = _InterlockedXor64(_Atomic_address_as<long long>(this->_Storage), static_cast<long long>(_Operand))
;
        return static_cast<_TVal>(_Result);
    }

    _TVal operator++(int) noexcept {
        unsigned long long _After =
            static_cast<unsigned long long>(_InterlockedIncrement64(_Atomic_address_as<long long>(this->_Storage)));
        --_After;
        return static_cast<_TVal>(_After);
    }

    _TVal operator++() noexcept {
        return static_cast<_TVal>(_InterlockedIncrement64(_Atomic_address_as<long long>(this->_Storage)));
    }

    _TVal operator--(int) noexcept {
        unsigned long long _After =
            static_cast<unsigned long long>(_InterlockedDecrement64(_Atomic_address_as<long long>(this->_Storage)));
        ++_After;
        return static_cast<_TVal>(_After);
    }

    _TVal operator--() noexcept {
        return static_cast<_TVal>(_InterlockedDecrement64(_Atomic_address_as<long long>(this->_Storage)));
    }
#line 1666 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"
};


template <size_t _TypeSize>
inline constexpr bool _Is_always_lock_free = _TypeSize <= 8 && (_TypeSize & (_TypeSize - 1)) == 0;








#line 1680 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"

template <class _Ty, bool _Is_lock_free = _Is_always_lock_free<sizeof(_Ty)>>
inline constexpr bool _Deprecate_non_lock_free_volatile = true;

template <class _Ty>
[[deprecated("warning STL4030: " "Some operations on volatile-qualified types in the STL are deprecated in C++20. " "You can define _SILENCE_CXX20_VOLATILE_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] inline constexpr bool _Deprecate_non_lock_free_volatile<_Ty, false> = true;

template <class _Ty>
struct _Atomic_integral_facade : _Atomic_integral<_Ty> {
    
    using _Base           = _Atomic_integral<_Ty>;
    using difference_type = _Ty;

    using _Base::_Base;

    

    
    
    
    using _Base::fetch_add;
    _Ty fetch_add(const _Ty _Operand) volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_add(_Operand);
    }

    _Ty fetch_add(const _Ty _Operand, const memory_order _Order) volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_add(_Operand, _Order);
    }

    [[nodiscard]] static _Ty _Negate(const _Ty _Value) noexcept { 
        return static_cast<_Ty>(0U - static_cast<make_unsigned_t<_Ty>>(_Value));
    }

    _Ty fetch_sub(const _Ty _Operand) noexcept {
        return fetch_add(_Negate(_Operand));
    }

    _Ty fetch_sub(const _Ty _Operand) volatile noexcept {
        return fetch_add(_Negate(_Operand));
    }

    _Ty fetch_sub(const _Ty _Operand, const memory_order _Order) noexcept {
        return fetch_add(_Negate(_Operand), _Order);
    }

    _Ty fetch_sub(const _Ty _Operand, const memory_order _Order) volatile noexcept {
        return fetch_add(_Negate(_Operand), _Order);
    }

    using _Base::fetch_and;
    _Ty fetch_and(const _Ty _Operand) volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_and(_Operand);
    }

    _Ty fetch_and(const _Ty _Operand, const memory_order _Order) volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_and(_Operand, _Order);
    }

    using _Base::fetch_or;
    _Ty fetch_or(const _Ty _Operand) volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_or(_Operand);
    }

    _Ty fetch_or(const _Ty _Operand, const memory_order _Order) volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_or(_Operand, _Order);
    }

    using _Base::fetch_xor;
    _Ty fetch_xor(const _Ty _Operand) volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_xor(_Operand);
    }

    _Ty fetch_xor(const _Ty _Operand, const memory_order _Order) volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_xor(_Operand, _Order);
    }

    using _Base::operator++;
    _Ty operator++(int) volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::operator++(0);
    }

    _Ty operator++() volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::operator++();
    }

    using _Base::operator--;
    _Ty operator--(int) volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::operator--(0);
    }

    _Ty operator--() volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::operator--();
    }

    _Ty operator+=(const _Ty _Operand) noexcept {
        return static_cast<_Ty>(this->_Base::fetch_add(_Operand) + _Operand);
    }

    _Ty operator+=(const _Ty _Operand) volatile noexcept {
        return static_cast<_Ty>(const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_add(_Operand) + _Operand);
    }

    _Ty operator-=(const _Ty _Operand) noexcept {
        return static_cast<_Ty>(fetch_sub(_Operand) - _Operand);
    }

    _Ty operator-=(const _Ty _Operand) volatile noexcept {
        return static_cast<_Ty>(const_cast<_Atomic_integral_facade*>(this)->fetch_sub(_Operand) - _Operand);
    }

    _Ty operator&=(const _Ty _Operand) noexcept {
        return static_cast<_Ty>(this->_Base::fetch_and(_Operand) & _Operand);
    }

    _Ty operator&=(const _Ty _Operand) volatile noexcept {
        return static_cast<_Ty>(const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_and(_Operand) & _Operand);
    }

    _Ty operator|=(const _Ty _Operand) noexcept {
        return static_cast<_Ty>(this->_Base::fetch_or(_Operand) | _Operand);
    }

    _Ty operator|=(const _Ty _Operand) volatile noexcept {
        return static_cast<_Ty>(const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_or(_Operand) | _Operand);
    }

    _Ty operator^=(const _Ty _Operand) noexcept {
        return static_cast<_Ty>(this->_Base::fetch_xor(_Operand) ^ _Operand);
    }

    _Ty operator^=(const _Ty _Operand) volatile noexcept {
        return static_cast<_Ty>(const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_xor(_Operand) ^ _Operand);
    }
};

template <class _Ty>
struct _Atomic_integral_facade<_Ty&> : _Atomic_integral<_Ty&> {
    
    using _Base           = _Atomic_integral<_Ty&>;
    using difference_type = _Ty;

    using _Base::_Base;

    [[nodiscard]] static _Ty _Negate(const _Ty _Value) noexcept { 
        return static_cast<_Ty>(0U - static_cast<make_unsigned_t<_Ty>>(_Value));
    }

    _Ty fetch_add(const _Ty _Operand) const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_add(_Operand);
    }

    _Ty fetch_add(const _Ty _Operand, const memory_order _Order) const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_add(_Operand, _Order);
    }

    _Ty fetch_sub(const _Ty _Operand) const noexcept {
        return fetch_add(_Negate(_Operand));
    }

    _Ty fetch_sub(const _Ty _Operand, const memory_order _Order) const noexcept {
        return fetch_add(_Negate(_Operand), _Order);
    }

    _Ty operator++(int) const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::operator++(0);
    }

    _Ty operator++() const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::operator++();
    }

    _Ty operator--(int) const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::operator--(0);
    }

    _Ty operator--() const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::operator--();
    }

    _Ty operator+=(const _Ty _Operand) const noexcept {
        return static_cast<_Ty>(fetch_add(_Operand) + _Operand);
    }

    _Ty operator-=(const _Ty _Operand) const noexcept {
        return static_cast<_Ty>(fetch_sub(_Operand) - _Operand);
    }

    _Ty fetch_and(const _Ty _Operand) const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_and(_Operand);
    }

    _Ty fetch_and(const _Ty _Operand, const memory_order _Order) const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_and(_Operand, _Order);
    }

    _Ty fetch_or(const _Ty _Operand) const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_or(_Operand);
    }

    _Ty fetch_or(const _Ty _Operand, const memory_order _Order) const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_or(_Operand, _Order);
    }

    _Ty fetch_xor(const _Ty _Operand) const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_xor(_Operand);
    }

    _Ty fetch_xor(const _Ty _Operand, const memory_order _Order) const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_xor(_Operand, _Order);
    }

    _Ty operator&=(const _Ty _Operand) const noexcept {
        return static_cast<_Ty>(fetch_and(_Operand) & _Operand);
    }

    _Ty operator|=(const _Ty _Operand) const noexcept {
        return static_cast<_Ty>(fetch_or(_Operand) | _Operand);
    }

    _Ty operator^=(const _Ty _Operand) const noexcept {
        return static_cast<_Ty>(fetch_xor(_Operand) ^ _Operand);
    }
};


template <class _Ty>
struct _Atomic_floating : _Atomic_storage<_Ty> {
    
    using _Base           = _Atomic_storage<_Ty>;
    using difference_type = _Ty;

    using _Base::_Base;

    _Ty fetch_add(const _Ty _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        _Ty _Temp{this->load(memory_order_relaxed)};
        while (!this->compare_exchange_strong(_Temp, _Temp + _Operand, _Order)) { 
        }

        return _Temp;
    }

    

    
    
    
    _Ty fetch_add(const _Ty _Operand, const memory_order _Order = memory_order_seq_cst) volatile noexcept {
        return const_cast<_Atomic_floating*>(this)->fetch_add(_Operand, _Order);
    }

    _Ty fetch_sub(const _Ty _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        _Ty _Temp{this->load(memory_order_relaxed)};
        while (!this->compare_exchange_strong(_Temp, _Temp - _Operand, _Order)) { 
        }

        return _Temp;
    }

    _Ty fetch_sub(const _Ty _Operand, const memory_order _Order = memory_order_seq_cst) volatile noexcept {
        return const_cast<_Atomic_floating*>(this)->fetch_sub(_Operand, _Order);
    }

    _Ty operator+=(const _Ty _Operand) noexcept {
        return fetch_add(_Operand) + _Operand;
    }

    _Ty operator+=(const _Ty _Operand) volatile noexcept {
        return const_cast<_Atomic_floating*>(this)->fetch_add(_Operand) + _Operand;
    }

    _Ty operator-=(const _Ty _Operand) noexcept {
        return fetch_sub(_Operand) - _Operand;
    }

    _Ty operator-=(const _Ty _Operand) volatile noexcept {
        return const_cast<_Atomic_floating*>(this)->fetch_sub(_Operand) - _Operand;
    }
};

template <class _Ty>
struct _Atomic_floating<_Ty&> : _Atomic_storage<_Ty&> {
    
    using _Base           = _Atomic_storage<_Ty&>;
    using difference_type = _Ty;

    using _Base::_Base;

    _Ty fetch_add(const _Ty _Operand, const memory_order _Order = memory_order_seq_cst) const noexcept {
        _Ty _Temp{this->load(memory_order_relaxed)};
        while (!const_cast<_Atomic_floating*>(this)->_Base::compare_exchange_strong(
            _Temp, _Temp + _Operand, _Order)) { 
        }

        return _Temp;
    }

    _Ty fetch_sub(const _Ty _Operand, const memory_order _Order = memory_order_seq_cst) const noexcept {
        _Ty _Temp{this->load(memory_order_relaxed)};
        while (!const_cast<_Atomic_floating*>(this)->_Base::compare_exchange_strong(
            _Temp, _Temp - _Operand, _Order)) { 
        }

        return _Temp;
    }

    _Ty operator+=(const _Ty _Operand) const noexcept {
        return fetch_add(_Operand) + _Operand;
    }

    _Ty operator-=(const _Ty _Operand) const noexcept {
        return fetch_sub(_Operand) - _Operand;
    }
};
#line 1994 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"

template <class _Ty>
struct _Atomic_pointer : _Atomic_storage<_Ty> {
    using _Base           = _Atomic_storage<_Ty>;
    using difference_type = ptrdiff_t;

    using _Base::_Base;

    _Ty fetch_add(const ptrdiff_t _Diff, const memory_order _Order = memory_order_seq_cst) noexcept {
        const ptrdiff_t _Shift_bytes =
            static_cast<ptrdiff_t>(static_cast<size_t>(_Diff) * sizeof(remove_pointer_t<_Ty>));
        ptrdiff_t _Result;



#line 2010 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"
        _Check_memory_order(static_cast<unsigned int>(_Order)); _Result = _InterlockedExchangeAdd64(_Atomic_address_as<long long>(this->_Storage), _Shift_bytes)
;
#line 2013 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"
        return reinterpret_cast<_Ty>(_Result);
    }

    

    _Ty fetch_add(const ptrdiff_t _Diff) volatile noexcept {
        return const_cast<_Atomic_pointer*>(this)->fetch_add(_Diff);
    }

    _Ty fetch_add(const ptrdiff_t _Diff, const memory_order _Order) volatile noexcept {
        return const_cast<_Atomic_pointer*>(this)->fetch_add(_Diff, _Order);
    }

    _Ty fetch_sub(const ptrdiff_t _Diff) volatile noexcept {
        return fetch_add(static_cast<ptrdiff_t>(0 - static_cast<size_t>(_Diff)));
    }

    _Ty fetch_sub(const ptrdiff_t _Diff) noexcept {
        return fetch_add(static_cast<ptrdiff_t>(0 - static_cast<size_t>(_Diff)));
    }

    _Ty fetch_sub(const ptrdiff_t _Diff, const memory_order _Order) volatile noexcept {
        return fetch_add(static_cast<ptrdiff_t>(0 - static_cast<size_t>(_Diff)), _Order);
    }

    _Ty fetch_sub(const ptrdiff_t _Diff, const memory_order _Order) noexcept {
        return fetch_add(static_cast<ptrdiff_t>(0 - static_cast<size_t>(_Diff)), _Order);
    }

    _Ty operator++(int) volatile noexcept {
        return fetch_add(1);
    }

    _Ty operator++(int) noexcept {
        return fetch_add(1);
    }

    _Ty operator++() volatile noexcept {
        return fetch_add(1) + 1;
    }

    _Ty operator++() noexcept {
        return fetch_add(1) + 1;
    }

    _Ty operator--(int) volatile noexcept {
        return fetch_add(-1);
    }

    _Ty operator--(int) noexcept {
        return fetch_add(-1);
    }

    _Ty operator--() volatile noexcept {
        return fetch_add(-1) - 1;
    }

    _Ty operator--() noexcept {
        return fetch_add(-1) - 1;
    }

    _Ty operator+=(const ptrdiff_t _Diff) volatile noexcept {
        return fetch_add(_Diff) + _Diff;
    }

    _Ty operator+=(const ptrdiff_t _Diff) noexcept {
        return fetch_add(_Diff) + _Diff;
    }

    _Ty operator-=(const ptrdiff_t _Diff) volatile noexcept {
        return fetch_add(static_cast<ptrdiff_t>(0 - static_cast<size_t>(_Diff))) - _Diff;
    }

    _Ty operator-=(const ptrdiff_t _Diff) noexcept {
        return fetch_add(static_cast<ptrdiff_t>(0 - static_cast<size_t>(_Diff))) - _Diff;
    }
};


template <class _Ty>
struct _Atomic_pointer<_Ty&> : _Atomic_storage<_Ty&> {
    using _Base           = _Atomic_storage<_Ty&>;
    using difference_type = ptrdiff_t;

    using _Base::_Base;

    _Ty fetch_add(const ptrdiff_t _Diff, const memory_order _Order = memory_order_seq_cst) const noexcept {
        const ptrdiff_t _Shift_bytes =
            static_cast<ptrdiff_t>(static_cast<size_t>(_Diff) * sizeof(remove_pointer_t<_Ty>));
        ptrdiff_t _Result;



#line 2107 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"
        _Check_memory_order(static_cast<unsigned int>(_Order)); _Result = _InterlockedExchangeAdd64(_Atomic_address_as<long long>(this->_Storage), _Shift_bytes)
;
#line 2110 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"
        return reinterpret_cast<_Ty>(_Result);
    }

    _Ty fetch_sub(const ptrdiff_t _Diff) const noexcept {
        return fetch_add(static_cast<ptrdiff_t>(0 - static_cast<size_t>(_Diff)));
    }

    _Ty fetch_sub(const ptrdiff_t _Diff, const memory_order _Order) const noexcept {
        return fetch_add(static_cast<ptrdiff_t>(0 - static_cast<size_t>(_Diff)), _Order);
    }

    _Ty operator++(int) const noexcept {
        return fetch_add(1);
    }

    _Ty operator++() const noexcept {
        return fetch_add(1) + 1;
    }

    _Ty operator--(int) const noexcept {
        return fetch_add(-1);
    }

    _Ty operator--() const noexcept {
        return fetch_add(-1) - 1;
    }

    _Ty operator+=(const ptrdiff_t _Diff) const noexcept {
        return fetch_add(_Diff) + _Diff;
    }

    _Ty operator-=(const ptrdiff_t _Diff) const noexcept {
        return fetch_add(static_cast<ptrdiff_t>(0 - static_cast<size_t>(_Diff))) - _Diff;
    }
};





template <class _TVal, class _Ty = _TVal>
using _Choose_atomic_base2_t =
    typename _Select<is_integral_v<_TVal> && !is_same_v<bool, _TVal>>::template _Apply<_Atomic_integral_facade<_Ty>,
        typename _Select<is_pointer_v<_TVal> && is_object_v<remove_pointer_t<_TVal>>>::template _Apply<
            _Atomic_pointer<_Ty>, _Atomic_storage<_Ty>>>;


template <class _TVal, class _Ty = _TVal>
using _Choose_atomic_base_t = typename _Select<is_floating_point_v<_TVal>>::template _Apply<_Atomic_floating<_Ty>,
    _Choose_atomic_base2_t<_TVal, _Ty>>;



#line 2164 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"

 template <class _Ty>
struct atomic : _Choose_atomic_base_t<_Ty> { 
private:
    using _Base = _Choose_atomic_base_t<_Ty>;

public:
    static_assert(is_trivially_copyable_v<_Ty> && is_copy_constructible_v<_Ty> && is_move_constructible_v<_Ty>
                      && is_copy_assignable_v<_Ty> && is_move_assignable_v<_Ty>,
        "atomic<T> requires T to be trivially copyable, copy constructible, move constructible, copy assignable, "
        "and move assignable.");

    using value_type = _Ty;

    using _Base::_Base;

    constexpr atomic() noexcept(is_nothrow_default_constructible_v<_Ty>) : _Base() {}

    atomic(const atomic&)            = delete;
    atomic& operator=(const atomic&) = delete;


    static constexpr bool is_always_lock_free = _Is_always_lock_free<sizeof(_Ty)>;
#line 2188 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"


    [[nodiscard]] bool is_lock_free() const volatile noexcept {
        constexpr bool _Result = sizeof(_Ty) <= 8 && (sizeof(_Ty) & sizeof(_Ty) - 1) == 0;
        return _Result;
    }










#line 2205 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"

    [[nodiscard]] bool is_lock_free() const noexcept {
        return static_cast<const volatile atomic*>(this)->is_lock_free();
    }

    _Ty operator=(const _Ty _Value) volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        this->store(_Value);
        return _Value;
    }

    _Ty operator=(const _Ty _Value) noexcept {
        this->store(_Value);
        return _Value;
    }

    
    
    
    
    
    using _Base::store;
    void store(const _Ty _Value) volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        const_cast<atomic*>(this)->_Base::store(_Value);
    }

    void store(const _Ty _Value, const memory_order _Order) volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        const_cast<atomic*>(this)->_Base::store(_Value, _Order);
    }

    using _Base::load;
    [[nodiscard]] _Ty load() const volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        return const_cast<const atomic*>(this)->_Base::load();
    }

    [[nodiscard]] _Ty load(const memory_order _Order) const volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        return const_cast<const atomic*>(this)->_Base::load(_Order);
    }

    using _Base::exchange;
    _Ty exchange(const _Ty _Value) volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        return const_cast<atomic*>(this)->_Base::exchange(_Value);
    }

    _Ty exchange(const _Ty _Value, const memory_order _Order) volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        return const_cast<atomic*>(this)->_Base::exchange(_Value, _Order);
    }

    using _Base::compare_exchange_strong;
    bool compare_exchange_strong(_Ty& _Expected, const _Ty _Desired) volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        return const_cast<atomic*>(this)->_Base::compare_exchange_strong(_Expected, _Desired);
    }

    bool compare_exchange_strong(_Ty& _Expected, const _Ty _Desired, const memory_order _Order) volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        return const_cast<atomic*>(this)->_Base::compare_exchange_strong(_Expected, _Desired, _Order);
    }

    bool compare_exchange_strong(_Ty& _Expected, const _Ty _Desired, const memory_order _Success,
        const memory_order _Failure) volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        return this->compare_exchange_strong(_Expected, _Desired, _Combine_cas_memory_orders(_Success, _Failure));
    }

    bool compare_exchange_strong(
        _Ty& _Expected, const _Ty _Desired, const memory_order _Success, const memory_order _Failure) noexcept {
        return this->compare_exchange_strong(_Expected, _Desired, _Combine_cas_memory_orders(_Success, _Failure));
    }

    bool compare_exchange_weak(_Ty& _Expected, const _Ty _Desired) volatile noexcept {
        
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        return this->compare_exchange_strong(_Expected, _Desired);
    }

    bool compare_exchange_weak(_Ty& _Expected, const _Ty _Desired) noexcept {
        return this->compare_exchange_strong(_Expected, _Desired);
    }

    bool compare_exchange_weak(_Ty& _Expected, const _Ty _Desired, const memory_order _Order) volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        return this->compare_exchange_strong(_Expected, _Desired, _Order);
    }

    bool compare_exchange_weak(_Ty& _Expected, const _Ty _Desired, const memory_order _Order) noexcept {
        return this->compare_exchange_strong(_Expected, _Desired, _Order);
    }

    bool compare_exchange_weak(_Ty& _Expected, const _Ty _Desired, const memory_order _Success,
        const memory_order _Failure) volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        return this->compare_exchange_strong(_Expected, _Desired, _Combine_cas_memory_orders(_Success, _Failure));
    }

    bool compare_exchange_weak(
        _Ty& _Expected, const _Ty _Desired, const memory_order _Success, const memory_order _Failure) noexcept {
        return this->compare_exchange_strong(_Expected, _Desired, _Combine_cas_memory_orders(_Success, _Failure));
    }


    using _Base::wait;
    void wait(const _Ty _Expected, const memory_order _Order = memory_order_seq_cst) const volatile noexcept {
        const_cast<const atomic*>(this)->_Base::wait(_Expected, _Order);
    }

    using _Base::notify_one;
    void notify_one() volatile noexcept {
        const_cast<atomic*>(this)->_Base::notify_one();
    }

    using _Base::notify_all;
    void notify_all() volatile noexcept {
        const_cast<atomic*>(this)->_Base::notify_all();
    }
#line 2327 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"

    operator _Ty() const volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        return this->load();
    }

    operator _Ty() const noexcept {
        return this->load();
    }
};


template <class _Ty>
atomic(_Ty) -> atomic<_Ty>;
#line 2342 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"


 template <class _Ty>
struct atomic_ref : _Choose_atomic_base_t<_Ty, _Ty&> { 
private:
    using _Base = _Choose_atomic_base_t<_Ty, _Ty&>;

public:
    static_assert(is_trivially_copyable_v<_Ty>, "atomic_ref<T> requires T to be trivially copyable.");

    using value_type = _Ty;

    explicit atomic_ref(_Ty& _Value) noexcept   : _Base(_Value) {
        if constexpr (_Is_potentially_lock_free) {
            _Check_alignment(_Value);
        } else {
            this->_Init_spinlock_for_ref();
        }
    }

    atomic_ref(const atomic_ref&) noexcept = default;

    atomic_ref& operator=(const atomic_ref&) = delete;

    static constexpr bool is_always_lock_free = _Is_always_lock_free<sizeof(_Ty)>;

    static constexpr bool _Is_potentially_lock_free =
        sizeof(_Ty) <= 2 * sizeof(void*) && (sizeof(_Ty) & (sizeof(_Ty) - 1)) == 0;

    static constexpr size_t required_alignment = _Is_potentially_lock_free ? sizeof(_Ty) : alignof(_Ty);

    [[nodiscard]] bool is_lock_free() const noexcept {


#line 2377 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"
        if constexpr (is_always_lock_free) {
            return true;
        } else {
            return __std_atomic_has_cmpxchg16b() != 0;
        }
#line 2383 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"
    }

    void store(const _Ty _Value) const noexcept {
        const_cast<atomic_ref*>(this)->_Base::store(_Value);
    }

    void store(const _Ty _Value, const memory_order _Order) const noexcept {
        const_cast<atomic_ref*>(this)->_Base::store(_Value, _Order);
    }

    _Ty operator=(const _Ty _Value) const noexcept {
        store(_Value);
        return _Value;
    }

    _Ty exchange(const _Ty _Value) const noexcept {
        return const_cast<atomic_ref*>(this)->_Base::exchange(_Value);
    }

    _Ty exchange(const _Ty _Value, const memory_order _Order) const noexcept {
        return const_cast<atomic_ref*>(this)->_Base::exchange(_Value, _Order);
    }

    bool compare_exchange_strong(_Ty& _Expected, const _Ty _Desired) const noexcept {
        return const_cast<atomic_ref*>(this)->_Base::compare_exchange_strong(_Expected, _Desired);
    }

    bool compare_exchange_strong(_Ty& _Expected, const _Ty _Desired, const memory_order _Order) const noexcept {
        return const_cast<atomic_ref*>(this)->_Base::compare_exchange_strong(_Expected, _Desired, _Order);
    }

    bool compare_exchange_strong(
        _Ty& _Expected, const _Ty _Desired, const memory_order _Success, const memory_order _Failure) const noexcept {
        return compare_exchange_strong(_Expected, _Desired, _Combine_cas_memory_orders(_Success, _Failure));
    }

    bool compare_exchange_weak(_Ty& _Expected, const _Ty _Desired) const noexcept {
        return compare_exchange_strong(_Expected, _Desired);
    }

    bool compare_exchange_weak(_Ty& _Expected, const _Ty _Desired, const memory_order _Order) const noexcept {
        return compare_exchange_strong(_Expected, _Desired, _Order);
    }

    bool compare_exchange_weak(
        _Ty& _Expected, const _Ty _Desired, const memory_order _Success, const memory_order _Failure) const noexcept {
        return compare_exchange_strong(_Expected, _Desired, _Combine_cas_memory_orders(_Success, _Failure));
    }

    operator _Ty() const noexcept {
        return this->load();
    }

    void notify_one() const noexcept {
        const_cast<atomic_ref*>(this)->_Base::notify_one();
    }

    void notify_all() const noexcept {
        const_cast<atomic_ref*>(this)->_Base::notify_all();
    }

private:
    static void _Check_alignment([[maybe_unused]] const _Ty& _Value) {
        

;
    }
};
#line 2452 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"

 template <class _Ty>
[[nodiscard]] bool atomic_is_lock_free(const volatile atomic<_Ty>* _Mem) noexcept {
    return _Mem->is_lock_free();
}

 template <class _Ty>
[[nodiscard]] bool atomic_is_lock_free(const atomic<_Ty>* _Mem) noexcept {
    return _Mem->is_lock_free();
}

 template <class _Ty>
void atomic_store(volatile atomic<_Ty>* const _Mem, const _Identity_t<_Ty> _Value) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    _Mem->store(_Value);
}

 template <class _Ty>
void atomic_store(atomic<_Ty>* const _Mem, const _Identity_t<_Ty> _Value) noexcept {
    _Mem->store(_Value);
}

 template <class _Ty>
void atomic_store_explicit(
    volatile atomic<_Ty>* const _Mem, const _Identity_t<_Ty> _Value, const memory_order _Order) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    _Mem->store(_Value, _Order);
}

 template <class _Ty>
void atomic_store_explicit(atomic<_Ty>* const _Mem, const _Identity_t<_Ty> _Value, const memory_order _Order) noexcept {
    _Mem->store(_Value, _Order);
}

 template <class _Ty>
[[deprecated("warning STL4028: " "std::atomic_init() overloads are deprecated in C++20. " "The constructors of std::atomic provide equivalent functionality. " "You can define _SILENCE_CXX20_ATOMIC_INIT_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] void atomic_init(
    volatile atomic<_Ty>* const _Mem, const typename atomic<_Ty>::value_type _Value) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    ::std:: atomic_store_explicit(_Mem, _Value, memory_order_relaxed);
}

 template <class _Ty>
[[deprecated("warning STL4028: " "std::atomic_init() overloads are deprecated in C++20. " "The constructors of std::atomic provide equivalent functionality. " "You can define _SILENCE_CXX20_ATOMIC_INIT_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] void atomic_init(
    atomic<_Ty>* const _Mem, const typename atomic<_Ty>::value_type _Value) noexcept {
    ::std:: atomic_store_explicit(_Mem, _Value, memory_order_relaxed);
}

 template <class _Ty>
[[nodiscard]] _Ty atomic_load(const volatile atomic<_Ty>* const _Mem) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->load();
}

 template <class _Ty>
[[nodiscard]] _Ty atomic_load(const atomic<_Ty>* const _Mem) noexcept {
    return _Mem->load();
}

 template <class _Ty>
[[nodiscard]] _Ty atomic_load_explicit(const volatile atomic<_Ty>* const _Mem, const memory_order _Order) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->load(_Order);
}

 template <class _Ty>
[[nodiscard]] _Ty atomic_load_explicit(const atomic<_Ty>* const _Mem, const memory_order _Order) noexcept {
    return _Mem->load(_Order);
}

 template <class _Ty>
_Ty atomic_exchange(volatile atomic<_Ty>* const _Mem, const _Identity_t<_Ty> _Value) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->exchange(_Value);
}

 template <class _Ty>
_Ty atomic_exchange(atomic<_Ty>* const _Mem, const _Identity_t<_Ty> _Value) noexcept {
    return _Mem->exchange(_Value);
}

 template <class _Ty>
_Ty atomic_exchange_explicit(
    volatile atomic<_Ty>* const _Mem, const _Identity_t<_Ty> _Value, const memory_order _Order) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->exchange(_Value, _Order);
}

 template <class _Ty>
_Ty atomic_exchange_explicit(
    atomic<_Ty>* const _Mem, const _Identity_t<_Ty> _Value, const memory_order _Order) noexcept {
    return _Mem->exchange(_Value, _Order);
}

 template <class _Ty>
bool atomic_compare_exchange_strong(
    volatile atomic<_Ty>* const _Mem, _Identity_t<_Ty>* const _Expected, const _Identity_t<_Ty> _Desired) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->compare_exchange_strong(*_Expected, _Desired);
}

 template <class _Ty>
bool atomic_compare_exchange_strong(
    atomic<_Ty>* const _Mem, _Identity_t<_Ty>* const _Expected, const _Identity_t<_Ty> _Desired) noexcept {
    return _Mem->compare_exchange_strong(*_Expected, _Desired);
}

 template <class _Ty>
bool atomic_compare_exchange_strong_explicit(volatile atomic<_Ty>* const _Mem, _Identity_t<_Ty>* const _Expected,
    const _Identity_t<_Ty> _Desired, const memory_order _Success, const memory_order _Failure) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->compare_exchange_strong(*_Expected, _Desired, _Combine_cas_memory_orders(_Success, _Failure));
}

 template <class _Ty>
bool atomic_compare_exchange_strong_explicit(atomic<_Ty>* const _Mem, _Identity_t<_Ty>* const _Expected,
    const _Identity_t<_Ty> _Desired, const memory_order _Success, const memory_order _Failure) noexcept {
    return _Mem->compare_exchange_strong(*_Expected, _Desired, _Combine_cas_memory_orders(_Success, _Failure));
}

 template <class _Ty>
bool atomic_compare_exchange_weak(
    volatile atomic<_Ty>* const _Mem, _Identity_t<_Ty>* const _Expected, const _Identity_t<_Ty> _Desired) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->compare_exchange_strong(*_Expected, _Desired);
}

 template <class _Ty>
bool atomic_compare_exchange_weak(
    atomic<_Ty>* const _Mem, _Identity_t<_Ty>* const _Expected, const _Identity_t<_Ty> _Desired) noexcept {
    return _Mem->compare_exchange_strong(*_Expected, _Desired);
}

 template <class _Ty>
bool atomic_compare_exchange_weak_explicit(volatile atomic<_Ty>* const _Mem, _Identity_t<_Ty>* const _Expected,
    const _Identity_t<_Ty> _Desired, const memory_order _Success, const memory_order _Failure) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->compare_exchange_strong(*_Expected, _Desired, _Combine_cas_memory_orders(_Success, _Failure));
}

 template <class _Ty>
bool atomic_compare_exchange_weak_explicit(atomic<_Ty>* const _Mem, _Identity_t<_Ty>* const _Expected,
    const _Identity_t<_Ty> _Desired, const memory_order _Success, const memory_order _Failure) noexcept {
    return _Mem->compare_exchange_strong(*_Expected, _Desired, _Combine_cas_memory_orders(_Success, _Failure));
}

 template <class _Ty>
_Ty atomic_fetch_add(volatile atomic<_Ty>* _Mem, const typename atomic<_Ty>::difference_type _Value) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->fetch_add(_Value);
}

 template <class _Ty>
_Ty atomic_fetch_add(atomic<_Ty>* _Mem, const typename atomic<_Ty>::difference_type _Value) noexcept {
    return _Mem->fetch_add(_Value);
}

 template <class _Ty>
_Ty atomic_fetch_add_explicit(volatile atomic<_Ty>* _Mem, const typename atomic<_Ty>::difference_type _Value,
    const memory_order _Order) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->fetch_add(_Value, _Order);
}

 template <class _Ty>
_Ty atomic_fetch_add_explicit(
    atomic<_Ty>* _Mem, const typename atomic<_Ty>::difference_type _Value, const memory_order _Order) noexcept {
    return _Mem->fetch_add(_Value, _Order);
}

 template <class _Ty>
_Ty atomic_fetch_sub(volatile atomic<_Ty>* _Mem, const typename atomic<_Ty>::difference_type _Value) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->fetch_sub(_Value);
}

 template <class _Ty>
_Ty atomic_fetch_sub(atomic<_Ty>* _Mem, const typename atomic<_Ty>::difference_type _Value) noexcept {
    return _Mem->fetch_sub(_Value);
}

 template <class _Ty>
_Ty atomic_fetch_sub_explicit(volatile atomic<_Ty>* _Mem, const typename atomic<_Ty>::difference_type _Value,
    const memory_order _Order) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->fetch_sub(_Value, _Order);
}

 template <class _Ty>
_Ty atomic_fetch_sub_explicit(
    atomic<_Ty>* _Mem, const typename atomic<_Ty>::difference_type _Value, const memory_order _Order) noexcept {
    return _Mem->fetch_sub(_Value, _Order);
}

 template <class _Ty>
_Ty atomic_fetch_and(volatile atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->fetch_and(_Value);
}

 template <class _Ty>
_Ty atomic_fetch_and(atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value) noexcept {
    return _Mem->fetch_and(_Value);
}

 template <class _Ty>
_Ty atomic_fetch_and_explicit(
    volatile atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value, const memory_order _Order) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->fetch_and(_Value, _Order);
}

 template <class _Ty>
_Ty atomic_fetch_and_explicit(
    atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value, const memory_order _Order) noexcept {
    return _Mem->fetch_and(_Value, _Order);
}

 template <class _Ty>
_Ty atomic_fetch_or(volatile atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->fetch_or(_Value);
}

 template <class _Ty>
_Ty atomic_fetch_or(atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value) noexcept {
    return _Mem->fetch_or(_Value);
}

 template <class _Ty>
_Ty atomic_fetch_or_explicit(
    volatile atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value, const memory_order _Order) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->fetch_or(_Value, _Order);
}

 template <class _Ty>
_Ty atomic_fetch_or_explicit(
    atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value, const memory_order _Order) noexcept {
    return _Mem->fetch_or(_Value, _Order);
}

 template <class _Ty>
_Ty atomic_fetch_xor(volatile atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->fetch_xor(_Value);
}

 template <class _Ty>
_Ty atomic_fetch_xor(atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value) noexcept {
    return _Mem->fetch_xor(_Value);
}

 template <class _Ty>
_Ty atomic_fetch_xor_explicit(
    volatile atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value, const memory_order _Order) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->fetch_xor(_Value, _Order);
}

 template <class _Ty>
_Ty atomic_fetch_xor_explicit(
    atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value, const memory_order _Order) noexcept {
    return _Mem->fetch_xor(_Value, _Order);
}


 template <class _Ty>
void atomic_wait(const volatile atomic<_Ty>* const _Mem, const typename atomic<_Ty>::value_type _Expected) noexcept {
    _Mem->wait(_Expected);
}

 template <class _Ty>
void atomic_wait(const atomic<_Ty>* const _Mem, const typename atomic<_Ty>::value_type _Expected) noexcept {
    _Mem->wait(_Expected);
}

 template <class _Ty>
void atomic_wait_explicit(const volatile atomic<_Ty>* const _Mem, const typename atomic<_Ty>::value_type _Expected,
    const memory_order _Order) noexcept {
    _Mem->wait(_Expected, _Order);
}

 template <class _Ty>
void atomic_wait_explicit(const atomic<_Ty>* const _Mem, const typename atomic<_Ty>::value_type _Expected,
    const memory_order _Order) noexcept {
    _Mem->wait(_Expected, _Order);
}

 template <class _Ty>
void atomic_notify_one(volatile atomic<_Ty>* const _Mem) noexcept {
    _Mem->notify_one();
}

 template <class _Ty>
void atomic_notify_one(atomic<_Ty>* const _Mem) noexcept {
    _Mem->notify_one();
}

 template <class _Ty>
void atomic_notify_all(volatile atomic<_Ty>* const _Mem) noexcept {
    _Mem->notify_all();
}

 template <class _Ty>
void atomic_notify_all(atomic<_Ty>* const _Mem) noexcept {
    _Mem->notify_all();
}
#line 2760 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"

 using atomic_bool = atomic<bool>;

 using atomic_char   = atomic<char>;
 using atomic_schar  = atomic<signed char>;
 using atomic_uchar  = atomic<unsigned char>;
 using atomic_short  = atomic<short>;
 using atomic_ushort = atomic<unsigned short>;
 using atomic_int    = atomic<int>;
 using atomic_uint   = atomic<unsigned int>;
 using atomic_long   = atomic<long>;
 using atomic_ulong  = atomic<unsigned long>;
 using atomic_llong  = atomic<long long>;
 using atomic_ullong = atomic<unsigned long long>;


 using atomic_char8_t = atomic<char8_t>;
#line 2778 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"
 using atomic_char16_t = atomic<char16_t>;
 using atomic_char32_t = atomic<char32_t>;
 using atomic_wchar_t  = atomic<wchar_t>;

 using atomic_int8_t   = atomic<int8_t>;
 using atomic_uint8_t  = atomic<uint8_t>;
 using atomic_int16_t  = atomic<int16_t>;
 using atomic_uint16_t = atomic<uint16_t>;
 using atomic_int32_t  = atomic<int32_t>;
 using atomic_uint32_t = atomic<uint32_t>;
 using atomic_int64_t  = atomic<int64_t>;
 using atomic_uint64_t = atomic<uint64_t>;

 using atomic_int_least8_t   = atomic<int_least8_t>;
 using atomic_uint_least8_t  = atomic<uint_least8_t>;
 using atomic_int_least16_t  = atomic<int_least16_t>;
 using atomic_uint_least16_t = atomic<uint_least16_t>;
 using atomic_int_least32_t  = atomic<int_least32_t>;
 using atomic_uint_least32_t = atomic<uint_least32_t>;
 using atomic_int_least64_t  = atomic<int_least64_t>;
 using atomic_uint_least64_t = atomic<uint_least64_t>;

 using atomic_int_fast8_t   = atomic<int_fast8_t>;
 using atomic_uint_fast8_t  = atomic<uint_fast8_t>;
 using atomic_int_fast16_t  = atomic<int_fast16_t>;
 using atomic_uint_fast16_t = atomic<uint_fast16_t>;
 using atomic_int_fast32_t  = atomic<int_fast32_t>;
 using atomic_uint_fast32_t = atomic<uint_fast32_t>;
 using atomic_int_fast64_t  = atomic<int_fast64_t>;
 using atomic_uint_fast64_t = atomic<uint_fast64_t>;

 using atomic_intptr_t  = atomic<intptr_t>;
 using atomic_uintptr_t = atomic<uintptr_t>;
 using atomic_size_t    = atomic<size_t>;
 using atomic_ptrdiff_t = atomic<ptrdiff_t>;
 using atomic_intmax_t  = atomic<intmax_t>;
 using atomic_uintmax_t = atomic<uintmax_t>;




 using atomic_signed_lock_free   = atomic_intptr_t;
 using atomic_unsigned_lock_free = atomic_uintptr_t;
#line 2822 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"




 struct atomic_flag { 

    [[nodiscard]] bool test(const memory_order _Order = memory_order_seq_cst) const noexcept {
        return _Storage.load(_Order) != 0;
    }

    [[nodiscard]] bool test(const memory_order _Order = memory_order_seq_cst) const volatile noexcept {
        return _Storage.load(_Order) != 0;
    }
#line 2836 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"

    bool test_and_set(const memory_order _Order = memory_order_seq_cst) noexcept {
        return _Storage.exchange(true, _Order) != 0;
    }

    bool test_and_set(const memory_order _Order = memory_order_seq_cst) volatile noexcept {
        return _Storage.exchange(true, _Order) != 0;
    }

    void clear(const memory_order _Order = memory_order_seq_cst) noexcept {
        _Storage.store(false, _Order);
    }

    void clear(const memory_order _Order = memory_order_seq_cst) volatile noexcept {
        _Storage.store(false, _Order);
    }

    constexpr atomic_flag() noexcept = default;


    void wait(const bool _Expected, const memory_order _Order = memory_order_seq_cst) const noexcept {
        _Storage.wait(static_cast<decltype(_Storage)::value_type>(_Expected), _Order);
    }

    void wait(const bool _Expected, const memory_order _Order = memory_order_seq_cst) const volatile noexcept {
        _Storage.wait(static_cast<decltype(_Storage)::value_type>(_Expected), _Order);
    }

    void notify_one() noexcept {
        _Storage.notify_one();
    }

    void notify_one() volatile noexcept {
        _Storage.notify_one();
    }

    void notify_all() noexcept {
        _Storage.notify_all();
    }

    void notify_all() volatile noexcept {
        _Storage.notify_all();
    }
#line 2880 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"


    atomic<long> _Storage;


#line 2886 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"
};



 [[nodiscard]] inline bool atomic_flag_test(const volatile atomic_flag* const _Flag) noexcept {
    return _Flag->test();
}

 [[nodiscard]] inline bool atomic_flag_test(const atomic_flag* const _Flag) noexcept {
    return _Flag->test();
}

 [[nodiscard]] inline bool atomic_flag_test_explicit(
    const volatile atomic_flag* const _Flag, const memory_order _Order) noexcept {
    return _Flag->test(_Order);
}

 [[nodiscard]] inline bool atomic_flag_test_explicit(
    const atomic_flag* const _Flag, const memory_order _Order) noexcept {
    return _Flag->test(_Order);
}
#line 2908 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"

 inline bool atomic_flag_test_and_set(atomic_flag* const _Flag) noexcept {
    return _Flag->test_and_set();
}

 inline bool atomic_flag_test_and_set(volatile atomic_flag* const _Flag) noexcept {
    return _Flag->test_and_set();
}

 inline bool atomic_flag_test_and_set_explicit(
    atomic_flag* const _Flag, const memory_order _Order) noexcept {
    return _Flag->test_and_set(_Order);
}

 inline bool atomic_flag_test_and_set_explicit(
    volatile atomic_flag* const _Flag, const memory_order _Order) noexcept {
    return _Flag->test_and_set(_Order);
}

 inline void atomic_flag_clear(atomic_flag* const _Flag) noexcept {
    _Flag->clear();
}

 inline void atomic_flag_clear(volatile atomic_flag* const _Flag) noexcept {
    _Flag->clear();
}

 inline void atomic_flag_clear_explicit(atomic_flag* const _Flag, const memory_order _Order) noexcept {
    _Flag->clear(_Order);
}

 inline void atomic_flag_clear_explicit(
    volatile atomic_flag* const _Flag, const memory_order _Order) noexcept {
    _Flag->clear(_Order);
}


 inline void atomic_flag_wait(const volatile atomic_flag* const _Flag, const bool _Expected) noexcept {
    return _Flag->wait(_Expected);
}

 inline void atomic_flag_wait(const atomic_flag* const _Flag, const bool _Expected) noexcept {
    return _Flag->wait(_Expected);
}

 inline void atomic_flag_wait_explicit(
    const volatile atomic_flag* const _Flag, const bool _Expected, const memory_order _Order) noexcept {
    return _Flag->wait(_Expected, _Order);
}

 inline void atomic_flag_wait_explicit(
    const atomic_flag* const _Flag, const bool _Expected, const memory_order _Order) noexcept {
    return _Flag->wait(_Expected, _Order);
}

 inline void atomic_flag_notify_one(volatile atomic_flag* const _Flag) noexcept {
    return _Flag->notify_one();
}

 inline void atomic_flag_notify_one(atomic_flag* const _Flag) noexcept {
    return _Flag->notify_one();
}

 inline void atomic_flag_notify_all(volatile atomic_flag* const _Flag) noexcept {
    return _Flag->notify_all();
}

 inline void atomic_flag_notify_all(atomic_flag* const _Flag) noexcept {
    return _Flag->notify_all();
}

template <class _Ty>
class _Locked_pointer {
public:
    static_assert(alignof(_Ty) >= (1 << 2), "2 low order bits are needed by _Locked_pointer");
    static constexpr uintptr_t _Lock_mask                = 3;
    static constexpr uintptr_t _Not_locked               = 0;
    static constexpr uintptr_t _Locked_notify_not_needed = 1;
    static constexpr uintptr_t _Locked_notify_needed     = 2;
    static constexpr uintptr_t _Ptr_value_mask           = ~_Lock_mask;

    constexpr _Locked_pointer() noexcept : _Storage{} {}
    explicit _Locked_pointer(_Ty* const _Ptr) noexcept : _Storage{reinterpret_cast<uintptr_t>(_Ptr)} {}

    _Locked_pointer(const _Locked_pointer&)            = delete;
    _Locked_pointer& operator=(const _Locked_pointer&) = delete;

    [[nodiscard]] _Ty* _Lock_and_load() noexcept {
        uintptr_t _Rep = _Storage.load(memory_order_relaxed);
        for (;;) {
            switch (_Rep & _Lock_mask) {
            case _Not_locked: 
                if (_Storage.compare_exchange_weak(_Rep, _Rep | _Locked_notify_not_needed)) {
                    return reinterpret_cast<_Ty*>(_Rep);
                }
                _mm_pause() ;
                break;

            case _Locked_notify_not_needed: 
                if (!_Storage.compare_exchange_weak(_Rep, (_Rep & _Ptr_value_mask) | _Locked_notify_needed)) {
                    
                    _mm_pause() ;
                    break;
                }
                _Rep = (_Rep & _Ptr_value_mask) | _Locked_notify_needed;
                [[fallthrough]];

            case _Locked_notify_needed: 
                _Storage.wait(_Rep, memory_order_relaxed);
                _Rep = _Storage.load(memory_order_relaxed);
                break;

            default: 
                :: abort();
            }
        }
    }

    void _Store_and_unlock(_Ty* const _Value) noexcept {
        const auto _Rep = _Storage.exchange(reinterpret_cast<uintptr_t>(_Value));
        if ((_Rep & _Lock_mask) == _Locked_notify_needed) {
            
            _Storage.notify_all();
        }
    }

    [[nodiscard]] _Ty* _Unsafe_load_relaxed() const noexcept {
        return reinterpret_cast<_Ty*>(_Storage.load(memory_order_relaxed));
    }

private:
    atomic<uintptr_t> _Storage;
};
#line 3042 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"

}

























#pragma warning(pop)
#pragma pack(pop)
#line 3072 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"
#line 3073 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\atomic"
#pragma external_header(pop)
#line 19 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\system_error"
#line 20 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\system_error"



#line 24 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\system_error"

#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




namespace std {
 enum class io_errc { 
    stream = 1
};

 template <class _Enum>
struct is_error_code_enum : false_type {};

template <>
struct is_error_code_enum<io_errc> : true_type {};

 template <class _Ty>
inline constexpr bool is_error_code_enum_v = is_error_code_enum<_Ty>::value;

 template <class _Enum>
struct is_error_condition_enum : false_type {};

template <>
struct is_error_condition_enum<errc> : true_type {};

 template <class _Ty>
inline constexpr bool is_error_condition_enum_v = is_error_condition_enum<_Ty>::value;

 class error_code;
 class error_condition;

namespace _Ensure_adl {
    void make_error_code()      = delete;
    void make_error_condition() = delete;
} 

 class error_category;

 [[nodiscard]] const error_category& generic_category() noexcept;
 [[nodiscard]] const error_category& iostream_category() noexcept;
 [[nodiscard]] const error_category& system_category() noexcept;

 class __declspec(novtable) error_category { 
public:





#pragma warning(push)
#pragma warning(disable : 4355) 
    constexpr error_category() noexcept : _Addr(this) {}
#pragma warning(pop)
#line 81 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\system_error"

    constexpr virtual ~error_category() noexcept = default;

    [[nodiscard]] virtual const char* name() const noexcept = 0;

    [[nodiscard]] virtual string message(int _Errval) const = 0;

    [[nodiscard]] virtual error_condition default_error_condition(int _Errval) const noexcept;

    [[nodiscard]] virtual bool equivalent(int _Errval, const error_condition& _Cond) const noexcept;

    [[nodiscard]] virtual bool equivalent(const error_code& _Code, int _Errval) const noexcept;

    [[nodiscard]] bool operator==(const error_category& _Right) const noexcept {



        return _Bit_cast<uintptr_t>(_Addr) == _Bit_cast<uintptr_t>(_Right._Addr);
#line 100 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\system_error"
    }





#line 107 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\system_error"


    [[nodiscard]] strong_ordering operator<=>(const error_category& _Right) const noexcept {
        return _Bit_cast<uintptr_t>(_Addr) <=> _Bit_cast<uintptr_t>(_Right._Addr);
    }








#line 121 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\system_error"

    error_category(const error_category&)            = delete;
    error_category& operator=(const error_category&) = delete;

protected:



    union _Addr_storage {
    private:
        uintptr_t _Num;
        error_category* _Ptr;

    public:
        constexpr explicit _Addr_storage(const uintptr_t _Addr_num) noexcept : _Num(_Addr_num) {}
        constexpr explicit _Addr_storage(error_category* const _Addr_ptr) noexcept : _Ptr(_Addr_ptr) {}

        
        constexpr _Addr_storage& operator=(const uintptr_t _Addr_num) noexcept {
            _Num = _Addr_num;
            return *this;
        }
    };
     ;
     ;

    _Addr_storage _Addr;
#line 149 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\system_error"

    constexpr explicit error_category(const uintptr_t _Addr_) noexcept : _Addr(_Addr_) {}

    enum : uintptr_t { 
        _Future_addr   = 1,
        _Generic_addr  = 3,
        _Iostream_addr = 5,
        _System_addr   = 7
    };
};


[[nodiscard]] inline bool _System_error_equal(const error_code&, const error_condition&) noexcept;
#line 163 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\system_error"

 class error_code { 
public:
    error_code() noexcept : _Myval(0), _Mycat(&::std:: system_category()) {} 

    error_code(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) {}

    template <class _Enum, enable_if_t<is_error_code_enum_v<_Enum>, int> = 0>
    error_code(_Enum _Errcode) noexcept : _Myval(0), _Mycat(nullptr) {
        using _Ensure_adl::make_error_code;
        *this = make_error_code(_Errcode); 
    }

    void assign(int _Val, const error_category& _Cat) noexcept {
        _Myval = _Val;
        _Mycat = &_Cat;
    }

    template <class _Enum, enable_if_t<is_error_code_enum_v<_Enum>, int> = 0>
    error_code& operator=(_Enum _Errcode) noexcept {
        using _Ensure_adl::make_error_code;
        *this = make_error_code(_Errcode); 
        return *this;
    }

    void clear() noexcept {
        _Myval = 0;
        _Mycat = &::std:: system_category();
    }

    [[nodiscard]] int value() const noexcept {
        return _Myval;
    }

    [[nodiscard]] const error_category& category() const noexcept {
        return *_Mycat;
    }

    [[nodiscard]] error_condition default_error_condition() const noexcept;

    [[nodiscard]] string message() const {
        return category().message(value());
    }

    explicit operator bool() const noexcept {
        return value() != 0;
    }


    [[nodiscard]] friend bool operator==(const error_code& _Left, const error_code& _Right) noexcept {
        return _Left.category() == _Right.category() && _Left.value() == _Right.value();
    }

    [[nodiscard]] friend bool operator==(const error_code& _Left, const error_condition& _Right) noexcept {
        return _System_error_equal(_Left, _Right);
    }


    [[nodiscard]] friend strong_ordering operator<=>(const error_code& _Left, const error_code& _Right) noexcept {
        if (const auto _Result = _Left.category() <=> _Right.category(); _Result != 0) {
            return _Result;
        }
        return _Left.value() <=> _Right.value();
    }





#line 233 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\system_error"
















#line 250 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\system_error"
#line 251 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\system_error"

private:
    int _Myval; 
    const error_category* _Mycat; 
};

 class error_condition { 
public:
    error_condition() noexcept : _Myval(0), _Mycat(&::std:: generic_category()) {} 

    error_condition(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) {}

    template <class _Enum, enable_if_t<is_error_condition_enum_v<_Enum>, int> = 0>
    error_condition(_Enum _Errcode) noexcept : _Myval(0), _Mycat(nullptr) {
        using _Ensure_adl::make_error_condition;
        *this = make_error_condition(_Errcode); 
    }

    void assign(int _Val, const error_category& _Cat) noexcept {
        _Myval = _Val;
        _Mycat = &_Cat;
    }

    template <class _Enum, enable_if_t<is_error_condition_enum_v<_Enum>, int> = 0>
    error_condition& operator=(_Enum _Errcode) noexcept {
        using _Ensure_adl::make_error_condition;
        *this = make_error_condition(_Errcode); 
        return *this;
    }

    void clear() noexcept {
        _Myval = 0;
        _Mycat = &::std:: generic_category();
    }

    [[nodiscard]] int value() const noexcept {
        return _Myval;
    }

    [[nodiscard]] const error_category& category() const noexcept {
        return *_Mycat;
    }

    [[nodiscard]] string message() const {
        return category().message(value());
    }

    explicit operator bool() const noexcept {
        return value() != 0;
    }


    [[nodiscard]] friend bool operator==(const error_condition& _Left, const error_condition& _Right) noexcept {
        return _Left.category() == _Right.category() && _Left.value() == _Right.value();
    }


    [[nodiscard]] friend strong_ordering operator<=>(
        const error_condition& _Left, const error_condition& _Right) noexcept {
        if (const auto _Result = _Left.category() <=> _Right.category(); _Result != 0) {
            return _Result;
        }
        return _Left.value() <=> _Right.value();
    }





#line 321 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\system_error"




#line 326 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\system_error"

    
    
    
    friend bool operator==(const error_code& _Left, const error_condition& _Right) noexcept;




#line 336 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\system_error"
#line 337 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\system_error"

private:
    int _Myval; 
    const error_category* _Mycat; 
};


[[nodiscard]] inline bool _System_error_equal(const error_code& _Left, const error_condition& _Right) noexcept {
    return _Left.category().equivalent(_Left.value(), _Right) || _Right.category().equivalent(_Left, _Right.value());
}





























































#line 409 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\system_error"

[[nodiscard]] inline error_condition error_category::default_error_condition(int _Errval) const noexcept {
    
    return error_condition(_Errval, *this);
}

[[nodiscard]] inline bool error_category::equivalent(int _Errval, const error_condition& _Cond) const noexcept {
    return default_error_condition(_Errval) == _Cond;
}

[[nodiscard]] inline bool error_category::equivalent(const error_code& _Code, int _Errval) const noexcept {
    return *this == _Code.category() && _Code.value() == _Errval;
}

[[nodiscard]] inline error_condition error_code::default_error_condition() const noexcept {
    
    return category().default_error_condition(value());
}

 [[nodiscard]] inline error_code make_error_code(errc _Ec) noexcept {
    return error_code(static_cast<int>(_Ec), ::std:: generic_category());
}

 [[nodiscard]] inline error_code make_error_code(io_errc _Ec) noexcept {
    return error_code(static_cast<int>(_Ec), ::std:: iostream_category());
}

 [[nodiscard]] inline error_condition make_error_condition(errc _Ec) noexcept {
    return error_condition(static_cast<int>(_Ec), ::std:: generic_category());
}

 [[nodiscard]] inline error_condition make_error_condition(io_errc _Ec) noexcept {
    return error_condition(static_cast<int>(_Ec), ::std:: iostream_category());
}

template <>
struct hash<error_code> {
    using _Unnameable_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = error_code;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]   = size_t;

    [[nodiscard]] size_t operator()(const error_code& _Keyval) const noexcept {
        return hash<int>{}(_Keyval.value());
    }
};

template <>
struct hash<error_condition> {
    using _Unnameable_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = error_condition;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]   = size_t;

    [[nodiscard]] size_t operator()(const error_condition& _Keyval) const noexcept {
        return hash<int>{}(_Keyval.value());
    }
};

class _System_error : public runtime_error { 
private:
    static string _Makestr(error_code _Errcode, string _Message) { 
        if (!_Message.empty()) {
            _Message.append(": ");
        }

        _Message.append(_Errcode.message());
        return _Message;
    }

protected:
    _System_error(error_code _Errcode, const string& _Message)
        : runtime_error(_Makestr(_Errcode, _Message)), _Mycode(_Errcode) {}

    error_code _Mycode; 
};

 class system_error : public _System_error { 
private:
    using _Mybase = _System_error;

public:
    system_error(error_code _Errcode) : _Mybase(_Errcode, "") {}

    system_error(error_code _Errcode, const string& _Message) : _Mybase(_Errcode, _Message) {}

    system_error(error_code _Errcode, const char* _Message) : _Mybase(_Errcode, _Message) {}

    system_error(int _Errval, const error_category& _Errcat) : _Mybase(error_code(_Errval, _Errcat), "") {}

    system_error(int _Errval, const error_category& _Errcat, const string& _Message)
        : _Mybase(error_code(_Errval, _Errcat), _Message) {}

    system_error(int _Errval, const error_category& _Errcat, const char* _Message)
        : _Mybase(error_code(_Errval, _Errcat), _Message) {}

    [[nodiscard]] const error_code& code() const noexcept {
        return _Mycode;
    }






#line 511 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\system_error"
};

[[noreturn]] inline void _Throw_system_error(const errc _Ec) {
    throw system_error{::std:: make_error_code(_Ec)} ;
}

extern "C++"  const char* __cdecl _Syserror_map(int);
extern "C++"  int __cdecl _Winerror_map(int);

struct _System_error_message {
    char* _Str;
    size_t _Length;

    explicit _System_error_message(const unsigned long _Ec) noexcept
        : _Str(nullptr), _Length(:: __std_system_error_allocate_message(_Ec, &_Str)) {}

    _System_error_message(const _System_error_message&)            = delete;
    _System_error_message& operator=(const _System_error_message&) = delete;

    ~_System_error_message() {
        :: __std_system_error_deallocate_message(_Str);
    }
};

class _Generic_error_category : public error_category { 
public:
    constexpr _Generic_error_category() noexcept : error_category(_Generic_addr) {}

    [[nodiscard]] const char* name() const noexcept override {
        return "generic";
    }

    [[nodiscard]] string message(int _Errcode) const override {
        return _Syserror_map(_Errcode);
    }
};

class _Iostream_error_category2 : public error_category { 
public:
    constexpr _Iostream_error_category2() noexcept : error_category(_Iostream_addr) {}

    [[nodiscard]] const char* name() const noexcept override {
        return "iostream";
    }

    [[nodiscard]] string message(int _Errcode) const override {
        if (_Errcode == static_cast<int>(io_errc::stream)) {
            static constexpr char _Iostream_error[] = "iostream stream error";
            constexpr size_t _Iostream_error_length = sizeof(_Iostream_error) - 1; 
            return string{_Iostream_error, _Iostream_error_length};
        } else {
            return _Syserror_map(_Errcode);
        }
    }
};

class _System_error_category : public error_category { 
public:
    constexpr _System_error_category() noexcept : error_category(_System_addr) {}

    [[nodiscard]] const char* name() const noexcept override {
        return "system";
    }

    [[nodiscard]] string message(int _Errcode) const override {
        const _System_error_message _Msg(static_cast<unsigned long>(_Errcode));
        if (_Msg._Length == 0) {
            static constexpr char _Unknown_error[] = "unknown error";
            constexpr size_t _Unknown_error_length = sizeof(_Unknown_error) - 1; 
            return string{_Unknown_error, _Unknown_error_length};
        } else {
            return string{_Msg._Str, _Msg._Length};
        }
    }

    [[nodiscard]] error_condition default_error_condition(int _Errval) const noexcept override {
        if (_Errval == 0) {
            return error_condition(0, ::std:: generic_category());
        }

        
        const int _Posv = _Winerror_map(_Errval);
        if (_Posv == 0) {
            return error_condition(_Errval, ::std:: system_category());
        } else {
            return error_condition(_Posv, ::std:: generic_category());
        }
    }
};





































#line 638 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\system_error"
template <class _Ty>
[[nodiscard]] const _Ty& _Immortalize_memcpy_image() noexcept {
    static constexpr _Ty _Static;
    return _Static;
}















































#line 691 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\system_error"

 [[nodiscard]] inline const error_category& generic_category() noexcept {
    return _Immortalize_memcpy_image<_Generic_error_category>();
}

 [[nodiscard]] inline const error_category& iostream_category() noexcept {
    return _Immortalize_memcpy_image<_Iostream_error_category2>();
}

 [[nodiscard]] inline const error_category& system_category() noexcept {
    return _Immortalize_memcpy_image<_System_error_category>();
}
}


#pragma warning(pop)
#pragma pack(pop)
#line 709 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\system_error"
#line 710 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\system_error"
#pragma external_header(pop)
#line 13 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xiosbase"
#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xlocale"





#pragma once






#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"





#pragma once







#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\typeinfo"





#pragma once







#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




#pragma warning(disable : 4275) 

#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime_typeinfo.h"







#pragma once






#pragma warning(push)
#pragma warning(disable: 4514 4820 )

#pragma pack(push, 8 )

extern "C++" { 





#line 27 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime_typeinfo.h"
    struct __type_info_node;
#line 29 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime_typeinfo.h"




    extern __type_info_node __type_info_root_node;
#line 35 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime_typeinfo.h"

} 


__pragma(pack(push, 8)) extern "C" {

struct __std_type_info_data
{
    const char * _UndecoratedName;
    const char   _DecoratedName[1];
    __std_type_info_data() = delete;
    __std_type_info_data(const __std_type_info_data&) = delete;
    __std_type_info_data(__std_type_info_data&&) = delete;

    __std_type_info_data& operator=(const __std_type_info_data&) = delete;
    __std_type_info_data& operator=(__std_type_info_data&&) = delete;
};

 int __cdecl __std_type_info_compare(
     const __std_type_info_data* _Lhs,
     const __std_type_info_data* _Rhs
    );

 size_t __cdecl __std_type_info_hash(
     const __std_type_info_data* _Data
    );

 const char* __cdecl __std_type_info_name(
     __std_type_info_data* _Data,
     __type_info_node*     _RootNode
    );

} __pragma(pack(pop))


#pragma warning(push)
#pragma warning(disable: 4577) 
extern "C++" { 
class type_info
{
public:

    type_info(const type_info&) = delete;
    type_info& operator=(const type_info&) = delete;

    [[nodiscard]] size_t hash_code() const noexcept
    {
        return __std_type_info_hash(&_Data);
    }

    [[nodiscard]]


#line 89 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime_typeinfo.h"
    bool operator==(const type_info& _Other) const noexcept
    {





#line 97 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime_typeinfo.h"

        return __std_type_info_compare(&_Data, &_Other._Data) == 0;
    }






#line 107 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime_typeinfo.h"

    [[nodiscard]] bool before(const type_info& _Other) const noexcept
    {
        return __std_type_info_compare(&_Data, &_Other._Data) < 0;
    }

    [[nodiscard]] const char* name() const noexcept
    {
        


        return __std_type_info_name(&_Data, &__type_info_root_node);
        #line 120 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime_typeinfo.h"
    }

    [[nodiscard]] const char* raw_name() const noexcept
    {
        return _Data._DecoratedName;
    }

    virtual ~type_info() noexcept;

private:

    mutable __std_type_info_data _Data;
};
} 
#pragma warning(pop)

namespace std {
    using ::type_info;
}



namespace std {

#pragma warning(push)
#pragma warning(disable: 4577) 
class bad_cast
    : public exception
{
public:

    bad_cast() noexcept
        : exception("bad cast", 1)
    {
    }

    static bad_cast __construct_from_string_literal(const char* const _Message) noexcept
    {
        return bad_cast(_Message, 1);
    }

private:

    bad_cast(const char* const _Message, int) noexcept
        : exception(_Message, 1)
    {
    }
};

class bad_typeid
    : public exception
{
public:

    bad_typeid() noexcept
        : exception("bad typeid", 1)
    {
    }

    static bad_typeid __construct_from_string_literal(const char* const _Message) noexcept
    {
        return bad_typeid(_Message, 1);
    }

private:

    friend class __non_rtti_object;

    bad_typeid(const char* const _Message, int) noexcept
        : exception(_Message, 1)
    {
    }
};

class __non_rtti_object
    : public bad_typeid
{
public:

    static __non_rtti_object __construct_from_string_literal(const char* const _Message) noexcept
    {
        return __non_rtti_object(_Message, 1);
    }

private:

    __non_rtti_object(const char* const _Message, int) noexcept
        : bad_typeid(_Message, 1)
    {
    }
};

#pragma warning(pop)
} 

#line 216 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime_typeinfo.h"
#pragma pack(pop)
#pragma warning(pop) 
#line 219 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime_typeinfo.h"
#pragma external_header(pop)
#line 24 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\typeinfo"

namespace std {


inline constexpr int _Small_object_num_ptrs = 6 + 16 / sizeof(void*);

 using ::type_info;


 class bad_cast;
 class bad_typeid;





























#line 65 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\typeinfo"

[[noreturn]] inline void _Throw_bad_cast() {
    throw bad_cast{} ;
}

}



#pragma pack(pop)
#pragma warning(pop)
#line 77 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\typeinfo"
#line 78 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\typeinfo"
#pragma external_header(pop)
#line 15 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"




#line 20 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"

#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




namespace std {






 template <class _ExPo, class _FwdIt, class _NoThrowFwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
_NoThrowFwdIt uninitialized_copy(_ExPo&&, const _FwdIt _First, const _FwdIt _Last, _NoThrowFwdIt _Dest) noexcept
  {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt>, "Parallel algorithms require forward iterators or stronger.") ;
    static_assert(_Is_ranges_fwd_iter_v<_NoThrowFwdIt> && is_lvalue_reference_v<_Iter_ref_t<_NoThrowFwdIt>>, "Parallel specialized <memory> algorithms require the iterator type to be forward iterator and dereference " "to lvalues.") ;

    return ::std:: uninitialized_copy(_First, _Last, _Dest);
}
#line 46 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"


namespace ranges {
     template <class _In, class _Out>
    using uninitialized_copy_result = in_out_result<_In, _Out>;

    class _Uninitialized_copy_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It, sentinel_for<_It> _Se, _No_throw_forward_iterator _Out,
            _No_throw_sentinel_for<_Out> _OSe>
            requires constructible_from<iter_value_t<_Out>, iter_reference_t<_It>>
        uninitialized_copy_result<_It, _Out> operator()(_It _First1, _Se _Last1, _Out _First2, _OSe _Last2) const {
            _Adl_verify_range(_First1, _Last1);
            _Adl_verify_range(_First2, _Last2);
            auto _UResult = _Uninitialized_copy_unchecked(_Unwrap_iter<_Se>(::std:: move(_First1)),
                _Unwrap_sent<_It>(::std:: move(_Last1)), _Unwrap_iter<_OSe>(::std:: move(_First2)),
                _Unwrap_sent<_Out>(::std:: move(_Last2)));

            _Seek_wrapped(_First1, ::std:: move(_UResult.in));
            _Seek_wrapped(_First2, ::std:: move(_UResult.out));
            return {::std:: move(_First1), ::std:: move(_First2)};
        }

        template <input_range _Rng1, _No_throw_forward_range _Rng2>
            requires constructible_from<range_value_t<_Rng2>, range_reference_t<_Rng1>>
        uninitialized_copy_result<borrowed_iterator_t<_Rng1>, borrowed_iterator_t<_Rng2>> operator()(
            _Rng1&& _Range1, _Rng2&& _Range2) const {
            auto _First1  = ::std::ranges:: begin(_Range1);
            auto _UResult = _Uninitialized_copy_unchecked(
                _Unwrap_range_iter<_Rng1>(::std:: move(_First1)), _Uend(_Range1), _Ubegin(_Range2), _Uend(_Range2));

            _Seek_wrapped(_First1, ::std:: move(_UResult.in));
            return {::std:: move(_First1), _Rewrap_iterator(_Range2, ::std:: move(_UResult.out))};
        }

    private:
        template <class _It, class _Se, class _Out, class _OSe>
        [[nodiscard]] static uninitialized_copy_result<_It, _Out> _Uninitialized_copy_unchecked(
            _It _IFirst, _Se _ILast, _Out _OFirst, _OSe _OLast) {
             ;
             ;
             ;
             ;
             ;

            constexpr bool _Is_sized1 = sized_sentinel_for<_Se, _It>;
            constexpr bool _Is_sized2 = sized_sentinel_for<_OSe, _Out>;
            if constexpr (_Iter_copy_cat<_It, _Out>::_Bitcopy_constructible
                          && _Sized_or_unreachable_sentinel_for<_Se, _It> 
                          && _Sized_or_unreachable_sentinel_for<_OSe, _Out>) {
                if constexpr (_Is_sized1 && _Is_sized2) {
                    return _Copy_memcpy_common(_IFirst, ::std::ranges:: next(_IFirst, ::std:: move(_ILast)), _OFirst,
                        ::std::ranges:: next(_OFirst, ::std:: move(_OLast)));
                } else if constexpr (_Is_sized1) {
                    return _Copy_memcpy_distance(_IFirst, _OFirst, _IFirst, ::std::ranges:: next(_IFirst, ::std:: move(_ILast)));
                } else if constexpr (_Is_sized2) {
                    return _Copy_memcpy_distance(_IFirst, _OFirst, _OFirst, ::std::ranges:: next(_OFirst, ::std:: move(_OLast)));
                } else {
                     ;
                }
            } else {
                _Uninitialized_backout _Backout{::std:: move(_OFirst)};

                for (; _IFirst != _ILast && _Backout._Last != _OLast; ++_IFirst) {
                    _Backout._Emplace_back(*_IFirst);
                }

                return {::std:: move(_IFirst), _Backout._Release()};
            }
        }
    };

     inline constexpr _Uninitialized_copy_fn uninitialized_copy{_Not_quite_object::_Construct_tag{}};
} 
#line 123 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"

 template <class _InIt, class _Diff, class _NoThrowFwdIt>
_NoThrowFwdIt uninitialized_copy_n(const _InIt _First, const _Diff _Count_raw, _NoThrowFwdIt _Dest) {
    
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (_Count <= 0) {
        return _Dest;
    }

    auto _UFirst = _Get_unwrapped_n(_First, _Count);
    auto _UDest  = _Get_unwrapped_n(_Dest, _Count);
    if constexpr (_Iter_copy_cat<decltype(_UFirst), decltype(_UDest)>::_Bitcopy_constructible) {
        _UDest = _Copy_memmove_n(_UFirst, static_cast<size_t>(_Count), _UDest);
    } else {
        _Uninitialized_backout<decltype(_UDest)> _Backout{_UDest};

        for (; _Count > 0; --_Count, (void) ++_UFirst) {
            _Backout._Emplace_back(*_UFirst);
        }

        _UDest = _Backout._Release();
    }

    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}


 template <class _ExPo, class _FwdIt, class _Diff, class _NoThrowFwdIt,
    _Enable_if_execution_policy_t<_ExPo> = 0>
_NoThrowFwdIt uninitialized_copy_n(_ExPo&&, const _FwdIt _First, const _Diff _Count_raw, _NoThrowFwdIt _Dest) noexcept
  {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt>, "Parallel algorithms require forward iterators or stronger.") ;
    static_assert(_Is_ranges_fwd_iter_v<_NoThrowFwdIt> && is_lvalue_reference_v<_Iter_ref_t<_NoThrowFwdIt>>, "Parallel specialized <memory> algorithms require the iterator type to be forward iterator and dereference " "to lvalues.") ;

    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    return ::std:: uninitialized_copy_n(_First, _Count, _Dest);
}
#line 164 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"


namespace ranges {
     template <class _In, class _Out>
    using uninitialized_copy_n_result = in_out_result<_In, _Out>;

    class _Uninitialized_copy_n_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It, _No_throw_forward_iterator _Out, _No_throw_sentinel_for<_Out> _OSe>
            requires constructible_from<iter_value_t<_Out>, iter_reference_t<_It>>
        uninitialized_copy_n_result<_It, _Out> operator()(
            _It _First1, iter_difference_t<_It> _Count, _Out _First2, _OSe _Last2) const {
            if (_Count <= 0) {
                return {::std:: move(_First1), ::std:: move(_First2)};
            }

            _Adl_verify_range(_First2, _Last2);
            auto _IFirst = _Get_unwrapped_n(::std:: move(_First1), _Count);
            auto _OFirst = _Unwrap_iter<_OSe>(::std:: move(_First2));
            auto _OLast  = _Unwrap_sent<_Out>(::std:: move(_Last2));
            if constexpr (_Iter_copy_cat<_It, _Out>::_Bitcopy_constructible
                          && _Sized_or_unreachable_sentinel_for<_OSe, _Out>) {
                if constexpr (sized_sentinel_for<_OSe, _Out>) {
                    auto _UResult = _Copy_memcpy_common(
                        _IFirst, _IFirst + _Count, _OFirst, ::std::ranges:: next(_OFirst, ::std:: move(_OLast)));
                    _IFirst = ::std:: move(_UResult.in);
                    _OFirst = ::std:: move(_UResult.out);
                } else {
                    auto _UResult = _Copy_memcpy_count(_IFirst, _OFirst, static_cast<size_t>(_Count));
                    _IFirst       = ::std:: move(_UResult.in);
                    _OFirst       = ::std:: move(_UResult.out);
                }
            } else {
                _Uninitialized_backout _Backout{::std:: move(_OFirst)};

                for (; _Count > 0 && _Backout._Last != _OLast; --_Count, (void) ++_IFirst) {
                    _Backout._Emplace_back(*_IFirst);
                }

                _OFirst = _Backout._Release();
            }

            _Seek_wrapped(_First1, ::std:: move(_IFirst));
            _Seek_wrapped(_First2, ::std:: move(_OFirst));
            return {::std:: move(_First1), ::std:: move(_First2)};
        }
    };

     inline constexpr _Uninitialized_copy_n_fn uninitialized_copy_n{_Not_quite_object::_Construct_tag{}};
} 
#line 217 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"


 template <class _InIt, class _NoThrowFwdIt>
_NoThrowFwdIt uninitialized_move(const _InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {
    
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    const auto _UDest  = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
    _Seek_wrapped(_Dest, ::std:: _Uninitialized_move_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}

 template <class _ExPo, class _FwdIt, class _NoThrowFwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
_NoThrowFwdIt uninitialized_move(_ExPo&&, const _FwdIt _First, const _FwdIt _Last, _NoThrowFwdIt _Dest) noexcept
  {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt>, "Parallel algorithms require forward iterators or stronger.") ;
    static_assert(_Is_ranges_fwd_iter_v<_NoThrowFwdIt> && is_lvalue_reference_v<_Iter_ref_t<_NoThrowFwdIt>>, "Parallel specialized <memory> algorithms require the iterator type to be forward iterator and dereference " "to lvalues.") ;

    return ::std:: uninitialized_move(_First, _Last, _Dest);
}


namespace ranges {
    class _Uninitialized_move_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It, sentinel_for<_It> _Se, _No_throw_forward_iterator _Out,
            _No_throw_sentinel_for<_Out> _OSe>
            requires constructible_from<iter_value_t<_Out>, iter_rvalue_reference_t<_It>>
        uninitialized_move_result<_It, _Out> operator()(_It _First1, _Se _Last1, _Out _First2, _OSe _Last2) const {
            _Adl_verify_range(_First1, _Last1);
            _Adl_verify_range(_First2, _Last2);
            auto _UResult = ::std::ranges:: _Uninitialized_move_unchecked(_Unwrap_iter<_Se>(::std:: move(_First1)),
                _Unwrap_sent<_It>(::std:: move(_Last1)), _Unwrap_iter<_OSe>(::std:: move(_First2)),
                _Unwrap_sent<_Out>(::std:: move(_Last2)));

            _Seek_wrapped(_First1, ::std:: move(_UResult.in));
            _Seek_wrapped(_First2, ::std:: move(_UResult.out));
            return {::std:: move(_First1), ::std:: move(_First2)};
        }

        template <input_range _Rng1, _No_throw_forward_range _Rng2>
            requires constructible_from<range_value_t<_Rng2>, range_rvalue_reference_t<_Rng1>>
        uninitialized_move_result<borrowed_iterator_t<_Rng1>, borrowed_iterator_t<_Rng2>> operator()(
            _Rng1&& _Range1, _Rng2&& _Range2) const {
            auto _First1  = ::std::ranges:: begin(_Range1);
            auto _UResult = ::std::ranges:: _Uninitialized_move_unchecked(
                _Unwrap_range_iter<_Rng1>(::std:: move(_First1)), _Uend(_Range1), _Ubegin(_Range2), _Uend(_Range2));

            _Seek_wrapped(_First1, ::std:: move(_UResult.in));
            return {::std:: move(_First1), _Rewrap_iterator(_Range2, ::std:: move(_UResult.out))};
        }
    };

     inline constexpr _Uninitialized_move_fn uninitialized_move{_Not_quite_object::_Construct_tag{}};
} 
#line 278 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"

 template <class _InIt, class _Diff, class _NoThrowFwdIt>
pair<_InIt, _NoThrowFwdIt> uninitialized_move_n(_InIt _First, const _Diff _Count_raw, _NoThrowFwdIt _Dest) {
    
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (_Count <= 0) {
        return {_First, _Dest};
    }

    auto _UFirst = _Get_unwrapped_n(_First, _Count);
    auto _UDest  = _Get_unwrapped_n(_Dest, _Count);
    if constexpr (_Iter_move_cat<decltype(_UFirst), decltype(_UDest)>::_Bitcopy_constructible) {
        _UDest = _Copy_memmove_n(_UFirst, static_cast<size_t>(_Count), _UDest);
        _UFirst += _Count;
    } else {
        _Uninitialized_backout<decltype(_UDest)> _Backout{_UDest};

        for (; _Count > 0; --_Count, (void) ++_UFirst) {
            _Backout._Emplace_back(::std:: move(*_UFirst));
        }

        _UDest = _Backout._Release();
    }

    _Seek_wrapped(_Dest, _UDest);
    _Seek_wrapped(_First, _UFirst);
    return {_First, _Dest};
}

 template <class _ExPo, class _FwdIt, class _Diff, class _NoThrowFwdIt,
    _Enable_if_execution_policy_t<_ExPo> = 0>
pair<_FwdIt, _NoThrowFwdIt> uninitialized_move_n(
    _ExPo&&, const _FwdIt _First, const _Diff _Count_raw, _NoThrowFwdIt _Dest) noexcept   {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt>, "Parallel algorithms require forward iterators or stronger.") ;
    static_assert(_Is_ranges_fwd_iter_v<_NoThrowFwdIt> && is_lvalue_reference_v<_Iter_ref_t<_NoThrowFwdIt>>, "Parallel specialized <memory> algorithms require the iterator type to be forward iterator and dereference " "to lvalues.") ;

    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    return ::std:: uninitialized_move_n(_First, _Count, _Dest);
}

 template <class _ExPo, class _NoThrowFwdIt, class _Tval, _Enable_if_execution_policy_t<_ExPo> = 0>
void uninitialized_fill(_ExPo&&, const _NoThrowFwdIt _First, const _NoThrowFwdIt _Last, const _Tval& _Val) noexcept
  {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_NoThrowFwdIt> && is_lvalue_reference_v<_Iter_ref_t<_NoThrowFwdIt>>, "Parallel specialized <memory> algorithms require the iterator type to be forward iterator and dereference " "to lvalues.") ;

    ::std:: uninitialized_fill(_First, _Last, _Val);
}
#line 330 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"


namespace ranges {
     template <class _In, class _Out>
    using uninitialized_move_n_result = in_out_result<_In, _Out>;

    class _Uninitialized_move_n_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It, _No_throw_forward_iterator _Out, _No_throw_sentinel_for<_Out> _OSe>
            requires constructible_from<iter_value_t<_Out>, iter_rvalue_reference_t<_It>>
        uninitialized_move_n_result<_It, _Out> operator()(
            _It _First1, iter_difference_t<_It> _Count, _Out _First2, _OSe _Last2) const {
            if (_Count <= 0) {
                return {::std:: move(_First1), ::std:: move(_First2)};
            }

            _Adl_verify_range(_First2, _Last2);
            auto _IFirst      = _Get_unwrapped_n(::std:: move(_First1), _Count);
            auto _OFirst      = _Unwrap_iter<_OSe>(::std:: move(_First2));
            const auto _OLast = _Unwrap_sent<_Out>(::std:: move(_Last2));
            if constexpr (_Iter_move_cat<_It, _Out>::_Bitcopy_constructible
                          && _Sized_or_unreachable_sentinel_for<_OSe, _Out>) {
                if constexpr (sized_sentinel_for<_OSe, _Out>) {
                    auto _UResult = _Copy_memcpy_common(
                        _IFirst, _IFirst + _Count, _OFirst, ::std::ranges:: next(_OFirst, ::std:: move(_OLast)));
                    _IFirst = ::std:: move(_UResult.in);
                    _OFirst = ::std:: move(_UResult.out);
                } else {
                    auto _UResult = _Copy_memcpy_count(_IFirst, _OFirst, static_cast<size_t>(_Count));
                    _IFirst       = ::std:: move(_UResult.in);
                    _OFirst       = ::std:: move(_UResult.out);
                }
            } else {
                _Uninitialized_backout _Backout{::std:: move(_OFirst)};

                for (; _Count > 0 && _Backout._Last != _OLast; --_Count, (void) ++_IFirst) {
                    _Backout._Emplace_back(::std::ranges:: iter_move(_IFirst));
                }

                _OFirst = _Backout._Release();
            }

            _Seek_wrapped(_First1, ::std:: move(_IFirst));
            _Seek_wrapped(_First2, ::std:: move(_OFirst));
            return {::std:: move(_First1), ::std:: move(_First2)};
        }
    };

     inline constexpr _Uninitialized_move_n_fn uninitialized_move_n{_Not_quite_object::_Construct_tag{}};

    class _Uninitialized_fill_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <_No_throw_forward_iterator _It, _No_throw_sentinel_for<_It> _Se, class _Ty>
            requires constructible_from<iter_value_t<_It>, const _Ty&>
        _It operator()(_It _First, _Se _Last, const _Ty& _Val) const {
            _Adl_verify_range(_First, _Last);
            auto _UResult = _Uninitialized_fill_unchecked(
                _Unwrap_iter<_Se>(::std:: move(_First)), _Unwrap_sent<_It>(::std:: move(_Last)), _Val);

            _Seek_wrapped(_First, ::std:: move(_UResult));
            return _First;
        }

        template <_No_throw_forward_range _Rng, class _Ty>
            requires constructible_from<range_value_t<_Rng>, const _Ty&>
        borrowed_iterator_t<_Rng> operator()(_Rng&& _Range, const _Ty& _Val) const {
            return _Rewrap_iterator(_Range, _Uninitialized_fill_unchecked(_Ubegin(_Range), _Uend(_Range), _Val));
        }

    private:
        template <class _It, class _Se, class _Ty>
        [[nodiscard]] static _It _Uninitialized_fill_unchecked(_It _OFirst, _Se _OLast, const _Ty& _Val) {
             ;
             ;
             ;

            if constexpr (_Fill_memset_is_safe<_It, _Ty>) {
                const auto _OFinal = ::std::ranges:: next(_OFirst, ::std:: move(_OLast));
                _Fill_memset(_OFirst, _Val, static_cast<size_t>(_OFinal - _OFirst));
                return _OFinal;
            } else {
                if constexpr (_Fill_zero_memset_is_safe<_It, _Ty>) {
                    if (_Is_all_bits_zero(_Val)) {
                        const auto _OFinal = ::std::ranges:: next(_OFirst, ::std:: move(_OLast));
                        _Fill_zero_memset(_OFirst, static_cast<size_t>(_OFinal - _OFirst));
                        return _OFinal;
                    }
                }

                _Uninitialized_backout _Backout{::std:: move(_OFirst)};

                while (_Backout._Last != _OLast) {
                    _Backout._Emplace_back(_Val);
                }

                return _Backout._Release();
            }
        }
    };

     inline constexpr _Uninitialized_fill_fn uninitialized_fill{_Not_quite_object::_Construct_tag{}};
} 
#line 437 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"

 template <class _NoThrowFwdIt, class _Diff, class _Tval>
_NoThrowFwdIt uninitialized_fill_n(_NoThrowFwdIt _First, const _Diff _Count_raw, const _Tval& _Val) {
    
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (_Count <= 0) {
        return _First;
    }

    auto _UFirst = _Get_unwrapped_n(_First, _Count);
    if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Tval>) {
        _Fill_memset(_UFirst, _Val, static_cast<size_t>(_Count));
        _UFirst += _Count;
    } else {
        if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Tval>) {
            if (_Is_all_bits_zero(_Val)) {
                _Fill_zero_memset(_UFirst, static_cast<size_t>(_Count));
                _Seek_wrapped(_First, _UFirst + _Count);
                return _First;
            }
        }

        _Uninitialized_backout<decltype(_UFirst)> _Backout{_UFirst};

        for (; _Count > 0; --_Count) {
            _Backout._Emplace_back(_Val);
        }

        _UFirst = _Backout._Release();
    }

    _Seek_wrapped(_First, _UFirst);
    return _First;
}


 template <class _ExPo, class _NoThrowFwdIt, class _Diff, class _Tval,
    _Enable_if_execution_policy_t<_ExPo> = 0>
_NoThrowFwdIt uninitialized_fill_n(
    _ExPo&&, const _NoThrowFwdIt _First, const _Diff _Count_raw, const _Tval& _Val) noexcept
  {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_NoThrowFwdIt> && is_lvalue_reference_v<_Iter_ref_t<_NoThrowFwdIt>>, "Parallel specialized <memory> algorithms require the iterator type to be forward iterator and dereference " "to lvalues.") ;

    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    return ::std:: uninitialized_fill_n(_First, _Count, _Val);
}
#line 486 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"


namespace ranges {
    class _Uninitialized_fill_n_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <_No_throw_forward_iterator _It, class _Ty>
            requires constructible_from<iter_value_t<_It>, const _Ty&>
        _It operator()(_It _First, iter_difference_t<_It> _Count, const _Ty& _Val) const {
            if (_Count <= 0) {
                return _First;
            }

            auto _UFirst = _Get_unwrapped_n(::std:: move(_First), _Count);
            if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
                _Fill_memset(_UFirst, _Val, static_cast<size_t>(_Count));
                _Seek_wrapped(_First, _UFirst + _Count);
            } else {
                if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
                    if (_Is_all_bits_zero(_Val)) {
                        _Fill_zero_memset(_UFirst, static_cast<size_t>(_Count));
                        _Seek_wrapped(_First, _UFirst + _Count);
                        return _First;
                    }
                }

                _Uninitialized_backout _Backout{::std:: move(_UFirst)};

                for (; _Count > 0; --_Count) {
                    _Backout._Emplace_back(_Val);
                }

                _Seek_wrapped(_First, _Backout._Release());
            }
            return _First;
        }
    };

     inline constexpr _Uninitialized_fill_n_fn uninitialized_fill_n{_Not_quite_object::_Construct_tag{}};

    class _Construct_at_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        
        template <class _Ty, class... _Types>
            requires requires(void* _Void_ptr, _Types&&... _Args) {
                ::new (_Void_ptr) _Ty(static_cast<_Types&&>(_Args)...);
            }
        constexpr _Ty* operator()(_Ty* _Location, _Types&&... _Args) const
            noexcept(noexcept(::new (const_cast<void*>(static_cast<const volatile void*>(_Location)))
                    _Ty(::std:: forward<_Types>(_Args)...)))   {
            
            [[msvc::constexpr]] return ::new (const_cast<void*>(static_cast<const volatile void*>(_Location)))
                _Ty(::std:: forward<_Types>(_Args)...);
        }
    };

     inline constexpr _Construct_at_fn construct_at{_Not_quite_object::_Construct_tag{}};

    template <_No_throw_input_iterator _It, _No_throw_sentinel_for<_It> _Se>
        requires destructible<iter_value_t<_It>>
    [[nodiscard]] constexpr _It _Destroy_unchecked(_It _First, _Se _Last) noexcept;

    class _Destroy_at_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <destructible _Ty>
        constexpr void operator()(_Ty* const _Location) const noexcept {
            if constexpr (is_array_v<_Ty>) {
                (void) ::std::ranges:: _Destroy_unchecked(::std::ranges:: begin(*_Location), ::std::ranges:: end(*_Location));
            } else {
                _Location->~_Ty();
            }
        }
    };

     inline constexpr _Destroy_at_fn destroy_at{_Not_quite_object::_Construct_tag{}};
} 
#line 568 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"


 template <class _NoThrowFwdIt>
constexpr void destroy(const _NoThrowFwdIt _First, const _NoThrowFwdIt _Last) {
    
    _Adl_verify_range(_First, _Last);
    _Destroy_range(_Get_unwrapped(_First), _Get_unwrapped(_Last));
}

 template <class _ExPo, class _NoThrowFwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
void destroy(_ExPo&& _Exec, _NoThrowFwdIt _First, _NoThrowFwdIt _Last) noexcept; 


namespace ranges {
    template <_No_throw_input_iterator _It, _No_throw_sentinel_for<_It> _Se>
        requires destructible<iter_value_t<_It>>
    [[nodiscard]] constexpr _It _Destroy_unchecked(_It _First, _Se _Last) noexcept {
        if constexpr (is_trivially_destructible_v<iter_value_t<_It>>) {
            ::std::ranges:: advance(_First, ::std:: move(_Last));
        } else {
            for (; _First != _Last; ++_First) {
                ::std::ranges:: destroy_at(::std:: addressof(*_First));
            }
        }

        return _First;
    }

    class _Destroy_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <_No_throw_input_iterator _It, _No_throw_sentinel_for<_It> _Se>
            requires destructible<iter_value_t<_It>>
        constexpr _It operator()(_It _First, _Se _Last) const noexcept {
            _Adl_verify_range(_First, _Last);
            _Seek_wrapped(_First,
                ::std::ranges:: _Destroy_unchecked(_Unwrap_iter<_Se>(::std:: move(_First)), _Unwrap_sent<_It>(::std:: move(_Last))));
            return _First;
        }

        template <_No_throw_input_range _Rng>
            requires destructible<range_value_t<_Rng>>
        constexpr borrowed_iterator_t<_Rng> operator()(_Rng&& _Range) const noexcept {
            auto _First = ::std::ranges:: begin(_Range);
            _Seek_wrapped(
                _First, ::std::ranges:: _Destroy_unchecked(_Unwrap_range_iter<_Rng>(::std:: move(_First)), _Uend(_Range)));
            return _First;
        }
    };

     inline constexpr _Destroy_fn destroy{_Not_quite_object::_Construct_tag{}};
} 
#line 622 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"

 template <class _NoThrowFwdIt, class _Diff>
constexpr _NoThrowFwdIt destroy_n(_NoThrowFwdIt _First, const _Diff _Count_raw) {
    
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (_Count <= 0) {
        return _First;
    }

    auto _UFirst = _Get_unwrapped_n(_First, _Count);
    if constexpr (is_trivially_destructible_v<_Iter_value_t<_NoThrowFwdIt>>) {
        ::std:: advance(_UFirst, _Count);
    } else {
        for (; _Count > 0; --_Count, (void) ++_UFirst) {
            _Destroy_in_place(*_UFirst);
        }
    }

    _Seek_wrapped(_First, _UFirst);
    return _First;
}

 template <class _ExPo, class _NoThrowFwdIt, class _Diff, _Enable_if_execution_policy_t<_ExPo> = 0>
_NoThrowFwdIt destroy_n(_ExPo&& _Exec, _NoThrowFwdIt _First, _Diff _Count_raw) noexcept; 


namespace ranges {
    class _Destroy_n_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <_No_throw_input_iterator _It>
            requires destructible<iter_value_t<_It>>
        constexpr _It operator()(_It _First, const iter_difference_t<_It> _Count_raw) const noexcept {
            _Algorithm_int_t<iter_difference_t<_It>> _Count = _Count_raw;
            if (_Count <= 0) {
                return _First;
            }

            auto _UFirst = _Get_unwrapped_n(::std:: move(_First), _Count);
            if constexpr (is_trivially_destructible_v<iter_value_t<_It>>) {
                ::std::ranges:: advance(_UFirst, _Count);
            } else {
                do {
                    ::std::ranges:: destroy_at(::std:: addressof(*_UFirst));
                    ++_UFirst;
                    --_Count;
                } while (_Count > 0);
            }

            _Seek_wrapped(_First, ::std:: move(_UFirst));
            return _First;
        }
    };

     inline constexpr _Destroy_n_fn destroy_n{_Not_quite_object::_Construct_tag{}};
} 
#line 680 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"

 template <class _NoThrowFwdIt>
void uninitialized_default_construct(const _NoThrowFwdIt _First, const _NoThrowFwdIt _Last) {
    
    using _Ty = remove_reference_t<_Iter_ref_t<_NoThrowFwdIt>>;
    _Adl_verify_range(_First, _Last);
    if constexpr (!is_trivially_default_constructible_v<_Ty>) {
        _Uninitialized_backout _Backout{_Get_unwrapped(_First)};

        for (const auto _ULast = _Get_unwrapped(_Last); _Backout._Last != _ULast; ++_Backout._Last) {
            _Default_construct_in_place(*_Backout._Last);
        }

        _Backout._Release();
    }
}

 template <class _ExPo, class _NoThrowFwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
void uninitialized_default_construct(_ExPo&& _Exec, _NoThrowFwdIt _First, _NoThrowFwdIt _Last) noexcept; 


namespace ranges {
    class _Uninitialized_default_construct_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <_No_throw_forward_iterator _It, _No_throw_sentinel_for<_It> _Se>
            requires default_initializable<iter_value_t<_It>>
        _It operator()(_It _First, _Se _Last) const {
            _Adl_verify_range(_First, _Last);
            auto _UResult = _Uninitialized_default_construct_unchecked(
                _Unwrap_iter<_Se>(::std:: move(_First)), _Unwrap_sent<_It>(::std:: move(_Last)));

            _Seek_wrapped(_First, ::std:: move(_UResult));
            return _First;
        }

        template <_No_throw_forward_range _Rng>
            requires default_initializable<range_value_t<_Rng>>
        borrowed_iterator_t<_Rng> operator()(_Rng&& _Range) const {
            auto _UResult = _Uninitialized_default_construct_unchecked(_Ubegin(_Range), _Uend(_Range));

            return _Rewrap_iterator(_Range, ::std:: move(_UResult));
        }

    private:
        template <class _It, class _Se>
        [[nodiscard]] static _It _Uninitialized_default_construct_unchecked(_It _OFirst, const _Se _OLast) {
             ;
             ;
             ;

            using _Ty = remove_reference_t<iter_reference_t<_It>>;
            if constexpr (is_trivially_default_constructible_v<_Ty>) {
                ::std::ranges:: advance(_OFirst, _OLast);
                return _OFirst;
            } else {
                _Uninitialized_backout _Backout{::std:: move(_OFirst)};

                for (; _Backout._Last != _OLast; ++_Backout._Last) {
                    _Default_construct_in_place(*_Backout._Last);
                }

                return _Backout._Release();
            }
        }
    };

     inline constexpr _Uninitialized_default_construct_fn uninitialized_default_construct{
        _Not_quite_object::_Construct_tag{}};
} 
#line 752 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"

 template <class _NoThrowFwdIt, class _Diff>
_NoThrowFwdIt uninitialized_default_construct_n(_NoThrowFwdIt _First, const _Diff _Count_raw) {
    
    using _Ty                      = _Iter_value_t<_NoThrowFwdIt>;
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (_Count <= 0) {
        return _First;
    }

    if constexpr (is_trivially_default_constructible_v<_Ty>) {
        ::std:: advance(_First, _Count);
    } else {
        _Uninitialized_backout _Backout{_Get_unwrapped_n(_First, _Count)};

        for (; _Count > 0; ++_Backout._Last, (void) --_Count) {
            _Default_construct_in_place(*_Backout._Last);
        }

        _Seek_wrapped(_First, _Backout._Release());
    }
    return _First;
}

 template <class _ExPo, class _NoThrowFwdIt, class _Diff, _Enable_if_execution_policy_t<_ExPo> = 0>
_NoThrowFwdIt uninitialized_default_construct_n(
    _ExPo&& _Exec, _NoThrowFwdIt _First, _Diff _Count_raw) noexcept; 


namespace ranges {
    class _Uninitialized_default_construct_n_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <_No_throw_forward_iterator _It>
            requires default_initializable<iter_value_t<_It>>
        _It operator()(_It _First, iter_difference_t<_It> _Count) const {
            if (_Count <= 0) {
                return _First;
            }

            using _Ty = remove_reference_t<iter_reference_t<_It>>;
            if constexpr (is_trivially_default_constructible_v<_Ty>) {
                ::std::ranges:: advance(_First, _Count);
            } else {
                _Uninitialized_backout _Backout{_Get_unwrapped_n(::std:: move(_First), _Count)};

                for (; _Count > 0; --_Count, (void) ++_Backout._Last) {
                    _Default_construct_in_place(*_Backout._Last);
                }

                _Seek_wrapped(_First, _Backout._Release());
            }
            return _First;
        }
    };

     inline constexpr _Uninitialized_default_construct_n_fn uninitialized_default_construct_n{
        _Not_quite_object::_Construct_tag{}};
} 
#line 813 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"

 template <class _NoThrowFwdIt>
void uninitialized_value_construct(const _NoThrowFwdIt _First, const _NoThrowFwdIt _Last) {
    
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    if constexpr (_Use_memset_value_construct_v<_Unwrapped_t<const _NoThrowFwdIt&>>) {
        _Zero_range(_UFirst, _ULast);
    } else {
        _Uninitialized_backout _Backout{_UFirst};

        while (_Backout._Last != _ULast) {
            _Backout._Emplace_back();
        }

        _Backout._Release();
    }
}

 template <class _ExPo, class _NoThrowFwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
void uninitialized_value_construct(_ExPo&& _Exec, _NoThrowFwdIt _First, _NoThrowFwdIt _Last) noexcept; 


namespace ranges {
    class _Uninitialized_value_construct_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <_No_throw_forward_iterator _It, _No_throw_sentinel_for<_It> _Se>
            requires default_initializable<iter_value_t<_It>>
        _It operator()(_It _First, _Se _Last) const {
            _Adl_verify_range(_First, _Last);
            auto _UResult = _Uninitialized_value_construct_unchecked(
                _Unwrap_iter<_Se>(::std:: move(_First)), _Unwrap_sent<_It>(::std:: move(_Last)));

            _Seek_wrapped(_First, ::std:: move(_UResult));
            return _First;
        }

        template <_No_throw_forward_range _Rng>
            requires default_initializable<range_value_t<_Rng>>
        borrowed_iterator_t<_Rng> operator()(_Rng&& _Range) const {
            auto _UResult = _Uninitialized_value_construct_unchecked(_Ubegin(_Range), _Uend(_Range));

            return _Rewrap_iterator(_Range, ::std:: move(_UResult));
        }

    private:
        template <class _It, class _Se>
        [[nodiscard]] static _It _Uninitialized_value_construct_unchecked(_It _OFirst, _Se _OLast) {
             ;
             ;
             ;

            if constexpr (_Use_memset_value_construct_v<_It>) {
                return _Zero_range(_OFirst, ::std::ranges:: next(_OFirst, ::std:: move(_OLast)));
            } else {
                _Uninitialized_backout _Backout{::std:: move(_OFirst)};

                while (_Backout._Last != _OLast) {
                    _Backout._Emplace_back();
                }

                return _Backout._Release();
            }
        }
    };

     inline constexpr _Uninitialized_value_construct_fn uninitialized_value_construct{
        _Not_quite_object::_Construct_tag{}};
} 
#line 886 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"

 template <class _NoThrowFwdIt, class _Diff>
_NoThrowFwdIt uninitialized_value_construct_n(_NoThrowFwdIt _First, const _Diff _Count_raw) {
    
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (_Count <= 0) {
        return _First;
    }

    _Seek_wrapped(_First, _Uninitialized_value_construct_n_unchecked1(_Get_unwrapped_n(_First, _Count), _Count));
    return _First;
}

 template <class _ExPo, class _NoThrowFwdIt, class _Diff, _Enable_if_execution_policy_t<_ExPo> = 0>
_NoThrowFwdIt uninitialized_value_construct_n(
    _ExPo&& _Exec, _NoThrowFwdIt _First, const _Diff _Count_raw) noexcept; 


namespace ranges {
    class _Uninitialized_value_construct_n_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <_No_throw_forward_iterator _It>
            requires default_initializable<iter_value_t<_It>>
        _It operator()(_It _First, iter_difference_t<_It> _Count) const {
            if (_Count <= 0) {
                return _First;
            }

            auto _UFirst = _Get_unwrapped_n(::std:: move(_First), _Count);
            if constexpr (_Use_memset_value_construct_v<_It>) {
                _Seek_wrapped(_First, _Zero_range(_UFirst, _UFirst + _Count));
            } else {
                _Uninitialized_backout _Backout{::std:: move(_UFirst)};

                for (; _Count > 0; --_Count) {
                    _Backout._Emplace_back();
                }

                _Seek_wrapped(_First, _Backout._Release());
            }
            return _First;
        }
    };

     inline constexpr _Uninitialized_value_construct_n_fn uninitialized_value_construct_n{
        _Not_quite_object::_Construct_tag{}};
} 
#line 936 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"
#line 937 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"


















































#line 988 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"













































































































#line 1098 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"


 class bad_weak_ptr : public exception { 
public:
    bad_weak_ptr() noexcept {}

    [[nodiscard]] const char*  what() const noexcept override {
        
        return "bad_weak_ptr";
    }
};

[[noreturn]] inline void _Throw_bad_weak_ptr() {
    throw bad_weak_ptr{} ;
}

class __declspec(novtable) _Ref_count_base { 
private:










    virtual void _Destroy() noexcept     = 0; 
    virtual void _Delete_this() noexcept = 0; 
#line 1129 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"

    _Atomic_counter_t _Uses  = 1;
    _Atomic_counter_t _Weaks = 1;

protected:
    constexpr _Ref_count_base() noexcept = default; 

public:
    _Ref_count_base(const _Ref_count_base&)            = delete;
    _Ref_count_base& operator=(const _Ref_count_base&) = delete;

    virtual ~_Ref_count_base() noexcept {} 

    bool _Incref_nz() noexcept { 
        auto& _Volatile_uses = reinterpret_cast<volatile long&>(_Uses);



        long _Count = __iso_volatile_load32(reinterpret_cast<volatile int*>(&_Volatile_uses));
#line 1149 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"
        while (_Count != 0) {
            const long _Old_value = _InterlockedCompareExchange (&_Volatile_uses, _Count + 1, _Count);
            if (_Old_value == _Count) {
                return true;
            }

            _Count = _Old_value;
        }

        return false;
    }

    void _Incref() noexcept { 
        _InterlockedIncrement(reinterpret_cast<volatile long*>(&_Uses)) ;
    }

    void _Incwref() noexcept { 
        _InterlockedIncrement(reinterpret_cast<volatile long*>(&_Weaks)) ;
    }

    void _Decref() noexcept { 
        if (_InterlockedDecrement(reinterpret_cast<volatile long*>(&_Uses)) == 0) {
            _Destroy();
            _Decwref();
        }
    }

    void _Decwref() noexcept { 
        if (_InterlockedDecrement(reinterpret_cast<volatile long*>(&_Weaks)) == 0) {
            _Delete_this();
        }
    }

    long _Use_count() const noexcept {
        return static_cast<long>(_Uses);
    }

    virtual void* _Get_deleter(const type_info&) const noexcept {
        return nullptr;
    }
};

template <class _Ty>
class _Ref_count : public _Ref_count_base { 
public:
    explicit _Ref_count(_Ty* _Px) : _Ref_count_base(), _Ptr(_Px) {}

private:
    void _Destroy() noexcept override { 
        delete _Ptr;
    }

    void _Delete_this() noexcept override { 
        delete this;
    }

    _Ty* _Ptr;
};

template <class _Resource, class _Dx>
class _Ref_count_resource : public _Ref_count_base { 
public:
    _Ref_count_resource(_Resource _Px, _Dx _Dt)
        : _Ref_count_base(), _Mypair(_One_then_variadic_args_t{}, ::std:: move(_Dt), _Px) {}




    ~_Ref_count_resource() noexcept override = default; 
#line 1219 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"

    void* _Get_deleter(const type_info& _Typeid) const noexcept override {

        if (_Typeid == typeid(_Dx)) {
            return const_cast<_Dx*>(::std:: addressof(_Mypair._Get_first()));
        }


#line 1228 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"

        return nullptr;
    }

private:
    void _Destroy() noexcept override { 
        _Mypair._Get_first()(_Mypair._Myval2);
    }

    void _Delete_this() noexcept override { 
        delete this;
    }

    _Compressed_pair<_Dx, _Resource> _Mypair;
};

template <class _Resource, class _Dx, class _Alloc>
class _Ref_count_resource_alloc : public _Ref_count_base {
    
public:
    _Ref_count_resource_alloc(_Resource _Px, _Dx _Dt, const _Alloc& _Ax)
        : _Ref_count_base(),
          _Mypair(_One_then_variadic_args_t{}, ::std:: move(_Dt), _One_then_variadic_args_t{}, _Ax, _Px) {}




    ~_Ref_count_resource_alloc() noexcept override = default; 
#line 1257 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"

    void* _Get_deleter(const type_info& _Typeid) const noexcept override {

        if (_Typeid == typeid(_Dx)) {
            return const_cast<_Dx*>(::std:: addressof(_Mypair._Get_first()));
        }


#line 1266 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"

        return nullptr;
    }

private:
    using _Myalty = _Rebind_alloc_t<_Alloc, _Ref_count_resource_alloc>;

    void _Destroy() noexcept override { 
        _Mypair._Get_first()(_Mypair._Myval2._Myval2);
    }

    void _Delete_this() noexcept override { 
        _Myalty _Al = _Mypair._Myval2._Get_first();
        this->~_Ref_count_resource_alloc();
        _Deallocate_plain(_Al, this);
    }

    _Compressed_pair<_Dx, _Compressed_pair<_Myalty, _Resource>> _Mypair;
};

 template <class _Ty>
struct default_delete;

 template <class _Ty, class _Dx = default_delete<_Ty>>
class unique_ptr;

 template <class _Ty>
class shared_ptr;

 template <class _Ty>
class weak_ptr;

template <class _Yty, class = void>
struct _Can_enable_shared : false_type {}; 

template <class _Yty>
struct _Can_enable_shared<_Yty, void_t<typename _Yty::_Esft_type>>
    : is_convertible<remove_cv_t<_Yty>*, typename _Yty::_Esft_type*>::type {
    
};

struct _Exception_ptr_access;

template <class _Ty>
class _Ptr_base { 
public:
    using element_type = remove_extent_t<_Ty>;

    [[nodiscard]] long use_count() const noexcept {
        return _Rep ? _Rep->_Use_count() : 0;
    }

    template <class _Ty2>
    [[nodiscard]] bool owner_before(const _Ptr_base<_Ty2>& _Right) const noexcept { 
        return _Rep < _Right._Rep;
    }

    _Ptr_base(const _Ptr_base&)            = delete;
    _Ptr_base& operator=(const _Ptr_base&) = delete;

protected:
    [[nodiscard]] element_type* get() const noexcept {
        return _Ptr;
    }

    constexpr _Ptr_base() noexcept = default;

    ~_Ptr_base() = default;

    template <class _Ty2>
    void _Move_construct_from(_Ptr_base<_Ty2>&& _Right) noexcept {
        
        _Ptr = _Right._Ptr;
        _Rep = _Right._Rep;

        _Right._Ptr = nullptr;
        _Right._Rep = nullptr;
    }

    template <class _Ty2>
    void _Copy_construct_from(const shared_ptr<_Ty2>& _Other) noexcept {
        
        _Other._Incref();

        _Ptr = _Other._Ptr;
        _Rep = _Other._Rep;
    }

    template <class _Ty2>
    void _Alias_construct_from(const shared_ptr<_Ty2>& _Other, element_type* _Px) noexcept {
        
        _Other._Incref();

        _Ptr = _Px;
        _Rep = _Other._Rep;
    }

    template <class _Ty2>
    void _Alias_move_construct_from(shared_ptr<_Ty2>&& _Other, element_type* _Px) noexcept {
        
        _Ptr = _Px;
        _Rep = _Other._Rep;

        _Other._Ptr = nullptr;
        _Other._Rep = nullptr;
    }

    template <class _Ty0>
    friend class weak_ptr; 

    template <class _Ty2>
    bool _Construct_from_weak(const weak_ptr<_Ty2>& _Other) noexcept {
        
        if (_Other._Rep && _Other._Rep->_Incref_nz()) {
            _Ptr = _Other._Ptr;
            _Rep = _Other._Rep;
            return true;
        }

        return false;
    }

    void _Incref() const noexcept {
        if (_Rep) {
            _Rep->_Incref();
        }
    }

    void _Decref() noexcept { 
        if (_Rep) {
            _Rep->_Decref();
        }
    }

    void _Swap(_Ptr_base& _Right) noexcept { 
        ::std:: swap(_Ptr, _Right._Ptr);
        ::std:: swap(_Rep, _Right._Rep);
    }

    template <class _Ty2>
    void _Weakly_construct_from(const _Ptr_base<_Ty2>& _Other) noexcept { 
        if (_Other._Rep) {
            _Ptr = _Other._Ptr;
            _Rep = _Other._Rep;
            _Rep->_Incwref();
        } else {
             ;
        }
    }

    template <class _Ty2>
    void _Weakly_convert_lvalue_avoiding_expired_conversions(const _Ptr_base<_Ty2>& _Other) noexcept {
        
        if (_Other._Rep) {
            _Rep = _Other._Rep; 
            _Rep->_Incwref();

            if (_Rep->_Incref_nz()) {
                _Ptr = _Other._Ptr; 
                _Rep->_Decref();
            } else {
                 ;
            }
        } else {
             ;
        }
    }

    template <class _Ty2>
    void _Weakly_convert_rvalue_avoiding_expired_conversions(_Ptr_base<_Ty2>&& _Other) noexcept {
        
        _Rep        = _Other._Rep; 
        _Other._Rep = nullptr;

        if (_Rep && _Rep->_Incref_nz()) {
            _Ptr = _Other._Ptr; 
            _Rep->_Decref();
        } else {
             ;
        }

        _Other._Ptr = nullptr;
    }

    void _Incwref() const noexcept {
        if (_Rep) {
            _Rep->_Incwref();
        }
    }

    void _Decwref() noexcept { 
        if (_Rep) {
            _Rep->_Decwref();
        }
    }

private:
    element_type* _Ptr{nullptr};
    _Ref_count_base* _Rep{nullptr};

    template <class _Ty0>
    friend class _Ptr_base;

    friend shared_ptr<_Ty>;

    template <class _Ty0>
    friend struct atomic;

    friend _Exception_ptr_access;


    template <class _Dx, class _Ty0>
    friend _Dx* get_deleter(const shared_ptr<_Ty0>& _Sx) noexcept;
#line 1480 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"
};

template <class _Yty, class = void>
struct _Can_scalar_delete : false_type {};
template <class _Yty>
struct _Can_scalar_delete<_Yty, void_t<decltype(delete ::std:: declval<_Yty*>())>> : true_type {};

template <class _Yty, class = void>
struct _Can_array_delete : false_type {};
template <class _Yty>
struct _Can_array_delete<_Yty, void_t<decltype(delete[] ::std:: declval<_Yty*>())>> : true_type{};

template <class _Fx, class _Arg, class = void>
struct _Can_call_function_object : false_type {};
template <class _Fx, class _Arg>
struct _Can_call_function_object<_Fx, _Arg, void_t<decltype(::std:: declval<_Fx>()(::std:: declval<_Arg>()))>> : true_type {};

template <class _Yty, class _Ty>
struct _SP_convertible : is_convertible<_Yty*, _Ty*>::type {};
template <class _Yty, class _Uty>
struct _SP_convertible<_Yty, _Uty[]> : is_convertible<_Yty (*)[], _Uty (*)[]>::type {};
template <class _Yty, class _Uty, size_t _Ext>
struct _SP_convertible<_Yty, _Uty[_Ext]> : is_convertible<_Yty (*)[_Ext], _Uty (*)[_Ext]>::type {};

template <class _Yty, class _Ty>
struct _SP_pointer_compatible : is_convertible<_Yty*, _Ty*>::type {
    
    
};
template <class _Uty, size_t _Ext>
struct _SP_pointer_compatible<_Uty[_Ext], _Uty[]> : true_type {
    
};
template <class _Uty, size_t _Ext>
struct _SP_pointer_compatible<_Uty[_Ext], const _Uty[]> : true_type {
    
};
template <class _Uty, size_t _Ext>
struct _SP_pointer_compatible<_Uty[_Ext], volatile _Uty[]> : true_type {
    
};
template <class _Uty, size_t _Ext>
struct _SP_pointer_compatible<_Uty[_Ext], const volatile _Uty[]> : true_type {
    
};

template <class _Ux>
struct _Temporary_owner {
    _Ux* _Ptr;

    explicit _Temporary_owner(_Ux* const _Ptr_) noexcept : _Ptr(_Ptr_) {}
    _Temporary_owner(const _Temporary_owner&)            = delete;
    _Temporary_owner& operator=(const _Temporary_owner&) = delete;
    ~_Temporary_owner() {
        delete _Ptr;
    }
};

template <class _UxptrOrNullptr, class _Dx>
struct _Temporary_owner_del {
    _UxptrOrNullptr _Ptr;
    _Dx& _Dt;
    bool _Call_deleter = true;

    explicit _Temporary_owner_del(const _UxptrOrNullptr _Ptr_, _Dx& _Dt_) noexcept : _Ptr(_Ptr_), _Dt(_Dt_) {}
    _Temporary_owner_del(const _Temporary_owner_del&)            = delete;
    _Temporary_owner_del& operator=(const _Temporary_owner_del&) = delete;
    ~_Temporary_owner_del() {
        if (_Call_deleter) {
            _Dt(_Ptr);
        }
    }
};

 template <class _Ty>
class shared_ptr : public _Ptr_base<_Ty> { 
private:
    using _Mybase = _Ptr_base<_Ty>;

public:
    using typename _Mybase::element_type;


    using weak_type = weak_ptr<_Ty>;
#line 1565 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"

    constexpr shared_ptr() noexcept = default;

    constexpr shared_ptr(nullptr_t) noexcept {} 

    template <class _Ux,
        enable_if_t<conjunction_v<conditional_t<is_array_v<_Ty>, _Can_array_delete<_Ux>, _Can_scalar_delete<_Ux>>,
                        _SP_convertible<_Ux, _Ty>>,
            int> = 0>
    explicit shared_ptr(_Ux* _Px) { 
        if constexpr (is_array_v<_Ty>) {
            _Setpd(_Px, default_delete<_Ux[]>{});
        } else {
            _Temporary_owner<_Ux> _Owner(_Px);
            _Set_ptr_rep_and_enable_shared(_Owner._Ptr, new _Ref_count<_Ux>(_Owner._Ptr));
            _Owner._Ptr = nullptr;
        }
    }

    template <class _Ux, class _Dx,
        enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx&, _Ux*&>,
                        _SP_convertible<_Ux, _Ty>>,
            int> = 0>
    shared_ptr(_Ux* _Px, _Dx _Dt) { 
        _Setpd(_Px, ::std:: move(_Dt));
    }

    template <class _Ux, class _Dx, class _Alloc,
        enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx&, _Ux*&>,
                        _SP_convertible<_Ux, _Ty>>,
            int> = 0>
    shared_ptr(_Ux* _Px, _Dx _Dt, _Alloc _Ax) { 
        _Setpda(_Px, ::std:: move(_Dt), _Ax);
    }

    template <class _Dx,
        enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx&, nullptr_t&>>, int> = 0>
    shared_ptr(nullptr_t, _Dx _Dt) { 
        _Setpd(nullptr, ::std:: move(_Dt));
    }

    template <class _Dx, class _Alloc,
        enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx&, nullptr_t&>>, int> = 0>
    shared_ptr(nullptr_t, _Dx _Dt, _Alloc _Ax) { 
        _Setpda(nullptr, ::std:: move(_Dt), _Ax);
    }

    template <class _Ty2>
    shared_ptr(const shared_ptr<_Ty2>& _Right, element_type* _Px) noexcept {
        
        this->_Alias_construct_from(_Right, _Px);
    }

    template <class _Ty2>
    shared_ptr(shared_ptr<_Ty2>&& _Right, element_type* _Px) noexcept {
        
        this->_Alias_move_construct_from(::std:: move(_Right), _Px);
    }

    shared_ptr(const shared_ptr& _Other) noexcept { 
        this->_Copy_construct_from(_Other);
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    shared_ptr(const shared_ptr<_Ty2>& _Other) noexcept {
        
        this->_Copy_construct_from(_Other);
    }

    shared_ptr(shared_ptr&& _Right) noexcept { 
        this->_Move_construct_from(::std:: move(_Right));
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    shared_ptr(shared_ptr<_Ty2>&& _Right) noexcept { 
        this->_Move_construct_from(::std:: move(_Right));
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    explicit shared_ptr(const weak_ptr<_Ty2>& _Other) { 
        if (!this->_Construct_from_weak(_Other)) {
            _Throw_bad_weak_ptr();
        }
    }








#line 1658 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"

    template <class _Ux, class _Dx,
        enable_if_t<conjunction_v<_SP_pointer_compatible<_Ux, _Ty>,
                        is_convertible<typename unique_ptr<_Ux, _Dx>::pointer, element_type*>>,
            int> = 0>
    shared_ptr(unique_ptr<_Ux, _Dx>&& _Other) {
        using _Fancy_t   = typename unique_ptr<_Ux, _Dx>::pointer;
        using _Raw_t     = typename unique_ptr<_Ux, _Dx>::element_type*;
        using _Deleter_t = conditional_t<is_reference_v<_Dx>, decltype(::std:: ref(_Other.get_deleter())), _Dx>;

        const _Fancy_t _Fancy = _Other.get();

        if (_Fancy) {
            const _Raw_t _Raw = _Fancy;
            const auto _Rx =
                new _Ref_count_resource<_Fancy_t, _Deleter_t>(_Fancy, ::std:: forward<_Dx>(_Other.get_deleter()));
            _Set_ptr_rep_and_enable_shared(_Raw, _Rx);
            _Other.release();
        }
    }

    ~shared_ptr() noexcept { 
        this->_Decref();
    }

    shared_ptr& operator=(const shared_ptr& _Right) noexcept {
        shared_ptr(_Right).swap(*this);
        return *this;
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    shared_ptr& operator=(const shared_ptr<_Ty2>& _Right) noexcept {
        shared_ptr(_Right).swap(*this);
        return *this;
    }

    shared_ptr& operator=(shared_ptr&& _Right) noexcept { 
        shared_ptr(::std:: move(_Right)).swap(*this);
        return *this;
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    shared_ptr& operator=(shared_ptr<_Ty2>&& _Right) noexcept { 
        shared_ptr(::std:: move(_Right)).swap(*this);
        return *this;
    }







#line 1712 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"

    template <class _Ux, class _Dx,
        enable_if_t<conjunction_v<_SP_pointer_compatible<_Ux, _Ty>,
                        is_convertible<typename unique_ptr<_Ux, _Dx>::pointer, element_type*>>,
            int> = 0>
    shared_ptr& operator=(unique_ptr<_Ux, _Dx>&& _Right) { 
        shared_ptr(::std:: move(_Right)).swap(*this);
        return *this;
    }

    void swap(shared_ptr& _Other) noexcept {
        this->_Swap(_Other);
    }

    void reset() noexcept { 
        shared_ptr().swap(*this);
    }

    template <class _Ux,
        enable_if_t<conjunction_v<conditional_t<is_array_v<_Ty>, _Can_array_delete<_Ux>, _Can_scalar_delete<_Ux>>,
                        _SP_convertible<_Ux, _Ty>>,
            int> = 0>
    void reset(_Ux* _Px) { 
        shared_ptr(_Px).swap(*this);
    }

    template <class _Ux, class _Dx,
        enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx&, _Ux*&>,
                        _SP_convertible<_Ux, _Ty>>,
            int> = 0>
    void reset(_Ux* _Px, _Dx _Dt) { 
        shared_ptr(_Px, _Dt).swap(*this);
    }

    template <class _Ux, class _Dx, class _Alloc,
        enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx&, _Ux*&>,
                        _SP_convertible<_Ux, _Ty>>,
            int> = 0>
    void reset(_Ux* _Px, _Dx _Dt, _Alloc _Ax) { 
        shared_ptr(_Px, _Dt, _Ax).swap(*this);
    }

    using _Mybase::get;

    template <class _Ty2 = _Ty, enable_if_t<!disjunction_v<is_array<_Ty2>, is_void<_Ty2>>, int> = 0>
    [[nodiscard]] _Ty2& operator*() const noexcept {
        return *get();
    }

    template <class _Ty2 = _Ty, enable_if_t<!is_array_v<_Ty2>, int> = 0>
    [[nodiscard]] _Ty2* operator->() const noexcept {
        return get();
    }

    template <class _Ty2 = _Ty, class _Elem = element_type, enable_if_t<is_array_v<_Ty2>, int> = 0>
    [[nodiscard]] _Elem& operator[](ptrdiff_t _Idx) const noexcept   {
        return get()[_Idx];
    }






#line 1777 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"

    explicit operator bool() const noexcept {
        return get() != nullptr;
    }

private:
    template <class _UxptrOrNullptr, class _Dx>
    void _Setpd(const _UxptrOrNullptr _Px, _Dx _Dt) { 
        _Temporary_owner_del<_UxptrOrNullptr, _Dx> _Owner(_Px, _Dt);
        _Set_ptr_rep_and_enable_shared(
            _Owner._Ptr, new _Ref_count_resource<_UxptrOrNullptr, _Dx>(_Owner._Ptr, ::std:: move(_Dt)));
        _Owner._Call_deleter = false;
    }

    template <class _UxptrOrNullptr, class _Dx, class _Alloc>
    void _Setpda(const _UxptrOrNullptr _Px, _Dx _Dt, _Alloc _Ax) { 
        using _Alref_alloc = _Rebind_alloc_t<_Alloc, _Ref_count_resource_alloc<_UxptrOrNullptr, _Dx, _Alloc>>;

        _Temporary_owner_del<_UxptrOrNullptr, _Dx> _Owner(_Px, _Dt);
        _Alref_alloc _Alref(_Ax);
        _Alloc_construct_ptr<_Alref_alloc> _Constructor(_Alref);
        _Constructor._Allocate();
        _Construct_in_place(*_Constructor._Ptr, _Owner._Ptr, ::std:: move(_Dt), _Ax);
        _Set_ptr_rep_and_enable_shared(_Owner._Ptr, _Unfancy(_Constructor._Ptr));
        _Constructor._Ptr    = nullptr;
        _Owner._Call_deleter = false;
    }


    template <class _Ty0, class... _Types>
    friend enable_if_t<!is_array_v<_Ty0>, shared_ptr<_Ty0>> make_shared(_Types&&... _Args);

    template <class _Ty0, class _Alloc, class... _Types>
    friend enable_if_t<!is_array_v<_Ty0>, shared_ptr<_Ty0>> allocate_shared(const _Alloc& _Al_arg, _Types&&... _Args);

    template <class _Ty0>
    friend enable_if_t<is_bounded_array_v<_Ty0>, shared_ptr<_Ty0>> make_shared();

    template <class _Ty0, class _Alloc>
    friend enable_if_t<is_bounded_array_v<_Ty0>, shared_ptr<_Ty0>> allocate_shared(const _Alloc& _Al_arg);

    template <class _Ty0>
    friend enable_if_t<is_bounded_array_v<_Ty0>, shared_ptr<_Ty0>> make_shared(const remove_extent_t<_Ty0>& _Val);

    template <class _Ty0, class _Alloc>
    friend enable_if_t<is_bounded_array_v<_Ty0>, shared_ptr<_Ty0>> allocate_shared(
        const _Alloc& _Al_arg, const remove_extent_t<_Ty0>& _Val);

    template <class _Ty0>
    friend enable_if_t<!is_unbounded_array_v<_Ty0>, shared_ptr<_Ty0>> make_shared_for_overwrite();

    template <class _Ty0, class _Alloc>
    friend enable_if_t<!is_unbounded_array_v<_Ty0>, shared_ptr<_Ty0>> allocate_shared_for_overwrite(
        const _Alloc& _Al_arg);

    template <class _Ty0, class... _ArgTypes>
    friend shared_ptr<_Ty0> _Make_shared_unbounded_array(size_t _Count, const _ArgTypes&... _Args);

    template <class _Ty0, class _Alloc, class... _ArgTypes>
    friend shared_ptr<_Ty0> _Allocate_shared_unbounded_array(
        const _Alloc& _Al, size_t _Count, const _ArgTypes&... _Args);






#line 1845 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"

    template <class _Ux>
    void _Set_ptr_rep_and_enable_shared(_Ux* const _Px, _Ref_count_base* const _Rx) noexcept { 
        this->_Ptr = _Px;
        this->_Rep = _Rx;
        if constexpr (conjunction_v<negation<is_array<_Ty>>, negation<is_volatile<_Ux>>, _Can_enable_shared<_Ux>>) {
            if (_Px && _Px->_Wptr.expired()) {
                _Px->_Wptr = shared_ptr<remove_cv_t<_Ux>>(*this, const_cast<remove_cv_t<_Ux>*>(_Px));
            }
        }
    }

    void _Set_ptr_rep_and_enable_shared(nullptr_t, _Ref_count_base* const _Rx) noexcept { 
        this->_Ptr = nullptr;
        this->_Rep = _Rx;
    }
};


template <class _Ty>
shared_ptr(weak_ptr<_Ty>) -> shared_ptr<_Ty>;

template <class _Ty, class _Dx>
shared_ptr(unique_ptr<_Ty, _Dx>) -> shared_ptr<_Ty>;
#line 1870 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"

 template <class _Ty1, class _Ty2>
[[nodiscard]] bool operator==(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept {
    return _Left.get() == _Right.get();
}


 template <class _Ty1, class _Ty2>
[[nodiscard]] strong_ordering operator<=>(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept {
    return _Left.get() <=> _Right.get();
}

























#line 1907 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"

 template <class _Ty>
[[nodiscard]] bool operator==(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept {
    return _Left.get() == nullptr;
}


 template <class _Ty>
[[nodiscard]] strong_ordering operator<=>(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept {
    return _Left.get() <=> static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr);
}























































#line 1974 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"

 template <class _Elem, class _Traits, class _Ty>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Out, const shared_ptr<_Ty>& _Px) {
    
    return _Out << _Px.get();
}

 template <class _Ty>
void swap(shared_ptr<_Ty>& _Left, shared_ptr<_Ty>& _Right) noexcept {
    _Left.swap(_Right);
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] shared_ptr<_Ty1> static_pointer_cast(const shared_ptr<_Ty2>& _Other) noexcept {
    
    const auto _Ptr = static_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());
    return shared_ptr<_Ty1>(_Other, _Ptr);
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] shared_ptr<_Ty1> static_pointer_cast(shared_ptr<_Ty2>&& _Other) noexcept {
    
    const auto _Ptr = static_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());
    return shared_ptr<_Ty1>(::std:: move(_Other), _Ptr);
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] shared_ptr<_Ty1> const_pointer_cast(const shared_ptr<_Ty2>& _Other) noexcept {
    
    const auto _Ptr = const_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());
    return shared_ptr<_Ty1>(_Other, _Ptr);
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] shared_ptr<_Ty1> const_pointer_cast(shared_ptr<_Ty2>&& _Other) noexcept {
    
    const auto _Ptr = const_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());
    return shared_ptr<_Ty1>(::std:: move(_Other), _Ptr);
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] shared_ptr<_Ty1> reinterpret_pointer_cast(const shared_ptr<_Ty2>& _Other) noexcept {
    
    const auto _Ptr = reinterpret_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());
    return shared_ptr<_Ty1>(_Other, _Ptr);
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] shared_ptr<_Ty1> reinterpret_pointer_cast(shared_ptr<_Ty2>&& _Other) noexcept {
    
    const auto _Ptr = reinterpret_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());
    return shared_ptr<_Ty1>(::std:: move(_Other), _Ptr);
}


 template <class _Ty1, class _Ty2>
[[nodiscard]] shared_ptr<_Ty1> dynamic_pointer_cast(const shared_ptr<_Ty2>& _Other) noexcept {
    
    const auto _Ptr = dynamic_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());

    if (_Ptr) {
        return shared_ptr<_Ty1>(_Other, _Ptr);
    }

    return {};
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] shared_ptr<_Ty1> dynamic_pointer_cast(shared_ptr<_Ty2>&& _Other) noexcept {
    
    const auto _Ptr = dynamic_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());

    if (_Ptr) {
        return shared_ptr<_Ty1>(::std:: move(_Other), _Ptr);
    }

    return {};
}





#line 2058 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"


 template <class _Dx, class _Ty>
[[nodiscard]] _Dx* get_deleter(const shared_ptr<_Ty>& _Sx) noexcept {
    
    if (_Sx._Rep) {
        return static_cast<_Dx*>(_Sx._Rep->_Get_deleter(typeid(_Dx)));
    }

    return nullptr;
}



#line 2073 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"


struct _For_overwrite_tag {
    explicit _For_overwrite_tag() = default;
};
#line 2079 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"

template <class _Ty>
class _Ref_count_obj2 : public _Ref_count_base { 
public:
    template <class... _Types>
    explicit _Ref_count_obj2(_Types&&... _Args) : _Ref_count_base() {

        if constexpr (sizeof...(_Types) == 1 && (is_same_v<_For_overwrite_tag, remove_cvref_t<_Types>> && ...)) {
            _Default_construct_in_place(_Storage._Value);
            ((void) _Args, ...);
        } else
#line 2091 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"
        {
            _Construct_in_place(_Storage._Value, ::std:: forward<_Types>(_Args)...);
        }
    }

    ~_Ref_count_obj2() noexcept override { 
        

        
        
        
    }

    union {
        _Wrap<_Ty> _Storage;
    };

private:
    void _Destroy() noexcept override { 
        _Destroy_in_place(_Storage._Value);
    }

    void _Delete_this() noexcept override { 
        delete this;
    }
};


template <size_t _Align>
struct _Alignas_storage_unit {
    alignas(_Align) char _Space[_Align];
};

enum class _Check_overflow : bool { _Nope, _Yes };

template <class _Refc, _Check_overflow _Check>
[[nodiscard]] size_t _Calculate_bytes_for_flexible_array(const size_t _Count) noexcept(_Check == _Check_overflow::_Nope) {
    constexpr size_t _Align = alignof(_Refc);

    size_t _Bytes = sizeof(_Refc); 

    if (_Count > 1) {
        constexpr size_t _Element_size = sizeof(typename _Refc::_Element_type);

        size_t _Extra_bytes;

        if constexpr (_Check == _Check_overflow::_Yes) {
            _Extra_bytes = _Get_size_of_n<_Element_size>(_Count - 1); 

            if (_Extra_bytes > static_cast<size_t>(-1) - _Bytes - (_Align - 1)) { 
                _Throw_bad_array_new_length(); 
            }
        } else {
            _Extra_bytes = _Element_size * (_Count - 1);
        }

        _Bytes += _Extra_bytes;

        _Bytes = (_Bytes + _Align - 1) & ~(_Align - 1);
    }






    return _Bytes;
}

template <class _Refc>
[[nodiscard]] _Refc* _Allocate_flexible_array(const size_t _Count) {
    const size_t _Bytes = _Calculate_bytes_for_flexible_array<_Refc, _Check_overflow::_Yes>(_Count);

    constexpr size_t _Align = alignof(_Refc);
    if constexpr (_Align > 16ull ) {
        return static_cast<_Refc*>(::operator new(_Bytes, align_val_t{_Align}));
    } else
#line 2169 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"
    {
        return static_cast<_Refc*>(::operator new(_Bytes));
    }
}

template <class _Refc>
void _Deallocate_flexible_array(_Refc* const _Ptr) noexcept {

    constexpr size_t _Align = alignof(_Refc);
    if constexpr (_Align > 16ull ) {
        ::operator delete(static_cast<void*>(_Ptr), align_val_t{_Align});
    } else
#line 2182 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"
    {
        ::operator delete(static_cast<void*>(_Ptr));
    }
}

template <class _NoThrowIt>
struct [[nodiscard]] _Uninitialized_rev_destroying_backout {
    
    _NoThrowIt _First;
    _NoThrowIt _Last;

    explicit _Uninitialized_rev_destroying_backout(_NoThrowIt _Dest) noexcept : _First(_Dest), _Last(_Dest) {}

    _Uninitialized_rev_destroying_backout(const _Uninitialized_rev_destroying_backout&)            = delete;
    _Uninitialized_rev_destroying_backout& operator=(const _Uninitialized_rev_destroying_backout&) = delete;

    ~_Uninitialized_rev_destroying_backout() {
        while (_Last != _First) {
            --_Last;
            ::std:: destroy_at(::std:: addressof(*_Last));
        }
    }

    template <class... _Types>
    void _Emplace_back(_Types&&... _Vals) { 
        _Construct_in_place(*_Last, ::std:: forward<_Types>(_Vals)...);
        ++_Last;
    }

    void _Emplace_back_for_overwrite() {
        _Default_construct_in_place(*_Last);
        ++_Last;
    }

    _NoThrowIt _Release() noexcept { 
        _First = _Last;
        return _Last;
    }
};

template <class _Ty>
void _Reverse_destroy_multidimensional_n(_Ty* const _Arr, size_t _Size) noexcept {
    while (_Size > 0) {
        --_Size;
        if constexpr (is_array_v<_Ty>) {
            _Reverse_destroy_multidimensional_n(_Arr[_Size], extent_v<_Ty>);
        } else {
            _Destroy_in_place(_Arr[_Size]);
        }
    }
}

template <class _Ty>
struct [[nodiscard]] _Reverse_destroy_multidimensional_n_guard {
    _Ty* _Target;
    size_t _Index;

    ~_Reverse_destroy_multidimensional_n_guard() {
        if (_Target) {
            _Reverse_destroy_multidimensional_n(_Target, _Index);
        }
    }
};

template <class _Ty, size_t _Size>
void _Uninitialized_copy_multidimensional(const _Ty (&_In)[_Size], _Ty (&_Out)[_Size]) {
    if constexpr (is_trivial_v<_Ty>) {
        _Copy_memmove_n(_In, _Size, _Out);
    } else if constexpr (is_array_v<_Ty>) {
        _Reverse_destroy_multidimensional_n_guard<_Ty> _Guard{_Out, 0};
        for (size_t& _Idx = _Guard._Index; _Idx < _Size; ++_Idx) {
            _Uninitialized_copy_multidimensional(_In[_Idx], _Out[_Idx]);
        }
        _Guard._Target = nullptr;
    } else {
        _Uninitialized_rev_destroying_backout _Backout{_Out};
        for (size_t _Idx = 0; _Idx < _Size; ++_Idx) {
            _Backout._Emplace_back(_In[_Idx]);
        }
        _Backout._Release();
    }
}

template <class _Ty>
void _Uninitialized_value_construct_multidimensional_n(_Ty* const _Out, const size_t _Size) {
    using _Item = remove_all_extents_t<_Ty>;
    if constexpr (_Use_memset_value_construct_v<_Item*>) {
        _Zero_range(_Out, _Out + _Size);
    } else if constexpr (is_array_v<_Ty>) {
        _Reverse_destroy_multidimensional_n_guard<_Ty> _Guard{_Out, 0};
        for (size_t& _Idx = _Guard._Index; _Idx < _Size; ++_Idx) {
            _Uninitialized_value_construct_multidimensional_n(_Out[_Idx], extent_v<_Ty>);
        }
        _Guard._Target = nullptr;
    } else {
        _Uninitialized_rev_destroying_backout _Backout{_Out};
        for (size_t _Idx = 0; _Idx < _Size; ++_Idx) {
            _Backout._Emplace_back();
        }
        _Backout._Release();
    }
}

template <class _Ty>
void _Uninitialized_default_construct_multidimensional_n(_Ty* const _Out, const size_t _Size) {
    if constexpr (!is_trivially_default_constructible_v<_Ty>) {
        if constexpr (is_array_v<_Ty>) {
            _Reverse_destroy_multidimensional_n_guard<_Ty> _Guard{_Out, 0};
            for (size_t& _Idx = _Guard._Index; _Idx < _Size; ++_Idx) {
                _Uninitialized_default_construct_multidimensional_n(_Out[_Idx], extent_v<_Ty>);
            }
            _Guard._Target = nullptr;
        } else {
            _Uninitialized_rev_destroying_backout _Backout{_Out};
            for (size_t _Idx = 0; _Idx < _Size; ++_Idx) {
                _Backout._Emplace_back_for_overwrite();
            }
            _Backout._Release();
        }
    }
}

template <class _Ty>
void _Uninitialized_fill_multidimensional_n(_Ty* const _Out, const size_t _Size, const _Ty& _Val) {
    if constexpr (is_array_v<_Ty>) {
        _Reverse_destroy_multidimensional_n_guard<_Ty> _Guard{_Out, 0};
        for (size_t& _Idx = _Guard._Index; _Idx < _Size; ++_Idx) {
            _Uninitialized_copy_multidimensional(_Val, _Out[_Idx]); 
        }
        _Guard._Target = nullptr;
    } else if constexpr (_Fill_memset_is_safe<_Ty*, _Ty>) {
        _Fill_memset(_Out, _Val, _Size);
    } else {
        if constexpr (_Fill_zero_memset_is_safe<_Ty*, _Ty>) {
            if (_Is_all_bits_zero(_Val)) {
                _Fill_zero_memset(_Out, _Size);
                return;
            }
        }
        _Uninitialized_rev_destroying_backout _Backout{_Out};
        for (size_t _Idx = 0; _Idx < _Size; ++_Idx) {
            _Backout._Emplace_back(_Val);
        }
        _Backout._Release();
    }
}

template <class _Ty, bool = is_trivially_destructible_v<remove_extent_t<_Ty>>>
class _Ref_count_unbounded_array : public _Ref_count_base {
    
public:
    static_assert(is_unbounded_array_v<_Ty>);

    using _Element_type = remove_extent_t<_Ty>;

    explicit _Ref_count_unbounded_array(const size_t _Count) : _Ref_count_base() {
        _Uninitialized_value_construct_multidimensional_n(_Get_ptr(), _Count);
    }

    template <class _Arg>
    explicit _Ref_count_unbounded_array(const size_t _Count, const _Arg& _Val) : _Ref_count_base() {
        if constexpr (is_same_v<_For_overwrite_tag, _Arg>) {
            _Uninitialized_default_construct_multidimensional_n(_Get_ptr(), _Count);
        } else {
            _Uninitialized_fill_multidimensional_n(_Get_ptr(), _Count, _Val);
        }
    }

    [[nodiscard]] auto _Get_ptr() noexcept {
        return ::std:: addressof(_Storage._Value);
    }

private:
    union {
        _Wrap<_Element_type> _Storage; 
    };

    ~_Ref_count_unbounded_array() noexcept override { 
        

        
    }

    void _Destroy() noexcept override { 
        
    }

    void _Delete_this() noexcept override { 
        this->~_Ref_count_unbounded_array();
        _Deallocate_flexible_array(this);
    }
};

template <class _Ty>
class _Ref_count_unbounded_array<_Ty, false> : public _Ref_count_base {
    
public:
    static_assert(is_unbounded_array_v<_Ty>);

    using _Element_type = remove_extent_t<_Ty>;

    explicit _Ref_count_unbounded_array(const size_t _Count) : _Ref_count_base(), _Size(_Count) {
        _Uninitialized_value_construct_multidimensional_n(_Get_ptr(), _Size);
    }

    template <class _Arg>
    explicit _Ref_count_unbounded_array(const size_t _Count, const _Arg& _Val) : _Ref_count_base(), _Size(_Count) {
        if constexpr (is_same_v<_For_overwrite_tag, _Arg>) {
            _Uninitialized_default_construct_multidimensional_n(_Get_ptr(), _Size);
        } else {
            _Uninitialized_fill_multidimensional_n(_Get_ptr(), _Size, _Val);
        }
    }

    [[nodiscard]] auto _Get_ptr() noexcept {
        return ::std:: addressof(_Storage._Value);
    }

private:
    size_t _Size;

    union {
        _Wrap<_Element_type> _Storage; 
    };

    ~_Ref_count_unbounded_array() noexcept override { 
        

        
    }

    void _Destroy() noexcept override { 
        _Reverse_destroy_multidimensional_n(_Get_ptr(), _Size);
    }

    void _Delete_this() noexcept override { 
        this->~_Ref_count_unbounded_array();
        _Deallocate_flexible_array(this);
    }
};

template <class _Ty>
class _Ref_count_bounded_array : public _Ref_count_base {
    
public:
    static_assert(is_bounded_array_v<_Ty>);

    _Ref_count_bounded_array() : _Ref_count_base(), _Storage() {} 

    template <class _Arg>
    explicit _Ref_count_bounded_array(const _Arg& _Val) : _Ref_count_base() { 
        if constexpr (is_same_v<_For_overwrite_tag, _Arg>) {
            _Uninitialized_default_construct_multidimensional_n(_Storage._Value, extent_v<_Ty>);
        } else {
            _Uninitialized_fill_multidimensional_n(_Storage._Value, extent_v<_Ty>, _Val);
        }
    }

    union {
        _Wrap<_Ty> _Storage;
    };

private:
    ~_Ref_count_bounded_array() noexcept override { 
        

        
    }

    void _Destroy() noexcept override { 
        _Destroy_in_place(_Storage); 
    }

    void _Delete_this() noexcept override { 
        delete this;
    }
};
#line 2460 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"

template <class _Ty, class _Alloc>
class _Ref_count_obj_alloc3 : public _Ebco_base<_Rebind_alloc_t<_Alloc, _Ty>>, public _Ref_count_base {
    
private:
    static_assert(is_same_v<_Ty, remove_cv_t<_Ty>>, "allocate_shared should remove_cv_t");

    using _Rebound = _Rebind_alloc_t<_Alloc, _Ty>;

public:
    template <class... _Types>
    explicit _Ref_count_obj_alloc3(const _Alloc& _Al_arg, _Types&&... _Args)
        : _Ebco_base<_Rebound>(_Al_arg), _Ref_count_base() {

        if constexpr (sizeof...(_Types) == 1 && (is_same_v<_For_overwrite_tag, remove_cvref_t<_Types>> && ...)) {
            _Default_construct_in_place(_Storage._Value);
            ((void) _Args, ...);
        } else
#line 2479 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"
        {
            allocator_traits<_Rebound>::construct(
                this->_Get_val(), ::std:: addressof(_Storage._Value), ::std:: forward<_Types>(_Args)...);
        }
    }

    union {
        _Wrap<_Ty> _Storage;
    };

private:
    ~_Ref_count_obj_alloc3() noexcept override { 
        

        
    }

    void _Destroy() noexcept override { 
        allocator_traits<_Rebound>::destroy(this->_Get_val(), ::std:: addressof(_Storage._Value));
    }

    void _Delete_this() noexcept override { 
        _Rebind_alloc_t<_Alloc, _Ref_count_obj_alloc3> _Al(this->_Get_val());
        this->~_Ref_count_obj_alloc3();
        _Deallocate_plain(_Al, this);
    }
};


template <class _Alloc>
class [[nodiscard]] _Uninitialized_rev_destroying_backout_al {
    

private:
    using pointer = _Alloc_ptr_t<_Alloc>;

public:
    _Uninitialized_rev_destroying_backout_al(pointer _Dest, _Alloc& _Al_) noexcept
        : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

    _Uninitialized_rev_destroying_backout_al(const _Uninitialized_rev_destroying_backout_al&)            = delete;
    _Uninitialized_rev_destroying_backout_al& operator=(const _Uninitialized_rev_destroying_backout_al&) = delete;

    ~_Uninitialized_rev_destroying_backout_al() {
        while (_Last != _First) {
            --_Last;
            allocator_traits<_Alloc>::destroy(_Al, _Last);
        }
    }

    template <class... _Types>
    void _Emplace_back(_Types&&... _Vals) { 
        allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), ::std:: forward<_Types>(_Vals)...);
        ++_Last;
    }

    pointer _Release() noexcept { 
        _First = _Last;
        return _Last;
    }

private:
    pointer _First;
    pointer _Last;
    _Alloc& _Al;
};

template <class _Ty, class _Alloc>
void _Reverse_destroy_multidimensional_n_al(_Ty* const _Arr, size_t _Size, _Alloc& _Al) noexcept {
    while (_Size > 0) {
        --_Size;
        if constexpr (is_array_v<_Ty>) {
            _Reverse_destroy_multidimensional_n_al(_Arr[_Size], extent_v<_Ty>, _Al);
        } else {
            allocator_traits<_Alloc>::destroy(_Al, _Arr + _Size);
        }
    }
}

template <class _Ty, class _Alloc>
struct [[nodiscard]] _Reverse_destroy_multidimensional_n_al_guard {
    _Ty* _Target;
    size_t _Index;
    _Alloc& _Al;

    ~_Reverse_destroy_multidimensional_n_al_guard() {
        if (_Target) {
            _Reverse_destroy_multidimensional_n_al(_Target, _Index, _Al);
        }
    }
};

template <class _Ty, size_t _Size, class _Alloc>
void _Uninitialized_copy_multidimensional_al(const _Ty (&_In)[_Size], _Ty (&_Out)[_Size], _Alloc& _Al) {
    using _Item = remove_all_extents_t<_Ty>;
    if constexpr (conjunction_v<is_trivial<_Ty>, _Uses_default_construct<_Alloc, _Item*, const _Item&>>) {
        _Copy_memmove_n(_In, _Size, _Out);
    } else if constexpr (is_array_v<_Ty>) {
        _Reverse_destroy_multidimensional_n_al_guard<_Ty, _Alloc> _Guard{_Out, 0, _Al};
        for (size_t& _Idx = _Guard._Index; _Idx < _Size; ++_Idx) {
            _Uninitialized_copy_multidimensional_al(_In[_Idx], _Out[_Idx], _Al);
        }
        _Guard._Target = nullptr;
    } else {
        _Uninitialized_rev_destroying_backout_al _Backout{_Out, _Al};
        for (size_t _Idx = 0; _Idx < _Size; ++_Idx) {
            _Backout._Emplace_back(_In[_Idx]);
        }
        _Backout._Release();
    }
}

template <class _Ty, class _Alloc>
void _Uninitialized_value_construct_multidimensional_n_al(_Ty* const _Out, const size_t _Size, _Alloc& _Al) {
    using _Item = remove_all_extents_t<_Ty>;
    if constexpr (_Use_memset_value_construct_v<_Item*> && _Uses_default_construct<_Alloc, _Item*>::value) {
        _Zero_range(_Out, _Out + _Size);
    } else if constexpr (is_array_v<_Ty>) {
        _Reverse_destroy_multidimensional_n_al_guard<_Ty, _Alloc> _Guard{_Out, 0, _Al};
        for (size_t& _Idx = _Guard._Index; _Idx < _Size; ++_Idx) {
            _Uninitialized_value_construct_multidimensional_n_al(_Out[_Idx], extent_v<_Ty>, _Al);
        }
        _Guard._Target = nullptr;
    } else {
        _Uninitialized_rev_destroying_backout_al _Backout{_Out, _Al};
        for (size_t _Idx = 0; _Idx < _Size; ++_Idx) {
            _Backout._Emplace_back();
        }
        _Backout._Release();
    }
}

template <class _Ty, class _Alloc>
void _Uninitialized_fill_multidimensional_n_al(_Ty* const _Out, const size_t _Size, const _Ty& _Val, _Alloc& _Al) {
    if constexpr (is_array_v<_Ty>) {
        _Reverse_destroy_multidimensional_n_al_guard<_Ty, _Alloc> _Guard{_Out, 0, _Al};
        for (size_t& _Idx = _Guard._Index; _Idx < _Size; ++_Idx) {
            _Uninitialized_copy_multidimensional_al(_Val, _Out[_Idx], _Al); 
        }
        _Guard._Target = nullptr;
    } else if constexpr (_Fill_memset_is_safe<_Ty*, _Ty> && _Uses_default_construct<_Alloc, _Ty*, const _Ty&>::value) {
        _Fill_memset(_Out, _Val, _Size);
    } else {
        if constexpr (_Fill_zero_memset_is_safe<_Ty*, _Ty>
                      && _Uses_default_construct<_Alloc, _Ty*, const _Ty&>::value) {
            if (_Is_all_bits_zero(_Val)) {
                _Fill_zero_memset(_Out, _Size);
                return;
            }
        }
        _Uninitialized_rev_destroying_backout_al _Backout{_Out, _Al};
        for (size_t _Idx = 0; _Idx < _Size; ++_Idx) {
            _Backout._Emplace_back(_Val);
        }
        _Backout._Release();
    }
}

template <class _Ty, class _Alloc>
class _Ref_count_unbounded_array_alloc : public _Ebco_base<_Rebind_alloc_t<_Alloc, remove_all_extents_t<_Ty>>>,
                                         public _Ref_count_base {
    
private:
    static_assert(is_unbounded_array_v<_Ty>);
    static_assert(is_same_v<_Ty, remove_cv_t<_Ty>>, "allocate_shared should remove_cv_t");

    using _Item    = remove_all_extents_t<_Ty>;
    using _Rebound = _Rebind_alloc_t<_Alloc, _Item>;

public:
    using _Element_type = remove_extent_t<_Ty>;

    explicit _Ref_count_unbounded_array_alloc(const _Alloc& _Al_arg, const size_t _Count)
        : _Ebco_base<_Rebound>(_Al_arg), _Ref_count_base(), _Size(_Count) {
        _Uninitialized_value_construct_multidimensional_n_al(_Get_ptr(), _Size, this->_Get_val());
    }

    template <class _Arg>
    explicit _Ref_count_unbounded_array_alloc(const _Alloc& _Al_arg, const size_t _Count, const _Arg& _Val)
        : _Ebco_base<_Rebound>(_Al_arg), _Ref_count_base(), _Size(_Count) {
        if constexpr (is_same_v<_For_overwrite_tag, _Arg>) {
            _Uninitialized_default_construct_multidimensional_n(_Get_ptr(), _Size); 
        } else {
            _Uninitialized_fill_multidimensional_n_al(_Get_ptr(), _Size, _Val, this->_Get_val());
        }
    }

    [[nodiscard]] auto _Get_ptr() noexcept {
        return ::std:: addressof(_Storage._Value);
    }

private:
    size_t _Size;

    union {
        _Wrap<_Element_type> _Storage; 
    };

    ~_Ref_count_unbounded_array_alloc() noexcept override { 
        

        
    }

    void _Destroy() noexcept override { 
        if constexpr (!conjunction_v<is_trivially_destructible<_Item>, _Uses_default_destroy<_Rebound, _Item*>>) {
            _Reverse_destroy_multidimensional_n_al(_Get_ptr(), _Size, this->_Get_val());
        }
    }

    void _Delete_this() noexcept override { 
        constexpr size_t _Align = alignof(_Ref_count_unbounded_array_alloc);
        using _Storage          = _Alignas_storage_unit<_Align>;

        _Rebind_alloc_t<_Alloc, _Storage> _Al(this->_Get_val());
        const size_t _Bytes =
            _Calculate_bytes_for_flexible_array<_Ref_count_unbounded_array_alloc, _Check_overflow::_Nope>(_Size);
        const size_t _Storage_units = _Bytes / sizeof(_Storage);

        this->~_Ref_count_unbounded_array_alloc();

        _Al.deallocate(reinterpret_cast<_Storage*>(this), _Storage_units);
    }
};

template <class _Ty, class _Alloc>
class _Ref_count_bounded_array_alloc : public _Ebco_base<_Rebind_alloc_t<_Alloc, remove_all_extents_t<_Ty>>>,
                                       public _Ref_count_base {
    
private:
    static_assert(is_bounded_array_v<_Ty>);
    static_assert(is_same_v<_Ty, remove_cv_t<_Ty>>, "allocate_shared should remove_cv_t");

    using _Item    = remove_all_extents_t<_Ty>;
    using _Rebound = _Rebind_alloc_t<_Alloc, _Item>;

public:
    explicit _Ref_count_bounded_array_alloc(const _Alloc& _Al_arg)
        : _Ebco_base<_Rebound>(_Al_arg), _Ref_count_base() { 
        _Uninitialized_value_construct_multidimensional_n_al(_Storage._Value, extent_v<_Ty>, this->_Get_val());
    }

    template <class _Arg>
    explicit _Ref_count_bounded_array_alloc(const _Alloc& _Al_arg, const _Arg& _Val)
        : _Ebco_base<_Rebound>(_Al_arg), _Ref_count_base() { 
        if constexpr (is_same_v<_For_overwrite_tag, _Arg>) {
            _Uninitialized_default_construct_multidimensional_n(
                _Storage._Value, extent_v<_Ty>); 
        } else {
            _Uninitialized_fill_multidimensional_n_al(_Storage._Value, extent_v<_Ty>, _Val, this->_Get_val());
        }
    }

    union {
        _Wrap<_Ty> _Storage;
    };

private:
    ~_Ref_count_bounded_array_alloc() noexcept override { 
        

        
    }

    void _Destroy() noexcept override { 
        if constexpr (!conjunction_v<is_trivially_destructible<_Item>, _Uses_default_destroy<_Rebound, _Item*>>) {
            _Reverse_destroy_multidimensional_n_al(_Storage._Value, extent_v<_Ty>, this->_Get_val());
        }
    }

    void _Delete_this() noexcept override { 
        _Rebind_alloc_t<_Alloc, _Ref_count_bounded_array_alloc> _Al(this->_Get_val());
        this->~_Ref_count_bounded_array_alloc();
        _Deallocate_plain(_Al, this);
    }
};
#line 2756 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"

 template <class _Ty, class... _Types>
[[nodiscard("This function constructs an object wrapped by a smart pointer and has no other effects; " "it is not useful to call this function and discard the return value.")]]

    enable_if_t<!is_array_v<_Ty>, shared_ptr<_Ty>>


#line 2764 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"
    make_shared(_Types&&... _Args) { 
    const auto _Rx = new _Ref_count_obj2<_Ty>(::std:: forward<_Types>(_Args)...);
    shared_ptr<_Ty> _Ret;
    _Ret._Set_ptr_rep_and_enable_shared(::std:: addressof(_Rx->_Storage._Value), _Rx);
    return _Ret;
}


template <class _Refc>
struct [[nodiscard]] _Global_delete_guard {
    _Refc* _Target;

    ~_Global_delete_guard() {
        
        
        
        if (_Target) {
            _Deallocate_flexible_array(_Target);
        }
    }
};

   template <class _Ty, class... _ArgTypes>
[[nodiscard]] shared_ptr<_Ty> _Make_shared_unbounded_array(const size_t _Count, const _ArgTypes&... _Args) {
    
    static_assert(is_unbounded_array_v<_Ty>);
    using _Refc    = _Ref_count_unbounded_array<_Ty>;
    const auto _Rx = _Allocate_flexible_array<_Refc>(_Count);
    _Global_delete_guard<_Refc> _Guard{_Rx};
    ::new (static_cast<void*>(_Rx)) _Refc(_Count, _Args...);
    _Guard._Target = nullptr;
    shared_ptr<_Ty> _Ret;
    _Ret._Set_ptr_rep_and_enable_shared(_Rx->_Get_ptr(), _Rx);
    return _Ret;
}

 template <class _Ty>
[[nodiscard("This function constructs an object wrapped by a smart pointer and has no other effects; " "it is not useful to call this function and discard the return value.")]] enable_if_t<is_unbounded_array_v<_Ty>, shared_ptr<_Ty>> make_shared(const size_t _Count) {
    return _Make_shared_unbounded_array<_Ty>(_Count);
}

 template <class _Ty>
[[nodiscard("This function constructs an object wrapped by a smart pointer and has no other effects; " "it is not useful to call this function and discard the return value.")]] enable_if_t<is_unbounded_array_v<_Ty>, shared_ptr<_Ty>> make_shared(
    const size_t _Count, const remove_extent_t<_Ty>& _Val) {
    return _Make_shared_unbounded_array<_Ty>(_Count, _Val);
}

 template <class _Ty>
[[nodiscard("This function constructs an object wrapped by a smart pointer and has no other effects; " "it is not useful to call this function and discard the return value.")]] enable_if_t<is_bounded_array_v<_Ty>, shared_ptr<_Ty>> make_shared() {
    
    const auto _Rx = new _Ref_count_bounded_array<_Ty>();
    shared_ptr<_Ty> _Ret;
    _Ret._Set_ptr_rep_and_enable_shared(_Rx->_Storage._Value, _Rx);
    return _Ret;
}

 template <class _Ty>
[[nodiscard("This function constructs an object wrapped by a smart pointer and has no other effects; " "it is not useful to call this function and discard the return value.")]] enable_if_t<is_bounded_array_v<_Ty>, shared_ptr<_Ty>> make_shared(
    const remove_extent_t<_Ty>& _Val) {
    
    const auto _Rx = new _Ref_count_bounded_array<_Ty>(_Val);
    shared_ptr<_Ty> _Ret;
    _Ret._Set_ptr_rep_and_enable_shared(_Rx->_Storage._Value, _Rx);
    return _Ret;
}

 template <class _Ty>
[[nodiscard("This function constructs an object wrapped by a smart pointer and has no other effects; " "it is not useful to call this function and discard the return value.")]] enable_if_t<!is_unbounded_array_v<_Ty>, shared_ptr<_Ty>> make_shared_for_overwrite() {
    shared_ptr<_Ty> _Ret;
    if constexpr (is_array_v<_Ty>) {
        
        const auto _Rx = new _Ref_count_bounded_array<_Ty>(_For_overwrite_tag{});
        _Ret._Set_ptr_rep_and_enable_shared(_Rx->_Storage._Value, _Rx);
    } else {
        
        const auto _Rx = new _Ref_count_obj2<_Ty>(_For_overwrite_tag{});
        _Ret._Set_ptr_rep_and_enable_shared(::std:: addressof(_Rx->_Storage._Value), _Rx);
    }
    return _Ret;
}

 template <class _Ty>
[[nodiscard("This function constructs an object wrapped by a smart pointer and has no other effects; " "it is not useful to call this function and discard the return value.")]] enable_if_t<is_unbounded_array_v<_Ty>, shared_ptr<_Ty>> make_shared_for_overwrite(
    const size_t _Count) {
    return _Make_shared_unbounded_array<_Ty>(_Count, _For_overwrite_tag{});
}
#line 2851 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"

 template <class _Ty, class _Alloc, class... _Types>
[[nodiscard("This function constructs an object wrapped by a smart pointer and has no other effects; " "it is not useful to call this function and discard the return value.")]]

    enable_if_t<!is_array_v<_Ty>, shared_ptr<_Ty>>


#line 2859 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"
    allocate_shared(const _Alloc& _Al, _Types&&... _Args) { 
    
    
    using _Refoa   = _Ref_count_obj_alloc3<remove_cv_t<_Ty>, _Alloc>;
    using _Alblock = _Rebind_alloc_t<_Alloc, _Refoa>;
    _Alblock _Rebound(_Al);
    _Alloc_construct_ptr<_Alblock> _Constructor{_Rebound};
    _Constructor._Allocate();
    _Construct_in_place(*_Constructor._Ptr, _Al, ::std:: forward<_Types>(_Args)...);
    shared_ptr<_Ty> _Ret;
    const auto _Ptr = reinterpret_cast<_Ty*>(::std:: addressof(_Constructor._Ptr->_Storage._Value));
    _Ret._Set_ptr_rep_and_enable_shared(_Ptr, _Unfancy(_Constructor._Release()));
    return _Ret;
}


template <class _Alloc>
struct _Allocate_n_ptr {
    _Alloc& _Al;
    _Alloc_ptr_t<_Alloc> _Ptr;
    size_t _Nx;

    _Allocate_n_ptr(_Alloc& _Al_, const size_t _Nx_) : _Al(_Al_), _Ptr(_Al_.allocate(_Nx_)), _Nx(_Nx_) {}

    ~_Allocate_n_ptr() {
        if (_Ptr) {
            _Al.deallocate(_Ptr, _Nx);
        }
    }

    _Allocate_n_ptr(const _Allocate_n_ptr&)            = delete;
    _Allocate_n_ptr& operator=(const _Allocate_n_ptr&) = delete;
};

   template <class _Ty, class _Alloc, class... _ArgTypes>
[[nodiscard]] shared_ptr<_Ty> _Allocate_shared_unbounded_array(
    const _Alloc& _Al, const size_t _Count, const _ArgTypes&... _Args) {
    
    static_assert(is_unbounded_array_v<_Ty>);
    using _Refc             = _Ref_count_unbounded_array_alloc<remove_cv_t<_Ty>, _Alloc>;
    constexpr size_t _Align = alignof(_Refc);
    using _Storage          = _Alignas_storage_unit<_Align>;
    _Rebind_alloc_t<_Alloc, _Storage> _Rebound(_Al);
    const size_t _Bytes         = _Calculate_bytes_for_flexible_array<_Refc, _Check_overflow::_Yes>(_Count);
    const size_t _Storage_units = _Bytes / sizeof(_Storage);
    _Allocate_n_ptr _Guard{_Rebound, _Storage_units};
    const auto _Rx = reinterpret_cast<_Refc*>(_Unfancy(_Guard._Ptr));
    ::new (static_cast<void*>(_Rx)) _Refc(_Al, _Count, _Args...);
    _Guard._Ptr = nullptr;
    shared_ptr<_Ty> _Ret;
    _Ret._Set_ptr_rep_and_enable_shared(_Rx->_Get_ptr(), _Rx);
    return _Ret;
}

 template <class _Ty, class _Alloc>
[[nodiscard("This function constructs an object wrapped by a smart pointer and has no other effects; " "it is not useful to call this function and discard the return value.")]] enable_if_t<is_unbounded_array_v<_Ty>, shared_ptr<_Ty>> allocate_shared(
    const _Alloc& _Al, const size_t _Count) {
    return _Allocate_shared_unbounded_array<_Ty>(_Al, _Count);
}

 template <class _Ty, class _Alloc>
[[nodiscard("This function constructs an object wrapped by a smart pointer and has no other effects; " "it is not useful to call this function and discard the return value.")]] enable_if_t<is_unbounded_array_v<_Ty>, shared_ptr<_Ty>> allocate_shared(
    const _Alloc& _Al, const size_t _Count, const remove_extent_t<_Ty>& _Val) {
    return _Allocate_shared_unbounded_array<_Ty>(_Al, _Count, _Val);
}

 template <class _Ty, class _Alloc>
[[nodiscard("This function constructs an object wrapped by a smart pointer and has no other effects; " "it is not useful to call this function and discard the return value.")]] enable_if_t<is_bounded_array_v<_Ty>, shared_ptr<_Ty>> allocate_shared(const _Alloc& _Al) {
    
    using _Refc    = _Ref_count_bounded_array_alloc<remove_cv_t<_Ty>, _Alloc>;
    using _Alblock = _Rebind_alloc_t<_Alloc, _Refc>;
    _Alblock _Rebound(_Al);
    _Alloc_construct_ptr _Constructor{_Rebound};
    _Constructor._Allocate();
    ::new (_Voidify_iter(_Constructor._Ptr)) _Refc(_Al);
    shared_ptr<_Ty> _Ret;
    const auto _Ptr = static_cast<remove_extent_t<_Ty>*>(_Constructor._Ptr->_Storage._Value);
    _Ret._Set_ptr_rep_and_enable_shared(_Ptr, _Unfancy(_Constructor._Release()));
    return _Ret;
}

 template <class _Ty, class _Alloc>
[[nodiscard("This function constructs an object wrapped by a smart pointer and has no other effects; " "it is not useful to call this function and discard the return value.")]] enable_if_t<is_bounded_array_v<_Ty>, shared_ptr<_Ty>> allocate_shared(
    const _Alloc& _Al, const remove_extent_t<_Ty>& _Val) {
    
    using _Refc    = _Ref_count_bounded_array_alloc<remove_cv_t<_Ty>, _Alloc>;
    using _Alblock = _Rebind_alloc_t<_Alloc, _Refc>;
    _Alblock _Rebound(_Al);
    _Alloc_construct_ptr _Constructor{_Rebound};
    _Constructor._Allocate();
    ::new (_Voidify_iter(_Constructor._Ptr)) _Refc(_Al, _Val);
    shared_ptr<_Ty> _Ret;
    const auto _Ptr = static_cast<remove_extent_t<_Ty>*>(_Constructor._Ptr->_Storage._Value);
    _Ret._Set_ptr_rep_and_enable_shared(_Ptr, _Unfancy(_Constructor._Release()));
    return _Ret;
}

 template <class _Ty, class _Alloc>
[[nodiscard("This function constructs an object wrapped by a smart pointer and has no other effects; " "it is not useful to call this function and discard the return value.")]] enable_if_t<!is_unbounded_array_v<_Ty>, shared_ptr<_Ty>> allocate_shared_for_overwrite(
    const _Alloc& _Al) {
    shared_ptr<_Ty> _Ret;
    if constexpr (is_array_v<_Ty>) {
        
        using _Refc    = _Ref_count_bounded_array_alloc<remove_cv_t<_Ty>, _Alloc>;
        using _Alblock = _Rebind_alloc_t<_Alloc, _Refc>;
        _Alblock _Rebound(_Al);
        _Alloc_construct_ptr _Constructor{_Rebound};
        _Constructor._Allocate();
        ::new (_Voidify_iter(_Constructor._Ptr)) _Refc(_Al, _For_overwrite_tag{});
        const auto _Ptr = static_cast<remove_extent_t<_Ty>*>(_Constructor._Ptr->_Storage._Value);
        _Ret._Set_ptr_rep_and_enable_shared(_Ptr, _Unfancy(_Constructor._Release()));
    } else {
        
        using _Refoa   = _Ref_count_obj_alloc3<remove_cv_t<_Ty>, _Alloc>;
        using _Alblock = _Rebind_alloc_t<_Alloc, _Refoa>;
        _Alblock _Rebound(_Al);
        _Alloc_construct_ptr<_Alblock> _Constructor{_Rebound};
        _Constructor._Allocate();
        _Construct_in_place(*_Constructor._Ptr, _Al, _For_overwrite_tag{});
        const auto _Ptr = reinterpret_cast<_Ty*>(::std:: addressof(_Constructor._Ptr->_Storage._Value));
        _Ret._Set_ptr_rep_and_enable_shared(_Ptr, _Unfancy(_Constructor._Release()));
    }

    return _Ret;
}

 template <class _Ty, class _Alloc>
[[nodiscard("This function constructs an object wrapped by a smart pointer and has no other effects; " "it is not useful to call this function and discard the return value.")]] enable_if_t<is_unbounded_array_v<_Ty>, shared_ptr<_Ty>> allocate_shared_for_overwrite(
    const _Alloc& _Al, const size_t _Count) {
    return _Allocate_shared_unbounded_array<_Ty>(_Al, _Count, _For_overwrite_tag{});
}
#line 2991 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"

 template <class _Ty>
class weak_ptr : public _Ptr_base<_Ty> { 
public:

    
    

    
    template <class _Ty2, class = const _Ty2*>
    static constexpr bool _Must_avoid_expired_conversions_from = true;

    
    template <class _Ty2>
    static constexpr bool
        _Must_avoid_expired_conversions_from<_Ty2, decltype(static_cast<const _Ty2*>(static_cast<_Ty*>(nullptr)))> =
            false;
#line 3009 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"

    constexpr weak_ptr() noexcept {}

    weak_ptr(const weak_ptr& _Other) noexcept {
        this->_Weakly_construct_from(_Other); 
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    weak_ptr(const shared_ptr<_Ty2>& _Other) noexcept {
        this->_Weakly_construct_from(_Other); 
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    weak_ptr(const weak_ptr<_Ty2>& _Other) noexcept {



        constexpr bool _Avoid_expired_conversions = _Must_avoid_expired_conversions_from<_Ty2>;
#line 3028 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"

        if constexpr (_Avoid_expired_conversions) {
            this->_Weakly_convert_lvalue_avoiding_expired_conversions(_Other);
        } else {
            this->_Weakly_construct_from(_Other);
        }
    }

    weak_ptr(weak_ptr&& _Other) noexcept {
        this->_Move_construct_from(::std:: move(_Other));
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    weak_ptr(weak_ptr<_Ty2>&& _Other) noexcept {



        constexpr bool _Avoid_expired_conversions = _Must_avoid_expired_conversions_from<_Ty2>;
#line 3047 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"

        if constexpr (_Avoid_expired_conversions) {
            this->_Weakly_convert_rvalue_avoiding_expired_conversions(::std:: move(_Other));
        } else {
            this->_Move_construct_from(::std:: move(_Other));
        }
    }

    ~weak_ptr() noexcept {
        this->_Decwref();
    }

    weak_ptr& operator=(const weak_ptr& _Right) noexcept {
        weak_ptr(_Right).swap(*this);
        return *this;
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    weak_ptr& operator=(const weak_ptr<_Ty2>& _Right) noexcept {
        weak_ptr(_Right).swap(*this);
        return *this;
    }

    weak_ptr& operator=(weak_ptr&& _Right) noexcept {
        weak_ptr(::std:: move(_Right)).swap(*this);
        return *this;
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    weak_ptr& operator=(weak_ptr<_Ty2>&& _Right) noexcept {
        weak_ptr(::std:: move(_Right)).swap(*this);
        return *this;
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    weak_ptr& operator=(const shared_ptr<_Ty2>& _Right) noexcept {
        weak_ptr(_Right).swap(*this);
        return *this;
    }

    void reset() noexcept { 
        weak_ptr{}.swap(*this);
    }

    void swap(weak_ptr& _Other) noexcept {
        this->_Swap(_Other);
    }

    [[nodiscard]] bool expired() const noexcept {
        return this->use_count() == 0;
    }

    [[nodiscard]] shared_ptr<_Ty> lock() const noexcept { 
        shared_ptr<_Ty> _Ret;
        (void) _Ret._Construct_from_weak(*this);
        return _Ret;
    }
};


template <class _Ty>
weak_ptr(shared_ptr<_Ty>) -> weak_ptr<_Ty>;
#line 3110 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"

 template <class _Ty>
void swap(weak_ptr<_Ty>& _Left, weak_ptr<_Ty>& _Right) noexcept {
    _Left.swap(_Right);
}

 template <class _Ty>
class enable_shared_from_this { 
public:
    using _Esft_type = enable_shared_from_this;

    [[nodiscard]] shared_ptr<_Ty> shared_from_this() {
        return shared_ptr<_Ty>(_Wptr);
    }

    [[nodiscard]] shared_ptr<const _Ty> shared_from_this() const {
        return shared_ptr<const _Ty>(_Wptr);
    }

    [[nodiscard]] weak_ptr<_Ty> weak_from_this() noexcept {
        return _Wptr;
    }

    [[nodiscard]] weak_ptr<const _Ty> weak_from_this() const noexcept {
        return _Wptr;
    }

protected:
    constexpr enable_shared_from_this() noexcept : _Wptr() {}

    enable_shared_from_this(const enable_shared_from_this&) noexcept : _Wptr() {
        
    }

    enable_shared_from_this& operator=(const enable_shared_from_this&) noexcept { 
        return *this;
    }

    ~enable_shared_from_this() = default;

private:
    template <class _Yty>
    friend class shared_ptr;

    mutable weak_ptr<_Ty> _Wptr;
};


 template <class _Ty>
struct default_delete { 
    constexpr default_delete() noexcept = default;

    template <class _Ty2, enable_if_t<is_convertible_v<_Ty2*, _Ty*>, int> = 0>
    inline default_delete(const default_delete<_Ty2>&) noexcept {}

    inline void operator()(_Ty* _Ptr) const noexcept   { 
        static_assert(0 < sizeof(_Ty), "can't delete an incomplete type");
        delete _Ptr;
    }
};

template <class _Ty>
struct default_delete<_Ty[]> { 
    constexpr default_delete() noexcept = default;

    template <class _Uty, enable_if_t<is_convertible_v<_Uty (*)[], _Ty (*)[]>, int> = 0>
    inline default_delete(const default_delete<_Uty[]>&) noexcept {}

    template <class _Uty, enable_if_t<is_convertible_v<_Uty (*)[], _Ty (*)[]>, int> = 0>
    inline void operator()(_Uty* _Ptr) const noexcept   { 
        static_assert(0 < sizeof(_Uty), "can't delete an incomplete type");
        delete[] _Ptr;
    }
};

template <class _Ty, class _Dx_noref, class = void>
struct _Get_deleter_pointer_type { 
    using type = _Ty*;
};

template <class _Ty, class _Dx_noref>
struct _Get_deleter_pointer_type<_Ty, _Dx_noref, void_t<typename _Dx_noref::pointer>> { 
    using type = typename _Dx_noref::pointer;
};

template <class _Dx2>
using _Unique_ptr_enable_default_t =
    enable_if_t<conjunction_v<negation<is_pointer<_Dx2>>, is_default_constructible<_Dx2>>, int>;

 template <class _Ty, class _Dx  >
class unique_ptr { 
public:
    using pointer      = typename _Get_deleter_pointer_type<_Ty, remove_reference_t<_Dx>>::type;
    using element_type = _Ty;
    using deleter_type = _Dx;

    template <class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0>
    constexpr unique_ptr() noexcept : _Mypair(_Zero_then_variadic_args_t{}) {}

    template <class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0>
    constexpr unique_ptr(nullptr_t) noexcept : _Mypair(_Zero_then_variadic_args_t{}) {}

    inline unique_ptr& operator=(nullptr_t) noexcept {
        reset();
        return *this;
    }

    
    
    template <class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0>
    inline explicit unique_ptr(pointer _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t{}, _Ptr) {}

    template <class _Dx2 = _Dx, enable_if_t<is_constructible_v<_Dx2, const _Dx2&>, int> = 0>
    inline unique_ptr(pointer _Ptr, const _Dx& _Dt) noexcept : _Mypair(_One_then_variadic_args_t{}, _Dt, _Ptr) {}

    template <class _Dx2                                                                            = _Dx,
        enable_if_t<conjunction_v<negation<is_reference<_Dx2>>, is_constructible<_Dx2, _Dx2>>, int> = 0>
    inline unique_ptr(pointer _Ptr, _Dx&& _Dt) noexcept
        : _Mypair(_One_then_variadic_args_t{}, ::std:: move(_Dt), _Ptr) {}

    template <class _Dx2                                                                                      = _Dx,
        enable_if_t<conjunction_v<is_reference<_Dx2>, is_constructible<_Dx2, remove_reference_t<_Dx2>>>, int> = 0>
    unique_ptr(pointer, remove_reference_t<_Dx>&&) = delete;

    template <class _Dx2 = _Dx, enable_if_t<is_move_constructible_v<_Dx2>, int> = 0>
    inline unique_ptr(unique_ptr&& _Right) noexcept
        : _Mypair(_One_then_variadic_args_t{}, ::std:: forward<_Dx>(_Right.get_deleter()), _Right.release()) {}

    template <class _Ty2, class _Dx2,
        enable_if_t<
            conjunction_v<negation<is_array<_Ty2>>, is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer, pointer>,
                conditional_t<is_reference_v<_Dx>, is_same<_Dx2, _Dx>, is_convertible<_Dx2, _Dx>>>,
            int> = 0>
    inline unique_ptr(unique_ptr<_Ty2, _Dx2>&& _Right) noexcept
        : _Mypair(_One_then_variadic_args_t{}, ::std:: forward<_Dx2>(_Right.get_deleter()), _Right.release()) {}





#line 3251 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"

    template <class _Ty2, class _Dx2,
        enable_if_t<conjunction_v<negation<is_array<_Ty2>>, is_assignable<_Dx&, _Dx2>,
                        is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer, pointer>>,
            int> = 0>
    inline unique_ptr& operator=(unique_ptr<_Ty2, _Dx2>&& _Right) noexcept {
        reset(_Right.release());
        _Mypair._Get_first() = ::std:: forward<_Dx2>(_Right._Mypair._Get_first());
        return *this;
    }

    template <class _Dx2 = _Dx, enable_if_t<is_move_assignable_v<_Dx2>, int> = 0>
    inline unique_ptr& operator=(unique_ptr&& _Right) noexcept {
        if (this != ::std:: addressof(_Right)) {
            reset(_Right.release());
            _Mypair._Get_first() = ::std:: forward<_Dx>(_Right._Mypair._Get_first());
        }
        return *this;
    }

    inline void swap(unique_ptr& _Right) noexcept {
        _Swap_adl(_Mypair._Myval2, _Right._Mypair._Myval2);
        _Swap_adl(_Mypair._Get_first(), _Right._Mypair._Get_first());
    }

    inline ~unique_ptr() noexcept {
        if (_Mypair._Myval2) {
            _Mypair._Get_first()(_Mypair._Myval2);
        }
    }

    [[nodiscard]] inline _Dx& get_deleter() noexcept {
        return _Mypair._Get_first();
    }

    [[nodiscard]] inline const _Dx& get_deleter() const noexcept {
        return _Mypair._Get_first();
    }

    [[nodiscard]] inline add_lvalue_reference_t<_Ty> operator*() const noexcept(noexcept(*::std:: declval<pointer>())) {
        return *_Mypair._Myval2;
    }

    [[nodiscard]] inline pointer operator->() const noexcept {
        return _Mypair._Myval2;
    }

    [[nodiscard]] inline pointer get() const noexcept {
        return _Mypair._Myval2;
    }

    inline explicit operator bool() const noexcept {
        return static_cast<bool>(_Mypair._Myval2);
    }

    inline pointer release() noexcept {
        return ::std:: exchange(_Mypair._Myval2, nullptr);
    }

    inline void reset(pointer _Ptr = nullptr) noexcept {
        pointer _Old = ::std:: exchange(_Mypair._Myval2, _Ptr);
        if (_Old) {
            _Mypair._Get_first()(_Old);
        }
    }

    unique_ptr(const unique_ptr&)            = delete;
    unique_ptr& operator=(const unique_ptr&) = delete;

private:
    template <class, class>
    friend class unique_ptr;

    _Compressed_pair<_Dx, pointer> _Mypair;
};

template <class _Ty, class _Dx>
class unique_ptr<_Ty[], _Dx> { 
public:
    using pointer      = typename _Get_deleter_pointer_type<_Ty, remove_reference_t<_Dx>>::type;
    using element_type = _Ty;
    using deleter_type = _Dx;

    template <class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0>
    constexpr unique_ptr() noexcept : _Mypair(_Zero_then_variadic_args_t{}) {}

    template <class _Uty, class _Is_nullptr = is_same<_Uty, nullptr_t>>
    using _Enable_ctor_reset =
        enable_if_t<is_same_v<_Uty, pointer> 
                        || _Is_nullptr::value 
                        || (is_same_v<pointer, element_type*> 
                            && is_pointer_v<_Uty> 
                            && is_convertible_v<remove_pointer_t<_Uty> (*)[], element_type (*)[]>),
            int>;

    template <class _Uty, class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0, _Enable_ctor_reset<_Uty> = 0>
    inline explicit unique_ptr(_Uty _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t{}, _Ptr) {}

    template <class _Uty, class _Dx2 = _Dx, enable_if_t<is_constructible_v<_Dx2, const _Dx2&>, int> = 0,
        _Enable_ctor_reset<_Uty> = 0>
    inline unique_ptr(_Uty _Ptr, const _Dx& _Dt) noexcept : _Mypair(_One_then_variadic_args_t{}, _Dt, _Ptr) {}

    template <class _Uty, class _Dx2 = _Dx,
        enable_if_t<conjunction_v<negation<is_reference<_Dx2>>, is_constructible<_Dx2, _Dx2>>, int> = 0,
        _Enable_ctor_reset<_Uty>                                                                    = 0>
    inline unique_ptr(_Uty _Ptr, _Dx&& _Dt) noexcept
        : _Mypair(_One_then_variadic_args_t{}, ::std:: move(_Dt), _Ptr) {}

    template <class _Uty, class _Dx2 = _Dx,
        enable_if_t<conjunction_v<is_reference<_Dx2>, is_constructible<_Dx2, remove_reference_t<_Dx2>>>, int> = 0>
    unique_ptr(_Uty, remove_reference_t<_Dx>&&) = delete;

    template <class _Dx2 = _Dx, enable_if_t<is_move_constructible_v<_Dx2>, int> = 0>
    inline unique_ptr(unique_ptr&& _Right) noexcept
        : _Mypair(_One_then_variadic_args_t{}, ::std:: forward<_Dx>(_Right.get_deleter()), _Right.release()) {}

    template <class _Dx2 = _Dx, enable_if_t<is_move_assignable_v<_Dx2>, int> = 0>
    inline unique_ptr& operator=(unique_ptr&& _Right) noexcept {
        if (this != ::std:: addressof(_Right)) {
            reset(_Right.release());
            _Mypair._Get_first() = ::std:: move(_Right._Mypair._Get_first());
        }

        return *this;
    }

    template <class _Uty, class _Ex, class _More, class _UP_pointer = typename unique_ptr<_Uty, _Ex>::pointer,
        class _UP_element_type = typename unique_ptr<_Uty, _Ex>::element_type>
    using _Enable_conversion = enable_if_t<
        conjunction_v<is_array<_Uty>, is_same<pointer, element_type*>, is_same<_UP_pointer, _UP_element_type*>,
            is_convertible<_UP_element_type (*)[], element_type (*)[]>, _More>,
        int>;

    template <class _Uty, class _Ex,
        _Enable_conversion<_Uty, _Ex, conditional_t<is_reference_v<_Dx>, is_same<_Ex, _Dx>, is_convertible<_Ex, _Dx>>> =
            0>
    inline unique_ptr(unique_ptr<_Uty, _Ex>&& _Right) noexcept
        : _Mypair(_One_then_variadic_args_t{}, ::std:: forward<_Ex>(_Right.get_deleter()), _Right.release()) {}

    template <class _Uty, class _Ex, _Enable_conversion<_Uty, _Ex, is_assignable<_Dx&, _Ex>> = 0>
    inline unique_ptr& operator=(unique_ptr<_Uty, _Ex>&& _Right) noexcept {
        reset(_Right.release());
        _Mypair._Get_first() = ::std:: forward<_Ex>(_Right._Mypair._Get_first());
        return *this;
    }

    template <class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0>
    constexpr unique_ptr(nullptr_t) noexcept : _Mypair(_Zero_then_variadic_args_t{}) {}

    inline unique_ptr& operator=(nullptr_t) noexcept {
        reset();
        return *this;
    }

    inline void reset(nullptr_t = nullptr) noexcept {
        reset(pointer());
    }

    inline void swap(unique_ptr& _Right) noexcept {
        _Swap_adl(_Mypair._Myval2, _Right._Mypair._Myval2);
        _Swap_adl(_Mypair._Get_first(), _Right._Mypair._Get_first());
    }

    inline ~unique_ptr() noexcept {
        if (_Mypair._Myval2) {
            _Mypair._Get_first()(_Mypair._Myval2);
        }
    }

    [[nodiscard]] inline _Dx& get_deleter() noexcept {
        return _Mypair._Get_first();
    }

    [[nodiscard]] inline const _Dx& get_deleter() const noexcept {
        return _Mypair._Get_first();
    }

    [[nodiscard]] inline _Ty& operator[](size_t _Idx) const noexcept   {
        return _Mypair._Myval2[_Idx];
    }

    [[nodiscard]] inline pointer get() const noexcept {
        return _Mypair._Myval2;
    }

    inline explicit operator bool() const noexcept {
        return static_cast<bool>(_Mypair._Myval2);
    }

    inline pointer release() noexcept {
        return ::std:: exchange(_Mypair._Myval2, nullptr);
    }

    template <class _Uty, _Enable_ctor_reset<_Uty, false_type> = 0>
    inline void reset(_Uty _Ptr) noexcept {
        pointer _Old = ::std:: exchange(_Mypair._Myval2, _Ptr);
        if (_Old) {
            _Mypair._Get_first()(_Old);
        }
    }

    unique_ptr(const unique_ptr&)            = delete;
    unique_ptr& operator=(const unique_ptr&) = delete;

private:
    template <class, class>
    friend class unique_ptr;

    _Compressed_pair<_Dx, pointer> _Mypair;
};


 template <class _Ty, class... _Types, enable_if_t<!is_array_v<_Ty>, int> = 0>
[[nodiscard("This function constructs an object wrapped by a smart pointer and has no other effects; " "it is not useful to call this function and discard the return value.")]] inline unique_ptr<_Ty> make_unique(_Types&&... _Args) { 
    return unique_ptr<_Ty>(new _Ty(::std:: forward<_Types>(_Args)...));
}

 template <class _Ty, enable_if_t<is_array_v<_Ty> && extent_v<_Ty> == 0, int> = 0>
[[nodiscard("This function constructs an object wrapped by a smart pointer and has no other effects; " "it is not useful to call this function and discard the return value.")]] inline unique_ptr<_Ty> make_unique(const size_t _Size) { 
    using _Elem = remove_extent_t<_Ty>;
    return unique_ptr<_Ty>(new _Elem[_Size]());
}

 template <class _Ty, class... _Types, enable_if_t<extent_v<_Ty> != 0, int> = 0>
void make_unique(_Types&&...) = delete;


 template <class _Ty, enable_if_t<!is_array_v<_Ty>, int> = 0>
[[nodiscard("This function constructs an object wrapped by a smart pointer and has no other effects; " "it is not useful to call this function and discard the return value.")]] inline unique_ptr<_Ty> make_unique_for_overwrite() {
    
    return unique_ptr<_Ty>(new _Ty);
}

 template <class _Ty, enable_if_t<is_unbounded_array_v<_Ty>, int> = 0>
[[nodiscard("This function constructs an object wrapped by a smart pointer and has no other effects; " "it is not useful to call this function and discard the return value.")]] inline unique_ptr<_Ty> make_unique_for_overwrite(const size_t _Size) {
    
    using _Elem = remove_extent_t<_Ty>;
    return unique_ptr<_Ty>(new _Elem[_Size]);
}

 template <class _Ty, class... _Types, enable_if_t<is_bounded_array_v<_Ty>, int> = 0>
void make_unique_for_overwrite(_Types&&...) = delete;
#line 3494 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"

 template <class _Ty, class _Dx, enable_if_t<_Is_swappable<_Dx>::value, int> = 0>
inline void swap(unique_ptr<_Ty, _Dx>& _Left, unique_ptr<_Ty, _Dx>& _Right) noexcept {
    _Left.swap(_Right);
}

 template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
[[nodiscard]] inline bool operator==(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right) {
    return _Left.get() == _Right.get();
}






#line 3511 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"

 template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
[[nodiscard]] bool operator<(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right) {
    using _Ptr1   = typename unique_ptr<_Ty1, _Dx1>::pointer;
    using _Ptr2   = typename unique_ptr<_Ty2, _Dx2>::pointer;
    using _Common = common_type_t<_Ptr1, _Ptr2>;
    return less<_Common>{}(_Left.get(), _Right.get());
}

 template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
[[nodiscard]] bool operator>=(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right) {
    return !(_Left < _Right);
}

 template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
[[nodiscard]] bool operator>(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right) {
    return _Right < _Left;
}

 template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
[[nodiscard]] bool operator<=(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right) {
    return !(_Right < _Left);
}



 template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
    requires three_way_comparable_with<typename unique_ptr<_Ty1, _Dx1>::pointer,
        typename unique_ptr<_Ty2, _Dx2>::pointer>
[[nodiscard]] compare_three_way_result_t<typename unique_ptr<_Ty1, _Dx1>::pointer,
        typename unique_ptr<_Ty2, _Dx2>::pointer>
    operator<=>(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right) {
    
    return _Left.get() <=> _Right.get();
}
#line 3547 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"

 template <class _Ty, class _Dx>
[[nodiscard]] inline bool operator==(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t) noexcept {
    return !_Left;
}
















#line 3569 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"

 template <class _Ty, class _Dx>
[[nodiscard]] inline bool operator<(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t _Right) {
    using _Ptr = typename unique_ptr<_Ty, _Dx>::pointer;
    return less<_Ptr>{}(_Left.get(), _Right);
}

 template <class _Ty, class _Dx>
[[nodiscard]] inline bool operator<(nullptr_t _Left, const unique_ptr<_Ty, _Dx>& _Right) {
    using _Ptr = typename unique_ptr<_Ty, _Dx>::pointer;
    return less<_Ptr>{}(_Left, _Right.get());
}

 template <class _Ty, class _Dx>
[[nodiscard]] inline bool operator>=(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t _Right) {
    return !(_Left < _Right);
}

 template <class _Ty, class _Dx>
[[nodiscard]] inline bool operator>=(nullptr_t _Left, const unique_ptr<_Ty, _Dx>& _Right) {
    return !(_Left < _Right);
}

 template <class _Ty, class _Dx>
[[nodiscard]] inline bool operator>(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t _Right) {
    return _Right < _Left;
}

 template <class _Ty, class _Dx>
[[nodiscard]] inline bool operator>(nullptr_t _Left, const unique_ptr<_Ty, _Dx>& _Right) {
    return _Right < _Left;
}

 template <class _Ty, class _Dx>
[[nodiscard]] inline bool operator<=(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t _Right) {
    return !(_Right < _Left);
}

 template <class _Ty, class _Dx>
[[nodiscard]] inline bool operator<=(nullptr_t _Left, const unique_ptr<_Ty, _Dx>& _Right) {
    return !(_Right < _Left);
}


 template <class _Ty, class _Dx>
    requires three_way_comparable<typename unique_ptr<_Ty, _Dx>::pointer>
[[nodiscard]] inline compare_three_way_result_t<typename unique_ptr<_Ty, _Dx>::pointer> operator<=>(
    const unique_ptr<_Ty, _Dx>& _Left, nullptr_t) {
    return _Left.get() <=> static_cast<typename unique_ptr<_Ty, _Dx>::pointer>(nullptr);
}
#line 3620 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"

template <class _OutTy, class _PxTy, class = void>
struct _Can_stream_unique_ptr : false_type {};
template <class _OutTy, class _PxTy>
struct _Can_stream_unique_ptr<_OutTy, _PxTy, void_t<decltype(::std:: declval<_OutTy>() << ::std:: declval<_PxTy>().get())>>
    : true_type {};

 template <class _Elem, class _Traits, class _Yty, class _Dx,
    enable_if_t<_Can_stream_unique_ptr<basic_ostream<_Elem, _Traits>&, const unique_ptr<_Yty, _Dx>&>::value, int> = 0>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Out, const unique_ptr<_Yty, _Dx>& _Px) {
    
    _Out << _Px.get();
    return _Out;
}


 enum class pointer_safety { relaxed, preferred, strict };

 inline void declare_reachable(void*) {}

 template <class _Ty>
_Ty* undeclare_reachable(_Ty* _Ptr) {
    return _Ptr;
}

 inline void declare_no_pointers(char*, size_t) {}

 inline void undeclare_no_pointers(char*, size_t) {}

 inline pointer_safety get_pointer_safety() noexcept {
    return pointer_safety::relaxed;
}
#line 3653 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"

 template <class _Ty = void>
struct owner_less; 

template <class _Ty>
struct owner_less<shared_ptr<_Ty>> {
    using _Unnameable_first_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]  = shared_ptr<_Ty>;
    using _Unnameable_second_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = shared_ptr<_Ty>;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]          = bool;

    [[nodiscard]] bool operator()(const shared_ptr<_Ty>& _Left, const shared_ptr<_Ty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }

    [[nodiscard]] bool operator()(const shared_ptr<_Ty>& _Left, const weak_ptr<_Ty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }

    [[nodiscard]] bool operator()(const weak_ptr<_Ty>& _Left, const shared_ptr<_Ty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }
};

template <class _Ty>
struct owner_less<weak_ptr<_Ty>> {
    using _Unnameable_first_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]  = weak_ptr<_Ty>;
    using _Unnameable_second_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = weak_ptr<_Ty>;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]          = bool;

    [[nodiscard]] bool operator()(const weak_ptr<_Ty>& _Left, const weak_ptr<_Ty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }

    [[nodiscard]] bool operator()(const weak_ptr<_Ty>& _Left, const shared_ptr<_Ty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }

    [[nodiscard]] bool operator()(const shared_ptr<_Ty>& _Left, const weak_ptr<_Ty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }
};

template <>
struct owner_less<void> {
    template <class _Ty, class _Uty>
    [[nodiscard]] bool operator()(const shared_ptr<_Ty>& _Left, const shared_ptr<_Uty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }

    template <class _Ty, class _Uty>
    [[nodiscard]] bool operator()(const shared_ptr<_Ty>& _Left, const weak_ptr<_Uty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }

    template <class _Ty, class _Uty>
    [[nodiscard]] bool operator()(const weak_ptr<_Ty>& _Left, const shared_ptr<_Uty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }

    template <class _Ty, class _Uty>
    [[nodiscard]] bool operator()(const weak_ptr<_Ty>& _Left, const weak_ptr<_Uty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }

    using is_transparent = int;
};

template <class _Ty, class _Dx>
struct hash<unique_ptr<_Ty, _Dx>> : _Conditionally_enabled_hash<unique_ptr<_Ty, _Dx>,
                                        is_default_constructible_v<hash<typename unique_ptr<_Ty, _Dx>::pointer>>> {
    static size_t _Do_hash(const unique_ptr<_Ty, _Dx>& _Keyval) noexcept(
        _Is_nothrow_hashable<typename unique_ptr<_Ty, _Dx>::pointer>::value) {
        return hash<typename unique_ptr<_Ty, _Dx>::pointer>{}(_Keyval.get());
    }
};

template <class _Ty>
struct hash<shared_ptr<_Ty>> {
    using _Unnameable_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = shared_ptr<_Ty>;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]   = size_t;

    [[nodiscard]] size_t operator()(const shared_ptr<_Ty>& _Keyval) const noexcept {
        return hash<typename shared_ptr<_Ty>::element_type*>()(_Keyval.get());
    }
};


 template <size_t _Nx, class _Ty>
[[nodiscard("'std::assume_aligned' has a potential effect on the return value (not on the passed argument). " "It is not useful to call 'std::assume_aligned' and discard the return value.")]] constexpr _Ty* assume_aligned(_Ty* const _Ptr) noexcept   {
    if (::std:: is_constant_evaluated()) {
        return _Ptr;
    } else {
        
        return static_cast<_Ty*>(__builtin_assume_aligned(_Ptr, _Nx));
    }
}
#line 3750 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"

extern "C" {
 void __cdecl _Lock_shared_ptr_spin_lock();
 void __cdecl _Unlock_shared_ptr_spin_lock();
}

struct _Shared_ptr_spin_lock { 
    _Shared_ptr_spin_lock() { 
        _Lock_shared_ptr_spin_lock();
    }

    ~_Shared_ptr_spin_lock() noexcept { 
        _Unlock_shared_ptr_spin_lock();
    }
};

 template <class _Ty>
[[deprecated("warning STL4029: " "std::atomic_*() overloads for shared_ptr are deprecated in C++20. " "The shared_ptr specialization of std::atomic provides superior functionality. " "You can define _SILENCE_CXX20_OLD_SHARED_PTR_ATOMIC_SUPPORT_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] [[nodiscard]] bool atomic_is_lock_free(const shared_ptr<_Ty>*) {
    
    return false;
}

 template <class _Ty>
[[deprecated("warning STL4029: " "std::atomic_*() overloads for shared_ptr are deprecated in C++20. " "The shared_ptr specialization of std::atomic provides superior functionality. " "You can define _SILENCE_CXX20_OLD_SHARED_PTR_ATOMIC_SUPPORT_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] [[nodiscard]] shared_ptr<_Ty> atomic_load_explicit(
    const shared_ptr<_Ty>* _Ptr, memory_order) {
    
    _Shared_ptr_spin_lock _Lock;
    shared_ptr<_Ty> _Result = *_Ptr;
    return _Result;
}

 template <class _Ty>
[[deprecated("warning STL4029: " "std::atomic_*() overloads for shared_ptr are deprecated in C++20. " "The shared_ptr specialization of std::atomic provides superior functionality. " "You can define _SILENCE_CXX20_OLD_SHARED_PTR_ATOMIC_SUPPORT_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] [[nodiscard]] shared_ptr<_Ty> atomic_load(
    const shared_ptr<_Ty>* _Ptr) { 
    return ::std:: atomic_load_explicit(_Ptr, memory_order_seq_cst);
}

 template <class _Ty>
[[deprecated("warning STL4029: " "std::atomic_*() overloads for shared_ptr are deprecated in C++20. " "The shared_ptr specialization of std::atomic provides superior functionality. " "You can define _SILENCE_CXX20_OLD_SHARED_PTR_ATOMIC_SUPPORT_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] void atomic_store_explicit(
    shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty> _Other, memory_order) {
    
    _Shared_ptr_spin_lock _Lock;
    _Ptr->swap(_Other);
}

 template <class _Ty>
[[deprecated("warning STL4029: " "std::atomic_*() overloads for shared_ptr are deprecated in C++20. " "The shared_ptr specialization of std::atomic provides superior functionality. " "You can define _SILENCE_CXX20_OLD_SHARED_PTR_ATOMIC_SUPPORT_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] void atomic_store(
    shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty> _Other) { 
    ::std:: atomic_store_explicit(_Ptr, ::std:: move(_Other), memory_order_seq_cst);
}

 template <class _Ty>
[[deprecated("warning STL4029: " "std::atomic_*() overloads for shared_ptr are deprecated in C++20. " "The shared_ptr specialization of std::atomic provides superior functionality. " "You can define _SILENCE_CXX20_OLD_SHARED_PTR_ATOMIC_SUPPORT_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] shared_ptr<_Ty> atomic_exchange_explicit(
    shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty> _Other, memory_order) {
    
    _Shared_ptr_spin_lock _Lock;
    _Ptr->swap(_Other);
    return _Other;
}

 template <class _Ty>
[[deprecated("warning STL4029: " "std::atomic_*() overloads for shared_ptr are deprecated in C++20. " "The shared_ptr specialization of std::atomic provides superior functionality. " "You can define _SILENCE_CXX20_OLD_SHARED_PTR_ATOMIC_SUPPORT_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] shared_ptr<_Ty> atomic_exchange(
    shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty> _Other) {
    
    return ::std:: atomic_exchange_explicit(_Ptr, ::std:: move(_Other), memory_order_seq_cst);
}

 template <class _Ty>
[[deprecated("warning STL4029: " "std::atomic_*() overloads for shared_ptr are deprecated in C++20. " "The shared_ptr specialization of std::atomic provides superior functionality. " "You can define _SILENCE_CXX20_OLD_SHARED_PTR_ATOMIC_SUPPORT_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] bool atomic_compare_exchange_weak_explicit(shared_ptr<_Ty>* _Ptr,
    shared_ptr<_Ty>* _Exp, shared_ptr<_Ty> _Value, memory_order, memory_order) { 
    shared_ptr<_Ty> _Old_exp; 
    _Shared_ptr_spin_lock _Lock;
    bool _Success = _Ptr->get() == _Exp->get() && !_Ptr->owner_before(*_Exp) && !_Exp->owner_before(*_Ptr);
    if (_Success) {
        _Ptr->swap(_Value);
    } else { 
        _Exp->swap(_Old_exp);
        *_Exp = *_Ptr;
    }
    return _Success;
}

 template <class _Ty>
[[deprecated("warning STL4029: " "std::atomic_*() overloads for shared_ptr are deprecated in C++20. " "The shared_ptr specialization of std::atomic provides superior functionality. " "You can define _SILENCE_CXX20_OLD_SHARED_PTR_ATOMIC_SUPPORT_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] bool atomic_compare_exchange_weak(
    shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty>* _Exp, shared_ptr<_Ty> _Value) {
    
    return ::std:: atomic_compare_exchange_weak_explicit(
        _Ptr, _Exp, ::std:: move(_Value), memory_order_seq_cst, memory_order_seq_cst);
}

 template <class _Ty>
[[deprecated("warning STL4029: " "std::atomic_*() overloads for shared_ptr are deprecated in C++20. " "The shared_ptr specialization of std::atomic provides superior functionality. " "You can define _SILENCE_CXX20_OLD_SHARED_PTR_ATOMIC_SUPPORT_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] bool atomic_compare_exchange_strong_explicit(shared_ptr<_Ty>* _Ptr,
    shared_ptr<_Ty>* _Exp, shared_ptr<_Ty> _Value, memory_order, memory_order) { 
    return ::std:: atomic_compare_exchange_weak_explicit(
        _Ptr, _Exp, ::std:: move(_Value), memory_order_seq_cst, memory_order_seq_cst);
}

 template <class _Ty>
[[deprecated("warning STL4029: " "std::atomic_*() overloads for shared_ptr are deprecated in C++20. " "The shared_ptr specialization of std::atomic provides superior functionality. " "You can define _SILENCE_CXX20_OLD_SHARED_PTR_ATOMIC_SUPPORT_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] bool atomic_compare_exchange_strong(
    shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty>* _Exp, shared_ptr<_Ty> _Value) {
    
    return ::std:: atomic_compare_exchange_strong_explicit(
        _Ptr, _Exp, ::std:: move(_Value), memory_order_seq_cst, memory_order_seq_cst);
}


template <class _Ty>
class alignas(2 * sizeof(void*)) _Atomic_ptr_base {
    
protected:
    constexpr _Atomic_ptr_base() noexcept = default;

    _Atomic_ptr_base(remove_extent_t<_Ty>* const _Px, _Ref_count_base* const _Ref) noexcept
        : _Ptr(_Px), _Repptr(_Ref) {}

    void _Wait(remove_extent_t<_Ty>* _Old, memory_order) const noexcept {
        for (;;) {
            auto _Rep   = _Repptr._Lock_and_load();
            bool _Equal = _Ptr.load(memory_order_relaxed) == _Old;
            _Repptr._Store_and_unlock(_Rep);
            if (!_Equal) {
                break;
            }
            __std_atomic_wait_direct(&_Ptr, &_Old, sizeof(_Old), _Atomic_wait_no_timeout);
        }
    }

    void notify_one() noexcept {
        _Ptr.notify_one();
    }

    void notify_all() noexcept {
        _Ptr.notify_all();
    }

    atomic<remove_extent_t<_Ty>*> _Ptr{nullptr};
    mutable _Locked_pointer<_Ref_count_base> _Repptr;
};

template <class _Ty>
struct atomic<shared_ptr<_Ty>> : private _Atomic_ptr_base<_Ty> {
private:
    using _Base = _Atomic_ptr_base<_Ty>;

public:
    using value_type = shared_ptr<_Ty>;

    static constexpr bool is_always_lock_free = false;

    [[nodiscard]] bool is_lock_free() const noexcept {
        return false;
    }

    void store(shared_ptr<_Ty> _Value, const memory_order _Order = memory_order_seq_cst) noexcept {
        _Check_store_memory_order(_Order);
        const auto _Rep                  = this->_Repptr._Lock_and_load();
        remove_extent_t<_Ty>* const _Tmp = _Value._Ptr;
        _Value._Ptr                      = this->_Ptr.load(memory_order_relaxed);
        this->_Ptr.store(_Tmp, memory_order_relaxed);
        this->_Repptr._Store_and_unlock(_Value._Rep);
        _Value._Rep = _Rep;
    }

    [[nodiscard]] shared_ptr<_Ty> load(const memory_order _Order = memory_order_seq_cst) const noexcept {
        _Check_load_memory_order(_Order);
        shared_ptr<_Ty> _Result;
        const auto _Rep = this->_Repptr._Lock_and_load();
        _Result._Ptr    = this->_Ptr.load(memory_order_relaxed);
        _Result._Rep    = _Rep;
        _Result._Incref();
        this->_Repptr._Store_and_unlock(_Rep);
        return _Result;
    }

    operator shared_ptr<_Ty>() const noexcept {
        return load();
    }

    shared_ptr<_Ty> exchange(shared_ptr<_Ty> _Value, const memory_order _Order = memory_order_seq_cst) noexcept {
        _Check_memory_order(static_cast<unsigned int>(_Order));
        shared_ptr<_Ty> _Result;
        _Result._Rep = this->_Repptr._Lock_and_load();
        _Result._Ptr = this->_Ptr.load(memory_order_relaxed);
        this->_Ptr.store(_Value._Ptr, memory_order_relaxed);
        this->_Repptr._Store_and_unlock(_Value._Rep);
        _Value._Ptr = nullptr; 
        _Value._Rep = nullptr;
        return _Result;
    }

    bool compare_exchange_weak(shared_ptr<_Ty>& _Expected, shared_ptr<_Ty> _Desired, const memory_order _Success,
        const memory_order _Failure) noexcept {
        return compare_exchange_strong(_Expected, ::std:: move(_Desired), _Combine_cas_memory_orders(_Success, _Failure));
    }

    bool compare_exchange_strong(shared_ptr<_Ty>& _Expected, shared_ptr<_Ty> _Desired, const memory_order _Success,
        const memory_order _Failure) noexcept {
        return compare_exchange_strong(_Expected, ::std:: move(_Desired), _Combine_cas_memory_orders(_Success, _Failure));
    }

    bool compare_exchange_weak(shared_ptr<_Ty>& _Expected, shared_ptr<_Ty> _Desired,
        const memory_order _Order = memory_order_seq_cst) noexcept {
        return compare_exchange_strong(_Expected, ::std:: move(_Desired), _Order);
    }

    bool compare_exchange_strong(shared_ptr<_Ty>& _Expected, shared_ptr<_Ty> _Desired,
        const memory_order _Order = memory_order_seq_cst) noexcept {
        _Check_memory_order(static_cast<unsigned int>(_Order));
        auto _Rep = this->_Repptr._Lock_and_load();
        if (this->_Ptr.load(memory_order_relaxed) == _Expected._Ptr && _Rep == _Expected._Rep) {
            remove_extent_t<_Ty>* const _Tmp = _Desired._Ptr;
            _Desired._Ptr                    = this->_Ptr.load(memory_order_relaxed);
            this->_Ptr.store(_Tmp, memory_order_relaxed);
            ::std:: swap(_Rep, _Desired._Rep);
            this->_Repptr._Store_and_unlock(_Rep);
            return true;
        }
        _Ref_count_base* _Expected_rep = _Expected._Rep;
        _Expected._Ptr                 = this->_Ptr.load(memory_order_relaxed);
        _Expected._Rep                 = _Rep;
        _Expected._Incref();
        this->_Repptr._Store_and_unlock(_Rep);
        if (_Expected_rep) {
            _Expected_rep->_Decref();
        }
        return false;
    }

    void wait(shared_ptr<_Ty> _Old, memory_order _Order = memory_order_seq_cst) const noexcept {
        this->_Wait(_Old._Ptr, _Order);
    }

    using _Base::notify_all;
    using _Base::notify_one;

    constexpr atomic() noexcept = default;

    constexpr atomic(nullptr_t) noexcept : atomic() {}

    atomic(const shared_ptr<_Ty> _Value) noexcept : _Base(_Value._Ptr, _Value._Rep) {
        _Value._Incref();
    }

    atomic(const atomic&)         = delete;
    void operator=(const atomic&) = delete;

    void operator=(shared_ptr<_Ty> _Value) noexcept {
        store(::std:: move(_Value));
    }

    ~atomic() {
        const auto _Rep = this->_Repptr._Unsafe_load_relaxed();
        if (_Rep) {
            _Rep->_Decref();
        }
    }
};

template <class _Ty>
struct atomic<weak_ptr<_Ty>> : private _Atomic_ptr_base<_Ty> {
private:
    using _Base = _Atomic_ptr_base<_Ty>;

public:
    using value_type = weak_ptr<_Ty>;

    static constexpr bool is_always_lock_free = false;

    [[nodiscard]] bool is_lock_free() const noexcept {
        return false;
    }

    void store(weak_ptr<_Ty> _Value, const memory_order _Order = memory_order_seq_cst) noexcept {
        _Check_store_memory_order(_Order);
        const auto _Rep                  = this->_Repptr._Lock_and_load();
        remove_extent_t<_Ty>* const _Tmp = _Value._Ptr;
        _Value._Ptr                      = this->_Ptr.load(memory_order_relaxed);
        this->_Ptr.store(_Tmp, memory_order_relaxed);
        this->_Repptr._Store_and_unlock(_Value._Rep);
        _Value._Rep = _Rep;
    }

    [[nodiscard]] weak_ptr<_Ty> load(const memory_order _Order = memory_order_seq_cst) const noexcept {
        _Check_load_memory_order(_Order);
        weak_ptr<_Ty> _Result;
        const auto _Rep = this->_Repptr._Lock_and_load();
        _Result._Ptr    = this->_Ptr.load(memory_order_relaxed);
        _Result._Rep    = _Rep;
        _Result._Incwref();
        this->_Repptr._Store_and_unlock(_Rep);
        return _Result;
    }

    operator weak_ptr<_Ty>() const noexcept {
        return load();
    }

    weak_ptr<_Ty> exchange(weak_ptr<_Ty> _Value, const memory_order _Order = memory_order_seq_cst) noexcept {
        _Check_memory_order(static_cast<unsigned int>(_Order));
        weak_ptr<_Ty> _Result;
        _Result._Rep = this->_Repptr._Lock_and_load();
        _Result._Ptr = this->_Ptr.load(memory_order_relaxed);
        this->_Ptr.store(_Value._Ptr, memory_order_relaxed);
        this->_Repptr._Store_and_unlock(_Value._Rep);
        _Value._Ptr = nullptr; 
        _Value._Rep = nullptr;
        return _Result;
    }

    bool compare_exchange_weak(weak_ptr<_Ty>& _Expected, weak_ptr<_Ty> _Desired, const memory_order _Success,
        const memory_order _Failure) noexcept {
        return compare_exchange_strong(_Expected, ::std:: move(_Desired), _Combine_cas_memory_orders(_Success, _Failure));
    }

    bool compare_exchange_strong(weak_ptr<_Ty>& _Expected, weak_ptr<_Ty> _Desired, const memory_order _Success,
        const memory_order _Failure) noexcept {
        return compare_exchange_strong(_Expected, ::std:: move(_Desired), _Combine_cas_memory_orders(_Success, _Failure));
    }

    bool compare_exchange_weak(
        weak_ptr<_Ty>& _Expected, weak_ptr<_Ty> _Desired, const memory_order _Order = memory_order_seq_cst) noexcept {
        return compare_exchange_strong(_Expected, ::std:: move(_Desired), _Order);
    }

    bool compare_exchange_strong(
        weak_ptr<_Ty>& _Expected, weak_ptr<_Ty> _Desired, const memory_order _Order = memory_order_seq_cst) noexcept {
        _Check_memory_order(static_cast<unsigned int>(_Order));
        auto _Rep = this->_Repptr._Lock_and_load();
        if (this->_Ptr.load(memory_order_relaxed) == _Expected._Ptr && _Rep == _Expected._Rep) {
            remove_extent_t<_Ty>* const _Tmp = _Desired._Ptr;
            _Desired._Ptr                    = this->_Ptr.load(memory_order_relaxed);
            this->_Ptr.store(_Tmp, memory_order_relaxed);
            ::std:: swap(_Rep, _Desired._Rep);
            this->_Repptr._Store_and_unlock(_Rep);
            return true;
        }
        const auto _Expected_rep = _Expected._Rep;
        _Expected._Ptr           = this->_Ptr.load(memory_order_relaxed);
        _Expected._Rep           = _Rep;
        _Expected._Incwref();
        this->_Repptr._Store_and_unlock(_Rep);
        if (_Expected_rep) {
            _Expected_rep->_Decwref();
        }
        return false;
    }

    void wait(weak_ptr<_Ty> _Old, memory_order _Order = memory_order_seq_cst) const noexcept {
        this->_Wait(_Old._Ptr, _Order);
    }

    using _Base::notify_all;
    using _Base::notify_one;

    constexpr atomic() noexcept = default;

    atomic(const weak_ptr<_Ty> _Value) noexcept : _Base(_Value._Ptr, _Value._Rep) {
        _Value._Incwref();
    }

    atomic(const atomic&)         = delete;
    void operator=(const atomic&) = delete;

    void operator=(weak_ptr<_Ty> _Value) noexcept {
        store(::std:: move(_Value));
    }

    ~atomic() {
        const auto _Rep = this->_Repptr._Unsafe_load_relaxed();
        if (_Rep) {
            _Rep->_Decwref();
        }
    }
};
#line 4125 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"




































































































































































































#line 4322 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"















#line 4338 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"

}


#pragma warning(pop)
#pragma pack(pop)
#line 4345 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"
#line 4346 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\memory"
#pragma external_header(pop)
#line 14 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xlocale"

#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xfacet"





#pragma once





#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )









namespace std {
extern "C++" class __declspec(dllimport) _Facet_base { 
public:
    virtual  ~_Facet_base() noexcept {} 

    
    virtual void  _Incref() noexcept = 0;

    
    virtual _Facet_base*  _Decref() noexcept = 0;
};




#line 40 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xfacet"
extern "C++" void __cdecl _Facet_Register(_Facet_base*);
#line 42 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xfacet"
}


#pragma warning(pop)
#pragma pack(pop)
#line 48 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xfacet"
#line 49 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xfacet"
#pragma external_header(pop)
#line 16 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xlocale"
#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xlocinfo"





#pragma once




#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\__msvc_xlocinfo_types.hpp"





#pragma once





#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




extern "C" {

struct _Collvec { 
    unsigned int _Page; 
    wchar_t* _LocaleName;
};

struct _Ctypevec { 
    unsigned int _Page; 
    const short* _Table;
    int _Delfl;
    wchar_t* _LocaleName;
};

struct _Cvtvec { 
    unsigned int _Page; 
    unsigned int _Mbcurmax;
    int _Isclocale; 
    unsigned char _Isleadbyte[32]; 
};

}



#pragma warning(pop)
#pragma pack(pop)
#line 47 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\__msvc_xlocinfo_types.hpp"
#line 48 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\__msvc_xlocinfo_types.hpp"
#pragma external_header(pop)
#line 12 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xlocinfo"
#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cctype"





#pragma once





#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\ctype.h"







#pragma once






#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {









 __declspec(dllimport) int __cdecl _isctype( int _C,  int _Type);
 __declspec(dllimport) int __cdecl _isctype_l( int _C,  int _Type,  _locale_t _Locale);
  __declspec(dllimport) int __cdecl isalpha( int _C);
 __declspec(dllimport) int __cdecl _isalpha_l( int _C,  _locale_t _Locale);
  __declspec(dllimport) int __cdecl isupper( int _C);
 __declspec(dllimport) int __cdecl _isupper_l( int _C,  _locale_t _Locale);
  __declspec(dllimport) int __cdecl islower( int _C);
 __declspec(dllimport) int __cdecl _islower_l( int _C,  _locale_t _Locale);


  __declspec(dllimport) int __cdecl isdigit( int _C);

 __declspec(dllimport) int __cdecl _isdigit_l( int _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl isxdigit( int _C);
 __declspec(dllimport) int __cdecl _isxdigit_l( int _C,  _locale_t _Locale);


  __declspec(dllimport) int __cdecl isspace( int _C);

 __declspec(dllimport) int __cdecl _isspace_l( int _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl ispunct( int _C);
 __declspec(dllimport) int __cdecl _ispunct_l( int _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl isblank( int _C);
 __declspec(dllimport) int __cdecl _isblank_l( int _C,  _locale_t _Locale);
  __declspec(dllimport) int __cdecl isalnum( int _C);
 __declspec(dllimport) int __cdecl _isalnum_l( int _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl isprint( int _C);
 __declspec(dllimport) int __cdecl _isprint_l( int _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl isgraph( int _C);
 __declspec(dllimport) int __cdecl _isgraph_l( int _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl iscntrl( int _C);
 __declspec(dllimport) int __cdecl _iscntrl_l( int _C,  _locale_t _Locale);


  __declspec(dllimport) int __cdecl toupper( int _C);


  __declspec(dllimport) int __cdecl tolower( int _C);

  __declspec(dllimport) int __cdecl _tolower( int _C);
 __declspec(dllimport) int __cdecl _tolower_l( int _C,  _locale_t _Locale);
  __declspec(dllimport) int __cdecl _toupper( int _C);
 __declspec(dllimport) int __cdecl _toupper_l( int _C,  _locale_t _Locale);

 __declspec(dllimport) int __cdecl __isascii( int _C);
 __declspec(dllimport) int __cdecl __toascii( int _C);
 __declspec(dllimport) int __cdecl __iscsymf( int _C);
 __declspec(dllimport) int __cdecl __iscsym( int _C);








__inline int __cdecl __acrt_locale_get_ctype_array_value(
     unsigned short const * const _Locale_pctype_array,
             int                    const _Char_value,
                            int                    const _Mask
    )
{
    
    
    
    

    if (_Char_value >= -1 && _Char_value <= 255)
    {
        return _Locale_pctype_array[_Char_value] & _Mask;
    }

    return 0;
}



    
    
    




















    
    
    




        
    #line 138 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\ctype.h"



    
    

    







        __forceinline int __cdecl __ascii_tolower(int const _C)
        {
            if (_C >= 'A' && _C <= 'Z')
            {
                return _C - ('A' - 'a');
            }
            return _C;
        }

        __forceinline int __cdecl __ascii_toupper(int const _C)
        {
            if (_C >= 'a' && _C <= 'z')
            {
                return _C - ('a' - 'A');
            }
            return _C;
        }

        __forceinline int __cdecl __ascii_iswalpha(int const _C)
        {
            return (_C >= 'A' && _C <= 'Z') || (_C >= 'a' && _C <= 'z');
        }

        __forceinline int __cdecl __ascii_iswdigit(int const _C)
        {
            return _C >= '0' && _C <= '9';
        }

        __forceinline int __cdecl __ascii_towlower(int const _C)
        {
            return __ascii_tolower(_C);
        }

        __forceinline int __cdecl __ascii_towupper(int const _C)
        {
            return __ascii_toupper(_C);
        }
    #line 190 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\ctype.h"



    












#line 207 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\ctype.h"

    __inline __crt_locale_data_public* __cdecl __acrt_get_locale_data_prefix(void const volatile* const _LocalePointers)
    {
        _locale_t const _TypedLocalePointers = (_locale_t)_LocalePointers;
        return (__crt_locale_data_public*)_TypedLocalePointers->locinfo;
    }

    



    __inline int __cdecl _chvalidchk_l(
             int       const _C,
             int       const _Mask,
         _locale_t const _Locale
        )
    {
        


        if (!_Locale)
        {
            return (__acrt_locale_get_ctype_array_value(__pctype_func(), (_C), (_Mask))) ;
        }

        return __acrt_locale_get_ctype_array_value(__acrt_get_locale_data_prefix(_Locale)->_locale_pctype, _C, _Mask);
        #line 234 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\ctype.h"
    }

    
    

    __inline int __cdecl _ischartype_l(
             int       const _C,
             int       const _Mask,
         _locale_t const _Locale
        )
    {
        if (!_Locale)
        {
            return _chvalidchk_l(_C, _Mask, 0);
        }

        if (_C >= -1 && _C <= 255)
        {
            return __acrt_get_locale_data_prefix(_Locale)->_locale_pctype[_C] & _Mask;
        }

        if (__acrt_get_locale_data_prefix(_Locale)->_locale_mb_cur_max > 1)
        {
            return _isctype_l(_C, _Mask, _Locale);
        }

        return 0; 
    }

    
    
    
    
    
    
    
    
    
    
    
    

    
    

    
    


    
    
    
    
    

    
    
    
    

#line 295 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\ctype.h"



    
    
    
    
#line 303 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\ctype.h"



#line 307 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\ctype.h"
} __pragma(pack(pop))

#pragma warning(pop) 
#line 311 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\ctype.h"
#pragma external_header(pop)
#line 13 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cctype"

#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




namespace std {
 using :: isalnum;
 using :: isalpha;
 using :: iscntrl;
 using :: isdigit;
 using :: isgraph;
 using :: islower;
 using :: isprint;
 using :: ispunct;
 using :: isspace;
 using :: isupper;
 using :: isxdigit;
 using :: tolower;
 using :: toupper;

 using :: isblank;
}



#pragma warning(pop)
#pragma pack(pop)

#line 45 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cctype"
#line 46 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cctype"
#pragma external_header(pop)
#line 13 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xlocinfo"
#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\clocale"





#pragma once





#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\locale.h"







#pragma once





#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {















struct lconv
{
    char*    decimal_point;
    char*    thousands_sep;
    char*    grouping;
    char*    int_curr_symbol;
    char*    currency_symbol;
    char*    mon_decimal_point;
    char*    mon_thousands_sep;
    char*    mon_grouping;
    char*    positive_sign;
    char*    negative_sign;
    char     int_frac_digits;
    char     frac_digits;
    char     p_cs_precedes;
    char     p_sep_by_space;
    char     n_cs_precedes;
    char     n_sep_by_space;
    char     p_sign_posn;
    char     n_sign_posn;
    wchar_t* _W_decimal_point;
    wchar_t* _W_thousands_sep;
    wchar_t* _W_int_curr_symbol;
    wchar_t* _W_currency_symbol;
    wchar_t* _W_mon_decimal_point;
    wchar_t* _W_mon_thousands_sep;
    wchar_t* _W_positive_sign;
    wchar_t* _W_negative_sign;
};

struct tm;























    __declspec(dllimport) void __cdecl _lock_locales(void);
    __declspec(dllimport) void __cdecl _unlock_locales(void);

    
    __declspec(dllimport) int __cdecl _configthreadlocale(
         int _Flag
        );

      
    __declspec(dllimport) char* __cdecl setlocale(
               int         _Category,
         char const* _Locale
        );

    
    __declspec(dllimport) struct lconv* __cdecl localeconv(void);

    
    __declspec(dllimport) _locale_t __cdecl _get_current_locale(void);

    
    __declspec(dllimport) _locale_t __cdecl _create_locale(
           int         _Category,
         char const* _Locale
        );

    __declspec(dllimport) void __cdecl _free_locale(
         _locale_t _Locale
        );

    
      
    __declspec(dllimport) wchar_t* __cdecl _wsetlocale(
               int            _Category,
         wchar_t const* _Locale
        );

    
    __declspec(dllimport) _locale_t __cdecl _wcreate_locale(
           int            _Category,
         wchar_t const* _Locale
        );



    __declspec(dllimport) wchar_t**    __cdecl ___lc_locale_name_func(void);
    __declspec(dllimport) unsigned int __cdecl ___lc_codepage_func   (void);
    __declspec(dllimport) unsigned int __cdecl ___lc_collate_cp_func (void);




    
    
    
    __declspec(dllimport) char*    __cdecl _Getdays(void);

    
    
    __declspec(dllimport) char*    __cdecl _Getmonths(void);

    __declspec(dllimport) void*    __cdecl _Gettnames(void);

    
    
    __declspec(dllimport) wchar_t* __cdecl _W_Getdays(void);

    
    
    __declspec(dllimport) wchar_t* __cdecl _W_Getmonths(void);

    __declspec(dllimport) void*    __cdecl _W_Gettnames(void);

    
    __declspec(dllimport) size_t __cdecl _Strftime(
         char*           _Buffer,
                             size_t           _Max_size,
                           char const*      _Format,
                             struct tm const* _Timeptr,
                         void*            _Lc_time_arg);

    
    __declspec(dllimport) size_t __cdecl _Wcsftime(
         wchar_t*        _Buffer,
                             size_t           _Max_size,
                           wchar_t const*   _Format,
                             struct tm const* _Timeptr,
                         void*            _Lc_time_arg
        );

#line 179 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\locale.h"


} __pragma(pack(pop))

#pragma warning(pop) 
#line 185 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\locale.h"
#pragma external_header(pop)
#line 13 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\clocale"

#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




namespace std {
 using :: lconv;
 using :: localeconv;
 using :: setlocale;
}



#pragma warning(pop)
#pragma pack(pop)

#line 33 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\clocale"
#line 34 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\clocale"
#pragma external_header(pop)
#line 14 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xlocinfo"






#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




extern "C" {




















 _Collvec __cdecl _Getcoll();
 _Ctypevec __cdecl _Getctype();
 _Cvtvec __cdecl _Getcvt();
 int __cdecl _Getdateorder();







  int __cdecl _Mbrtowc(
     wchar_t*, const char*, size_t _Max_multibyte, mbstate_t*, const _Cvtvec*);
#line 62 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xlocinfo"

 int __cdecl _Strcoll(const char*, const char*, const char*, const char*, const _Collvec*);
 size_t __cdecl _Strxfrm(
                                                           char* _String1,
     char* _End1, const char*, const char*, const _Collvec*);
 int __cdecl _Tolower(int, const _Ctypevec*);
 int __cdecl _Toupper(int, const _Ctypevec*);
  int __cdecl
    _Wcrtomb( char*, wchar_t, mbstate_t*, const _Cvtvec*);
 int __cdecl _Wcscoll(
    const wchar_t*, const wchar_t*, const wchar_t*, const wchar_t*, const _Collvec*);
 size_t __cdecl _Wcsxfrm( 
                                                          wchar_t* _String1,
     wchar_t* _End1, const wchar_t*, const wchar_t*, const _Collvec*);

 short __cdecl _Getwctype(wchar_t, const _Ctypevec*);
 const wchar_t* __cdecl _Getwctypes(
    const wchar_t*, const wchar_t*, short*, const _Ctypevec*);
 wchar_t __cdecl _Towlower(wchar_t, const _Ctypevec*);
 wchar_t __cdecl _Towupper(wchar_t, const _Ctypevec*);

}

extern "C" {
  __declspec(dllimport) char* __cdecl _Getdays();

  __declspec(dllimport) char* __cdecl _Getmonths();

__declspec(dllimport) void* __cdecl _Gettnames();

 __declspec(dllimport) size_t __cdecl _Strftime(
     char*,  size_t _Maxsize,  const char*,  const tm*,  void*);

  __declspec(dllimport) wchar_t* __cdecl _W_Getdays();

  __declspec(dllimport) wchar_t* __cdecl _W_Getmonths();

__declspec(dllimport) void* __cdecl _W_Gettnames();

 __declspec(dllimport) size_t __cdecl _Wcsftime(
     wchar_t*,  size_t _Maxsize,  const wchar_t*,  const tm*,  void*);
}

namespace std {
extern "C++" class __declspec(dllimport) _Timevec { 
public:
    explicit  _Timevec(void* _Ptr = nullptr) : _Timeptr(_Ptr) {}

     _Timevec(const _Timevec& _Right) : _Timeptr(nullptr) {
        *this = _Right;
    }

     ~_Timevec() noexcept {
        :: free(_Timeptr);
    }

    _Timevec&  operator=(const _Timevec& _Right) { 
        if (this != &_Right) {
            :: free(_Timeptr);
            _Timeptr                               = _Right._Timeptr;
            const_cast<_Timevec&>(_Right)._Timeptr = nullptr; 
        }

        return *this;
    }

    void*  _Getptr() const {
        return _Timeptr;
    }

private:
    void* _Timeptr; 
};

extern "C++" template <class _Elem>
class __declspec(dllimport) _Yarn { 
public:
     _Yarn() noexcept : _Myptr(nullptr), _Nul(0) {}

     _Yarn(const _Yarn& _Right) noexcept : _Myptr(nullptr), _Nul(0) {
        *this = _Right;
    }

     _Yarn(const _Elem* _Right) noexcept : _Myptr(nullptr), _Nul(0) {
        *this = _Right;
    }

    _Yarn&  operator=(const _Yarn& _Right) noexcept {
        return *this = _Right._Myptr;
    }

    _Yarn&  operator=(const _Elem* _Right) noexcept {
        if (_Myptr != _Right) { 
            _Tidy();

            if (_Right) { 
                const _Elem* _Ptr = _Right;
                while (*_Ptr != _Elem{}) {
                    ++_Ptr;
                }

                const auto _Count = (++_Ptr - _Right) * sizeof(_Elem);




                _Myptr = static_cast<_Elem*>(:: malloc(_Count));
#line 170 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xlocinfo"

                if (_Myptr) {
                    :: memcpy(_Myptr, _Right, _Count);
                }
            }
        }

        return *this;
    }

     ~_Yarn() noexcept {
        _Tidy();
    }

    [[nodiscard]] bool  empty() const noexcept {
        return _Myptr == nullptr;
    }

     const _Elem*  c_str() const noexcept {
        return _Myptr ? _Myptr : &_Nul;
    }

    [[nodiscard]] bool  _Empty() const noexcept {
        return _Myptr == nullptr;
    }

     const _Elem*  _C_str() const noexcept {
        return _Myptr ? _Myptr : &_Nul;
    }

private:
    void  _Tidy() noexcept {
        if (_Myptr) {



            :: free(_Myptr);
#line 208 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xlocinfo"
        }

        _Myptr = nullptr;
    }

    _Elem* _Myptr; 
    _Elem _Nul; 
};

extern "C++" class __declspec(dllimport) _Locinfo { 
public:
    using _Collvec  = ::_Collvec;
    using _Ctypevec = ::_Ctypevec;
    using _Cvtvec   = ::_Cvtvec;
    using _Timevec  = ::std:: _Timevec;

    static void __cdecl _Locinfo_ctor(_Locinfo*, const char*);
    static void __cdecl _Locinfo_ctor(_Locinfo*, int, const char*);
    static void __cdecl _Locinfo_dtor(_Locinfo*);
    static _Locinfo& __cdecl _Locinfo_Addcats(_Locinfo*, int, const char*);

     _Locinfo(const char* _Pch = "C")

        : _Lock(0 )
#line 233 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xlocinfo"
    {
        if (_Pch) {
            _Locinfo_ctor(this, _Pch);
            return;
        }

        _Xruntime_error("bad locale name");
    }

     _Locinfo(int _Cat, const char* _Pch)

        : _Lock(0 )
#line 246 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xlocinfo"
    {
        if (_Pch) {
            _Locinfo_ctor(this, _Cat, _Pch);
            return;
        }

        _Xruntime_error("bad locale name");
    }

     ~_Locinfo() noexcept {
        _Locinfo_dtor(this);
    }

    _Locinfo&  _Addcats(int _Cat, const char* _Pch) { 
        if (_Pch) {
            return _Locinfo_Addcats(this, _Cat, _Pch);
        }

        _Xruntime_error("bad locale name");
    }

    const char*  _Getname() const {
        return _Newlocname._C_str();
    }

    _Collvec  _Getcoll() const {
        return ::_Getcoll();
    }

    _Ctypevec  _Getctype() const {
        return ::_Getctype();
    }

    _Cvtvec  _Getcvt() const {
        return ::_Getcvt();
    }

    const lconv*  _Getlconv() const {
        return localeconv();
    }

    _Timevec  _Gettnames() const {
        return _Timevec(::_Gettnames());
    }

    const char*  _Getdays() const {
        const char* _Ptr = ::_Getdays();
        if (_Ptr) { 
            const_cast<_Locinfo*>(this)->_Days = _Ptr;
            :: free(const_cast<char*>(_Ptr));
        }

        return !_Days._Empty() ? _Days._C_str()
                               : ":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday"
                                 ":Thu:Thursday:Fri:Friday:Sat:Saturday";
    }

    const char*  _Getmonths() const {
        const char* _Ptr = ::_Getmonths();
        if (_Ptr) { 
            const_cast<_Locinfo*>(this)->_Months = _Ptr;
            :: free(const_cast<char*>(_Ptr));
        }

        return !_Months._Empty() ? _Months._C_str()
                                 : ":Jan:January:Feb:February:Mar:March"
                                   ":Apr:April:May:May:Jun:June"
                                   ":Jul:July:Aug:August:Sep:September"
                                   ":Oct:October:Nov:November:Dec:December";
    }

    const char*  _Getfalse() const {
        return "false";
    }

    const char*  _Gettrue() const {
        return "true";
    }

    int  _Getdateorder() const {
        return ::_Getdateorder();
    }

    _Timevec  _W_Gettnames() const {
        return _Timevec(::_W_Gettnames());
    }

    const unsigned short*  _W_Getdays() const {
        const wchar_t* _Ptr = ::_W_Getdays();
        if (_Ptr) { 
            const_cast<_Locinfo*>(this)->_W_Days = _Ptr;
            :: free(const_cast<wchar_t*>(_Ptr));
        }

        const wchar_t* _Ret;

        if (_W_Days._Empty()) {
            _Ret = L":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday:Thu:Thursday:Fri:Friday:Sat:Saturday";
        } else {
            _Ret = _W_Days._C_str();
        }

        return reinterpret_cast<const unsigned short*>(_Ret);
    }

    const unsigned short*  _W_Getmonths() const {
        const wchar_t* _Ptr = ::_W_Getmonths();
        if (_Ptr) { 
            const_cast<_Locinfo*>(this)->_W_Months = _Ptr;
            :: free(const_cast<wchar_t*>(_Ptr));
        }

        const wchar_t* _Ret;

        if (_W_Months._Empty()) {
            _Ret = L":Jan:January:Feb:February:Mar:March:Apr:April:May:May:Jun:June"
                   L":Jul:July:Aug:August:Sep:September:Oct:October:Nov:November:Dec:December";
        } else {
            _Ret = _W_Months._C_str();
        }

        return reinterpret_cast<const unsigned short*>(_Ret);
    }

    _Locinfo(const _Locinfo&)            = delete;
    _Locinfo& operator=(const _Locinfo&) = delete;

private:



    _Lockit _Lock; 
#line 379 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xlocinfo"

    _Yarn<char> _Days; 
    _Yarn<char> _Months; 
    _Yarn<wchar_t> _W_Days; 
    _Yarn<wchar_t> _W_Months; 
    _Yarn<char> _Oldlocname; 
    _Yarn<char> _Newlocname; 
};

template <class _Elem>
int __cdecl _LStrcoll(const _Elem* _First1, const _Elem* _Last1, const _Elem* _First2, const _Elem* _Last2,
    const _Locinfo::_Collvec*) { 
    for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2) {
        if (*_First1 < *_First2) {
            return -1; 
        } else if (*_First2 < *_First1) {
            return +1; 
        }
    }

    return _First2 != _Last2 ? -1 : _First1 != _Last1 ? +1 : 0;
}

template <>
inline int __cdecl _LStrcoll(const char* _First1, const char* _Last1, const char* _First2, const char* _Last2,
    const _Locinfo::_Collvec* _Vector) { 
    return _Strcoll(_First1, _Last1, _First2, _Last2, _Vector);
}

template <>
inline int __cdecl _LStrcoll(const wchar_t* _First1, const wchar_t* _Last1, const wchar_t* _First2,
    const wchar_t* _Last2,
    const _Locinfo::_Collvec* _Vector) { 
    return _Wcscoll(_First1, _Last1, _First2, _Last2, _Vector);
}

template <class _Elem>
size_t __cdecl _LStrxfrm(_Elem* _First1, _Elem* _Last1, const _Elem* _First2, const _Elem* _Last2,
    const _Locinfo::_Collvec*) { 
    const ptrdiff_t _Count = _Last2 - _First2;
    if (_Count <= _Last1 - _First1) {
        :: memcpy(_First1, _First2, _Count * sizeof(_Elem));
    }

    return _Count;
}

template <>
inline size_t __cdecl _LStrxfrm(  char* _First1,
     char* _Last1, const char* _First2, const char* _Last2,
    const _Locinfo::_Collvec* _Vector) { 
    return _Strxfrm(_First1, _Last1, _First2, _Last2, _Vector);
}

template <>
inline size_t __cdecl _LStrxfrm(  wchar_t* _First1,
     wchar_t* _Last1, const wchar_t* _First2, const wchar_t* _Last2,
    const _Locinfo::_Collvec* _Vector) { 
    return _Wcsxfrm(_First1, _Last1, _First2, _Last2, _Vector);
}
}


#pragma warning(pop)
#pragma pack(pop)
#line 445 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xlocinfo"
#line 446 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xlocinfo"
#pragma external_header(pop)
#line 17 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xlocale"

#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




namespace std {
template <class _Dummy>
class _Locbase { 
public:
     static const int collate  = ((1 << (1)) >> 1) ;
     static const int ctype    = ((1 << (2)) >> 1) ;
     static const int monetary = ((1 << (3)) >> 1) ;
     static const int numeric  = ((1 << (4)) >> 1) ;
     static const int time     = ((1 << (5)) >> 1) ;
     static const int messages = ((1 << (6)) >> 1) ;
     static const int all      = (((1 << ((6 + 1))) >> 1) - 1) ;
     static const int none     = 0;
};

template <class _Dummy>
const int _Locbase<_Dummy>::collate;
template <class _Dummy>
const int _Locbase<_Dummy>::ctype;
template <class _Dummy>
const int _Locbase<_Dummy>::monetary;
template <class _Dummy>
const int _Locbase<_Dummy>::numeric;
template <class _Dummy>
const int _Locbase<_Dummy>::time;
template <class _Dummy>
const int _Locbase<_Dummy>::messages;
template <class _Dummy>
const int _Locbase<_Dummy>::all;
template <class _Dummy>
const int _Locbase<_Dummy>::none;

 template <class _Elem>
class collate;

extern "C++" struct __declspec(dllimport) _Crt_new_delete { 




























};

 extern "C++" class locale : public _Locbase<int>, public _Crt_new_delete {
public:
    using category = int;

    class __declspec(dllimport) id { 
    public:
         id(size_t _Val = 0) : _Id(_Val) {}

        id(const id&)            = delete;
        id& operator=(const id&) = delete;

         operator size_t() { 
            if (_Id == 0) { 
                { ::std:: _Lockit _Lock(0);
                if (_Id == 0) {
                    _Id = static_cast<size_t>(++_Id_cnt);
                }
                }
            }
            return _Id;
        }

    private:
        size_t _Id; 

         static int _Id_cnt;
    };

    class _Locimp;

    class __declspec(dllimport) facet : public _Facet_base, public _Crt_new_delete {
        
    private:
        friend struct _Facet_guard;

    public:
        static size_t __cdecl _Getcat(const facet** = nullptr, const locale* = nullptr) {
            
            return static_cast<size_t>(-1);
        }

        void  _Incref() noexcept override { 
            _InterlockedIncrement(reinterpret_cast<volatile long*>(&_Myrefs)) ;
        }

        _Facet_base*  _Decref() noexcept override { 
            if (_InterlockedDecrement(reinterpret_cast<volatile long*>(&_Myrefs)) == 0) {
                return this;
            }

            return nullptr;
        }

    private:
        _Atomic_counter_t _Myrefs; 

    protected:
        explicit  facet(size_t _Initrefs = 0)
            : _Myrefs(static_cast<_Atomic_counter_t>(_Initrefs)) 
        {}

         ~facet() noexcept override {}

    public:
         facet(const facet&)            = delete;
        facet&  operator=(const facet&) = delete;
    };

    struct [[nodiscard]] _Facet_guard {
        facet* _Target;
        ~_Facet_guard() {
            if (_Target) {
                delete _Target->_Decref();
            }
        }
    };

    class __declspec(dllimport) _Locimp : public facet { 
    protected:
         ~_Locimp() noexcept {
            _Locimp_dtor(this);
        }

    private:
        static _Locimp* __cdecl _New_Locimp(bool _Transparent = false);
        static _Locimp* __cdecl _New_Locimp(const _Locimp& _Right);

        static void __cdecl _Locimp_dtor(_Locimp*);
        static void __cdecl _Locimp_Addfac(_Locimp*, facet*, size_t); 
        static void __cdecl _Locimp_ctor(_Locimp*, const _Locimp&);

        friend locale;

         _Locimp(bool _Transparent)
            : locale::facet(1), _Facetvec(nullptr), _Facetcount(0), _Catmask(none), _Xparent(_Transparent), _Name("*") {
        }

         _Locimp(const _Locimp& _Right)
            : locale::facet(1), _Facetvec(nullptr), _Facetcount(_Right._Facetcount), _Catmask(_Right._Catmask),
              _Xparent(_Right._Xparent), _Name(_Right._Name.c_str()) {
            _Locimp_ctor(this, _Right);
        }

        void  _Addfac(facet* _Pfacet, size_t _Id) { 
            _Locimp_Addfac(this, _Pfacet, _Id);
        }

        static _Locimp* __cdecl _Makeloc(
            const _Locinfo&, category, _Locimp*, const locale*); 

        static void __cdecl _Makewloc(
            const _Locinfo&, category, _Locimp*, const locale*); 


        static void __cdecl _Makeushloc(
            const _Locinfo&, category, _Locimp*, const locale*); 
#line 207 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xlocale"

        static void __cdecl _Makexloc(
            const _Locinfo&, category, _Locimp*, const locale*); 

        facet** _Facetvec; 
        size_t _Facetcount; 
        category _Catmask; 
        bool _Xparent; 
        _Yarn<char> _Name; 

         static _Locimp* _Clocptr;

    public:
        _Locimp&  operator=(const _Locimp&) = delete;
    };

    template <class _Elem, class _Traits, class _Alloc>
    bool operator()(
        const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) const {
        
        const auto& _Coll_fac = ::std:: use_facet<::std:: collate<_Elem>>(*this);

        const _Elem* const _Left_data  = _Left.data();
        const _Elem* const _Right_data = _Right.data();
        return _Coll_fac.compare(_Left_data, _Left_data + _Left.size(), _Right_data, _Right_data + _Right.size()) < 0;
    }

    template <class _Facet>
    locale combine(const locale& _Loc) const { 
        _Facet* _Facptr;

        try {
        _Facptr = const_cast<_Facet*>(::std:: addressof(::std:: use_facet<_Facet>(_Loc)));
        } catch (...) {
        _Xruntime_error("locale::combine facet missing");
        }

        _Locimp* _Newimp = _Locimp::_New_Locimp(*_Ptr);
        _Newimp->_Addfac(_Facptr, _Facet::id);
        _Newimp->_Catmask = none;
        _Newimp->_Name    = "*";
        return locale{_Newimp};
    }

    template <class _Facet>
    locale(const locale& _Loc, const _Facet* _Facptr) : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr)) {
        if (_Facptr) { 
            _Ptr->_Addfac(const_cast<_Facet*>(_Facptr), _Facet::id);
            _Ptr->_Catmask = none;
            _Ptr->_Name    = "*";
        }
    }

    locale(_Uninitialized) {} 

    locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) {
        _Ptr->_Incref();
    }

    locale() noexcept : _Ptr(_Init(true)) {}


    locale(const locale& _Loc, const locale& _Other, category _Cat) : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr)) {
        
        if (_Cat != none) { 
            _Facet_guard _Guard{_Ptr};
            { _Locinfo _Lobj;
            _Locimp::_Makeloc(_Lobj, _Cat, _Ptr, &_Other);
            _Lobj._Addcats(_Loc._Ptr->_Catmask, _Loc.name().c_str());
            _Lobj._Addcats(_Other._Ptr->_Catmask, _Other.name().c_str());
            _Ptr->_Catmask = _Loc._Ptr->_Catmask | _Other._Ptr->_Catmask;
            _Ptr->_Name    = _Lobj._Getname();
            }
            _Guard._Target = nullptr;
        }
    }

private:
    void _Construct(const string& _Str, category _Cat) {
        
        bool _Bad = false;
        _Init();
        if (_Cat != none) { 
            _Facet_guard _Guard{_Ptr};
            { _Locinfo _Lobj(_Cat, _Str.c_str());
            if (_Badname(_Lobj)) {
                _Bad = true;
            } else { 
                _Locimp::_Makeloc(_Lobj, _Cat, _Ptr, nullptr);
                _Ptr->_Catmask = _Cat;
                _Ptr->_Name    = _Str.c_str();
            }
            }
            _Guard._Target = nullptr;
        }

        if (_Bad) { 
            delete _Ptr->_Decref();
            _Xruntime_error("bad locale name");
        }
    }

public:
    explicit locale(const char* _Locname, category _Cat = all) : _Ptr(_Locimp::_New_Locimp()) {
        
        
        
        if (_Locname) {
            _Construct(_Locname, _Cat);
            return;
        }

        _Xruntime_error("bad locale name");
    }

    locale(const locale& _Loc, const char* _Locname, category _Cat) : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr)) {
        
        
        
        if (_Locname) {
            _Construct(_Locname, _Cat);
            return;
        }

        _Xruntime_error("bad locale name");
    }

    explicit locale(const string& _Str, category _Cat = all) : _Ptr(_Locimp::_New_Locimp()) {
        
        _Construct(_Str, _Cat);
    }

    locale(const locale& _Loc, const string& _Str, category _Cat) : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr)) {
        
        _Construct(_Str, _Cat);
    }
#line 344 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xlocale"

    ~locale() noexcept {
        if (_Ptr) {
            delete _Ptr->_Decref();
        }
    }

    const locale& operator=(const locale& _Right) noexcept {
        if (_Ptr != _Right._Ptr) { 
            delete _Ptr->_Decref();
            _Ptr = _Right._Ptr;
            _Ptr->_Incref();
        }
        return *this;
    }

    string name() const {
        return _Ptr ? _Ptr->_Name.c_str() : string{};
    }

     const char* _C_str() const noexcept {
        return _Ptr ? _Ptr->_Name.c_str() : "";
    }

    const facet* _Getfacet(size_t _Id) const { 
        const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; 
        if (_Facptr || !_Ptr->_Xparent) {
            return _Facptr; 
        }

        
        locale::_Locimp* _Ptr0 = _Getgloballocale();
        if (_Id < _Ptr0->_Facetcount) {
            return _Ptr0->_Facetvec[_Id]; 
        }

        return nullptr; 
    }

    [[nodiscard]] bool operator==(const locale& _Loc) const noexcept   { 
        return _Ptr == _Loc._Ptr || (:: strcmp(_C_str(), "*") != 0 && :: strcmp(_C_str(), _Loc._C_str()) == 0);
    }





#line 392 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xlocale"

    static  const locale& __cdecl classic(); 

    static  locale __cdecl global(const locale&); 

    static  locale __cdecl empty(); 

private:
    locale(_Locimp* _Ptrimp) : _Ptr(_Ptrimp) {}

    static  _Locimp* __cdecl _Init(bool _Do_incref = false); 
    static  _Locimp* __cdecl _Getgloballocale();
    static  void __cdecl _Setgloballocale(void*);

    bool _Badname(const _Locinfo& _Lobj) { 
        return :: strcmp(_Lobj._Getname(), "*") == 0;
    }

    _Locimp* _Ptr; 
};

template <class _Facet>
struct _Facetptr { 
     static const locale::facet* _Psave;
};

template <class _Facet>
 const locale::facet* _Facetptr<_Facet>::_Psave = nullptr;

 template <class _Facet>
const _Facet& __cdecl use_facet(const locale& _Loc) { 
    { ::std:: _Lockit _Lock(0); 
    const locale::facet* _Psave = _Facetptr<_Facet>::_Psave; 

    const size_t _Id         = _Facet::id;
    const locale::facet* _Pf = _Loc._Getfacet(_Id);

    if (!_Pf) {
        if (_Psave) {
            _Pf = _Psave; 
        } else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1)) {

            _Throw_bad_cast(); 


#line 438 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xlocale"
        } else { 
            auto _Pfmod = const_cast<locale::facet*>(_Psave);
            unique_ptr<_Facet_base> _Psave_guard(static_cast<_Facet_base*>(_Pfmod));



#line 445 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xlocale"
            _Facet_Register(_Pfmod);
#line 447 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xlocale"

            _Pfmod->_Incref();
            _Facetptr<_Facet>::_Psave = _Psave;
            _Pf                       = _Psave;

            (void) _Psave_guard.release();
        }
    }

    return static_cast<const _Facet&>(*_Pf); 
    }
} 

template <class _Elem>
char __cdecl _Maklocbyte(_Elem _Char, const _Locinfo::_Cvtvec&) {
    
    return static_cast<char>(static_cast<unsigned char>(_Char));
}

template <>
inline char __cdecl _Maklocbyte(wchar_t _Char, const _Locinfo::_Cvtvec& _Cvt) {
    
    char _Byte       = '\0';
    mbstate_t _Mbst1 = {};
    _Wcrtomb(&_Byte, _Char, &_Mbst1, &_Cvt);
    return _Byte;
}


template <>
inline char __cdecl _Maklocbyte(unsigned short _Char, const _Locinfo::_Cvtvec& _Cvt) {
    
    char _Byte       = '\0';
    mbstate_t _Mbst1 = {};
    _Wcrtomb(&_Byte, static_cast<wchar_t>(_Char), &_Mbst1, &_Cvt);
    return _Byte;
}
#line 485 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xlocale"

template <class _Elem>
_Elem __cdecl _Maklocchr(char _Byte, _Elem*, const _Locinfo::_Cvtvec&) {
    
    return static_cast<_Elem>(static_cast<unsigned char>(_Byte));
}

template <>
inline wchar_t __cdecl _Maklocchr(char _Byte, wchar_t*, const _Locinfo::_Cvtvec& _Cvt) {
    
    wchar_t _Wc      = L'\0';
    mbstate_t _Mbst1 = {};
    _Mbrtowc(&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);
    return _Wc;
}


template <>
inline unsigned short __cdecl _Maklocchr(char _Byte, unsigned short*, const _Locinfo::_Cvtvec& _Cvt) {
    
    unsigned short _Wc = 0;
    mbstate_t _Mbst1   = {};
    _Mbrtowc(reinterpret_cast<wchar_t*>(&_Wc), &_Byte, 1, &_Mbst1, &_Cvt);
    return _Wc;
}
#line 511 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xlocale"

template <class _Elem>
_Elem* __cdecl _Maklocstr(const char* _Ptr, _Elem*, const _Locinfo::_Cvtvec&) {
    
    size_t _Count = :: strlen(_Ptr) + 1;

    _Elem* _Ptrdest = static_cast<_Elem*>(calloc(_Count, sizeof(_Elem)) );

    if (!_Ptrdest) {
        _Xbad_alloc();
    }

    for (_Elem* _Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr) {
        *_Ptrnext = static_cast<_Elem>(static_cast<unsigned char>(*_Ptr));
    }

    return _Ptrdest;
}

template <>
inline wchar_t* __cdecl _Maklocstr(const char* _Ptr, wchar_t*, const _Locinfo::_Cvtvec& _Cvt) {
    
    size_t _Count;
    size_t _Count1;
    size_t _Wchars;
    const char* _Ptr1;
    int _Bytes;
    wchar_t _Wc;
    mbstate_t _Mbst1 = {};

    _Count1 = :: strlen(_Ptr) + 1;
    for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count; _Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars) {
        if ((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0) {
            break;
        }
    }

    ++_Wchars; 

    wchar_t* _Ptrdest = static_cast<wchar_t*>(calloc(_Wchars, sizeof(wchar_t)) );

    if (!_Ptrdest) {
        _Xbad_alloc();
    }

    wchar_t* _Ptrnext = _Ptrdest;
    mbstate_t _Mbst2  = {};

    for (; 0 < _Wchars; _Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext) {
        if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0) {
            break;
        }
    }

    *_Ptrnext = L'\0';

    return _Ptrdest;
}


template <>
inline unsigned short* __cdecl _Maklocstr(const char* _Ptr, unsigned short*, const _Locinfo::_Cvtvec& _Cvt) {
    
    size_t _Count;
    size_t _Count1;
    size_t _Wchars;
    const char* _Ptr1;
    int _Bytes;
    unsigned short _Wc;
    mbstate_t _Mbst1 = {};

    _Count1 = :: strlen(_Ptr) + 1;
    for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count; _Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars) {
        if ((_Bytes = _Mbrtowc(reinterpret_cast<wchar_t*>(&_Wc), _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0) {
            break;
        }
    }

    ++_Wchars; 

    wchar_t* _Ptrdest = static_cast<wchar_t*>(calloc(_Wchars, sizeof(wchar_t)) );

    if (!_Ptrdest) {
        _Xbad_alloc();
    }

    wchar_t* _Ptrnext = _Ptrdest;
    mbstate_t _Mbst2  = {};
    for (; 0 < _Wchars; _Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext) {
        if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0) {
            break;
        }
    }

    *_Ptrnext = L'\0';
    return reinterpret_cast<unsigned short*>(_Ptrdest);
}
#line 609 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xlocale"

 extern "C++" class __declspec(dllimport) codecvt_base : public locale::facet { 
public:
    enum { 
        ok,
        partial,
        error,
        noconv
    };
    using result = int;

     codecvt_base(size_t _Refs = 0) : locale::facet(_Refs) {}

    bool  always_noconv() const noexcept {
        
        return do_always_noconv();
    }

    int  max_length() const noexcept {
        
        return do_max_length();
    }

    int  encoding() const noexcept {
        return do_encoding();
    }

     ~codecvt_base() noexcept {}

protected:
    virtual bool  do_always_noconv() const noexcept {
        
        return false;
    }

    virtual int  do_max_length() const noexcept {
        
        return 1;
    }

    virtual int  do_encoding() const noexcept {
        return 1; 
    }
};

template <class _Ty>
inline constexpr bool _Is_one_byte_char_like_v = _Is_any_of_v<remove_cv_t<_Ty>, signed char, unsigned char,

    byte,
#line 659 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xlocale"

    char8_t,
#line 662 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xlocale"
    char>;

template <class _Elem, class _Byte>
inline constexpr bool _Is_codecvt_do_always_noconv_v =
    is_same_v<_Byte, _Elem> || (_Is_one_byte_char_like_v<_Byte> && _Is_one_byte_char_like_v<_Elem>);

 extern "C++" template <class _Elem, class _Byte, class _Statype>
class codecvt : public codecvt_base { 
public:
    
    
    
    
    
    
    

    static_assert(!0 || is_same_v<codecvt, codecvt<char, char, mbstate_t>>,
        "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. " "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 " "to suppress this error." );

    using intern_type = _Elem;
    using extern_type = _Byte;
    using state_type  = _Statype;

    result  in(_Statype& _State, const _Byte* _First1, const _Byte* _Last1, const _Byte*& _Mid1,
        _Elem* _First2, _Elem* _Last2, _Elem*& _Mid2) const { 
        return do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result  out(_Statype& _State, const _Elem* _First1, const _Elem* _Last1, const _Elem*& _Mid1,
        _Byte* _First2, _Byte* _Last2, _Byte*& _Mid2) const { 
        return do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result  unshift(_Statype& _State, _Byte* _First2, _Byte* _Last2, _Byte*& _Mid2) const {
        
        return do_unshift(_State, _First2, _Last2, _Mid2);
    }

    int  length(_Statype& _State, const _Byte* _First1, const _Byte* _Last1, size_t _Count) const {
        
        
        return do_length(_State, _First1, _Last1, _Count);
    }

     static locale::id id; 

    explicit  codecvt(size_t _Refs = 0) : codecvt_base(_Refs) {
        _Init(_Locinfo());
    }

    explicit  codecvt(const _Locinfo& _Lobj, size_t _Refs = 0) : codecvt_base(_Refs) {
        _Init(_Lobj);
    }

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        
        if (_Ppf && !*_Ppf) {
            *_Ppf = new codecvt(_Locinfo(_Ploc->_C_str()));
        }

        return 2 ;
    }

protected:
     ~codecvt() noexcept override {}

    void  _Init(const _Locinfo&) {} 

    bool  do_always_noconv() const noexcept override {
        
        return _Is_codecvt_do_always_noconv_v<_Elem, _Byte>;
    }

    virtual result  do_in(_Statype&, const _Byte* _First1, const _Byte* _Last1, const _Byte*& _Mid1,
        _Elem* _First2, _Elem* _Last2, _Elem*& _Mid2) const { 
        _Mid1 = _First1;
        _Mid2 = _First2;
        if constexpr (_Is_codecvt_do_always_noconv_v<_Elem, _Byte>) {
            return noconv; 
        } else {
            
            for (; _Mid1 != _Last1; ++_Mid1, ++_Mid2) {
                if (_Mid2 == _Last2) {
                    return partial;
                }
                *_Mid2 = static_cast<_Elem>(*_Mid1);
            }

            return ok;
        }
    }

    virtual result  do_out(_Statype&, const _Elem* _First1, const _Elem* _Last1, const _Elem*& _Mid1,
        _Byte* _First2, _Byte* _Last2, _Byte*& _Mid2) const { 
        _Mid1 = _First1;
        _Mid2 = _First2;
        if constexpr (_Is_codecvt_do_always_noconv_v<_Elem, _Byte>) {
            return noconv; 
        } else {
            
            for (; _Mid1 != _Last1; ++_Mid1, ++_Mid2) {
                if (_Mid2 == _Last2) {
                    return partial;
                }
                *_Mid2 = static_cast<_Byte>(*_Mid1);
            }

            return ok;
        }
    }

    virtual result  do_unshift(_Statype&, _Byte* _First2, _Byte*, _Byte*& _Mid2) const {
        
        _Mid2 = _First2;
        return noconv; 
    }

    virtual int  do_length(
        _Statype&, const _Byte* _First1, const _Byte* _Last1, size_t _Count) const {
        
        
        
        const auto _Dist = static_cast<size_t>((::std:: min)(_Last1 - _First1, ptrdiff_t{2147483647 }));
        return static_cast<int>((::std:: min)(_Count, _Dist));
    }
};






template <class _Elem, class _Byte, class _Statype>
 locale::id codecvt<_Elem, _Byte, _Statype>::id;





   template <class _CvtTy, class _Byte, class _Statype>
[[nodiscard]] int _Codecvt_do_length(
    const _CvtTy& _Cvt, _Statype& _State, const _Byte* _First1, const _Byte* _Last1, size_t _Count) {
    
    

    __pragma(warning(push)) __pragma(warning(disable : 4996))
    using _Elem = typename _CvtTy::intern_type;
    __pragma(warning(pop))

    _Adl_verify_range(_First1, _Last1);
    const auto _Old_first1 = _First1;

    while (_Count > 0 && _First1 != _Last1) { 
        const _Byte* _Mid1;
        _Elem* _Mid2;
        _Elem _Ch;

        

        __pragma(warning(push)) __pragma(warning(disable : 4996))
        const auto _Result = _Cvt._CvtTy::do_in(_State, _First1, _Last1, _Mid1, &_Ch, &_Ch + 1, _Mid2);
        __pragma(warning(pop))

        if (_Result != codecvt_base::ok) {
            if (_Result == codecvt_base::noconv) {
                _First1 += (::std:: min)(static_cast<size_t>(_Last1 - _First1), _Count);
            }

            break; 
        }

        if (_Mid2 == &_Ch + 1) {
            --_Count; 
        }

        _First1 = _Mid1;
    }

    return static_cast<int>((::std:: min)(_First1 - _Old_first1, ptrdiff_t{2147483647 }));
}

enum _Codecvt_mode { _Consume_header = 4, _Generate_header = 2 };

extern "C++" template <>
class __declspec(dllimport) [[deprecated("warning STL4020: " "std::codecvt<char16_t, char, mbstate_t>, std::codecvt<char32_t, char, mbstate_t>, " "std::codecvt_byname<char16_t, char, mbstate_t>, and std::codecvt_byname<char32_t, char, mbstate_t> " "are deprecated in C++20 and replaced by specializations with a second argument of type char8_t. " "You can define _SILENCE_CXX20_CODECVT_FACETS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]]
    codecvt<char16_t, char, mbstate_t> : public codecvt_base {
    
public:
    using intern_type = char16_t;
    using extern_type = char;
    using state_type  = mbstate_t;

    result  in(mbstate_t& _State, const char* _First1, const char* _Last1, const char*& _Mid1,
        char16_t* _First2, char16_t* _Last2, char16_t*& _Mid2) const {
        
        return do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result  out(mbstate_t& _State, const char16_t* _First1, const char16_t* _Last1,
        const char16_t*& _Mid1, char* _First2, char* _Last2, char*& _Mid2) const {
        
        return do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result  unshift(mbstate_t& _State, char* _First2, char* _Last2, char*& _Mid2) const {
        
        return do_unshift(_State, _First2, _Last2, _Mid2);
    }

    int  length(mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const {
        
        
        return do_length(_State, _First1, _Last1, _Count);
    }

     static locale::id id;

    explicit  codecvt(size_t _Refs = 0)
        : codecvt_base(_Refs), _Maxcode(0x10ffff), _Mode(_Consume_header) {
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }

    explicit  codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
        : codecvt_base(_Refs), _Maxcode(0x10ffff), _Mode(_Consume_header) {
        _Init(_Lobj);
    }

     codecvt(
        const _Locinfo& _Lobj, unsigned long _Maxcode_arg, _Codecvt_mode _Mode_arg, size_t _Refs = 0)
        : codecvt_base(_Refs), _Maxcode(_Maxcode_arg), _Mode(_Mode_arg) {
        _Init(_Lobj);
    }

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        
        if (_Ppf && !*_Ppf) {
            __pragma(warning(push)) __pragma(warning(disable : 4996))
            *_Ppf = new codecvt(_Locinfo(_Ploc->_C_str()));
            __pragma(warning(pop))
        }

        return 2 ;
    }

protected:
     ~codecvt() noexcept override {}

    void  _Init(const _Locinfo&) {} 

    virtual result  do_in(mbstate_t& _State, const char* _First1, const char* _Last1,
        const char*& _Mid1, char16_t* _First2, char16_t* _Last2, char16_t*& _Mid2) const {
        
        unsigned short* _Pstate = reinterpret_cast<unsigned short*>(&_State);
        _Mid1                   = _First1;
        _Mid2                   = _First2;

        while (_Mid1 != _Last1 && _Mid2 != _Last2) { 
            unsigned char _By = static_cast<unsigned char>(*_Mid1);
            unsigned long _Ch;
            int _Nextra;
            int _Nskip;

            if (*_Pstate > 1) {
                if (_By < 0x80 || 0xc0 <= _By) {
                    return codecvt::error; 
                }

                
                ++_Mid1;
                *_Mid2++ = static_cast<char16_t>(*_Pstate | (_By & 0x3f));
                *_Pstate = 1;
                continue;
            }

            if (_By < 0x80u) {
                _Ch     = _By;
                _Nextra = 0;
            } else if (_By < 0xc0u) { 
                ++_Mid1;
                return codecvt::error;
            } else if (_By < 0xe0u) {
                _Ch     = static_cast<unsigned long>(_By & 0x1f);
                _Nextra = 1;
            } else if (_By < 0xf0u) {
                _Ch     = static_cast<unsigned long>(_By & 0x0f);
                _Nextra = 2;
            } else if (_By < 0xf8u) {
                _Ch     = static_cast<unsigned long>(_By & 0x07);
                _Nextra = 3;
            } else {
                _Ch     = static_cast<unsigned long>(_By & 0x03);
                _Nextra = _By < 0xfc ? 4 : 5;
            }

            _Nskip  = _Nextra < 3 ? 0 : 1; 
            _First1 = _Mid1; 

            if (_Nextra == 0) {
                ++_Mid1;
            } else if (_Last1 - _Mid1 < _Nextra + 1 - _Nskip) {
                break; 
            } else {
                for (++_Mid1; _Nskip < _Nextra; --_Nextra, ++_Mid1) {
                    if ((_By = static_cast<unsigned char>(*_Mid1)) < 0x80u || 0xc0u <= _By) {
                        return codecvt::error; 
                    } else {
                        _Ch = _Ch << 6 | (_By & 0x3f);
                    }
                }
            }

            if (0 < _Nskip) {
                _Ch <<= 6; 
            }

            if ((_Maxcode < 0x10ffffu ? _Maxcode : 0x10ffffu) < _Ch) {
                return codecvt::error; 
            }

            if (0xffffu < _Ch) { 
                unsigned short _Ch0 = static_cast<unsigned short>(0xd800 | (_Ch >> 10) - 0x0040);

                *_Mid2++ = static_cast<char16_t>(_Ch0);
                *_Pstate = static_cast<unsigned short>(0xdc00 | (_Ch & 0x03ff));
                continue;
            }

            if (_Nskip != 0) {
                if (_Mid1 == _Last1) { 
                    _Mid1 = _First1;
                    break;
                }

                if ((_By = static_cast<unsigned char>(*_Mid1++)) < 0x80u || 0xc0u <= _By) {
                    return codecvt::error; 
                }

                _Ch |= _By & 0x3f; 
            }

            if (*_Pstate == 0u) { 
                *_Pstate = 1;

                if ((_Mode & _Consume_header) != 0 && _Ch == 0xfeffu) { 
                    const result _Ans = do_in(_State, _Mid1, _Last1, _Mid1, _First2, _Last2, _Mid2);

                    if (_Ans == codecvt::partial) { 
                        *_Pstate = 0;
                        _Mid1    = _First1;
                    }

                    return _Ans;
                }
            }

            *_Mid2++ = static_cast<char16_t>(_Ch);
        }

        return _First1 == _Mid1 ? codecvt::partial : codecvt::ok;
    }

    virtual result  do_out(mbstate_t& _State, const char16_t* _First1, const char16_t* _Last1,
        const char16_t*& _Mid1, char* _First2, char* _Last2, char*& _Mid2) const {
        
        unsigned short* _Pstate = reinterpret_cast<unsigned short*>(&_State);
        _Mid1                   = _First1;
        _Mid2                   = _First2;

        while (_Mid1 != _Last1 && _Mid2 != _Last2) { 
            unsigned long _Ch;
            const unsigned short _Ch1 = static_cast<unsigned short>(*_Mid1);
            bool _Save                = false;

            if (1 < *_Pstate) { 
                if (_Ch1 < 0xdc00u || 0xe000u <= _Ch1) {
                    return codecvt::error; 
                }

                _Ch = static_cast<unsigned long>((*_Pstate << 10) | (_Ch1 - 0xdc00));
            } else if (0xd800u <= _Ch1 && _Ch1 < 0xdc00u) { 
                _Ch   = static_cast<unsigned long>((_Ch1 - 0xd800 + 0x0040) << 10);
                _Save = true; 
            } else {
                _Ch = _Ch1; 
            }

            char _By;
            int _Nextra;

            if (_Ch < 0x0080u) {
                _By     = static_cast<char>(_Ch);
                _Nextra = 0;
            } else if (_Ch < 0x0800u) {
                _By     = static_cast<char>(0xc0 | _Ch >> 6);
                _Nextra = 1;
            } else if (_Ch < 0x10000u) {
                _By     = static_cast<char>(0xe0 | _Ch >> 12);
                _Nextra = 2;
            } else {
                _By     = static_cast<char>(0xf0 | _Ch >> 18);
                _Nextra = 3;
            }

            int _Nput = _Nextra < 3 ? _Nextra + 1 : _Save ? 1 : 3;

            if (_Last2 - _Mid2 < _Nput) {
                break; 
            }

            if (*_Pstate == 0u && (_Mode & _Generate_header) != 0) {
                if (_Last2 - _Mid2 < 3 + _Nput) {
                    break; 
                }

                
                *_Mid2++ = '\xef';
                *_Mid2++ = '\xbb';
                *_Mid2++ = '\xbf';
            }

            ++_Mid1;
            if (_Save || _Nextra < 3) { 
                *_Mid2++ = _By;
                --_Nput;
            }

            for (; 0 < _Nput; --_Nput) {
                *_Mid2++ = static_cast<char>((_Ch >> 6 * --_Nextra & 0x3f) | 0x80);
            }

            *_Pstate = static_cast<unsigned short>(_Save ? _Ch >> 10 : 1);
        }

        return _First1 == _Mid1 ? codecvt::partial : codecvt::ok;
    }

    virtual result  do_unshift(mbstate_t& _State, char* _First2, char*, char*& _Mid2) const {
        
        unsigned short* _Pstate = reinterpret_cast<unsigned short*>(&_State);
        _Mid2                   = _First2;

        return 1u < *_Pstate ? codecvt::error : codecvt::ok; 
    }

    friend int _Codecvt_do_length<>(const codecvt&, mbstate_t&, const char*, const char*, size_t);

    virtual int  do_length(
        mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const {
        return _Codecvt_do_length(*this, _State, _First1, _Last1, _Count);
    }

    bool  do_always_noconv() const noexcept override {
        
        return false;
    }

    int  do_max_length() const noexcept override {
        

        if ((_Mode & _Consume_header) != 0) {
            return 9; 
        }

        if ((_Mode & _Generate_header) != 0) {
            return 7; 
        }

        return 6; 
    }

    int do_encoding() const noexcept override {
        return 0; 
    }

private:
    unsigned long _Maxcode; 
    _Codecvt_mode _Mode; 
};

extern "C++" template <>
class __declspec(dllimport) [[deprecated("warning STL4020: " "std::codecvt<char16_t, char, mbstate_t>, std::codecvt<char32_t, char, mbstate_t>, " "std::codecvt_byname<char16_t, char, mbstate_t>, and std::codecvt_byname<char32_t, char, mbstate_t> " "are deprecated in C++20 and replaced by specializations with a second argument of type char8_t. " "You can define _SILENCE_CXX20_CODECVT_FACETS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]]
    codecvt<char32_t, char, mbstate_t> : public codecvt_base {
    
public:
    using intern_type = char32_t;
    using extern_type = char;
    using state_type  = mbstate_t;

    result  in(mbstate_t& _State, const char* _First1, const char* _Last1, const char*& _Mid1,
        char32_t* _First2, char32_t* _Last2, char32_t*& _Mid2) const {
        
        return do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result  out(mbstate_t& _State, const char32_t* _First1, const char32_t* _Last1,
        const char32_t*& _Mid1, char* _First2, char* _Last2, char*& _Mid2) const {
        
        return do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result  unshift(mbstate_t& _State, char* _First2, char* _Last2, char*& _Mid2) const {
        
        return do_unshift(_State, _First2, _Last2, _Mid2);
    }

    int  length(mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const {
        
        
        return do_length(_State, _First1, _Last1, _Count);
    }

     static locale::id id;

    explicit  codecvt(size_t _Refs = 0)
        : codecvt_base(_Refs), _Maxcode(0xffffffff), _Mode(_Consume_header) {
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }

    explicit  codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
        : codecvt_base(_Refs), _Maxcode(0xffffffff), _Mode(_Consume_header) {
        _Init(_Lobj);
    }

     codecvt(
        const _Locinfo& _Lobj, unsigned long _Maxcode_arg, _Codecvt_mode _Mode_arg, size_t _Refs = 0)
        : codecvt_base(_Refs), _Maxcode(_Maxcode_arg), _Mode(_Mode_arg) {
        _Init(_Lobj);
    }

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        
        if (_Ppf && !*_Ppf) {
            __pragma(warning(push)) __pragma(warning(disable : 4996))
            *_Ppf = new codecvt(_Locinfo(_Ploc->_C_str()));
            __pragma(warning(pop))
        }

        return 2 ;
    }

protected:
     ~codecvt() noexcept override {}

    void  _Init(const _Locinfo&) {} 

    virtual result  do_in(mbstate_t& _State, const char* _First1, const char* _Last1,
        const char*& _Mid1, char32_t* _First2, char32_t* _Last2, char32_t*& _Mid2) const {
        
        char* _Pstate = reinterpret_cast<char*>(&_State);
        _Mid1         = _First1;
        _Mid2         = _First2;

        while (_Mid1 != _Last1 && _Mid2 != _Last2) { 
            unsigned char _By = static_cast<unsigned char>(*_Mid1);
            unsigned long _Ch;
            int _Nextra;

            if (_By < 0x80u) {
                _Ch     = _By;
                _Nextra = 0;
            } else if (_By < 0xc0u) { 
                ++_Mid1;
                return codecvt::error;
            } else if (_By < 0xe0u) {
                _Ch     = static_cast<unsigned long>(_By & 0x1f);
                _Nextra = 1;
            } else if (_By < 0xf0u) {
                _Ch     = static_cast<unsigned long>(_By & 0x0f);
                _Nextra = 2;
            } else if (_By < 0xf8u) {
                _Ch     = static_cast<unsigned long>(_By & 0x07);
                _Nextra = 3;
            } else {
                _Ch     = static_cast<unsigned long>(_By & 0x03);
                _Nextra = _By < 0xfc ? 4 : 5;
            }

            if (_Nextra == 0) {
                ++_Mid1;
            } else if (_Last1 - _Mid1 < _Nextra + 1) {
                break; 
            } else {
                for (++_Mid1; 0 < _Nextra; --_Nextra, ++_Mid1) {
                    if ((_By = static_cast<unsigned char>(*_Mid1)) < 0x80u || 0xc0u <= _By) {
                        return codecvt::error; 
                    } else {
                        _Ch = _Ch << 6 | (_By & 0x3f);
                    }
                }
            }

            if (*_Pstate == 0) { 
                *_Pstate = 1;

                if ((_Mode & _Consume_header) != 0 && _Ch == 0xfeffu) { 
                    const result _Ans = do_in(_State, _Mid1, _Last1, _Mid1, _First2, _Last2, _Mid2);

                    if (_Ans == codecvt::partial) { 
                        *_Pstate = 0;
                        _Mid1    = _First1;
                    }
                    return _Ans;
                }
            }

            if (_Maxcode < _Ch) {
                return codecvt::error; 
            }

            *_Mid2++ = static_cast<char32_t>(_Ch);
        }

        return _First1 == _Mid1 ? codecvt::partial : codecvt::ok;
    }

    virtual result  do_out(mbstate_t& _State, const char32_t* _First1, const char32_t* _Last1,
        const char32_t*& _Mid1, char* _First2, char* _Last2, char*& _Mid2) const {
        
        char* _Pstate = reinterpret_cast<char*>(&_State);
        _Mid1         = _First1;
        _Mid2         = _First2;

        while (_Mid1 != _Last1 && _Mid2 != _Last2) { 
            char _By;
            int _Nextra;
            unsigned long _Ch = static_cast<unsigned long>(*_Mid1);

            if (_Maxcode < _Ch) {
                return codecvt::error;
            }

            if (_Ch < 0x0080u) {
                _By     = static_cast<char>(_Ch);
                _Nextra = 0;
            } else if (_Ch < 0x0800u) {
                _By     = static_cast<char>(0xc0 | _Ch >> 6);
                _Nextra = 1;
            } else if (_Ch < 0x00010000u) {
                _By     = static_cast<char>(0xe0 | _Ch >> 12);
                _Nextra = 2;
            } else if (_Ch < 0x00200000u) {
                _By     = static_cast<char>(0xf0 | _Ch >> 18);
                _Nextra = 3;
            } else if (_Ch < 0x04000000u) {
                _By     = static_cast<char>(0xf8 | _Ch >> 24);
                _Nextra = 4;
            } else {
                _By     = static_cast<char>(0xfc | (_Ch >> 30 & 0x03));
                _Nextra = 5;
            }

            if (*_Pstate == 0) { 
                *_Pstate = 1;
                if ((_Mode & _Generate_header) != 0) {
                    if (_Last2 - _Mid2 < 3 + 1 + _Nextra) {
                        return codecvt::partial; 
                    }

                    
                    *_Mid2++ = '\xef';
                    *_Mid2++ = '\xbb';
                    *_Mid2++ = '\xbf';
                }
            }

            if (_Last2 - _Mid2 < 1 + _Nextra) {
                break; 
            }

            ++_Mid1;
            for (*_Mid2++ = _By; 0 < _Nextra;) {
                *_Mid2++ = static_cast<char>((_Ch >> 6 * --_Nextra & 0x3f) | 0x80);
            }
        }
        return _First1 == _Mid1 ? codecvt::partial : codecvt::ok;
    }

    virtual result  do_unshift(mbstate_t&, char* _First2, char*, char*& _Mid2) const {
        
        _Mid2 = _First2;
        return codecvt::noconv;
    }

    friend int _Codecvt_do_length<>(const codecvt&, mbstate_t&, const char*, const char*, size_t);

    virtual int  do_length(
        mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const {
        return _Codecvt_do_length(*this, _State, _First1, _Last1, _Count);
    }

    bool  do_always_noconv() const noexcept override {
        
        return false;
    }

    int  do_max_length() const noexcept override {
        
        return (_Mode & (_Consume_header | _Generate_header)) != 0 ? 9 : 6;
    }

    int  do_encoding() const noexcept override {
        
        return (_Mode & (_Consume_header | _Generate_header)) != 0 ? -1
                                                                   : 0; 
    }

private:
    unsigned long _Maxcode; 
    _Codecvt_mode _Mode; 
};


template <class _From, class _To>
struct [[nodiscard]] _Codecvt_guard {
    const _From* const& _First1;
    const _From*& _Mid1;
    _To* const& _First2;
    _To*& _Mid2;

    _Codecvt_guard(const _From* const& _First1_, const _From*& _Mid1_, _To* const& _First2_, _To*& _Mid2_)
        : _First1{_First1_}, _Mid1{_Mid1_}, _First2{_First2_}, _Mid2{_Mid2_} {}

    _Codecvt_guard(const _Codecvt_guard&)            = delete;
    _Codecvt_guard& operator=(const _Codecvt_guard&) = delete;

    ~_Codecvt_guard() {
        _Mid1 = _First1;
        _Mid2 = _First2;
    }
};

extern "C++" template <>
class codecvt<char16_t, char8_t, mbstate_t> : public codecvt_base {
    
public:
    using intern_type = char16_t;
    using extern_type = char8_t;
    using state_type  = mbstate_t;

    result in(mbstate_t& _State, const char8_t* _First1, const char8_t* _Last1, const char8_t*& _Mid1,
        char16_t* _First2, char16_t* _Last2, char16_t*& _Mid2) const {
        
        return do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result out(mbstate_t& _State, const char16_t* _First1, const char16_t* _Last1, const char16_t*& _Mid1,
        char8_t* _First2, char8_t* _Last2, char8_t*& _Mid2) const {
        
        return do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result unshift(mbstate_t& _State, char8_t* _First2, char8_t* _Last2, char8_t*& _Mid2) const {
        
        return do_unshift(_State, _First2, _Last2, _Mid2);
    }

    int length(mbstate_t& _State, const char8_t* _First1, const char8_t* _Last1, size_t _Count) const {
        
        
        return do_length(_State, _First1, _Last1, _Count);
    }

    __declspec(dllimport) static locale::id id;

    explicit codecvt(size_t _Refs = 0) : codecvt_base(_Refs) {} 
    explicit codecvt(const _Locinfo&, size_t _Refs = 0) : codecvt_base(_Refs) {} 

    static size_t _Getcat(const locale::facet** _Ppf = nullptr, const locale* = nullptr) {
        
        if (_Ppf && !*_Ppf) {
            *_Ppf = new codecvt;
        }

        return 2 ;
    }

protected:
     ~codecvt() noexcept override = default;

    virtual result  do_in(mbstate_t&, const char8_t* _First1, const char8_t* _Last1,
        const char8_t*& _Mid1, char16_t* _First2, char16_t* _Last2, char16_t*& _Mid2) const {
        
        _Adl_verify_range(_First1, _Last1);
        _Adl_verify_range(_First2, _Last2);

        _Codecvt_guard<char8_t, char16_t> _Guard{_First1, _Mid1, _First2, _Mid2};

        for (; _First1 != _Last1; ++_First1, ++_First2) {
            if (_First2 == _Last2) {
                return partial;
            }

            char8_t _Lead_byte = *_First1;
            if (_Lead_byte < 0b1000'0000u) { 
                *_First2 = static_cast<char16_t>(_Lead_byte);
                continue;
            }

            int _Trailing_count = 1;
            if (_Lead_byte < 0b1110'0000u) {
                if (_Lead_byte < 0b1100'0000u) { 
                    return error;
                }

                
                _Lead_byte &= 0b0001'1111u;
            } else if (_Lead_byte < 0b1111'0000u) { 
                _Lead_byte &= 0b0000'1111u;
                _Trailing_count = 2;
            } else if (_Lead_byte < 0b1111'1000u) { 
                if (_Last2 - _First2 < 2) { 
                    return partial;
                }

                _Lead_byte &= 0b0000'0111u;
                _Trailing_count = 3;
            } else { 
                return error;
            }

            if (_Last1 - _First1 < _Trailing_count + 1) { 
                return partial;
            }

            const char8_t* _Peek = _First1;
            char32_t _Code_point = _Lead_byte;
            do {
                const char8_t _By = *++_Peek;
                if ((_By & 0b1100'0000u) != 0b1000'0000u) { 
                    return error;
                }

                _Code_point = (_Code_point << 6) | (_By & 0b11'1111u);
            } while (--_Trailing_count != 0);

            if (_Code_point < 0x10000u) {
                if (_Code_point >= 0xd800u && _Code_point < 0xe000u) { 
                    return error;
                }
                
                *_First2 = static_cast<char16_t>(_Code_point);
            } else if (_Code_point >= 0x110000u) { 
                return error;
            } else {
                
                _Code_point -= 0x10000u;
                
                *_First2 = static_cast<char16_t>(0xd800u | (_Code_point >> 10));
                
                *++_First2 = static_cast<char16_t>(0xdc00u | (_Code_point & 0b11'1111'1111u));
            }

            _First1 = _Peek;
        }

        return ok;
    }

    virtual result  do_out(mbstate_t&, const char16_t* _First1, const char16_t* _Last1,
        const char16_t*& _Mid1, char8_t* _First2, char8_t* _Last2, char8_t*& _Mid2) const {
        
        _Adl_verify_range(_First1, _Last1);
        _Adl_verify_range(_First2, _Last2);

        _Codecvt_guard<char16_t, char8_t> _Guard{_First1, _Mid1, _First2, _Mid2};

        for (; _First1 != _Last1; ++_First1, ++_First2) {
            if (_First2 == _Last2) { 
                return partial;
            }

            char32_t _Code_point = *_First1;
            if (_Code_point < 0x80u) { 
                *_First2 = static_cast<char8_t>(_Code_point);
                continue;
            }

            int _Trailing_count = 1;
            if (_Code_point < 0x800u) { 
                *_First2 = static_cast<char8_t>(0b1100'0000u | (_Code_point >> 6));
            } else if (_Code_point < 0xd800u || _Code_point >= 0xe000u) { 
                *_First2        = static_cast<char8_t>(0b1110'0000u | (_Code_point >> 12));
                _Trailing_count = 2;
            } else if (_Code_point < 0xdc00u) { 
                if (_Last1 - _First1 < 2) { 
                    return partial;
                }

                const char16_t _Low_surrogate = *++_First1;
                if (_Low_surrogate < 0xdc00u || _Low_surrogate >= 0xe000u) { 
                    --_First1;
                    return error;
                }
                _Code_point = 0x10000u + (((_Code_point & 0b11'1111'1111u) << 10) | (_Low_surrogate & 0b11'1111'1111u));

                
                *_First2        = static_cast<char8_t>(0b1111'0000u | (_Code_point >> 18));
                _Trailing_count = 3;
            } else { 
                return error;
            }

            if (_Last2 - _First2 < _Trailing_count + 1) { 
                if (_Trailing_count > 2) { 
                    --_First1;
                }
                return partial;
            }

            do {
                --_Trailing_count;
                *++_First2 = static_cast<char8_t>(0b1000'0000u | ((_Code_point >> (6 * _Trailing_count)) & 0b11'1111u));
            } while (_Trailing_count != 0);
        }

        return ok;
    }

    virtual result  do_unshift(mbstate_t&, char8_t* _First2, char8_t*, char8_t*& _Mid2) const {
        
        _Mid2 = _First2;
        return noconv; 
    }

    virtual int  do_length(
        mbstate_t&, const char8_t* _First1, const char8_t* _Last1, size_t _Count) const {
        
        
        _Adl_verify_range(_First1, _Last1);

        const auto _Old_first1 = _First1;

        for (; _First1 != _Last1 && _Count > 0u; ++_First1, --_Count) {
            char32_t _Code_point = *_First1;
            if (_Code_point < 0b1000'0000u) { 
                continue;
            }

            int _Trailing_count = 1;
            if (_Code_point < 0b1110'0000u) {
                if (_Code_point < 0b1100'0000u) { 
                    break;
                }

                
                _Code_point &= 0b0001'1111u;
            } else if (_Code_point < 0b1111'0000u) { 
                _Code_point &= 0b0000'1111u;
                _Trailing_count = 2;
            } else if (_Code_point < 0b1111'1000u) { 
                if (_Count < 2u) { 
                    break;
                }

                _Code_point &= 0b0000'0111u;
                _Trailing_count = 3;
            } else { 
                break;
            }

            if (_Last1 - _First1 < _Trailing_count + 1) { 
                break;
            }

            const char8_t* _Peek = _First1;
            bool _Done           = false;
            do {
                const char8_t _By = *++_Peek;
                if ((_By & 0b1100'0000u) != 0b1000'0000u) { 
                    _Done = true;
                    break;
                }

                _Code_point = (_Code_point << 6) | (_By & 0b11'1111u);
            } while (--_Trailing_count != 0);

            if (_Done) {
                break;
            }

            if (_Code_point < 0x10000u) { 
                if (_Code_point >= 0xd800u && _Code_point < 0xe0000u) { 
                    break;
                }
            } else if (_Code_point < 0x110000u) { 
                --_Count;
            } else { 
                break;
            }

            _First1 = _Peek;
        }

        return static_cast<int>((::std:: min)(_First1 - _Old_first1, ptrdiff_t{2147483647 }));
    }

    bool  do_always_noconv() const noexcept override {
        
        return false;
    }

    int  do_max_length() const noexcept override {
        
        return 4; 
    }

    int  do_encoding() const noexcept override {
        
        return 0; 
    }
};

extern "C++" template <>
class codecvt<char32_t, char8_t, mbstate_t> : public codecvt_base {
    
public:
    using intern_type = char32_t;
    using extern_type = char8_t;
    using state_type  = mbstate_t;

    result in(mbstate_t& _State, const char8_t* _First1, const char8_t* _Last1, const char8_t*& _Mid1,
        char32_t* _First2, char32_t* _Last2, char32_t*& _Mid2) const {
        
        return do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result out(mbstate_t& _State, const char32_t* _First1, const char32_t* _Last1, const char32_t*& _Mid1,
        char8_t* _First2, char8_t* _Last2, char8_t*& _Mid2) const {
        
        return do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result unshift(mbstate_t& _State, char8_t* _First2, char8_t* _Last2, char8_t*& _Mid2) const {
        
        return do_unshift(_State, _First2, _Last2, _Mid2);
    }

    int length(mbstate_t& _State, const char8_t* _First1, const char8_t* _Last1, size_t _Count) const {
        
        
        return do_length(_State, _First1, _Last1, _Count);
    }

    __declspec(dllimport) static locale::id id;

    explicit codecvt(size_t _Refs = 0) : codecvt_base(_Refs) {} 
    explicit codecvt(const _Locinfo&, size_t _Refs = 0) : codecvt_base(_Refs) {} 

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* = nullptr) {
        
        if (_Ppf && !*_Ppf) {
            *_Ppf = new codecvt;
        }

        return 2 ;
    }

protected:
     ~codecvt() noexcept override = default;

    virtual result  do_in(mbstate_t&, const char8_t* _First1, const char8_t* _Last1,
        const char8_t*& _Mid1, char32_t* _First2, char32_t* _Last2, char32_t*& _Mid2) const {
        
        _Adl_verify_range(_First1, _Last1);
        _Adl_verify_range(_First2, _Last2);

        _Codecvt_guard<char8_t, char32_t> _Guard{_First1, _Mid1, _First2, _Mid2};

        for (; _First1 != _Last1; ++_First1, ++_First2) {
            if (_First2 == _Last2) {
                return partial;
            }

            char8_t _Lead_byte = *_First1;
            if (_Lead_byte < 0b1000'0000u) { 
                *_First2 = _Lead_byte;
                continue;
            }

            int _Trailing_count = 1;
            if (_Lead_byte < 0b1110'0000u) {
                if (_Lead_byte < 0b1100'0000u) { 
                    return partial;
                }

                
                _Lead_byte &= 0b0001'1111u;
            } else if (_Lead_byte < 0b1111'0000u) { 
                _Lead_byte &= 0b0000'1111u;
                _Trailing_count = 2;
            } else if (_Lead_byte < 0b1111'1000u) { 
                _Lead_byte &= 0b0000'0111u;
                _Trailing_count = 3;
            } else { 
                return error;
            }

            if (_Last1 - _First1 < _Trailing_count + 1) { 
                return partial;
            }

            const char8_t* _Peek = _First1;
            char32_t _Code_point = _Lead_byte;
            do {
                const char8_t _By = *++_Peek;
                if ((_By & 0b1100'0000u) != 0b1000'0000u) { 
                    return error;
                }

                _Code_point = (_Code_point << 6) | (_By & 0b11'1111u);
            } while (--_Trailing_count != 0);

            if (_Code_point >= 0xd800u && (_Code_point < 0xe000u || _Code_point >= 0x110000u)) {
                
                return error;
            }

            _First1  = _Peek;
            *_First2 = _Code_point;
        }

        return ok;
    }

    virtual result  do_out(mbstate_t&, const char32_t* _First1, const char32_t* _Last1,
        const char32_t*& _Mid1, char8_t* _First2, char8_t* _Last2, char8_t*& _Mid2) const {
        
        _Adl_verify_range(_First1, _Last1);
        _Adl_verify_range(_First2, _Last2);

        _Codecvt_guard<char32_t, char8_t> _Guard{_First1, _Mid1, _First2, _Mid2};

        for (; _First1 != _Last1; ++_First1, ++_First2) {
            if (_First2 == _Last2) { 
                return partial;
            }

            const char32_t _Code_point = *_First1;
            if (_Code_point < 0x80u) { 
                *_First2 = static_cast<char8_t>(_Code_point);
                continue;
            }

            int _Trailing_count = 1;
            if (_Code_point < 0x800u) { 
                *_First2 = static_cast<char8_t>(0b1100'0000u | (_Code_point >> 6));
            } else if (_Code_point < 0x10000u) { 
                if (_Code_point >= 0xd800u && _Code_point < 0xe000u) { 
                    return error;
                }

                *_First2        = static_cast<char8_t>(0b1110'0000u | (_Code_point >> 12));
                _Trailing_count = 2;
            } else if (_Code_point < 0x110000u) { 
                *_First2        = static_cast<char8_t>(0b1111'0000u | (_Code_point >> 18));
                _Trailing_count = 3;
            } else { 
                return error;
            }

            if (_Last2 - _First2 < _Trailing_count + 1) { 
                return partial;
            }

            do {
                --_Trailing_count;
                *++_First2 = static_cast<char8_t>(0b1000'0000u | ((_Code_point >> (6 * _Trailing_count)) & 0b11'1111u));
            } while (_Trailing_count != 0);
        }

        return ok;
    }

    virtual result  do_unshift(mbstate_t&, char8_t* _First2, char8_t*, char8_t*& _Mid2) const {
        
        _Mid2 = _First2;
        return noconv; 
    }

    virtual int  do_length(
        mbstate_t&, const char8_t* _First1, const char8_t* _Last1, size_t _Count) const {
        
        
        _Adl_verify_range(_First1, _Last1);

        const auto _Old_first1 = _First1;

        for (; _First1 != _Last1 && _Count > 0u; ++_First1, --_Count) {
            char32_t _Code_point = *_First1;
            if (_Code_point < 0b1000'0000u) { 
                continue;
            }

            int _Trailing_count = 1;
            if (_Code_point < 0b1110'0000u) {
                if (_Code_point < 0b1100'0000u) { 
                    break;
                }

                
                _Code_point &= 0b0001'1111u;
            } else if (_Code_point < 0b1111'0000u) { 
                _Code_point &= 0b0000'1111u;
                _Trailing_count = 2;
            } else if (_Code_point < 0b1111'1000u) { 
                _Code_point &= 0b0000'0111u;
                _Trailing_count = 3;
            } else { 
                break;
            }

            if (_Last1 - _First1 < _Trailing_count + 1) { 
                break;
            }

            const char8_t* _Peek = _First1;
            bool _Done           = false;
            do {
                const char8_t _By = *++_Peek;
                if ((_By & 0b1100'0000u) != 0b1000'0000u) { 
                    _Done = true;
                    break;
                }

                _Code_point = (_Code_point << 6) | (_By & 0b11'1111u);
            } while (--_Trailing_count != 0);

            if (_Done || (_Code_point >= 0xd800u && (_Code_point < 0xe000u || _Code_point >= 0x110000u))) {
                
                break;
            }

            _First1 = _Peek;
        }

        return static_cast<int>((::std:: min)(_First1 - _Old_first1, ptrdiff_t{2147483647 }));
    }

    bool  do_always_noconv() const noexcept override {
        
        return false;
    }

    int  do_max_length() const noexcept override {
        
        return 4;
    }

    int  do_encoding() const noexcept override {
        
        return 0; 
    }
};
#line 1921 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xlocale"

extern "C++" template <>
class __declspec(dllimport) codecvt<wchar_t, char, mbstate_t> : public codecvt_base {
    
public:
    using intern_type = wchar_t;
    using extern_type = char;
    using state_type  = mbstate_t;

    result  in(mbstate_t& _State, const char* _First1, const char* _Last1, const char*& _Mid1,
        wchar_t* _First2, wchar_t* _Last2, wchar_t*& _Mid2) const {
        
        return do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result  out(mbstate_t& _State, const wchar_t* _First1, const wchar_t* _Last1,
        const wchar_t*& _Mid1, char* _First2, char* _Last2, char*& _Mid2) const {
        
        return do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result  unshift(mbstate_t& _State, char* _First2, char* _Last2, char*& _Mid2) const {
        
        return do_unshift(_State, _First2, _Last2, _Mid2);
    }

    int  length(mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const {
        
        
        return do_length(_State, _First1, _Last1, _Count);
    }

     static locale::id id;

    explicit  codecvt(size_t _Refs = 0) : codecvt_base(_Refs) {
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }

    explicit  codecvt(const _Locinfo& _Lobj, size_t _Refs = 0) : codecvt_base(_Refs) {
        _Init(_Lobj);
    }

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        
        if (_Ppf && !*_Ppf) {
            *_Ppf = new codecvt(_Locinfo(_Ploc->_C_str()));
        }

        return 2 ;
    }

protected:
     ~codecvt() noexcept override {}

    void  _Init(const _Locinfo& _Lobj) { 
        _Cvt = _Lobj._Getcvt();
    }

    virtual result  do_in(mbstate_t&, const char* _First1, const char* _Last1, const char*& _Mid1,
        wchar_t* _First2, wchar_t* _Last2, wchar_t*& _Mid2) const {
        
        mbstate_t _Mystate{};
        _Adl_verify_range(_First1, _Last1);
        _Adl_verify_range(_First2, _Last2);
        _Mid1 = _First1;
        _Mid2 = _First2;
        for (;;) {
            if (_Mid1 == _Last1) {
                return ok;
            }

            if (_Mid2 == _Last2) {
                return partial;
            }

            int _Bytes = _Mbrtowc(_Mid2, _Mid1, static_cast<size_t>(_Last1 - _Mid1), &_Mystate, &_Cvt);
            switch (_Bytes) {
            case -2: 
                return partial;

            case -1: 
                return error;

            case 0: 
                _Bytes = 1;
                [[fallthrough]] ;

            default: 
                _Mid1 += _Bytes;
                ++_Mid2;
                break;
            }
        }
    }

    virtual result  do_out(mbstate_t& _State, const wchar_t* _First1, const wchar_t* _Last1,
        const wchar_t*& _Mid1, char* _First2, char* _Last2, char*& _Mid2) const {
        
        _Adl_verify_range(_First1, _Last1);
        _Adl_verify_range(_First2, _Last2);
        _Mid1 = _First1;
        _Mid2 = _First2;
        int _Bytes;

        while (_Mid1 != _Last1 && _Mid2 != _Last2) {
            if (5 <= _Last2 - _Mid2) {
                if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1, &_State, &_Cvt)) < 0) {
                    return error; 
                } else {
                    ++_Mid1;
                    _Mid2 += _Bytes;
                }
            } else { 
                char _Buf[5 ];
                mbstate_t _Stsave = _State;

                if ((_Bytes = _Wcrtomb(_Buf, *_Mid1, &_State, &_Cvt)) < 0) {
                    return error; 
                } else if (_Last2 - _Mid2 < _Bytes) { 
                    _State = _Stsave;
                    break;
                } else { 
                    :: memcpy(_Mid2, _Buf, static_cast<size_t>(_Bytes));
                    ++_Mid1;
                    _Mid2 += _Bytes;
                }
            }
        }

        return _Mid1 == _Last1 ? ok : partial;
    }

    virtual result  do_unshift(mbstate_t& _State, char* _First2, char* _Last2, char*& _Mid2) const {
        
        _Adl_verify_range(_First2, _Last2);
        _Mid2       = _First2;
        result _Ans = ok;
        int _Bytes;
        char _Buf[5 ];
        mbstate_t _Stsave = _State;

        if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0) {
            _Ans = error; 
        } else if (_Last2 - _Mid2 < --_Bytes) { 
            _State = _Stsave;
            _Ans   = partial;
        } else if (0 < _Bytes) { 
            :: memcpy(_Mid2, _Buf, static_cast<size_t>(_Bytes));
            _Mid2 += _Bytes;
        }
        return _Ans;
    }

    virtual int  do_length(
        mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const {
        
        
        _Adl_verify_range(_First1, _Last1);
        const auto _Old_first1 = _First1;

        for (; _Count > 0u && _First1 != _Last1; --_Count) {
            wchar_t _Ch;
            int _Bytes = _Mbrtowc(&_Ch, _First1, static_cast<size_t>(_Last1 - _First1), &_State, &_Cvt);
            if (_Bytes < 0) { 
                break;
            }

            if (_Bytes == 0) { 
                _Bytes = 1;
            }

            
            _First1 += _Bytes;
        }

        return static_cast<int>((::std:: min)(_First1 - _Old_first1, ptrdiff_t{2147483647 }));
    }

    bool  do_always_noconv() const noexcept override {
        
        return false;
    }

    int  do_max_length() const noexcept override {
        
        return static_cast<int>(_Cvt._Mbcurmax);
    }

    int  do_encoding() const noexcept override {
        
        return _Cvt._Mbcurmax == 1; 
    }

private:
    _Locinfo::_Cvtvec _Cvt; 
};


extern "C++" template <>
class __declspec(dllimport) codecvt<unsigned short, char, mbstate_t> : public codecvt_base {
    
public:
    using intern_type = unsigned short;
    using extern_type = char;
    using state_type  = mbstate_t;

    result  in(mbstate_t& _State, const char* _First1, const char* _Last1, const char*& _Mid1,
        unsigned short* _First2, unsigned short* _Last2, unsigned short*& _Mid2) const {
        
        return do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result  out(mbstate_t& _State, const unsigned short* _First1, const unsigned short* _Last1,
        const unsigned short*& _Mid1, char* _First2, char* _Last2, char*& _Mid2) const {
        
        return do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result  unshift(mbstate_t& _State, char* _First2, char* _Last2, char*& _Mid2) const {
        
        return do_unshift(_State, _First2, _Last2, _Mid2);
    }

    int  length(mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const {
        
        
        return do_length(_State, _First1, _Last1, _Count);
    }

     static locale::id id;

    explicit  codecvt(size_t _Refs = 0) : codecvt_base(_Refs) {
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }

    explicit  codecvt(const _Locinfo& _Lobj, size_t _Refs = 0) : codecvt_base(_Refs) {
        _Init(_Lobj);
    }

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        
        if (_Ppf && !*_Ppf) {
            *_Ppf = new codecvt(_Locinfo(_Ploc->_C_str()));
        }

        return 2 ;
    }

protected:
     ~codecvt() noexcept override {}

    void  _Init(const _Locinfo& _Lobj) { 
        _Cvt = _Lobj._Getcvt();
    }

    virtual result  do_in(mbstate_t&, const char* _First1, const char* _Last1, const char*& _Mid1,
        unsigned short* _First2, unsigned short* _Last2, unsigned short*& _Mid2) const {
        
        mbstate_t _Mystate{};
        _Adl_verify_range(_First1, _Last1);
        _Adl_verify_range(_First2, _Last2);
        _Mid1 = _First1;
        _Mid2 = _First2;
        for (;;) {
            if (_Mid1 == _Last1) {
                return ok;
            }

            if (_Mid2 == _Last2) {
                return partial;
            }

            int _Bytes = _Mbrtowc(
                reinterpret_cast<wchar_t*>(_Mid2), _Mid1, static_cast<size_t>(_Last1 - _Mid1), &_Mystate, &_Cvt);
            switch (_Bytes) {
            case -2: 
                return partial;

            case -1: 
                return error;

            case 0: 
                _Bytes = 1;
                [[fallthrough]] ;

            default: 
                _Mid1 += _Bytes;
                ++_Mid2;
                break;
            }
        }
    }

    virtual result  do_out(mbstate_t& _State, const unsigned short* _First1,
        const unsigned short* _Last1, const unsigned short*& _Mid1, char* _First2, char* _Last2, char*& _Mid2) const {
        
        _Adl_verify_range(_First1, _Last1);
        _Adl_verify_range(_First2, _Last2);
        _Mid1 = _First1;
        _Mid2 = _First2;
        int _Bytes;

        while (_Mid1 != _Last1 && _Mid2 != _Last2) {
            if (5 <= _Last2 - _Mid2) {
                if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1, &_State, &_Cvt)) < 0) {
                    return error; 
                } else {
                    ++_Mid1;
                    _Mid2 += _Bytes;
                }
            } else { 
                char _Buf[5 ];
                mbstate_t _Stsave = _State;

                if ((_Bytes = _Wcrtomb(_Buf, *_Mid1, &_State, &_Cvt)) < 0) {
                    return error; 
                } else if (_Last2 - _Mid2 < _Bytes) { 
                    _State = _Stsave;
                    break;
                } else { 
                    :: memcpy(_Mid2, _Buf, static_cast<size_t>(_Bytes));
                    ++_Mid1;
                    _Mid2 += _Bytes;
                }
            }
        }

        return _Mid1 == _Last1 ? ok : partial;
    }

    virtual result  do_unshift(mbstate_t& _State, char* _First2, char* _Last2, char*& _Mid2) const {
        
        _Adl_verify_range(_First2, _Last2);
        _Mid2       = _First2;
        result _Ans = ok;
        int _Bytes;
        char _Buf[5 ];
        mbstate_t _Stsave = _State;

        if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0) {
            _Ans = error; 
        } else if (_Last2 - _Mid2 < --_Bytes) { 
            _State = _Stsave;
            _Ans   = partial;
        } else if (0 < _Bytes) { 
            :: memcpy(_Mid2, _Buf, static_cast<size_t>(_Bytes));
            _Mid2 += _Bytes;
        }

        return _Ans;
    }

    virtual int  do_length(
        mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const {
        
        
        _Adl_verify_range(_First1, _Last1);
        const auto _Old_first1 = _First1;

        for (; _Count > 0u && _First1 != _Last1; --_Count) {
            wchar_t _Ch;
            int _Bytes = _Mbrtowc(&_Ch, _First1, static_cast<size_t>(_Last1 - _First1), &_State, &_Cvt);
            if (_Bytes < 0) { 
                break;
            }

            if (_Bytes == 0) { 
                _Bytes = 1;
            }

            
            _First1 += _Bytes;
        }

        return static_cast<int>((::std:: min)(_First1 - _Old_first1, ptrdiff_t{2147483647 }));
    }

    bool  do_always_noconv() const noexcept override {
        
        return false;
    }

    int  do_max_length() const noexcept override {
        
        return static_cast<int>(_Cvt._Mbcurmax);
    }

    int  do_encoding() const noexcept override {
        
        return _Cvt._Mbcurmax == 1u; 
    }

private:
    _Locinfo::_Cvtvec _Cvt; 
};
#line 2321 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xlocale"

 template <class _Elem, class _Byte, class _Statype>
class codecvt_byname : public codecvt<_Elem, _Byte, _Statype> { 
public:
    static_assert(!0
                      || _Is_any_of_v<codecvt_byname,

                          codecvt_byname<char16_t, char8_t, mbstate_t>, codecvt_byname<char32_t, char8_t, mbstate_t>,
#line 2330 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xlocale"
                          codecvt_byname<char, char, mbstate_t>, codecvt_byname<wchar_t, char, mbstate_t>>,
        "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. " "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 " "to suppress this error." );

    explicit  codecvt_byname(const char* _Locname, size_t _Refs = 0)
        : codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Locname), _Refs) {} 

    explicit  codecvt_byname(const string& _Str, size_t _Refs = 0)
        : codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Str.c_str()), _Refs) {} 

protected:
     ~codecvt_byname() noexcept override {}
};











 extern "C++" struct __declspec(dllimport) ctype_base : locale::facet { 
    enum { 
        alnum  = 0x04 | 0x02 | 0x01 | 0x100 ,
        alpha  = 0x02 | 0x01 | 0x100 ,
        cntrl  = 0x20 ,
        digit  = 0x04 ,
        graph  = 0x04 | 0x02 | 0x10 | 0x01 | 0x100 ,
        lower  = 0x02 ,
        print  = 0x04 | 0x02 | 0x10 | 0x40 | 0x01 | 0x100 | 0x80 ,
        punct  = 0x10 ,
        space  = 0x08 | 0x40 ,
        upper  = 0x01 ,
        xdigit = 0x80 ,
        blank  = 0x08 | 0x40
    };
    using mask = short; 

     ctype_base(size_t _Refs = 0) : locale::facet(_Refs) {}

     ~ctype_base() noexcept override {}
};











 extern "C++" template <class _Elem>
class ctype : public ctype_base { 
public:
    
    static_assert(!0 || _Always_false<_Elem>, "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. " "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 " "to suppress this error." );

    using char_type = _Elem;

    bool  is(mask _Maskval, _Elem _Ch) const { 
        return do_is(_Maskval, _Ch);
    }

    const _Elem*  is(const _Elem* _First, const _Elem* _Last,
        mask* _Dest) const { 
        return do_is(_First, _Last, _Dest);
    }

    const _Elem*  scan_is(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        return do_scan_is(_Maskval, _First, _Last);
    }

    const _Elem*  scan_not(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        return do_scan_not(_Maskval, _First, _Last);
    }

    _Elem  tolower(_Elem _Ch) const { 
        return do_tolower(_Ch);
    }

    const _Elem*  tolower(
        _Elem* _First, const _Elem* _Last) const { 
        return do_tolower(_First, _Last);
    }

    _Elem  toupper(_Elem _Ch) const { 
        return do_toupper(_Ch);
    }

    const _Elem*  toupper(
        _Elem* _First, const _Elem* _Last) const { 
        return do_toupper(_First, _Last);
    }

    _Elem  widen(char _Byte) const { 
        return do_widen(_Byte);
    }

    const char*  widen(const char* _First, const char* _Last,
        _Elem* _Dest) const { 
        return do_widen(_First, _Last, _Dest);
    }

    char  narrow(_Elem _Ch, char _Dflt = '\0') const { 
        return do_narrow(_Ch, _Dflt);
    }

    const _Elem*  narrow(const _Elem* _First, const _Elem* _Last, char _Dflt,
        char* _Dest) const { 
        return do_narrow(_First, _Last, _Dflt, _Dest);
    }

     static locale::id id;

    explicit  ctype(size_t _Refs = 0) : ctype_base(_Refs) {
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }

     ctype(const _Locinfo& _Lobj, size_t _Refs = 0) : ctype_base(_Refs) {
        _Init(_Lobj);
    }

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        if (_Ppf && !*_Ppf) {
            *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->_C_str()));
        }

        return 2 ;
    }

protected:
     ~ctype() noexcept override {
        if (_Ctype._Delfl) {
            :: free(const_cast<short*>(_Ctype._Table));
        }

        :: free(_Ctype._LocaleName);
    }

    void  _Init(const _Locinfo& _Lobj) { 
        _Ctype = _Lobj._Getctype();
        _Cvt   = _Lobj._Getcvt();
    }

    virtual bool  do_is(
        mask _Maskval, _Elem _Ch) const { 
        return (_Ctype._Table[static_cast<unsigned char>(narrow(_Ch))] & _Maskval) != 0;
    }

    virtual const _Elem*  do_is(const _Elem* _First, const _Elem* _Last,
        mask* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Ctype._Table[static_cast<unsigned char>(narrow(*_First))];
        }

        return _First;
    }

    virtual const _Elem*  do_scan_is(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && !is(_Maskval, *_First)) {
            ++_First;
        }

        return _First;
    }

    virtual const _Elem*  do_scan_not(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && is(_Maskval, *_First)) {
            ++_First;
        }

        return _First;
    }

    virtual _Elem  do_tolower(_Elem _Ch) const { 
        unsigned char _Byte = static_cast<unsigned char>(narrow(_Ch, '\0'));
        if (_Byte == '\0') {
            return _Ch;
        }

        return widen(static_cast<char>(_Tolower(_Byte, &_Ctype)));
    }

    virtual const _Elem*  do_tolower(_Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First) { 
            unsigned char _Byte = static_cast<unsigned char>(narrow(*_First, '\0'));
            if (_Byte != '\0') {
                *_First = (widen(static_cast<char>(_Tolower(_Byte, &_Ctype))));
            }
        }
        return _First;
    }

    virtual _Elem  do_toupper(_Elem _Ch) const { 
        unsigned char _Byte = static_cast<unsigned char>(narrow(_Ch, '\0'));
        if (_Byte == '\0') {
            return _Ch;
        }

        return widen(static_cast<char>(_Toupper(_Byte, &_Ctype)));
    }

    virtual const _Elem*  do_toupper(_Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First) { 
            unsigned char _Byte = static_cast<unsigned char>(narrow(*_First, '\0'));
            if (_Byte != '\0') {
                *_First = (widen(static_cast<char>(_Toupper(_Byte, &_Ctype))));
            }
        }

        return _First;
    }

    virtual _Elem  do_widen(char _Byte) const { 
        return _Maklocchr(_Byte, static_cast<_Elem*>(nullptr), _Cvt);
    }

    virtual const char*  do_widen(
        const char* _First, const char* _Last, _Elem* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Maklocchr(*_First, static_cast<_Elem*>(nullptr), _Cvt);
        }

        return _First;
    }

    char  _Donarrow(_Elem _Ch, char _Dflt) const { 
        char _Byte;
        if (_Ch == _Elem{}) {
            return '\0';
        }

        if ((_Byte = _Maklocbyte(_Ch, _Cvt)) == '\0') {
            return _Dflt;
        }

        return _Byte;
    }

    virtual char  do_narrow(_Elem _Ch, char _Dflt) const { 
        return _Donarrow(_Ch, _Dflt);
    }

    virtual const _Elem*  do_narrow(const _Elem* _First, const _Elem* _Last, char _Dflt,
        char* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Donarrow(*_First, _Dflt);
        }

        return _First;
    }

private:
    _Locinfo::_Ctypevec _Ctype; 
    _Locinfo::_Cvtvec _Cvt; 
};






template <class _Elem>
locale::id ctype<_Elem>::id;





extern "C++" template <>
class __declspec(dllimport) ctype<char> : public ctype_base { 
public:
    using _Elem     = char;
    using char_type = _Elem;

    bool  is(mask _Maskval, _Elem _Ch) const { 
        return (_Ctype._Table[static_cast<unsigned char>(_Ch)] & _Maskval) != 0;
    }

    const _Elem*  is(const _Elem* _First, const _Elem* _Last,
        mask* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Ctype._Table[static_cast<unsigned char>(*_First)];
        }

        return _First;
    }

    const _Elem*  scan_is(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && !is(_Maskval, *_First)) {
            ++_First;
        }

        return _First;
    }

    const _Elem*  scan_not(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && is(_Maskval, *_First)) {
            ++_First;
        }

        return _First;
    }

    _Elem  tolower(_Elem _Ch) const { 
        return do_tolower(_Ch);
    }

    const _Elem*  tolower(
        _Elem* _First, const _Elem* _Last) const { 
        return do_tolower(_First, _Last);
    }

    _Elem  toupper(_Elem _Ch) const { 
        return do_toupper(_Ch);
    }

    const _Elem*  toupper(
        _Elem* _First, const _Elem* _Last) const { 
        return do_toupper(_First, _Last);
    }

    _Elem  widen(char _Byte) const { 
        return do_widen(_Byte);
    }

    const _Elem*  widen(const char* _First, const char* _Last,
        _Elem* _Dest) const { 
        return do_widen(_First, _Last, _Dest);
    }

    _Elem  narrow(_Elem _Ch, char _Dflt = '\0') const { 
        return do_narrow(_Ch, _Dflt);
    }

    const _Elem*  narrow(const _Elem* _First, const _Elem* _Last, char _Dflt,
        char* _Dest) const { 
        return do_narrow(_First, _Last, _Dflt, _Dest);
    }

     static locale::id id;

    explicit  ctype(const mask* _Table = nullptr, bool _Deletetable = false,
        size_t _Refs = 0)
        : ctype_base(_Refs) { 
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }

        _Tidy(); 
        if (_Table) { 
            _Ctype._Table = _Table;
            _Ctype._Delfl = _Deletetable ? -1 : 0;
        } else { 
            _Ctype._Table = classic_table();
            _Ctype._Delfl = 0;
        }
    }

     ctype(const _Locinfo& _Lobj, size_t _Refs = 0) : ctype_base(_Refs) {
        _Init(_Lobj);
    }

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        if (_Ppf && !*_Ppf) {
            *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->_C_str()));
        }

        return 2 ;
    }

    const mask*  table() const noexcept {
        return _Ctype._Table;
    }

    static const mask* __cdecl classic_table() noexcept {
        return ::std:: use_facet<ctype>(locale::classic()).table();
    }

     static const size_t table_size = 1 << 8 ; 

protected:
     ~ctype() noexcept override {
        _Tidy();
    }

    void  _Init(const _Locinfo& _Lobj) { 
        _Ctype = _Lobj._Getctype();
    }

    void  _Tidy() noexcept { 
        if (0 < _Ctype._Delfl) {
            :: free(const_cast<short*>(_Ctype._Table));
        } else if (_Ctype._Delfl < 0) {
            delete[] _Ctype._Table;
        }

        :: free(_Ctype._LocaleName);
    }

    virtual _Elem  do_tolower(_Elem _Ch) const { 
        return static_cast<_Elem>(_Tolower(static_cast<unsigned char>(_Ch), &_Ctype));
    }

    virtual const _Elem*  do_tolower(_Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First) {
            *_First = static_cast<_Elem>(_Tolower(static_cast<unsigned char>(*_First), &_Ctype));
        }

        return _First;
    }

    virtual _Elem  do_toupper(_Elem _Ch) const { 
        return static_cast<_Elem>(_Toupper(static_cast<unsigned char>(_Ch), &_Ctype));
    }

    virtual const _Elem*  do_toupper(_Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First) {
            *_First = static_cast<_Elem>(_Toupper(static_cast<unsigned char>(*_First), &_Ctype));
        }

        return _First;
    }

    virtual _Elem  do_widen(char _Byte) const { 
        return _Byte;
    }

    virtual const _Elem*  do_widen(
        const char* _First, const char* _Last, _Elem* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        :: memcpy(_Dest, _First, static_cast<size_t>(_Last - _First));
        return _Last;
    }

    virtual _Elem  do_narrow(_Elem _Ch, char) const { 
        return _Ch;
    }

    virtual const _Elem*  do_narrow(const _Elem* _First, const _Elem* _Last, char,
        char* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        :: memcpy(_Dest, _First, static_cast<size_t>(_Last - _First));
        return _Last;
    }

private:
    _Locinfo::_Ctypevec _Ctype; 
};

extern "C++" template <>
class __declspec(dllimport) ctype<wchar_t>
    : public ctype_base { 
public:
    using _Elem     = wchar_t;
    using char_type = _Elem;

    bool  is(mask _Maskval, _Elem _Ch) const { 
        return do_is(_Maskval, _Ch);
    }

    const _Elem*  is(const _Elem* _First, const _Elem* _Last,
        mask* _Dest) const { 
        return do_is(_First, _Last, _Dest);
    }

    const _Elem*  scan_is(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        return do_scan_is(_Maskval, _First, _Last);
    }

    const _Elem*  scan_not(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        return do_scan_not(_Maskval, _First, _Last);
    }

    _Elem  tolower(_Elem _Ch) const { 
        return do_tolower(_Ch);
    }

    const _Elem*  tolower(
        _Elem* _First, const _Elem* _Last) const { 
        return do_tolower(_First, _Last);
    }

    _Elem  toupper(_Elem _Ch) const { 
        return do_toupper(_Ch);
    }

    const _Elem*  toupper(
        _Elem* _First, const _Elem* _Last) const { 
        return do_toupper(_First, _Last);
    }

    _Elem  widen(char _Byte) const { 
        return do_widen(_Byte);
    }

    const char*  widen(const char* _First, const char* _Last,
        _Elem* _Dest) const { 
        return do_widen(_First, _Last, _Dest);
    }

    char  narrow(_Elem _Ch, char _Dflt = '\0') const { 
        return do_narrow(_Ch, _Dflt);
    }

    const _Elem*  narrow(const _Elem* _First, const _Elem* _Last, char _Dflt,
        char* _Dest) const { 
        return do_narrow(_First, _Last, _Dflt, _Dest);
    }

     static locale::id id;

    explicit  ctype(size_t _Refs = 0) : ctype_base(_Refs) {
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }

     ctype(const _Locinfo& _Lobj, size_t _Refs = 0) : ctype_base(_Refs) {
        _Init(_Lobj);
    }

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        if (_Ppf && !*_Ppf) {
            *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->_C_str()));
        }

        return 2 ;
    }

protected:
     ~ctype() noexcept override {
        if (_Ctype._Delfl) {
            :: free(const_cast<short*>(_Ctype._Table));
        }

        :: free(_Ctype._LocaleName);
    }

    void  _Init(const _Locinfo& _Lobj) { 
        _Ctype = _Lobj._Getctype();
        _Cvt   = _Lobj._Getcvt();
    }

    virtual bool  do_is(
        mask _Maskval, _Elem _Ch) const { 
        return (:: _Getwctype(_Ch, &_Ctype) & _Maskval) != 0;
    }

    virtual const _Elem*  do_is(const _Elem* _First, const _Elem* _Last,
        mask* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        return :: _Getwctypes(_First, _Last, _Dest, &_Ctype);
    }

    virtual const _Elem*  do_scan_is(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && !is(_Maskval, *_First)) {
            ++_First;
        }

        return _First;
    }

    virtual const _Elem*  do_scan_not(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && is(_Maskval, *_First)) {
            ++_First;
        }

        return _First;
    }

    virtual _Elem  do_tolower(_Elem _Ch) const { 
        return _Towlower(_Ch, &_Ctype);
    }

    virtual const _Elem*  do_tolower(_Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First) {
            *_First = _Towlower(*_First, &_Ctype);
        }

        return _First;
    }

    virtual _Elem  do_toupper(_Elem _Ch) const { 
        return _Towupper(_Ch, &_Ctype);
    }

    virtual const _Elem*  do_toupper(_Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First) {
            *_First = _Towupper(*_First, &_Ctype);
        }

        return _First;
    }

    _Elem  _Dowiden(char _Byte) const { 
        mbstate_t _Mbst = {};
        wchar_t _Wc;
        return _Mbrtowc(&_Wc, &_Byte, 1, &_Mbst, &_Cvt) < 0 ? static_cast<wchar_t>(((wint_t)(0xFFFF)) ) : _Wc;
    }

    virtual _Elem  do_widen(char _Byte) const { 
        return _Dowiden(_Byte);
    }

    virtual const char*  do_widen(
        const char* _First, const char* _Last, _Elem* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Dowiden(*_First);
        }

        return _First;
    }

    char  _Donarrow(_Elem _Ch, char _Dflt) const { 
        char _Buf[5 ];
        mbstate_t _Mbst = {};
        return _Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1 ? _Dflt : _Buf[0];
    }

    virtual char  do_narrow(_Elem _Ch, char _Dflt) const { 
        return _Donarrow(_Ch, _Dflt);
    }

    virtual const _Elem*  do_narrow(const _Elem* _First, const _Elem* _Last, char _Dflt,
        char* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Donarrow(*_First, _Dflt);
        }

        return _First;
    }

private:
    _Locinfo::_Ctypevec _Ctype; 
    _Locinfo::_Cvtvec _Cvt; 
};


extern "C++" template <>
class __declspec(dllimport) ctype<unsigned short>
    : public ctype_base { 
public:
    using _Elem     = unsigned short;
    using char_type = _Elem;

    bool  is(mask _Maskval, _Elem _Ch) const { 
        return do_is(_Maskval, _Ch);
    }

    const _Elem*  is(const _Elem* _First, const _Elem* _Last,
        mask* _Dest) const { 
        return do_is(_First, _Last, _Dest);
    }

    const _Elem*  scan_is(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        return do_scan_is(_Maskval, _First, _Last);
    }

    const _Elem*  scan_not(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        return do_scan_not(_Maskval, _First, _Last);
    }

    _Elem  tolower(_Elem _Ch) const { 
        return do_tolower(_Ch);
    }

    const _Elem*  tolower(
        _Elem* _First, const _Elem* _Last) const { 
        return do_tolower(_First, _Last);
    }

    _Elem  toupper(_Elem _Ch) const { 
        return do_toupper(_Ch);
    }

    const _Elem*  toupper(
        _Elem* _First, const _Elem* _Last) const { 
        return do_toupper(_First, _Last);
    }

    _Elem  widen(char _Byte) const { 
        return do_widen(_Byte);
    }

    const char*  widen(const char* _First, const char* _Last,
        _Elem* _Dest) const { 
        return do_widen(_First, _Last, _Dest);
    }

    char  narrow(_Elem _Ch, char _Dflt = '\0') const { 
        return do_narrow(_Ch, _Dflt);
    }

    const _Elem*  narrow(const _Elem* _First, const _Elem* _Last, char _Dflt,
        char* _Dest) const { 
        return do_narrow(_First, _Last, _Dflt, _Dest);
    }

     static locale::id id;

    explicit  ctype(size_t _Refs = 0) : ctype_base(_Refs) {
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }

     ctype(const _Locinfo& _Lobj, size_t _Refs = 0) : ctype_base(_Refs) {
        _Init(_Lobj);
    }

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        if (_Ppf && !*_Ppf) {
            *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->_C_str()));
        }

        return 2 ;
    }

protected:
     ~ctype() noexcept override {
        if (_Ctype._Delfl) {
            :: free(const_cast<short*>(_Ctype._Table));
        }

        :: free(_Ctype._LocaleName);
    }

    void  _Init(const _Locinfo& _Lobj) { 
        _Ctype = _Lobj._Getctype();
        _Cvt   = _Lobj._Getcvt();
    }

    virtual bool  do_is(
        mask _Maskval, _Elem _Ch) const { 
        return (:: _Getwctype(_Ch, &_Ctype) & _Maskval) != 0;
    }

    virtual const _Elem*  do_is(const _Elem* _First, const _Elem* _Last,
        mask* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        return reinterpret_cast<const _Elem*>(:: _Getwctypes(
            reinterpret_cast<const wchar_t*>(_First), reinterpret_cast<const wchar_t*>(_Last), _Dest, &_Ctype));
    }

    virtual const _Elem*  do_scan_is(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && !is(_Maskval, *_First)) {
            ++_First;
        }

        return _First;
    }

    virtual const _Elem*  do_scan_not(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && is(_Maskval, *_First)) {
            ++_First;
        }

        return _First;
    }

    virtual _Elem  do_tolower(_Elem _Ch) const { 
        return _Towlower(_Ch, &_Ctype);
    }

    virtual const _Elem*  do_tolower(_Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First) {
            *_First = _Towlower(*_First, &_Ctype);
        }

        return _First;
    }

    virtual _Elem  do_toupper(_Elem _Ch) const { 
        return _Towupper(_Ch, &_Ctype);
    }

    virtual const _Elem*  do_toupper(_Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First) {
            *_First = _Towupper(*_First, &_Ctype);
        }

        return _First;
    }

    _Elem  _Dowiden(char _Byte) const { 
        mbstate_t _Mbst = {};
        unsigned short _Wc;

        if (_Mbrtowc(reinterpret_cast<wchar_t*>(&_Wc), &_Byte, 1, &_Mbst, &_Cvt) < 0) {
            return static_cast<unsigned short>(((wint_t)(0xFFFF)) );
        }

        return _Wc;
    }

    virtual _Elem  do_widen(char _Byte) const { 
        return _Dowiden(_Byte);
    }

    virtual const char*  do_widen(
        const char* _First, const char* _Last, _Elem* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Dowiden(*_First);
        }

        return _First;
    }

    char  _Donarrow(_Elem _Ch, char _Dflt) const { 
        char _Buf[5 ];
        mbstate_t _Mbst = {};
        return _Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1 ? _Dflt : _Buf[0];
    }

    virtual char  do_narrow(_Elem _Ch, char _Dflt) const { 
        return _Donarrow(_Ch, _Dflt);
    }

    virtual const _Elem*  do_narrow(const _Elem* _First, const _Elem* _Last, char _Dflt,
        char* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Donarrow(*_First, _Dflt);
        }

        return _First;
    }

private:
    _Locinfo::_Ctypevec _Ctype; 
    _Locinfo::_Cvtvec _Cvt; 
};
#line 3215 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xlocale"

 template <class _Elem>
class ctype_byname : public ctype<_Elem> { 
public:
    static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t>, "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. " "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 " "to suppress this error." );

    explicit  ctype_byname(const char* _Locname, size_t _Refs = 0)
        : ctype<_Elem>(_Locinfo(_Locname), _Refs) {} 

    explicit  ctype_byname(const string& _Str, size_t _Refs = 0)
        : ctype<_Elem>(_Locinfo(_Str.c_str()), _Refs) {} 

protected:
     ~ctype_byname() noexcept override {}
};

enum class _Case_sensitive : bool { _Nope, _Yes };

template <class _InIt, class _Elem>
int __cdecl _Getloctxt(
    _InIt& _First, _InIt& _Last, size_t _Numfields, const _Elem* _Ptr, const _Case_sensitive _Matching) {
    
    for (size_t _Off = 0; _Ptr[_Off] != _Elem{}; ++_Off) {
        if (_Ptr[_Off] == _Ptr[0]) {
            ++_Numfields; 
        }
    }

    string _Str(_Numfields, '\0'); 
    const ctype<_Elem>& _CType = ::std:: use_facet<ctype<_Elem>>(locale{});

    int _Ans = -2; 
    for (size_t _Column = 1;; ++_Column, (void) ++_First, _Ans = -1) { 
        bool _Prefix  = false; 
        size_t _Off   = 0; 
        size_t _Field = 0; 

        for (; _Field < _Numfields; ++_Field) { 
            while (_Ptr[_Off] != _Elem{} && _Ptr[_Off] != _Ptr[0]) { 
                ++_Off;
            }

            if (_Str[_Field] != '\0') {
                _Off += _Str[_Field]; 
            } else if (_Ptr[_Off += _Column] == _Ptr[0]
                       || _Ptr[_Off] == _Elem{}) { 
                _Str[_Field] = static_cast<char>(_Column < 127 ? _Column : 127); 
                _Ans         = static_cast<int>(_Field); 
            } else if (_First == _Last
                       || (_Matching == _Case_sensitive::_Yes
                               ? _Ptr[_Off] != *_First
                               : _CType.tolower(_Ptr[_Off]) != _CType.tolower(static_cast<_Elem>(*_First)))) {
                _Str[_Field] = static_cast<char>(_Column < 127 ? _Column : 127); 
            } else {
                _Prefix = true; 
            }
        }

        if (!_Prefix || _First == _Last) {
            break; 
        }
    }
    return _Ans; 
}



template class __declspec(dllimport) codecvt<char, char, mbstate_t>;
#line 3284 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xlocale"
#line 3285 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xlocale"
}


#pragma warning(pop)
#pragma pack(pop)
#line 3291 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xlocale"
#line 3292 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xlocale"
#pragma external_header(pop)
#line 14 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xiosbase"

#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




namespace std {
template <class _Dummy>
class _Iosb { 
public:
    enum _Dummy_enum { _Dummy_enum_val = 1 }; 
    enum _Fmtflags { 
        _Fmtmask = 0xffff,
        _Fmtzero = 0
    };

    static constexpr _Fmtflags skipws     = static_cast<_Fmtflags>(0x0001);
    static constexpr _Fmtflags unitbuf    = static_cast<_Fmtflags>(0x0002);
    static constexpr _Fmtflags uppercase  = static_cast<_Fmtflags>(0x0004);
    static constexpr _Fmtflags showbase   = static_cast<_Fmtflags>(0x0008);
    static constexpr _Fmtflags showpoint  = static_cast<_Fmtflags>(0x0010);
    static constexpr _Fmtflags showpos    = static_cast<_Fmtflags>(0x0020);
    static constexpr _Fmtflags left       = static_cast<_Fmtflags>(0x0040);
    static constexpr _Fmtflags right      = static_cast<_Fmtflags>(0x0080);
    static constexpr _Fmtflags internal   = static_cast<_Fmtflags>(0x0100);
    static constexpr _Fmtflags dec        = static_cast<_Fmtflags>(0x0200);
    static constexpr _Fmtflags oct        = static_cast<_Fmtflags>(0x0400);
    static constexpr _Fmtflags hex        = static_cast<_Fmtflags>(0x0800);
    static constexpr _Fmtflags scientific = static_cast<_Fmtflags>(0x1000);
    static constexpr _Fmtflags fixed      = static_cast<_Fmtflags>(0x2000);

    static constexpr _Fmtflags hexfloat = static_cast<_Fmtflags>(0x3000); 

    static constexpr _Fmtflags boolalpha   = static_cast<_Fmtflags>(0x4000);
    static constexpr _Fmtflags _Stdio      = static_cast<_Fmtflags>(0x8000);
    static constexpr _Fmtflags adjustfield = static_cast<_Fmtflags>(0x01C0); 
    static constexpr _Fmtflags basefield   = static_cast<_Fmtflags>(0x0E00); 
    static constexpr _Fmtflags floatfield  = static_cast<_Fmtflags>(0x3000); 

    enum _Iostate { 
        _Statmask = 0x17
    };

    static constexpr _Iostate goodbit = static_cast<_Iostate>(0x0);
    static constexpr _Iostate eofbit  = static_cast<_Iostate>(0x1);
    static constexpr _Iostate failbit = static_cast<_Iostate>(0x2);
    static constexpr _Iostate badbit  = static_cast<_Iostate>(0x4);

    enum _Openmode { 
        _Openmask = 0xff
    };

    static constexpr _Openmode in         = static_cast<_Openmode>(0x01);
    static constexpr _Openmode out        = static_cast<_Openmode>(0x02);
    static constexpr _Openmode ate        = static_cast<_Openmode>(0x04);
    static constexpr _Openmode app        = static_cast<_Openmode>(0x08);
    static constexpr _Openmode trunc      = static_cast<_Openmode>(0x10);
    static constexpr _Openmode _Nocreate  = static_cast<_Openmode>(0x40);
    static constexpr _Openmode _Noreplace = static_cast<_Openmode>(0x80);
    static constexpr _Openmode binary     = static_cast<_Openmode>(0x20);


#line 79 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xiosbase"

    enum _Seekdir { 
        _Seekbeg,
        _Seekcur,
        _Seekend
    };

    static constexpr _Seekdir beg = _Seekbeg;
    static constexpr _Seekdir cur = _Seekcur;
    static constexpr _Seekdir end = _Seekend;

    enum { 
        _Openprot = 0x40
    };

    static constexpr int _Default_open_prot = 0x40 ; 
};

 extern "C++" class __declspec(dllimport) ios_base : public _Iosb<int> { 
public:
    using fmtflags = int;
    using iostate  = int;
    using openmode = int;
    using seekdir  = int;




#line 108 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xiosbase"

    enum event { 
        erase_event,
        imbue_event,
        copyfmt_event
    };

    using event_callback = void(__cdecl *)(event, ios_base&, int);





#line 122 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xiosbase"

    class failure : public system_error { 
    public:
        explicit failure(const string& _Message, const error_code& _Errcode = ::std:: make_error_code(io_errc::stream))
            : system_error(_Errcode, _Message) {} 

        explicit failure(const char* _Message, const error_code& _Errcode = ::std:: make_error_code(io_errc::stream))
            : system_error(_Errcode, _Message) {} 






#line 137 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xiosbase"
    };

    class __declspec(dllimport) Init { 
    public:
         Init() { 
            _Init_ctor(this);
        }

         ~Init() noexcept { 
            _Init_dtor(this);
        }

    private:
        static void __cdecl _Init_ctor(Init*);
        static void __cdecl _Init_dtor(Init*);

         static int _Init_cnt; 

        static int& __cdecl _Init_cnt_func();
    };

    explicit  operator bool() const noexcept   {
        return !fail();
    }

    [[nodiscard]] bool  operator!() const noexcept   {
        return fail();
    }

    void  clear(iostate _State, bool _Reraise) { 
        _State &= _Statmask;
        _Mystate             = _State;
        const auto _Filtered = _State & _Except;
        if (_Filtered) {
            if (_Reraise) {
                throw ;
            }

            const char* _Msg;
            if (_Filtered & ios_base::badbit) {
                _Msg = "ios_base::badbit set";
            } else if (_Filtered & ios_base::failbit) {
                _Msg = "ios_base::failbit set";
            } else {
                _Msg = "ios_base::eofbit set";
            }

            throw failure(_Msg) ;
        }
    }

    void  clear(iostate _State = goodbit) { 
        clear(_State, false);
    }





#line 197 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xiosbase"

    [[nodiscard]] iostate  rdstate() const noexcept   {
        return _Mystate;
    }

    void  setstate(
        iostate _State, bool _Exreraise) { 
        clear(rdstate() | _State, _Exreraise);
    }

    void  setstate(iostate _State) { 
        clear(rdstate() | _State, false);
    }





#line 216 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xiosbase"

    [[nodiscard]] bool  good() const noexcept   {
        return rdstate() == ios_base::goodbit;
    }

    [[nodiscard]] bool  eof() const noexcept   {
        return rdstate() & ios_base::eofbit;
    }

    [[nodiscard]] bool  fail() const noexcept   {
        return rdstate() & (ios_base::badbit | ios_base::failbit);
    }

    [[nodiscard]] bool  bad() const noexcept   {
        return rdstate() & ios_base::badbit;
    }

    [[nodiscard]] iostate  exceptions() const noexcept   {
        return _Except;
    }

    void  exceptions(iostate _Newexcept) { 
        _Except = _Newexcept & _Statmask;
        clear(rdstate());
    }





#line 247 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xiosbase"

    [[nodiscard]] fmtflags  flags() const noexcept   {
        return _Fmtfl;
    }

    fmtflags  flags(fmtflags _Newfmtflags) noexcept   {
        
        const fmtflags _Oldfmtflags = _Fmtfl;
        _Fmtfl                      = _Newfmtflags & _Fmtmask;
        return _Oldfmtflags;
    }

    fmtflags  setf(fmtflags _Newfmtflags) noexcept   {
        
        const ios_base::fmtflags _Oldfmtflags = _Fmtfl;
        _Fmtfl |= _Newfmtflags & _Fmtmask;
        return _Oldfmtflags;
    }

    fmtflags  setf(fmtflags _Newfmtflags, fmtflags _Mask) noexcept   {
        
        const ios_base::fmtflags _Oldfmtflags = _Fmtfl;
        _Fmtfl                                = (_Oldfmtflags & ~_Mask) | (_Newfmtflags & _Mask & _Fmtmask);
        return _Oldfmtflags;
    }

    void  unsetf(fmtflags _Mask) noexcept   {
        
        _Fmtfl &= ~_Mask;
    }

    [[nodiscard]] streamsize  precision() const noexcept   {
        return _Prec;
    }

    streamsize  precision(streamsize _Newprecision) noexcept   {
        
        const streamsize _Oldprecision = _Prec;
        _Prec                          = _Newprecision;
        return _Oldprecision;
    }

    [[nodiscard]] streamsize  width() const noexcept   {
        return _Wide;
    }

    streamsize  width(streamsize _Newwidth) noexcept   {
        
        const streamsize _Oldwidth = _Wide;
        _Wide                      = _Newwidth;
        return _Oldwidth;
    }

    [[nodiscard]] locale  getloc() const noexcept   { 
        return *_Ploc;
    }

    locale  imbue(const locale& _Loc) { 
        locale _Oldlocale = *_Ploc;
        *_Ploc            = _Loc;
        _Callfns(imbue_event);
        return _Oldlocale;
    }

    [[nodiscard]] static int __cdecl xalloc() { 
        { ::std:: _Lockit _Lock(2); 
        return _Index++;
        }
    }

    [[nodiscard]] long&  iword(int _Idx) {
        return _Findarr(_Idx)._Lo;
    }

    [[nodiscard]] void*&  pword(int _Idx) {
        return _Findarr(_Idx)._Vp;
    }

    void  register_callback(event_callback _Pfn, int _Idx) {
        
        _Calls = new _Fnarray(_Idx, _Pfn, _Calls);
    }

    ios_base&  copyfmt(const ios_base& _Other) { 
        if (this != ::std:: addressof(_Other)) { 
            _Tidy();
            *_Ploc          = *_Other._Ploc;
            _Fmtfl          = _Other._Fmtfl;
            _Prec           = _Other._Prec;
            _Wide           = _Other._Wide;
            _Iosarray* _Ptr = _Other._Arr;

            for (_Arr = nullptr; _Ptr; _Ptr = _Ptr->_Next) {
                if (_Ptr->_Lo != 0 || _Ptr->_Vp) { 
                    iword(_Ptr->_Index) = _Ptr->_Lo;
                    pword(_Ptr->_Index) = _Ptr->_Vp;
                }
            }

            for (_Fnarray* _Pfa = _Other._Calls; _Pfa; _Pfa = _Pfa->_Next) {
                register_callback(_Pfa->_Pfn, _Pfa->_Index);
            }

            _Callfns(copyfmt_event); 
            exceptions(_Other._Except); 
        }
        return *this;
    }

    static bool __cdecl sync_with_stdio(bool _Newsync = true) {
        
        { ::std:: _Lockit _Lock(2); 
        const bool _Oldsync = _Sync;
        _Sync               = _Newsync;
        return _Oldsync;
        }
    }

    void  swap(ios_base& _Right) noexcept   {
        if (this != ::std:: addressof(_Right)) {
            ::std:: swap(_Mystate, _Right._Mystate);
            ::std:: swap(_Except, _Right._Except);
            ::std:: swap(_Fmtfl, _Right._Fmtfl);
            ::std:: swap(_Prec, _Right._Prec);
            ::std:: swap(_Wide, _Right._Wide);

            ::std:: swap(_Arr, _Right._Arr);
            ::std:: swap(_Calls, _Right._Calls);
            ::std:: swap(_Ploc, _Right._Ploc);
        }
    }

    virtual  ~ios_base() noexcept {
        _Ios_base_dtor(this);
    }

    static void __cdecl _Addstd(ios_base*); 

    size_t _Stdstr{0}; 

protected:
     ios_base() {}

    void  _Init() { 
        _Ploc   = nullptr;
        _Stdstr = 0;
        _Except = goodbit;
        _Fmtfl  = skipws | dec;
        _Prec   = 6;
        _Wide   = 0;
        _Arr    = nullptr;
        _Calls  = nullptr;
        clear(goodbit);
        _Ploc = new locale;
    }

private:
    struct _Iosarray : _Crt_new_delete { 
    public:
         _Iosarray(int _Idx, _Iosarray* _Link)
            : _Next(_Link), _Index(_Idx), _Lo(0), _Vp(nullptr) {} 

        _Iosarray* _Next; 
        int _Index; 
        long _Lo; 
        void* _Vp; 
    };

    struct _Fnarray : _Crt_new_delete { 
         _Fnarray(int _Idx, event_callback _Pnew, _Fnarray* _Link)
            : _Next(_Link), _Index(_Idx), _Pfn(_Pnew) {} 

        _Fnarray* _Next; 
        int _Index; 
        event_callback _Pfn; 
    };

    void  _Callfns(event _Ev) { 
        for (_Fnarray* _Pfa = _Calls; _Pfa; _Pfa = _Pfa->_Next) {
            (*_Pfa->_Pfn)(_Ev, *this, _Pfa->_Index);
        }
    }

    _Iosarray&  _Findarr(int _Idx) { 
        _Iosarray* _Ptr1;
        _Iosarray* _Ptr2;

        for (_Ptr1 = _Arr, _Ptr2 = nullptr; _Ptr1; _Ptr1 = _Ptr1->_Next) {
            if (_Ptr1->_Index == _Idx) {
                return *_Ptr1; 
            } else if (!_Ptr2 && _Ptr1->_Lo == 0 && !_Ptr1->_Vp) {
                _Ptr2 = _Ptr1; 
            }
        }

        if (_Ptr2) { 
            _Ptr2->_Index = _Idx;
            return *_Ptr2;
        }

        _Arr = new _Iosarray(_Idx, _Arr); 
        return *_Arr;
    }

    void  _Tidy() noexcept { 
        _Callfns(erase_event);
        _Iosarray* _Ptr1;
        _Iosarray* _Ptr2;

        for (_Ptr1 = _Arr; _Ptr1; _Ptr1 = _Ptr2) { 
            _Ptr2 = _Ptr1->_Next;
            delete _Ptr1;
        }
        _Arr = nullptr;

        _Fnarray* _Pfa1;
        _Fnarray* _Pfa2;
        for (_Pfa1 = _Calls; _Pfa1; _Pfa1 = _Pfa2) { 
            _Pfa2 = _Pfa1->_Next;
            delete _Pfa1;
        }
        _Calls = nullptr;
    }

    iostate _Mystate; 
    iostate _Except; 
    fmtflags _Fmtfl; 
    streamsize _Prec; 
    streamsize _Wide; 
    _Iosarray* _Arr{nullptr}; 
    _Fnarray* _Calls{nullptr}; 
    locale* _Ploc{nullptr}; 

     static int _Index;
     static bool _Sync;

    static void __cdecl _Ios_base_dtor(ios_base*);

public:
    ios_base(const ios_base&)            = delete;
    ios_base& operator=(const ios_base&) = delete;
};
}


#pragma warning(pop)
#pragma pack(pop)
#line 495 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xiosbase"
#line 496 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xiosbase"
#pragma external_header(pop)
#line 12 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\streambuf"

#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




namespace std {
 extern "C++" template <class _Elem, class _Traits>
class basic_streambuf { 
protected:
     basic_streambuf() : _Plocale(new locale) {
        _Init();
    }

     basic_streambuf(_Uninitialized) noexcept {}

     basic_streambuf(const basic_streambuf& _Right) : _Plocale(new locale{_Right.getloc()}) {
        _Init();
        setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
        setg(_Right.eback(), _Right.gptr(), _Right.egptr());
    }

    basic_streambuf&  operator=(const basic_streambuf& _Right) {
        if (this != ::std:: addressof(_Right)) {
            setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
            setg(_Right.eback(), _Right.gptr(), _Right.egptr());
            pubimbue(_Right.getloc());
        }
        return *this;
    }

    void  swap(basic_streambuf& _Right) noexcept   {
        if (this != ::std:: addressof(_Right)) {
            _Elem* _Pfirst0 = pbase();
            _Elem* _Pnext0  = pptr();
            _Elem* _Pend    = epptr();
            _Elem* _Gfirst0 = eback();
            _Elem* _Gnext0  = gptr();
            _Elem* _Gend    = egptr();

            setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
            _Right.setp(_Pfirst0, _Pnext0, _Pend);

            setg(_Right.eback(), _Right.gptr(), _Right.egptr());
            _Right.setg(_Gfirst0, _Gnext0, _Gend);

            ::std:: swap(_Plocale, _Right._Plocale);
        }
    }

public:
    using char_type   = _Elem;
    using traits_type = _Traits;

    virtual  ~basic_streambuf() noexcept {
        delete _Plocale;
    }

    using int_type = typename _Traits::int_type;
    using pos_type = typename _Traits::pos_type;
    using off_type = typename _Traits::off_type;

    pos_type  pubseekoff(off_type _Off, ios_base::seekdir _Way,
        ios_base::openmode _Mode = ios_base::in | ios_base::out) { 
        return seekoff(_Off, _Way, _Mode);
    }






#line 87 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\streambuf"

    pos_type  pubseekpos(pos_type _Pos,
        ios_base::openmode _Mode = ios_base::in | ios_base::out) { 
        return seekpos(_Pos, _Mode);
    }






#line 99 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\streambuf"

    basic_streambuf*  pubsetbuf(_Elem* _Buffer,
        streamsize _Count) { 
        return setbuf(_Buffer, _Count);
    }

    locale  pubimbue(const locale& _Newlocale) { 
        locale _Oldlocale = *_Plocale;
        imbue(_Newlocale);
        *_Plocale = _Newlocale;
        return _Oldlocale;
    }

    locale  getloc() const noexcept   { 
        return *_Plocale;
    }

    streamsize  in_avail() {
        streamsize _Res = _Gnavail();
        return 0 < _Res ? _Res : showmanyc();
    }

    int  pubsync() { 
        return sync();
    }

    int_type  sbumpc() { 
        return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();
    }

    int_type  sgetc() { 
        return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();
    }

    streamsize  sgetn(_Elem* _Ptr,
        streamsize _Count) { 
        return xsgetn(_Ptr, _Count);
    }

    int_type  snextc() { 
        return 1 < _Gnavail()                                 ? _Traits::to_int_type(*_Gnpreinc())
             : _Traits::eq_int_type(_Traits::eof(), sbumpc()) ? _Traits::eof()
                                                              : sgetc();
    }

    int_type  sputbackc(_Elem _Ch) { 
        if (gptr() && eback() < gptr() && _Traits::eq(_Ch, gptr()[-1])) {
            return _Traits::to_int_type(*_Gndec());
        }

        return pbackfail(_Traits::to_int_type(_Ch));
    }









#line 161 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\streambuf"

    int_type  sungetc() { 
        return gptr() && eback() < gptr() ? _Traits::to_int_type(*_Gndec()) : pbackfail();
    }

    int_type  sputc(_Elem _Ch) { 
        return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));
    }

    streamsize  sputn(const _Elem* _Ptr,
        streamsize _Count) { 
        return xsputn(_Ptr, _Count);
    }

    virtual void  _Lock() {} 

    virtual void  _Unlock() {} 

protected:
    _Elem*  eback() const noexcept   {
        return *_IGfirst;
    }

    _Elem*  gptr() const noexcept   {
        return *_IGnext;
    }

    _Elem*  pbase() const noexcept   {
        return *_IPfirst;
    }

    _Elem*  pptr() const noexcept   {
        return *_IPnext;
    }

    _Elem*  egptr() const noexcept   {
        return *_IGnext + *_IGcount;
    }

    void  gbump(int _Off) noexcept   {
        
        *_IGcount -= _Off;
        *_IGnext += _Off;
    }

    void  setg(_Elem* _First, _Elem* _Next, _Elem* _Last) noexcept   {
        
        *_IGfirst = _First;
        *_IGnext  = _Next;
        *_IGcount = static_cast<int>(_Last - _Next);
    }

    _Elem*  epptr() const noexcept   {
        return *_IPnext + *_IPcount;
    }

    _Elem*  _Gndec() noexcept { 
        ++*_IGcount;
        return --*_IGnext;
    }

    _Elem*  _Gninc() noexcept { 
        --*_IGcount;
        return (*_IGnext)++;
    }

    _Elem*  _Gnpreinc() noexcept { 
        --*_IGcount;
        return ++(*_IGnext);
    }

    streamsize  _Gnavail() const noexcept { 
        return *_IGnext ? *_IGcount : 0;
    }

    void  pbump(int _Off) noexcept   {
        
        *_IPcount -= _Off;
        *_IPnext += _Off;
    }

    void  setp(_Elem* _First, _Elem* _Last) noexcept   {
        
        *_IPfirst = _First;
        *_IPnext  = _First;
        *_IPcount = static_cast<int>(_Last - _First);
    }

    void  setp(_Elem* _First, _Elem* _Next, _Elem* _Last) noexcept   {
        
        *_IPfirst = _First;
        *_IPnext  = _Next;
        *_IPcount = static_cast<int>(_Last - _Next);
    }

    _Elem*  _Pninc() noexcept { 
        --*_IPcount;
        return (*_IPnext)++;
    }

    streamsize  _Pnavail() const noexcept { 
        return *_IPnext ? *_IPcount : 0;
    }

    void  _Init() noexcept { 
        _IGfirst = &_Gfirst;
        _IPfirst = &_Pfirst;
        _IGnext  = &_Gnext;
        _IPnext  = &_Pnext;
        _IGcount = &_Gcount;
        _IPcount = &_Pcount;
        setp(nullptr, nullptr);
        setg(nullptr, nullptr, nullptr);
    }

    void  _Init(_Elem** _Gf, _Elem** _Gn, int* _Gc, _Elem** _Pf, _Elem** _Pn, int* _Pc) noexcept {
        
        _IGfirst = _Gf;
        _IPfirst = _Pf;
        _IGnext  = _Gn;
        _IPnext  = _Pn;
        _IGcount = _Gc;
        _IPcount = _Pc;
    }

    virtual int_type  overflow(int_type = _Traits::eof()) { 
        return _Traits::eof();
    }

    virtual int_type  pbackfail(int_type = _Traits::eof()) {
        
        return _Traits::eof();
    }

    virtual streamsize  showmanyc() {
        return 0;
    }

    virtual int_type  underflow() { 
        return _Traits::eof();
    }

    virtual int_type  uflow() { 
        return _Traits::eq_int_type(_Traits::eof(), underflow()) ? _Traits::eof() : _Traits::to_int_type(*_Gninc());
    }

    virtual streamsize  xsgetn(_Elem* _Ptr, streamsize _Count) { 
        const streamsize _Start_count = _Count;

        while (0 < _Count) {
            streamsize _Size = _Gnavail();
            if (0 < _Size) { 
                if (_Count < _Size) {
                    _Size = _Count;
                }

                _Traits::copy(_Ptr, gptr(), static_cast<size_t>(_Size));
                _Ptr += _Size;
                _Count -= _Size;
                gbump(static_cast<int>(_Size));
            } else {
                const int_type _Meta = uflow();
                if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {
                    break; 
                }

                
                *_Ptr++ = _Traits::to_char_type(_Meta);
                --_Count;
            }
        }

        return _Start_count - _Count;
    }

    virtual streamsize  xsputn(const _Elem* _Ptr, streamsize _Count) {
        
        const streamsize _Start_count = _Count;
        while (0 < _Count) {
            streamsize _Size = _Pnavail();
            if (0 < _Size) { 
                if (_Count < _Size) {
                    _Size = _Count;
                }

                _Traits::copy(pptr(), _Ptr, static_cast<size_t>(_Size));
                _Ptr += _Size;
                _Count -= _Size;
                pbump(static_cast<int>(_Size));
            } else if (_Traits::eq_int_type(_Traits::eof(), overflow(_Traits::to_int_type(*_Ptr)))) {
                break; 
            } else { 
                ++_Ptr;
                --_Count;
            }
        }

        return _Start_count - _Count;
    }

    virtual pos_type  seekoff(
        off_type, ios_base::seekdir, ios_base::openmode = ios_base::in | ios_base::out) {
        
        return pos_type{off_type{-1}};
    }

    virtual pos_type  seekpos(pos_type, ios_base::openmode = ios_base::in | ios_base::out) {
        
        return pos_type{off_type{-1}};
    }

    virtual basic_streambuf*  setbuf(_Elem*, streamsize) {
        
        return this;
    }

    virtual int  sync() { 
        return 0;
    }

    virtual void  imbue(const locale&) {} 

private:
    _Elem* _Gfirst; 
    _Elem* _Pfirst; 
    _Elem** _IGfirst; 
    _Elem** _IPfirst; 
    _Elem* _Gnext; 
    _Elem* _Pnext; 
    _Elem** _IGnext; 
    _Elem** _IPnext; 

    int _Gcount; 
    int _Pcount; 
    int* _IGcount; 
    int* _IPcount; 

protected:
    locale* _Plocale; 
};




template class __declspec(dllimport) basic_streambuf<char, char_traits<char>>;
template class __declspec(dllimport) basic_streambuf<wchar_t, char_traits<wchar_t>>;
#line 408 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\streambuf"




#line 413 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\streambuf"
}



#pragma warning(pop)
#pragma pack(pop)
#line 420 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\streambuf"
#line 421 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\streambuf"
#pragma external_header(pop)
#line 17 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xlocnum"

#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




extern "C" {

 long __cdecl _Stolx(const char*,   char**, int, int*);
 unsigned long __cdecl _Stoulx(
    const char*,   char**, int, int*);
 long long __cdecl _Stollx(
    const char*,   char**, int, int*);
 unsigned long long __cdecl _Stoullx(
    const char*,   char**, int, int*);

}

namespace std {

inline double _Stodx_v2(const char* _Str, char** _Endptr, int _Pten, int* _Perr) { 
    int& _Errno_ref = (*_errno()) ; 
    const int _Orig = _Errno_ref;

    _Errno_ref  = 0;
    double _Val = :: strtod(_Str, _Endptr);
    *_Perr      = _Errno_ref;
    _Errno_ref  = _Orig;

    if (_Pten != 0) {
        _Val *= :: pow(10.0, static_cast<double>(_Pten));
    }

    return _Val;
}

inline float _Stofx_v2(const char* _Str, char** _Endptr, int _Pten, int* _Perr) { 
    int& _Errno_ref = (*_errno()) ; 
    const int _Orig = _Errno_ref;

    _Errno_ref = 0;
    float _Val = :: strtof(_Str, _Endptr);
    *_Perr     = _Errno_ref;
    _Errno_ref = _Orig;

    if (_Pten != 0) {
        _Val *= :: powf(10.0f, static_cast<float>(_Pten));
    }

    return _Val;
}

template <class _Elem, size_t _Base_size>
size_t _Find_elem(const _Elem (&_Base)[_Base_size], const _Elem _Ch) {
    
    
    return static_cast<size_t>(::std:: _Find_unchecked(_Base, _Base + (_Base_size - 1), _Ch) - _Base);
}

inline wchar_t* _Maklocwcs(const wchar_t* _Ptr) { 
    const size_t _Count = :: wcslen(_Ptr) + 1;

    wchar_t* _Ptrdest = static_cast<wchar_t*>(calloc(_Count, sizeof(wchar_t)) );

    if (!_Ptrdest) {
        _Xbad_alloc();
    }

    :: wmemcpy(_Ptrdest, _Ptr, _Count);
    return _Ptrdest;
}

 template <class _Elem>
class numpunct : public locale::facet { 
private:
    friend _Tidy_guard<numpunct>;

public:
    static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t>, "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. " "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 " "to suppress this error." );

    using string_type = basic_string<_Elem, char_traits<_Elem>, allocator<_Elem>>;
    using char_type   = _Elem;

     __declspec(dllimport) static locale::id id; 

    _Elem decimal_point() const {
        return do_decimal_point();
    }

    _Elem thousands_sep() const {
        return do_thousands_sep();
    }

    string grouping() const {
        return do_grouping();
    }

    string_type falsename() const {
        return do_falsename();
    }

    string_type truename() const {
        return do_truename();
    }

    explicit numpunct(size_t _Refs = 0) : locale::facet(_Refs) { 
        { _Locinfo _Lobj;
        _Init(_Lobj);
        if (_Kseparator == 0) {
            _Kseparator = 
                _Maklocchr(',', static_cast<_Elem*>(nullptr), _Lobj._Getcvt());
        }
        }
    }

    numpunct(const _Locinfo& _Lobj, size_t _Refs = 0, bool _Isdef = false) : locale::facet(_Refs) {
        _Init(_Lobj, _Isdef);
    }

    static size_t _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        
        if (_Ppf && !*_Ppf) {
            *_Ppf = new numpunct<_Elem>(_Locinfo(_Ploc->_C_str()), 0, true);
        }
        return 4 ;
    }

protected:
     ~numpunct() noexcept override {
        _Tidy();
    }

    numpunct(const char* _Locname, size_t _Refs = 0, bool _Isdef = false) : locale::facet(_Refs) {
        { _Locinfo _Lobj(_Locname);
        _Init(_Lobj, _Isdef);
        }
    }

    template <class _Elem2>
    void _Getvals(_Elem2, const lconv* _Ptr, _Locinfo::_Cvtvec _Cvt) { 
        _Dp         = _Maklocchr(_Ptr->decimal_point[0], static_cast<_Elem2*>(nullptr), _Cvt);
        _Kseparator = _Maklocchr(_Ptr->thousands_sep[0], static_cast<_Elem2*>(nullptr), _Cvt);
    }

    void _Getvals(wchar_t, const lconv* _Ptr, _Locinfo::_Cvtvec) { 
        _Dp         = static_cast<_Elem>(_Ptr->_W_decimal_point[0]);
        _Kseparator = static_cast<_Elem>(_Ptr->_W_thousands_sep[0]);
    }

    void _Init(const _Locinfo& _Lobj, bool _Isdef = false) { 
        const lconv* _Ptr      = _Lobj._Getlconv();
        _Locinfo::_Cvtvec _Cvt = _Lobj._Getcvt(); 

        _Grouping  = nullptr;
        _Falsename = nullptr;
        _Truename  = nullptr;

        _Tidy_guard<numpunct> _Guard{this};
        _Grouping      = _Maklocstr(_Isdef ? "" : _Ptr->grouping, static_cast<char*>(nullptr), _Lobj._Getcvt());
        _Falsename     = _Maklocstr(_Lobj._Getfalse(), static_cast<_Elem*>(nullptr), _Cvt);
        _Truename      = _Maklocstr(_Lobj._Gettrue(), static_cast<_Elem*>(nullptr), _Cvt);
        _Guard._Target = nullptr;

        if (_Isdef) { 
            
            _Dp         = _Maklocchr('.', static_cast<_Elem*>(nullptr), _Cvt);
            _Kseparator = _Maklocchr(',', static_cast<_Elem*>(nullptr), _Cvt);
        } else {
            _Getvals(_Elem{}, _Ptr, _Cvt);
        }
    }

    virtual _Elem  do_decimal_point() const {
        return _Dp;
    }

    virtual _Elem  do_thousands_sep() const {
        return _Kseparator;
    }

    virtual string  do_grouping() const {
        return string{_Grouping};
    }

    virtual string_type  do_falsename() const {
        return string_type{_Falsename};
    }

    virtual string_type  do_truename() const {
        return string_type{_Truename};
    }

private:
    void _Tidy() noexcept { 
        :: free(const_cast<char*>(_Grouping));
        :: free(const_cast<_Elem*>(_Falsename));
        :: free(const_cast<_Elem*>(_Truename));
    }

    const char* _Grouping; 
    _Elem _Dp; 
    _Elem _Kseparator; 
    const _Elem* _Falsename; 
    const _Elem* _Truename; 
};

 template <class _Elem>
class numpunct_byname : public numpunct<_Elem> { 
public:
    static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t>, "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. " "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 " "to suppress this error." );

    explicit numpunct_byname(const char* _Locname, size_t _Refs = 0)
        : numpunct<_Elem>(_Locname, _Refs) {} 

    explicit numpunct_byname(const string& _Str, size_t _Refs = 0)
        : numpunct<_Elem>(_Str.c_str(), _Refs) {} 

protected:
     ~numpunct_byname() noexcept override {}
};







template <class _Elem>
 locale::id numpunct<_Elem>::id;




#line 253 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xlocnum"

 extern "C++" template <class _Elem, class _InIt = istreambuf_iterator<_Elem, char_traits<_Elem>>>
class num_get : public locale::facet { 
public:
    static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t>, "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. " "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 " "to suppress this error." );

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        
        if (_Ppf && !*_Ppf) {
            *_Ppf = new num_get<_Elem, _InIt>(_Locinfo(_Ploc->_C_str()));
        }

        return 4 ;
    }

     static locale::id id; 

protected:
     ~num_get() noexcept override {}

    void _Init(const _Locinfo&) {} 

public:
    explicit  num_get(size_t _Refs = 0) : locale::facet(_Refs) { 
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }

     num_get(const _Locinfo& _Lobj, size_t _Refs = 0) : locale::facet(_Refs) {
        _Init(_Lobj);
    }

    using char_type = _Elem;
    using iter_type = _InIt;

    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        bool& _Val) const { 
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned short& _Val) const { 
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned int& _Val) const { 
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        long& _Val) const { 
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned long& _Val) const { 
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        long long& _Val) const { 
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned long long& _Val) const { 
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        float& _Val) const { 
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        double& _Val) const { 
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        long double& _Val) const { 
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        void*& _Val) const { 
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

protected:
    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        bool& _Val) const { 
        _Adl_verify_range(_First, _Last);
        if (_Iosbase.flags() & ios_base::boolalpha) { 
            const auto& _Punct_fac = ::std:: use_facet<numpunct<_Elem>>(_Iosbase.getloc());
            basic_string<_Elem> _Str(static_cast<size_t>(1), _Elem{});
            _Str += _Punct_fac.falsename();
            _Str.push_back(_Elem{});
            _Str += _Punct_fac.truename(); 
            switch (_Getloctxt(_First, _Last, 2, _Str.c_str(), _Case_sensitive::_Yes)) {
            case 0:
                _Val = false;
                break;
            case 1:
                _Val = true;
                break;
            default:
                _Val   = false;
                _State = ios_base::failbit;
                break;
            }
        } else { 
            char _Ac[32 ];
            const int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); 
            if (_Ac[0] == '\0') { 
                                  
                                  
                                  
                                  
                                  
                _Val   = false;
                _State = ios_base::failbit;
            } else {
                char* _Ep;
                int _Errno;
                const long _Ans = :: _Stolx(_Ac, &_Ep, _Base, &_Errno); 
                if (_Ep == _Ac || _Errno != 0) {
                    _Val   = true;
                    _State = ios_base::failbit;
                } else {
                    _Val = _Ans != 0;
                    if (_Ans != 0 && _Ans != 1) {
                        _State = ios_base::failbit;
                    }
                }
            }
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }

    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned short& _Val) const { 
        _Adl_verify_range(_First, _Last);
        char _Ac[32 ];
        const int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); 
        if (_Ac[0] == '\0') { 
            _State = ios_base::failbit;
            _Val   = 0;
        } else {
            const bool _Minus   = _Ac[0] == '-';
            const char* _Digits = _Ac;
            
            
            if (_Minus) { 
                ++_Digits;
            }

            char* _Ep;
            int _Errno;
            const unsigned long _Tmp = :: _Stoulx(_Digits, &_Ep, _Base, &_Errno); 
            _Val                     = static_cast<unsigned short>(_Tmp);
            if (_Ep == _Digits || _Errno != 0 || _Tmp > 0xffff ) {
                _State = ios_base::failbit;
                _Val   = 0xffff ;
            } else if (_Minus) { 
                                 
                _Val = static_cast<unsigned short>(0 - _Val);
            }
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }

    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned int& _Val) const { 
        static_assert(sizeof(unsigned int) == sizeof(unsigned long),
            "Bad overflow assumptions due to sizeof(unsigned int) != sizeof(unsigned long)");
        unsigned long _Tmp;
        _First = num_get::do_get(_First, _Last, _Iosbase, _State, _Tmp); 
        _Val   = _Tmp;
        return _First;
    }

    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        long& _Val) const { 
        _Adl_verify_range(_First, _Last);
        char _Ac[32 ];
        const int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); 
        if (_Ac[0] == '\0') { 
            _State = ios_base::failbit;
            _Val   = 0;
        } else {
            char* _Ep;
            int _Errno;
            _Val = :: _Stolx(_Ac, &_Ep, _Base, &_Errno); 
            if (_Ep == _Ac || _Errno != 0) {
                _State = ios_base::failbit;
            }
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }

    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned long& _Val) const { 
        _Adl_verify_range(_First, _Last);
        char _Ac[32 ];
        const int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); 
        if (_Ac[0] == '\0') { 
            _State = ios_base::failbit;
            _Val   = 0;
        } else {
            char* _Ep;
            int _Errno;
            _Val = :: _Stoulx(_Ac, &_Ep, _Base, &_Errno); 
            if (_Ep == _Ac || _Errno != 0) {
                _State = ios_base::failbit;
            }
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }

    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        long long& _Val) const { 
        _Adl_verify_range(_First, _Last);
        char _Ac[32 ];
        const int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc());
        if (_Ac[0] == '\0') { 
            _State = ios_base::failbit;
            _Val   = 0;
        } else {
            char* _Ep;
            int _Errno;
            _Val = :: _Stollx(_Ac, &_Ep, _Base, &_Errno); 
            if (_Ep == _Ac || _Errno != 0) {
                _State = ios_base::failbit;
            }
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }

    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned long long& _Val) const { 
        _Adl_verify_range(_First, _Last);
        char _Ac[32 ];
        const int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc());
        if (_Ac[0] == '\0') { 
            _State = ios_base::failbit;
            _Val   = 0;
        } else {
            int _Errno;
            char* _Ep;
            _Val = :: _Stoullx(_Ac, &_Ep, _Base, &_Errno); 
            if (_Ep == _Ac || _Errno != 0) {
                _State = ios_base::failbit;
            }
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }








    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        float& _Val) const { 
        _Adl_verify_range(_First, _Last);
        char _Ac[(8 + 768 + 16) ];
        int _Hexexp     = 1000000000 ;
        const int _Base = _Getffld(_Ac, _First, _Last, _Iosbase, &_Hexexp); 
        if (_Ac[0] == '\0') { 
            _State = ios_base::failbit;
            _Val   = 0.0f;
        } else {
            int _Errno;
            char* _Ep;
            _Val = _Stofx_v2(_Ac, &_Ep, _Base, &_Errno); 
            if (_Ep == _Ac || _Errno != 0) {
                _State = ios_base::failbit;
                _Val   = 0.0f;
            } else if (_Hexexp != 1000000000 && _Hexexp != 0) {
                _Val = :: ldexpf(_Val, 4 * _Hexexp);
            }
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }

    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        double& _Val) const { 
        _Adl_verify_range(_First, _Last);
        char _Ac[(8 + 768 + 16) ];
        int _Hexexp     = 1000000000 ;
        const int _Base = _Getffld(_Ac, _First, _Last, _Iosbase, &_Hexexp); 
        if (_Ac[0] == '\0') { 
            _State = ios_base::failbit;
            _Val   = 0.0;
        } else {
            int _Errno;
            char* _Ep;
            _Val = _Stodx_v2(_Ac, &_Ep, _Base, &_Errno); 
            if (_Ep == _Ac || _Errno != 0) {
                _State = ios_base::failbit;
                _Val   = 0.0;
            } else if (_Hexexp != 1000000000 && _Hexexp != 0) {
                _Val = :: ldexp(_Val, 4 * _Hexexp);
            }
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }


    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        long double& _Val) const { 
        static_assert(sizeof(double) == sizeof(long double), "Bad assumption: sizeof(double) == sizeof(long double).");
        double _Result;
        _First = num_get::do_get(_First, _Last, _Iosbase, _State, _Result); 
        _Val   = _Result;
        return _First;
    }

    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        void*& _Val) const { 
        _Adl_verify_range(_First, _Last);
        char _Ac[32 ];
        const int _Base = _Getifld(_Ac, _First, _Last, ios_base::hex, _Iosbase.getloc()); 
        if (_Ac[0] == '\0') { 
            _State = ios_base::failbit;
            _Val   = nullptr;
        } else {
            int _Errno;
            char* _Ep;

            _Val = reinterpret_cast<void*>(:: _Stoullx(_Ac, &_Ep, _Base, &_Errno));


#line 632 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xlocnum"
            if (_Ep == _Ac || _Errno != 0) {
                _State = ios_base::failbit;
                _Val   = nullptr;
            }
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }

private:
    int __cdecl _Getifld(char* _Ac, _InIt& _First, _InIt& _Last, ios_base::fmtflags _Basefield,
        const locale& _Loc) const { 
        const auto& _Punct_fac  = ::std:: use_facet<numpunct<_Elem>>(_Loc);
        const string _Grouping  = _Punct_fac.grouping();
        const _Elem _Kseparator = _Grouping.empty() ? _Elem{} : _Punct_fac.thousands_sep();

        constexpr int _Numget_signoff = 22;
        constexpr int _Numget_xoff    = 24;
        static constexpr char _Src[]  = "0123456789ABCDEFabcdef-+Xx";
        _Elem _Atoms[sizeof(_Src)];
        const ctype<_Elem>& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Loc);
        _Ctype_fac.widen(::std:: begin(_Src), ::std:: end(_Src), _Atoms);

        char* _Ptr = _Ac;

        if (_First != _Last) {
            if (*_First == _Atoms[_Numget_signoff + 1]) { 
                *_Ptr++ = '+';
                ++_First;
            } else if (*_First == _Atoms[_Numget_signoff]) { 
                *_Ptr++ = '-';
                ++_First;
            }
        }

        _Basefield &= ios_base::basefield;

        int _Base;
        if (_Basefield == ios_base::oct) {
            _Base = 8;
        } else if (_Basefield == ios_base::hex) {
            _Base = 16;
        } else if (_Basefield == ios_base::_Fmtzero) {
            _Base = 0;
        } else {
            _Base = 10;
        }

        bool _Seendigit = false; 
        bool _Nonzero   = false; 

        if (_First != _Last && *_First == _Atoms[0]) { 
            _Seendigit = true;
            ++_First;
            if (_First != _Last && (*_First == _Atoms[_Numget_xoff + 1] || *_First == _Atoms[_Numget_xoff])
                && (_Base == 0 || _Base == 16)) {
                _Base      = 16;
                _Seendigit = false;
                ++_First;
            } else if (_Base == 0) {
                _Base = 8;
            }
        }

        const auto _Dlen = static_cast<size_t>(_Base == 0 || _Base == 10 ? 10 : _Base == 8 ? 8 : 16 + 6);
        string _Groups(1, static_cast<char>(_Seendigit));
        size_t _Group = 0;

        for (char* const _Pe = &_Ac[32 - 1]; _First != _Last; ++_First) { 
            size_t _Idx = _Find_elem(_Atoms, *_First);
            if (_Idx < _Dlen) { 
                *_Ptr = _Src[_Idx];
                if ((_Nonzero || *_Ptr != '0') && _Ptr < _Pe) {
                    ++_Ptr;
                    _Nonzero = true;
                }

                _Seendigit = true;
                if (_Groups[_Group] != 127 ) {
                    ++_Groups[_Group];
                }
            } else if (_Groups[_Group] == '\0' || _Kseparator == _Elem{} || *_First != _Kseparator) {
                break; 
            } else { 
                _Groups.push_back('\0');
                ++_Group;
            }
        }

        if (_Group != 0) {
            if ('\0' < _Groups[_Group]) {
                ++_Group; 
            } else {
                _Seendigit = false; 
            }
        }

        for (const char* _Pg = &_Grouping[0]; _Seendigit && 0 < _Group;) {
            if (*_Pg == 127 ) {
                break; 
            } else if ((0 < --_Group && *_Pg != _Groups[_Group]) || (0 == _Group && *_Pg < _Groups[_Group])) {
                _Seendigit = false; 
            } else if ('\0' < _Pg[1]) {
                ++_Pg; 
            }
        }

        if (_Seendigit && !_Nonzero) {
            *_Ptr++ = '0'; 
        } else if (!_Seendigit) {
            _Ptr = _Ac; 
        }

        *_Ptr = '\0';
        return _Base;
    }

    int __cdecl _Getffld(char* _Ac, _InIt& _First, _InIt& _Last, ios_base& _Iosbase,
        int* _Phexexp) const { 
        if ((_Iosbase.flags() & ios_base::floatfield) == ios_base::hexfloat) {
            return _Getffldx(_Ac, _First, _Last, _Iosbase, _Phexexp); 
        }

        const auto& _Punct_fac = ::std:: use_facet<numpunct<_Elem>>(_Iosbase.getloc());
        const string _Grouping = _Punct_fac.grouping();
        char* _Ptr             = _Ac;
        bool _Bad              = false;
        bool _Sticky           = false;

        constexpr int _Numget_signoff = 10;
        constexpr int _Numget_eoff    = 12;
        static constexpr char _Src[]  = "0123456789-+Ee";
        _Elem _Atoms[sizeof(_Src)];
        const ctype<_Elem>& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Iosbase.getloc());
        _Ctype_fac.widen(::std:: begin(_Src), ::std:: end(_Src), _Atoms);

        if (_First != _Last) {
            if (*_First == _Atoms[_Numget_signoff + 1]) { 
                *_Ptr++ = '+';
                ++_First;
            } else if (*_First == _Atoms[_Numget_signoff]) { 
                *_Ptr++ = '-';
                ++_First;
            }
        }

        char* _Leading = _Ptr; 
        *_Ptr++        = '0'; 

        bool _Seendigit  = false; 
        int _Significant = 0; 
        int _Pten        = 0; 
        size_t _Idx;

        const int _Max_sig_dig = (*_Phexexp == 1000000000 ? 768 : 36 );

        const char* _Pg = &_Grouping[0];
        if (*_Pg == 127 || *_Pg <= '\0') {
            for (; _First != _Last && (_Idx = _Find_elem(_Atoms, *_First)) < 10; _Seendigit = true, (void) ++_First) {
                if (_Max_sig_dig <= _Significant) { 
                    ++_Pten;
                    if (0 < _Idx) {
                        _Sticky = true;
                    }
                } else if (_Idx != 0 || _Significant != 0) { 
                    *_Ptr++ = _Src[_Idx];
                    ++_Significant;
                }
            }
        } else { 
            const _Elem _Kseparator = _Grouping.empty() ? _Elem{} : _Punct_fac.thousands_sep();
            string _Groups(1, '\0');
            size_t _Group = 0;

            for (; _First != _Last; ++_First) {
                if ((_Idx = _Find_elem(_Atoms, *_First)) < 10) { 
                    _Seendigit = true;
                    if (_Max_sig_dig <= _Significant) { 
                        ++_Pten;
                        if (0 < _Idx) {
                            _Sticky = true;
                        }
                    } else if (_Idx != 0 || _Significant != 0) { 
                        *_Ptr++ = _Src[_Idx];
                        ++_Significant;
                    }

                    if (_Groups[_Group] != 127 ) {
                        ++_Groups[_Group];
                    }
                } else if (_Groups[_Group] == '\0' || _Kseparator == _Elem{} || *_First != _Kseparator) {
                    break; 
                } else { 
                    _Groups.push_back('\0');
                    ++_Group;
                }
            }

            if (_Group != 0) {
                if ('\0' < _Groups[_Group]) {
                    ++_Group; 
                } else {
                    _Bad = true; 
                }
            }

            while (!_Bad && 0 < _Group) {
                if (*_Pg == 127 ) {
                    break; 
                }

                if ((0 < --_Group && *_Pg != _Groups[_Group]) || (0 == _Group && *_Pg < _Groups[_Group])) {
                    _Bad = true; 
                } else if ('\0' < _Pg[1]) {
                    ++_Pg; 
                }
            }
        }

        if (_First != _Last && *_First == _Punct_fac.decimal_point()) { 
            *_Ptr++ = localeconv()->decimal_point[0];
            ++_First;
        }

        if (*_Phexexp != 1000000000 && _Significant == 0) { 
            for (; _First != _Last && *_First == _Atoms[0]; _Seendigit = true, (void) ++_First) {
                --_Pten; 
            }

            if (_Pten < 0) { 
                *_Ptr++ = '0';
                ++_Pten;
            }
        }

        for (; _First != _Last && (_Idx = _Find_elem(_Atoms, *_First)) < 10; _Seendigit = true, (void) ++_First) {
            if (_Significant < _Max_sig_dig) { 
                *_Ptr++ = _Src[_Idx];
                ++_Significant;
            } else if (0 < _Idx) {
                _Sticky = true; 
            }
        }

        if (_Sticky) { 
            char* _Px = _Ptr;
            while (--_Px != _Leading) { 
                if (*_Px != localeconv()->decimal_point[0]) { 
                    if (*_Px != '9') { 
                        ++*_Px;
                        break;
                    }

                    *_Px = '0'; 
                }
            }

            if (_Px == _Leading) { 
                *_Px = '1';
                ++_Pten;
            }
        }

        if (_Seendigit && _First != _Last
            && (*_First == _Atoms[_Numget_eoff + 1]
                || *_First == _Atoms[_Numget_eoff])) { 
            *_Ptr++ = 'e';
            ++_First;
            _Seendigit   = false;
            _Significant = 0;

            if (_First != _Last) {
                if (*_First == _Atoms[_Numget_signoff + 1]) { 
                    *_Ptr++ = '+';
                    ++_First;
                } else if (*_First == _Atoms[_Numget_signoff]) { 
                    *_Ptr++ = '-';
                    ++_First;
                }
            }

            for (; _First != _Last && *_First == _Atoms[0]; ++_First) { 
                _Seendigit = true;
            }

            if (_Seendigit) {
                *_Ptr++ = '0'; 
            }

            for (; _First != _Last && (_Idx = _Find_elem(_Atoms, *_First)) < 10; _Seendigit = true, (void) ++_First) {
                if (_Significant < 8 ) { 
                    *_Ptr++ = _Src[_Idx];
                    ++_Significant;
                }
            }
        }

        if (_Bad || !_Seendigit) {
            _Ptr = _Ac; 
        }

        *_Ptr = '\0';
        return _Pten;
    }

    int __cdecl _Getffldx(char* _Ac, _InIt& _First, _InIt& _Last, ios_base& _Iosbase,
        int* _Phexexp) const { 
        const auto& _Punct_fac = ::std:: use_facet<numpunct<_Elem>>(_Iosbase.getloc());
        const string _Grouping = _Punct_fac.grouping();

        constexpr int _Numget_signoff = 22;
        constexpr int _Numget_xoff    = 24;
        constexpr int _Numget_poff    = 26;
        static constexpr char _Src[]  = "0123456789ABCDEFabcdef-+XxPp";
        _Elem _Atoms[sizeof(_Src)];
        const ctype<_Elem>& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Iosbase.getloc());
        _Ctype_fac.widen(::std:: begin(_Src), ::std:: end(_Src), _Atoms);

        char* _Ptr = _Ac;
        bool _Bad  = false;
        size_t _Idx;

        if (_First != _Last) {
            if (*_First == _Atoms[_Numget_signoff + 1]) { 
                *_Ptr++ = '+';
                ++_First;
            } else if (*_First == _Atoms[_Numget_signoff]) { 
                *_Ptr++ = '-';
                ++_First;
            }
        }

        *_Ptr++ = '0';
        *_Ptr++ = 'x';

        bool _Seendigit  = false; 
        int _Significant = 0; 
        int _Phex        = 0; 

        if (_First != _Last && *_First == _Atoms[0]) {
            if (++_First != _Last && (*_First == _Atoms[_Numget_xoff + 1] || *_First == _Atoms[_Numget_xoff])) {
                ++_First; 
            } else {
                _Seendigit = true; 
            }
        }

        const int _Max_sig_dig = (*_Phexexp == 1000000000 ? 768 : 36 );

        const char* _Pg = &_Grouping[0];
        if (*_Pg == 127 || *_Pg <= '\0') {
            for (; _First != _Last && (_Idx = _Find_elem(_Atoms, *_First)) < _Numget_signoff;
                 _Seendigit = true, (void) ++_First) {
                if (_Max_sig_dig <= _Significant) {
                    ++_Phex; 
                } else if (_Idx != 0 || _Significant != 0) { 
                    *_Ptr++ = _Src[_Idx];
                    ++_Significant;
                }
            }
        } else { 
            const _Elem _Kseparator = _Grouping.empty() ? _Elem{} : _Punct_fac.thousands_sep();
            string _Groups(1, '\0');
            size_t _Group = 0;

            for (; _First != _Last; ++_First) {
                if ((_Idx = _Find_elem(_Atoms, *_First)) < _Numget_signoff) { 
                    _Seendigit = true;
                    if (_Max_sig_dig <= _Significant) {
                        ++_Phex; 
                    } else if (_Idx != 0 || _Significant != 0) { 
                        *_Ptr++ = _Src[_Idx];
                        ++_Significant;
                    }

                    if (_Groups[_Group] != 127 ) {
                        ++_Groups[_Group];
                    }
                } else if (_Groups[_Group] == '\0' || _Kseparator == _Elem{} || *_First != _Kseparator) {
                    break; 
                } else { 
                    _Groups.push_back('\0');
                    ++_Group;
                }
            }

            if (_Group != 0) {
                if ('\0' < _Groups[_Group]) {
                    ++_Group; 
                } else {
                    _Bad = true; 
                }
            }

            while (!_Bad && 0 < _Group) {
                if (*_Pg == 127 ) {
                    break; 
                }

                if ((0 < --_Group && *_Pg != _Groups[_Group]) || (0 == _Group && *_Pg < _Groups[_Group])) {
                    _Bad = true; 
                } else if ('\0' < _Pg[1]) {
                    ++_Pg; 
                }
            }
        }

        if (_Seendigit && _Significant == 0) {
            *_Ptr++ = '0'; 
        }

        if (_First != _Last && *_First == _Punct_fac.decimal_point()) { 
            *_Ptr++ = localeconv()->decimal_point[0];
            ++_First;
        }

        if (_Significant == 0) { 
            for (; _First != _Last && *_First == _Atoms[0]; _Seendigit = true, (void) ++_First) {
                --_Phex; 
            }

            if (_Phex < 0) { 
                *_Ptr++ = '0';
                ++_Phex;
            }
        }

        for (; _First != _Last && (_Idx = _Find_elem(_Atoms, *_First)) < _Numget_signoff;
             _Seendigit = true, (void) ++_First) {
            if (_Significant < _Max_sig_dig) { 
                *_Ptr++ = _Src[_Idx];
                ++_Significant;
            }
        }

        if (_Seendigit && _First != _Last
            && (*_First == _Atoms[_Numget_poff + 1]
                || *_First == _Atoms[_Numget_poff])) { 
            *_Ptr++ = 'p';
            ++_First;
            _Seendigit   = false;
            _Significant = 0;

            if (_First != _Last) {
                if (*_First == _Atoms[_Numget_signoff + 1]) { 
                    *_Ptr++ = '+';
                    ++_First;
                } else if (*_First == _Atoms[_Numget_signoff]) { 
                    *_Ptr++ = '-';
                    ++_First;
                }
            }

            for (; _First != _Last && *_First == _Atoms[0]; ++_First) { 
                _Seendigit = true;
            }

            if (_Seendigit) {
                *_Ptr++ = '0'; 
            }

            for (; _First != _Last && (_Idx = _Find_elem(_Atoms, *_First)) < _Numget_signoff;
                 _Seendigit = true, (void) ++_First) {
                if (_Significant < 8 ) { 
                    *_Ptr++ = _Src[_Idx];
                    ++_Significant;
                }
            }
        }

        if (_Bad || !_Seendigit) {
            _Ptr = _Ac; 
        }

        *_Ptr     = '\0';
        *_Phexexp = _Phex; 
        return 0; 
    }


};






template <class _Elem, class _InIt>
 locale::id num_get<_Elem, _InIt>::id;





template <class _Ty>
int _Float_put_desired_precision(const streamsize _Precision, const ios_base::fmtflags _Float_flags) {
    
    const bool _Is_hex = _Float_flags == (ios_base::fixed | ios_base::scientific);
    if (_Is_hex) {
        
        if constexpr (is_same_v<_Ty, double>) {
            return ((53 - 1) + 3) / 4;
        } else if constexpr (is_same_v<_Ty, long double>) {
            return ((53 - 1) + 3) / 4;
        } else {
            static_assert(_Always_false<_Ty>, "Expected only double or long double here (not float).");
        }
    }

    if (_Precision > 0) {
        return static_cast<int>(_Precision);
    } else if (_Precision == 0) {
        const bool _Is_default_float = _Float_flags == 0;
        if (_Is_default_float) {
            return 1;
        } else {
            return 0;
        }
    } else {
        constexpr int _Default_precision = 6;
        return _Default_precision;
    }
}

 extern "C++" template <class _Elem, class _OutIt = ostreambuf_iterator<_Elem, char_traits<_Elem>>>
class num_put : public locale::facet { 
public:
    static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t>, "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. " "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 " "to suppress this error." );

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        
        if (_Ppf && !*_Ppf) {
            *_Ppf = new num_put<_Elem, _OutIt>(_Locinfo(_Ploc->_C_str()));
        }

        return 4 ;
    }

     static locale::id id; 

protected:
     ~num_put() noexcept override {}

    void  _Init(const _Locinfo&) {} 

public:
    explicit  num_put(size_t _Refs = 0) : locale::facet(_Refs) { 
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }

     num_put(const _Locinfo& _Lobj, size_t _Refs = 0) : locale::facet(_Refs) {
        _Init(_Lobj);
    }

    using char_type = _Elem;
    using iter_type = _OutIt;

    _OutIt  put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, bool _Val) const { 
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }

    _OutIt  put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long _Val) const { 
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }

    _OutIt  put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill,
        unsigned long _Val) const { 
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }

    _OutIt  put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long long _Val) const { 
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }

    _OutIt  put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill,
        unsigned long long _Val) const { 
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }

    _OutIt  put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, double _Val) const { 
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }

    _OutIt  put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long double _Val) const { 
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }

    _OutIt  put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, const void* _Val) const { 
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }

protected:
    virtual _OutIt  do_put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, bool _Val) const { 
        if (!(_Iosbase.flags() & ios_base::boolalpha)) {
            return do_put(_Dest, _Iosbase, _Fill, static_cast<long>(_Val));
        } else { 
            const auto& _Punct_fac = ::std:: use_facet<numpunct<_Elem>>(_Iosbase.getloc());
            basic_string<_Elem> _Str;
            if (_Val) {
                _Str.assign(_Punct_fac.truename());
            } else {
                _Str.assign(_Punct_fac.falsename());
            }

            size_t _Fillcount;
            if (_Iosbase.width() <= 0 || static_cast<size_t>(_Iosbase.width()) <= _Str.size()) {
                _Fillcount = 0;
            } else {
                _Fillcount = static_cast<size_t>(_Iosbase.width()) - _Str.size();
            }

            if ((_Iosbase.flags() & ios_base::adjustfield) != ios_base::left) { 
                _Dest      = _Rep(_Dest, _Fill, _Fillcount);
                _Fillcount = 0;
            }
            _Dest = _Put(_Dest, _Str.c_str(), _Str.size()); 
            _Iosbase.width(0);
            return _Rep(_Dest, _Fill, _Fillcount); 
        }
    }

#pragma warning(push)
#pragma warning(disable : 4774) 
    virtual _OutIt  do_put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long _Val) const { 
        char _Buf[2 * 32 ];
        char _Fmt[6];

        return _Iput(_Dest, _Iosbase, _Fill, _Buf,
            static_cast<size_t>(:: sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "ld", _Iosbase.flags()), _Val)));
    }

    virtual _OutIt  do_put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill,
        unsigned long _Val) const { 
        char _Buf[2 * 32 ];
        char _Fmt[6];

        return _Iput(_Dest, _Iosbase, _Fill, _Buf,
            static_cast<size_t>(:: sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "lu", _Iosbase.flags()), _Val)));
    }

    virtual _OutIt  do_put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long long _Val) const { 
        char _Buf[2 * 32 ];
        char _Fmt[8];

        return _Iput(_Dest, _Iosbase, _Fill, _Buf,
            static_cast<size_t>(:: sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "Ld", _Iosbase.flags()), _Val)));
    }

    virtual _OutIt  do_put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill,
        unsigned long long _Val) const { 
        char _Buf[2 * 32 ];
        char _Fmt[8];

        return _Iput(_Dest, _Iosbase, _Fill, _Buf,
            static_cast<size_t>(:: sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "Lu", _Iosbase.flags()), _Val)));
    }

    virtual _OutIt  do_put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, double _Val) const { 
        string _Buf;
        char _Fmt[8];
        const auto _Float_flags     = _Iosbase.flags() & ios_base::floatfield;
        const bool _Is_fixed        = _Float_flags == ios_base::fixed;
        const bool _Is_hex          = _Float_flags == (ios_base::fixed | ios_base::scientific);
        const streamsize _Precision = _Is_hex ? -1 : _Iosbase.precision(); 
        const int _Desired_precision =
            _Float_put_desired_precision<double>(_Precision, _Float_flags); 
        size_t _Bufsize = static_cast<size_t>(_Desired_precision);
        if (_Is_fixed && 1e10 < :: fabs(_Val)) { 
            int _Ptwo;
            (void) :: frexp(_Val, &_Ptwo);
            _Bufsize += :: abs(_Ptwo) * 30103L / 100000L;
        }

        _Buf.resize(_Bufsize + 50); 
        const auto _Ngen = static_cast<size_t>(:: sprintf_s(
            &_Buf[0], _Buf.size(), _Ffmt(_Fmt, 0, _Iosbase.flags()), static_cast<int>(_Precision), _Val));

        return _Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen);
    }

    virtual _OutIt  do_put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long double _Val) const { 
        string _Buf;
        char _Fmt[8];
        const auto _Float_flags     = _Iosbase.flags() & ios_base::floatfield;
        const bool _Is_fixed        = _Float_flags == ios_base::fixed;
        const bool _Is_hex          = _Float_flags == (ios_base::fixed | ios_base::scientific);
        const streamsize _Precision = _Is_hex ? -1 : _Iosbase.precision(); 
        const int _Desired_precision =
            _Float_put_desired_precision<long double>(_Precision, _Float_flags); 
        size_t _Bufsize = static_cast<size_t>(_Desired_precision);
        if (_Is_fixed && 1e10 < :: fabsl(_Val)) { 
            int _Ptwo;
            (void) :: frexpl(_Val, &_Ptwo);
            _Bufsize += :: abs(_Ptwo) * 30103L / 100000L;
        }

        _Buf.resize(_Bufsize + 50); 
        const auto _Ngen = static_cast<size_t>(:: sprintf_s(
            &_Buf[0], _Buf.size(), _Ffmt(_Fmt, 'L', _Iosbase.flags()), static_cast<int>(_Precision), _Val));

        return _Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen);
    }
#pragma warning(pop)

    virtual _OutIt  do_put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, const void* _Val) const { 
        char _Buf[2 * 32 ];

        return _Iput(
            _Dest, _Iosbase, _Fill, _Buf, static_cast<size_t>(:: sprintf_s(_Buf, sizeof(_Buf), "%p", _Val)));
    }

private:
    char* __cdecl _Ffmt(
        char* _Fmt, char _Spec, ios_base::fmtflags _Flags) const { 
        char* _Ptr = _Fmt;
        *_Ptr++    = '%';

        if (_Flags & ios_base::showpos) {
            *_Ptr++ = '+';
        }

        if (_Flags & ios_base::showpoint) {
            *_Ptr++ = '#';
        }

        *_Ptr++ = '.';
        *_Ptr++ = '*'; 
        if (_Spec != '\0') {
            *_Ptr++ = _Spec; 
        }

        char _Ch; 
        ios_base::fmtflags _Ffl = _Flags & ios_base::floatfield;
        if (_Flags & ios_base::uppercase) {
            if (_Ffl == ios_base::fixed) {
                _Ch = 'f';
            } else if (_Ffl == ios_base::hexfloat) {
                _Ch = 'A'; 
            } else if (_Ffl == ios_base::scientific) {
                _Ch = 'E';
            } else {
                _Ch = 'G';
            }
        } else {
            if (_Ffl == ios_base::fixed) {
                _Ch = 'f';
            } else if (_Ffl == ios_base::hexfloat) {
                _Ch = 'a'; 
            } else if (_Ffl == ios_base::scientific) {
                _Ch = 'e';
            } else {
                _Ch = 'g';
            }
        }
        *_Ptr++ = _Ch;

        *_Ptr = '\0';
        return _Fmt;
    }

    _OutIt __cdecl _Fput(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, const char* _Buf,
        size_t _Count) const { 
        auto _Prefix = static_cast<size_t>(0 < _Count && (*_Buf == '+' || *_Buf == '-'));
        const char* _Exps;
        if ((_Iosbase.flags() & ios_base::floatfield) != ios_base::hexfloat) {
            _Exps = "eE";
        } else { 
            _Exps = "pP";
            if (_Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
                && (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X')) {
                _Prefix += 2;
            }
        }
        const size_t _Eoff = :: strcspn(&_Buf[0], _Exps); 
        char _Dp[2]        = {"."};
        _Dp[0]             = :: localeconv()->decimal_point[0];
        const size_t _Poff = :: strcspn(&_Buf[0], &_Dp[0]); 

        const ctype<_Elem>& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Iosbase.getloc());
        basic_string<_Elem> _Groupstring(_Count, _Elem(0)); 
        _Ctype_fac.widen(_Buf, _Buf + _Count, &_Groupstring[0]);

        const auto& _Punct_fac  = ::std:: use_facet<numpunct<_Elem>>(_Iosbase.getloc());
        const string _Grouping  = _Punct_fac.grouping();
        const _Elem _Kseparator = _Punct_fac.thousands_sep();

        if (_Poff != _Count) {
            _Groupstring[_Poff] = _Punct_fac.decimal_point();
        }

        size_t _Off     = _Poff == _Count ? _Eoff : _Poff;
        const char* _Pg = &_Grouping[0];
        while (*_Pg != 127 && '\0' < *_Pg && static_cast<size_t>(*_Pg) < _Off - _Prefix) {
            
            _Groupstring.insert(_Off -= *_Pg, 1, _Kseparator);
            if ('\0' < _Pg[1]) {
                ++_Pg; 
            }
        }

        _Count = _Groupstring.size();

        size_t _Fillcount;
        if (_Iosbase.width() <= 0 || static_cast<size_t>(_Iosbase.width()) <= _Count) {
            _Fillcount = 0;
        } else {
            _Fillcount = static_cast<size_t>(_Iosbase.width()) - _Count;
        }

        ios_base::fmtflags _Adjustfield = _Iosbase.flags() & ios_base::adjustfield;
        if (_Adjustfield != ios_base::left && _Adjustfield != ios_base::internal) { 
            _Dest      = _Rep(_Dest, _Fill, _Fillcount);
            _Fillcount = 0;
            _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);
        } else if (_Adjustfield == ios_base::internal) { 
            _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);
            _Dest      = _Rep(_Dest, _Fill, _Fillcount);
            _Fillcount = 0;
        } else {
            _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
        }

        _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);
        _Iosbase.width(0);
        return _Rep(_Dest, _Fill, _Fillcount); 
    }

    char* __cdecl _Ifmt(
        char* _Fmt, const char* _Spec, ios_base::fmtflags _Flags) const { 
        char* _Ptr = _Fmt;
        *_Ptr++    = '%';

        if (_Flags & ios_base::showpos) {
            *_Ptr++ = '+';
        }

        if (_Flags & ios_base::showbase) {
            *_Ptr++ = '#';
        }

        if (_Spec[0] != 'L') {
            *_Ptr++ = _Spec[0]; 
        } else { 
            *_Ptr++ = 'I';
            *_Ptr++ = '6';
            *_Ptr++ = '4';
        }

        ios_base::fmtflags _Basefield = _Flags & ios_base::basefield;
        *_Ptr++                       = _Basefield == ios_base::oct  ? 'o'
                                      : _Basefield != ios_base::hex  ? _Spec[1] 
                                      : _Flags & ios_base::uppercase ? 'X'
                                                                     : 'x';
        *_Ptr                         = '\0';
        return _Fmt;
    }

    _OutIt __cdecl _Iput(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, char* _Buf,
        size_t _Count) const { 
        auto _Prefix = static_cast<size_t>(0 < _Count && (*_Buf == '+' || *_Buf == '-'));
        if ((_Iosbase.flags() & ios_base::basefield) == ios_base::hex && _Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
            && (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X')) {
            _Prefix += 2;
        }

        const ctype<_Elem>& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Iosbase.getloc());
        basic_string<_Elem> _Groupstring(_Count, _Elem(0)); 
        _Ctype_fac.widen(_Buf, _Buf + _Count, &_Groupstring[0]);

        const auto& _Punct_fac = ::std:: use_facet<numpunct<_Elem>>(_Iosbase.getloc());
        const string _Grouping = _Punct_fac.grouping();
        const char* _Pg        = &_Grouping[0];
        if (*_Pg != 127 && '\0' < *_Pg) { 
            const _Elem _Kseparator = _Punct_fac.thousands_sep();
            while (*_Pg != 127 && '\0' < *_Pg && static_cast<size_t>(*_Pg) < _Count - _Prefix) {
                
                _Count -= *_Pg;
                _Groupstring.insert(_Count, 1, _Kseparator);
                if ('\0' < _Pg[1]) {
                    ++_Pg; 
                }
            }
        }

        _Count = _Groupstring.size();

        size_t _Fillcount;
        if (_Iosbase.width() <= 0 || static_cast<size_t>(_Iosbase.width()) <= _Count) {
            _Fillcount = 0;
        } else {
            _Fillcount = static_cast<size_t>(_Iosbase.width()) - _Count;
        }

        ios_base::fmtflags _Adjustfield = _Iosbase.flags() & ios_base::adjustfield;
        if (_Adjustfield != ios_base::left && _Adjustfield != ios_base::internal) { 
            _Dest      = _Rep(_Dest, _Fill, _Fillcount);
            _Fillcount = 0;
            _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);
        } else if (_Adjustfield == ios_base::internal) { 
            _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);
            _Dest      = _Rep(_Dest, _Fill, _Fillcount);
            _Fillcount = 0;
        } else {
            _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
        }

        _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);
        _Iosbase.width(0);
        return _Rep(_Dest, _Fill, _Fillcount); 
    }

    _OutIt __cdecl _Put(
        _OutIt _Dest, const _Elem* _Ptr, size_t _Count) const { 
        for (; 0 < _Count; --_Count, (void) ++_Dest, ++_Ptr) {
            *_Dest = *_Ptr;
        }

        return _Dest;
    }

    _OutIt __cdecl _Rep(_OutIt _Dest, _Elem _Ch, size_t _Count) const { 
        for (; 0 < _Count; --_Count, (void) ++_Dest) {
            *_Dest = _Ch;
        }

        return _Dest;
    }
};






template <class _Elem, class _OutIt>
 locale::id num_put<_Elem, _OutIt>::id;




template  locale::id numpunct<char>::id;
template class __declspec(dllimport) num_get<char, istreambuf_iterator<char, char_traits<char>>>;
template class __declspec(dllimport) num_put<char, ostreambuf_iterator<char, char_traits<char>>>;

template  locale::id numpunct<wchar_t>::id;
template class __declspec(dllimport) num_get<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t>>>;
template class __declspec(dllimport) num_put<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t>>>;
#line 1598 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xlocnum"








#line 1607 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xlocnum"




}


#pragma warning(pop)
#pragma pack(pop)
#line 1617 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xlocnum"
#line 1618 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xlocnum"
#pragma external_header(pop)
#line 12 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ios"

#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




namespace std {
 extern "C++" template <class _Elem, class _Traits>
class basic_ios : public ios_base { 
public:
    using _Myos       = basic_ostream<_Elem, _Traits>;
    using _Mysb       = basic_streambuf<_Elem, _Traits>;
    using _Ctype      = ctype<_Elem>;
    using char_type   = _Elem;
    using traits_type = _Traits;
    using int_type    = typename _Traits::int_type;
    using pos_type    = typename _Traits::pos_type;
    using off_type    = typename _Traits::off_type;

    explicit  basic_ios(_Mysb* _Strbuf) {
        init(_Strbuf);
    }

     ~basic_ios() noexcept override {}

    void  clear(iostate _State = goodbit, bool _Reraise = false) {
        
        ios_base::clear(_State | (_Mystrbuf ? ios_base::_Iostate{} : ios_base::badbit), _Reraise);
    }





#line 49 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ios"

    void  setstate(iostate _State, bool _Reraise = false) {
        
        clear(rdstate() | _State, _Reraise);
    }





#line 60 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ios"

    basic_ios&  copyfmt(const basic_ios& _Right) { 
        _Tiestr = _Right.tie();
        _Fillch = _Right.fill();
        ios_base::copyfmt(_Right);
        return *this;
    }

    _Myos*  tie() const noexcept   {
        return _Tiestr;
    }

    _Myos*  tie(_Myos* _Newtie) noexcept   { 
        _Myos* _Oldtie = _Tiestr;
        _Tiestr        = _Newtie;
        return _Oldtie;
    }

    [[nodiscard]] _Mysb*  rdbuf() const noexcept   {
        return _Mystrbuf;
    }

    _Mysb*  rdbuf(_Mysb* _Strbuf) { 
        _Mysb* _Oldstrbuf = _Mystrbuf;
        _Mystrbuf         = _Strbuf;
        clear();
        return _Oldstrbuf;
    }

    locale  imbue(const locale& _Loc) { 
        locale _Oldlocale = ios_base::imbue(_Loc);
        const auto _Rdbuf = rdbuf();
        if (_Rdbuf) {
            _Rdbuf->pubimbue(_Loc);
        }

        return _Oldlocale;
    }

    _Elem  fill() const noexcept   {
        return _Fillch;
    }

    _Elem  fill(_Elem _Newfill) noexcept   { 
        _Elem _Oldfill = _Fillch;
        _Fillch        = _Newfill;
        return _Oldfill;
    }

    char  narrow(_Elem _Ch, char _Dflt = '\0') const { 
        return ::std:: use_facet<_Ctype>(getloc()).narrow(_Ch, _Dflt);
    }

    _Elem  widen(char _Byte) const { 
        return ::std:: use_facet<_Ctype>(getloc()).widen(_Byte);
    }

    void  move(basic_ios& _Right) noexcept   {
        if (this != ::std:: addressof(_Right)) {
            _Mystrbuf = nullptr;
            _Tiestr   = nullptr;
            this->swap(_Right);
        }
    }

    void  move(basic_ios&& _Right) noexcept   {
        if (this != ::std:: addressof(_Right)) {
            _Mystrbuf = nullptr;
            _Tiestr   = nullptr;
            this->swap(_Right);
        }
    }

    void  swap(basic_ios& _Right) noexcept { 
        ios_base::swap(_Right);
        ::std:: swap(_Fillch, _Right._Fillch);
        ::std:: swap(_Tiestr, _Right._Tiestr);
    }

    void  set_rdbuf(_Mysb* _Strbuf) noexcept   {
        
        _Mystrbuf = _Strbuf;
    }

protected:
    void  init(_Mysb* _Strbuf = nullptr, bool _Isstd = false) {
        
        _Init(); 
        _Mystrbuf = _Strbuf;
        _Tiestr   = nullptr;
        _Fillch   = widen(' ');

        if (!_Mystrbuf) {
            setstate(badbit);
        }

        if (_Isstd) {
            _Addstd(this); 
        }
    }

     basic_ios() {}

private:
    _Mysb* _Mystrbuf; 
    _Myos* _Tiestr; 
    _Elem _Fillch; 

public:
     basic_ios(const basic_ios&)            = delete;
    basic_ios&  operator=(const basic_ios&) = delete;
};




template class __declspec(dllimport) basic_ios<char, char_traits<char>>;
template class __declspec(dllimport) basic_ios<wchar_t, char_traits<wchar_t>>;
#line 179 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ios"




#line 184 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ios"

 inline ios_base& __cdecl boolalpha(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::boolalpha);
    return _Iosbase;
}

 inline ios_base& __cdecl dec(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::dec, ios_base::basefield);
    return _Iosbase;
}

 inline ios_base& __cdecl defaultfloat(ios_base& _Iosbase) { 
    _Iosbase.unsetf(ios_base::floatfield);
    return _Iosbase;
}

 inline ios_base& __cdecl fixed(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::fixed, ios_base::floatfield);
    return _Iosbase;
}

 inline ios_base& __cdecl hex(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::hex, ios_base::basefield);
    return _Iosbase;
}

 inline ios_base& __cdecl hexfloat(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::hexfloat, ios_base::floatfield);
    return _Iosbase;
}

 inline ios_base& __cdecl internal(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::internal, ios_base::adjustfield);
    return _Iosbase;
}

 inline ios_base& __cdecl left(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::left, ios_base::adjustfield);
    return _Iosbase;
}

 inline ios_base& __cdecl noboolalpha(ios_base& _Iosbase) { 
    _Iosbase.unsetf(ios_base::boolalpha);
    return _Iosbase;
}

 inline ios_base& __cdecl noshowbase(ios_base& _Iosbase) { 
    _Iosbase.unsetf(ios_base::showbase);
    return _Iosbase;
}

 inline ios_base& __cdecl noshowpoint(ios_base& _Iosbase) { 
    _Iosbase.unsetf(ios_base::showpoint);
    return _Iosbase;
}

 inline ios_base& __cdecl noshowpos(ios_base& _Iosbase) { 
    _Iosbase.unsetf(ios_base::showpos);
    return _Iosbase;
}

 inline ios_base& __cdecl noskipws(ios_base& _Iosbase) { 
    _Iosbase.unsetf(ios_base::skipws);
    return _Iosbase;
}

 inline ios_base& __cdecl nounitbuf(ios_base& _Iosbase) { 
    _Iosbase.unsetf(ios_base::unitbuf);
    return _Iosbase;
}

 inline ios_base& __cdecl nouppercase(ios_base& _Iosbase) { 
    _Iosbase.unsetf(ios_base::uppercase);
    return _Iosbase;
}

 inline ios_base& __cdecl oct(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::oct, ios_base::basefield);
    return _Iosbase;
}

 inline ios_base& __cdecl right(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::right, ios_base::adjustfield);
    return _Iosbase;
}

 inline ios_base& __cdecl scientific(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::scientific, ios_base::floatfield);
    return _Iosbase;
}

 inline ios_base& __cdecl showbase(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::showbase);
    return _Iosbase;
}

 inline ios_base& __cdecl showpoint(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::showpoint);
    return _Iosbase;
}

 inline ios_base& __cdecl showpos(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::showpos);
    return _Iosbase;
}

 inline ios_base& __cdecl skipws(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::skipws);
    return _Iosbase;
}

 inline ios_base& __cdecl unitbuf(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::unitbuf);
    return _Iosbase;
}

 inline ios_base& __cdecl uppercase(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::uppercase);
    return _Iosbase;
}





#line 310 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ios"

}



#pragma warning(pop)
#pragma pack(pop)
#line 318 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ios"
#line 319 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ios"
#pragma external_header(pop)
#line 12 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ostream"

#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




namespace std {
#pragma vtordisp(push, 2) 

 extern "C++" template <class _Elem, class _Traits>
class basic_ostream : virtual public basic_ios<_Elem, _Traits> { 
public:
    using _Myios = basic_ios<_Elem, _Traits>;
    using _Mysb  = basic_streambuf<_Elem, _Traits>;
    using _Iter  = ostreambuf_iterator<_Elem, _Traits>;
    using _Nput  = num_put<_Elem, _Iter>;

    explicit  basic_ostream(basic_streambuf<_Elem, _Traits>* _Strbuf, bool _Isstd = false) {
        _Myios::init(_Strbuf, _Isstd);
    }

     basic_ostream(_Uninitialized, bool _Addit = true) {
        if (_Addit) {
            this->_Addstd(this); 
        }
    }

protected:
     basic_ostream(basic_ostream&& _Right) {
        _Myios::init();
        _Myios::move(::std:: move(_Right));
    }

    basic_ostream&  operator=(basic_ostream&& _Right) noexcept   {
        this->swap(_Right);
        return *this;
    }

    void  swap(basic_ostream& _Right) noexcept   {
        if (this != ::std:: addressof(_Right)) {
            _Myios::swap(_Right);
        }
    }

public:
     basic_ostream(const basic_ostream&)            = delete;
    basic_ostream&  operator=(const basic_ostream&) = delete;

     ~basic_ostream() noexcept override {}

    using int_type = typename _Traits::int_type;
    using pos_type = typename _Traits::pos_type;
    using off_type = typename _Traits::off_type;

    class _Sentry_base { 
    public:
         _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { 
            const auto _Rdbuf = _Myostr.rdbuf();
            if (_Rdbuf) {
                _Rdbuf->_Lock();
            }
        }

         ~_Sentry_base() noexcept { 
            const auto _Rdbuf = _Myostr.rdbuf();
            if (_Rdbuf) {
                _Rdbuf->_Unlock();
            }
        }

        basic_ostream& _Myostr; 

        _Sentry_base& operator=(const _Sentry_base&) = delete;
    };

    class sentry : public _Sentry_base {
    public:
        explicit  sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {
            if (!_Ostr.good()) {
                _Ok = false;
                return;
            }

            const auto _Tied = _Ostr.tie();
            if (!_Tied || _Tied == &_Ostr) {
                _Ok = true;
                return;
            }

            _Tied->flush();
            _Ok = _Ostr.good(); 
        }

        __pragma(warning(push)) __pragma(warning(disable : 4996))
         ~sentry() noexcept {


#line 112 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ostream"

#line 114 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ostream"
            const bool _Zero_uncaught_exceptions = ::std:: uncaught_exceptions() == 0;
#line 116 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ostream"

            if (_Zero_uncaught_exceptions) {
                this->_Myostr._Osfx();
            }
        }
        __pragma(warning(pop))

        explicit  operator bool() const {
            return _Ok;
        }

         sentry(const sentry&)            = delete;
        sentry&  operator=(const sentry&) = delete;

    private:
        bool _Ok; 
    };

    
    bool  opfx() { 
        if (!this->good()) {
            return false;
        }

        const auto _Tied = _Myios::tie();
        if (!_Tied || _Myios::tie() == this) {
            return true;
        }

        _Tied->flush();
        return this->good();
    }

    
    void  osfx() noexcept { 
        _Osfx();
    }

    void  _Osfx() noexcept { 
        try {
        if (this->good() && this->flags() & ios_base::unitbuf) {
            if (_Myios::rdbuf()->pubsync() == -1) { 
                _Myios::setstate(ios_base::badbit);
            }
        }
        } catch (...) {
        }
    }




















    basic_ostream&  operator<<(basic_ostream&(__cdecl* _Pfn)(basic_ostream&) ) {
        
        return _Pfn(*this);
    }

    basic_ostream&  operator<<(_Myios&(__cdecl* _Pfn)(_Myios&) ) {
        
        _Pfn(*this);
        return *this;
    }

    basic_ostream&  operator<<(ios_base&(__cdecl* _Pfn)(ios_base&) ) {
        
        _Pfn(*this);
        return *this;
    }

    basic_ostream&  operator<<(bool _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { 
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  operator<<(short _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { 
            const _Nput& _Nput_fac  = ::std:: use_facet<_Nput>(this->getloc());
            ios_base::fmtflags _Bfl = this->flags() & ios_base::basefield;

            long _Tmp;
            if (_Bfl == ios_base::oct || _Bfl == ios_base::hex) {
                _Tmp = static_cast<long>(static_cast<unsigned short>(_Val));
            } else {
                _Tmp = static_cast<long>(_Val);
            }

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Tmp).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    
    
    
    

    
    

    basic_ostream&  operator<<(unsigned short _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { 
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), static_cast<unsigned long>(_Val))
                    .failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  operator<<(int _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { 
            const _Nput& _Nput_fac  = ::std:: use_facet<_Nput>(this->getloc());
            ios_base::fmtflags _Bfl = this->flags() & ios_base::basefield;

            long _Tmp;
            if (_Bfl == ios_base::oct || _Bfl == ios_base::hex) {
                _Tmp = static_cast<long>(static_cast<unsigned int>(_Val));
            } else {
                _Tmp = static_cast<long>(_Val);
            }

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Tmp).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  operator<<(unsigned int _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { 
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), static_cast<unsigned long>(_Val))
                    .failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  operator<<(long _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { 
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  operator<<(unsigned long _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { 
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  operator<<(long long _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { 
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  operator<<(unsigned long long _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { 
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  operator<<(float _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { 
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), static_cast<double>(_Val)).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  operator<<(double _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { 
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  operator<<(long double _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { 
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  operator<<(const void* _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { 
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }






#line 467 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ostream"


    template <class = void> 
    basic_ostream& operator<<(nullptr_t) { 
        return *this << "nullptr";
    }
#line 474 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ostream"

    basic_ostream&  operator<<(_Mysb* _Strbuf) { 
        ios_base::iostate _State = ios_base::goodbit;
        bool _Copied             = false;
        const sentry _Ok(*this);

        if (_Ok && _Strbuf) {
            for (int_type _Meta = _Traits::eof();; _Copied = true) { 
                try {
                _Meta = _Traits::eq_int_type(_Traits::eof(), _Meta) ? _Strbuf->sgetc() : _Strbuf->snextc();
                } catch (...) {
                _Myios::setstate(ios_base::failbit);
                throw ;
                }

                if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {
                    break; 
                }

                try {
                if (_Traits::eq_int_type(_Traits::eof(), _Myios::rdbuf()->sputc(_Traits::to_char_type(_Meta)))) {
                    _State |= ios_base::badbit; 
                    break;
                }
                } catch (...) { _Myios::setstate(ios_base::badbit, true); }
            }
        }

        this->width(0);
        int _Setstate_with;
        if (_Strbuf) {
            if (_Copied) {
                _Setstate_with = _State;
            } else {
                _Setstate_with = _State | ios_base::failbit;
            }
        } else {
            _Setstate_with = ios_base::badbit;
        }

        _Myios::setstate(_Setstate_with);
        return *this;
    }

    basic_ostream&  put(_Elem _Ch) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (!_Ok) {
            _State |= ios_base::badbit;
        } else { 
            try {
            if (_Traits::eq_int_type(_Traits::eof(), _Myios::rdbuf()->sputc(_Ch))) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  write(const _Elem* _Str, streamsize _Count) {
        
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (!_Ok) {
            _State |= ios_base::badbit;
        } else if (0 < _Count) { 
            try {
            if (_Myios::rdbuf()->sputn(_Str, _Count) != _Count) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  flush() { 
        const auto _Rdbuf = _Myios::rdbuf();
        if (_Rdbuf) { 
            const sentry _Ok(*this);

            if (_Ok) {
                ios_base::iostate _State = ios_base::goodbit;
                try {
                if (_Rdbuf->pubsync() == -1) {
                    _State |= ios_base::badbit; 
                }
                } catch (...) { _Myios::setstate(ios_base::badbit, true); }
                _Myios::setstate(_State);
            }
        }
        return *this;
    }

    basic_ostream&  seekp(pos_type _Pos) { 
        const sentry _Ok(*this);

        if (!this->fail()) {
            ios_base::iostate _State = ios_base::goodbit;
            try {
            if (static_cast<off_type>(_Myios::rdbuf()->pubseekpos(_Pos, ios_base::out)) == -1) {
                _State |= ios_base::failbit; 
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
            _Myios::setstate(_State);
        }

        return *this;
    }

    basic_ostream&  seekp(off_type _Off, ios_base::seekdir _Way) {
        
        const sentry _Ok(*this);

        if (!this->fail()) {
            ios_base::iostate _State = ios_base::goodbit;
            try {
            if (static_cast<off_type>(_Myios::rdbuf()->pubseekoff(_Off, _Way, ios_base::out)) == -1) {
                _State |= ios_base::failbit; 
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
            _Myios::setstate(_State);
        }

        return *this;
    }

    pos_type  tellp() {
        const sentry _Ok(*this);

        if (!this->fail()) {
            try {
            return _Myios::rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        return pos_type{off_type{-1}};
    }
};

#pragma vtordisp(pop) 



















































template class __declspec(dllimport) basic_ostream<char, char_traits<char>>;
template class __declspec(dllimport) basic_ostream<wchar_t, char_traits<wchar_t>>;
#line 674 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ostream"




#line 679 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ostream"

 template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr, const char* _Val) { 
    ios_base::iostate _State = ios_base::goodbit;
    streamsize _Count        = static_cast<streamsize>(:: strlen(_Val));
    streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;
    const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

    if (!_Ok) {
        _State |= ios_base::badbit;
    } else { 
        try {
        const ctype<_Elem>& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Ostr.getloc());
        if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {
            for (; 0 < _Pad; --_Pad) { 
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit; 
                    break;
                }
            }
        }

        for (; _State == ios_base::goodbit && 0 < _Count; --_Count, ++_Val) {
            if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ctype_fac.widen(*_Val)))) {
                _State |= ios_base::badbit;
            }
        }

        if (_State == ios_base::goodbit) {
            for (; 0 < _Pad; --_Pad) { 
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit; 
                    break;
                }
            }
        }

        _Ostr.width(0);
        } catch (...) { (_Ostr) .setstate(ios_base::badbit, true); }
    }

    _Ostr.setstate(_State);
    return _Ostr;
}

 template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr, char _Ch) { 
    ios_base::iostate _State = ios_base::goodbit;
    const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

    if (_Ok) { 
        const ctype<_Elem>& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Ostr.getloc());
        streamsize _Pad                = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

        try {
        if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {
            for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { 
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit;
                }
            }
        }

        if (_State == ios_base::goodbit
            && _Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ctype_fac.widen(_Ch)))) {
            _State |= ios_base::badbit;
        }

        for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { 
            if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                _State |= ios_base::badbit;
            }
        }
        } catch (...) { (_Ostr) .setstate(ios_base::badbit, true); }
    }

    _Ostr.width(0);
    _Ostr.setstate(_State);
    return _Ostr;
}

 template <class _Traits>
basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& _Ostr, const char* _Val) {
    
    using _Elem = char;
    using _Myos = basic_ostream<_Elem, _Traits>;

    ios_base::iostate _State = ios_base::goodbit;
    streamsize _Count        = static_cast<streamsize>(_Traits::length(_Val));
    streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;
    const typename _Myos::sentry _Ok(_Ostr);

    if (!_Ok) {
        _State |= ios_base::badbit;
    } else { 
        try {
        if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {
            for (; 0 < _Pad; --_Pad) { 
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit; 
                    break;
                }
            }
        }

        if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {
            _State |= ios_base::badbit;
        }

        if (_State == ios_base::goodbit) {
            for (; 0 < _Pad; --_Pad) { 
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit; 
                    break;
                }
            }
        }

        _Ostr.width(0);
        } catch (...) { (_Ostr) .setstate(ios_base::badbit, true); }
    }

    _Ostr.setstate(_State);
    return _Ostr;
}

 template <class _Traits>
basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& _Ostr, char _Ch) {
    
    using _Elem = char;
    using _Myos = basic_ostream<_Elem, _Traits>;

    ios_base::iostate _State = ios_base::goodbit;
    const typename _Myos::sentry _Ok(_Ostr);

    if (_Ok) { 
        streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

        try {
        if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {
            for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { 
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit;
                }
            }
        }

        if (_State == ios_base::goodbit && _Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ch))) {
            _State |= ios_base::badbit;
        }

        for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { 
            if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                _State |= ios_base::badbit;
            }
        }
        } catch (...) { (_Ostr) .setstate(ios_base::badbit, true); }
    }

    _Ostr.width(0);
    _Ostr.setstate(_State);
    return _Ostr;
}

 template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr, const _Elem* _Val) { 
    using _Myos = basic_ostream<_Elem, _Traits>;

    ios_base::iostate _State = ios_base::goodbit;
    streamsize _Count        = static_cast<streamsize>(_Traits::length(_Val));
    streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;
    const typename _Myos::sentry _Ok(_Ostr);

    if (!_Ok) {
        _State |= ios_base::badbit;
    } else { 
        try {
        if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {
            for (; 0 < _Pad; --_Pad) { 
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit; 
                    break;
                }
            }
        }

        if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {
            _State |= ios_base::badbit;
        }

        if (_State == ios_base::goodbit) {
            for (; 0 < _Pad; --_Pad) { 
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit; 
                    break;
                }
            }
        }

        _Ostr.width(0);
        } catch (...) { (_Ostr) .setstate(ios_base::badbit, true); }
    }

    _Ostr.setstate(_State);
    return _Ostr;
}

 template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr, _Elem _Ch) { 
    using _Myos = basic_ostream<_Elem, _Traits>;

    ios_base::iostate _State = ios_base::goodbit;
    const typename _Myos::sentry _Ok(_Ostr);

    if (_Ok) { 
        streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

        try {
        if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {
            for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { 
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit;
                }
            }
        }

        if (_State == ios_base::goodbit && _Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ch))) {
            _State |= ios_base::badbit;
        }

        for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { 
            if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                _State |= ios_base::badbit;
            }
        }
        } catch (...) { (_Ostr) .setstate(ios_base::badbit, true); }
    }

    _Ostr.width(0);
    _Ostr.setstate(_State);
    return _Ostr;
}

 template <class _Traits>
basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& _Ostr, const signed char* _Val) {
    
    return _Ostr << reinterpret_cast<const char*>(_Val);
}

 template <class _Traits>
basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& _Ostr, signed char _Ch) { 
    return _Ostr << static_cast<char>(_Ch);
}

 template <class _Traits>
basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& _Ostr, const unsigned char* _Val) {
    
    return _Ostr << reinterpret_cast<const char*>(_Val);
}

 template <class _Traits>
basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& _Ostr, unsigned char _Ch) {
    
    return _Ostr << static_cast<char>(_Ch);
}



 template <class _Traits>
basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>&, const char8_t*) = delete;
 template <class _Traits>
basic_ostream<wchar_t, _Traits>& operator<<(basic_ostream<wchar_t, _Traits>&, const char8_t*) = delete;


 template <class _Traits>
basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>&, char8_t) = delete;
 template <class _Traits>
basic_ostream<wchar_t, _Traits>& operator<<(basic_ostream<wchar_t, _Traits>&, char8_t) = delete;
#line 958 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ostream"



 template <class _Traits>
basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>&, wchar_t) = delete;

 template <class _Traits>
basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>&, const wchar_t*) = delete;
#line 967 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ostream"

 template <class _Traits>
basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>&, char16_t) = delete;
 template <class _Traits>
basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>&, char32_t) = delete;

 template <class _Traits>
basic_ostream<wchar_t, _Traits>& operator<<(basic_ostream<wchar_t, _Traits>&, char16_t) = delete;
 template <class _Traits>
basic_ostream<wchar_t, _Traits>& operator<<(basic_ostream<wchar_t, _Traits>&, char32_t) = delete;

 template <class _Traits>
basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>&, const char16_t*) = delete;
 template <class _Traits>
basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>&, const char32_t*) = delete;

 template <class _Traits>
basic_ostream<wchar_t, _Traits>& operator<<(basic_ostream<wchar_t, _Traits>&, const char16_t*) = delete;
 template <class _Traits>
basic_ostream<wchar_t, _Traits>& operator<<(basic_ostream<wchar_t, _Traits>&, const char32_t*) = delete;
#line 988 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ostream"

template <class _Ostr, class _Ty, class = void>
struct _Can_stream_out : false_type {};

template <class _Ostr, class _Ty>
struct _Can_stream_out<_Ostr, _Ty, void_t<decltype(::std:: declval<_Ostr&>() << ::std:: declval<const _Ty&>())>> : true_type {
};

 template <class _Ostr, class _Ty,
    enable_if_t<conjunction_v<is_convertible<_Ostr*, ios_base*>, _Can_stream_out<_Ostr, _Ty>>, int> = 0>
_Ostr&& operator<<(_Ostr&& _Os, const _Ty& _Val) { 
    _Os << _Val;
    return ::std:: move(_Os);
}

 template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& __cdecl endl(
    basic_ostream<_Elem, _Traits>& _Ostr) { 
    _Ostr.put(_Ostr.widen('\n'));
    _Ostr.flush();
    return _Ostr;
}

 template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& __cdecl ends(basic_ostream<_Elem, _Traits>& _Ostr) { 
    _Ostr.put(_Elem());
    return _Ostr;
}

 template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& __cdecl flush(basic_ostream<_Elem, _Traits>& _Ostr) { 
    _Ostr.flush();
    return _Ostr;
}



 template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& emit_on_flush(basic_ostream<_Elem, _Traits>& _Ostr) {
    const auto _Sync_buf_ptr = dynamic_cast<_Basic_syncbuf_impl<_Elem, _Traits>*>(_Ostr.rdbuf());
    if (_Sync_buf_ptr) {
        _Sync_buf_ptr->set_emit_on_sync(true);
    }
    return _Ostr;
}

 template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& noemit_on_flush(basic_ostream<_Elem, _Traits>& _Ostr) {
    const auto _Sync_buf_ptr = dynamic_cast<_Basic_syncbuf_impl<_Elem, _Traits>*>(_Ostr.rdbuf());
    if (_Sync_buf_ptr) {
        _Sync_buf_ptr->set_emit_on_sync(false);
    }
    return _Ostr;
}

 template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& flush_emit(basic_ostream<_Elem, _Traits>& _Ostr) {
    _Ostr.flush();
    const auto _Sync_buf_ptr = dynamic_cast<_Basic_syncbuf_impl<_Elem, _Traits>*>(_Ostr.rdbuf());
    if (_Sync_buf_ptr) {
        ios_base::iostate _State = ios_base::goodbit;
        const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);
        if (!_Ok) {
            _State |= ios_base::badbit;
        } else {
            try {
            const bool _Emit_failed = !_Sync_buf_ptr->_Do_emit();
            if (_Emit_failed) {
                _State |= ios_base::badbit;
            }
            } catch (...) { (_Ostr) .setstate(ios_base::badbit, true); }
        }
        _Ostr.setstate(_State);
    }
    return _Ostr;
}







#line 1072 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ostream"
#line 1073 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ostream"

 template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr, const error_code& _Errcode) {
    
    return _Ostr << _Errcode.category().name() << ':' << _Errcode.value();
}
}



#pragma warning(pop)
#pragma pack(pop)
#line 1086 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ostream"
#line 1087 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ostream"
#pragma external_header(pop)
#line 12 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\istream"

#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




namespace std {
#pragma vtordisp(push, 2) 

 extern "C++" template <class _Elem, class _Traits>
class basic_istream : virtual public basic_ios<_Elem, _Traits> { 
public:
    using _Myios = basic_ios<_Elem, _Traits>;
    using _Mysb  = basic_streambuf<_Elem, _Traits>;
    using _Iter  = istreambuf_iterator<_Elem, _Traits>;
    using _Ctype = ctype<_Elem>;
    using _Nget  = num_get<_Elem, _Iter>;







#line 39 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\istream"

    explicit  basic_istream(_Mysb* _Strbuf, bool _Isstd = false)

        : _Chcount(0) {
        _Myios::init(_Strbuf, _Isstd);
    }

     basic_istream(_Uninitialized) {
        this->_Addstd(this);
    }

protected:
     basic_istream(basic_istream&& _Right) : _Chcount(_Right._Chcount) {
        _Myios::init();
        _Myios::move(::std:: move(_Right));
        _Right._Chcount = 0;
    }

    basic_istream&  operator=(basic_istream&& _Right) noexcept   {
        this->swap(_Right);
        return *this;
    }

    void  swap(basic_istream& _Right) noexcept   {
        _Myios::swap(_Right);
        ::std:: swap(_Chcount, _Right._Chcount);
    }

public:
     basic_istream(const basic_istream&)            = delete;
    basic_istream&  operator=(const basic_istream&) = delete;

     ~basic_istream() noexcept override {}

    using int_type = typename _Traits::int_type;
    using pos_type = typename _Traits::pos_type;
    using off_type = typename _Traits::off_type;

    class _Sentry_base {
    public:
         _Sentry_base(basic_istream& _Istr) : _Myistr(_Istr) {
            const auto _Rdbuf = _Myistr.rdbuf();
            if (_Rdbuf) {
                _Rdbuf->_Lock();
            }
        }

         ~_Sentry_base() noexcept {
            const auto _Rdbuf = _Myistr.rdbuf();
            if (_Rdbuf) {
                _Rdbuf->_Unlock();
            }
        }

        basic_istream& _Myistr;

        _Sentry_base& operator=(const _Sentry_base&) = delete;
    };

    class sentry : public _Sentry_base {
    public:
        explicit  sentry(basic_istream& _Istr, bool _Noskip = false)
            : _Sentry_base(_Istr), _Ok(_Sentry_base::_Myistr._Ipfx(_Noskip)) {}

        explicit  operator bool() const {
            return _Ok;
        }

         sentry(const sentry&)            = delete;
        sentry&  operator=(const sentry&) = delete;

    private:
        bool _Ok; 
    };

    bool  _Ipfx(bool _Noskip = false) { 
        if (!this->good()) {
            _Myios::setstate(ios_base::failbit);
            return false;
        }

        
        const auto _Tied = _Myios::tie();
        if (_Tied) {
            _Tied->flush();
        }

        bool _Eof = false;
        if (!_Noskip && this->flags() & ios_base::skipws) { 
            const _Ctype& _Ctype_fac = ::std:: use_facet<_Ctype>(this->getloc());

            try {
            int_type _Meta = _Myios::rdbuf()->sgetc();

            for (;; _Meta = _Myios::rdbuf()->snextc()) {
                if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { 
                    _Eof = true;
                    break;
                } else if (!_Ctype_fac.is(_Ctype::space, _Traits::to_char_type(_Meta))) {
                    break; 
                }
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        if (_Eof) {
            _Myios::setstate(ios_base::eofbit | ios_base::failbit);
        }

        return this->good();
    }

    
    bool  ipfx(bool _Noskip = false) { 
        return _Ipfx(_Noskip);
    }

    
    void  isfx() {} 


















    basic_istream&  operator>>(basic_istream&(__cdecl* _Pfn)(basic_istream&) ) {
        
        return _Pfn(*this);
    }

    basic_istream&  operator>>(_Myios&(__cdecl* _Pfn)(_Myios&) ) { 
        _Pfn(*this);
        return *this;
    }

    basic_istream&  operator>>(ios_base&(__cdecl* _Pfn)(ios_base&) ) { 
        _Pfn(*this);
        return *this;
    }

private:
    template <class _Ty>
    basic_istream& _Common_extract_with_num_get(_Ty& _Val) { 
        ios_base::iostate _Err = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { 
            try {
            ::std:: use_facet<_Nget>(this->getloc()).get(*this, {}, *this, _Err, _Val);
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_Err);
        return *this;
    }

    template <class = void>
    void _Increment_gcount() noexcept {
        if (_Chcount != (numeric_limits<streamsize>::max)()) {
            ++_Chcount;
        }
    }

public:
    basic_istream&  operator>>(bool& _Val) { 
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream&  operator>>(short& _Val) { 
        ios_base::iostate _Err = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { 
            try {
            long _Lval;
            ::std:: use_facet<_Nget>(this->getloc()).get(*this, {}, *this, _Err, _Lval);
            if (_Lval < (-32768) ) {
                _Err |= ios_base::failbit;
                _Val = (-32768) ;
            } else if (_Lval > 32767 ) {
                _Err |= ios_base::failbit;
                _Val = 32767 ;
            } else {
                _Val = static_cast<short>(_Lval);
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_Err);
        return *this;
    }

    
    
    
    

    
    

    basic_istream&  operator>>(unsigned short& _Val) { 
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream&  operator>>(int& _Val) { 
        static_assert(sizeof(int) == sizeof(long), "Bad overflow assumptions due to sizeof(int) != sizeof(long)");
        long _Result = _Val;
        _Common_extract_with_num_get(_Result);
        _Val = _Result;
        return *this;
    }

    basic_istream&  operator>>(unsigned int& _Val) { 
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream&  operator>>(long& _Val) { 
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream&  operator>>(unsigned long& _Val) { 
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream&  operator>>(long long& _Val) { 
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream&  operator>>(unsigned long long& _Val) { 
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream&  operator>>(float& _Val) { 
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream&  operator>>(double& _Val) { 
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream&  operator>>(long double& _Val) { 
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream&  operator>>(void*& _Val) { 
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream&  operator>>(_Mysb* _Strbuf) { 
        _Chcount = 0; 
        const sentry _Ok(*this, true);
        ios_base::iostate _State = ios_base::goodbit;
        if (_Ok && _Strbuf) { 
            try {
            for (int_type _Meta = _Myios::rdbuf()->sgetc();; _Meta = _Myios::rdbuf()->snextc()) {
                if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { 
                    _State |= ios_base::eofbit;
                    break;
                }
                
                try {
                if (_Traits::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Traits::to_char_type(_Meta)))) {
                    break;
                }

                } catch (...) {
                break;
                }

                _Increment_gcount();
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        if (_Chcount == 0) { 
            _State |= ios_base::failbit;
        }

        _Myios::setstate(_State);
        return *this;
    }

    int_type  get() { 
        int_type _Meta           = 0;
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount                 = 0;
        const sentry _Ok(*this, true);

        if (!_Ok) {
            _Meta = _Traits::eof(); 
        } else { 
            try {
            _Meta = _Myios::rdbuf()->sgetc();

            if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {
                _State |= ios_base::eofbit | ios_base::failbit; 
            } else { 
                _Myios::rdbuf()->sbumpc();
                _Chcount = 1;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return _Meta;
    }

    basic_istream&  get(_Elem* _Str, streamsize _Count) { 
        return get(_Str, _Count, _Myios::widen('\n'));
    }

    basic_istream&  get(_Elem* _Str, streamsize _Count, _Elem _Delim) {
        
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount                 = 0;
        const sentry _Ok(*this, true);

        if (_Ok && 0 < _Count) { 
            try {
            int_type _Meta = _Myios::rdbuf()->sgetc();

            for (; 0 < --_Count; _Meta = _Myios::rdbuf()->snextc()) {
                if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { 
                    _State |= ios_base::eofbit;
                    break;
                } else if (_Traits::to_char_type(_Meta) == _Delim) {
                    break; 
                } else { 
                    *_Str++ = _Traits::to_char_type(_Meta);
                    _Increment_gcount();
                }
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_Chcount == 0 ? _State | ios_base::failbit : _State);
        *_Str = _Elem(); 
        return *this;
    }

    basic_istream&  get(_Elem& _Ch) { 
        int_type _Meta = get();
        if (!_Traits::eq_int_type(_Traits::eof(), _Meta)) {
            _Ch = _Traits::to_char_type(_Meta);
        }

        return *this;
    }

    basic_istream&  get(_Mysb& _Strbuf) { 
        return get(_Strbuf, _Myios::widen('\n'));
    }

    basic_istream&  get(_Mysb& _Strbuf, _Elem _Delim) {
        
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount                 = 0;
        const sentry _Ok(*this, true);

        if (_Ok) { 
            try {
            int_type _Meta = _Myios::rdbuf()->sgetc();

            for (;; _Meta = _Myios::rdbuf()->snextc()) {
                if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { 
                    _State |= ios_base::eofbit;
                    break;
                } else { 
                    try {
                    _Elem _Ch = _Traits::to_char_type(_Meta);
                    if (_Ch == _Delim || _Traits::eq_int_type(_Traits::eof(), _Strbuf.sputc(_Ch))) {
                        break;
                    }
                    } catch (...) {
                    break;
                    }
                    _Increment_gcount();
                }
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        if (_Chcount == 0) {
            _State |= ios_base::failbit;
        }
        _Myios::setstate(_State);
        return *this;
    }

    basic_istream&  getline(_Elem* _Str, streamsize _Count) {
        
        return getline(_Str, _Count, _Myios::widen('\n'));
    }

    basic_istream&  getline(_Elem* _Str, streamsize _Count, _Elem _Delim) {
        
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount                 = 0;
        const sentry _Ok(*this, true);

        if (_Ok && 0 < _Count) { 
            int_type _Metadelim = _Traits::to_int_type(_Delim);

            try {
            int_type _Meta = _Myios::rdbuf()->sgetc();

            for (;; _Meta = _Myios::rdbuf()->snextc()) {
                if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { 
                    _State |= ios_base::eofbit;
                    break;
                } else if (_Meta == _Metadelim) { 
                    _Increment_gcount();
                    _Myios::rdbuf()->sbumpc();
                    break;
                } else if (--_Count <= 0) { 
                    _State |= ios_base::failbit;
                    break;
                } else { 
                    *_Str++ = _Traits::to_char_type(_Meta);
                    _Increment_gcount();
                }
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        *_Str = _Elem(); 
        _Myios::setstate(_Chcount == 0 ? _State | ios_base::failbit : _State);
        return *this;
    }

    basic_istream&  ignore(streamsize _Count = 1, int_type _Metadelim = _Traits::eof()) {
        
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount                 = 0;
        const sentry _Ok(*this, true);

        if (_Ok && 0 < _Count) { 
            try {
            for (;;) { 
                int_type _Meta;
                if (_Count != (numeric_limits<streamsize>::max)() && --_Count < 0) {
                    break; 
                } else if (_Traits::eq_int_type(_Traits::eof(),
                               _Meta = _Myios::rdbuf()->sbumpc())) { 
                    _State |= ios_base::eofbit;
                    break;
                } else { 
                    _Increment_gcount();
                    if (_Meta == _Metadelim) {
                        break; 
                    }
                }
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_istream&  read(_Elem* _Str, streamsize _Count) { 
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount                 = 0;
        const sentry _Ok(*this, true);

        if (_Ok && 0 < _Count) { 
            try {
            const streamsize _Num = _Myios::rdbuf()->sgetn(_Str, _Count);
            _Chcount              = _Num;

            if (_Num != _Count) {
                _State |= ios_base::eofbit | ios_base::failbit; 
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    streamsize  readsome(_Elem* _Str, streamsize _Count) {
        
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount                 = 0;
        const sentry _Ok(*this, true);
        streamsize _Num;

        if (!_Ok) {
            _State |= ios_base::failbit; 
        } else if ((_Num = _Myios::rdbuf()->in_avail()) < 0) {
            _State |= ios_base::eofbit; 
        } else if (0 < _Count && 0 < _Num) { 
            read(_Str, _Num < _Count ? _Num : _Count);
        }

        _Myios::setstate(_State);
        return gcount();
    }

    int_type  peek() {
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount                 = 0;
        int_type _Meta           = 0;
        const sentry _Ok(*this, true);

        if (!_Ok) {
            _Meta = _Traits::eof(); 
        } else { 
            try {
            if (_Traits::eq_int_type(_Traits::eof(), _Meta = _Myios::rdbuf()->sgetc())) {
                _State |= ios_base::eofbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return _Meta;
    }

    basic_istream&  putback(_Elem _Ch) { 
        _Chcount                    = 0;
        ios_base::iostate _State    = ios_base::goodbit;
        ios_base::iostate _Oldstate = _Myios::rdstate();
        _Myios::clear(_Oldstate & ~ios_base::eofbit);
        const sentry _Ok(*this, true);

        if (_Ok) { 
            try {
            if (_Traits::eq_int_type(_Traits::eof(), _Myios::rdbuf()->sputbackc(_Ch))) {
                _State |= ios_base::badbit | _Oldstate;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_istream&  unget() { 
        _Chcount                    = 0;
        ios_base::iostate _State    = ios_base::goodbit;
        ios_base::iostate _Oldstate = _Myios::rdstate();
        _Myios::clear(_Oldstate & ~ios_base::eofbit);
        const sentry _Ok(*this, true);

        if (_Ok) { 
            try {
            if (_Traits::eq_int_type(_Traits::eof(), _Myios::rdbuf()->sungetc())) {
                _State |= ios_base::badbit | _Oldstate;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    [[nodiscard]] streamsize  gcount() const noexcept   {
        
        return _Chcount;
    }

    int  sync() { 
        const sentry _Ok(*this, true);

        const auto _Rdbuf = _Myios::rdbuf();
        if (!_Rdbuf) {
            return -1;
        }

        ios_base::iostate _State = ios_base::goodbit;
        try {
        if (_Rdbuf->pubsync() == -1) {
            _State |= ios_base::badbit;
        }
        } catch (...) {
        _Myios::setstate(ios_base::badbit, true);
        return -1;
        }

        if (_State & ios_base::badbit) {
            _Myios::setstate(ios_base::badbit);
            return -1;
        }

        return 0;
    }

    basic_istream&  seekg(pos_type _Pos) { 
        ios_base::iostate _State    = ios_base::goodbit;
        ios_base::iostate _Oldstate = _Myios::rdstate();
        _Myios::clear(_Oldstate & ~ios_base::eofbit);
        const sentry _Ok(*this, true);

        if (!this->fail()) {
            try {
            if (static_cast<off_type>(_Myios::rdbuf()->pubseekpos(_Pos, ios_base::in)) == -1) {
                _State |= ios_base::failbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_istream&  seekg(off_type _Off, ios_base::seekdir _Way) {
        
        ios_base::iostate _State    = ios_base::goodbit;
        ios_base::iostate _Oldstate = _Myios::rdstate();
        _Myios::clear(_Oldstate & ~ios_base::eofbit);
        const sentry _Ok(*this, true);

        if (!this->fail()) {
            try {
            if (static_cast<off_type>(_Myios::rdbuf()->pubseekoff(_Off, _Way, ios_base::in)) == -1) {
                _State |= ios_base::failbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    pos_type  tellg() {
        const sentry _Ok(*this, true);

        if (!this->fail()) {
            try {
            return _Myios::rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        return pos_type{off_type{-1}};
    }

private:
    streamsize _Chcount; 
};

#pragma vtordisp(pop) 























template class __declspec(dllimport) basic_istream<char, char_traits<char>>;
template class __declspec(dllimport) basic_istream<wchar_t, char_traits<wchar_t>>;
#line 719 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\istream"




#line 724 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\istream"

 extern "C++" template <class _Elem, class _Traits>
class basic_iostream : public basic_istream<_Elem, _Traits>,
                       public basic_ostream<_Elem, _Traits> { 
public:
    using _Myis       = basic_istream<_Elem, _Traits>;
    using _Myos       = basic_ostream<_Elem, _Traits>;
    using _Myios      = basic_ios<_Elem, _Traits>;
    using char_type   = _Elem;
    using traits_type = _Traits;
    using int_type    = typename _Traits::int_type;
    using pos_type    = typename _Traits::pos_type;
    using off_type    = typename _Traits::off_type;

    explicit  basic_iostream(basic_streambuf<_Elem, _Traits>* _Strbuf)
        : _Myis(_Strbuf, false), _Myos(_Noinit, false) {}

protected:
     basic_iostream(basic_iostream&& _Right) : _Myis(_Right.rdbuf(), false), _Myos(_Noinit, false) {
        _Myios::init();
        _Myios::move(::std:: move(_Right));
    }

    basic_iostream&  operator=(basic_iostream&& _Right) noexcept   {
        this->swap(_Right);
        return *this;
    }

    void  swap(basic_iostream& _Right) noexcept   {
        if (this != ::std:: addressof(_Right)) {
            _Myios::swap(_Right);
        }
    }

public:
     basic_iostream(const basic_iostream&)            = delete;
    basic_iostream&  operator=(const basic_iostream&) = delete;

     ~basic_iostream() noexcept override {}
};




template class __declspec(dllimport) basic_iostream<char, char_traits<char>>;
template class __declspec(dllimport) basic_iostream<wchar_t, char_traits<wchar_t>>;
#line 771 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\istream"




#line 776 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\istream"

template <class _Elem, class _Traits>
basic_istream<_Elem, _Traits>& _Istream_extract_into_buffer(
    basic_istream<_Elem, _Traits>& _Istr, size_t _Size, _Elem* _Str) {
    using _Myis              = basic_istream<_Elem, _Traits>;
    using _Ctype             = ctype<_Elem>;
    ios_base::iostate _State = ios_base::goodbit;
    size_t _Current          = 0;
    const typename _Myis::sentry _Ok(_Istr);

    if (_Ok) { 
        const _Ctype& _Ctype_fac = ::std:: use_facet<_Ctype>(_Istr.getloc());

        try {
        size_t _Count       = _Size;
        const size_t _Width = static_cast<size_t>(_Istr.width());
        if (_Width > 0 && _Width < _Size) {
            _Count = _Width;
        }

        typename _Myis::int_type _Meta = _Istr.rdbuf()->sgetc();
        _Elem _Ch;

        for (; _Current < _Count - 1; _Meta = _Istr.rdbuf()->snextc(), (void) ++_Current) {
            if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { 
                _State |= ios_base::eofbit;
                break;
            } else if (_Ctype_fac.is(_Ctype::space, _Ch = _Traits::to_char_type(_Meta)) || _Ch == _Elem()) {
                break; 
            } else {
                _Str[_Current] = _Traits::to_char_type(_Meta); 
            }
        }
        } catch (...) { (_Istr) .setstate(ios_base::badbit, true); }
    }
     ; 
    _Str[_Current] = _Elem(); 
    _Istr.width(0);
    if (_Current == 0) {
        _State |= ios_base::failbit;
    }
    _Istr.setstate(_State);
    return _Istr;
}


#pragma warning(push)
#pragma warning(disable : 6001) 
 template <class _Elem, class _Traits, size_t _Size>
basic_istream<_Elem, _Traits>& operator>>(
    basic_istream<_Elem, _Traits>& _Istr,  _Elem (&_Str)[_Size]) {
    return _Istream_extract_into_buffer(_Istr, _Size, _Str);
}

 template <class _Traits, size_t _Size>
basic_istream<char, _Traits>& operator>>(
    basic_istream<char, _Traits>& _Istr,  signed char (&_Str)[_Size]) {
    return _Istream_extract_into_buffer(_Istr, _Size, reinterpret_cast<char*>(_Str));
}

 template <class _Traits, size_t _Size>
basic_istream<char, _Traits>& operator>>(
    basic_istream<char, _Traits>& _Istr,  unsigned char (&_Str)[_Size]) {
    return _Istream_extract_into_buffer(_Istr, _Size, reinterpret_cast<char*>(_Str));
}
#pragma warning(pop)















#line 858 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\istream"

 template <class _Elem, class _Traits>
basic_istream<_Elem, _Traits>& operator>>(basic_istream<_Elem, _Traits>& _Istr, _Elem& _Ch) { 
    using _Myis = basic_istream<_Elem, _Traits>;

    typename _Myis::int_type _Meta;
    ios_base::iostate _State = ios_base::goodbit;
    const typename _Myis::sentry _Ok(_Istr);

    if (_Ok) { 
        try {
        _Meta = _Istr.rdbuf()->sbumpc();
        if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {
            _State |= ios_base::eofbit | ios_base::failbit; 
        } else {
            _Ch = _Traits::to_char_type(_Meta); 
        }
        } catch (...) { (_Istr) .setstate(ios_base::badbit, true); }
    }

    _Istr.setstate(_State);
    return _Istr;
}

 template <class _Traits>
basic_istream<char, _Traits>& operator>>(basic_istream<char, _Traits>& _Istr, signed char& _Ch) {
    
    return _Istr >> reinterpret_cast<char&>(_Ch);
}

 template <class _Traits>
basic_istream<char, _Traits>& operator>>(basic_istream<char, _Traits>& _Istr, unsigned char& _Ch) {
    
    return _Istr >> reinterpret_cast<char&>(_Ch);
}

template <class _Istr, class _Ty, class = void>
struct _Can_stream_in : false_type {};

template <class _Istr, class _Ty>
struct _Can_stream_in<_Istr, _Ty, void_t<decltype(::std:: declval<_Istr&>() >> ::std:: declval<_Ty>())>> : true_type {};

 template <class _Istr, class _Ty,
    enable_if_t<conjunction_v<is_convertible<_Istr*, ios_base*>, _Can_stream_in<_Istr, _Ty>>, int> = 0>
_Istr&& operator>>(_Istr&& _Is, _Ty&& _Val) { 
    _Is >> ::std:: forward<_Ty>(_Val);
    return ::std:: move(_Is);
}

 template <class _Elem, class _Traits>
basic_istream<_Elem, _Traits>& __cdecl ws(basic_istream<_Elem, _Traits>& _Istr) { 
    const typename basic_istream<_Elem, _Traits>::sentry _Ok(_Istr, true);

    if (_Ok) { 
        ios_base::iostate _State = ios_base::goodbit;
        const auto& _Ctype_fac   = ::std:: use_facet<ctype<_Elem>>(_Istr.getloc());

        try {
        for (typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();; _Meta = _Istr.rdbuf()->snextc()) {
            if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { 
                _State |= ios_base::eofbit;
                break;
            } else if (!_Ctype_fac.is(ctype<_Elem>::space, _Traits::to_char_type(_Meta))) {
                break; 
            }
        }
        } catch (...) { (_Istr) .setstate(ios_base::badbit, true); }
        _Istr.setstate(_State);
    }

    return _Istr;
}
}



#pragma warning(pop)
#pragma pack(pop)
#line 937 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\istream"
#line 938 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\istream"
#pragma external_header(pop)
#line 12 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iostream"

#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )



namespace std {



















 extern "C++"  __declspec(dllimport) istream cin;
 extern "C++"  __declspec(dllimport) ostream cout;
 extern "C++"  __declspec(dllimport) ostream cerr;
 extern "C++"  __declspec(dllimport) ostream clog;
extern "C++"  __declspec(dllimport) istream* _Ptr_cin;
extern "C++"  __declspec(dllimport) ostream* _Ptr_cout;
extern "C++"  __declspec(dllimport) ostream* _Ptr_cerr;
extern "C++"  __declspec(dllimport) ostream* _Ptr_clog;

 extern "C++"  __declspec(dllimport) wistream wcin;
 extern "C++"  __declspec(dllimport) wostream wcout;
 extern "C++"  __declspec(dllimport) wostream wcerr;
 extern "C++"  __declspec(dllimport) wostream wclog;
extern "C++"  __declspec(dllimport) wistream* _Ptr_wcin;
extern "C++"  __declspec(dllimport) wostream* _Ptr_wcout;
extern "C++"  __declspec(dllimport) wostream* _Ptr_wcerr;
extern "C++"  __declspec(dllimport) wostream* _Ptr_wclog;












#line 69 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iostream"
}


#pragma warning(pop)
#pragma pack(pop)
#line 75 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iostream"
#line 76 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\iostream"
#pragma external_header(pop)
#line 5 "D:\\dev\\DaisyEngine\\DaisyEngine\\src\\Model.h"
namespace Daisy
{
	class Model
	{
	public:
		Model(float vertices[], unsigned int indices[], unsigned int vertCount, unsigned int indicesCount);

		void Bind();
		void Unbind();
		void Flush();

	private:
		unsigned int VBO;
		unsigned int VAO;
		unsigned int EBO;
	};
}
#line 2 "D:\\dev\\DaisyEngine\\DaisyEngine\\src\\Model.cpp"

namespace Daisy
{
	Model::Model(float vertices[], unsigned int indices[], unsigned int vertCount, unsigned int indicesCount)
	{
		__glewGenVertexArrays (1, &VAO);
		__glewGenBuffers (1, &VBO);
		__glewGenBuffers (1, &EBO);

		__glewBindVertexArray (VAO);

		__glewBindBuffer (0x8892 , VBO);

		__glewBufferData (0x8892 , vertCount, vertices, 0x88E4 );
		__glewBindBuffer (0x8893 , EBO);
		__glewBufferData (0x8893 , indicesCount, indices, 0x88E4 );

		__glewVertexAttribPointer (0, 3, 0x1406 , 0 , 5 * sizeof(float), (void*)0);
		__glewEnableVertexAttribArray (0);
		__glewVertexAttribPointer (1, 2, 0x1406 , 0 , 5 * sizeof(float), (void*)(3 * sizeof(float)));
		__glewEnableVertexAttribArray (1);

		__glewBindBuffer (0x8892 , 0);
		__glewBindVertexArray (0);
	}

	void Model::Bind()
	{
		__glewBindVertexArray (VAO);
		__glewBindBuffer (0x8074 , VBO);
		__glewBindBuffer (0x8893 , EBO);
	}

	void Model::Unbind()
	{
		__glewBindVertexArray (0 );
		__glewBindBuffer (0x8074 , 0 );
		__glewBindBuffer (0x8893 , 0 );
	}

	void Model::Flush()
	{
		__glewDeleteVertexArrays (1, &VAO);
		__glewDeleteBuffers (1, &VBO);
		__glewDeleteBuffers (1, &EBO);
	}
}
