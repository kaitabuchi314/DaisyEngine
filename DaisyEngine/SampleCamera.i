#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\src\\SampleCamera.cpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\src\\SampleCamera.h"
#pragma once
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\GLFW\\glfw3.h"
































extern "C" {
#line 35 "D:\\dev\\DaisyEngine\\DaisyEngine\\GLFW\\glfw3.h"






























































#line 98 "D:\\dev\\DaisyEngine\\DaisyEngine\\GLFW\\glfw3.h"





#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stddef.h"







#pragma once



#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"







#pragma once

#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"







#pragma once






















#line 32 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"

#line 34 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
#line 35 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"


    
#line 39 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"






    
    

#line 49 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
        
            
        

#line 54 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
    #line 55 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
#line 56 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"

#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"













#pragma once







































































































































#line 151 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"



#line 155 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"





























#line 185 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"


#line 188 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"

#line 190 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"





#line 196 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"



#line 200 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"






#line 207 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"











#line 219 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"








#line 228 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"
#line 229 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"































































































































































































































































































































































































































































































#pragma region Input Buffer SAL 1 compatibility macros



























































































































































































































































































































































































































































































































































































































































































































































































#pragma endregion Input Buffer SAL 1 compatibility macros

















































































#line 1555 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"






























#line 1586 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"
























#line 1611 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"












#line 1624 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"






































#line 1663 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"















































































































#line 1775 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"






































































































#line 1878 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"








































































































































































#line 2047 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"





































































































#line 2149 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"



















































































































































































































#line 2361 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"
extern "C" {




#line 2367 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"



































































































































































































































#line 2595 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    

    
    

#line 2634 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"









































































































































































































































#line 2868 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"









#line 2878 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"





#line 2884 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"
    
#line 2886 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"
#line 2887 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"






#line 2894 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"
#line 2895 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"






#line 2902 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"
#line 2903 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"











#line 2915 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"

































#line 2949 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"






















}
#line 2973 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"

#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\concurrencysal.h"


















#pragma once


extern "C" {
#line 24 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\concurrencysal.h"











































































































































































































































































#line 292 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\concurrencysal.h"



#line 296 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\concurrencysal.h"
















































#line 345 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\concurrencysal.h"











































#line 389 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\concurrencysal.h"


}
#line 393 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\concurrencysal.h"

#line 395 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\concurrencysal.h"
#pragma external_header(pop)
#line 2975 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\sal.h"
#pragma external_header(pop)
#line 58 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"










#pragma once



#pragma pack(push, 8 )



    


        
    #line 24 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"
#line 25 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"




    


        
    #line 34 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"
#line 35 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"



    
#line 40 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"




    
#line 46 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"

#pragma warning(push)
#pragma warning(disable: 4514 4820 )


extern "C" {
#line 53 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"



#line 57 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"


    
    
        typedef unsigned __int64  uintptr_t;
    

#line 65 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"
#line 66 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"


    
    


        typedef char* va_list;
    #line 74 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"
#line 75 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"


    


#line 81 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"





#line 87 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"



#line 91 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"
    
    
#line 94 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"











#line 106 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"







#line 114 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"











#line 126 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"





#line 132 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"










#line 143 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"










#line 154 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"

    void __cdecl __va_start(va_list* , ...);

    
    



    

#line 165 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"


} 
#line 169 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"


    extern "C++"
    {
        template <typename _Ty>
        struct __vcrt_va_list_is_reference
        {
            enum : bool { __the_value = false };
        };

        template <typename _Ty>
        struct __vcrt_va_list_is_reference<_Ty&>
        {
            enum : bool { __the_value = true };
        };

        template <typename _Ty>
        struct __vcrt_va_list_is_reference<_Ty&&>
        {
            enum : bool { __the_value = true };
        };

        template <typename _Ty>
        struct __vcrt_assert_va_start_is_not_reference
        {
            static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value,
                "va_start argument must not have reference type and must not be parenthesized");
        };
    } 

    





#line 206 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vadefs.h"

#pragma warning(pop) 
#pragma pack(pop)
#pragma external_header(pop)
#line 59 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"

#pragma warning(push)
#pragma warning(disable: 4514 4820 )






    



    





















#line 95 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"

__pragma(pack(push, 8)) extern "C" {




    


        
    #line 106 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
#line 107 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
















    

#line 126 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"

#line 128 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
        
    #line 130 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
#line 131 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"


    

#line 136 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
        
    #line 138 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
#line 139 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"





#line 145 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
    
    
#line 148 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"




    
#line 154 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"








    


#line 166 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"



#line 170 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
    
#line 172 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"




    
#line 178 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"


    
        
        
    

#line 186 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
#line 187 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"






    typedef unsigned __int64 size_t;
    typedef __int64          ptrdiff_t;
    typedef __int64          intptr_t;




#line 201 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"


    typedef bool  __vcrt_bool;






#line 211 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"



    
#line 216 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"


    
#line 220 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"


    
#line 224 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"








    
        
    

#line 237 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
#line 238 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"


    


#line 244 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"



#line 248 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"


    extern "C++"
    {
        template <typename _CountofType, size_t _SizeOfArray>
        char (*__countof_helper(__unaligned _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];

        
    }


#line 260 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"



#line 264 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"


    

#line 269 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
        
    #line 271 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"


#line 274 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"


    
        
    

#line 281 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
#line 282 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"


    
        
    

#line 289 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
#line 290 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"


    

#line 295 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
        
    #line 297 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
#line 298 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"





#line 304 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"



#line 308 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"



    


        
    

#line 318 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
#line 319 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"


    


#line 325 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"









    
        
    

#line 339 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
#line 340 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"









#line 350 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"


    


        




    #line 361 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
#line 362 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"



#line 366 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"


    
        
    


#line 374 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
#line 375 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"


    void __cdecl __security_init_cookie(void);

    


#line 383 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"


#line 386 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
        void __cdecl __security_check_cookie( uintptr_t _StackCookie);
        __declspec(noreturn) void __cdecl __report_gsfailure( uintptr_t _StackCookie);
    #line 389 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
#line 390 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"

extern uintptr_t __security_cookie;


    
    
    
#line 398 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"

} __pragma(pack(pop))

#pragma warning(pop) 

#line 404 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime.h"
#pragma external_header(pop)
#line 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"







    

















        
    #line 38 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
#line 39 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"


    
#line 43 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"


    
        
    

#line 50 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
#line 51 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"

















    


        
    #line 73 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
#line 74 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"



    
#line 79 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"














    
#line 95 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"


    











        
    #line 111 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
#line 112 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"


    


        
    #line 119 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
#line 120 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"

#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {







    

#line 136 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
        
    

#line 140 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
#line 141 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"




    
#line 147 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"


    

#line 152 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
        
    

#line 156 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
#line 157 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"



#line 161 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
    
#line 163 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"


    


#line 169 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"





#line 175 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
    
#line 177 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"





    
#line 184 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"



#line 188 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
    
#line 190 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"









    
#line 201 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"













    


        
    #line 219 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
#line 220 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"



#line 224 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
    
#line 226 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"



#line 230 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
    
#line 232 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"



#line 236 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
    
#line 238 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"


    
        
    

#line 245 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
#line 246 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"








extern "C++"
{
    template<bool _Enable, typename _Ty>
    struct _CrtEnableIf;

    template<typename _Ty>
    struct _CrtEnableIf<true, _Ty>
    {
        typedef _Ty _Type;
    };
}
#line 266 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"


    typedef bool  __crt_bool;






#line 276 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"










    
        
    #line 289 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"








#line 298 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"



















    

#line 320 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
        
    #line 322 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
#line 323 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"



#line 327 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"


    
#line 331 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"


 
  
   
  

#line 339 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
 





#line 346 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
#line 347 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"


 

#line 352 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
   
 #line 354 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
#line 355 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
















__declspec(dllimport) void __cdecl _invalid_parameter_noinfo(void);
__declspec(dllimport) __declspec(noreturn) void __cdecl _invalid_parameter_noinfo_noreturn(void);

__declspec(noreturn)
__declspec(dllimport) void __cdecl _invoke_watson(
     wchar_t const* _Expression,
     wchar_t const* _FunctionName,
     wchar_t const* _FileName,
           unsigned int _LineNo,
           uintptr_t _Reserved);


    



        
        
        
        
        
        
        
        
        
        
        
        

    #line 401 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
#line 402 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"












    


#line 419 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"



#line 423 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"


    


        


    #line 432 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
#line 433 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"









    






        
    #line 451 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
#line 452 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"


    


        
    #line 459 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
#line 460 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"



#line 464 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"













#line 478 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"















#line 494 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"





    
#line 501 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"



#line 505 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"


    

#line 510 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
#line 511 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"


    


        


            
        #line 521 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
    #line 522 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
#line 523 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"



#line 527 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"





#line 533 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"


    


        



    #line 543 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
#line 544 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"


    
        
    



#line 553 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"

    
        
        
        
    



#line 563 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"

    
        
              
        

#line 570 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
    



#line 575 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"

    
        
    



#line 583 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"

    
        
    



#line 591 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
#line 592 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"


    
#line 596 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"








typedef int                           errno_t;
typedef unsigned short                wint_t;
typedef unsigned short                wctype_t;
typedef long                          __time32_t;
typedef __int64                       __time64_t;

typedef struct __crt_locale_data_public
{
      unsigned short const* _locale_pctype;
     int _locale_mb_cur_max;
               unsigned int _locale_lc_codepage;
} __crt_locale_data_public;

typedef struct __crt_locale_pointers
{
    struct __crt_locale_data*    locinfo;
    struct __crt_multibyte_data* mbcinfo;
} __crt_locale_pointers;

typedef __crt_locale_pointers* _locale_t;

typedef struct _Mbstatet
{ 
    unsigned long _Wchar;
    unsigned short _Byte, _State;
} _Mbstatet;

typedef _Mbstatet mbstate_t;



#line 636 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"



#line 640 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"


    


        typedef __time64_t time_t;
    #line 647 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
#line 648 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"



    
#line 653 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"


    typedef size_t rsize_t;
#line 657 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"










    

        










        










        










        










        










        










        










        










        










        












        












        
















    














#line 827 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
#line 828 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"












































































    













































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1879 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"

        
        
        
        

        

            


            


            


            


            


            


            


            


            



            



            


            


            


            


            


            


            


            


            


            


            



            



            



            


            



            




            

            




            

            




            

            




            

            




            

            




            

            




            

            




            

        











































#line 2069 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
    #line 2070 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"
#line 2071 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt.h"

} __pragma(pack(pop))


#pragma warning(pop) 
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stddef.h"

#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {




    namespace std
    {
        typedef decltype(__nullptr) nullptr_t;
    }

    using ::std::nullptr_t;
#line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stddef.h"





    __declspec(dllimport) int* __cdecl _errno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_errno( int _Value);
    __declspec(dllimport) errno_t __cdecl _get_errno( int* _Value);

#line 42 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stddef.h"









#line 52 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stddef.h"
    
#line 54 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stddef.h"

__declspec(dllimport) extern unsigned long  __cdecl __threadid(void);

__declspec(dllimport) extern uintptr_t __cdecl __threadhandle(void);



} __pragma(pack(pop))

#pragma warning(pop) 
#line 65 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stddef.h"
#pragma external_header(pop)
#line 104 "D:\\dev\\DaisyEngine\\DaisyEngine\\GLFW\\glfw3.h"




#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\stdint.h"







#pragma once






#pragma warning(push)
#pragma warning(disable: 4514 4820 )

typedef signed char        int8_t;
typedef short              int16_t;
typedef int                int32_t;
typedef long long          int64_t;
typedef unsigned char      uint8_t;
typedef unsigned short     uint16_t;
typedef unsigned int       uint32_t;
typedef unsigned long long uint64_t;

typedef signed char        int_least8_t;
typedef short              int_least16_t;
typedef int                int_least32_t;
typedef long long          int_least64_t;
typedef unsigned char      uint_least8_t;
typedef unsigned short     uint_least16_t;
typedef unsigned int       uint_least32_t;
typedef unsigned long long uint_least64_t;

typedef signed char        int_fast8_t;
typedef int                int_fast16_t;
typedef int                int_fast32_t;
typedef long long          int_fast64_t;
typedef unsigned char      uint_fast8_t;
typedef unsigned int       uint_fast16_t;
typedef unsigned int       uint_fast32_t;
typedef unsigned long long uint_fast64_t;

typedef long long          intmax_t;
typedef unsigned long long uintmax_t;










































    
    
    




#line 97 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\stdint.h"









    
    
        
    

#line 112 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\stdint.h"
#line 113 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\stdint.h"























#pragma warning(pop) 

#line 139 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\stdint.h"
#pragma external_header(pop)
#line 109 "D:\\dev\\DaisyEngine\\DaisyEngine\\GLFW\\glfw3.h"



#line 113 "D:\\dev\\DaisyEngine\\DaisyEngine\\GLFW\\glfw3.h"









 
  
 

#line 127 "D:\\dev\\DaisyEngine\\DaisyEngine\\GLFW\\glfw3.h"
 
#line 129 "D:\\dev\\DaisyEngine\\DaisyEngine\\GLFW\\glfw3.h"




 
 
#line 136 "D:\\dev\\DaisyEngine\\DaisyEngine\\GLFW\\glfw3.h"




 
 
#line 143 "D:\\dev\\DaisyEngine\\DaisyEngine\\GLFW\\glfw3.h"










#line 154 "D:\\dev\\DaisyEngine\\DaisyEngine\\GLFW\\glfw3.h"






#line 161 "D:\\dev\\DaisyEngine\\DaisyEngine\\GLFW\\glfw3.h"






#line 168 "D:\\dev\\DaisyEngine\\DaisyEngine\\GLFW\\glfw3.h"






#line 175 "D:\\dev\\DaisyEngine\\DaisyEngine\\GLFW\\glfw3.h"






#line 182 "D:\\dev\\DaisyEngine\\DaisyEngine\\GLFW\\glfw3.h"

















#line 200 "D:\\dev\\DaisyEngine\\DaisyEngine\\GLFW\\glfw3.h"















#line 216 "D:\\dev\\DaisyEngine\\DaisyEngine\\GLFW\\glfw3.h"

 






#line 240 "D:\\dev\\DaisyEngine\\DaisyEngine\\GLFW\\glfw3.h"

  #pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\um\\GL\\gl.h"





















#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared\\winapifamily.h"



















#pragma warning(push)
#pragma warning(disable:4001) 
#line 23 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared\\winapifamily.h"
#pragma once
#line 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared\\winapifamily.h"

#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared\\winpackagefamily.h"



















#pragma warning(push)
#pragma warning(disable:4001) 
#line 23 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared\\winpackagefamily.h"
#pragma once
#line 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared\\winpackagefamily.h"



#line 29 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared\\winpackagefamily.h"


























































#pragma warning(pop)
#line 89 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared\\winpackagefamily.h"
#line 90 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared\\winpackagefamily.h"

#line 92 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared\\winpackagefamily.h"
#pragma external_header(pop)
#line 27 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared\\winapifamily.h"















































 
 














#line 91 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared\\winapifamily.h"



















































#line 148 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared\\winapifamily.h"



#line 152 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared\\winapifamily.h"






#line 159 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared\\winapifamily.h"





#line 165 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared\\winapifamily.h"



#line 169 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared\\winapifamily.h"





#line 175 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared\\winapifamily.h"











#line 187 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared\\winapifamily.h"






































 

















#line 244 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared\\winapifamily.h"



#pragma warning(pop)
#line 249 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared\\winapifamily.h"
#line 250 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared\\winapifamily.h"

#line 252 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared\\winapifamily.h"
#pragma external_header(pop)
#line 23 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\um\\GL\\gl.h"


extern "C" {
#line 27 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\um\\GL\\gl.h"


















#pragma region Desktop Family


typedef unsigned int GLenum;
typedef unsigned char GLboolean;
typedef unsigned int GLbitfield;
typedef signed char GLbyte;
typedef short GLshort;
typedef int GLint;
typedef int GLsizei;
typedef unsigned char GLubyte;
typedef unsigned short GLushort;
typedef unsigned int GLuint;
typedef float GLfloat;
typedef float GLclampf;
typedef double GLdouble;
typedef double GLclampd;
typedef void GLvoid;

 

 


 






 









 






















 











 









 
 
 



 
 
 
 

 



 
 
 
 
 

 
 
 
 
 
 
 

 







 
 
 
 

 
 
 
 
 
 

 
 
 
 
 
 
 
 
 

 
 
 
 

 












 
 
 
 
 
 
 
 
 

 















 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 








 






 









 
 




 
 
 
 
 
 
 

 



 




 
 
 
 
 
 
 
 
 
 
 

 
 
 
 
 
 
 

 

















































































































































































































 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 
 
 
 
 





 
 
 
 
 
 
 
 

 




 
 
 
 
 
 
 

 
 
 
 
 

 
 
 
 

 









 











 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 



 
 
 
 
 
 
 
 
 
 
 

 

















 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 
 
 
 

 




 
 
 

 




 
 
 

 
 
 
 

 
 
 
 
 
 

 




 












 
 
 
 
 
 
 
 
 
 
 

 
 
 
 
 
 
 
 
 
 
 
 
 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 

 
 
 
 
 
 
 

 




 
 
 
 
 
 
 
 
 
 
 
 
 

 




 




 
 
 
 
 
 
 
 
 

 
 




 

 





 





 
 
 
 
 

 


 
 

 



 


 




 




 



 
 
 





 




 
 

 
 
 
 
 

 



 
 
 
 
 

 




 






 










































 





 









































 








 


































 



 

 
















 



 



 


 



 

__declspec(dllimport) void __stdcall glAccum (GLenum op, GLfloat value);
__declspec(dllimport) void __stdcall glAlphaFunc (GLenum func, GLclampf ref);
__declspec(dllimport) GLboolean __stdcall glAreTexturesResident (GLsizei n, const GLuint *textures, GLboolean *residences);
__declspec(dllimport) void __stdcall glArrayElement (GLint i);
__declspec(dllimport) void __stdcall glBegin (GLenum mode);
__declspec(dllimport) void __stdcall glBindTexture (GLenum target, GLuint texture);
__declspec(dllimport) void __stdcall glBitmap (GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap);
__declspec(dllimport) void __stdcall glBlendFunc (GLenum sfactor, GLenum dfactor);
__declspec(dllimport) void __stdcall glCallList (GLuint list);
__declspec(dllimport) void __stdcall glCallLists (GLsizei n, GLenum type, const GLvoid *lists);
__declspec(dllimport) void __stdcall glClear (GLbitfield mask);
__declspec(dllimport) void __stdcall glClearAccum (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
__declspec(dllimport) void __stdcall glClearColor (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
__declspec(dllimport) void __stdcall glClearDepth (GLclampd depth);
__declspec(dllimport) void __stdcall glClearIndex (GLfloat c);
__declspec(dllimport) void __stdcall glClearStencil (GLint s);
__declspec(dllimport) void __stdcall glClipPlane (GLenum plane, const GLdouble *equation);
__declspec(dllimport) void __stdcall glColor3b (GLbyte red, GLbyte green, GLbyte blue);
__declspec(dllimport) void __stdcall glColor3bv (const GLbyte *v);
__declspec(dllimport) void __stdcall glColor3d (GLdouble red, GLdouble green, GLdouble blue);
__declspec(dllimport) void __stdcall glColor3dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glColor3f (GLfloat red, GLfloat green, GLfloat blue);
__declspec(dllimport) void __stdcall glColor3fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glColor3i (GLint red, GLint green, GLint blue);
__declspec(dllimport) void __stdcall glColor3iv (const GLint *v);
__declspec(dllimport) void __stdcall glColor3s (GLshort red, GLshort green, GLshort blue);
__declspec(dllimport) void __stdcall glColor3sv (const GLshort *v);
__declspec(dllimport) void __stdcall glColor3ub (GLubyte red, GLubyte green, GLubyte blue);
__declspec(dllimport) void __stdcall glColor3ubv (const GLubyte *v);
__declspec(dllimport) void __stdcall glColor3ui (GLuint red, GLuint green, GLuint blue);
__declspec(dllimport) void __stdcall glColor3uiv (const GLuint *v);
__declspec(dllimport) void __stdcall glColor3us (GLushort red, GLushort green, GLushort blue);
__declspec(dllimport) void __stdcall glColor3usv (const GLushort *v);
__declspec(dllimport) void __stdcall glColor4b (GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha);
__declspec(dllimport) void __stdcall glColor4bv (const GLbyte *v);
__declspec(dllimport) void __stdcall glColor4d (GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha);
__declspec(dllimport) void __stdcall glColor4dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glColor4f (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
__declspec(dllimport) void __stdcall glColor4fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glColor4i (GLint red, GLint green, GLint blue, GLint alpha);
__declspec(dllimport) void __stdcall glColor4iv (const GLint *v);
__declspec(dllimport) void __stdcall glColor4s (GLshort red, GLshort green, GLshort blue, GLshort alpha);
__declspec(dllimport) void __stdcall glColor4sv (const GLshort *v);
__declspec(dllimport) void __stdcall glColor4ub (GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);
__declspec(dllimport) void __stdcall glColor4ubv (const GLubyte *v);
__declspec(dllimport) void __stdcall glColor4ui (GLuint red, GLuint green, GLuint blue, GLuint alpha);
__declspec(dllimport) void __stdcall glColor4uiv (const GLuint *v);
__declspec(dllimport) void __stdcall glColor4us (GLushort red, GLushort green, GLushort blue, GLushort alpha);
__declspec(dllimport) void __stdcall glColor4usv (const GLushort *v);
__declspec(dllimport) void __stdcall glColorMask (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
__declspec(dllimport) void __stdcall glColorMaterial (GLenum face, GLenum mode);
__declspec(dllimport) void __stdcall glColorPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
__declspec(dllimport) void __stdcall glCopyPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum type);
__declspec(dllimport) void __stdcall glCopyTexImage1D (GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLint border);
__declspec(dllimport) void __stdcall glCopyTexImage2D (GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
__declspec(dllimport) void __stdcall glCopyTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
__declspec(dllimport) void __stdcall glCopyTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
__declspec(dllimport) void __stdcall glCullFace (GLenum mode);
__declspec(dllimport) void __stdcall glDeleteLists (GLuint list, GLsizei range);
__declspec(dllimport) void __stdcall glDeleteTextures (GLsizei n, const GLuint *textures);
__declspec(dllimport) void __stdcall glDepthFunc (GLenum func);
__declspec(dllimport) void __stdcall glDepthMask (GLboolean flag);
__declspec(dllimport) void __stdcall glDepthRange (GLclampd zNear, GLclampd zFar);
__declspec(dllimport) void __stdcall glDisable (GLenum cap);
__declspec(dllimport) void __stdcall glDisableClientState (GLenum array);
__declspec(dllimport) void __stdcall glDrawArrays (GLenum mode, GLint first, GLsizei count);
__declspec(dllimport) void __stdcall glDrawBuffer (GLenum mode);
__declspec(dllimport) void __stdcall glDrawElements (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
__declspec(dllimport) void __stdcall glDrawPixels (GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
__declspec(dllimport) void __stdcall glEdgeFlag (GLboolean flag);
__declspec(dllimport) void __stdcall glEdgeFlagPointer (GLsizei stride, const GLvoid *pointer);
__declspec(dllimport) void __stdcall glEdgeFlagv (const GLboolean *flag);
__declspec(dllimport) void __stdcall glEnable (GLenum cap);
__declspec(dllimport) void __stdcall glEnableClientState (GLenum array);
__declspec(dllimport) void __stdcall glEnd (void);
__declspec(dllimport) void __stdcall glEndList (void);
__declspec(dllimport) void __stdcall glEvalCoord1d (GLdouble u);
__declspec(dllimport) void __stdcall glEvalCoord1dv (const GLdouble *u);
__declspec(dllimport) void __stdcall glEvalCoord1f (GLfloat u);
__declspec(dllimport) void __stdcall glEvalCoord1fv (const GLfloat *u);
__declspec(dllimport) void __stdcall glEvalCoord2d (GLdouble u, GLdouble v);
__declspec(dllimport) void __stdcall glEvalCoord2dv (const GLdouble *u);
__declspec(dllimport) void __stdcall glEvalCoord2f (GLfloat u, GLfloat v);
__declspec(dllimport) void __stdcall glEvalCoord2fv (const GLfloat *u);
__declspec(dllimport) void __stdcall glEvalMesh1 (GLenum mode, GLint i1, GLint i2);
__declspec(dllimport) void __stdcall glEvalMesh2 (GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2);
__declspec(dllimport) void __stdcall glEvalPoint1 (GLint i);
__declspec(dllimport) void __stdcall glEvalPoint2 (GLint i, GLint j);
__declspec(dllimport) void __stdcall glFeedbackBuffer (GLsizei size, GLenum type, GLfloat *buffer);
__declspec(dllimport) void __stdcall glFinish (void);
__declspec(dllimport) void __stdcall glFlush (void);
__declspec(dllimport) void __stdcall glFogf (GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glFogfv (GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glFogi (GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glFogiv (GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glFrontFace (GLenum mode);
__declspec(dllimport) void __stdcall glFrustum (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
__declspec(dllimport) GLuint __stdcall glGenLists (GLsizei range);
__declspec(dllimport) void __stdcall glGenTextures (GLsizei n, GLuint *textures);
__declspec(dllimport) void __stdcall glGetBooleanv (GLenum pname, GLboolean *params);
__declspec(dllimport) void __stdcall glGetClipPlane (GLenum plane, GLdouble *equation);
__declspec(dllimport) void __stdcall glGetDoublev (GLenum pname, GLdouble *params);
__declspec(dllimport) GLenum __stdcall glGetError (void);
__declspec(dllimport) void __stdcall glGetFloatv (GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetIntegerv (GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glGetLightfv (GLenum light, GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetLightiv (GLenum light, GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glGetMapdv (GLenum target, GLenum query, GLdouble *v);
__declspec(dllimport) void __stdcall glGetMapfv (GLenum target, GLenum query, GLfloat *v);
__declspec(dllimport) void __stdcall glGetMapiv (GLenum target, GLenum query, GLint *v);
__declspec(dllimport) void __stdcall glGetMaterialfv (GLenum face, GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetMaterialiv (GLenum face, GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glGetPixelMapfv (GLenum map, GLfloat *values);
__declspec(dllimport) void __stdcall glGetPixelMapuiv (GLenum map, GLuint *values);
__declspec(dllimport) void __stdcall glGetPixelMapusv (GLenum map, GLushort *values);
__declspec(dllimport) void __stdcall glGetPointerv (GLenum pname, GLvoid* *params);
__declspec(dllimport) void __stdcall glGetPolygonStipple (GLubyte *mask);
__declspec(dllimport) const GLubyte * __stdcall glGetString (GLenum name);
__declspec(dllimport) void __stdcall glGetTexEnvfv (GLenum target, GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetTexEnviv (GLenum target, GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glGetTexGendv (GLenum coord, GLenum pname, GLdouble *params);
__declspec(dllimport) void __stdcall glGetTexGenfv (GLenum coord, GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetTexGeniv (GLenum coord, GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glGetTexImage (GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels);
__declspec(dllimport) void __stdcall glGetTexLevelParameterfv (GLenum target, GLint level, GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetTexLevelParameteriv (GLenum target, GLint level, GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glGetTexParameterfv (GLenum target, GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetTexParameteriv (GLenum target, GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glHint (GLenum target, GLenum mode);
__declspec(dllimport) void __stdcall glIndexMask (GLuint mask);
__declspec(dllimport) void __stdcall glIndexPointer (GLenum type, GLsizei stride, const GLvoid *pointer);
__declspec(dllimport) void __stdcall glIndexd (GLdouble c);
__declspec(dllimport) void __stdcall glIndexdv (const GLdouble *c);
__declspec(dllimport) void __stdcall glIndexf (GLfloat c);
__declspec(dllimport) void __stdcall glIndexfv (const GLfloat *c);
__declspec(dllimport) void __stdcall glIndexi (GLint c);
__declspec(dllimport) void __stdcall glIndexiv (const GLint *c);
__declspec(dllimport) void __stdcall glIndexs (GLshort c);
__declspec(dllimport) void __stdcall glIndexsv (const GLshort *c);
__declspec(dllimport) void __stdcall glIndexub (GLubyte c);
__declspec(dllimport) void __stdcall glIndexubv (const GLubyte *c);
__declspec(dllimport) void __stdcall glInitNames (void);
__declspec(dllimport) void __stdcall glInterleavedArrays (GLenum format, GLsizei stride, const GLvoid *pointer);
__declspec(dllimport) GLboolean __stdcall glIsEnabled (GLenum cap);
__declspec(dllimport) GLboolean __stdcall glIsList (GLuint list);
__declspec(dllimport) GLboolean __stdcall glIsTexture (GLuint texture);
__declspec(dllimport) void __stdcall glLightModelf (GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glLightModelfv (GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glLightModeli (GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glLightModeliv (GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glLightf (GLenum light, GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glLightfv (GLenum light, GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glLighti (GLenum light, GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glLightiv (GLenum light, GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glLineStipple (GLint factor, GLushort pattern);
__declspec(dllimport) void __stdcall glLineWidth (GLfloat width);
__declspec(dllimport) void __stdcall glListBase (GLuint base);
__declspec(dllimport) void __stdcall glLoadIdentity (void);
__declspec(dllimport) void __stdcall glLoadMatrixd (const GLdouble *m);
__declspec(dllimport) void __stdcall glLoadMatrixf (const GLfloat *m);
__declspec(dllimport) void __stdcall glLoadName (GLuint name);
__declspec(dllimport) void __stdcall glLogicOp (GLenum opcode);
__declspec(dllimport) void __stdcall glMap1d (GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points);
__declspec(dllimport) void __stdcall glMap1f (GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points);
__declspec(dllimport) void __stdcall glMap2d (GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points);
__declspec(dllimport) void __stdcall glMap2f (GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points);
__declspec(dllimport) void __stdcall glMapGrid1d (GLint un, GLdouble u1, GLdouble u2);
__declspec(dllimport) void __stdcall glMapGrid1f (GLint un, GLfloat u1, GLfloat u2);
__declspec(dllimport) void __stdcall glMapGrid2d (GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2);
__declspec(dllimport) void __stdcall glMapGrid2f (GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2);
__declspec(dllimport) void __stdcall glMaterialf (GLenum face, GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glMaterialfv (GLenum face, GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glMateriali (GLenum face, GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glMaterialiv (GLenum face, GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glMatrixMode (GLenum mode);
__declspec(dllimport) void __stdcall glMultMatrixd (const GLdouble *m);
__declspec(dllimport) void __stdcall glMultMatrixf (const GLfloat *m);
__declspec(dllimport) void __stdcall glNewList (GLuint list, GLenum mode);
__declspec(dllimport) void __stdcall glNormal3b (GLbyte nx, GLbyte ny, GLbyte nz);
__declspec(dllimport) void __stdcall glNormal3bv (const GLbyte *v);
__declspec(dllimport) void __stdcall glNormal3d (GLdouble nx, GLdouble ny, GLdouble nz);
__declspec(dllimport) void __stdcall glNormal3dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glNormal3f (GLfloat nx, GLfloat ny, GLfloat nz);
__declspec(dllimport) void __stdcall glNormal3fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glNormal3i (GLint nx, GLint ny, GLint nz);
__declspec(dllimport) void __stdcall glNormal3iv (const GLint *v);
__declspec(dllimport) void __stdcall glNormal3s (GLshort nx, GLshort ny, GLshort nz);
__declspec(dllimport) void __stdcall glNormal3sv (const GLshort *v);
__declspec(dllimport) void __stdcall glNormalPointer (GLenum type, GLsizei stride, const GLvoid *pointer);
__declspec(dllimport) void __stdcall glOrtho (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
__declspec(dllimport) void __stdcall glPassThrough (GLfloat token);
__declspec(dllimport) void __stdcall glPixelMapfv (GLenum map, GLsizei mapsize, const GLfloat *values);
__declspec(dllimport) void __stdcall glPixelMapuiv (GLenum map, GLsizei mapsize, const GLuint *values);
__declspec(dllimport) void __stdcall glPixelMapusv (GLenum map, GLsizei mapsize, const GLushort *values);
__declspec(dllimport) void __stdcall glPixelStoref (GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glPixelStorei (GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glPixelTransferf (GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glPixelTransferi (GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glPixelZoom (GLfloat xfactor, GLfloat yfactor);
__declspec(dllimport) void __stdcall glPointSize (GLfloat size);
__declspec(dllimport) void __stdcall glPolygonMode (GLenum face, GLenum mode);
__declspec(dllimport) void __stdcall glPolygonOffset (GLfloat factor, GLfloat units);
__declspec(dllimport) void __stdcall glPolygonStipple (const GLubyte *mask);
__declspec(dllimport) void __stdcall glPopAttrib (void);
__declspec(dllimport) void __stdcall glPopClientAttrib (void);
__declspec(dllimport) void __stdcall glPopMatrix (void);
__declspec(dllimport) void __stdcall glPopName (void);
__declspec(dllimport) void __stdcall glPrioritizeTextures (GLsizei n, const GLuint *textures, const GLclampf *priorities);
__declspec(dllimport) void __stdcall glPushAttrib (GLbitfield mask);
__declspec(dllimport) void __stdcall glPushClientAttrib (GLbitfield mask);
__declspec(dllimport) void __stdcall glPushMatrix (void);
__declspec(dllimport) void __stdcall glPushName (GLuint name);
__declspec(dllimport) void __stdcall glRasterPos2d (GLdouble x, GLdouble y);
__declspec(dllimport) void __stdcall glRasterPos2dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glRasterPos2f (GLfloat x, GLfloat y);
__declspec(dllimport) void __stdcall glRasterPos2fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glRasterPos2i (GLint x, GLint y);
__declspec(dllimport) void __stdcall glRasterPos2iv (const GLint *v);
__declspec(dllimport) void __stdcall glRasterPos2s (GLshort x, GLshort y);
__declspec(dllimport) void __stdcall glRasterPos2sv (const GLshort *v);
__declspec(dllimport) void __stdcall glRasterPos3d (GLdouble x, GLdouble y, GLdouble z);
__declspec(dllimport) void __stdcall glRasterPos3dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glRasterPos3f (GLfloat x, GLfloat y, GLfloat z);
__declspec(dllimport) void __stdcall glRasterPos3fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glRasterPos3i (GLint x, GLint y, GLint z);
__declspec(dllimport) void __stdcall glRasterPos3iv (const GLint *v);
__declspec(dllimport) void __stdcall glRasterPos3s (GLshort x, GLshort y, GLshort z);
__declspec(dllimport) void __stdcall glRasterPos3sv (const GLshort *v);
__declspec(dllimport) void __stdcall glRasterPos4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
__declspec(dllimport) void __stdcall glRasterPos4dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glRasterPos4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
__declspec(dllimport) void __stdcall glRasterPos4fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glRasterPos4i (GLint x, GLint y, GLint z, GLint w);
__declspec(dllimport) void __stdcall glRasterPos4iv (const GLint *v);
__declspec(dllimport) void __stdcall glRasterPos4s (GLshort x, GLshort y, GLshort z, GLshort w);
__declspec(dllimport) void __stdcall glRasterPos4sv (const GLshort *v);
__declspec(dllimport) void __stdcall glReadBuffer (GLenum mode);
__declspec(dllimport) void __stdcall glReadPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);
__declspec(dllimport) void __stdcall glRectd (GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2);
__declspec(dllimport) void __stdcall glRectdv (const GLdouble *v1, const GLdouble *v2);
__declspec(dllimport) void __stdcall glRectf (GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2);
__declspec(dllimport) void __stdcall glRectfv (const GLfloat *v1, const GLfloat *v2);
__declspec(dllimport) void __stdcall glRecti (GLint x1, GLint y1, GLint x2, GLint y2);
__declspec(dllimport) void __stdcall glRectiv (const GLint *v1, const GLint *v2);
__declspec(dllimport) void __stdcall glRects (GLshort x1, GLshort y1, GLshort x2, GLshort y2);
__declspec(dllimport) void __stdcall glRectsv (const GLshort *v1, const GLshort *v2);
__declspec(dllimport) GLint __stdcall glRenderMode (GLenum mode);
__declspec(dllimport) void __stdcall glRotated (GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
__declspec(dllimport) void __stdcall glRotatef (GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
__declspec(dllimport) void __stdcall glScaled (GLdouble x, GLdouble y, GLdouble z);
__declspec(dllimport) void __stdcall glScalef (GLfloat x, GLfloat y, GLfloat z);
__declspec(dllimport) void __stdcall glScissor (GLint x, GLint y, GLsizei width, GLsizei height);
__declspec(dllimport) void __stdcall glSelectBuffer (GLsizei size, GLuint *buffer);
__declspec(dllimport) void __stdcall glShadeModel (GLenum mode);
__declspec(dllimport) void __stdcall glStencilFunc (GLenum func, GLint ref, GLuint mask);
__declspec(dllimport) void __stdcall glStencilMask (GLuint mask);
__declspec(dllimport) void __stdcall glStencilOp (GLenum fail, GLenum zfail, GLenum zpass);
__declspec(dllimport) void __stdcall glTexCoord1d (GLdouble s);
__declspec(dllimport) void __stdcall glTexCoord1dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glTexCoord1f (GLfloat s);
__declspec(dllimport) void __stdcall glTexCoord1fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glTexCoord1i (GLint s);
__declspec(dllimport) void __stdcall glTexCoord1iv (const GLint *v);
__declspec(dllimport) void __stdcall glTexCoord1s (GLshort s);
__declspec(dllimport) void __stdcall glTexCoord1sv (const GLshort *v);
__declspec(dllimport) void __stdcall glTexCoord2d (GLdouble s, GLdouble t);
__declspec(dllimport) void __stdcall glTexCoord2dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glTexCoord2f (GLfloat s, GLfloat t);
__declspec(dllimport) void __stdcall glTexCoord2fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glTexCoord2i (GLint s, GLint t);
__declspec(dllimport) void __stdcall glTexCoord2iv (const GLint *v);
__declspec(dllimport) void __stdcall glTexCoord2s (GLshort s, GLshort t);
__declspec(dllimport) void __stdcall glTexCoord2sv (const GLshort *v);
__declspec(dllimport) void __stdcall glTexCoord3d (GLdouble s, GLdouble t, GLdouble r);
__declspec(dllimport) void __stdcall glTexCoord3dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glTexCoord3f (GLfloat s, GLfloat t, GLfloat r);
__declspec(dllimport) void __stdcall glTexCoord3fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glTexCoord3i (GLint s, GLint t, GLint r);
__declspec(dllimport) void __stdcall glTexCoord3iv (const GLint *v);
__declspec(dllimport) void __stdcall glTexCoord3s (GLshort s, GLshort t, GLshort r);
__declspec(dllimport) void __stdcall glTexCoord3sv (const GLshort *v);
__declspec(dllimport) void __stdcall glTexCoord4d (GLdouble s, GLdouble t, GLdouble r, GLdouble q);
__declspec(dllimport) void __stdcall glTexCoord4dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glTexCoord4f (GLfloat s, GLfloat t, GLfloat r, GLfloat q);
__declspec(dllimport) void __stdcall glTexCoord4fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glTexCoord4i (GLint s, GLint t, GLint r, GLint q);
__declspec(dllimport) void __stdcall glTexCoord4iv (const GLint *v);
__declspec(dllimport) void __stdcall glTexCoord4s (GLshort s, GLshort t, GLshort r, GLshort q);
__declspec(dllimport) void __stdcall glTexCoord4sv (const GLshort *v);
__declspec(dllimport) void __stdcall glTexCoordPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
__declspec(dllimport) void __stdcall glTexEnvf (GLenum target, GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glTexEnvfv (GLenum target, GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glTexEnvi (GLenum target, GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glTexEnviv (GLenum target, GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glTexGend (GLenum coord, GLenum pname, GLdouble param);
__declspec(dllimport) void __stdcall glTexGendv (GLenum coord, GLenum pname, const GLdouble *params);
__declspec(dllimport) void __stdcall glTexGenf (GLenum coord, GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glTexGenfv (GLenum coord, GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glTexGeni (GLenum coord, GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glTexGeniv (GLenum coord, GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glTexImage1D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
__declspec(dllimport) void __stdcall glTexImage2D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
__declspec(dllimport) void __stdcall glTexParameterf (GLenum target, GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glTexParameterfv (GLenum target, GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glTexParameteri (GLenum target, GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glTexParameteriv (GLenum target, GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
__declspec(dllimport) void __stdcall glTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
__declspec(dllimport) void __stdcall glTranslated (GLdouble x, GLdouble y, GLdouble z);
__declspec(dllimport) void __stdcall glTranslatef (GLfloat x, GLfloat y, GLfloat z);
__declspec(dllimport) void __stdcall glVertex2d (GLdouble x, GLdouble y);
__declspec(dllimport) void __stdcall glVertex2dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glVertex2f (GLfloat x, GLfloat y);
__declspec(dllimport) void __stdcall glVertex2fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glVertex2i (GLint x, GLint y);
__declspec(dllimport) void __stdcall glVertex2iv (const GLint *v);
__declspec(dllimport) void __stdcall glVertex2s (GLshort x, GLshort y);
__declspec(dllimport) void __stdcall glVertex2sv (const GLshort *v);
__declspec(dllimport) void __stdcall glVertex3d (GLdouble x, GLdouble y, GLdouble z);
__declspec(dllimport) void __stdcall glVertex3dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glVertex3f (GLfloat x, GLfloat y, GLfloat z);
__declspec(dllimport) void __stdcall glVertex3fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glVertex3i (GLint x, GLint y, GLint z);
__declspec(dllimport) void __stdcall glVertex3iv (const GLint *v);
__declspec(dllimport) void __stdcall glVertex3s (GLshort x, GLshort y, GLshort z);
__declspec(dllimport) void __stdcall glVertex3sv (const GLshort *v);
__declspec(dllimport) void __stdcall glVertex4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
__declspec(dllimport) void __stdcall glVertex4dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glVertex4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
__declspec(dllimport) void __stdcall glVertex4fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glVertex4i (GLint x, GLint y, GLint z, GLint w);
__declspec(dllimport) void __stdcall glVertex4iv (const GLint *v);
__declspec(dllimport) void __stdcall glVertex4s (GLshort x, GLshort y, GLshort z, GLshort w);
__declspec(dllimport) void __stdcall glVertex4sv (const GLshort *v);
__declspec(dllimport) void __stdcall glVertexPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
__declspec(dllimport) void __stdcall glViewport (GLint x, GLint y, GLsizei width, GLsizei height);

 
typedef void (__stdcall * PFNGLARRAYELEMENTEXTPROC) (GLint i);
typedef void (__stdcall * PFNGLDRAWARRAYSEXTPROC) (GLenum mode, GLint first, GLsizei count);
typedef void (__stdcall * PFNGLVERTEXPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void (__stdcall * PFNGLNORMALPOINTEREXTPROC) (GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void (__stdcall * PFNGLCOLORPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void (__stdcall * PFNGLINDEXPOINTEREXTPROC) (GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void (__stdcall * PFNGLTEXCOORDPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void (__stdcall * PFNGLEDGEFLAGPOINTEREXTPROC) (GLsizei stride, GLsizei count, const GLboolean *pointer);
typedef void (__stdcall * PFNGLGETPOINTERVEXTPROC) (GLenum pname, GLvoid* *params);
typedef void (__stdcall * PFNGLARRAYELEMENTARRAYEXTPROC)(GLenum mode, GLsizei count, const GLvoid* pi);

 
typedef void (__stdcall * PFNGLDRAWRANGEELEMENTSWINPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);

 
typedef void (__stdcall * PFNGLADDSWAPHINTRECTWINPROC)  (GLint x, GLint y, GLsizei width, GLsizei height);

 
typedef void (__stdcall * PFNGLCOLORTABLEEXTPROC)
    (GLenum target, GLenum internalFormat, GLsizei width, GLenum format,
     GLenum type, const GLvoid *data);
typedef void (__stdcall * PFNGLCOLORSUBTABLEEXTPROC)
    (GLenum target, GLsizei start, GLsizei count, GLenum format,
     GLenum type, const GLvoid *data);
typedef void (__stdcall * PFNGLGETCOLORTABLEEXTPROC)
    (GLenum target, GLenum format, GLenum type, GLvoid *data);
typedef void (__stdcall * PFNGLGETCOLORTABLEPARAMETERIVEXTPROC)
    (GLenum target, GLenum pname, GLint *params);
typedef void (__stdcall * PFNGLGETCOLORTABLEPARAMETERFVEXTPROC)
    (GLenum target, GLenum pname, GLfloat *params);

#line 1527 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\um\\GL\\gl.h"
#pragma endregion


}
#line 1532 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\um\\GL\\gl.h"

#line 1534 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\um\\GL\\gl.h"
#line 1535 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\um\\GL\\gl.h"
#pragma external_header(pop)
#line 242 "D:\\dev\\DaisyEngine\\DaisyEngine\\GLFW\\glfw3.h"
  

#line 245 "D:\\dev\\DaisyEngine\\DaisyEngine\\GLFW\\glfw3.h"

 #line 247 "D:\\dev\\DaisyEngine\\DaisyEngine\\GLFW\\glfw3.h"

#line 249 "D:\\dev\\DaisyEngine\\DaisyEngine\\GLFW\\glfw3.h"







#line 257 "D:\\dev\\DaisyEngine\\DaisyEngine\\GLFW\\glfw3.h"







#line 265 "D:\\dev\\DaisyEngine\\DaisyEngine\\GLFW\\glfw3.h"


#line 268 "D:\\dev\\DaisyEngine\\DaisyEngine\\GLFW\\glfw3.h"


#line 271 "D:\\dev\\DaisyEngine\\DaisyEngine\\GLFW\\glfw3.h"
 
#line 273 "D:\\dev\\DaisyEngine\\DaisyEngine\\GLFW\\glfw3.h"





























 











































 






















 

























 



















































 









































































 










































 




















 

























 





























 















 
































































































































































































 































































































































































































































































































 





















































































































































 









































 













 




















typedef void (*GLFWglproc)(void);













typedef void (*GLFWvkproc)(void);











typedef struct GLFWmonitor GLFWmonitor;











typedef struct GLFWwindow GLFWwindow;











typedef struct GLFWcursor GLFWcursor;




















































typedef void* (* GLFWallocatefun)(size_t size, void* user);























































typedef void* (* GLFWreallocatefun)(void* block, size_t size, void* user);









































typedef void (* GLFWdeallocatefun)(void* block, void* user);























typedef void (* GLFWerrorfun)(int error_code, const char* description);






















typedef void (* GLFWwindowposfun)(GLFWwindow* window, int xpos, int ypos);





















typedef void (* GLFWwindowsizefun)(GLFWwindow* window, int width, int height);



















typedef void (* GLFWwindowclosefun)(GLFWwindow* window);



















typedef void (* GLFWwindowrefreshfun)(GLFWwindow* window);




















typedef void (* GLFWwindowfocusfun)(GLFWwindow* window, int focused);




















typedef void (* GLFWwindowiconifyfun)(GLFWwindow* window, int iconified);




















typedef void (* GLFWwindowmaximizefun)(GLFWwindow* window, int maximized);




















typedef void (* GLFWframebuffersizefun)(GLFWwindow* window, int width, int height);




















typedef void (* GLFWwindowcontentscalefun)(GLFWwindow* window, float xscale, float yscale);

























typedef void (* GLFWmousebuttonfun)(GLFWwindow* window, int button, int action, int mods);






















typedef void (* GLFWcursorposfun)(GLFWwindow* window, double xpos, double ypos);




















typedef void (* GLFWcursorenterfun)(GLFWwindow* window, int entered);




















typedef void (* GLFWscrollfun)(GLFWwindow* window, double xoffset, double yoffset);

























typedef void (* GLFWkeyfun)(GLFWwindow* window, int key, int scancode, int action, int mods);




















typedef void (* GLFWcharfun)(GLFWwindow* window, unsigned int codepoint);


























typedef void (* GLFWcharmodsfun)(GLFWwindow* window, unsigned int codepoint, int mods);























typedef void (* GLFWdropfun)(GLFWwindow* window, int path_count, const char* paths[]);




















typedef void (* GLFWmonitorfun)(GLFWmonitor* monitor, int event);




















typedef void (* GLFWjoystickfun)(int jid, int event);














typedef struct GLFWvidmode
{
    

    int width;
    

    int height;
    

    int redBits;
    

    int greenBits;
    

    int blueBits;
    

    int refreshRate;
} GLFWvidmode;













typedef struct GLFWgammaramp
{
    

    unsigned short* red;
    

    unsigned short* green;
    

    unsigned short* blue;
    

    unsigned int size;
} GLFWgammaramp;














typedef struct GLFWimage
{
    

    int width;
    

    int height;
    

    unsigned char* pixels;
} GLFWimage;












typedef struct GLFWgamepadstate
{
    


    unsigned char buttons[15];
    


    float axes[6];
} GLFWgamepadstate;













typedef struct GLFWallocator
{
    


    GLFWallocatefun allocate;
    


    GLFWreallocatefun reallocate;
    


    GLFWdeallocatefun deallocate;
    


    void* user;
} GLFWallocator;
































































 int glfwInit(void);

































 void glfwTerminate(void);































 void glfwInitHint(int hint, int value);






























 void glfwInitAllocator(const GLFWallocator* allocator);















































#line 2366 "D:\\dev\\DaisyEngine\\DaisyEngine\\GLFW\\glfw3.h"


























 void glfwGetVersion(int* major, int* minor, int* rev);

































 const char* glfwGetVersionString(void);






























 int glfwGetError(const char** description);













































 GLFWerrorfun glfwSetErrorCallback(GLFWerrorfun callback);




















 int glfwGetPlatform(void);























 int glfwPlatformSupported(int platform);




























 GLFWmonitor** glfwGetMonitors(int* count);























 GLFWmonitor* glfwGetPrimaryMonitor(void);
























 void glfwGetMonitorPos(GLFWmonitor* monitor, int* xpos, int* ypos);






























 void glfwGetMonitorWorkarea(GLFWmonitor* monitor, int* xpos, int* ypos, int* width, int* height);


































 void glfwGetMonitorPhysicalSize(GLFWmonitor* monitor, int* widthMM, int* heightMM);


































 void glfwGetMonitorContentScale(GLFWmonitor* monitor, float* xscale, float* yscale);

























 const char* glfwGetMonitorName(GLFWmonitor* monitor);

























 void glfwSetMonitorUserPointer(GLFWmonitor* monitor, void* pointer);























 void* glfwGetMonitorUserPointer(GLFWmonitor* monitor);





























 GLFWmonitorfun glfwSetMonitorCallback(GLFWmonitorfun callback);

































 const GLFWvidmode* glfwGetVideoModes(GLFWmonitor* monitor, int* count);



























 const GLFWvidmode* glfwGetVideoMode(GLFWmonitor* monitor);
































 void glfwSetGamma(GLFWmonitor* monitor, float gamma);





























 const GLFWgammaramp* glfwGetGammaRamp(GLFWmonitor* monitor);








































 void glfwSetGammaRamp(GLFWmonitor* monitor, const GLFWgammaramp* ramp);


















 void glfwDefaultWindowHints(void);


































 void glfwWindowHint(int hint, int value);





































 void glfwWindowHintString(int hint, const char* value);















































































































































 GLFWwindow* glfwCreateWindow(int width, int height, const char* title, GLFWmonitor* monitor, GLFWwindow* share);




























 void glfwDestroyWindow(GLFWwindow* window);



















 int glfwWindowShouldClose(GLFWwindow* window);





















 void glfwSetWindowShouldClose(GLFWwindow* window, int value);































 const char* glfwGetWindowTitle(GLFWwindow* window);

























 void glfwSetWindowTitle(GLFWwindow* window, const char* title);
















































 void glfwSetWindowIcon(GLFWwindow* window, int count, const GLFWimage* images);































 void glfwGetWindowPos(GLFWwindow* window, int* xpos, int* ypos);


































 void glfwSetWindowPos(GLFWwindow* window, int xpos, int ypos);





























 void glfwGetWindowSize(GLFWwindow* window, int* width, int* height);










































 void glfwSetWindowSizeLimits(GLFWwindow* window, int minwidth, int minheight, int maxwidth, int maxheight);










































 void glfwSetWindowAspectRatio(GLFWwindow* window, int numer, int denom);





































 void glfwSetWindowSize(GLFWwindow* window, int width, int height);




























 void glfwGetFramebufferSize(GLFWwindow* window, int* width, int* height);




































 void glfwGetWindowFrameSize(GLFWwindow* window, int* left, int* top, int* right, int* bottom);
































 void glfwGetWindowContentScale(GLFWwindow* window, float* xscale, float* yscale);


























 float glfwGetWindowOpacity(GLFWwindow* window);































 void glfwSetWindowOpacity(GLFWwindow* window, float opacity);































 void glfwIconifyWindow(GLFWwindow* window);


























 void glfwRestoreWindow(GLFWwindow* window);
























 void glfwMaximizeWindow(GLFWwindow* window);































 void glfwShowWindow(GLFWwindow* window);





















 void glfwHideWindow(GLFWwindow* window);






































 void glfwFocusWindow(GLFWwindow* window);


























 void glfwRequestWindowAttention(GLFWwindow* window);





















 GLFWmonitor* glfwGetWindowMonitor(GLFWwindow* window);























































 void glfwSetWindowMonitor(GLFWwindow* window, GLFWmonitor* monitor, int xpos, int ypos, int width, int height, int refreshRate);




































 int glfwGetWindowAttrib(GLFWwindow* window, int attrib);









































 void glfwSetWindowAttrib(GLFWwindow* window, int attrib, int value);






















 void glfwSetWindowUserPointer(GLFWwindow* window, void* pointer);




















 void* glfwGetWindowUserPointer(GLFWwindow* window);


































 GLFWwindowposfun glfwSetWindowPosCallback(GLFWwindow* window, GLFWwindowposfun callback);































 GLFWwindowsizefun glfwSetWindowSizeCallback(GLFWwindow* window, GLFWwindowsizefun callback);







































 GLFWwindowclosefun glfwSetWindowCloseCallback(GLFWwindow* window, GLFWwindowclosefun callback);



































 GLFWwindowrefreshfun glfwSetWindowRefreshCallback(GLFWwindow* window, GLFWwindowrefreshfun callback);


































 GLFWwindowfocusfun glfwSetWindowFocusCallback(GLFWwindow* window, GLFWwindowfocusfun callback);





























 GLFWwindowiconifyfun glfwSetWindowIconifyCallback(GLFWwindow* window, GLFWwindowiconifyfun callback);





























 GLFWwindowmaximizefun glfwSetWindowMaximizeCallback(GLFWwindow* window, GLFWwindowmaximizefun callback);





























 GLFWframebuffersizefun glfwSetFramebufferSizeCallback(GLFWwindow* window, GLFWframebuffersizefun callback);






























 GLFWwindowcontentscalefun glfwSetWindowContentScaleCallback(GLFWwindow* window, GLFWwindowcontentscalefun callback);





































 void glfwPollEvents(void);












































 void glfwWaitEvents(void);
















































 void glfwWaitEventsTimeout(double timeout);



















 void glfwPostEmptyEvent(void);
























 int glfwGetInputMode(GLFWwindow* window, int mode);
































































 void glfwSetInputMode(GLFWwindow* window, int mode, int value);




























 int glfwRawMouseMotionSupported(void);



































































 const char* glfwGetKeyName(int key, int scancode);


























 int glfwGetKeyScancode(int key);






































 int glfwGetKey(GLFWwindow* window, int key);




























 int glfwGetMouseButton(GLFWwindow* window, int button);





































 void glfwGetCursorPos(GLFWwindow* window, double* xpos, double* ypos);







































 void glfwSetCursorPos(GLFWwindow* window, double xpos, double ypos);





































 GLFWcursor* glfwCreateCursor(const GLFWimage* image, int xhot, int yhot);















































 GLFWcursor* glfwCreateStandardCursor(int shape);


























 void glfwDestroyCursor(GLFWcursor* cursor);


























 void glfwSetCursor(GLFWwindow* window, GLFWcursor* cursor);

















































 GLFWkeyfun glfwSetKeyCallback(GLFWwindow* window, GLFWkeyfun callback);










































 GLFWcharfun glfwSetCharCallback(GLFWwindow* window, GLFWcharfun callback);









































 GLFWcharmodsfun glfwSetCharModsCallback(GLFWwindow* window, GLFWcharmodsfun callback);




































 GLFWmousebuttonfun glfwSetMouseButtonCallback(GLFWwindow* window, GLFWmousebuttonfun callback);































 GLFWcursorposfun glfwSetCursorPosCallback(GLFWwindow* window, GLFWcursorposfun callback);






























 GLFWcursorenterfun glfwSetCursorEnterCallback(GLFWwindow* window, GLFWcursorenterfun callback);

































 GLFWscrollfun glfwSetScrollCallback(GLFWwindow* window, GLFWscrollfun callback);


































 GLFWdropfun glfwSetDropCallback(GLFWwindow* window, GLFWdropfun callback);























 int glfwJoystickPresent(int jid);
































 const float* glfwGetJoystickAxes(int jid, int* count);








































 const unsigned char* glfwGetJoystickButtons(int jid, int* count);
























































 const unsigned char* glfwGetJoystickHats(int jid, int* count);






























 const char* glfwGetJoystickName(int jid);








































 const char* glfwGetJoystickGUID(int jid);

























 void glfwSetJoystickUserPointer(int jid, void* pointer);























 void* glfwGetJoystickUserPointer(int jid);



























 int glfwJoystickIsGamepad(int jid);



































 GLFWjoystickfun glfwSetJoystickCallback(GLFWjoystickfun callback);

































 int glfwUpdateGamepadMappings(const char* string);































 const char* glfwGetGamepadName(int jid);





































 int glfwGetGamepadState(int jid, GLFWgamepadstate* state);





























 void glfwSetClipboardString(GLFWwindow* window, const char* string);


































 const char* glfwGetClipboardString(GLFWwindow* window);





























 double glfwGetTime(void);





























 void glfwSetTime(double time);





















 uint64_t glfwGetTimerValue(void);



















 uint64_t glfwGetTimerFrequency(void);












































 void glfwMakeContextCurrent(GLFWwindow* window);




















 GLFWwindow* glfwGetCurrentContext(void);

































 void glfwSwapBuffers(GLFWwindow* window);













































 void glfwSwapInterval(int interval);





































 int glfwExtensionSupported(const char* extension);









































 GLFWglproc glfwGetProcAddress(const char* procname);

























 int glfwVulkanSupported(void);











































 const char** glfwGetRequiredInstanceExtensions(uint32_t* count);























































































































































#line 6513 "D:\\dev\\DaisyEngine\\DaisyEngine\\GLFW\\glfw3.h"






 


 
 
#line 6525 "D:\\dev\\DaisyEngine\\DaisyEngine\\GLFW\\glfw3.h"


 
 
#line 6530 "D:\\dev\\DaisyEngine\\DaisyEngine\\GLFW\\glfw3.h"





 
 
#line 6538 "D:\\dev\\DaisyEngine\\DaisyEngine\\GLFW\\glfw3.h"

 



}
#line 6545 "D:\\dev\\DaisyEngine\\DaisyEngine\\GLFW\\glfw3.h"

#line 6547 "D:\\dev\\DaisyEngine\\DaisyEngine\\GLFW\\glfw3.h"

#line 3 "D:\\dev\\DaisyEngine\\DaisyEngine\\src\\SampleCamera.h"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\glm.hpp"







































































































#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\_fixes.hpp"
#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"





#pragma once


#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"





#pragma once


#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"





#pragma once








#line 16 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"

#line 18 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"
#line 19 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"































































































































































































































































































































































































































































#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#pragma once

























#line 33 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 39 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 45 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 51 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 57 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 63 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 69 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 75 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 81 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 87 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 93 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 99 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 105 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 111 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 117 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 123 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 129 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 135 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 141 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 147 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 153 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 159 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 165 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 171 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 177 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 183 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 189 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 195 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 201 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 207 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 213 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 219 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 225 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 231 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 237 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 243 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 249 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 255 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 261 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 267 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 273 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 279 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 285 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 291 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 297 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"






#line 304 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 310 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 316 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 322 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 328 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 334 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 340 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 346 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 352 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 358 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 364 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 370 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 376 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 382 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 388 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 394 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 400 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 406 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 412 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 418 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 424 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 430 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 436 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 442 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 448 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 454 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 460 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 466 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 472 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 478 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 484 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 490 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 496 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 502 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 508 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 514 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"






#line 521 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 527 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 533 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 539 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"






#line 546 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 552 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 558 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"







#line 566 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 572 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 578 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"





#line 584 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"



#line 588 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"

#line 590 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"
#line 591 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xkeycheck.h"
#pragma external_header(pop)
#line 467 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"





#line 473 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"

#line 475 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"














#line 490 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"

#line 492 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"
#line 493 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 497 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 501 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"







#line 509 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"













#line 523 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"










#line 534 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 538 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"

#line 540 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"





















































































#line 626 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"































#line 658 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"

#line 660 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"







#line 668 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"







#line 676 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"







#line 684 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"













#line 698 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"




#line 703 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"

#line 705 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"




#line 710 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"

#line 712 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 716 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"






































#line 755 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"






















#line 778 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"
#line 779 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"






#line 786 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"
#line 787 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"











#line 799 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 803 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"
#line 804 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"







#line 812 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"

#line 814 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"
#line 815 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"










#line 826 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"

#line 828 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 832 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"


#line 835 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"


#line 838 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"
#line 839 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 843 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 847 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"









#line 857 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"






#line 864 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"




#line 869 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"

#line 871 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"




#line 876 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"

#line 878 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"






#line 885 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"




#line 890 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"




#line 895 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 899 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"




#line 904 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"




#line 909 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"







#line 917 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"




#line 922 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"














#line 937 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"






#line 944 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"










#line 955 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"










#line 966 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"





#line 972 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"








#line 981 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"
#line 982 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"














#line 998 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"









#line 1009 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"











#line 1022 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"












#line 1036 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"











#line 1049 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"













#line 1064 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"











#line 1077 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"










#line 1089 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"










#line 1101 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"











#line 1114 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"















#line 1131 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"










#line 1143 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"
















#line 1161 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"
















#line 1178 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"















#line 1195 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"












#line 1209 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"











#line 1221 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"












#line 1234 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"












#line 1248 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"











#line 1261 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"









#line 1271 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"











#line 1284 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"










#line 1296 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"










#line 1308 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"









#line 1319 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"









#line 1330 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"










#line 1342 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"










#line 1354 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"








#line 1364 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"

#line 1366 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"








#line 1376 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"

#line 1378 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"









#line 1388 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"










#line 1399 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"














#line 1414 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 1418 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 1422 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 1426 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 1430 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 1434 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 1438 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 1442 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 1446 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 1450 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 1454 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"






#line 1461 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"




#line 1466 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"





#line 1472 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"




#line 1477 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"




#line 1482 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"


















#line 1501 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"


























#line 1528 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"





#line 1534 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"

















#line 1552 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"






#line 1559 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"






#line 1566 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 1570 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"





#line 1576 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"

#line 1578 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"
#line 1579 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 1583 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"






























#line 1614 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"










#line 1625 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"
#line 1626 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"






#line 1633 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"
#line 1634 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"








#line 1643 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"








#line 1652 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"








#line 1661 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"





#line 1667 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"

























































#line 1725 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"






#line 1732 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"







#line 1740 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 1744 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"

#line 1746 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"






#line 1753 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"
#line 1754 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 1758 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 1762 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"




#line 1767 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"

#line 1769 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"
#line 1770 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"





#line 1776 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 1780 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"

#line 1782 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"





#line 1788 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"





































#line 1826 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 1830 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"



#line 1834 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"












#line 1847 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"


#line 1850 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"


#line 1853 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"
#line 1854 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"





#line 1860 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"







#line 1868 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"





#line 1874 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"

#line 1876 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"
#line 1877 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals_core.h"
#pragma external_header(pop)
#line 10 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"







#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\crtdbg.h"







#pragma once




#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime_new_debug.h"







#pragma once

#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime_new.h"







#pragma once



#pragma warning(push)
#pragma warning(disable: 4514 4820 )
#pragma warning(disable: 4985) 


extern "C++" {

#pragma pack(push, 8 )





namespace std
{
    enum class align_val_t : size_t {};
}
#line 30 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime_new.h"



    namespace std
    {
        struct nothrow_t {
            explicit nothrow_t() = default;
        };

        


            extern nothrow_t const nothrow;
        #line 44 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime_new.h"
    }
#line 46 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime_new.h"

[[nodiscard]]   __declspec(allocator)
void* __cdecl operator new(
    size_t _Size
    );

[[nodiscard]]    __declspec(allocator)
void* __cdecl operator new(
    size_t _Size,
    ::std::nothrow_t const&
    ) noexcept;

[[nodiscard]]   __declspec(allocator)
void* __cdecl operator new[](
    size_t _Size
    );

[[nodiscard]]    __declspec(allocator)
void* __cdecl operator new[](
    size_t _Size,
    ::std::nothrow_t const&
    ) noexcept;

void __cdecl operator delete(
    void* _Block
    ) noexcept;

void __cdecl operator delete(
    void* _Block,
    ::std::nothrow_t const&
    ) noexcept;

void __cdecl operator delete[](
    void* _Block
    ) noexcept;

void __cdecl operator delete[](
    void* _Block,
    ::std::nothrow_t const&
    ) noexcept;

void __cdecl operator delete(
    void*  _Block,
    size_t _Size
    ) noexcept;

void __cdecl operator delete[](
    void* _Block,
    size_t _Size
    ) noexcept;


[[nodiscard]]   __declspec(allocator)
void* __cdecl operator new(
    size_t             _Size,
    ::std::align_val_t _Al
    );

[[nodiscard]]    __declspec(allocator)
void* __cdecl operator new(
    size_t                  _Size,
    ::std::align_val_t      _Al,
    ::std::nothrow_t const&
    ) noexcept;


[[nodiscard]]   __declspec(allocator)
void* __cdecl operator new[](
    size_t             _Size,
    ::std::align_val_t _Al
    );

[[nodiscard]]    __declspec(allocator)
void* __cdecl operator new[](
    size_t                  _Size,
    ::std::align_val_t      _Al,
    ::std::nothrow_t const&
    ) noexcept;

void __cdecl operator delete(
    void*              _Block,
    ::std::align_val_t _Al
    ) noexcept;

void __cdecl operator delete(
    void*                   _Block,
    ::std::align_val_t      _Al,
    ::std::nothrow_t const&
    ) noexcept;

void __cdecl operator delete[](
    void*              _Block,
    ::std::align_val_t _Al
    ) noexcept;

void __cdecl operator delete[](
    void*                   _Block,
    ::std::align_val_t      _Al,
    ::std::nothrow_t const&
    ) noexcept;

void __cdecl operator delete(
    void*              _Block,
    size_t             _Size,
    ::std::align_val_t _Al
    ) noexcept;

void __cdecl operator delete[](
    void*              _Block,
    size_t             _Size,
    ::std::align_val_t _Al
    ) noexcept;
#line 159 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime_new.h"

#pragma warning(push)
#pragma warning(disable: 4577) 
#pragma warning(disable: 4514) 

    
    [[nodiscard]] [[msvc::constexpr]]   
    inline void* __cdecl operator new(size_t _Size,
         void* _Where) noexcept
    {
        (void)_Size;
        return _Where;
    }

    inline void __cdecl operator delete(void*, void*) noexcept
    {
        return;
    }
#line 178 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime_new.h"


    
    [[nodiscard]]   
    inline void* __cdecl operator new[](size_t _Size,
         void* _Where) noexcept
    {
        (void)_Size;
        return _Where;
    }

    inline void __cdecl operator delete[](void*, void*) noexcept
    {
    }
#line 193 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime_new.h"
#pragma warning(pop)



#pragma pack(pop)

} 
#line 201 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime_new.h"

#pragma warning(pop) 
#pragma external_header(pop)
#line 11 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime_new_debug.h"

#pragma warning(push)
#pragma warning(disable: 4514 4820 )


extern "C++" {

#pragma pack(push, 8 )






    [[nodiscard]]   
    __declspec(allocator) void* __cdecl operator new(
           size_t      _Size,
           int         _BlockUse,
         char const* _FileName,
           int         _LineNumber
        );

    [[nodiscard]]   
    __declspec(allocator) void* __cdecl operator new[](
           size_t      _Size,
           int         _BlockUse,
         char const* _FileName,
           int         _LineNumber
        );

    void __cdecl operator delete(
        void*       _Block,
        int         _BlockUse,
        char const* _FileName,
        int         _LineNumber
        ) noexcept;

    void __cdecl operator delete[](
        void*       _Block,
        int         _BlockUse,
        char const* _FileName,
        int         _LineNumber
        ) noexcept;

#line 56 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime_new_debug.h"



#pragma pack(pop)

} 
#line 63 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime_new_debug.h"

#pragma warning(pop) 
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\crtdbg.h"

#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {



typedef void* _HFILE; 

























typedef int (__cdecl * _CRT_REPORT_HOOK )(int, char*,    int*);
typedef int (__cdecl * _CRT_REPORT_HOOKW)(int, wchar_t*, int*);





typedef int (__cdecl * _CRT_ALLOC_HOOK)(int, void*, size_t, int, long, unsigned char const*, int);























































typedef void (__cdecl * _CRT_DUMP_CLIENT)(void*, size_t);





struct _CrtMemBlockHeader;

typedef struct _CrtMemState
{
    struct _CrtMemBlockHeader* pBlockHeader;
    size_t lCounts[5 ];
    size_t lSizes[5 ];
    size_t lHighWaterCount;
    size_t lTotalCount;
} _CrtMemState;



    
    

    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
























































































#line 239 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\crtdbg.h"










    
    
    
    
    
    
    

    
    
    
    
    
    
    
    

    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

















































































































































































































































































































#line 590 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\crtdbg.h"











    
    
    
    
    
    
    

















































































#line 690 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\crtdbg.h"











    

    
        
    #line 706 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\crtdbg.h"

    
        
    #line 710 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\crtdbg.h"

    
        
    #line 714 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\crtdbg.h"

    
    

    
    

    
    

    
    












































#line 771 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\crtdbg.h"













    
#line 786 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\crtdbg.h"



























} __pragma(pack(pop))

#pragma warning(pop) 
#line 817 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\crtdbg.h"
#pragma external_header(pop)
#line 18 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"
#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\crtdefs.h"




















    

#line 24 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\crtdefs.h"
        
    #line 26 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\crtdefs.h"
#line 27 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\crtdefs.h"



    

#line 33 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\crtdefs.h"
        
    #line 35 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\crtdefs.h"
#line 36 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\crtdefs.h"



    

#line 42 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\crtdefs.h"
        
    #line 44 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\crtdefs.h"
#line 45 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\crtdefs.h"





    


#line 54 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\crtdefs.h"
        
        
    


#line 60 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\crtdefs.h"
#line 61 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\crtdefs.h"


    

#line 66 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\crtdefs.h"
        
            
        

#line 71 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\crtdefs.h"
    #line 72 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\crtdefs.h"
#line 73 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\crtdefs.h"


    

#line 78 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\crtdefs.h"

#line 80 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\crtdefs.h"
        
    #line 82 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\crtdefs.h"
#line 83 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\crtdefs.h"
#pragma external_header(pop)
#line 19 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"

#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )












#line 36 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"

#line 38 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"















#line 54 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"
#line 55 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"
#line 56 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"






















































#line 111 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"
#line 112 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"









#line 122 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"

#line 124 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"
#line 125 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"




#line 130 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"

#line 132 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"

#line 134 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"

#line 136 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"


#pragma detect_mismatch("_MSC_VER", "1900")
#line 140 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"


#pragma detect_mismatch("_ITERATOR_DEBUG_LEVEL", "0" )
#line 144 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"




#line 149 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"

#line 151 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"
#pragma detect_mismatch("RuntimeLibrary", "MD_DynamicRelease")


#line 155 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"
#line 156 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"






#line 163 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"
#line 164 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"



#line 168 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"






#line 175 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"

#line 177 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"
#line 178 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"





























#line 208 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"





#line 214 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"





#line 220 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"






#line 227 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"
#line 228 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"



#line 232 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"

#line 234 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"


#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\use_ansi.h"





#pragma once








#line 16 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\use_ansi.h"
















#line 33 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\use_ansi.h"









#line 43 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\use_ansi.h"




#line 48 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\use_ansi.h"

#pragma comment(lib, "msvcprt" "" "" )






#line 57 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\use_ansi.h"

#line 59 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\use_ansi.h"

#line 61 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\use_ansi.h"
#pragma external_header(pop)
#line 237 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"

















#line 255 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"






#line 262 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"
#line 263 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"



#line 267 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"






#line 274 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"
#line 275 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"












#line 288 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"



#line 292 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"
#line 293 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"






#line 300 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"
#line 301 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"






#line 308 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"
#line 309 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"




#line 314 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"

#line 316 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"
#line 317 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"
















#line 334 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"

#line 336 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"
#line 337 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"



#line 341 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"



#line 345 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"

namespace std {
enum _Uninitialized { 
    _Noinit
};

extern "C++" class __declspec(dllimport) _Lockit { 
public:














    __thiscall _Lockit() noexcept;
    explicit __thiscall _Lockit(int) noexcept; 
    __thiscall ~_Lockit() noexcept; 
#line 371 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"

    static void __cdecl _Lockit_ctor(int) noexcept;
    static void __cdecl _Lockit_dtor(int) noexcept;

private:
    static void __cdecl _Lockit_ctor(_Lockit*) noexcept;
    static void __cdecl _Lockit_ctor(_Lockit*, int) noexcept;
    static void __cdecl _Lockit_dtor(_Lockit*) noexcept;

public:
     _Lockit(const _Lockit&)            = delete;
    _Lockit&  operator=(const _Lockit&) = delete;

private:
    int _Locktype;
};



































































#line 455 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"

















































#line 505 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"
}



#pragma warning(pop)
#pragma pack(pop)
#line 512 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"
#line 513 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\yvals.h"
#pragma external_header(pop)
#line 10 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"


#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cstdlib"





#pragma once





#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\math.h"










#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_math.h"







#pragma once





#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {


    
    
    struct _exception
    {
        int    type;   
        char*  name;   
        double arg1;   
        double arg2;   
        double retval; 
    };

    
    
    
        

        struct _complex
        {
            double x, y; 
        };

        


#line 46 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_math.h"
    #line 47 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_math.h"
#line 48 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_math.h"










#line 59 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_math.h"
    typedef float  float_t;
    typedef double double_t;
#line 62 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_math.h"















    
        extern double const _HUGE;
    

#line 82 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_math.h"
#line 83 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_math.h"


    
#line 87 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_math.h"











#line 99 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_math.h"












































































void __cdecl _fperrraise( int _Except);

 __declspec(dllimport) short __cdecl _dclass( double _X);
 __declspec(dllimport) short __cdecl _ldclass( long double _X);
 __declspec(dllimport) short __cdecl _fdclass( float _X);

 __declspec(dllimport) int __cdecl _dsign( double _X);
 __declspec(dllimport) int __cdecl _ldsign( long double _X);
 __declspec(dllimport) int __cdecl _fdsign( float _X);

 __declspec(dllimport) int __cdecl _dpcomp( double _X,  double _Y);
 __declspec(dllimport) int __cdecl _ldpcomp( long double _X,  long double _Y);
 __declspec(dllimport) int __cdecl _fdpcomp( float _X,  float _Y);

 __declspec(dllimport) short __cdecl _dtest( double* _Px);
 __declspec(dllimport) short __cdecl _ldtest( long double* _Px);
 __declspec(dllimport) short __cdecl _fdtest( float* _Px);

__declspec(dllimport) short __cdecl _d_int( double* _Px,  short _Xexp);
__declspec(dllimport) short __cdecl _ld_int( long double* _Px,  short _Xexp);
__declspec(dllimport) short __cdecl _fd_int( float* _Px,  short _Xexp);

__declspec(dllimport) short __cdecl _dscale( double* _Px,  long _Lexp);
__declspec(dllimport) short __cdecl _ldscale( long double* _Px,  long _Lexp);
__declspec(dllimport) short __cdecl _fdscale( float* _Px,  long _Lexp);

__declspec(dllimport) short __cdecl _dunscale( short* _Pex,  double* _Px);
__declspec(dllimport) short __cdecl _ldunscale( short* _Pex,  long double* _Px);
__declspec(dllimport) short __cdecl _fdunscale( short* _Pex,  float* _Px);

 __declspec(dllimport) short __cdecl _dexp( double* _Px,  double _Y,  long _Eoff);
 __declspec(dllimport) short __cdecl _ldexp( long double* _Px,  long double _Y,  long _Eoff);
 __declspec(dllimport) short __cdecl _fdexp( float* _Px,  float _Y,  long _Eoff);

 __declspec(dllimport) short __cdecl _dnorm( unsigned short* _Ps);
 __declspec(dllimport) short __cdecl _fdnorm( unsigned short* _Ps);

 __declspec(dllimport) double __cdecl _dpoly( double _X,  double const* _Tab,  int _N);
 __declspec(dllimport) long double __cdecl _ldpoly( long double _X,  long double const* _Tab,  int _N);
 __declspec(dllimport) float __cdecl _fdpoly( float _X,  float const* _Tab,  int _N);

 __declspec(dllimport) double __cdecl _dlog( double _X,  int _Baseflag);
 __declspec(dllimport) long double __cdecl _ldlog( long double _X,  int _Baseflag);
 __declspec(dllimport) float __cdecl _fdlog( float _X,  int _Baseflag);

 __declspec(dllimport) double __cdecl _dsin( double _X,  unsigned int _Qoff);
 __declspec(dllimport) long double __cdecl _ldsin( long double _X,  unsigned int _Qoff);
 __declspec(dllimport) float __cdecl _fdsin( float _X,  unsigned int _Qoff);


typedef union
{   
    unsigned short _Sh[4];
    double _Val;
} _double_val;


typedef union
{   
    unsigned short _Sh[2];
    float _Val;
} _float_val;


typedef union
{   
    unsigned short _Sh[4];
    long double _Val;
} _ldouble_val;

typedef union
{   
    unsigned short _Word[4];
    float _Float;
    double _Double;
    long double _Long_double;
} _float_const;

extern const _float_const _Denorm_C,  _Inf_C,  _Nan_C,  _Snan_C, _Hugeval_C;
extern const _float_const _FDenorm_C, _FInf_C, _FNan_C, _FSnan_C;
extern const _float_const _LDenorm_C, _LInf_C, _LNan_C, _LSnan_C;

extern const _float_const _Eps_C,  _Rteps_C;
extern const _float_const _FEps_C, _FRteps_C;
extern const _float_const _LEps_C, _LRteps_C;

extern const double      _Zero_C,  _Xbig_C;
extern const float       _FZero_C, _FXbig_C;
extern const long double _LZero_C, _LXbig_C;




























extern "C++"
{
     inline int fpclassify( float _X) throw()
    {
        return _fdtest(&_X);
    }

     inline int fpclassify( double _X) throw()
    {
        return _dtest(&_X);
    }

     inline int fpclassify( long double _X) throw()
    {
        return _ldtest(&_X);
    }

     inline bool signbit( float _X) throw()
    {
        return _fdsign(_X) != 0;
    }

     inline bool signbit( double _X) throw()
    {
        return _dsign(_X) != 0;
    }

     inline bool signbit( long double _X) throw()
    {
        return _ldsign(_X) != 0;
    }

     inline int _fpcomp( float _X,  float _Y) throw()
    {
        return _fdpcomp(_X, _Y);
    }

     inline int _fpcomp( double _X,  double _Y) throw()
    {
        return _dpcomp(_X, _Y);
    }

     inline int _fpcomp( long double _X,  long double _Y) throw()
    {
        return _ldpcomp(_X, _Y);
    }

    template <class _Trc, class _Tre> struct _Combined_type
    {   
        typedef float _Type;
    };

    template <> struct _Combined_type<float, double>
    {   
        typedef double _Type;
    };

    template <> struct _Combined_type<float, long double>
    {   
        typedef long double _Type;
    };

    template <class _Ty, class _T2> struct _Real_widened
    {   
        typedef long double _Type;
    };

    template <> struct _Real_widened<float, float>
    {   
        typedef float _Type;
    };

    template <> struct _Real_widened<float, double>
    {   
        typedef double _Type;
    };

    template <> struct _Real_widened<double, float>
    {   
        typedef double _Type;
    };

    template <> struct _Real_widened<double, double>
    {   
        typedef double _Type;
    };

    template <class _Ty> struct _Real_type
    {   
        typedef double _Type;   
    };

    template <> struct _Real_type<float>
    {   
        typedef float _Type;
    };

    template <> struct _Real_type<long double>
    {   
        typedef long double _Type;
    };

    template <class _T1, class _T2>
     inline int _fpcomp( _T1 _X,  _T2 _Y) throw()
    {   
        typedef typename _Combined_type<float,
            typename _Real_widened<
            typename _Real_type<_T1>::_Type,
            typename _Real_type<_T2>::_Type>::_Type>::_Type _Tw;
        return _fpcomp((_Tw)_X, (_Tw)_Y);
    }

    template <class _Ty>
     inline bool isfinite( _Ty _X) throw()
    {
        return fpclassify(_X) <= 0;
    }

    template <class _Ty>
     inline bool isinf( _Ty _X) throw()
    {
        return fpclassify(_X) == 1 ;
    }

    template <class _Ty>
     inline bool isnan( _Ty _X) throw()
    {
        return fpclassify(_X) == 2 ;
    }

    template <class _Ty>
     inline bool isnormal( _Ty _X) throw()
    {
        return fpclassify(_X) == (-1) ;
    }

    template <class _Ty1, class _Ty2>
     inline bool isgreater( _Ty1 _X,  _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & 4 ) != 0;
    }

    template <class _Ty1, class _Ty2>
     inline bool isgreaterequal( _Ty1 _X,  _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (2 | 4 )) != 0;
    }

    template <class _Ty1, class _Ty2>
     inline bool isless( _Ty1 _X,  _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & 1 ) != 0;
    }

    template <class _Ty1, class _Ty2>
     inline bool islessequal( _Ty1 _X,  _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (1 | 2 )) != 0;
    }

    template <class _Ty1, class _Ty2>
     inline bool islessgreater( _Ty1 _X,  _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (1 | 4 )) != 0;
    }

    template <class _Ty1, class _Ty2>
     inline bool isunordered( _Ty1 _X,  _Ty2 _Y) throw()
    {
        return _fpcomp(_X, _Y) == 0;
    }
}  
#line 465 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_math.h"





     int       __cdecl abs( int _X);
     long      __cdecl labs( long _X);
     long long __cdecl llabs( long long _X);

     double __cdecl acos( double _X);
     double __cdecl asin( double _X);
     double __cdecl atan( double _X);
     double __cdecl atan2( double _Y,  double _X);

     double __cdecl cos( double _X);
     double __cdecl cosh( double _X);
     double __cdecl exp( double _X);
      double __cdecl fabs( double _X);
     double __cdecl fmod( double _X,  double _Y);
     double __cdecl log( double _X);
     double __cdecl log10( double _X);
     double __cdecl pow( double _X,  double _Y);
     double __cdecl sin( double _X);
     double __cdecl sinh( double _X);
      double __cdecl sqrt( double _X);
     double __cdecl tan( double _X);
     double __cdecl tanh( double _X);

     __declspec(dllimport) double    __cdecl acosh( double _X);
     __declspec(dllimport) double    __cdecl asinh( double _X);
     __declspec(dllimport) double    __cdecl atanh( double _X);
     __declspec(dllimport)  double    __cdecl atof( char const* _String);
     __declspec(dllimport)  double    __cdecl _atof_l( char const* _String,  _locale_t _Locale);
     __declspec(dllimport) double    __cdecl _cabs( struct _complex _Complex_value);
     __declspec(dllimport) double    __cdecl cbrt( double _X);
     __declspec(dllimport) double    __cdecl ceil( double _X);
     __declspec(dllimport) double    __cdecl _chgsign( double _X);
     __declspec(dllimport) double    __cdecl copysign( double _Number,  double _Sign);
     __declspec(dllimport) double    __cdecl _copysign( double _Number,  double _Sign);
     __declspec(dllimport) double    __cdecl erf( double _X);
     __declspec(dllimport) double    __cdecl erfc( double _X);
     __declspec(dllimport) double    __cdecl exp2( double _X);
     __declspec(dllimport) double    __cdecl expm1( double _X);
     __declspec(dllimport) double    __cdecl fdim( double _X,  double _Y);
     __declspec(dllimport) double    __cdecl floor( double _X);
     __declspec(dllimport) double    __cdecl fma( double _X,  double _Y,  double _Z);
     __declspec(dllimport) double    __cdecl fmax( double _X,  double _Y);
     __declspec(dllimport) double    __cdecl fmin( double _X,  double _Y);
     __declspec(dllimport) double    __cdecl frexp( double _X,  int* _Y);
     __declspec(dllimport) double    __cdecl hypot( double _X,  double _Y);
     __declspec(dllimport) double    __cdecl _hypot( double _X,  double _Y);
     __declspec(dllimport) int       __cdecl ilogb( double _X);
     __declspec(dllimport) double    __cdecl ldexp( double _X,  int _Y);
     __declspec(dllimport) double    __cdecl lgamma( double _X);
     __declspec(dllimport) long long __cdecl llrint( double _X);
     __declspec(dllimport) long long __cdecl llround( double _X);
     __declspec(dllimport) double    __cdecl log1p( double _X);
     __declspec(dllimport) double    __cdecl log2( double _X);
     __declspec(dllimport) double    __cdecl logb( double _X);
     __declspec(dllimport) long      __cdecl lrint( double _X);
     __declspec(dllimport) long      __cdecl lround( double _X);

    int __cdecl _matherr( struct _exception* _Except);

     __declspec(dllimport) double __cdecl modf( double _X,  double* _Y);
     __declspec(dllimport) double __cdecl nan( char const* _X);
     __declspec(dllimport) double __cdecl nearbyint( double _X);
     __declspec(dllimport) double __cdecl nextafter( double _X,  double _Y);
     __declspec(dllimport) double __cdecl nexttoward( double _X,  long double _Y);
     __declspec(dllimport) double __cdecl remainder( double _X,  double _Y);
     __declspec(dllimport) double __cdecl remquo( double _X,  double _Y,  int* _Z);
     __declspec(dllimport) double __cdecl rint( double _X);
     __declspec(dllimport) double __cdecl round( double _X);
     __declspec(dllimport) double __cdecl scalbln( double _X,  long _Y);
     __declspec(dllimport) double __cdecl scalbn( double _X,  int _Y);
     __declspec(dllimport) double __cdecl tgamma( double _X);
     __declspec(dllimport) double __cdecl trunc( double _X);
     __declspec(dllimport) double __cdecl _j0( double _X );
     __declspec(dllimport) double __cdecl _j1( double _X );
     __declspec(dllimport) double __cdecl _jn(int _X,  double _Y);
     __declspec(dllimport) double __cdecl _y0( double _X);
     __declspec(dllimport) double __cdecl _y1( double _X);
     __declspec(dllimport) double __cdecl _yn( int _X,  double _Y);

     __declspec(dllimport) float     __cdecl acoshf( float _X);
     __declspec(dllimport) float     __cdecl asinhf( float _X);
     __declspec(dllimport) float     __cdecl atanhf( float _X);
     __declspec(dllimport) float     __cdecl cbrtf( float _X);
     __declspec(dllimport) float     __cdecl _chgsignf( float _X);
     __declspec(dllimport) float     __cdecl copysignf( float _Number,  float _Sign);
     __declspec(dllimport) float     __cdecl _copysignf( float _Number,  float _Sign);
     __declspec(dllimport) float     __cdecl erff( float _X);
     __declspec(dllimport) float     __cdecl erfcf( float _X);
     __declspec(dllimport) float     __cdecl expm1f( float _X);
     __declspec(dllimport) float     __cdecl exp2f( float _X);
     __declspec(dllimport) float     __cdecl fdimf( float _X,  float _Y);
     __declspec(dllimport) float     __cdecl fmaf( float _X,  float _Y,  float _Z);
     __declspec(dllimport) float     __cdecl fmaxf( float _X,  float _Y);
     __declspec(dllimport) float     __cdecl fminf( float _X,  float _Y);
     __declspec(dllimport) float     __cdecl _hypotf( float _X,  float _Y);
     __declspec(dllimport) int       __cdecl ilogbf( float _X);
     __declspec(dllimport) float     __cdecl lgammaf( float _X);
     __declspec(dllimport) long long __cdecl llrintf( float _X);
     __declspec(dllimport) long long __cdecl llroundf( float _X);
     __declspec(dllimport) float     __cdecl log1pf( float _X);
     __declspec(dllimport) float     __cdecl log2f( float _X);
     __declspec(dllimport) float     __cdecl logbf( float _X);
     __declspec(dllimport) long      __cdecl lrintf( float _X);
     __declspec(dllimport) long      __cdecl lroundf( float _X);
     __declspec(dllimport) float     __cdecl nanf( char const* _X);
     __declspec(dllimport) float     __cdecl nearbyintf( float _X);
     __declspec(dllimport) float     __cdecl nextafterf( float _X,  float _Y);
     __declspec(dllimport) float     __cdecl nexttowardf( float _X,  long double _Y);
     __declspec(dllimport) float     __cdecl remainderf( float _X,  float _Y);
     __declspec(dllimport) float     __cdecl remquof( float _X,  float _Y,  int* _Z);
     __declspec(dllimport) float     __cdecl rintf( float _X);
     __declspec(dllimport) float     __cdecl roundf( float _X);
     __declspec(dllimport) float     __cdecl scalblnf( float _X,  long _Y);
     __declspec(dllimport) float     __cdecl scalbnf( float _X,  int _Y);
     __declspec(dllimport) float     __cdecl tgammaf( float _X);
     __declspec(dllimport) float     __cdecl truncf( float _X);

    



#line 592 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_math.h"

    

         __declspec(dllimport) float __cdecl _logbf( float _X);
         __declspec(dllimport) float __cdecl _nextafterf( float _X,  float _Y);
         __declspec(dllimport) int   __cdecl _finitef( float _X);
         __declspec(dllimport) int   __cdecl _isnanf( float _X);
         __declspec(dllimport) int   __cdecl _fpclassf( float _X);

         __declspec(dllimport) int   __cdecl _set_FMA3_enable( int _Flag);
         __declspec(dllimport) int   __cdecl _get_FMA3_enable(void);

    




#line 610 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_math.h"



    

         __declspec(dllimport) float __cdecl acosf( float _X);
         __declspec(dllimport) float __cdecl asinf( float _X);
         __declspec(dllimport) float __cdecl atan2f( float _Y,  float _X);
         __declspec(dllimport) float __cdecl atanf( float _X);
         __declspec(dllimport) float __cdecl ceilf( float _X);
         __declspec(dllimport) float __cdecl cosf( float _X);
         __declspec(dllimport) float __cdecl coshf( float _X);
         __declspec(dllimport) float __cdecl expf( float _X);

    









































#line 667 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_math.h"

    



#line 673 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_math.h"

         __inline float __cdecl fabsf( float _X)
        {
            return (float)fabs(_X);
        }

    #line 680 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_math.h"

    

         __declspec(dllimport) float __cdecl floorf( float _X);
         __declspec(dllimport) float __cdecl fmodf( float _X,  float _Y);

    











#line 699 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_math.h"

     __inline float __cdecl frexpf( float _X,  int *_Y)
    {
        return (float)frexp(_X, _Y);
    }

     __inline float __cdecl hypotf( float _X,  float _Y)
    {
        return _hypotf(_X, _Y);
    }

     __inline float __cdecl ldexpf( float _X,  int _Y)
    {
        return (float)ldexp(_X, _Y);
    }

    

         __declspec(dllimport) float  __cdecl log10f( float _X);
         __declspec(dllimport) float  __cdecl logf( float _X);
         __declspec(dllimport) float  __cdecl modff( float _X,  float *_Y);
         __declspec(dllimport) float  __cdecl powf( float _X,  float _Y);
         __declspec(dllimport) float  __cdecl sinf( float _X);
         __declspec(dllimport) float  __cdecl sinhf( float _X);
         __declspec(dllimport) float  __cdecl sqrtf( float _X);
         __declspec(dllimport) float  __cdecl tanf( float _X);
         __declspec(dllimport) float  __cdecl tanhf( float _X);

    

















































#line 778 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_math.h"

     __declspec(dllimport) long double __cdecl acoshl( long double _X);

     __inline long double __cdecl acosl( long double _X)
    {
        return acos((double)_X);
    }

     __declspec(dllimport) long double __cdecl asinhl( long double _X);

     __inline long double __cdecl asinl( long double _X)
    {
        return asin((double)_X);
    }

     __inline long double __cdecl atan2l( long double _Y,  long double _X)
    {
        return atan2((double)_Y, (double)_X);
    }

     __declspec(dllimport) long double __cdecl atanhl( long double _X);

     __inline long double __cdecl atanl( long double _X)
    {
        return atan((double)_X);
    }

     __declspec(dllimport) long double __cdecl cbrtl( long double _X);

     __inline long double __cdecl ceill( long double _X)
    {
        return ceil((double)_X);
    }

     __inline long double __cdecl _chgsignl( long double _X)
    {
        return _chgsign((double)_X);
    }

     __declspec(dllimport) long double __cdecl copysignl( long double _Number,  long double _Sign);

     __inline long double __cdecl _copysignl( long double _Number,  long double _Sign)
    {
        return _copysign((double)_Number, (double)_Sign);
    }

     __inline long double __cdecl coshl( long double _X)
    {
        return cosh((double)_X);
    }

     __inline long double __cdecl cosl( long double _X)
    {
        return cos((double)_X);
    }

     __declspec(dllimport) long double __cdecl erfl( long double _X);
     __declspec(dllimport) long double __cdecl erfcl( long double _X);

     __inline long double __cdecl expl( long double _X)
    {
        return exp((double)_X);
    }

     __declspec(dllimport) long double __cdecl exp2l( long double _X);
     __declspec(dllimport) long double __cdecl expm1l( long double _X);

     __inline long double __cdecl fabsl( long double _X)
    {
        return fabs((double)_X);
    }

     __declspec(dllimport) long double __cdecl fdiml( long double _X,  long double _Y);

     __inline long double __cdecl floorl( long double _X)
    {
        return floor((double)_X);
    }

     __declspec(dllimport) long double __cdecl fmal( long double _X,  long double _Y,  long double _Z);
     __declspec(dllimport) long double __cdecl fmaxl( long double _X,  long double _Y);
     __declspec(dllimport) long double __cdecl fminl( long double _X,  long double _Y);

     __inline long double __cdecl fmodl( long double _X,  long double _Y)
    {
        return fmod((double)_X, (double)_Y);
    }

     __inline long double __cdecl frexpl( long double _X,  int *_Y)
    {
        return frexp((double)_X, _Y);
    }

     __declspec(dllimport) int __cdecl ilogbl( long double _X);

     __inline long double __cdecl _hypotl( long double _X,  long double _Y)
    {
        return _hypot((double)_X, (double)_Y);
    }

     __inline long double __cdecl hypotl( long double _X,  long double _Y)
    {
        return _hypot((double)_X, (double)_Y);
    }

     __inline long double __cdecl ldexpl( long double _X,  int _Y)
    {
        return ldexp((double)_X, _Y);
    }

     __declspec(dllimport) long double __cdecl lgammal( long double _X);
     __declspec(dllimport) long long __cdecl llrintl( long double _X);
     __declspec(dllimport) long long __cdecl llroundl( long double _X);

     __inline long double __cdecl logl( long double _X)
    {
        return log((double)_X);
    }

     __inline long double __cdecl log10l( long double _X)
    {
        return log10((double)_X);
    }

     __declspec(dllimport) long double __cdecl log1pl( long double _X);
     __declspec(dllimport) long double __cdecl log2l( long double _X);
     __declspec(dllimport) long double __cdecl logbl( long double _X);
     __declspec(dllimport) long __cdecl lrintl( long double _X);
     __declspec(dllimport) long __cdecl lroundl( long double _X);

     __inline long double __cdecl modfl( long double _X,  long double* _Y)
    {
        double _F, _I;
        _F = modf((double)_X, &_I);
        *_Y = _I;
        return _F;
    }

     __declspec(dllimport) long double __cdecl nanl( char const* _X);
     __declspec(dllimport) long double __cdecl nearbyintl( long double _X);
     __declspec(dllimport) long double __cdecl nextafterl( long double _X,  long double _Y);
     __declspec(dllimport) long double __cdecl nexttowardl( long double _X,  long double _Y);

     __inline long double __cdecl powl( long double _X,  long double _Y)
    {
        return pow((double)_X, (double)_Y);
    }

     __declspec(dllimport) long double __cdecl remainderl( long double _X,  long double _Y);
     __declspec(dllimport) long double __cdecl remquol( long double _X,  long double _Y,  int* _Z);
     __declspec(dllimport) long double __cdecl rintl( long double _X);
     __declspec(dllimport) long double __cdecl roundl( long double _X);
     __declspec(dllimport) long double __cdecl scalblnl( long double _X,  long _Y);
     __declspec(dllimport) long double __cdecl scalbnl( long double _X,  int _Y);

     __inline long double __cdecl sinhl( long double _X)
    {
        return sinh((double)_X);
    }

     __inline long double __cdecl sinl( long double _X)
    {
        return sin((double)_X);
    }

     __inline long double __cdecl sqrtl( long double _X)
    {
        return sqrt((double)_X);
    }

     __inline long double __cdecl tanhl( long double _X)
    {
        return tanh((double)_X);
    }

     __inline long double __cdecl tanl( long double _X)
    {
        return tan((double)_X);
    }

     __declspec(dllimport) long double __cdecl tgammal( long double _X);
     __declspec(dllimport) long double __cdecl truncl( long double _X);

    



#line 966 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_math.h"



    
    
    
    
    
    

    

    
        
            extern double HUGE;
        

#line 984 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_math.h"

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_j0" ". See online help for details."))  __declspec(dllimport) double __cdecl j0( double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_j1" ". See online help for details."))  __declspec(dllimport) double __cdecl j1( double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_jn" ". See online help for details."))  __declspec(dllimport) double __cdecl jn( int _X,  double _Y);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_y0" ". See online help for details."))  __declspec(dllimport) double __cdecl y0( double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_y1" ". See online help for details."))  __declspec(dllimport) double __cdecl y1( double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_yn" ". See online help for details."))  __declspec(dllimport) double __cdecl yn( int _X,  double _Y);
    #line 992 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_math.h"

#line 994 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_math.h"

} __pragma(pack(pop))

#pragma warning(pop) 
#line 999 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_math.h"
#pragma external_header(pop)
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\math.h"




#pragma external_header(pop)
#line 13 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cstdlib"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"







#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_malloc.h"








#pragma once



#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {





































#line 56 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_malloc.h"

  
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _calloc_base(
     size_t _Count,
     size_t _Size
    );

  
__declspec(dllimport)  __declspec(allocator) __declspec(restrict) 
void* __cdecl calloc(
      size_t _Count,
      size_t _Size
    );


__declspec(dllimport) int __cdecl _callnewh(
     size_t _Size
    );

  
__declspec(dllimport) __declspec(allocator) 
void* __cdecl _expand(
               void*  _Block,
      size_t _Size
    );

__declspec(dllimport)
void __cdecl _free_base(
      void* _Block
    );

__declspec(dllimport) 
void __cdecl free(
      void* _Block
    );

  
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _malloc_base(
     size_t _Size
    );

  
__declspec(dllimport) __declspec(allocator)  __declspec(restrict) 
void* __cdecl malloc(
      size_t _Size
    );


__declspec(dllimport)
size_t __cdecl _msize_base(
     void* _Block
    ) noexcept ;


__declspec(dllimport) 
size_t __cdecl _msize(
     void* _Block
    );

   
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _realloc_base(
       void*  _Block,
                                size_t _Size
    );

   
__declspec(dllimport) __declspec(allocator) __declspec(restrict) 
void* __cdecl realloc(
      void*  _Block,
             size_t _Size
    );

   
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _recalloc_base(
      void*  _Block,
                               size_t _Count,
                               size_t _Size
    );

   
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _recalloc(
      void*  _Block,
             size_t _Count,
             size_t _Size
    );

__declspec(dllimport)
void __cdecl _aligned_free(
      void* _Block
    );

  
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_malloc(
      size_t _Size,
                        size_t _Alignment
    );

  
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_malloc(
      size_t _Size,
                        size_t _Alignment,
                        size_t _Offset
    );


__declspec(dllimport)
size_t __cdecl _aligned_msize(
     void*  _Block,
              size_t _Alignment,
              size_t _Offset
    );

   
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_realloc(
      void*  _Block,
             size_t _Size,
                               size_t _Alignment,
                               size_t _Offset
    );

   
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_recalloc(
      void*  _Block,
             size_t _Count,
             size_t _Size,
                               size_t _Alignment,
                               size_t _Offset
    );

   
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_realloc(
      void*  _Block,
             size_t _Size,
                               size_t _Alignment
    );

   
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_recalloc(
      void*  _Block,
             size_t _Count,
             size_t _Size,
                               size_t _Alignment
    );


















#line 229 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_malloc.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_search.h"










#pragma once




#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {


    typedef int (__cdecl* _CoreCrtSecureSearchSortCompareFunction)(void*, void const*, void const*);
    typedef int (__cdecl* _CoreCrtNonSecureSearchSortCompareFunction)(void const*, void const*);




    
    __declspec(dllimport) void* __cdecl bsearch_s(
                                                       void const* _Key,
         void const* _Base,
                                                       rsize_t     _NumOfElements,
                                                       rsize_t     _SizeOfElements,
                           _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                   void*       _Context
        );

    __declspec(dllimport) void __cdecl qsort_s(
         void*   _Base,
                                                            rsize_t _NumOfElements,
                                                            rsize_t _SizeOfElements,
                            _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                        void*   _Context
        );

#line 48 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_search.h"




__declspec(dllimport) void* __cdecl bsearch(
                                                   void const* _Key,
     void const* _Base,
                                                   size_t      _NumOfElements,
                                                   size_t      _SizeOfElements,
                    _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );

__declspec(dllimport) void __cdecl qsort(
     void*  _Base,
                                                        size_t _NumOfElements,
                                                        size_t _SizeOfElements,
                    _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );


__declspec(dllimport) void* __cdecl _lfind_s(
                                                      void const*   _Key,
     void const*   _Base,
                                                   unsigned int* _NumOfElements,
                                                      size_t        _SizeOfElements,
                            _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                      void*         _Context
    );


__declspec(dllimport) void* __cdecl _lfind(
                                                      void const*   _Key,
     void const*   _Base,
                                                   unsigned int* _NumOfElements,
                                                      unsigned int  _SizeOfElements,
                         _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );


__declspec(dllimport) void* __cdecl _lsearch_s(
                                                            void const*   _Key,
     void*         _Base,
                                                         unsigned int* _NumOfElements,
                                                            size_t        _SizeOfElements,
                                  _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                            void*         _Context
    );


__declspec(dllimport) void* __cdecl _lsearch(
                                                            void const*   _Key,
     void*         _Base,
                                                         unsigned int* _NumOfElements,
                                                            unsigned int  _SizeOfElements,
                               _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );




















































































#line 189 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_search.h"





     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_lfind" ". See online help for details."))
    __declspec(dllimport) void* __cdecl lfind(
                                                          void const*   _Key,
         void const*   _Base,
                                                       unsigned int* _NumOfElements,
                                                          unsigned int  _SizeOfElements,
                             _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
        );

     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_lsearch" ". See online help for details."))
    __declspec(dllimport) void* __cdecl lsearch(
                                                               void const*   _Key,
         void*         _Base,
                                                            unsigned int* _NumOfElements,
                                                               unsigned int  _SizeOfElements,
                                  _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
        );

#line 213 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_search.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdlib.h"








#pragma once



#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {


































    
    
    __declspec(dllimport) errno_t __cdecl _itow_s(
                                 int      _Value,
         wchar_t* _Buffer,
                                 size_t   _BufferCount,
                                 int      _Radix
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _itow_s(int _Value, wchar_t (&_Buffer)[_Size], int _Radix) throw() { return _itow_s(_Value, _Buffer, _Size, _Radix); } }






    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_itow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _itow(int _Value, wchar_t *_Buffer, int _Radix);






    
    
    __declspec(dllimport) errno_t __cdecl _ltow_s(
                                 long     _Value,
         wchar_t* _Buffer,
                                 size_t   _BufferCount,
                                 int      _Radix
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltow_s(long _Value, wchar_t (&_Buffer)[_Size], int _Radix) throw() { return _ltow_s(_Value, _Buffer, _Size, _Radix); } }






    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _ltow(long _Value, wchar_t *_Buffer, int _Radix);






    
    __declspec(dllimport) errno_t __cdecl _ultow_s(
                                 unsigned long _Value,
         wchar_t*      _Buffer,
                                 size_t        _BufferCount,
                                 int           _Radix
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultow_s(unsigned long _Value, wchar_t (&_Buffer)[_Size], int _Radix) throw() { return _ultow_s(_Value, _Buffer, _Size, _Radix); } }






    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _ultow(unsigned long _Value, wchar_t *_Buffer, int _Radix);






    
    __declspec(dllimport) double __cdecl wcstod(
                           wchar_t const* _String,
          wchar_t**      _EndPtr
        );

    
    __declspec(dllimport) double __cdecl _wcstod_l(
                           wchar_t const* _String,
          wchar_t**      _EndPtr,
                         _locale_t      _Locale
        );

    
    __declspec(dllimport) long __cdecl wcstol(
                           wchar_t const* _String,
          wchar_t**      _EndPtr,
                             int            _Radix
        );

    
    __declspec(dllimport) long __cdecl _wcstol_l(
                           wchar_t const* _String,
          wchar_t**      _EndPtr,
                             int            _Radix,
                         _locale_t      _Locale
        );

    
    __declspec(dllimport) long long __cdecl wcstoll(
                           wchar_t const* _String,
          wchar_t**      _EndPtr,
                             int            _Radix
        );

    
    __declspec(dllimport) long long __cdecl _wcstoll_l(
                           wchar_t const* _String,
          wchar_t**      _EndPtr,
                             int            _Radix,
                         _locale_t      _Locale
        );

    
    __declspec(dllimport) unsigned long __cdecl wcstoul(
                           wchar_t const* _String,
          wchar_t**      _EndPtr,
                             int            _Radix
        );

    
    __declspec(dllimport) unsigned long __cdecl _wcstoul_l(
                           wchar_t const* _String,
          wchar_t**      _EndPtr,
                             int            _Radix,
                         _locale_t      _Locale
        );

    
    __declspec(dllimport) unsigned long long __cdecl wcstoull(
                           wchar_t const* _String,
          wchar_t**      _EndPtr,
                             int            _Radix
        );

    
    __declspec(dllimport) unsigned long long __cdecl _wcstoull_l(
                           wchar_t const* _String,
          wchar_t**      _EndPtr,
                             int            _Radix,
                         _locale_t      _Locale
        );

    
    __declspec(dllimport) long double __cdecl wcstold(
                           wchar_t const* _String,
          wchar_t**      _EndPtr
        );

    
    __declspec(dllimport) long double __cdecl _wcstold_l(
                           wchar_t const* _String,
          wchar_t**      _EndPtr,
                         _locale_t      _Locale
        );

    
    __declspec(dllimport) float __cdecl wcstof(
                           wchar_t const* _String,
          wchar_t**      _EndPtr
        );

    
    __declspec(dllimport) float __cdecl _wcstof_l(
                           wchar_t const* _String,
          wchar_t**      _EndPtr,
                         _locale_t      _Locale
        );

    
    __declspec(dllimport) double __cdecl _wtof(
         wchar_t const* _String
        );

    
    __declspec(dllimport) double __cdecl _wtof_l(
           wchar_t const* _String,
         _locale_t      _Locale
        );

    
    __declspec(dllimport) int __cdecl _wtoi(
         wchar_t const* _String
        );

    
    __declspec(dllimport) int __cdecl _wtoi_l(
           wchar_t const* _String,
         _locale_t      _Locale
        );

    
    __declspec(dllimport) long __cdecl _wtol(
         wchar_t const* _String
        );

    
    __declspec(dllimport) long __cdecl _wtol_l(
           wchar_t const* _String,
         _locale_t      _Locale
        );

    
    __declspec(dllimport) long long __cdecl _wtoll(
         wchar_t const* _String
        );

    
    __declspec(dllimport) long long __cdecl _wtoll_l(
           wchar_t const* _String,
         _locale_t      _Locale
        );

    
    __declspec(dllimport) errno_t __cdecl _i64tow_s(
                                 __int64  _Value,
         wchar_t* _Buffer,
                                 size_t   _BufferCount,
                                 int      _Radix
        );

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_i64tow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) wchar_t* __cdecl _i64tow(
                           __int64  _Value,
          wchar_t* _Buffer,
                           int      _Radix
        );

    
    __declspec(dllimport) errno_t __cdecl _ui64tow_s(
                                 unsigned __int64 _Value,
         wchar_t*         _Buffer,
                                 size_t           _BufferCount,
                                 int              _Radix
        );

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ui64tow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) wchar_t* __cdecl _ui64tow(
                           unsigned __int64 _Value,
          wchar_t*         _Buffer,
                           int              _Radix
        );

    
    __declspec(dllimport) __int64 __cdecl _wtoi64(
         wchar_t const* _String
        );

    
    __declspec(dllimport) __int64 __cdecl _wtoi64_l(
           wchar_t const* _String,
         _locale_t      _Locale
        );

    
    __declspec(dllimport) __int64 __cdecl _wcstoi64(
                           wchar_t const* _String,
          wchar_t**      _EndPtr,
                             int            _Radix
        );

    
    __declspec(dllimport) __int64 __cdecl _wcstoi64_l(
                           wchar_t const* _String,
          wchar_t**      _EndPtr,
                             int            _Radix,
                         _locale_t      _Locale
        );

    
    __declspec(dllimport) unsigned __int64 __cdecl _wcstoui64(
                           wchar_t const* _String,
          wchar_t**      _EndPtr,
                             int            _Radix
        );

    
    __declspec(dllimport) unsigned __int64 __cdecl _wcstoui64_l(
                           wchar_t const* _String,
          wchar_t**      _EndPtr,
                             int            _Radix,
                         _locale_t      _Locale
        );

    
    

    
    
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wfullpath(
         wchar_t*       _Buffer,
                                   wchar_t const* _Path,
                                     size_t         _BufferCount
        );

    

    
    __declspec(dllimport) errno_t __cdecl _wmakepath_s(
         wchar_t*       _Buffer,
                                 size_t         _BufferCount,
                           wchar_t const* _Drive,
                           wchar_t const* _Dir,
                           wchar_t const* _Filename,
                           wchar_t const* _Ext
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmakepath_s(wchar_t (&_Buffer)[_Size], wchar_t const* _Drive, wchar_t const* _Dir, wchar_t const* _Filename, wchar_t const* _Ext) throw() { return _wmakepath_s(_Buffer, _Size, _Drive, _Dir, _Filename, _Ext); } }








__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wmakepath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) void __cdecl _wmakepath( wchar_t *_Buffer, wchar_t const* _Drive, wchar_t const* _Dir, wchar_t const* _Filename, wchar_t const* _Ext);








    __declspec(dllimport) void __cdecl _wperror(
         wchar_t const* _ErrorMessage
        );

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsplitpath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) void __cdecl _wsplitpath(
                           wchar_t const* _FullPath,
          wchar_t*       _Drive,
          wchar_t*       _Dir,
          wchar_t*       _Filename,
          wchar_t*       _Ext
        );

    __declspec(dllimport) errno_t __cdecl _wsplitpath_s(
                                     wchar_t const* _FullPath,
            wchar_t*       _Drive,
                                       size_t         _DriveCount,
              wchar_t*       _Dir,
                                       size_t         _DirCount,
         wchar_t*       _Filename,
                                       size_t         _FilenameCount,
              wchar_t*       _Ext,
                                       size_t         _ExtCount
        );

    extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _wsplitpath_s( wchar_t const* _Path, wchar_t (&_Drive)[_DriveSize], wchar_t (&_Dir)[_DirSize], wchar_t (&_Name)[_NameSize], wchar_t (&_Ext)[_ExtSize] ) throw() { return _wsplitpath_s(_Path, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }




        
        

        
        __declspec(dllimport) errno_t __cdecl _wdupenv_s(
              wchar_t**      _Buffer,
                                                                               size_t*        _BufferCount,
                                                                                  wchar_t const* _VarName
            );

        

         __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wdupenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        __declspec(dllimport) wchar_t* __cdecl _wgetenv(
             wchar_t const* _VarName
            );

        
        
        __declspec(dllimport) errno_t __cdecl _wgetenv_s(
                                        size_t*        _RequiredCount,
             wchar_t*       _Buffer,
                                         size_t         _BufferCount,
                                       wchar_t const* _VarName
            );

        extern "C++" { template <size_t _Size> inline errno_t __cdecl _wgetenv_s(size_t* _RequiredCount, wchar_t (&_Buffer)[_Size], wchar_t const* _VarName) throw() { return _wgetenv_s(_RequiredCount, _Buffer, _Size, _VarName); } }







        
        __declspec(dllimport) int __cdecl _wputenv(
             wchar_t const* _EnvString
            );

        
        __declspec(dllimport) errno_t __cdecl _wputenv_s(
             wchar_t const* _Name,
             wchar_t const* _Value
            );

        __declspec(dllimport) errno_t __cdecl _wsearchenv_s(
                                   wchar_t const* _Filename,
                                   wchar_t const* _VarName,
             wchar_t*       _Buffer,
                                     size_t         _BufferCount
            );

        extern "C++" { template <size_t _Size> inline errno_t __cdecl _wsearchenv_s(wchar_t const* _Filename, wchar_t const* _VarName, wchar_t (&_ResultPath)[_Size]) throw() { return _wsearchenv_s(_Filename, _VarName, _ResultPath, _Size); } }






        __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsearchenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) void __cdecl _wsearchenv(wchar_t const* _Filename, wchar_t const* _VarName, wchar_t *_ResultPath);






        __declspec(dllimport) int __cdecl _wsystem(
             wchar_t const* _Command
            );

#line 476 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdlib.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 16 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"
#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits.h"







#pragma once




#pragma warning(push)
#pragma warning(disable: 4514 4820 )

__pragma(pack(push, 8)) extern "C" {







    
    



#line 30 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits.h"









































    
        
    #line 74 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits.h"
#line 75 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits.h"

} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 17 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"

#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {




    
#line 29 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"









__declspec(dllimport) void __cdecl _swab(
      char* _Buf1,
      char* _Buf2,
                                                                 int   _SizeInBytes
    );













    __declspec(dllimport) __declspec(noreturn) void __cdecl exit( int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl _exit( int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl _Exit( int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl quick_exit( int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl abort(void);
#line 62 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"





__declspec(dllimport) unsigned int __cdecl _set_abort_behavior(
     unsigned int _Flags,
     unsigned int _Mask
    );




    

    typedef int (__cdecl * _onexit_t)(void);
    


#line 82 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"


    
    
#line 87 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"

























































    int       __cdecl atexit(void (__cdecl*)(void));
    _onexit_t __cdecl _onexit( _onexit_t _Func);
#line 147 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"

int __cdecl at_quick_exit(void (__cdecl*)(void));









    
    typedef void (__cdecl* _purecall_handler)(void);

    
    typedef void (__cdecl* _invalid_parameter_handler)(
        wchar_t const*,
        wchar_t const*,
        wchar_t const*,
        unsigned int,
        uintptr_t
        );

    
     _purecall_handler __cdecl _set_purecall_handler(
         _purecall_handler _Handler
        );

     _purecall_handler __cdecl _get_purecall_handler(void);

    
    __declspec(dllimport) _invalid_parameter_handler __cdecl _set_invalid_parameter_handler(
         _invalid_parameter_handler _Handler
        );

    __declspec(dllimport) _invalid_parameter_handler __cdecl _get_invalid_parameter_handler(void);

    __declspec(dllimport) _invalid_parameter_handler __cdecl _set_thread_local_invalid_parameter_handler(
         _invalid_parameter_handler _Handler
        );

    __declspec(dllimport) _invalid_parameter_handler __cdecl _get_thread_local_invalid_parameter_handler(void);
#line 190 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"












#line 203 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"









 __declspec(dllimport) int __cdecl _set_error_mode( int _Mode);




    __declspec(dllimport) int* __cdecl _errno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_errno( int _Value);
    __declspec(dllimport) errno_t __cdecl _get_errno( int* _Value);

    __declspec(dllimport) unsigned long* __cdecl __doserrno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_doserrno( unsigned long _Value);
    __declspec(dllimport) errno_t __cdecl _get_doserrno( unsigned long * _Value);

    
    __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) char** __cdecl __sys_errlist(void);
    

    __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) int * __cdecl __sys_nerr(void);
    

    __declspec(dllimport) void __cdecl perror( char const* _ErrMsg);
#line 238 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"




__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_pgmptr" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char**    __cdecl __p__pgmptr (void);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_wpgmptr" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t** __cdecl __p__wpgmptr(void);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_fmode" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) int*      __cdecl __p__fmode  (void);








    
    
    
#line 257 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"


__declspec(dllimport) errno_t __cdecl _get_pgmptr ( char**    _Value);


__declspec(dllimport) errno_t __cdecl _get_wpgmptr( wchar_t** _Value);

__declspec(dllimport) errno_t __cdecl _set_fmode  (              int       _Mode );

__declspec(dllimport) errno_t __cdecl _get_fmode  (             int*      _PMode);








typedef struct _div_t
{
    int quot;
    int rem;
} div_t;

typedef struct _ldiv_t
{
    long quot;
    long rem;
} ldiv_t;

typedef struct _lldiv_t
{
    long long quot;
    long long rem;
} lldiv_t;

 int       __cdecl abs   ( int       _Number);
 long      __cdecl labs  ( long      _Number);
 long long __cdecl llabs ( long long _Number);
 __int64   __cdecl _abs64( __int64   _Number);

 unsigned short   __cdecl _byteswap_ushort( unsigned short   _Number);
 unsigned long    __cdecl _byteswap_ulong ( unsigned long    _Number);
 unsigned __int64 __cdecl _byteswap_uint64( unsigned __int64 _Number);

 __declspec(dllimport) div_t   __cdecl div  ( int       _Numerator,  int       _Denominator);
 __declspec(dllimport) ldiv_t  __cdecl ldiv ( long      _Numerator,  long      _Denominator);
 __declspec(dllimport) lldiv_t __cdecl lldiv( long long _Numerator,  long long _Denominator);



#pragma warning(push)
#pragma warning(disable: 6540)

unsigned int __cdecl _rotl(
     unsigned int _Value,
     int          _Shift
    );


unsigned long __cdecl _lrotl(
     unsigned long _Value,
     int           _Shift
    );

unsigned __int64 __cdecl _rotl64(
     unsigned __int64 _Value,
     int              _Shift
    );

unsigned int __cdecl _rotr(
     unsigned int _Value,
     int          _Shift
    );


unsigned long __cdecl _lrotr(
     unsigned long _Value,
     int           _Shift
    );

unsigned __int64 __cdecl _rotr64(
     unsigned __int64 _Value,
     int              _Shift
    );

#pragma warning(pop)






__declspec(dllimport) void __cdecl srand( unsigned int _Seed);

 __declspec(dllimport) int __cdecl rand(void);



#line 357 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"




extern "C++"
{
    inline long abs(long const _X) throw()
    {
        return labs(_X);
    }

    inline long long abs(long long const _X) throw()
    {
        return llabs(_X);
    }

    inline ldiv_t div(long const _A1, long const _A2) throw()
    {
        return ldiv(_A1, _A2);
    }

    inline lldiv_t div(long long const _A1, long long const _A2) throw()
    {
        return lldiv(_A1, _A2);
    }
}
#line 384 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"










    #pragma pack(push, 4)
    typedef struct
    {
        unsigned char ld[10];
    } _LDOUBLE;
    #pragma pack(pop)

    











#line 414 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"

typedef struct
{
    double x;
} _CRT_DOUBLE;

typedef struct
{
    float f;
} _CRT_FLOAT;





typedef struct
{
    long double x;
} _LONGDOUBLE;



#pragma pack(push, 4)
typedef struct
{
    unsigned char ld12[12];
} _LDBL12;
#pragma pack(pop)








                    __declspec(dllimport) double    __cdecl atof   ( char const* _String);
  __declspec(dllimport) int       __cdecl atoi   ( char const* _String);
                    __declspec(dllimport) long      __cdecl atol   ( char const* _String);
                    __declspec(dllimport) long long __cdecl atoll  ( char const* _String);
                    __declspec(dllimport) __int64   __cdecl _atoi64( char const* _String);

 __declspec(dllimport) double    __cdecl _atof_l  ( char const* _String,  _locale_t _Locale);
 __declspec(dllimport) int       __cdecl _atoi_l  ( char const* _String,  _locale_t _Locale);
 __declspec(dllimport) long      __cdecl _atol_l  ( char const* _String,  _locale_t _Locale);
 __declspec(dllimport) long long __cdecl _atoll_l ( char const* _String,  _locale_t _Locale);
 __declspec(dllimport) __int64   __cdecl _atoi64_l( char const* _String,  _locale_t _Locale);

 __declspec(dllimport) int __cdecl _atoflt ( _CRT_FLOAT*  _Result,  char const* _String);
 __declspec(dllimport) int __cdecl _atodbl ( _CRT_DOUBLE* _Result,  char*       _String);
 __declspec(dllimport) int __cdecl _atoldbl( _LDOUBLE*    _Result,  char*       _String);


__declspec(dllimport) int __cdecl _atoflt_l(
        _CRT_FLOAT* _Result,
       char const* _String,
     _locale_t   _Locale
    );


__declspec(dllimport) int __cdecl _atodbl_l(
        _CRT_DOUBLE* _Result,
       char*        _String,
     _locale_t    _Locale
    );



__declspec(dllimport) int __cdecl _atoldbl_l(
        _LDOUBLE* _Result,
       char*     _String,
     _locale_t _Locale
    );


__declspec(dllimport) float __cdecl strtof(
                       char const* _String,
      char**      _EndPtr
    );


__declspec(dllimport) float __cdecl _strtof_l(
                       char const* _String,
      char**      _EndPtr,
                     _locale_t   _Locale
    );


__declspec(dllimport) double __cdecl strtod(
                       char const* _String,
      char**      _EndPtr
    );


__declspec(dllimport) double __cdecl _strtod_l(
                       char const* _String,
      char**      _EndPtr,
                     _locale_t   _Locale
    );


__declspec(dllimport) long double __cdecl strtold(
                       char const* _String,
      char**      _EndPtr
    );


__declspec(dllimport) long double __cdecl _strtold_l(
                       char const* _String,
      char**      _EndPtr,
                     _locale_t   _Locale
    );


__declspec(dllimport) long __cdecl strtol(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix
    );


__declspec(dllimport) long __cdecl _strtol_l(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix,
                     _locale_t   _Locale
    );


__declspec(dllimport) long long __cdecl strtoll(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix
    );


__declspec(dllimport) long long __cdecl _strtoll_l(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix,
                     _locale_t   _Locale
    );


__declspec(dllimport) unsigned long __cdecl strtoul(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix
    );


__declspec(dllimport) unsigned long __cdecl _strtoul_l(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix,
                     _locale_t   _Locale
    );


__declspec(dllimport) unsigned long long __cdecl strtoull(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix
    );


__declspec(dllimport) unsigned long long __cdecl _strtoull_l(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix,
                     _locale_t   _Locale
    );


__declspec(dllimport) __int64 __cdecl _strtoi64(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix
    );


__declspec(dllimport) __int64 __cdecl _strtoi64_l(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix,
                     _locale_t   _Locale
    );


__declspec(dllimport) unsigned __int64 __cdecl _strtoui64(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix
    );


__declspec(dllimport) unsigned __int64 __cdecl _strtoui64_l(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix,
                     _locale_t   _Locale
    );










__declspec(dllimport) errno_t __cdecl _itoa_s(
                             int    _Value,
     char*  _Buffer,
                             size_t _BufferCount,
                             int    _Radix
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _itoa_s(int _Value, char (&_Buffer)[_Size], int _Radix) throw() { return _itoa_s(_Value, _Buffer, _Size, _Radix); } }







__declspec(deprecated("This function or variable may be unsafe. Consider using " "_itoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _itoa(int _Value, char *_Buffer, int _Radix);








__declspec(dllimport) errno_t __cdecl _ltoa_s(
                             long   _Value,
     char*  _Buffer,
                             size_t _BufferCount,
                             int    _Radix
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltoa_s(long _Value, char (&_Buffer)[_Size], int _Radix) throw() { return _ltoa_s(_Value, _Buffer, _Size, _Radix); } }






__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _ltoa(long _Value, char *_Buffer, int _Radix);








__declspec(dllimport) errno_t __cdecl _ultoa_s(
                             unsigned long _Value,
     char*         _Buffer,
                             size_t        _BufferCount,
                             int           _Radix
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultoa_s(unsigned long _Value, char (&_Buffer)[_Size], int _Radix) throw() { return _ultoa_s(_Value, _Buffer, _Size, _Radix); } }






__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _ultoa(unsigned long _Value, char *_Buffer, int _Radix);








__declspec(dllimport) errno_t __cdecl _i64toa_s(
                             __int64 _Value,
     char*   _Buffer,
                             size_t  _BufferCount,
                             int     _Radix
    );


__declspec(deprecated("This function or variable may be unsafe. Consider using " "_i64toa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _i64toa(
                       __int64 _Value,
      char*   _Buffer,
                       int     _Radix
    );



__declspec(dllimport) errno_t __cdecl _ui64toa_s(
                             unsigned __int64 _Value,
     char*            _Buffer,
                             size_t           _BufferCount,
                             int              _Radix
    );

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ui64toa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _ui64toa(
                       unsigned __int64 _Value,
      char*            _Buffer,
                       int              _Radix
    );















__declspec(dllimport) errno_t __cdecl _ecvt_s(
     char* _Buffer,
      size_t                       _BufferCount,
      double                       _Value,
      int                          _DigitCount,
     int*                         _PtDec,
     int*                         _PtSign
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ecvt_s(char (&_Buffer)[_Size], double _Value, int _DigitCount, int* _PtDec, int* _PtSign) throw() { return _ecvt_s(_Buffer, _Size, _Value, _DigitCount, _PtDec, _PtSign); } }








 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ecvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _ecvt(
      double _Value,
      int    _DigitCount,
     int*   _PtDec,
     int*   _PtSign
    );



__declspec(dllimport) errno_t __cdecl _fcvt_s(
     char*  _Buffer,
                             size_t _BufferCount,
                             double _Value,
                             int    _FractionalDigitCount,
                            int*   _PtDec,
                            int*   _PtSign
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _fcvt_s(char (&_Buffer)[_Size], double _Value, int _FractionalDigitCount, int* _PtDec, int* _PtSign) throw() { return _fcvt_s(_Buffer, _Size, _Value, _FractionalDigitCount, _PtDec, _PtSign); } }










 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _fcvt(
      double _Value,
      int    _FractionalDigitCount,
     int*   _PtDec,
     int*   _PtSign
    );


__declspec(dllimport) errno_t __cdecl _gcvt_s(
     char*  _Buffer,
                             size_t _BufferCount,
                             double _Value,
                             int    _DigitCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _gcvt_s(char (&_Buffer)[_Size], double _Value, int _DigitCount) throw() { return _gcvt_s(_Buffer, _Size, _Value, _DigitCount); } }







__declspec(deprecated("This function or variable may be unsafe. Consider using " "_gcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _gcvt(
                       double _Value,
                       int    _DigitCount,
      char*  _Buffer
    );











    

#line 833 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"
        
    #line 835 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"

    


        
    #line 841 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"

    
    __declspec(dllimport) int __cdecl ___mb_cur_max_func(void);

    
    __declspec(dllimport) int __cdecl ___mb_cur_max_l_func(_locale_t _Locale);
#line 848 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"




__declspec(dllimport) int __cdecl mblen(
      char const* _Ch,
                                            size_t      _MaxCount
    );


__declspec(dllimport) int __cdecl _mblen_l(
      char const* _Ch,
                                            size_t      _MaxCount,
                                        _locale_t   _Locale
    );



__declspec(dllimport) size_t __cdecl _mbstrlen(
     char const* _String
    );



__declspec(dllimport) size_t __cdecl _mbstrlen_l(
       char const* _String,
     _locale_t   _Locale
    );



__declspec(dllimport) size_t __cdecl _mbstrnlen(
     char const* _String,
       size_t      _MaxCount
    );



__declspec(dllimport) size_t __cdecl _mbstrnlen_l(
       char const* _String,
         size_t      _MaxCount,
     _locale_t   _Locale
    );


__declspec(dllimport) int __cdecl mbtowc(
                    wchar_t*    _DstCh,
     char const* _SrcCh,
                                     size_t      _SrcSizeInBytes
    );


__declspec(dllimport) int __cdecl _mbtowc_l(
                    wchar_t*    _DstCh,
     char const* _SrcCh,
                                     size_t      _SrcSizeInBytes,
                                 _locale_t   _Locale
    );


__declspec(dllimport) errno_t __cdecl mbstowcs_s(
                                                     size_t*     _PtNumOfCharConverted,
     wchar_t*    _DstBuf,
                                                          size_t      _SizeInWords,
                                    char const* _SrcBuf,
                                                          size_t      _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl mbstowcs_s(size_t* _PtNumOfCharConverted, wchar_t (&_Dest)[_Size], char const* _Source, size_t _MaxCount) throw() { return mbstowcs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }







__declspec(deprecated("This function or variable may be unsafe. Consider using " "mbstowcs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl mbstowcs( wchar_t *_Dest, char const* _Source, size_t _MaxCount);







__declspec(dllimport) errno_t __cdecl _mbstowcs_s_l(
                                                     size_t*     _PtNumOfCharConverted,
     wchar_t*    _DstBuf,
                                                          size_t      _SizeInWords,
                                    char const* _SrcBuf,
                                                          size_t      _MaxCount,
                                                      _locale_t   _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _mbstowcs_s_l(size_t* _PtNumOfCharConverted, wchar_t (&_Dest)[_Size], char const* _Source, size_t _MaxCount, _locale_t _Locale) throw() { return _mbstowcs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }








__declspec(deprecated("This function or variable may be unsafe. Consider using " "_mbstowcs_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl _mbstowcs_l( wchar_t *_Dest, char const* _Source, size_t _MaxCount, _locale_t _Locale);











__declspec(deprecated("This function or variable may be unsafe. Consider using " "wctomb_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) int __cdecl wctomb(
     char*   _MbCh,
                               wchar_t _WCh
    );

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctomb_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) int __cdecl _wctomb_l(
      char*     _MbCh,
                         wchar_t   _WCh,
                     _locale_t _Locale
    );



    
    __declspec(dllimport) errno_t __cdecl wctomb_s(
                                                        int*    _SizeConverted,
         char*   _MbCh,
                                                             rsize_t _SizeInBytes,
                                                             wchar_t _WCh
        );

#line 986 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"


__declspec(dllimport) errno_t __cdecl _wctomb_s_l(
                            int*     _SizeConverted,
     char*     _MbCh,
                                 size_t    _SizeInBytes,
                                 wchar_t   _WCh,
                             _locale_t _Locale);


__declspec(dllimport) errno_t __cdecl wcstombs_s(
                                                              size_t*        _PtNumOfCharConverted,
     char*          _Dst,
                                                                   size_t         _DstSizeInBytes,
                                                                 wchar_t const* _Src,
                                                                   size_t         _MaxCountInBytes
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcstombs_s(size_t* _PtNumOfCharConverted, char (&_Dest)[_Size], wchar_t const* _Source, size_t _MaxCount) throw() { return wcstombs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }







__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstombs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl wcstombs( char *_Dest, wchar_t const* _Source, size_t _MaxCount);







__declspec(dllimport) errno_t __cdecl _wcstombs_s_l(
                                                              size_t*        _PtNumOfCharConverted,
     char*          _Dst,
                                                                   size_t         _DstSizeInBytes,
                                                                 wchar_t const* _Src,
                                                                   size_t         _MaxCountInBytes,
                                                               _locale_t      _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcstombs_s_l(size_t* _PtNumOfCharConverted, char (&_Dest)[_Size], wchar_t const* _Source, size_t _MaxCount, _locale_t _Locale) throw() { return _wcstombs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }








__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcstombs_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl _wcstombs_l( char *_Dest, wchar_t const* _Source, size_t _MaxCount, _locale_t _Locale);





























__declspec(dllimport) __declspec(allocator) char* __cdecl _fullpath(
     char*       _Buffer,
                               char const* _Path,
                                 size_t      _BufferCount
    );




__declspec(dllimport) errno_t __cdecl _makepath_s(
     char*       _Buffer,
                             size_t      _BufferCount,
                       char const* _Drive,
                       char const* _Dir,
                       char const* _Filename,
                       char const* _Ext
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _makepath_s(char (&_Buffer)[_Size], char const* _Drive, char const* _Dir, char const* _Filename, char const* _Ext) throw() { return _makepath_s(_Buffer, _Size, _Drive, _Dir, _Filename, _Ext); } }








__declspec(deprecated("This function or variable may be unsafe. Consider using " "_makepath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) void __cdecl _makepath( char *_Buffer, char const* _Drive, char const* _Dir, char const* _Filename, char const* _Ext);








__declspec(deprecated("This function or variable may be unsafe. Consider using " "_splitpath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) void __cdecl _splitpath(
                       char const* _FullPath,
      char*       _Drive,
      char*       _Dir,
      char*       _Filename,
      char*       _Ext
    );


__declspec(dllimport) errno_t __cdecl _splitpath_s(
                                 char const* _FullPath,
        char*       _Drive,
                                   size_t      _DriveCount,
          char*       _Dir,
                                   size_t      _DirCount,
     char*       _Filename,
                                   size_t      _FilenameCount,
          char*       _Ext,
                                   size_t      _ExtCount
    );

extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _splitpath_s( char const* _Dest, char (&_Drive)[_DriveSize], char (&_Dir)[_DirSize], char (&_Name)[_NameSize], char (&_Ext)[_ExtSize] ) throw() { return _splitpath_s(_Dest, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }





__declspec(dllimport) errno_t __cdecl getenv_s(
                                size_t*     _RequiredCount,
     char*       _Buffer,
                                 rsize_t     _BufferCount,
                               char const* _VarName
    );

#line 1140 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"




__declspec(dllimport) int*       __cdecl __p___argc (void);
__declspec(dllimport) char***    __cdecl __p___argv (void);
__declspec(dllimport) wchar_t*** __cdecl __p___wargv(void);






    
    
    
#line 1157 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"

__declspec(dllimport) char***    __cdecl __p__environ (void);
__declspec(dllimport) wchar_t*** __cdecl __p__wenviron(void);


    
#line 1164 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"







    
    
#line 1174 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"









     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_dupenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl getenv(
         char const* _VarName
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl getenv_s(size_t* _RequiredCount, char (&_Buffer)[_Size], char const* _VarName) throw() { return getenv_s(_RequiredCount, _Buffer, _Size, _VarName); } }






    


#line 1199 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"

    
    __declspec(dllimport) errno_t __cdecl _dupenv_s(
          char**      _Buffer,
                                                                           size_t*     _BufferCount,
                                                                              char const* _VarName
        );

    

#line 1210 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"

    __declspec(dllimport) int __cdecl system(
         char const* _Command
        );

    
    
    #pragma warning(push)
    #pragma warning(disable: 6540)

    
    __declspec(dllimport) int __cdecl _putenv(
         char const* _EnvString
        );

    
    __declspec(dllimport) errno_t __cdecl _putenv_s(
         char const* _Name,
         char const* _Value
        );

    #pragma warning(pop)

    __declspec(dllimport) errno_t __cdecl _searchenv_s(
                               char const* _Filename,
                               char const* _VarName,
         char*       _Buffer,
                                 size_t      _BufferCount
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _searchenv_s(char const* _Filename, char const* _VarName, char (&_Buffer)[_Size]) throw() { return _searchenv_s(_Filename, _VarName, _Buffer, _Size); } }






    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_searchenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) void __cdecl _searchenv(char const* _Filename, char const* _VarName, char *_Buffer);






    
    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "SetErrorMode" " " "instead. See online help for details."))
    __declspec(dllimport) void __cdecl _seterrormode(
         int _Mode
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "Beep" " " "instead. See online help for details."))
    __declspec(dllimport) void __cdecl _beep(
         unsigned _Frequency,
         unsigned _Duration
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "Sleep" " " "instead. See online help for details."))
    __declspec(dllimport) void __cdecl _sleep(
         unsigned long _Duration
        );

#line 1272 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"









    




    
    

    #pragma warning(push)
    #pragma warning(disable: 4141) 

     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ecvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ecvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl ecvt(
          double _Value,
          int    _DigitCount,
         int*   _PtDec,
         int*   _PtSign
        );

     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fcvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl fcvt(
          double _Value,
          int    _FractionalDigitCount,
         int*   _PtDec,
         int*   _PtSign
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_gcvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl gcvt(
                           double _Value,
                           int    _DigitCount,
          char*  _DstBuf
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_itoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_itoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl itoa(
                           int   _Value,
          char* _Buffer,
                           int   _Radix
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ltoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl ltoa(
                           long  _Value,
          char* _Buffer,
                           int   _Radix
        );


    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_swab" ". See online help for details."))
    __declspec(dllimport) void __cdecl swab(
         char* _Buf1,
         char* _Buf2,
                                    int   _SizeInBytes
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ultoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl ultoa(
                           unsigned long _Value,
          char*         _Buffer,
                           int           _Radix
        );

    

     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_putenv" ". See online help for details."))
    __declspec(dllimport) int __cdecl putenv(
         char const* _EnvString
        );

    #pragma warning(pop)

    _onexit_t __cdecl onexit( _onexit_t _Func);

#line 1356 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#line 1363 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdlib.h"
#pragma external_header(pop)
#line 14 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cstdlib"

#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )





[[nodiscard]]  inline double abs( double _Xx) noexcept   {
    return :: fabs(_Xx);
}

[[nodiscard]]  inline float abs( float _Xx) noexcept   {
    return :: fabsf(_Xx);
}

[[nodiscard]]  inline long double abs( long double _Xx) noexcept   {
    return :: fabsl(_Xx);
}

namespace std {
 using :: size_t;
 using :: div_t;
 using :: ldiv_t;
 using :: abort;
 using :: abs;
 using :: atexit;
 using :: atof;
 using :: atoi;
 using :: atol;
 using :: bsearch;
 using :: calloc;
 using :: div;
 using :: exit;
 using :: free;
 using :: labs;
 using :: ldiv;
 using :: malloc;
 using :: mblen;
 using :: mbstowcs;
 using :: mbtowc;
 using :: qsort;
 using :: rand;
 using :: realloc;
 using :: srand;
 using :: strtod;
 using :: strtol;
 using :: strtoul;
 using :: wcstombs;
 using :: wctomb;

 using :: lldiv_t;

 using :: getenv;
 using :: system;

 using :: atoll;
 using :: llabs;
 using :: lldiv;
 using :: strtof;
 using :: strtold;
 using :: strtoll;
 using :: strtoull;

 using :: _Exit;
 using :: at_quick_exit;
 using :: quick_exit;
}



#pragma warning(pop)
#pragma pack(pop)

#line 90 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cstdlib"
#line 91 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cstdlib"
#pragma external_header(pop)
#line 13 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"
#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xtr1common"





#pragma once





#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




namespace std {
 template <class _Ty, _Ty _Val>
struct integral_constant {
    static constexpr _Ty value = _Val;

    using value_type = _Ty;
    using type       = integral_constant;

    constexpr operator value_type() const noexcept {
        return value;
    }

    [[nodiscard]] constexpr value_type operator()() const noexcept {
        return value;
    }
};

 template <bool _Val>
using bool_constant = integral_constant<bool, _Val>;

 using true_type  = bool_constant<true>;
 using false_type = bool_constant<false>;

 template <bool _Test, class _Ty = void>
struct enable_if {}; 

template <class _Ty>
struct enable_if<true, _Ty> { 
    using type = _Ty;
};

 template <bool _Test, class _Ty = void>
using enable_if_t = typename enable_if<_Test, _Ty>::type;

 template <bool _Test, class _Ty1, class _Ty2>
struct conditional { 
    using type = _Ty1;
};

template <class _Ty1, class _Ty2>
struct conditional<false, _Ty1, _Ty2> {
    using type = _Ty2;
};

 template <bool _Test, class _Ty1, class _Ty2>
using conditional_t = typename conditional<_Test, _Ty1, _Ty2>::type;








 template <class, class>
inline constexpr bool is_same_v = false; 
template <class _Ty>
inline constexpr bool is_same_v<_Ty, _Ty> = true;

 template <class _Ty1, class _Ty2>
struct is_same : bool_constant<is_same_v<_Ty1, _Ty2>> {};
#line 81 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xtr1common"

 template <class _Ty>
struct remove_const { 
    using type = _Ty;
};

template <class _Ty>
struct remove_const<const _Ty> {
    using type = _Ty;
};

 template <class _Ty>
using remove_const_t = typename remove_const<_Ty>::type;

 template <class _Ty>
struct remove_volatile { 
    using type = _Ty;
};

template <class _Ty>
struct remove_volatile<volatile _Ty> {
    using type = _Ty;
};

 template <class _Ty>
using remove_volatile_t = typename remove_volatile<_Ty>::type;

 template <class _Ty>
struct remove_cv { 
    using type = _Ty;

    template <template <class> class _Fn>
    using _Apply = _Fn<_Ty>; 
};

template <class _Ty>
struct remove_cv<const _Ty> {
    using type = _Ty;

    template <template <class> class _Fn>
    using _Apply = const _Fn<_Ty>;
};

template <class _Ty>
struct remove_cv<volatile _Ty> {
    using type = _Ty;

    template <template <class> class _Fn>
    using _Apply = volatile _Fn<_Ty>;
};

template <class _Ty>
struct remove_cv<const volatile _Ty> {
    using type = _Ty;

    template <template <class> class _Fn>
    using _Apply = const volatile _Fn<_Ty>;
};

 template <class _Ty>
using remove_cv_t = typename remove_cv<_Ty>::type;

template <bool _First_value, class _First, class... _Rest>
struct _Disjunction { 
    using type = _First;
};

template <class _False, class _Next, class... _Rest>
struct _Disjunction<false, _False, _Next, _Rest...> { 
    using type = typename _Disjunction<_Next::value, _Next, _Rest...>::type;
};

 template <class... _Traits>
struct disjunction : false_type {}; 

template <class _First, class... _Rest>
struct disjunction<_First, _Rest...> : _Disjunction<_First::value, _First, _Rest...>::type {
    
};

 template <class... _Traits>
inline constexpr bool disjunction_v = disjunction<_Traits...>::value;

template <class _Ty, class... _Types>
inline constexpr bool _Is_any_of_v = 
    disjunction_v<is_same<_Ty, _Types>...>;

[[nodiscard]] constexpr bool _Is_constant_evaluated() noexcept { 
    return __builtin_is_constant_evaluated();
}


 [[nodiscard]] constexpr bool is_constant_evaluated() noexcept {
    return __builtin_is_constant_evaluated();
}
#line 177 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xtr1common"

 template <class _Ty>
inline constexpr bool is_integral_v = _Is_any_of_v<remove_cv_t<_Ty>, bool, char, signed char, unsigned char,
    wchar_t,

    char8_t,
#line 184 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xtr1common"
    char16_t, char32_t, short, unsigned short, int, unsigned int, long, unsigned long, long long, unsigned long long>;

 template <class _Ty>
struct is_integral : bool_constant<is_integral_v<_Ty>> {};

 template <class _Ty>
inline constexpr bool is_floating_point_v = _Is_any_of_v<remove_cv_t<_Ty>, float, double, long double>;

 template <class _Ty>
struct is_floating_point : bool_constant<is_floating_point_v<_Ty>> {};

 template <class _Ty>
inline constexpr bool is_arithmetic_v = 
    is_integral_v<_Ty> || is_floating_point_v<_Ty>;

 template <class _Ty>
struct is_arithmetic : bool_constant<is_arithmetic_v<_Ty>> {};

 template <class _Ty>
struct remove_reference {
    using type                 = _Ty;
    using _Const_thru_ref_type = const _Ty;
};

template <class _Ty>
struct remove_reference<_Ty&> {
    using type                 = _Ty;
    using _Const_thru_ref_type = const _Ty&;
};

template <class _Ty>
struct remove_reference<_Ty&&> {
    using type                 = _Ty;
    using _Const_thru_ref_type = const _Ty&&;
};

 template <class _Ty>
using remove_reference_t = typename remove_reference<_Ty>::type;

template <class _Ty>
using _Const_thru_ref = typename remove_reference<_Ty>::_Const_thru_ref_type;

template <class _Ty>
using _Remove_cvref_t [[msvc::known_semantics]] = remove_cv_t<remove_reference_t<_Ty>>;


 template <class _Ty>
using remove_cvref_t = _Remove_cvref_t<_Ty>;

 template <class _Ty>
struct remove_cvref {
    using type = remove_cvref_t<_Ty>;
};
#line 238 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xtr1common"

}


#pragma warning(pop)
#pragma pack(pop)
#line 245 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xtr1common"
#line 246 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xtr1common"
#pragma external_header(pop)
#line 14 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"





#line 21 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"


#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin0.h"












#pragma once





#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin0.inl.h"













#pragma once





#pragma warning(push)
#pragma warning(disable: 4514 4820 )


extern "C" {
#line 26 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin0.inl.h"


























 



#line 57 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin0.inl.h"


#line 60 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin0.inl.h"






#line 67 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin0.inl.h"




#line 72 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin0.inl.h"




#line 77 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin0.inl.h"




#line 82 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin0.inl.h"

 




#line 89 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin0.inl.h"




#line 94 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin0.inl.h"




#line 99 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin0.inl.h"




#line 104 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin0.inl.h"




#line 109 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin0.inl.h"




#line 114 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin0.inl.h"









unsigned char _BitScanForward(unsigned long * _Index, unsigned long _Mask);
unsigned char _BitScanForward64(unsigned long * _Index, unsigned __int64 _Mask);

unsigned char _BitScanReverse(unsigned long * _Index, unsigned long _Mask);
unsigned char _BitScanReverse64(unsigned long * _Index, unsigned __int64 _Mask);

unsigned char _bittest(long const *, long);


long _InterlockedAnd(long volatile * _Value, long _Mask);
short _InterlockedAnd16(short volatile * _Value, short _Mask);



__int64 _InterlockedAnd64(__int64 volatile * _Value, __int64 _Mask);
__int64 _interlockedand64(__int64 volatile * _Value, __int64 _Mask);



char _InterlockedAnd8(char volatile * _Value, char _Mask);






long _InterlockedCompareExchange(long volatile * _Destination, long _Exchange, long _Comparand);

short _InterlockedCompareExchange16(short volatile * _Destination, short _Exchange, short _Comparand);



__int64 _InterlockedCompareExchange64(__int64 volatile * _Destination, __int64 _Exchange, __int64 _Comparand);



char _InterlockedCompareExchange8(char volatile * _Destination, char _Exchange, char _Comparand);






unsigned char _InterlockedCompareExchange128(__int64 volatile * _Destination, __int64 _ExchangeHigh, __int64 _ExchangeLow, __int64 * _ComparandResult);



long _InterlockedDecrement(long volatile * _Addend);

short _InterlockedDecrement16(short volatile * _Addend);
__int64 _InterlockedDecrement64(__int64 volatile * _Addend);
__int64 _interlockeddecrement64(__int64 volatile * _Addend);
long _InterlockedExchange(long volatile * _Target, long _Value);

short _InterlockedExchange16(short volatile * _Target, short _Value);



__int64 _InterlockedExchange64(__int64 volatile * _Target, __int64 _Value);
__int64 _interlockedexchange64(__int64 volatile * _Target, __int64 _Value);



char _InterlockedExchange8(char volatile * _Target, char _Value);



long _InterlockedExchangeAdd(long volatile * _Addend, long _Value);
short _InterlockedExchangeAdd16(short volatile * _Addend, short _Value);



__int64 _InterlockedExchangeAdd64(__int64 volatile * _Addend, __int64 _Value);
__int64 _interlockedexchangeadd64(__int64 volatile * _Addend, __int64 _Value);



char _InterlockedExchangeAdd8(char volatile * _Addend, char _Value);









long _InterlockedIncrement(long volatile * _Addend);

short _InterlockedIncrement16(short volatile * _Addend);
__int64 _InterlockedIncrement64(__int64 volatile * _Addend);
__int64 _interlockedincrement64(__int64 volatile * _Addend);

long _InterlockedOr(long volatile * _Value, long _Mask);
short _InterlockedOr16(short volatile * _Value, short _Mask);



__int64 _InterlockedOr64(__int64 volatile * _Value, __int64 _Mask);
__int64 _interlockedor64(__int64 volatile * _Value, __int64 _Mask);



char _InterlockedOr8(char volatile * _Value, char _Mask);






long _InterlockedXor(long volatile * _Value, long _Mask);
short _InterlockedXor16(short volatile * _Value, short _Mask);



__int64 _InterlockedXor64(__int64 volatile * _Value, __int64 _Mask);
__int64 _interlockedxor64(__int64 volatile * _Value, __int64 _Mask);



char _InterlockedXor8(char volatile * _Value, char _Mask);






void _ReadWriteBarrier(void);
__int16 __iso_volatile_load16(const volatile __int16 *);
__int32 __iso_volatile_load32(const volatile __int32 *);
__int64 __iso_volatile_load64(const volatile __int64 *);
__int8 __iso_volatile_load8(const volatile __int8 *);
void __iso_volatile_store16(volatile __int16 *, __int16);
void __iso_volatile_store32(volatile __int32 *, __int32);
void __iso_volatile_store64(volatile __int64 *, __int64);
void __iso_volatile_store8(volatile __int8 *, __int8);


void _mm_pause(void);
unsigned int __lzcnt(unsigned int);
unsigned short __lzcnt16(unsigned short);
unsigned __int64 __lzcnt64(unsigned __int64);
unsigned int __popcnt(unsigned int);
unsigned short __popcnt16(unsigned short);
unsigned __int64 __popcnt64(unsigned __int64);
unsigned int __cdecl _rotl( unsigned int _Value, int _Shift);
unsigned short __cdecl _rotl16(unsigned short _Value, unsigned char _Shift);
unsigned __int64 __cdecl _rotl64( unsigned __int64 _Value, int _Shift);
unsigned char __cdecl _rotl8(unsigned char _Value, unsigned char _Shift);
unsigned int __cdecl _rotr( unsigned int _Value, int _Shift);
unsigned short __cdecl _rotr16(unsigned short _Value, unsigned char _Shift);
unsigned __int64 __cdecl _rotr64( unsigned __int64 _Value, int _Shift);
unsigned char __cdecl _rotr8(unsigned char _Value, unsigned char _Shift);
unsigned __int64 __shiftleft128(unsigned __int64 _LowPart, unsigned __int64 _HighPart, unsigned char _Shift);
unsigned __int64 __shiftright128(unsigned __int64 _LowPart, unsigned __int64 _HighPart, unsigned char _Shift);

unsigned int _tzcnt_u32(unsigned int);
unsigned __int64 _tzcnt_u64(unsigned __int64);
#line 282 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin0.inl.h"
unsigned __int64 _umul128(unsigned __int64 _Multiplier, unsigned __int64 _Multiplicand, unsigned __int64 * _HighProduct);

unsigned __int64 __cdecl _udiv128(unsigned __int64 _HighDividend, unsigned __int64 _LowDividend, unsigned __int64 _Divisor, unsigned __int64* _Remainder);
unsigned char __cdecl _addcarry_u64(unsigned char, unsigned __int64, unsigned __int64, unsigned __int64 *);
unsigned char __cdecl _subborrow_u64(unsigned char, unsigned __int64, unsigned __int64, unsigned __int64 *);
double __ceil(double);
float __ceilf(float);
double __floor(double);
float __floorf(float);
double __round(double);
float __roundf(float);
double __trunc(double);
float __truncf(float);
double __copysign(double, double);
float __copysignf(float, float);
unsigned __signbitvalue(double);
unsigned __signbitvaluef(float);







#line 307 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin0.inl.h"











constexpr void * __cdecl __builtin_assume_aligned(const void *, size_t, ...) noexcept;


#line 322 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin0.inl.h"
#line 323 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin0.inl.h"








}
#line 333 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin0.inl.h"
#pragma warning(pop) 
#line 335 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin0.inl.h"
#pragma external_header(pop)
#line 20 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin0.h"
#line 21 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin0.h"
#pragma external_header(pop)
#line 24 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"
#line 25 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"


#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"





#pragma once





#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\__msvc_iter_core.hpp"





#pragma once




#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"





#pragma once




#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"





#pragma once




#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cstdint"





#pragma once







#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




namespace std {
 using :: int8_t;
 using :: int16_t;
 using :: int32_t;
 using :: int64_t;
 using :: uint8_t;
 using :: uint16_t;
 using :: uint32_t;
 using :: uint64_t;

 using :: int_least8_t;
 using :: int_least16_t;
 using :: int_least32_t;
 using :: int_least64_t;
 using :: uint_least8_t;
 using :: uint_least16_t;
 using :: uint_least32_t;
 using :: uint_least64_t;

 using :: int_fast8_t;
 using :: int_fast16_t;
 using :: int_fast32_t;
 using :: int_fast64_t;
 using :: uint_fast8_t;
 using :: uint_fast16_t;
 using :: uint_fast32_t;
 using :: uint_fast64_t;

 using :: intmax_t;
 using :: intptr_t;
 using :: uintmax_t;
 using :: uintptr_t;



































#line 89 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cstdint"
}



#pragma warning(pop)
#pragma pack(pop)

#line 97 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cstdint"
#line 98 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cstdint"
#pragma external_header(pop)
#line 12 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"
#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstddef"





#pragma once




#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cstddef"





#pragma once








#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




namespace std {
 using :: ptrdiff_t;
 using :: size_t;
 using max_align_t = double; 
 using nullptr_t   = decltype(nullptr);


 enum class byte : unsigned char {};

 template <class _IntType, enable_if_t<is_integral_v<_IntType>, int> = 0>
[[nodiscard]] constexpr byte operator<<(const byte _Arg, const _IntType _Shift) noexcept {
    
    return static_cast<byte>(static_cast<unsigned char>(static_cast<unsigned int>(_Arg) << _Shift));
}

 template <class _IntType, enable_if_t<is_integral_v<_IntType>, int> = 0>
[[nodiscard]] constexpr byte operator>>(const byte _Arg, const _IntType _Shift) noexcept {
    
    return static_cast<byte>(static_cast<unsigned char>(static_cast<unsigned int>(_Arg) >> _Shift));
}

 [[nodiscard]] constexpr byte operator|(const byte _Left, const byte _Right) noexcept {
    
    return static_cast<byte>(
        static_cast<unsigned char>(static_cast<unsigned int>(_Left) | static_cast<unsigned int>(_Right)));
}

 [[nodiscard]] constexpr byte operator&(const byte _Left, const byte _Right) noexcept {
    
    return static_cast<byte>(
        static_cast<unsigned char>(static_cast<unsigned int>(_Left) & static_cast<unsigned int>(_Right)));
}

 [[nodiscard]] constexpr byte operator^(const byte _Left, const byte _Right) noexcept {
    
    return static_cast<byte>(
        static_cast<unsigned char>(static_cast<unsigned int>(_Left) ^ static_cast<unsigned int>(_Right)));
}

 [[nodiscard]] constexpr byte operator~(const byte _Arg) noexcept {
    
    return static_cast<byte>(static_cast<unsigned char>(~static_cast<unsigned int>(_Arg)));
}

 template <class _IntType, enable_if_t<is_integral_v<_IntType>, int> = 0>
constexpr byte& operator<<=(byte& _Arg, const _IntType _Shift) noexcept {
    return _Arg = _Arg << _Shift;
}

 template <class _IntType, enable_if_t<is_integral_v<_IntType>, int> = 0>
constexpr byte& operator>>=(byte& _Arg, const _IntType _Shift) noexcept {
    return _Arg = _Arg >> _Shift;
}

 constexpr byte& operator|=(byte& _Left, const byte _Right) noexcept {
    return _Left = _Left | _Right;
}

 constexpr byte& operator&=(byte& _Left, const byte _Right) noexcept {
    return _Left = _Left & _Right;
}

 constexpr byte& operator^=(byte& _Left, const byte _Right) noexcept {
    return _Left = _Left ^ _Right;
}

 template <class _IntType, enable_if_t<is_integral_v<_IntType>, int> = 0>
[[nodiscard]] constexpr _IntType to_integer(const byte _Arg) noexcept {
    return static_cast<_IntType>(_Arg);
}
#line 93 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cstddef"

}

using ::std:: max_align_t; 



#pragma warning(pop)
#pragma pack(pop)

#line 104 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cstddef"
#line 105 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cstddef"
#pragma external_header(pop)
#line 12 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstddef"

#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\initializer_list"





#pragma once






#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




namespace std {
 template <class _Elem>
class initializer_list {
public:
    using value_type      = _Elem;
    using reference       = const _Elem&;
    using const_reference = const _Elem&;
    using size_type       = size_t;

    using iterator       = const _Elem*;
    using const_iterator = const _Elem*;

    constexpr initializer_list() noexcept : _First(nullptr), _Last(nullptr) {}

    constexpr initializer_list(const _Elem* _First_arg, const _Elem* _Last_arg) noexcept
        : _First(_First_arg), _Last(_Last_arg) {}

    [[nodiscard]] constexpr const _Elem* begin() const noexcept {
        return _First;
    }

    [[nodiscard]] constexpr const _Elem* end() const noexcept {
        return _Last;
    }

    [[nodiscard]] constexpr size_t size() const noexcept {
        return static_cast<size_t>(_Last - _First);
    }

private:
    const _Elem* _First;
    const _Elem* _Last;
};

 template <class _Elem>
[[nodiscard]] constexpr const _Elem* begin(initializer_list<_Elem> _Ilist) noexcept {
    return _Ilist.begin();
}

 template <class _Elem>
[[nodiscard]] constexpr const _Elem* end(initializer_list<_Elem> _Ilist) noexcept {
    return _Ilist.end();
}
}


#pragma warning(pop)
#pragma pack(pop)
#line 69 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\initializer_list"
#line 70 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\initializer_list"
#pragma external_header(pop)
#line 14 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstddef"


#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




namespace std {
template <class>

inline constexpr bool _Always_false = false;















#line 43 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstddef"

#pragma warning(push)
#pragma warning(disable : 5215) 
#pragma warning(disable : 5216) 






template <class _Ty>
[[nodiscard]] _Ty _Fake_copy_init(_Ty) noexcept;









#pragma warning(pop)

 template <class _Ty = void>
struct plus {
    using _Unnameable_first_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]  = _Ty;
    using _Unnameable_second_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ty;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]          = _Ty;

    [[nodiscard]] constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left + _Right;
    }
};

 template <class _Ty = void>
struct minus {
    using _Unnameable_first_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]  = _Ty;
    using _Unnameable_second_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ty;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]          = _Ty;

    [[nodiscard]] constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left - _Right;
    }
};

 template <class _Ty = void>
struct multiplies {
    using _Unnameable_first_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]  = _Ty;
    using _Unnameable_second_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ty;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]          = _Ty;

    [[nodiscard]] constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left * _Right;
    }
};

 template <class _Ty = void>
struct equal_to {
    using _Unnameable_first_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]  = _Ty;
    using _Unnameable_second_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ty;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]          = bool;

    [[nodiscard]] constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
        noexcept(noexcept(_Fake_copy_init<bool>(_Left == _Right)))   {
        return _Left == _Right;
    }
};

 template <class _Ty = void>
struct not_equal_to {
    using _Unnameable_first_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]  = _Ty;
    using _Unnameable_second_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ty;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]          = bool;

    [[nodiscard]] constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
        noexcept(noexcept(_Fake_copy_init<bool>(_Left != _Right)))   {
        return _Left != _Right;
    }
};

 template <class _Ty = void>
struct greater {
    using _Unnameable_first_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]  = _Ty;
    using _Unnameable_second_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ty;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]          = bool;

    [[nodiscard]] constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
        noexcept(noexcept(_Fake_copy_init<bool>(_Left > _Right)))   {
        return _Left > _Right;
    }
};

 template <class _Ty = void>
struct less {
    using _Unnameable_first_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]  = _Ty;
    using _Unnameable_second_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ty;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]          = bool;

    [[nodiscard]] constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
        noexcept(noexcept(_Fake_copy_init<bool>(_Left < _Right)))   {
        return _Left < _Right;
    }
};

 template <class _Ty = void>
struct greater_equal {
    using _Unnameable_first_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]  = _Ty;
    using _Unnameable_second_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ty;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]          = bool;

    [[nodiscard]] constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
        noexcept(noexcept(_Fake_copy_init<bool>(_Left >= _Right)))   {
        return _Left >= _Right;
    }
};

 template <class _Ty = void>
struct less_equal {
    using _Unnameable_first_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]  = _Ty;
    using _Unnameable_second_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ty;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]          = bool;

    [[nodiscard]] constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
        noexcept(noexcept(_Fake_copy_init<bool>(_Left <= _Right)))   {
        return _Left <= _Right;
    }
};

template <>
struct plus<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) + static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) + static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) + static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct minus<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) - static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) - static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) - static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct multiplies<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) * static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) * static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) * static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct equal_to<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct not_equal_to<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) != static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) != static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) != static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct greater<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) > static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) > static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) > static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct less<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct greater_equal<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) >= static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) >= static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) >= static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct less_equal<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) <= static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) <= static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) <= static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

 template <class _Ty>
[[nodiscard]] constexpr _Ty* addressof(_Ty& _Val) noexcept {
    return __builtin_addressof(_Val);
}

 template <class _Ty>
const _Ty* addressof(const _Ty&&) = delete;

template <class _Ptrty>
[[nodiscard]] constexpr auto _Unfancy(_Ptrty _Ptr) noexcept { 
    return ::std:: addressof(*_Ptr);
}

template <class _Ty>
[[nodiscard]] constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { 
    return _Ptr;
}
}








#line 306 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstddef"




#line 311 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstddef"

#line 313 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstddef"








#line 322 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstddef"






#line 329 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstddef"

























#line 355 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstddef"


























#line 382 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstddef"









































#line 424 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstddef"



#pragma warning(pop)
#pragma pack(pop)
#line 430 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstddef"
#line 431 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xstddef"
#pragma external_header(pop)
#line 13 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




namespace std {
 template <class _Ty, _Ty... _Vals>
struct integer_sequence { 
    static_assert(is_integral_v<_Ty>, "integer_sequence<T, I...> requires T to be an integral type.");

    using value_type = _Ty;

    [[nodiscard]] static constexpr size_t size() noexcept {
        return sizeof...(_Vals);
    }
};

 template <class _Ty, _Ty _Size>
using make_integer_sequence = __make_integer_seq<integer_sequence, _Ty, _Size>;

 template <size_t... _Vals>
using index_sequence = integer_sequence<size_t, _Vals...>;

 template <size_t _Size>
using make_index_sequence = make_integer_sequence<size_t, _Size>;

 template <class... _Types>
using index_sequence_for = make_index_sequence<sizeof...(_Types)>;

template <bool _First_value, class _First, class... _Rest>
struct _Conjunction { 
    using type = _First;
};

template <class _True, class _Next, class... _Rest>
struct _Conjunction<true, _True, _Next, _Rest...> { 
    using type = typename _Conjunction<_Next::value, _Next, _Rest...>::type;
};

 template <class... _Traits>
struct conjunction : true_type {}; 

template <class _First, class... _Rest>
struct conjunction<_First, _Rest...> : _Conjunction<_First::value, _First, _Rest...>::type {
    
};

 template <class... _Traits>
inline constexpr bool conjunction_v = conjunction<_Traits...>::value;

 template <class _Trait>
struct negation : bool_constant<!static_cast<bool>(_Trait::value)> {}; 

 template <class _Trait>
inline constexpr bool negation_v = negation<_Trait>::value;

 template <class _Ty>
inline constexpr bool is_void_v = is_same_v<remove_cv_t<_Ty>, void>;

 template <class _Ty>
struct is_void : bool_constant<is_void_v<_Ty>> {};

 template <class... _Types>
using void_t = void;

template <class _Ty>
struct _Identity {
    using type = _Ty;
};
template <class _Ty>
using _Identity_t [[msvc::known_semantics]] = typename _Identity<_Ty>::type;


 template <class _Ty>
struct add_const { 
    using type = const _Ty;
};

 template <class _Ty>
using add_const_t = typename add_const<_Ty>::type;

 template <class _Ty>
struct add_volatile { 
    using type = volatile _Ty;
};

 template <class _Ty>
using add_volatile_t = typename add_volatile<_Ty>::type;

 template <class _Ty>
struct add_cv { 
    using type = const volatile _Ty;
};

 template <class _Ty>
using add_cv_t = typename add_cv<_Ty>::type;

template <class _Ty, class = void>
struct _Add_reference { 
    using _Lvalue = _Ty;
    using _Rvalue = _Ty;
};

template <class _Ty>
struct _Add_reference<_Ty, void_t<_Ty&>> { 
    using _Lvalue = _Ty&;
    using _Rvalue = _Ty&&;
};

 template <class _Ty>
struct add_lvalue_reference {
    using type = typename _Add_reference<_Ty>::_Lvalue;
};

 template <class _Ty>
using add_lvalue_reference_t = typename _Add_reference<_Ty>::_Lvalue;

 template <class _Ty>
struct add_rvalue_reference {
    using type = typename _Add_reference<_Ty>::_Rvalue;
};

 template <class _Ty>
using add_rvalue_reference_t = typename _Add_reference<_Ty>::_Rvalue;

 template <class _Ty>
add_rvalue_reference_t<_Ty> declval() noexcept {
    static_assert(_Always_false<_Ty>, "Calling declval is ill-formed, see N4917 22.2.6 [declval]/2.");
}

 template <class _Ty>
struct remove_extent { 
    using type = _Ty;
};

template <class _Ty, size_t _Ix>
struct remove_extent<_Ty[_Ix]> {
    using type = _Ty;
};

template <class _Ty>
struct remove_extent<_Ty[]> {
    using type = _Ty;
};

 template <class _Ty>
using remove_extent_t = typename remove_extent<_Ty>::type;

 template <class _Ty>
struct remove_all_extents { 
    using type = _Ty;
};

template <class _Ty, size_t _Ix>
struct remove_all_extents<_Ty[_Ix]> {
    using type = typename remove_all_extents<_Ty>::type;
};

template <class _Ty>
struct remove_all_extents<_Ty[]> {
    using type = typename remove_all_extents<_Ty>::type;
};

 template <class _Ty>
using remove_all_extents_t = typename remove_all_extents<_Ty>::type;

 template <class _Ty>
struct remove_pointer {
    using type = _Ty;
};

template <class _Ty>
struct remove_pointer<_Ty*> {
    using type = _Ty;
};

template <class _Ty>
struct remove_pointer<_Ty* const> {
    using type = _Ty;
};

template <class _Ty>
struct remove_pointer<_Ty* volatile> {
    using type = _Ty;
};

template <class _Ty>
struct remove_pointer<_Ty* const volatile> {
    using type = _Ty;
};

 template <class _Ty>
using remove_pointer_t = typename remove_pointer<_Ty>::type;

template <class _Ty, class = void>
struct _Add_pointer { 
    using type = _Ty;
};

template <class _Ty>
struct _Add_pointer<_Ty, void_t<remove_reference_t<_Ty>*>> { 
    using type = remove_reference_t<_Ty>*;
};

 template <class _Ty>
struct add_pointer {
    using type = typename _Add_pointer<_Ty>::type;
};

 template <class _Ty>
using add_pointer_t = typename _Add_pointer<_Ty>::type;

 template <class>
inline constexpr bool is_array_v = false; 

template <class _Ty, size_t _Nx>
inline constexpr bool is_array_v<_Ty[_Nx]> = true;

template <class _Ty>
inline constexpr bool is_array_v<_Ty[]> = true;

 template <class _Ty>
struct is_array : bool_constant<is_array_v<_Ty>> {};


 template <class>
inline constexpr bool is_bounded_array_v = false;

template <class _Ty, size_t _Nx>
inline constexpr bool is_bounded_array_v<_Ty[_Nx]> = true;

 template <class _Ty>
struct is_bounded_array : bool_constant<is_bounded_array_v<_Ty>> {};

 template <class>
inline constexpr bool is_unbounded_array_v = false;

template <class _Ty>
inline constexpr bool is_unbounded_array_v<_Ty[]> = true;

 template <class _Ty>
struct is_unbounded_array : bool_constant<is_unbounded_array_v<_Ty>> {};
#line 259 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

 template <class>
inline constexpr bool is_lvalue_reference_v = false; 

template <class _Ty>
inline constexpr bool is_lvalue_reference_v<_Ty&> = true;

 template <class _Ty>
struct is_lvalue_reference : bool_constant<is_lvalue_reference_v<_Ty>> {};

 template <class>
inline constexpr bool is_rvalue_reference_v = false; 

template <class _Ty>
inline constexpr bool is_rvalue_reference_v<_Ty&&> = true;

 template <class _Ty>
struct is_rvalue_reference : bool_constant<is_rvalue_reference_v<_Ty>> {};

 template <class>
inline constexpr bool is_reference_v = false; 

template <class _Ty>
inline constexpr bool is_reference_v<_Ty&> = true;

template <class _Ty>
inline constexpr bool is_reference_v<_Ty&&> = true;

 template <class _Ty>
struct is_reference : bool_constant<is_reference_v<_Ty>> {};

 template <class>
inline constexpr bool is_pointer_v = false; 

template <class _Ty>
inline constexpr bool is_pointer_v<_Ty*> = true;

template <class _Ty>
inline constexpr bool is_pointer_v<_Ty* const> = true;

template <class _Ty>
inline constexpr bool is_pointer_v<_Ty* volatile> = true;

template <class _Ty>
inline constexpr bool is_pointer_v<_Ty* const volatile> = true;

 template <class _Ty>
struct is_pointer : bool_constant<is_pointer_v<_Ty>> {};

 template <class _Ty>
inline constexpr bool is_null_pointer_v =
    is_same_v<remove_cv_t<_Ty>, nullptr_t>; 

 template <class _Ty>
struct is_null_pointer : bool_constant<is_null_pointer_v<_Ty>> {};

 template <class _Ty>
struct is_union : bool_constant<__is_union(_Ty)> {}; 

 template <class _Ty>
inline constexpr bool is_union_v = __is_union(_Ty);

 template <class _Ty>
struct is_class : bool_constant<__is_class(_Ty)> {}; 

 template <class _Ty>
inline constexpr bool is_class_v = __is_class(_Ty);

 template <class _Ty>
inline constexpr bool is_fundamental_v = is_arithmetic_v<_Ty> || is_void_v<_Ty> || is_null_pointer_v<_Ty>;

 template <class _Ty>
struct is_fundamental : bool_constant<is_fundamental_v<_Ty>> {}; 

 template <class _From, class _To>
struct is_convertible : bool_constant<__is_convertible_to(_From, _To)> {
    
};

 template <class _From, class _To>
inline constexpr bool is_convertible_v = __is_convertible_to(_From, _To);


template <class _Ty>
struct is_convertible<_Ty&, volatile _Ty&> : true_type {};

template <class _Ty>
struct is_convertible<volatile _Ty&, volatile _Ty&> : true_type {};

template <class _Ty>
struct is_convertible<_Ty&, const volatile _Ty&> : true_type {};

template <class _Ty>
struct is_convertible<volatile _Ty&, const volatile _Ty&> : true_type {};

template <class _Ty>
inline constexpr bool is_convertible_v<_Ty&, volatile _Ty&> = true;

template <class _Ty>
inline constexpr bool is_convertible_v<volatile _Ty&, volatile _Ty&> = true;

template <class _Ty>
inline constexpr bool is_convertible_v<_Ty&, const volatile _Ty&> = true;

template <class _Ty>
inline constexpr bool is_convertible_v<volatile _Ty&, const volatile _Ty&> = true;
#line 366 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

 template <class _Ty>
struct is_enum : bool_constant<__is_enum(_Ty)> {}; 

 template <class _Ty>
inline constexpr bool is_enum_v = __is_enum(_Ty);







#line 380 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

 template <class _Ty>
struct is_compound : bool_constant<!is_fundamental_v<_Ty>> {}; 

 template <class _Ty>
inline constexpr bool is_compound_v = !is_fundamental_v<_Ty>;

template <class... _Types>
struct _Arg_types {}; 

template <class _Ty1>
struct _Arg_types<_Ty1> {
    using _Unnameable_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ty1;
};

template <class _Ty1, class _Ty2>
struct _Arg_types<_Ty1, _Ty2> {
    using _Unnameable_first_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]  = _Ty1;
    using _Unnameable_second_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ty2;
};

template <class _Ty>
struct _Is_memfunptr { 
    using _Bool_type = false_type; 
};











template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)> : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...)> : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const> : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const> : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile> : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile> : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile> : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile> : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) &> : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) &> : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const &> : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const &> : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile &> : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile &> : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile &> : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile &> : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) &&> : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) &&> : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const &&> : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const &&> : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile &&> : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile &&> : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile &&> : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile &&> : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) noexcept> : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) noexcept> : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const noexcept> : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const noexcept> : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile noexcept> : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile noexcept> : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile noexcept> : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile noexcept> : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) & noexcept> : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) & noexcept> : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const & noexcept> : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const & noexcept> : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile & noexcept> : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile & noexcept> : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile & noexcept> : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile & noexcept> : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) && noexcept> : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) && noexcept> : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const && noexcept> : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const && noexcept> : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile && noexcept> : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile && noexcept> : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile && noexcept> : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile && noexcept> : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; };












template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...)> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) &> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const&> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile&> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile&> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) &&> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const&&> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile&&> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile&&> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) noexcept> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const noexcept> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile noexcept> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile noexcept> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) &noexcept> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const& noexcept> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile& noexcept> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile& noexcept> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) &&noexcept> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const&& noexcept> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile&& noexcept> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile&& noexcept> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; };
















#line 447 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"





 template <class _Ty>
inline constexpr bool is_member_function_pointer_v = _Is_memfunptr<remove_cv_t<_Ty>>::_Bool_type::value;
#line 455 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

 template <class _Ty>
struct is_member_function_pointer : bool_constant<is_member_function_pointer_v<_Ty>> {};

 template <class>
inline constexpr bool is_const_v = false; 

template <class _Ty>
inline constexpr bool is_const_v<const _Ty> = true;

 template <class _Ty>
struct is_const : bool_constant<is_const_v<_Ty>> {};

 template <class>
inline constexpr bool is_volatile_v = false; 

template <class _Ty>
inline constexpr bool is_volatile_v<volatile _Ty> = true;

 template <class _Ty>
struct is_volatile : bool_constant<is_volatile_v<_Ty>> {};

 template <class _Ty>
inline constexpr bool is_function_v = 
    !is_const_v<const _Ty> && !is_reference_v<_Ty>;

 template <class _Ty>
struct is_function : bool_constant<is_function_v<_Ty>> {};

 template <class _Ty>
inline constexpr bool is_object_v = 
    is_const_v<const _Ty> && !is_void_v<_Ty>;

 template <class _Ty>
struct is_object : bool_constant<is_object_v<_Ty>> {};

template <class>
struct _Is_member_object_pointer {
    static constexpr bool value = false;
};

template <class _Ty1, class _Ty2>
struct _Is_member_object_pointer<_Ty1 _Ty2::*> {
    static constexpr bool value = !is_function_v<_Ty1>;
    using _Class_type           = _Ty2;
};





 template <class _Ty>
inline constexpr bool is_member_object_pointer_v = _Is_member_object_pointer<remove_cv_t<_Ty>>::value;
#line 509 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

 template <class _Ty>
struct is_member_object_pointer : bool_constant<is_member_object_pointer_v<_Ty>> {};





 template <class _Ty>
inline constexpr bool is_member_pointer_v = is_member_object_pointer_v<_Ty> || is_member_function_pointer_v<_Ty>;
#line 520 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

 template <class _Ty>
struct is_member_pointer : bool_constant<is_member_pointer_v<_Ty>> {}; 

 template <class _Ty>
inline constexpr bool is_scalar_v = 
    is_arithmetic_v<_Ty> || is_enum_v<_Ty> || is_pointer_v<_Ty> || is_member_pointer_v<_Ty> || is_null_pointer_v<_Ty>;

 template <class _Ty>
struct is_scalar : bool_constant<is_scalar_v<_Ty>> {};

 template <class _Ty>
struct [[deprecated("warning STL4025: " "std::is_pod and std::is_pod_v are deprecated in C++20. " "The std::is_trivially_copyable and/or std::is_standard_layout traits likely suit your use case. " "You can define _SILENCE_CXX20_IS_POD_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] is_pod : bool_constant<__is_pod(_Ty)> {}; 

 template <class _Ty>
[[deprecated("warning STL4025: " "std::is_pod and std::is_pod_v are deprecated in C++20. " "The std::is_trivially_copyable and/or std::is_standard_layout traits likely suit your use case. " "You can define _SILENCE_CXX20_IS_POD_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] inline constexpr bool is_pod_v = __is_pod(_Ty);

 template <class _Ty>
struct is_empty : bool_constant<__is_empty(_Ty)> {}; 

 template <class _Ty>
inline constexpr bool is_empty_v = __is_empty(_Ty);

 template <class _Ty>
struct is_polymorphic : bool_constant<__is_polymorphic(_Ty)> {}; 

 template <class _Ty>
inline constexpr bool is_polymorphic_v = __is_polymorphic(_Ty);

 template <class _Ty>
struct is_abstract : bool_constant<__is_abstract(_Ty)> {}; 

 template <class _Ty>
inline constexpr bool is_abstract_v = __is_abstract(_Ty);

 template <class _Ty>
struct is_final : bool_constant<__is_final(_Ty)> {}; 

 template <class _Ty>
inline constexpr bool is_final_v = __is_final(_Ty);

 template <class _Ty>
struct is_standard_layout : bool_constant<__is_standard_layout(_Ty)> {}; 

 template <class _Ty>
inline constexpr bool is_standard_layout_v = __is_standard_layout(_Ty);









#line 576 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"


 template <class _Ty>
struct is_trivial : bool_constant<__is_trivially_constructible(_Ty) && __is_trivially_copyable(_Ty)> {
    
};

 template <class _Ty>
inline constexpr bool is_trivial_v = __is_trivially_constructible(_Ty) && __is_trivially_copyable(_Ty);






#line 592 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

 template <class _Ty>
struct is_trivially_copyable : bool_constant<__is_trivially_copyable(_Ty)> {
    
};

 template <class _Ty>
inline constexpr bool is_trivially_copyable_v = __is_trivially_copyable(_Ty);

 template <class _Ty>
struct has_virtual_destructor : bool_constant<__has_virtual_destructor(_Ty)> {
    
};

 template <class _Ty>
inline constexpr bool has_virtual_destructor_v = __has_virtual_destructor(_Ty);


 template <class _Ty>
struct has_unique_object_representations : bool_constant<__has_unique_object_representations(_Ty)> {
    
};

 template <class _Ty>
inline constexpr bool has_unique_object_representations_v = __has_unique_object_representations(_Ty);



template <class _Ty>
struct _Is_aggregate_impl : bool_constant<__is_aggregate(_Ty)> {};

 template <class _Ty>
inline constexpr bool is_aggregate_v = disjunction_v<is_array<_Ty>, _Is_aggregate_impl<_Ty>>;

 template <class _Ty>
struct is_aggregate : bool_constant<is_aggregate_v<_Ty>> {};






#line 635 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"
#line 636 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

 template <class _Ty, class... _Args>
struct is_constructible : bool_constant<__is_constructible(_Ty, _Args...)> {
    
};

 template <class _Ty, class... _Args>
inline constexpr bool is_constructible_v = __is_constructible(_Ty, _Args...);

 template <class _Ty>
struct is_copy_constructible : bool_constant<__is_constructible(_Ty, add_lvalue_reference_t<const _Ty>)> {
    
};

 template <class _Ty>
inline constexpr bool is_copy_constructible_v = __is_constructible(_Ty, add_lvalue_reference_t<const _Ty>);

 template <class _Ty>
struct is_default_constructible : bool_constant<__is_constructible(_Ty)> {
    
};

 template <class _Ty>
inline constexpr bool is_default_constructible_v = __is_constructible(_Ty);

template <class _Ty, class = void>
struct _Is_implicitly_default_constructible : false_type {
    
};

template <class _Ty>
void _Implicitly_default_construct(const _Ty&);

template <class _Ty>
struct _Is_implicitly_default_constructible<_Ty, void_t<decltype(_Implicitly_default_construct<_Ty>({}))>> : true_type {
};

 template <class _Ty>
struct is_move_constructible : bool_constant<__is_constructible(_Ty, _Ty)> {
    
};

 template <class _Ty>
inline constexpr bool is_move_constructible_v = __is_constructible(_Ty, _Ty);

 template <class _To, class _From>
struct is_assignable : bool_constant<__is_assignable(_To, _From)> {}; 

 template <class _To, class _From>
inline constexpr bool is_assignable_v = __is_assignable(_To, _From);


template <class _To, class _From>
struct _Is_assignable_no_precondition_check : bool_constant<__is_assignable_no_precondition_check(_To, _From)> {};



#line 694 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

 template <class _Ty>
struct is_copy_assignable
    : bool_constant<__is_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)> {
    
};

 template <class _Ty>
inline constexpr bool is_copy_assignable_v =
    __is_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);


template <class _Ty>
struct _Is_copy_assignable_no_precondition_check
    : bool_constant<__is_assignable_no_precondition_check(
          add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)> {};

template <class _Ty>
inline constexpr bool _Is_copy_assignable_unchecked_v =
    __is_assignable_no_precondition_check(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);






#line 721 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

 template <class _Ty>
struct is_move_assignable : bool_constant<__is_assignable(add_lvalue_reference_t<_Ty>, _Ty)> {
    
};

 template <class _Ty>
inline constexpr bool is_move_assignable_v = __is_assignable(add_lvalue_reference_t<_Ty>, _Ty);


template <class _Ty>
struct _Is_move_assignable_no_precondition_check
    : bool_constant<__is_assignable_no_precondition_check(add_lvalue_reference_t<_Ty>, _Ty)> {};

template <class _Ty>
inline constexpr bool _Is_move_assignable_unchecked_v =
    __is_assignable_no_precondition_check(add_lvalue_reference_t<_Ty>, _Ty);






#line 745 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

 template <class _Ty>
struct is_destructible : bool_constant<__is_destructible(_Ty)> {
    
};

 template <class _Ty>
inline constexpr bool is_destructible_v = __is_destructible(_Ty);

 template <class _Ty, class... _Args>
struct is_trivially_constructible : bool_constant<__is_trivially_constructible(_Ty, _Args...)> {
    
};

 template <class _Ty, class... _Args>
inline constexpr bool is_trivially_constructible_v = __is_trivially_constructible(_Ty, _Args...);

 template <class _Ty>
struct is_trivially_copy_constructible
    : bool_constant<__is_trivially_constructible(_Ty, add_lvalue_reference_t<const _Ty>)> {
    
};

 template <class _Ty>
inline constexpr bool is_trivially_copy_constructible_v =
    __is_trivially_constructible(_Ty, add_lvalue_reference_t<const _Ty>);

 template <class _Ty>
struct is_trivially_default_constructible : bool_constant<__is_trivially_constructible(_Ty)> {
    
};

 template <class _Ty>
inline constexpr bool is_trivially_default_constructible_v = __is_trivially_constructible(_Ty);

 template <class _Ty>
struct is_trivially_move_constructible : bool_constant<__is_trivially_constructible(_Ty, _Ty)> {
    
};

 template <class _Ty>
inline constexpr bool is_trivially_move_constructible_v = __is_trivially_constructible(_Ty, _Ty);

 template <class _To, class _From>
struct is_trivially_assignable : bool_constant<__is_trivially_assignable(_To, _From)> {
    
};

 template <class _To, class _From>
inline constexpr bool is_trivially_assignable_v = __is_trivially_assignable(_To, _From);

 template <class _Ty>
struct is_trivially_copy_assignable
    : bool_constant<__is_trivially_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)> {
    
};

 template <class _Ty>
inline constexpr bool is_trivially_copy_assignable_v =
    __is_trivially_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);

 template <class _Ty>
struct is_trivially_move_assignable : bool_constant<__is_trivially_assignable(add_lvalue_reference_t<_Ty>, _Ty)> {
    
};

 template <class _Ty>
inline constexpr bool is_trivially_move_assignable_v = __is_trivially_assignable(add_lvalue_reference_t<_Ty>, _Ty);

 template <class _Ty>
struct is_trivially_destructible : bool_constant<__is_trivially_destructible(_Ty)> {
    
};

 template <class _Ty>
inline constexpr bool is_trivially_destructible_v = __is_trivially_destructible(_Ty);

 template <class _Ty, class... _Args>
struct is_nothrow_constructible : bool_constant<__is_nothrow_constructible(_Ty, _Args...)> {
    
};

 template <class _Ty, class... _Args>
inline constexpr bool is_nothrow_constructible_v = __is_nothrow_constructible(_Ty, _Args...);

 template <class _Ty>
struct is_nothrow_copy_constructible
    : bool_constant<__is_nothrow_constructible(_Ty, add_lvalue_reference_t<const _Ty>)> {
    
    
};

 template <class _Ty>
inline constexpr bool is_nothrow_copy_constructible_v =
    __is_nothrow_constructible(_Ty, add_lvalue_reference_t<const _Ty>);

 template <class _Ty>
struct is_nothrow_default_constructible : bool_constant<__is_nothrow_constructible(_Ty)> {
    
};

 template <class _Ty>
inline constexpr bool is_nothrow_default_constructible_v = __is_nothrow_constructible(_Ty);

 template <class _Ty>
struct is_nothrow_move_constructible : bool_constant<__is_nothrow_constructible(_Ty, _Ty)> {
    
};

 template <class _Ty>
inline constexpr bool is_nothrow_move_constructible_v = __is_nothrow_constructible(_Ty, _Ty);

 template <class _To, class _From>
struct is_nothrow_assignable : bool_constant<__is_nothrow_assignable(_To, _From)> {
    
};

 template <class _To, class _From>
inline constexpr bool is_nothrow_assignable_v = __is_nothrow_assignable(_To, _From);

 template <class _Ty>
struct is_nothrow_copy_assignable
    : bool_constant<__is_nothrow_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)> {
    
};

 template <class _Ty>
inline constexpr bool is_nothrow_copy_assignable_v =
    __is_nothrow_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);

 template <class _Ty>
struct is_nothrow_move_assignable : bool_constant<__is_nothrow_assignable(add_lvalue_reference_t<_Ty>, _Ty)> {
    
};

 template <class _Ty>
inline constexpr bool is_nothrow_move_assignable_v = __is_nothrow_assignable(add_lvalue_reference_t<_Ty>, _Ty);

 template <class _Ty>
struct is_nothrow_destructible : bool_constant<__is_nothrow_destructible(_Ty)> {
    
    
};

 template <class _Ty>
inline constexpr bool is_nothrow_destructible_v = __is_nothrow_destructible(_Ty);

template <class _Ty, bool = is_integral_v<_Ty>>
struct _Sign_base { 
    using _Uty = remove_cv_t<_Ty>;

    static constexpr bool _Signed   = static_cast<_Uty>(-1) < static_cast<_Uty>(0);
    static constexpr bool _Unsigned = !_Signed;
};

template <class _Ty>
struct _Sign_base<_Ty, false> { 
                                
    static constexpr bool _Signed   = is_floating_point_v<_Ty>;
    static constexpr bool _Unsigned = false;
};

 template <class _Ty>
struct is_signed : bool_constant<_Sign_base<_Ty>::_Signed> {}; 

 template <class _Ty>
inline constexpr bool is_signed_v = _Sign_base<_Ty>::_Signed;

 template <class _Ty>
struct is_unsigned : bool_constant<_Sign_base<_Ty>::_Unsigned> {}; 

 template <class _Ty>
inline constexpr bool is_unsigned_v = _Sign_base<_Ty>::_Unsigned;

template <class _Ty>
inline constexpr bool _Is_nonbool_integral = is_integral_v<_Ty> && !is_same_v<remove_cv_t<_Ty>, bool>;

template <bool>
struct _Select { 
    template <class _Ty1, class>
    using _Apply = _Ty1;
};

template <>
struct _Select<false> {
    template <class, class _Ty2>
    using _Apply = _Ty2;
};

template <size_t>
struct _Make_signed2; 

template <>
struct _Make_signed2<1> {
    template <class>
    using _Apply = signed char;
};

template <>
struct _Make_signed2<2> {
    template <class>
    using _Apply = short;
};

template <>
struct _Make_signed2<4> {
    template <class _Ty>
    using _Apply = 
        typename _Select<is_same_v<_Ty, long> || is_same_v<_Ty, unsigned long>>::template _Apply<long, int>;
};

template <>
struct _Make_signed2<8> {
    template <class>
    using _Apply = long long;
};

template <class _Ty>
using _Make_signed1 = 
    typename _Make_signed2<sizeof(_Ty)>::template _Apply<_Ty>;

 template <class _Ty>
struct make_signed { 
    static_assert(_Is_nonbool_integral<_Ty> || is_enum_v<_Ty>,
        "make_signed<T> requires that T shall be a (possibly cv-qualified) "
        "integral type or enumeration but not a bool type.");

    using type = typename remove_cv<_Ty>::template _Apply<_Make_signed1>;
};

 template <class _Ty>
using make_signed_t = typename make_signed<_Ty>::type;

template <size_t>
struct _Make_unsigned2; 

template <>
struct _Make_unsigned2<1> {
    template <class>
    using _Apply = unsigned char;
};

template <>
struct _Make_unsigned2<2> {
    template <class>
    using _Apply = unsigned short;
};

template <>
struct _Make_unsigned2<4> {
    template <class _Ty>
    using _Apply = 
        typename _Select<is_same_v<_Ty, long> || is_same_v<_Ty, unsigned long>>::template _Apply<unsigned long,
            unsigned int>;
};

template <>
struct _Make_unsigned2<8> {
    template <class>
    using _Apply = unsigned long long;
};

template <class _Ty>
using _Make_unsigned1 = 
    typename _Make_unsigned2<sizeof(_Ty)>::template _Apply<_Ty>;

 template <class _Ty>
struct make_unsigned { 
    static_assert(_Is_nonbool_integral<_Ty> || is_enum_v<_Ty>,
        "make_unsigned<T> requires that T shall be a (possibly cv-qualified) "
        "integral type or enumeration but not a bool type.");

    using type = typename remove_cv<_Ty>::template _Apply<_Make_unsigned1>;
};

 template <class _Ty>
using make_unsigned_t = typename make_unsigned<_Ty>::type;

template <class _Rep>
constexpr make_unsigned_t<_Rep> _Unsigned_value(_Rep _Val) { 
    return static_cast<make_unsigned_t<_Rep>>(_Val);
}

 template <class _Ty>
struct alignment_of : integral_constant<size_t, alignof(_Ty)> {}; 

 template <class _Ty>
inline constexpr size_t alignment_of_v = alignof(_Ty);

template <class _Ty, size_t _Len>
union _Align_type { 
    _Ty _Val;
    char _Pad[_Len];
};

template <size_t _Len, size_t _Align, class _Ty, bool _Ok>
struct _Aligned; 

template <size_t _Len, size_t _Align, class _Ty>
struct _Aligned<_Len, _Align, _Ty, true> {
    using type = _Align_type<_Ty, _Len>;
};

template <size_t _Len, size_t _Align>
struct _Aligned<_Len, _Align, double, false> {






    static_assert(_Always_false<_Aligned>,
        "You've instantiated std::aligned_storage<Len, Align> with an extended alignment (in other "
        "words, Align > alignof(max_align_t)). Before VS 2017 15.8, the member \"type\" would "
        "non-conformingly have an alignment of only alignof(max_align_t). VS 2017 15.8 was fixed to "
        "handle this correctly, but the fix inherently changes layout and breaks binary compatibility "
        "(*only* for uses of aligned_storage with extended alignments). "
        "To suppress this error, please define either "
        "(1) _ENABLE_EXTENDED_ALIGNED_STORAGE to confirm that you want a type with an extended alignment, or "
        "(2) _DISABLE_EXTENDED_ALIGNED_STORAGE to get the old non-conforming behavior.");
#line 1066 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"
    using type = _Align_type<max_align_t, _Len>;
#line 1068 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"
};

template <size_t _Len, size_t _Align>
struct _Aligned<_Len, _Align, int, false> {
    using _Next                 = double;
    static constexpr bool _Fits = _Align <= alignof(_Next);
    using type                  = typename _Aligned<_Len, _Align, _Next, _Fits>::type;
};

template <size_t _Len, size_t _Align>
struct _Aligned<_Len, _Align, short, false> {
    using _Next                 = int;
    static constexpr bool _Fits = _Align <= alignof(_Next);
    using type                  = typename _Aligned<_Len, _Align, _Next, _Fits>::type;
};

template <size_t _Len, size_t _Align>
struct _Aligned<_Len, _Align, char, false> {
    using _Next                 = short;
    static constexpr bool _Fits = _Align <= alignof(_Next);
    using type                  = typename _Aligned<_Len, _Align, _Next, _Fits>::type;
};


template <size_t _Len, size_t _Align = alignof(max_align_t)>
struct _Aligned_storage { 
    using _Next                 = char;
    static constexpr bool _Fits = _Align <= alignof(_Next);
    using type                  = typename _Aligned<_Len, _Align, _Next, _Fits>::type;
};

template <size_t _Len, size_t _Align = alignof(max_align_t)>
using _Aligned_storage_t = typename _Aligned_storage<_Len, _Align>::type;

 template <size_t _Len, size_t _Align = alignof(max_align_t)>
struct  aligned_storage { 
    using type = _Aligned_storage_t<_Len, _Align>;
};

 template <size_t _Len, size_t _Align = alignof(max_align_t)>
using aligned_storage_t  = _Aligned_storage_t<_Len, _Align>;

template <size_t... _Vals>
struct _Maximum;

template <>
struct _Maximum<> : integral_constant<size_t, 0> {}; 

template <size_t _Val>
struct _Maximum<_Val> : integral_constant<size_t, _Val> {}; 

template <size_t _First, size_t _Second, size_t... _Rest>
struct _Maximum<_First, _Second, _Rest...> : _Maximum<(_First < _Second ? _Second : _First), _Rest...>::type {
    
};

 template <size_t _Len, class... _Types>
struct  aligned_union {
    
    static constexpr size_t _Max_len        = _Maximum<_Len, sizeof(_Types)...>::value; 
    static constexpr size_t alignment_value = _Maximum<alignof(_Types)...>::value;

    using type = _Aligned_storage_t<_Max_len, alignment_value>;
};

__pragma(warning(push)) __pragma(warning(disable : 4996))
 template <size_t _Len, class... _Types>
using aligned_union_t  = typename aligned_union<_Len, _Types...>::type;
__pragma(warning(pop))

template <class _Ty, bool = is_enum_v<_Ty>>
struct _Underlying_type {
    using type = __underlying_type(_Ty);
};

template <class _Ty>
struct _Underlying_type<_Ty, false> {};

 template <class _Ty>
struct underlying_type : _Underlying_type<_Ty> {}; 

 template <class _Ty>
using underlying_type_t = typename _Underlying_type<_Ty>::type;

 template <class _Ty>
inline constexpr size_t rank_v = 0; 

template <class _Ty, size_t _Nx>
inline constexpr size_t rank_v<_Ty[_Nx]> = rank_v<_Ty> + 1;

template <class _Ty>
inline constexpr size_t rank_v<_Ty[]> = rank_v<_Ty> + 1;

 template <class _Ty>
struct rank : integral_constant<size_t, rank_v<_Ty>> {};

 template <class _Ty, unsigned int _Ix = 0>
inline constexpr size_t extent_v = 0; 

template <class _Ty, size_t _Nx>
inline constexpr size_t extent_v<_Ty[_Nx], 0> = _Nx;

template <class _Ty, unsigned int _Ix, size_t _Nx>
inline constexpr size_t extent_v<_Ty[_Nx], _Ix> = extent_v<_Ty, _Ix - 1>;

template <class _Ty, unsigned int _Ix>
inline constexpr size_t extent_v<_Ty[], _Ix> = extent_v<_Ty, _Ix - 1>;

 template <class _Ty, unsigned int _Ix = 0>
struct extent : integral_constant<size_t, extent_v<_Ty, _Ix>> {};

 template <class _Base, class _Derived>
struct is_base_of : bool_constant<__is_base_of(_Base, _Derived)> {
    
};

 template <class _Base, class _Derived>
inline constexpr bool is_base_of_v = __is_base_of(_Base, _Derived);

 template <class _Ty>
struct decay { 
    using _Ty1 = remove_reference_t<_Ty>;
    using _Ty2 = typename _Select<is_function_v<_Ty1>>::template _Apply<add_pointer<_Ty1>, remove_cv<_Ty1>>;
    using type = typename _Select<is_array_v<_Ty1>>::template _Apply<add_pointer<remove_extent_t<_Ty1>>, _Ty2>::type;
};

 template <class _Ty>
using decay_t = typename decay<_Ty>::type;

template <class _Ty1, class _Ty2>
using _Conditional_type = decltype(false ? ::std:: declval<_Ty1>() : ::std:: declval<_Ty2>());


template <class _Ty1, class _Ty2, class = void>
struct _Const_lvalue_cond_oper {};



template <class _Ty1, class _Ty2>
struct _Const_lvalue_cond_oper<_Ty1, _Ty2, void_t<_Conditional_type<const _Ty1&, const _Ty2&>>> {
    using type = remove_cvref_t<_Conditional_type<const _Ty1&, const _Ty2&>>;
};

template <class _Ty1, class _Ty2, class = void>
struct _Decayed_cond_oper : _Const_lvalue_cond_oper<_Ty1, _Ty2> {};



#line 1217 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

template <class _Ty1, class _Ty2>
struct _Decayed_cond_oper<_Ty1, _Ty2, void_t<_Conditional_type<_Ty1, _Ty2>>> {
    using type = decay_t<_Conditional_type<_Ty1, _Ty2>>;
};

 template <class... _Ty>
struct common_type;

 template <class... _Ty>
using common_type_t = typename common_type<_Ty...>::type;

template <>
struct common_type<> {};

template <class _Ty1>
struct common_type<_Ty1> : common_type<_Ty1, _Ty1> {};

template <class _Ty1, class _Ty2, class _Decayed1 = decay_t<_Ty1>, class _Decayed2 = decay_t<_Ty2>>
struct _Common_type2 : common_type<_Decayed1, _Decayed2> {};

template <class _Ty1, class _Ty2>
struct _Common_type2<_Ty1, _Ty2, _Ty1, _Ty2> : _Decayed_cond_oper<_Ty1, _Ty2> {};

template <class _Ty1, class _Ty2>
struct common_type<_Ty1, _Ty2> : _Common_type2<_Ty1, _Ty2> {};

template <class _Void, class _Ty1, class _Ty2, class... _Rest>
struct _Common_type3 {};

template <class _Ty1, class _Ty2, class... _Rest>
struct _Common_type3<void_t<common_type_t<_Ty1, _Ty2>>, _Ty1, _Ty2, _Rest...>
    : common_type<common_type_t<_Ty1, _Ty2>, _Rest...> {};

template <class _Ty1, class _Ty2, class... _Rest>
struct common_type<_Ty1, _Ty2, _Rest...> : _Common_type3<void, _Ty1, _Ty2, _Rest...> {};

template <class _Ty>
_Ty _Returns_exactly() noexcept; 


 template <class, class, template <class> class, template <class> class>
struct basic_common_reference {};

template <class _From>
struct _Copy_cv_impl {
    template <class _To>
    using _Apply = _To;
};
template <class _From>
struct _Copy_cv_impl<const _From> {
    template <class _To>
    using _Apply = const _To;
};
template <class _From>
struct _Copy_cv_impl<volatile _From> {
    template <class _To>
    using _Apply = volatile _To;
};
template <class _From>
struct _Copy_cv_impl<const volatile _From> {
    template <class _To>
    using _Apply = const volatile _To;
};
template <class _From, class _To>
using _Copy_cv = 
    typename _Copy_cv_impl<_From>::template _Apply<_To>;

template <class _Ty1>
struct _Add_qualifiers { 
    template <class _Ty2>
    using _Apply = _Copy_cv<_Ty1, _Ty2>;
};
template <class _Ty1>
struct _Add_qualifiers<_Ty1&> {
    template <class _Ty2>
    using _Apply = add_lvalue_reference_t<_Copy_cv<_Ty1, _Ty2>>;
};
template <class _Ty1>
struct _Add_qualifiers<_Ty1&&> {
    template <class _Ty2>
    using _Apply = add_rvalue_reference_t<_Copy_cv<_Ty1, _Ty2>>;
};


template <class _Ty1, class _Ty2>
using _Cond_res_if_right = 
    decltype(false ? _Returns_exactly<_Ty1>() : _Returns_exactly<_Ty2>());

template <class _Ty>
using _Is_scalar_or_array = disjunction<is_scalar<_Ty>, is_array<_Ty>>;

template <class _Ty1, class _Ty2, class = void>
struct _Cond_res_workaround {};

template <class _Ty1, class _Ty2>
struct _Cond_res_workaround<_Ty1, _Ty2, void_t<_Cond_res_if_right<_Ty1, _Ty2>>> {
    using _Uty = remove_cvref_t<_Ty1>;
    using type = conditional_t<conjunction_v<is_same<_Uty, remove_cvref_t<_Ty2>>, _Is_scalar_or_array<_Uty>,
                                   disjunction<conjunction<is_lvalue_reference<_Ty1>, is_rvalue_reference<_Ty2>>,
                                       conjunction<is_rvalue_reference<_Ty1>, is_lvalue_reference<_Ty2>>>>,
        decay_t<_Copy_cv<remove_reference_t<_Ty1>, remove_reference_t<_Ty2>>>, _Cond_res_if_right<_Ty1, _Ty2>>;
};

template <class _Ty1, class _Ty2>
using _Cond_res = typename _Cond_res_workaround<_Ty1, _Ty2>::type;




#line 1328 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

 template <class...>
struct common_reference;

 template <class... _Types>
using common_reference_t = typename common_reference<_Types...>::type;


template <>
struct common_reference<> {};


template <class _Ty>
struct common_reference<_Ty> {
    using type = _Ty;
};





template <class _Ty1, class _Ty2, class = void>
struct _Common_reference2C : common_type<_Ty1, _Ty2> {};


template <class _Ty1, class _Ty2>
struct _Common_reference2C<_Ty1, _Ty2, void_t<_Cond_res<_Ty1, _Ty2>>> {
    using type = _Cond_res<_Ty1, _Ty2>;
};


template <class _Ty1, class _Ty2>
using _Basic_specialization = typename basic_common_reference<remove_cvref_t<_Ty1>, remove_cvref_t<_Ty2>,
    _Add_qualifiers<_Ty1>::template _Apply, _Add_qualifiers<_Ty2>::template _Apply>::type;

template <class _Ty1, class _Ty2, class = void>
struct _Common_reference2B : _Common_reference2C<_Ty1, _Ty2> {};

template <class _Ty1, class _Ty2>
struct _Common_reference2B<_Ty1, _Ty2, void_t<_Basic_specialization<_Ty1, _Ty2>>> {
    using type = _Basic_specialization<_Ty1, _Ty2>;
};


template <class _Ty1, class _Ty2, class = void>
struct _Common_reference2A : _Common_reference2B<_Ty1, _Ty2> {};

template <class _Ty1, class _Ty2, class _Result = _Cond_res<_Copy_cv<_Ty1, _Ty2>&, _Copy_cv<_Ty2, _Ty1>&>,
    enable_if_t<is_lvalue_reference_v<_Result>, int> = 0>
using _LL_common_ref = _Result;

template <class _Ty1, class _Ty2>
struct _Common_reference2A<_Ty1&, _Ty2&, void_t<_LL_common_ref<_Ty1, _Ty2>>> {
    using type = _LL_common_ref<_Ty1, _Ty2>; 
};

template <class _Ty1, class _Ty2>
struct _Common_reference2A<_Ty1&&, _Ty2&, enable_if_t<is_convertible_v<_Ty1&&, _LL_common_ref<const _Ty1, _Ty2>>>> {
    using type =
        _LL_common_ref<const _Ty1, _Ty2>; 
};

template <class _Ty1, class _Ty2>
struct _Common_reference2A<_Ty1&, _Ty2&&, enable_if_t<is_convertible_v<_Ty2&&, _LL_common_ref<const _Ty2, _Ty1>>>> {
    using type =
        _LL_common_ref<const _Ty2, _Ty1>; 
};

template <class _Ty1, class _Ty2>
using _RR_common_ref = remove_reference_t<_LL_common_ref<_Ty1, _Ty2>>&&;

template <class _Ty1, class _Ty2>
struct _Common_reference2A<_Ty1&&, _Ty2&&,
    enable_if_t<is_convertible_v<_Ty1&&, _RR_common_ref<_Ty1, _Ty2>>
                && is_convertible_v<_Ty2&&, _RR_common_ref<_Ty1, _Ty2>>>> {
    using type = _RR_common_ref<_Ty1, _Ty2>; 
};

template <class _Ty1, class _Ty2>
struct common_reference<_Ty1, _Ty2> : _Common_reference2A<_Ty1, _Ty2> {};


template <class _Void, class _Ty1, class _Ty2, class... _Types>
struct _Fold_common_reference {};
template <class _Ty1, class _Ty2, class... _Types>
struct _Fold_common_reference<void_t<common_reference_t<_Ty1, _Ty2>>, _Ty1, _Ty2, _Types...>
    : common_reference<common_reference_t<_Ty1, _Ty2>, _Types...> {};

template <class _Ty1, class _Ty2, class _Ty3, class... _Rest>
struct common_reference<_Ty1, _Ty2, _Ty3, _Rest...> : _Fold_common_reference<void, _Ty1, _Ty2, _Ty3, _Rest...> {};
#line 1419 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"


 template <class _Ty>
struct type_identity {
    using type = _Ty;
};
 template <class _Ty>
using type_identity_t = typename type_identity<_Ty>::type;
#line 1428 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

template <class _Type, template <class...> class _Template>
inline constexpr bool _Is_specialization_v = false; 
template <template <class...> class _Template, class... _Types>
inline constexpr bool _Is_specialization_v<_Template<_Types...>, _Template> = true;

template <class _Type, template <class...> class _Template>
struct _Is_specialization : bool_constant<_Is_specialization_v<_Type, _Template>> {};

 template <class _Ty>
[[nodiscard]] [[msvc::intrinsic]] constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {
    return static_cast<_Ty&&>(_Arg);
}

 template <class _Ty>
[[nodiscard]] [[msvc::intrinsic]] constexpr _Ty&& forward(remove_reference_t<_Ty>&& _Arg) noexcept {
    static_assert(!is_lvalue_reference_v<_Ty>, "bad forward call");
    return static_cast<_Ty&&>(_Arg);
}

 template <class _Ty>
[[nodiscard]] [[msvc::intrinsic]] constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {
    return static_cast<remove_reference_t<_Ty>&&>(_Arg);
}

 template <class _Ty>
[[nodiscard]] [[msvc::intrinsic]] constexpr 
    conditional_t<!is_nothrow_move_constructible_v<_Ty> && is_copy_constructible_v<_Ty>, const _Ty&, _Ty&&>
    move_if_noexcept(_Ty& _Arg) noexcept {
    return ::std:: move(_Arg);
}

 template <class _Ty>
class reference_wrapper;






enum class _Invoker_strategy {
    _Functor,
    _Pmf_object,
    _Pmf_refwrap,
    _Pmf_pointer,
    _Pmd_object,
    _Pmd_refwrap,
    _Pmd_pointer
};

struct _Invoker_functor {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Functor;

    template <class _Callable, class... _Types>
    static constexpr auto _Call(_Callable&& _Obj, _Types&&... _Args) noexcept(
        noexcept(static_cast<_Callable&&>(_Obj)(static_cast<_Types&&>(_Args)...)))
        -> decltype(static_cast<_Callable&&>(_Obj)(static_cast<_Types&&>(_Args)...)) {
        return static_cast<_Callable&&>(_Obj)(static_cast<_Types&&>(_Args)...);
    }
};

struct _Invoker_pmf_object {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmf_object;

    template <class _Decayed, class _Ty1, class... _Types2>
    static constexpr auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2) noexcept(
        noexcept((static_cast<_Ty1&&>(_Arg1).*_Pmf)(static_cast<_Types2&&>(_Args2)...)))
        -> decltype((static_cast<_Ty1&&>(_Arg1).*_Pmf)(static_cast<_Types2&&>(_Args2)...)) {
        return (static_cast<_Ty1&&>(_Arg1).*_Pmf)(static_cast<_Types2&&>(_Args2)...);
    }
};

struct _Invoker_pmf_refwrap {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmf_refwrap;

    template <class _Decayed, class _Refwrap, class... _Types2>
    static constexpr auto _Call(_Decayed _Pmf, _Refwrap _Rw, _Types2&&... _Args2) noexcept(
        noexcept((_Rw.get().*_Pmf)(static_cast<_Types2&&>(_Args2)...)))
        -> decltype((_Rw.get().*_Pmf)(static_cast<_Types2&&>(_Args2)...)) {
        return (_Rw.get().*_Pmf)(static_cast<_Types2&&>(_Args2)...);
    }
};

struct _Invoker_pmf_pointer {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmf_pointer;

    template <class _Decayed, class _Ty1, class... _Types2>
    static constexpr auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2) noexcept(
        noexcept(((*static_cast<_Ty1&&>(_Arg1)).*_Pmf)(static_cast<_Types2&&>(_Args2)...)))
        -> decltype(((*static_cast<_Ty1&&>(_Arg1)).*_Pmf)(static_cast<_Types2&&>(_Args2)...)) {
        return ((*static_cast<_Ty1&&>(_Arg1)).*_Pmf)(static_cast<_Types2&&>(_Args2)...);
    }
};

struct _Invoker_pmd_object {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmd_object;

    template <class _Decayed, class _Ty1>
    static constexpr auto _Call(_Decayed _Pmd, _Ty1&& _Arg1) noexcept -> decltype(static_cast<_Ty1&&>(_Arg1).*_Pmd) {
        return static_cast<_Ty1&&>(_Arg1).*_Pmd;
    }
};

struct _Invoker_pmd_refwrap {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmd_refwrap;

    template <class _Decayed, class _Refwrap>
    static constexpr auto _Call(_Decayed _Pmd, _Refwrap _Rw) noexcept -> decltype(_Rw.get().*_Pmd) {
        return _Rw.get().*_Pmd;
    }
};

struct _Invoker_pmd_pointer {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmd_pointer;

    template <class _Decayed, class _Ty1>
    static constexpr auto _Call(_Decayed _Pmd, _Ty1&& _Arg1) noexcept(noexcept((*static_cast<_Ty1&&>(_Arg1)).*_Pmd))
        -> decltype((*static_cast<_Ty1&&>(_Arg1)).*_Pmd) {
        return (*static_cast<_Ty1&&>(_Arg1)).*_Pmd;
    }
};

template <class _Callable, class _Ty1, class _Removed_cvref = _Remove_cvref_t<_Callable>,
    bool _Is_pmf = is_member_function_pointer_v<_Removed_cvref>,
    bool _Is_pmd = is_member_object_pointer_v<_Removed_cvref>>
struct _Invoker1;

template <class _Callable, class _Ty1, class _Removed_cvref>
struct _Invoker1<_Callable, _Ty1, _Removed_cvref, true, false>
    : conditional_t<is_base_of_v<typename _Is_memfunptr<_Removed_cvref>::_Class_type, remove_reference_t<_Ty1>>,
          _Invoker_pmf_object,
          conditional_t<_Is_specialization_v<_Remove_cvref_t<_Ty1>, reference_wrapper>, _Invoker_pmf_refwrap,
              _Invoker_pmf_pointer>> {}; 

template <class _Callable, class _Ty1, class _Removed_cvref>
struct _Invoker1<_Callable, _Ty1, _Removed_cvref, false, true>
    : conditional_t<
          is_base_of_v<typename _Is_member_object_pointer<_Removed_cvref>::_Class_type, remove_reference_t<_Ty1>>,
          _Invoker_pmd_object,
          conditional_t<_Is_specialization_v<_Remove_cvref_t<_Ty1>, reference_wrapper>, _Invoker_pmd_refwrap,
              _Invoker_pmd_pointer>> {}; 

template <class _Callable, class _Ty1, class _Removed_cvref>
struct _Invoker1<_Callable, _Ty1, _Removed_cvref, false, false> : _Invoker_functor {};

 template <class _Callable>
constexpr auto invoke(_Callable&& _Obj) noexcept(noexcept(static_cast<_Callable&&>(_Obj)()))
    -> decltype(static_cast<_Callable&&>(_Obj)()) {
    return static_cast<_Callable&&>(_Obj)();
}

 template <class _Callable, class _Ty1, class... _Types2>
constexpr auto invoke(_Callable&& _Obj, _Ty1&& _Arg1, _Types2&&... _Args2) noexcept(
    noexcept(_Invoker1<_Callable, _Ty1>::_Call(
        static_cast<_Callable&&>(_Obj), static_cast<_Ty1&&>(_Arg1), static_cast<_Types2&&>(_Args2)...)))
    -> decltype(_Invoker1<_Callable, _Ty1>::_Call(
        static_cast<_Callable&&>(_Obj), static_cast<_Ty1&&>(_Arg1), static_cast<_Types2&&>(_Args2)...)) {
    if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Functor) {
        return static_cast<_Callable&&>(_Obj)(static_cast<_Ty1&&>(_Arg1), static_cast<_Types2&&>(_Args2)...);
    } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmf_object) {
        return (static_cast<_Ty1&&>(_Arg1).*_Obj)(static_cast<_Types2&&>(_Args2)...);
    } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmf_refwrap) {
        return (_Arg1.get().*_Obj)(static_cast<_Types2&&>(_Args2)...);
    } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmf_pointer) {
        return ((*static_cast<_Ty1&&>(_Arg1)).*_Obj)(static_cast<_Types2&&>(_Args2)...);
    } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmd_object) {
        return static_cast<_Ty1&&>(_Arg1).*_Obj;
    } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmd_refwrap) {
        return _Arg1.get().*_Obj;
    } else {
        static_assert(_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmd_pointer, "bug in invoke");
        return (*static_cast<_Ty1&&>(_Arg1)).*_Obj;
    }
}

#pragma warning(push)
#pragma warning(disable : 4242) 
#pragma warning(disable : 4244) 
#pragma warning(disable : 4365) 

template <class _From, class _To, bool = is_convertible_v<_From, _To>, bool = is_void_v<_To>>
inline constexpr bool _Is_nothrow_convertible_v = noexcept(_Fake_copy_init<_To>(::std:: declval<_From>()));

#pragma warning(pop)

template <class _From, class _To, bool _IsVoid>
inline constexpr bool _Is_nothrow_convertible_v<_From, _To, false, _IsVoid> = false;

template <class _From, class _To>
inline constexpr bool _Is_nothrow_convertible_v<_From, _To, true, true> = true;

template <class _From, class _To>
struct _Is_nothrow_convertible : bool_constant<_Is_nothrow_convertible_v<_From, _To>> {
    
};


 template <class _From, class _To>
inline constexpr bool is_nothrow_convertible_v = _Is_nothrow_convertible_v<_From, _To>;

 template <class _From, class _To>
using is_nothrow_convertible = _Is_nothrow_convertible<_From, _To>;
#line 1631 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

template <class _From, class _To, class = void>
struct _Invoke_convertible : false_type {};

template <class _From, class _To>
struct _Invoke_convertible<_From, _To, void_t<decltype(::std:: _Fake_copy_init<_To>(::std:: _Returns_exactly<_From>()))>>
    : true_type {};

template <class _From, class _To>
struct _Invoke_nothrow_convertible
    : bool_constant<noexcept(::std:: _Fake_copy_init<_To>(::std:: _Returns_exactly<_From>()))> {};

template <class _Result, bool _Nothrow>
struct _Invoke_traits_common {
    using type                  = _Result;
    using _Is_invocable         = true_type;
    using _Is_nothrow_invocable = bool_constant<_Nothrow>;
    template <class _Rx>
    using _Is_invocable_r = bool_constant<disjunction_v<is_void<_Rx>, _Invoke_convertible<type, _Rx>>>;
    template <class _Rx>
    using _Is_nothrow_invocable_r = bool_constant<conjunction_v<_Is_nothrow_invocable,
        disjunction<is_void<_Rx>,
            conjunction<_Invoke_convertible<type, _Rx>, _Invoke_nothrow_convertible<type, _Rx>>>>>;
};

template <class _Void, class _Callable>
struct _Invoke_traits_zero {
    
    using _Is_invocable         = false_type;
    using _Is_nothrow_invocable = false_type;
    template <class _Rx>
    using _Is_invocable_r = false_type;
    template <class _Rx>
    using _Is_nothrow_invocable_r = false_type;
};

template <class _Callable>
using _Decltype_invoke_zero = decltype(::std:: declval<_Callable>()());

template <class _Callable>
struct _Invoke_traits_zero<void_t<_Decltype_invoke_zero<_Callable>>, _Callable>
    : _Invoke_traits_common<_Decltype_invoke_zero<_Callable>, noexcept(::std:: declval<_Callable>()())> {};

template <class _Void, class... _Types>
struct _Invoke_traits_nonzero {
    
    using _Is_invocable         = false_type;
    using _Is_nothrow_invocable = false_type;
    template <class _Rx>
    using _Is_invocable_r = false_type;
    template <class _Rx>
    using _Is_nothrow_invocable_r = false_type;
};

template <class _Callable, class _Ty1, class... _Types2>
using _Decltype_invoke_nonzero = decltype(_Invoker1<_Callable, _Ty1>::_Call(
    ::std:: declval<_Callable>(), ::std:: declval<_Ty1>(), ::std:: declval<_Types2>()...));

template <class _Callable, class _Ty1, class... _Types2>
struct _Invoke_traits_nonzero<void_t<_Decltype_invoke_nonzero<_Callable, _Ty1, _Types2...>>, _Callable, _Ty1,
    _Types2...> : _Invoke_traits_common<_Decltype_invoke_nonzero<_Callable, _Ty1, _Types2...>,
                      noexcept(_Invoker1<_Callable, _Ty1>::_Call(
                          ::std:: declval<_Callable>(), ::std:: declval<_Ty1>(), ::std:: declval<_Types2>()...))> {};

template <class _Callable, class... _Args>
using _Select_invoke_traits = conditional_t<sizeof...(_Args) == 0, _Invoke_traits_zero<void, _Callable>,
    _Invoke_traits_nonzero<void, _Callable, _Args...>>;





















#line 1720 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

template <class _Callable, class... _Args>
using _Invoke_result_t = typename _Select_invoke_traits<_Callable, _Args...>::type;

template <class _Rx, class _Callable, class... _Args>
using _Is_invocable_r_ = typename _Select_invoke_traits<_Callable, _Args...>::template _Is_invocable_r<_Rx>;

template <class _Rx, class _Callable, class... _Args>
struct _Is_invocable_r : _Is_invocable_r_<_Rx, _Callable, _Args...> {
    
};


 template <class _Callable, class... _Args>
struct invoke_result : _Select_invoke_traits<_Callable, _Args...> {
    
};

 template <class _Callable, class... _Args>
using invoke_result_t = typename _Select_invoke_traits<_Callable, _Args...>::type;

 template <class _Callable, class... _Args>
struct is_invocable : _Select_invoke_traits<_Callable, _Args...>::_Is_invocable {
    
};

 template <class _Callable, class... _Args>
inline constexpr bool is_invocable_v = _Select_invoke_traits<_Callable, _Args...>::_Is_invocable::value;

 template <class _Callable, class... _Args>
struct is_nothrow_invocable : _Select_invoke_traits<_Callable, _Args...>::_Is_nothrow_invocable {
    
};

 template <class _Callable, class... _Args>
inline constexpr bool is_nothrow_invocable_v = _Select_invoke_traits<_Callable, _Args...>::_Is_nothrow_invocable::value;

 template <class _Rx, class _Callable, class... _Args>
struct is_invocable_r : _Is_invocable_r_<_Rx, _Callable, _Args...> {
    
};

 template <class _Rx, class _Callable, class... _Args>
inline constexpr bool is_invocable_r_v = _Is_invocable_r_<_Rx, _Callable, _Args...>::value;

 template <class _Rx, class _Callable, class... _Args>
struct is_nothrow_invocable_r : _Select_invoke_traits<_Callable, _Args...>::template _Is_nothrow_invocable_r<_Rx> {
    
};

 template <class _Rx, class _Callable, class... _Args>
inline constexpr bool is_nothrow_invocable_r_v =
    _Select_invoke_traits<_Callable, _Args...>::template _Is_nothrow_invocable_r<_Rx>::value;
#line 1774 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"




 template <class _Ty1, class _Ty2>
struct is_layout_compatible : bool_constant<__is_layout_compatible(_Ty1, _Ty2)> {};

 template <class _Ty1, class _Ty2>
inline constexpr bool is_layout_compatible_v = __is_layout_compatible(_Ty1, _Ty2);

 template <class _Base, class _Derived>
struct is_pointer_interconvertible_base_of : bool_constant<__is_pointer_interconvertible_base_of(_Base, _Derived)> {};

 template <class _Base, class _Derived>
inline constexpr bool is_pointer_interconvertible_base_of_v = __is_pointer_interconvertible_base_of(_Base, _Derived);

 template <class _ClassTy, class _MemberTy>
[[nodiscard]] constexpr bool is_pointer_interconvertible_with_class(_MemberTy _ClassTy::*_Pm) noexcept {
    return __is_pointer_interconvertible_with_class(_ClassTy, _Pm);
}

 template <class _ClassTy1, class _ClassTy2, class _MemberTy1, class _MemberTy2>
[[nodiscard]] constexpr bool is_corresponding_member(_MemberTy1 _ClassTy1::*_Pm1, _MemberTy2 _ClassTy2::*_Pm2) noexcept {
    return __is_corresponding_member(_ClassTy1, _ClassTy2, _Pm1, _Pm2);
}
#line 1800 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"
#line 1801 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"
#line 1802 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

template <class _Ty>
struct _Function_args {}; 







template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...)> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...)> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) volatile> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) volatile> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const volatile> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const volatile> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) &> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) &> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const &> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const &> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) volatile &> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) volatile &> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const volatile &> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const volatile &> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) &&> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) &&> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const &&> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const &&> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) volatile &&> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) volatile &&> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const volatile &&> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const volatile &&> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) volatile noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) volatile noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const volatile noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const volatile noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) & noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) & noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const & noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const & noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) volatile & noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) volatile & noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const volatile & noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const volatile & noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) && noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) && noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const && noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const && noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) volatile && noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) volatile && noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const volatile && noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const volatile && noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; };








template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...)> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) volatile> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const volatile> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) &> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const&> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) volatile&> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const volatile&> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) &&> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const&&> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) volatile&&> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const volatile&&> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) noexcept> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const noexcept> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) volatile noexcept> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const volatile noexcept> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) &noexcept> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const& noexcept> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) volatile& noexcept> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const volatile& noexcept> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) &&noexcept> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const&& noexcept> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) volatile&& noexcept> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const volatile&& noexcept> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; };


template <class _Ty, class = void>
struct _Weak_result_type {}; 

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ty>
struct _Weak_result_type<_Ty, void_t<typename _Ty::result_type>> { 
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = typename _Ty::result_type;
};
__pragma(warning(pop))

template <class _Ty, class = void>
struct _Weak_argument_type : _Weak_result_type<_Ty> {}; 

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ty>
struct _Weak_argument_type<_Ty, void_t<typename _Ty::argument_type>> : _Weak_result_type<_Ty> {
    
    using _Unnameable_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = typename _Ty::argument_type;
};
__pragma(warning(pop))

template <class _Ty, class = void>
struct _Weak_binary_args : _Weak_argument_type<_Ty> {}; 

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ty>
struct _Weak_binary_args<_Ty, void_t<typename _Ty::first_argument_type,
                                  typename _Ty::second_argument_type>>
    : _Weak_argument_type<_Ty> { 
    using _Unnameable_first_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]  = typename _Ty::first_argument_type;
    using _Unnameable_second_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = typename _Ty::second_argument_type;
};
__pragma(warning(pop))

template <class _Ty>
using _Weak_types = conditional_t<is_function_v<remove_pointer_t<_Ty>>, _Function_args<remove_pointer_t<_Ty>>,
    conditional_t<is_member_function_pointer_v<_Ty>, _Is_memfunptr<remove_cv_t<_Ty>>, _Weak_binary_args<_Ty>>>;

template <class _Ty>
void _Refwrap_ctor_fun(_Identity_t<_Ty&>) noexcept; 
template <class _Ty>
void _Refwrap_ctor_fun(_Identity_t<_Ty&&>) = delete;

template <class _Ty, class _Uty, class = void>
struct _Refwrap_has_ctor_from : false_type {};

template <class _Ty, class _Uty>
struct _Refwrap_has_ctor_from<_Ty, _Uty, void_t<decltype(::std:: _Refwrap_ctor_fun<_Ty>(::std:: declval<_Uty>()))>>
    : true_type {}; 

 template <class _Ty>
class reference_wrapper


#line 1879 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"
{
public:
    static_assert(is_object_v<_Ty> || is_function_v<_Ty>,
        "reference_wrapper<T> requires T to be an object type or a function type.");

    using type = _Ty;

    template <class _Uty, enable_if_t<conjunction_v<negation<is_same<_Remove_cvref_t<_Uty>, reference_wrapper>>,
                                          _Refwrap_has_ctor_from<_Ty, _Uty>>,
                              int> = 0>
    constexpr reference_wrapper(_Uty&& _Val) noexcept(
        noexcept(::std:: _Refwrap_ctor_fun<_Ty>(::std:: declval<_Uty>()))) { 
        _Ty& _Ref = static_cast<_Uty&&>(_Val);
        _Ptr      = ::std:: addressof(_Ref);
    }

    constexpr operator _Ty&() const noexcept {
        return *_Ptr;
    }

    [[nodiscard]] constexpr _Ty& get() const noexcept {
        return *_Ptr;
    }

private:
    _Ty* _Ptr{};

public:
    template <class... _Types>
    constexpr auto operator()(_Types&&... _Args) const
        noexcept(noexcept(::std:: invoke(*_Ptr, static_cast<_Types&&>(_Args)...)))
            -> decltype(::std:: invoke(*_Ptr, static_cast<_Types&&>(_Args)...)) {
        return ::std:: invoke(*_Ptr, static_cast<_Types&&>(_Args)...);
    }
};


template <class _Ty>
reference_wrapper(_Ty&) -> reference_wrapper<_Ty>;
#line 1919 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

 template <class _Ty>
[[nodiscard]] constexpr reference_wrapper<_Ty> ref(_Ty& _Val) noexcept {
    return reference_wrapper<_Ty>(_Val);
}

 template <class _Ty>
void ref(const _Ty&&) = delete;

 template <class _Ty>
[[nodiscard]] constexpr reference_wrapper<_Ty> ref(reference_wrapper<_Ty> _Val) noexcept {
    return _Val;
}

 template <class _Ty>
[[nodiscard]] constexpr reference_wrapper<const _Ty> cref(const _Ty& _Val) noexcept {
    return reference_wrapper<const _Ty>(_Val);
}

 template <class _Ty>
void cref(const _Ty&&) = delete;

 template <class _Ty>
[[nodiscard]] constexpr reference_wrapper<const _Ty> cref(reference_wrapper<_Ty> _Val) noexcept {
    return _Val;
}


 template <class _Ty>
struct unwrap_reference {
    using type = _Ty;
};
template <class _Ty>
struct unwrap_reference<reference_wrapper<_Ty>> {
    using type = _Ty&;
};
 template <class _Ty>
using unwrap_reference_t = typename unwrap_reference<_Ty>::type;

 template <class _Ty>
using unwrap_ref_decay_t = unwrap_reference_t<decay_t<_Ty>>;
 template <class _Ty>
struct unwrap_ref_decay {
    using type = unwrap_ref_decay_t<_Ty>;
};
#line 1965 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

template <class _Ty>
struct _Is_swappable;

template <class _Ty>
struct _Is_nothrow_swappable;


 template <class _Ty, enable_if_t<is_move_constructible_v<_Ty> && is_move_assignable_v<_Ty>, int> = 0>


#line 1977 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"
constexpr void swap(_Ty&, _Ty&) noexcept(is_nothrow_move_constructible_v<_Ty>&& is_nothrow_move_assignable_v<_Ty>);

 template <class _Ty, size_t _Size, enable_if_t<_Is_swappable<_Ty>::value, int> = 0>
constexpr void swap(_Ty (&)[_Size], _Ty (&)[_Size]) noexcept(_Is_nothrow_swappable<_Ty>::value);

template <class _Ty1, class _Ty2, class = void>
struct _Swappable_with_helper : false_type {}; 

template <class _Ty1, class _Ty2>
struct _Swappable_with_helper<_Ty1, _Ty2, void_t<decltype(swap(::std:: declval<_Ty1>(), ::std:: declval<_Ty2>()))>>
    : true_type {}; 

template <class _Ty1, class _Ty2>
struct _Is_swappable_with
    : bool_constant<conjunction_v<_Swappable_with_helper<_Ty1, _Ty2>, _Swappable_with_helper<_Ty2, _Ty1>>> {
    
};

template <class _Ty>
struct _Is_swappable : _Is_swappable_with<add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<_Ty>>::type {
    
};

template <class _Ty1, class _Ty2>
struct _Swap_cannot_throw : bool_constant<noexcept(swap(::std:: declval<_Ty1>(), ::std:: declval<_Ty2>()))
                                          && noexcept(swap(::std:: declval<_Ty2>(), ::std:: declval<_Ty1>()))> {
    
    
};

template <class _Ty1, class _Ty2>
struct _Is_nothrow_swappable_with
    : bool_constant<conjunction_v<_Is_swappable_with<_Ty1, _Ty2>, _Swap_cannot_throw<_Ty1, _Ty2>>> {
    
    
};

template <class _Ty>
struct _Is_nothrow_swappable
    : _Is_nothrow_swappable_with<add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<_Ty>>::type {
    
};


 template <class _Ty1, class _Ty2>
struct is_swappable_with : _Is_swappable_with<_Ty1, _Ty2>::type {
    
    
};

 template <class _Ty1, class _Ty2>
inline constexpr bool is_swappable_with_v =
    conjunction_v<_Swappable_with_helper<_Ty1, _Ty2>, _Swappable_with_helper<_Ty2, _Ty1>>;

 template <class _Ty>
struct is_swappable : _Is_swappable<_Ty>::type {}; 

 template <class _Ty>
inline constexpr bool is_swappable_v = _Is_swappable<_Ty>::value;

 template <class _Ty1, class _Ty2>
struct is_nothrow_swappable_with : _Is_nothrow_swappable_with<_Ty1, _Ty2>::type {
    
    
};

 template <class _Ty1, class _Ty2>
inline constexpr bool is_nothrow_swappable_with_v = _Is_nothrow_swappable_with<_Ty1, _Ty2>::value;

 template <class _Ty>
struct is_nothrow_swappable : _Is_nothrow_swappable<_Ty>::type {
    
};

 template <class _Ty>
inline constexpr bool is_nothrow_swappable_v = _Is_nothrow_swappable<_Ty>::value;
#line 2054 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

namespace _Has_ADL_swap_detail {


#line 2059 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"
    void swap();
#line 2061 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

    template <class, class = void>
    struct _Has_ADL_swap : false_type {};
    template <class _Ty>
    struct _Has_ADL_swap<_Ty, void_t<decltype(swap(::std:: declval<_Ty&>(), ::std:: declval<_Ty&>()))>> : true_type {};
} 
using _Has_ADL_swap_detail::_Has_ADL_swap;

template <class _Ty>
inline constexpr bool _Is_trivially_swappable_v = conjunction_v<is_trivially_destructible<_Ty>,
    is_trivially_move_constructible<_Ty>, is_trivially_move_assignable<_Ty>, negation<_Has_ADL_swap<_Ty>>>;


template <>
inline constexpr bool _Is_trivially_swappable_v<byte> = true;
#line 2077 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

template <class _Ty>
struct _Is_trivially_swappable : bool_constant<_Is_trivially_swappable_v<_Ty>> {
    
};


































template <class _Bitmask>
[[nodiscard]] constexpr bool _Bitmask_includes_any(_Bitmask _Left, _Bitmask _Elements) noexcept {
    return (_Left & _Elements) != _Bitmask{};
}

template <class _Bitmask>
[[nodiscard]] constexpr bool _Bitmask_includes_all(_Bitmask _Left, _Bitmask _Elements) noexcept {
    return (_Left & _Elements) == _Elements;
}




inline constexpr size_t _FNV_offset_basis = 14695981039346656037ULL;
inline constexpr size_t _FNV_prime        = 1099511628211ULL;



#line 2135 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

[[nodiscard]] inline size_t _Fnv1a_append_bytes(size_t _Val, const unsigned char* const _First,
    const size_t _Count) noexcept { 
    for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {
        _Val ^= static_cast<size_t>(_First[_Idx]);
        _Val *= _FNV_prime;
    }

    return _Val;
}

template <class _Ty>
[[nodiscard]] size_t _Fnv1a_append_range(const size_t _Val, const _Ty* const _First,
    const _Ty* const _Last) noexcept { 
    static_assert(is_trivial_v<_Ty>, "Only trivial types can be directly hashed.");
    const auto _Firstb = reinterpret_cast<const unsigned char*>(_First);
    const auto _Lastb  = reinterpret_cast<const unsigned char*>(_Last);
    return _Fnv1a_append_bytes(_Val, _Firstb, static_cast<size_t>(_Lastb - _Firstb));
}

template <class _Kty>
[[nodiscard]] size_t _Fnv1a_append_value(
    const size_t _Val, const _Kty& _Keyval) noexcept { 
    static_assert(is_trivial_v<_Kty>, "Only trivial types can be directly hashed.");
    return _Fnv1a_append_bytes(_Val, &reinterpret_cast<const unsigned char&>(_Keyval), sizeof(_Kty));
}

template <class _Kty>
[[nodiscard]] size_t _Hash_representation(const _Kty& _Keyval) noexcept { 
    return _Fnv1a_append_value(_FNV_offset_basis, _Keyval);
}

template <class _Kty>
[[nodiscard]] size_t _Hash_array_representation(
    const _Kty* const _First, const size_t _Count) noexcept { 
    static_assert(is_trivial_v<_Kty>, "Only trivial types can be directly hashed.");
    return _Fnv1a_append_bytes(
        _FNV_offset_basis, reinterpret_cast<const unsigned char*>(_First), _Count * sizeof(_Kty));
}

 template <class _Kty>
struct hash;

template <class _Kty, bool _Enabled>
struct _Conditionally_enabled_hash { 
    using _Unnameable_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Kty;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]   = size_t;

    [[nodiscard]] size_t operator()(const _Kty& _Keyval) const
        noexcept(noexcept(hash<_Kty>::_Do_hash(_Keyval)))   {
        return hash<_Kty>::_Do_hash(_Keyval);
    }
};

template <class _Kty>
struct _Conditionally_enabled_hash<_Kty, false> { 
    _Conditionally_enabled_hash()                                              = delete;
    _Conditionally_enabled_hash(const _Conditionally_enabled_hash&)            = delete;
    _Conditionally_enabled_hash(_Conditionally_enabled_hash&&)                 = delete;
    _Conditionally_enabled_hash& operator=(const _Conditionally_enabled_hash&) = delete;
    _Conditionally_enabled_hash& operator=(_Conditionally_enabled_hash&&)      = delete;
};

 template <class _Kty>
struct hash : _Conditionally_enabled_hash<_Kty, !is_const_v<_Kty> && !is_volatile_v<_Kty>
                                                    && (is_enum_v<_Kty> || is_integral_v<_Kty> || is_pointer_v<_Kty>)> {
    
    static size_t _Do_hash(const _Kty& _Keyval) noexcept {
        return _Hash_representation(_Keyval);
    }
};

template <>
struct hash<float> {
    using _Unnameable_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = float;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]   = size_t;
    [[nodiscard]] size_t operator()(const float _Keyval) const noexcept {
        return _Hash_representation(_Keyval == 0.0F ? 0.0F : _Keyval); 
    }
};

template <>
struct hash<double> {
    using _Unnameable_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = double;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]   = size_t;
    [[nodiscard]] size_t operator()(const double _Keyval) const noexcept {
        return _Hash_representation(_Keyval == 0.0 ? 0.0 : _Keyval); 
    }
};

template <>
struct hash<long double> {
    using _Unnameable_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = long double;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]   = size_t;
    [[nodiscard]] size_t operator()(const long double _Keyval) const noexcept {
        return _Hash_representation(_Keyval == 0.0L ? 0.0L : _Keyval); 
    }
};

template <>
struct hash<nullptr_t> {
    using _Unnameable_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = nullptr_t;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]   = size_t;
    [[nodiscard]] size_t operator()(nullptr_t) const noexcept {
        void* _Null{};
        return _Hash_representation(_Null);
    }
};

template <class _Kty, class = void>
struct _Is_nothrow_hashable : false_type {}; 

template <class _Kty>
struct _Is_nothrow_hashable<_Kty, void_t<decltype(hash<_Kty>{}(::std:: declval<const _Kty&>()))>>
    : bool_constant<noexcept(hash<_Kty>{}(::std:: declval<const _Kty&>()))> {};



template <class _FloatingType>
struct _Floating_type_traits;

template <>
struct _Floating_type_traits<float> {
    static constexpr int32_t _Mantissa_bits           = 24; 
    static constexpr int32_t _Exponent_bits           = 8; 
    static constexpr int32_t _Maximum_binary_exponent = 127; 
    static constexpr int32_t _Minimum_binary_exponent = -126; 
    static constexpr int32_t _Exponent_bias           = 127;
    static constexpr int32_t _Sign_shift              = 31; 
    static constexpr int32_t _Exponent_shift          = 23; 

    using _Uint_type = uint32_t;

    static constexpr uint32_t _Exponent_mask             = 0x000000FFu; 
    static constexpr uint32_t _Normal_mantissa_mask      = 0x00FFFFFFu; 
    static constexpr uint32_t _Denormal_mantissa_mask    = 0x007FFFFFu; 
    static constexpr uint32_t _Special_nan_mantissa_mask = 0x00400000u; 
    static constexpr uint32_t _Shifted_sign_mask         = 0x80000000u; 
    static constexpr uint32_t _Shifted_exponent_mask     = 0x7F800000u; 
};

template <>
struct _Floating_type_traits<double> {
    static constexpr int32_t _Mantissa_bits           = 53; 
    static constexpr int32_t _Exponent_bits           = 11; 
    static constexpr int32_t _Maximum_binary_exponent = 1023; 
    static constexpr int32_t _Minimum_binary_exponent = -1022; 
    static constexpr int32_t _Exponent_bias           = 1023;
    static constexpr int32_t _Sign_shift              = 63; 
    static constexpr int32_t _Exponent_shift          = 52; 

    using _Uint_type = uint64_t;

    static constexpr uint64_t _Exponent_mask             = 0x00000000000007FFu; 
    static constexpr uint64_t _Normal_mantissa_mask      = 0x001FFFFFFFFFFFFFu; 
    static constexpr uint64_t _Denormal_mantissa_mask    = 0x000FFFFFFFFFFFFFu; 
    static constexpr uint64_t _Special_nan_mantissa_mask = 0x0008000000000000u; 
    static constexpr uint64_t _Shifted_sign_mask         = 0x8000000000000000u; 
    static constexpr uint64_t _Shifted_exponent_mask     = 0x7FF0000000000000u; 
};

template <>
struct _Floating_type_traits<long double> : _Floating_type_traits<double> {};




































































#line 2367 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"

}



#pragma warning(pop)
#pragma pack(pop)

#line 2376 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"
#line 2377 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\type_traits"
#pragma external_header(pop)
#line 12 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"



#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\concepts"





#pragma once











#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




namespace std {

template <class _Ty1, class _Ty2>
concept _Same_impl = 



    is_same_v<_Ty1, _Ty2>;
#line 34 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\concepts"

 template <class _Ty1, class _Ty2>
concept same_as = _Same_impl<_Ty1, _Ty2> && _Same_impl<_Ty2, _Ty1>;

 template <class _Derived, class _Base>
concept derived_from = __is_base_of(_Base, _Derived)
    && __is_convertible_to(const volatile _Derived*, const volatile _Base*);

 template <class _From, class _To>

concept convertible_to = is_convertible_v<_From, _To>


#line 48 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\concepts"
    && requires {
        static_cast<_To>(::std:: declval<_From>());
    };

template <class _From, class _To>
concept _Implicitly_convertible_to = is_convertible_v<_From, _To>;

 template <class _Ty1, class _Ty2>
concept common_reference_with =
    requires {
        typename common_reference_t<_Ty1, _Ty2>;
        typename common_reference_t<_Ty2, _Ty1>;
    }
    && same_as<common_reference_t<_Ty1, _Ty2>, common_reference_t<_Ty2, _Ty1>>
    && convertible_to<_Ty1, common_reference_t<_Ty1, _Ty2>>
    && convertible_to<_Ty2, common_reference_t<_Ty1, _Ty2>>;

 template <class _Ty1, class _Ty2>
concept common_with =
    requires {
        typename common_type_t<_Ty1, _Ty2>;
        typename common_type_t<_Ty2, _Ty1>;
    }
    && same_as<common_type_t<_Ty1, _Ty2>, common_type_t<_Ty2, _Ty1>>
    && requires {
        static_cast<common_type_t<_Ty1, _Ty2>>(::std:: declval<_Ty1>());
        static_cast<common_type_t<_Ty1, _Ty2>>(::std:: declval<_Ty2>());
    }
    && common_reference_with<add_lvalue_reference_t<const _Ty1>, add_lvalue_reference_t<const _Ty2>>
    && common_reference_with<add_lvalue_reference_t<common_type_t<_Ty1, _Ty2>>,
        common_reference_t<add_lvalue_reference_t<const _Ty1>, add_lvalue_reference_t<const _Ty2>>>;

 template <class _Ty>
concept integral = is_integral_v<_Ty>;

 template <class _Ty>
concept signed_integral = integral<_Ty> && static_cast<_Ty>(-1) < static_cast<_Ty>(0);

 template <class _Ty>
concept unsigned_integral = integral<_Ty> && !signed_integral<_Ty>;

 template <class _Ty>
concept floating_point = is_floating_point_v<_Ty>;

 template <class _LTy, class _RTy>
concept assignable_from = is_lvalue_reference_v<_LTy>
    && common_reference_with<const remove_reference_t<_LTy>&, const remove_reference_t<_RTy>&>
    && requires(_LTy _Left, _RTy&& _Right) {
        { _Left = static_cast<_RTy&&>(_Right) } -> same_as<_LTy>;
    };



 template <class _Ty>
concept destructible = __is_nothrow_destructible(_Ty);

 template <class _Ty, class... _ArgTys>
concept constructible_from = destructible<_Ty>
    && __is_constructible(_Ty, _ArgTys...);

 template <class _Ty>
concept default_initializable = constructible_from<_Ty>
    && requires {
        _Ty{};
        ::new (static_cast<void*>(nullptr)) _Ty; 
    };

 template <class _Ty>
concept move_constructible = constructible_from<_Ty, _Ty> && convertible_to<_Ty, _Ty>;

template <class _Ty>
concept _Has_class_or_enum_type = __is_class(remove_reference_t<_Ty>) || __is_enum(remove_reference_t<_Ty>)
    || __is_union(remove_reference_t<_Ty>);

namespace ranges {
    namespace _Swap {
        template <class _Ty>
        void swap(_Ty&, _Ty&) = delete;

        template <class _Ty1, class _Ty2>
        concept _Use_ADL_swap = (_Has_class_or_enum_type<_Ty1> || _Has_class_or_enum_type<_Ty2>)
            && requires(_Ty1&& __t, _Ty2&& __u) {
                swap(static_cast<_Ty1&&>(__t), static_cast<_Ty2&&>(__u)); 
            };

        struct _Cpo {
            template <class _Ty1, class _Ty2>
                requires _Use_ADL_swap<_Ty1, _Ty2>
            constexpr void operator()(_Ty1&& __t, _Ty2&& __u) const
                noexcept(noexcept(swap(static_cast<_Ty1&&>(__t), static_cast<_Ty2&&>(__u)))) { 
                swap(static_cast<_Ty1&&>(__t), static_cast<_Ty2&&>(__u)); 
            }

            template <class _Ty>
                requires (!_Use_ADL_swap<_Ty&, _Ty&> && move_constructible<_Ty> && assignable_from<_Ty&, _Ty>)
            constexpr void operator()(_Ty& __x, _Ty& __y) const
                noexcept(is_nothrow_move_constructible_v<_Ty> && is_nothrow_move_assignable_v<_Ty>) {
                _Ty __tmp(static_cast<_Ty&&>(__x));
                __x = static_cast<_Ty&&>(__y);
                __y = static_cast<_Ty&&>(__tmp);
            }

            template <class _Ty1, class _Ty2, size_t _Size>
            constexpr void operator()(_Ty1 (&__t)[_Size], _Ty2 (&__u)[_Size]) const
                noexcept(noexcept((*this)(__t[0], __u[0])))
                requires requires { (*this)(__t[0], __u[0]); } {
                for (size_t __i = 0; __i < _Size; ++__i) {
                    (*this)(__t[__i], __u[__i]);
                }
            }
        };
    } 

    inline namespace _Cpos {
         inline constexpr _Swap::_Cpo swap;
    }
} 

 template <class _Ty>
concept swappable = requires(_Ty& __x, _Ty& __y) {
    ::std::ranges:: swap(__x, __y);
};

 template <class _Ty1, class _Ty2>
concept swappable_with = common_reference_with<_Ty1, _Ty2>
    && requires(_Ty1&& __t, _Ty2&& __u) {
        ::std::ranges:: swap(static_cast<_Ty1&&>(__t), static_cast<_Ty1&&>(__t));
        ::std::ranges:: swap(static_cast<_Ty2&&>(__u), static_cast<_Ty2&&>(__u));
        ::std::ranges:: swap(static_cast<_Ty1&&>(__t), static_cast<_Ty2&&>(__u));
        ::std::ranges:: swap(static_cast<_Ty2&&>(__u), static_cast<_Ty1&&>(__t));
    };

 template <class _Ty>
concept copy_constructible = move_constructible<_Ty>
    && constructible_from<_Ty, _Ty&> && convertible_to<_Ty&, _Ty>
    && constructible_from<_Ty, const _Ty&> && convertible_to<const _Ty&, _Ty>
    && constructible_from<_Ty, const _Ty> && convertible_to<const _Ty, _Ty>;

template <class _Ty>
concept _Boolean_testable_impl = convertible_to<_Ty, bool>;

template <class _Ty>
concept _Boolean_testable = _Boolean_testable_impl<_Ty>
    && requires(_Ty&& __t) {
        { !static_cast<_Ty&&>(__t) } -> _Boolean_testable_impl;
    };

template <class _Ty1, class _Ty2>
concept _Half_equality_comparable =
    requires(const remove_reference_t<_Ty1>& __x, const remove_reference_t<_Ty2>& __y) {
        { __x == __y } -> _Boolean_testable;
        { __x != __y } -> _Boolean_testable;
    };

template <class _Ty1, class _Ty2>
concept _Weakly_equality_comparable_with =
    _Half_equality_comparable<_Ty1, _Ty2> && _Half_equality_comparable<_Ty2, _Ty1>;

 template <class _Ty>
concept equality_comparable = _Half_equality_comparable<_Ty, _Ty>;












#line 221 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\concepts"

 template <class _Ty1, class _Ty2>
concept equality_comparable_with = equality_comparable<_Ty1> && equality_comparable<_Ty2>


#line 227 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\concepts"
    && common_reference_with<const remove_reference_t<_Ty1>&, const remove_reference_t<_Ty2>&>
#line 229 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\concepts"
    && equality_comparable<common_reference_t<const remove_reference_t<_Ty1>&, const remove_reference_t<_Ty2>&>>
    && _Weakly_equality_comparable_with<_Ty1, _Ty2>;

template <class _Ty1, class _Ty2>
concept _Half_ordered = requires(const remove_reference_t<_Ty1>& __t, const remove_reference_t<_Ty2>& __u) {
    { __t <  __u } -> _Boolean_testable;
    { __t >  __u } -> _Boolean_testable;
    { __t <= __u } -> _Boolean_testable;
    { __t >= __u } -> _Boolean_testable;
};

template <class _Ty1, class _Ty2>
concept _Partially_ordered_with = _Half_ordered<_Ty1, _Ty2> && _Half_ordered<_Ty2, _Ty1>;

 template <class _Ty>
concept totally_ordered = equality_comparable<_Ty> && _Half_ordered<_Ty, _Ty>;

 template <class _Ty1, class _Ty2>
concept totally_ordered_with = totally_ordered<_Ty1> && totally_ordered<_Ty2>
    && equality_comparable_with<_Ty1, _Ty2>
    && totally_ordered<common_reference_t<const remove_reference_t<_Ty1>&, const remove_reference_t<_Ty2>&>>
    && _Partially_ordered_with<_Ty1, _Ty2>;

 template <class _Ty>
concept movable = is_object_v<_Ty>
    && move_constructible<_Ty>
    && assignable_from<_Ty&, _Ty>
    && swappable<_Ty>;

 template <class _Ty>
concept copyable = copy_constructible<_Ty>
    && movable<_Ty>
    && assignable_from<_Ty&, _Ty&>
    && assignable_from<_Ty&, const _Ty&>
    && assignable_from<_Ty&, const _Ty>;

 template <class _Ty>
concept semiregular = copyable<_Ty> && default_initializable<_Ty>;

 template <class _Ty>
concept regular = semiregular<_Ty> && equality_comparable<_Ty>;

 template <class _FTy, class... _ArgTys>
concept invocable = requires(_FTy&& _Fn, _ArgTys&&... _Args) {
    ::std:: invoke(static_cast<_FTy&&>(_Fn), static_cast<_ArgTys&&>(_Args)...);
};

 template <class _FTy, class... _ArgTys>
concept regular_invocable = invocable<_FTy, _ArgTys...>;

 template <class _FTy, class... _ArgTys>
concept predicate = regular_invocable<_FTy, _ArgTys...>
    && _Boolean_testable<invoke_result_t<_FTy, _ArgTys...>>;

 template <class _FTy, class _Ty1, class _Ty2>
concept relation =
       predicate<_FTy, _Ty1, _Ty1>
    && predicate<_FTy, _Ty2, _Ty2>
    && predicate<_FTy, _Ty1, _Ty2>
    && predicate<_FTy, _Ty2, _Ty1>;

 template <class _FTy, class _Ty1, class _Ty2>
concept equivalence_relation = relation<_FTy, _Ty1, _Ty2>;

 template <class _FTy, class _Ty1, class _Ty2>
concept strict_weak_order = relation<_FTy, _Ty1, _Ty2>;



template <class _Ty>
struct _Choice_t {
    _Ty _Strategy  = _Ty{};
    bool _No_throw = false;
};

}



#pragma warning(pop)
#pragma pack(pop)
#line 311 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\concepts"
#line 312 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\concepts"
#line 313 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\concepts"
#pragma external_header(pop)
#line 16 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"
#line 17 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"


#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\compare"





#pragma once







#line 15 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\compare"

#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\bit"





#pragma once






#line 14 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\bit"


#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\isa_availability.h"














enum ISA_AVAILABILITY
{
    __ISA_AVAILABLE_X86   = 0,
    __ISA_AVAILABLE_SSE2  = 1,
    __ISA_AVAILABLE_SSE42 = 2,
    __ISA_AVAILABLE_AVX   = 3,
    __ISA_AVAILABLE_ENFSTRG = 4,
    __ISA_AVAILABLE_AVX2 = 5,
    __ISA_AVAILABLE_AVX512 = 6,

    __ISA_AVAILABLE_ARMNT   = 0,   
    __ISA_AVAILABLE_NEON    = 1,   
    __ISA_AVAILABLE_NEON_ARM64 = 2,
                                   
};








#line 39 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\isa_availability.h"

 


 

#line 46 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\isa_availability.h"

#line 48 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\isa_availability.h"
#pragma external_header(pop)
#line 17 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\bit"
#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"





#pragma once




#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cfloat"





#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\float.h"








#pragma once





#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {




    


        


            
        #line 32 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\float.h"
    #line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\float.h"
#line 34 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\float.h"



















    






        
    #line 62 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\float.h"
#line 63 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\float.h"
























































































































































#line 216 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\float.h"

    

#line 220 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\float.h"











__declspec(dllimport) unsigned int __cdecl _clearfp(void);

#pragma warning(push)
#pragma warning(disable: 4141) 

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_controlfp_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) unsigned int __cdecl _controlfp(
     unsigned int _NewValue,
     unsigned int _Mask
    );

#pragma warning(pop)


__declspec(dllimport) void __cdecl _set_controlfp(
     unsigned int _NewValue,
     unsigned int _Mask
    );


__declspec(dllimport) errno_t __cdecl _controlfp_s(
     unsigned int* _CurrentState,
          unsigned int  _NewValue,
          unsigned int  _Mask
    );


__declspec(dllimport) unsigned int __cdecl _statusfp(void);


__declspec(dllimport) void __cdecl _fpreset(void);















__declspec(dllimport) unsigned int __cdecl _control87(
     unsigned int _NewValue,
     unsigned int _Mask
    );













__declspec(dllimport) int* __cdecl __fpecode(void);




__declspec(dllimport) int __cdecl __fpe_flt_rounds(void);












 __declspec(dllimport) double __cdecl _copysign( double _Number,  double _Sign);
 __declspec(dllimport) double __cdecl _chgsign( double _X);
 __declspec(dllimport) double __cdecl _scalb( double _X,  long _Y);
 __declspec(dllimport) double __cdecl _logb( double _X);
 __declspec(dllimport) double __cdecl _nextafter( double _X,  double _Y);
 __declspec(dllimport) int    __cdecl _finite( double _X);
 __declspec(dllimport) int    __cdecl _isnan( double _X);
 __declspec(dllimport) int    __cdecl _fpclass( double _X);


     __declspec(dllimport) float __cdecl _scalbf( float _X,  long _Y);
#line 324 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\float.h"










    
    
    

    
    __declspec(dllimport) void __cdecl fpreset(void);

    
    

    
    

    
    
    

    
    
    
    
    
    
    

    
    
    

    
    
    
    
    

    
    
    
    

    

    
    
    
    
    
    

    
    
    
    

    
    
    
    
    
    

    
    
    
    

    

#line 403 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\float.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#line 410 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\float.h"
#pragma external_header(pop)
#line 12 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cfloat"
#line 13 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cfloat"
#pragma external_header(pop)
#line 12 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"
#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\climits"





#pragma once







#line 15 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\climits"
#line 16 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\climits"
#pragma external_header(pop)
#line 13 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"
#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cwchar"





#pragma once





#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cstdio"





#pragma once





#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"







#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"









#pragma once


#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_stdio_config.h"







#pragma once



#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {



#line 21 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_stdio_config.h"




#line 26 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_stdio_config.h"
    
#line 28 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_stdio_config.h"


    

#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_stdio_config.h"
        
    

#line 37 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_stdio_config.h"
#line 38 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_stdio_config.h"














    








#line 62 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_stdio_config.h"




#line 67 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_stdio_config.h"

    
        


            #pragma detect_mismatch("_CRT_STDIO_ISO_WIDE_SPECIFIERS", "0")
        #line 74 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_stdio_config.h"
    #line 75 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_stdio_config.h"
#line 76 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_stdio_config.h"






#line 83 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_stdio_config.h"


    
    
     
    
    __declspec(noinline) __inline unsigned __int64* __cdecl __local_stdio_printf_options(void)
    {
        static unsigned __int64 _OptionsStorage;
        return &_OptionsStorage;
    }

    
    
     
    
    __declspec(noinline) __inline unsigned __int64* __cdecl __local_stdio_scanf_options(void)
    {
        static unsigned __int64 _OptionsStorage;
        return &_OptionsStorage;
    }
#line 105 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_stdio_config.h"



#line 109 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_stdio_config.h"




















} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {







    
    typedef struct _iobuf
    {
        void* _Placeholder;
    } FILE;
#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

__declspec(dllimport) FILE* __cdecl __acrt_iob_func(unsigned _Ix);










    
    
    
    
    
    
    __declspec(dllimport) wint_t __cdecl fgetwc(
         FILE* _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _fgetwchar(void);

    
    __declspec(dllimport) wint_t __cdecl fputwc(
            wchar_t _Character,
         FILE*   _Stream);

    
    __declspec(dllimport) wint_t __cdecl _fputwchar(
         wchar_t _Character
        );

    
    __declspec(dllimport) wint_t __cdecl getwc(
         FILE* _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl getwchar(void);


    
    
    __declspec(dllimport) wchar_t* __cdecl fgetws(
         wchar_t* _Buffer,
                                 int      _BufferCount,
                              FILE*    _Stream
        );

    
    __declspec(dllimport) int __cdecl fputws(
          wchar_t const* _Buffer,
         FILE*          _Stream
        );

    
    
    __declspec(dllimport) wchar_t* __cdecl _getws_s(
         wchar_t* _Buffer,
                                 size_t   _BufferCount
        );

    extern "C++" { template <size_t _Size> inline wchar_t* __cdecl _getws_s(wchar_t (&_Buffer)[_Size]) throw() { return _getws_s(_Buffer, _Size); } }





    
    __declspec(dllimport) wint_t __cdecl putwc(
            wchar_t _Character,
         FILE*   _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl putwchar(
         wchar_t _Character
        );

    
    __declspec(dllimport) int __cdecl _putws(
         wchar_t const* _Buffer
        );

    
    __declspec(dllimport) wint_t __cdecl ungetwc(
            wint_t _Character,
         FILE*  _Stream
        );

    
    __declspec(dllimport) FILE * __cdecl _wfdopen(
           int            _FileHandle,
         wchar_t const* _Mode
        );

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wfopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) FILE* __cdecl _wfopen(
         wchar_t const* _FileName,
         wchar_t const* _Mode
        );

    
    __declspec(dllimport) errno_t __cdecl _wfopen_s(
         FILE**         _Stream,
                            wchar_t const* _FileName,
                            wchar_t const* _Mode
        );

    
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wfreopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) FILE* __cdecl _wfreopen(
          wchar_t const* _FileName,
          wchar_t const* _Mode,
         FILE*          _OldStream
        );

    
    __declspec(dllimport) errno_t __cdecl _wfreopen_s(
         FILE**         _Stream,
                            wchar_t const* _FileName,
                            wchar_t const* _Mode,
                           FILE*          _OldStream
        );

    
    __declspec(dllimport) FILE* __cdecl _wfsopen(
         wchar_t const* _FileName,
         wchar_t const* _Mode,
           int            _ShFlag
        );

    __declspec(dllimport) void __cdecl _wperror(
         wchar_t const* _ErrorMessage
        );

    

        
        __declspec(dllimport) FILE* __cdecl _wpopen(
             wchar_t const* _Command,
             wchar_t const* _Mode
            );

    #line 181 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    __declspec(dllimport) int __cdecl _wremove(
         wchar_t const* _FileName
        );

    
    

    
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wtempnam(
         wchar_t const* _Directory,
         wchar_t const* _FilePrefix
        );

    

    
    
    __declspec(dllimport) errno_t __cdecl _wtmpnam_s(
         wchar_t* _Buffer,
                                 size_t   _BufferCount
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _wtmpnam_s(wchar_t (&_Buffer)[_Size]) throw() { return _wtmpnam_s(_Buffer, _Size); } }





    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wtmpnam_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wtmpnam( wchar_t *_Buffer);







    
    
    
    
    
    
    __declspec(dllimport) wint_t __cdecl _fgetwc_nolock(
         FILE* _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _fputwc_nolock(
            wchar_t _Character,
         FILE*   _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _getwc_nolock(
         FILE* _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _putwc_nolock(
            wchar_t _Character,
         FILE*   _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _ungetwc_nolock(
            wint_t _Character,
         FILE*  _Stream
        );

    



#line 256 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"



    
    





    
    
    
    
    
    
    __declspec(dllimport) int __cdecl __stdio_common_vfwprintf(
                                            unsigned __int64 _Options,
                                         FILE*            _Stream,
          wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __stdio_common_vfwprintf_s(
                                            unsigned __int64 _Options,
                                         FILE*            _Stream,
          wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __stdio_common_vfwprintf_p(
                                            unsigned __int64 _Options,
                                         FILE*            _Stream,
          wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __inline int __cdecl _vfwprintf_l(
                                         FILE*          const _Stream,
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 308 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwprintf((*__local_stdio_printf_options()) , _Stream, _Format, _Locale, _ArgList);
    }
    #line 312 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl vfwprintf(
                               FILE*          const _Stream,
          wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 322 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_l(_Stream, _Format, 0 , _ArgList);
    }
    #line 326 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vfwprintf_s_l(
                                         FILE*          const _Stream,
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 337 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwprintf_s((*__local_stdio_printf_options()) , _Stream, _Format, _Locale, _ArgList);
    }
    #line 341 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl vfwprintf_s(
                                   FILE*          const _Stream,
              wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 353 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwprintf_s_l(_Stream, _Format, 0 , _ArgList);
        }
    #line 357 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    #line 359 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vfwprintf_p_l(
                                         FILE*          const _Stream,
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 370 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwprintf_p((*__local_stdio_printf_options()) , _Stream, _Format, _Locale, _ArgList);
    }
    #line 374 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vfwprintf_p(
                               FILE*          const _Stream,
          wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 384 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_p_l(_Stream, _Format, 0 , _ArgList);
    }
    #line 388 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwprintf_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 398 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_l((__acrt_iob_func(1)) , _Format, _Locale, _ArgList);
    }
    #line 402 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl vwprintf(
          wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 411 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_l((__acrt_iob_func(1)) , _Format, 0 , _ArgList);
    }
    #line 415 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwprintf_s_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 425 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_s_l((__acrt_iob_func(1)) , _Format, _Locale, _ArgList);
    }
    #line 429 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl vwprintf_s(
              wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 440 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwprintf_s_l((__acrt_iob_func(1)) , _Format, 0 , _ArgList);
        }
    #line 444 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    #line 446 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwprintf_p_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 456 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_p_l((__acrt_iob_func(1)) , _Format, _Locale, _ArgList);
    }
    #line 460 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwprintf_p(
          wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 469 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_p_l((__acrt_iob_func(1)) , _Format, 0 , _ArgList);
    }
    #line 473 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwprintf_l(
                                         FILE*          const _Stream,
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 483 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfwprintf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 492 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl fwprintf(
                               FILE*          const _Stream,
          wchar_t const* const _Format,
        ...)
    

#line 501 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vfwprintf_l(_Stream, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 510 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwprintf_s_l(
                                         FILE*          const _Stream,
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 520 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfwprintf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 529 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl fwprintf_s(
                                   FILE*          const _Stream,
              wchar_t const* const _Format,
            ...)
    

#line 540 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
            _Result = _vfwprintf_s_l(_Stream, _Format, 0 , _ArgList);
            ((void)(_ArgList = (va_list)0)) ;
            return _Result;
        }
    #line 549 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    #line 551 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwprintf_p_l(
                                         FILE*          const _Stream,
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 561 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfwprintf_p_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 570 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwprintf_p(
                               FILE*          const _Stream,
          wchar_t const* const _Format,
        ...)
    

#line 579 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vfwprintf_p_l(_Stream, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 588 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wprintf_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 597 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfwprintf_l((__acrt_iob_func(1)) , _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 606 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl wprintf(
          wchar_t const* const _Format,
        ...)
    

#line 614 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vfwprintf_l((__acrt_iob_func(1)) , _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 623 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wprintf_s_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 632 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfwprintf_s_l((__acrt_iob_func(1)) , _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 641 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl wprintf_s(
              wchar_t const* const _Format,
            ...)
    

#line 651 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
            _Result = _vfwprintf_s_l((__acrt_iob_func(1)) , _Format, 0 , _ArgList);
            ((void)(_ArgList = (va_list)0)) ;
            return _Result;
        }
    #line 660 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    #line 662 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wprintf_p_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 671 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfwprintf_p_l((__acrt_iob_func(1)) , _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 680 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wprintf_p(
          wchar_t const* const _Format,
        ...)
    

#line 688 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vfwprintf_p_l((__acrt_iob_func(1)) , _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 697 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"


    
    
    
    
    
    
    __declspec(dllimport) int __cdecl __stdio_common_vfwscanf(
                                           unsigned __int64 _Options,
                                        FILE*            _Stream,
          wchar_t const*   _Format,
                                       _locale_t        _Locale,
                                               va_list          _ArgList
        );

    
    __inline int __cdecl _vfwscanf_l(
         FILE*                                const _Stream,
          wchar_t const* const _Format,
                              _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 723 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwscanf(
            (*__local_stdio_scanf_options ()) ,
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 729 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl vfwscanf(
         FILE*                                const _Stream,
          wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 739 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_l(_Stream, _Format, 0 , _ArgList);
    }
    #line 743 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vfwscanf_s_l(
                               FILE*          const _Stream,
          wchar_t const* const _Format,
                              _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 754 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0) ,
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 760 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl vfwscanf_s(
                                   FILE*          const _Stream,
              wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 772 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwscanf_s_l(_Stream, _Format, 0 , _ArgList);
        }
    #line 776 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    #line 778 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    __inline int __cdecl _vwscanf_l(
          wchar_t const* const _Format,
                              _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 787 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_l((__acrt_iob_func(0)) , _Format, _Locale, _ArgList);
    }
    #line 791 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl vwscanf(
          wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 800 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_l((__acrt_iob_func(0)) , _Format, 0 , _ArgList);
    }
    #line 804 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwscanf_s_l(
          wchar_t const* const _Format,
                              _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 814 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_s_l((__acrt_iob_func(0)) , _Format, _Locale, _ArgList);
    }
    #line 818 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl vwscanf_s(
              wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 829 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwscanf_s_l((__acrt_iob_func(0)) , _Format, 0 , _ArgList);
        }
    #line 833 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    #line 835 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _fwscanf_l(
                                        FILE*          const _Stream,
          wchar_t const* const _Format,
                                       _locale_t      const _Locale,
        ...)
    

#line 845 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfwscanf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 854 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "fwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl fwscanf(
                              FILE*          const _Stream,
          wchar_t const* const _Format,
        ...)
    

#line 863 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vfwscanf_l(_Stream, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 872 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwscanf_s_l(
                                          FILE*          const _Stream,
          wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 882 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfwscanf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 891 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl fwscanf_s(
                                    FILE*          const _Stream,
              wchar_t const* const _Format,
            ...)
    

#line 902 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
            _Result = _vfwscanf_s_l(_Stream, _Format, 0 , _ArgList);
            ((void)(_ArgList = (va_list)0)) ;
            return _Result;
        }
    #line 911 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    #line 913 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _wscanf_l(
          wchar_t const* const _Format,
                                       _locale_t      const _Locale,
        ...)
    

#line 922 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfwscanf_l((__acrt_iob_func(0)) , _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 931 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "wscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl wscanf(
          wchar_t const* const _Format,
        ...)
    

#line 939 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vfwscanf_l((__acrt_iob_func(0)) , _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 948 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wscanf_s_l(
          wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 957 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfwscanf_s_l((__acrt_iob_func(0)) , _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 966 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl wscanf_s(
              wchar_t const* const _Format,
            ...)
    

#line 976 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
            _Result = _vfwscanf_s_l((__acrt_iob_func(0)) , _Format, 0 , _ArgList);
            ((void)(_ArgList = (va_list)0)) ;
            return _Result;
        }
    #line 985 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    #line 987 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"



    
    
    
    
    
    
        



    

#line 1003 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __declspec(dllimport) int __cdecl __stdio_common_vswprintf(
                                            unsigned __int64 _Options,
                wchar_t*         _Buffer,
                                            size_t           _BufferCount,
          wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    
    __declspec(dllimport) int __cdecl __stdio_common_vswprintf_s(
                                            unsigned __int64 _Options,
                    wchar_t*         _Buffer,
                                            size_t           _BufferCount,
          wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    
    __declspec(dllimport) int __cdecl __stdio_common_vsnwprintf_s(
                                            unsigned __int64 _Options,
                wchar_t*         _Buffer,
                                            size_t           _BufferCount,
                                            size_t           _MaxCount,
          wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    
    __declspec(dllimport) int __cdecl __stdio_common_vswprintf_p(
                                            unsigned __int64 _Options,
                    wchar_t*         _Buffer,
                                            size_t           _BufferCount,
          wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsnwprintf_l(
          wchar_t*       const _Buffer,
                                                 size_t         const _BufferCount,
               wchar_t const* const _Format,
                                             _locale_t      const _Locale,
                                                     va_list              _ArgList
        )
    

#line 1061 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()) | (1ULL << 0) ,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1069 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _vsnwprintf_s_l(
          wchar_t*       const _Buffer,
                                                      size_t         const _BufferCount,
                                                      size_t         const _MaxCount,
                    wchar_t const* const _Format,
                                                  _locale_t      const _Locale,
                                                          va_list              _ArgList
        )
    

#line 1083 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vsnwprintf_s(
            (*__local_stdio_printf_options()) ,
            _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1091 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _vsnwprintf_s(
          wchar_t*       const _Buffer,
                                                      size_t         const _BufferCount,
                                                      size_t         const _MaxCount,
                              wchar_t const* const _Format,
                                                          va_list              _ArgList
        )
    

#line 1104 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0 , _ArgList);
    }
    #line 1108 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline int __cdecl _snwprintf( wchar_t *_Buffer, size_t _BufferCount, wchar_t const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline int __cdecl _vsnwprintf( wchar_t *_Buffer, size_t _BufferCount, wchar_t const* _Format, va_list _Args);








    
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsnwprintf(
          wchar_t*       _Buffer,
                                                 size_t         _BufferCount,
                         wchar_t const* _Format,
                                                     va_list        _ArgList
        )
    

#line 1129 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
    }
    #line 1133 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { template <size_t _Size> inline int __cdecl _vsnwprintf_s(wchar_t (&_Buffer)[_Size], size_t _BufferCount, wchar_t const* _Format, va_list _ArgList) throw() { return _vsnwprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }








    
    
    __inline int __cdecl _vswprintf_c_l(
          wchar_t*       const _Buffer,
                                                      size_t         const _BufferCount,
                    wchar_t const* const _Format,
                                                  _locale_t      const _Locale,
                                                          va_list              _ArgList
        )
    

#line 1155 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()) ,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1163 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _vswprintf_c(
          wchar_t*       const _Buffer,
                                                      size_t         const _BufferCount,
                              wchar_t const* const _Format,
                                                          va_list              _ArgList
        )
    

#line 1175 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
    }
    #line 1179 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _vswprintf_l(
          wchar_t*       const _Buffer,
                                                      size_t         const _BufferCount,
                    wchar_t const* const _Format,
                                                  _locale_t      const _Locale,
                                                          va_list              _ArgList
        )
    

#line 1192 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }
    #line 1196 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl __vswprintf_l(
                 wchar_t*       const _Buffer,
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 1208 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 1212 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _vswprintf(
          wchar_t*       const _Buffer,
             wchar_t const* const _Format,
                                         va_list              _ArgList
        )
    

#line 1223 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, 0 , _ArgList);
    }
    #line 1227 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl vswprintf(
          wchar_t*       const _Buffer,
                                                      size_t         const _BufferCount,
                    wchar_t const* const _Format,
                                                          va_list              _ArgList
        )
    

#line 1239 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
    }
    #line 1243 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _vswprintf_s_l(
          wchar_t*       const _Buffer,
                                                  size_t         const _BufferCount,
                wchar_t const* const _Format,
                                              _locale_t      const _Locale,
                                                      va_list              _ArgList
        )
    

#line 1256 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf_s(
            (*__local_stdio_printf_options()) ,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1264 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl vswprintf_s(
              wchar_t*       const _Buffer,
                                                      size_t         const _BufferCount,
                              wchar_t const* const _Format,
                                                          va_list              _ArgList
            )
    

#line 1277 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
        }
    #line 1281 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    #line 1283 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { template <size_t _Size> inline int __cdecl vswprintf_s(wchar_t (&_Buffer)[_Size], wchar_t const* _Format, va_list _ArgList) throw() { return vswprintf_s(_Buffer, _Size, _Format, _ArgList); } }







    
    
    __inline int __cdecl _vswprintf_p_l(
          wchar_t*       const _Buffer,
                                                  size_t         const _BufferCount,
                wchar_t const* const _Format,
                                              _locale_t      const _Locale,
                                                      va_list              _ArgList
        )
    

#line 1304 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf_p(
            (*__local_stdio_printf_options()) ,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1312 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _vswprintf_p(
          wchar_t*       const _Buffer,
                                                  size_t         const _BufferCount,
                          wchar_t const* const _Format,
                                                      va_list              _ArgList
        )
    

#line 1324 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
    }
    #line 1328 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _vscwprintf_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 1339 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1) ,
            0 , 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1347 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _vscwprintf(
          wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 1357 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vscwprintf_l(_Format, 0 , _ArgList);
    }
    #line 1361 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _vscwprintf_p_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 1372 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf_p(
            (*__local_stdio_printf_options()) | (1ULL << 1) ,
            0 , 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1380 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _vscwprintf_p(
          wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 1390 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vscwprintf_p_l(_Format, 0 , _ArgList);
    }
    #line 1394 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl __swprintf_l(
                 wchar_t*       const _Buffer,
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 1405 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = __vswprintf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1414 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _swprintf_l(
          wchar_t*       const _Buffer,
                                                      size_t         const _BufferCount,
                    wchar_t const* const _Format,
                                                  _locale_t      const _Locale,
        ...)
    

#line 1426 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1435 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _swprintf(
          wchar_t*       const _Buffer,
             wchar_t const* const _Format,
        ...)
    

#line 1445 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = __vswprintf_l(_Buffer, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1454 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl swprintf(
          wchar_t*       const _Buffer,
                                                      size_t         const _BufferCount,
                              wchar_t const* const _Format,
        ...)
    

#line 1465 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1474 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "__swprintf_l_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline int __cdecl __swprintf_l( wchar_t *_Buffer, wchar_t const* _Format, _locale_t _Locale, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vswprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline int __cdecl __vswprintf_l( wchar_t *_Buffer, wchar_t const* _Format, _locale_t _Locale, va_list _Args);








    __declspec(deprecated("This function or variable may be unsafe. Consider using " "swprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline int __cdecl _swprintf( wchar_t *_Buffer, wchar_t const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "vswprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline int __cdecl _vswprintf( wchar_t *_Buffer, wchar_t const* _Format, va_list _Args);






    
    
    __inline int __cdecl _swprintf_s_l(
          wchar_t*       const _Buffer,
                                                  size_t         const _BufferCount,
                wchar_t const* const _Format,
                                              _locale_t      const _Locale,
        ...)
    

#line 1502 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1511 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl swprintf_s(
              wchar_t*       const _Buffer,
                                                      size_t         const _BufferCount,
                              wchar_t const* const _Format,
            ...)
    

#line 1523 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
            _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
            ((void)(_ArgList = (va_list)0)) ;
            return _Result;
        }
    #line 1532 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    #line 1534 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { template <size_t _Size> inline int __cdecl swprintf_s(wchar_t (&_Buffer)[_Size], wchar_t const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return vswprintf_s(_Buffer, _Size, _Format, _ArgList); } }






    
    
    __inline int __cdecl _swprintf_p_l(
          wchar_t*       const _Buffer,
                                                  size_t         const _BufferCount,
                wchar_t const* const _Format,
                                              _locale_t      const _Locale,
        ...)
    

#line 1553 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1562 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _swprintf_p(
          wchar_t*       const _Buffer,
                                                  size_t         const _BufferCount,
                          wchar_t const* const _Format,
        ...)
    

#line 1573 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1582 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _swprintf_c_l(
          wchar_t*       const _Buffer,
                                                      size_t         const _BufferCount,
                    wchar_t const* const _Format,
                                                  _locale_t      const _Locale,
        ...)
    

#line 1594 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1603 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _swprintf_c(
          wchar_t*       const _Buffer,
                                                      size_t         const _BufferCount,
                              wchar_t const* const _Format,
        ...)
    

#line 1614 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1623 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snwprintf_l(
          wchar_t*       const _Buffer,
                                                 size_t         const _BufferCount,
               wchar_t const* const _Format,
                                             _locale_t      const _Locale,
        ...)
    

#line 1635 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;

        _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1646 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _snwprintf(
          wchar_t*       _Buffer,
                                                 size_t         _BufferCount,
                         wchar_t const* _Format,
        ...)
    

#line 1657 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;

        _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);

        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1668 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _snwprintf_s_l(
          wchar_t*       const _Buffer,
                                                      size_t         const _BufferCount,
                                                      size_t         const _MaxCount,
                    wchar_t const* const _Format,
                                                  _locale_t      const _Locale,
        ...)
    

#line 1681 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1690 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _snwprintf_s(
          wchar_t*       const _Buffer,
                                                      size_t         const _BufferCount,
                                                      size_t         const _MaxCount,
                              wchar_t const* const _Format,
        ...)
    

#line 1702 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1711 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { template <size_t _Size> inline int __cdecl _snwprintf_s(wchar_t (&_Buffer)[_Size], size_t _BufferCount, wchar_t const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return _vsnwprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }







    
    __inline int __cdecl _scwprintf_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 1728 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vscwprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1737 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _scwprintf(
          wchar_t const* const _Format,
        ...)
    

#line 1746 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vscwprintf_l(_Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1755 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _scwprintf_p_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 1765 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vscwprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1774 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _scwprintf_p(
          wchar_t const* const _Format,
        ...)
    

#line 1783 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vscwprintf_p_l(_Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1792 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"


    
        
        
        #pragma warning(push)
        #pragma warning(disable: 4141 6054)

        

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "swprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
            inline int swprintf(
                         wchar_t*       const _Buffer,
                  wchar_t const* const _Format,
                ...) throw()
            {
                int _Result;
                va_list _ArgList;
                ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
                _Result = vswprintf(_Buffer, 2147483647 , _Format, _ArgList);
                ((void)(_ArgList = (va_list)0)) ;
                return _Result;
            }

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "vswprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
            inline int __cdecl vswprintf(
                         wchar_t*       const _Buffer,
                  wchar_t const* const _Format,
                                              va_list              _ArgList
                ) throw()
            {
                return vswprintf(_Buffer, 2147483647 , _Format, _ArgList);
            }

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_swprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
            inline int _swprintf_l(
                                   wchar_t*       const _Buffer,
                  wchar_t const* const _Format,
                                                _locale_t      const _Locale,
                ...) throw()
            {
                int _Result;
                va_list _ArgList;
                ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
                _Result = _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
                ((void)(_ArgList = (va_list)0)) ;
                return _Result;
            }

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vswprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
            inline int __cdecl _vswprintf_l(
                                   wchar_t*       const _Buffer,
                  wchar_t const* const _Format,
                                                _locale_t      const _Locale,
                                                        va_list              _ArgList
                ) throw()
            {
                return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
            }

        #line 1853 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

        #pragma warning(pop)
    #line 1856 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    




#line 1863 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"


    
    
    
    
    
    
    __declspec(dllimport) int __cdecl __stdio_common_vswscanf(
                                           unsigned __int64 _Options,
                wchar_t const*   _Buffer,
                                           size_t           _BufferCount,
          wchar_t const*   _Format,
                                       _locale_t        _Locale,
                                               va_list          _ArgList
        );

    
    
    __inline int __cdecl _vswscanf_l(
                                wchar_t const* const _Buffer,
          wchar_t const* const _Format,
                              _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 1891 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()) ,
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 1897 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl vswscanf(
                                wchar_t const* _Buffer,
          wchar_t const* _Format,
                                      va_list        _ArgList
        )
    

#line 1908 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswscanf_l(_Buffer, _Format, 0 , _ArgList);
    }
    #line 1912 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _vswscanf_s_l(
                                wchar_t const* const _Buffer,
          wchar_t const* const _Format,
                              _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 1924 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0) ,
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 1930 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    

        
        
        __inline int __cdecl vswscanf_s(
                                    wchar_t const* const _Buffer,
              wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 1943 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vswscanf_s_l(_Buffer, _Format, 0 , _ArgList);
        }
    #line 1947 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    #line 1949 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { template <size_t _Size> inline int __cdecl vswscanf_s(wchar_t (&_Buffer)[_Size], wchar_t const* _Format, va_list _ArgList) throw() { return vswscanf_s(_Buffer, _Size, _Format, _ArgList); } }







    
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsnwscanf_l(
                wchar_t const* const _Buffer,
                                           size_t         const _BufferCount,
          wchar_t const* const _Format,
                                       _locale_t      const _Locale,
                                               va_list              _ArgList
        )
    

#line 1970 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()) ,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }
    #line 1976 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _vsnwscanf_s_l(
                  wchar_t const* const _Buffer,
                                             size_t         const _BufferCount,
          wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                 va_list              _ArgList
        )
    

#line 1989 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0) ,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }
    #line 1995 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_swscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _swscanf_l(
                                         wchar_t const* const _Buffer,
          wchar_t const* const _Format,
                                       _locale_t            _Locale,
        ...)
    

#line 2006 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vswscanf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2015 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "swscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl swscanf(
                               wchar_t const* const _Buffer,
          wchar_t const* const _Format,
        ...)
    

#line 2025 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vswscanf_l(_Buffer, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2034 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _swscanf_s_l(
                                           wchar_t const* const _Buffer,
          wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 2045 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vswscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2054 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    

        
        
        __inline int __cdecl swscanf_s(
                                     wchar_t const* const _Buffer,
              wchar_t const* const _Format,
            ...)
    

#line 2066 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
            _Result = _vswscanf_s_l(_Buffer, _Format, 0 , _ArgList);
            ((void)(_ArgList = (va_list)0)) ;
            return _Result;
        }
    #line 2075 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    #line 2077 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snwscanf_l(
                wchar_t const* const _Buffer,
                                           size_t         const _BufferCount,
          wchar_t const* const _Format,
                                       _locale_t      const _Locale,
        ...)
    

#line 2089 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;

        _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2100 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snwscanf(
          wchar_t const* const _Buffer,
                                     size_t         const _BufferCount,
              wchar_t const* const _Format,
        ...)
    

#line 2111 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;

        _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);

        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2122 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _snwscanf_s_l(
                  wchar_t const* const _Buffer,
                                             size_t         const _BufferCount,
          wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 2134 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2143 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _snwscanf_s(
           wchar_t const* const _Buffer,
                                      size_t         const _BufferCount,
             wchar_t const* const _Format,
        ...)
    

#line 2154 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2163 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

    


#line 2168 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstdio.h"

} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {

 





























    
#line 53 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"



 











    
    
#line 71 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"


typedef __int64 fpos_t;





    
    __declspec(dllimport) errno_t __cdecl _get_stream_buffer_pointers(
              FILE*   _Stream,
         char*** _Base,
         char*** _Pointer,
         int**   _Count
        );


    
    
    
    
    
    

        
        __declspec(dllimport) errno_t __cdecl clearerr_s(
             FILE* _Stream
            );

        
        
        __declspec(dllimport) errno_t __cdecl fopen_s(
             FILE**      _Stream,
                                    char const* _FileName,
                                    char const* _Mode
            );

        
        
        __declspec(dllimport) size_t __cdecl fread_s(
               void*  _Buffer,
                                   size_t _BufferSize,
                                                                           size_t _ElementSize,
                                                                           size_t _ElementCount,
                                                                        FILE*  _Stream
            );

        
        __declspec(dllimport) errno_t __cdecl freopen_s(
             FILE**      _Stream,
                                char const* _FileName,
                                char const* _Mode,
                               FILE*       _OldStream
            );

        
        __declspec(dllimport) char* __cdecl gets_s(
             char*   _Buffer,
                              rsize_t _Size
            );

        
        __declspec(dllimport) errno_t __cdecl tmpfile_s(
              FILE** _Stream
            );

        
        
        __declspec(dllimport) errno_t __cdecl tmpnam_s(
             char*   _Buffer,
                              rsize_t _Size
            );

    #line 145 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    __declspec(dllimport) void __cdecl clearerr(
         FILE* _Stream
        );

    
    
    __declspec(dllimport) int __cdecl fclose(
         FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _fcloseall(void);

    
    __declspec(dllimport) FILE* __cdecl _fdopen(
           int         _FileHandle,
         char const* _Mode
        );

    
    __declspec(dllimport) int __cdecl feof(
         FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl ferror(
         FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl fflush(
         FILE* _Stream
        );

    
    
    __declspec(dllimport) int __cdecl fgetc(
         FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _fgetchar(void);

    
    
    __declspec(dllimport) int __cdecl fgetpos(
         FILE*   _Stream,
           fpos_t* _Position
        );

    
    
    __declspec(dllimport) char* __cdecl fgets(
         char* _Buffer,
                              int   _MaxCount,
                           FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _fileno(
         FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _flushall(void);

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "fopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) FILE* __cdecl fopen(
         char const* _FileName,
         char const* _Mode
        );


    
    
    __declspec(dllimport) int __cdecl fputc(
            int   _Character,
         FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _fputchar(
         int _Character
        );

    
    
    __declspec(dllimport) int __cdecl fputs(
          char const* _Buffer,
         FILE*       _Stream
        );

    
    __declspec(dllimport) size_t __cdecl fread(
         void*  _Buffer,
                                                     size_t _ElementSize,
                                                     size_t _ElementCount,
                                                  FILE*  _Stream
        );

    
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "freopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) FILE* __cdecl freopen(
          char const* _FileName,
          char const* _Mode,
         FILE*       _Stream
        );

    
    __declspec(dllimport) FILE* __cdecl _fsopen(
         char const* _FileName,
         char const* _Mode,
           int         _ShFlag
        );

    
    
    __declspec(dllimport) int __cdecl fsetpos(
         FILE*         _Stream,
            fpos_t const* _Position
        );

    
    
    __declspec(dllimport) int __cdecl fseek(
         FILE* _Stream,
            long  _Offset,
            int   _Origin
        );

    
    
    __declspec(dllimport) int __cdecl _fseeki64(
         FILE*   _Stream,
            __int64 _Offset,
            int     _Origin
        );

    
    
    __declspec(dllimport) long __cdecl ftell(
         FILE* _Stream
        );

    
    
    __declspec(dllimport) __int64 __cdecl _ftelli64(
         FILE* _Stream
        );

    
    __declspec(dllimport) size_t __cdecl fwrite(
         void const* _Buffer,
                                                   size_t      _ElementSize,
                                                   size_t      _ElementCount,
                                                FILE*       _Stream
        );

    
    
    __declspec(dllimport) int __cdecl getc(
         FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl getchar(void);

    
    __declspec(dllimport) int __cdecl _getmaxstdio(void);

    extern "C++" { template <size_t _Size> inline char* __cdecl gets_s(char (&_Buffer)[_Size]) throw() { return gets_s(_Buffer, _Size); } }



    
    __declspec(dllimport) int __cdecl _getw(
         FILE* _Stream
        );

    __declspec(dllimport) void __cdecl perror(
         char const* _ErrorMessage
        );

    

        
        
        __declspec(dllimport) int __cdecl _pclose(
             FILE* _Stream
            );

        
        __declspec(dllimport) FILE* __cdecl _popen(
             char const* _Command,
             char const* _Mode
            );

    #line 344 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    
    __declspec(dllimport) int __cdecl putc(
            int   _Character,
         FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl putchar(
         int _Character
        );

    
    __declspec(dllimport) int __cdecl puts(
         char const* _Buffer
        );

    
    
    __declspec(dllimport) int __cdecl _putw(
            int   _Word,
         FILE* _Stream
        );

    __declspec(dllimport) int __cdecl remove(
         char const* _FileName
        );

    
    __declspec(dllimport) int __cdecl rename(
         char const* _OldFileName,
         char const* _NewFileName
        );

    __declspec(dllimport) int __cdecl _unlink(
         char const* _FileName
        );

    

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_unlink" ". See online help for details."))
        __declspec(dllimport) int __cdecl unlink(
             char const* _FileName
            );

    #line 391 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    __declspec(dllimport) void __cdecl rewind(
         FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _rmtmp(void);

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "setvbuf" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) void __cdecl setbuf(
                                                     FILE* _Stream,
          char* _Buffer
        );

    
    __declspec(dllimport) int __cdecl _setmaxstdio(
         int _Maximum
        );

    
    
    __declspec(dllimport) int __cdecl setvbuf(
                              FILE*  _Stream,
           char*  _Buffer,
                                 int    _Mode,
                                 size_t _Size
        );

    


#line 423 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __declspec(dllimport) __declspec(allocator) char* __cdecl _tempnam(
         char const* _DirectoryName,
         char const* _FilePrefix
        );

    

#line 433 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "tmpfile_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) FILE* __cdecl tmpfile(void);

    extern "C++" { template <size_t _Size> inline errno_t __cdecl tmpnam_s(char (&_Buffer)[_Size]) throw() { return tmpnam_s(_Buffer, _Size); } }





__declspec(deprecated("This function or variable may be unsafe. Consider using " "tmpnam_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl tmpnam( char *_Buffer);





    
    
    __declspec(dllimport) int __cdecl ungetc(
            int   _Character,
         FILE* _Stream
        );



    
    
    
    
    
    __declspec(dllimport) void __cdecl _lock_file(
         FILE* _Stream
        );

    __declspec(dllimport) void __cdecl _unlock_file(
         FILE* _Stream
        );

    
    
    __declspec(dllimport) int __cdecl _fclose_nolock(
         FILE* _Stream
        );

    
    
    __declspec(dllimport) int __cdecl _fflush_nolock(
         FILE* _Stream
        );

    
    
    __declspec(dllimport) int __cdecl _fgetc_nolock(
         FILE* _Stream
        );

    
    
    __declspec(dllimport) int __cdecl _fputc_nolock(
            int   _Character,
         FILE* _Stream
        );

    
    __declspec(dllimport) size_t __cdecl _fread_nolock(
         void*  _Buffer,
                                                     size_t _ElementSize,
                                                     size_t _ElementCount,
                                                  FILE*  _Stream
        );

    
    
    __declspec(dllimport) size_t __cdecl _fread_nolock_s(
         void*  _Buffer,
                             size_t _BufferSize,
                                                                     size_t _ElementSize,
                                                                     size_t _ElementCount,
                                                                  FILE*  _Stream
        );

    
    __declspec(dllimport) int __cdecl _fseek_nolock(
         FILE* _Stream,
            long  _Offset,
            int   _Origin
        );

    
    __declspec(dllimport) int __cdecl _fseeki64_nolock(
         FILE*   _Stream,
            __int64 _Offset,
            int     _Origin
        );

    
    __declspec(dllimport) long __cdecl _ftell_nolock(
         FILE* _Stream
        );

    
    __declspec(dllimport) __int64 __cdecl _ftelli64_nolock(
         FILE* _Stream
        );

    
    __declspec(dllimport) size_t __cdecl _fwrite_nolock(
         void const* _Buffer,
                                                   size_t      _ElementSize,
                                                   size_t      _ElementCount,
                                                FILE*       _Stream
        );

    
    __declspec(dllimport) int __cdecl _getc_nolock(
         FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _putc_nolock(
            int   _Character,
         FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _ungetc_nolock(
            int   _Character,
         FILE* _Stream
        );

    
    
    
    



    














#line 586 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"



    __declspec(dllimport) int* __cdecl __p__commode(void);

    


        
    #line 596 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"



    
    

#line 603 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    
    
    
    
    __declspec(dllimport) int __cdecl __stdio_common_vfprintf(
                                            unsigned __int64 _Options,
                                         FILE*            _Stream,
          char const*      _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    __declspec(dllimport) int __cdecl __stdio_common_vfprintf_s(
                                            unsigned __int64 _Options,
                                         FILE*            _Stream,
          char const*      _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __stdio_common_vfprintf_p(
                                            unsigned __int64 _Options,
                                         FILE*            _Stream,
          char const*      _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __inline int __cdecl _vfprintf_l(
          FILE*       const _Stream,
           char const* const _Format,
         _locale_t   const _Locale,
                 va_list           _ArgList
        )
    

#line 644 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfprintf((*__local_stdio_printf_options()) , _Stream, _Format, _Locale, _ArgList);
    }
    #line 648 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vfprintf(
                               FILE*       const _Stream,
          char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 658 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return _vfprintf_l(_Stream, _Format, 0 , _ArgList);
    }
    #line 662 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vfprintf_s_l(
          FILE*       const _Stream,
           char const* const _Format,
         _locale_t   const _Locale,
                 va_list           _ArgList
        )
    

#line 673 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfprintf_s((*__local_stdio_printf_options()) , _Stream, _Format, _Locale, _ArgList);
    }
    #line 677 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl vfprintf_s(
                                   FILE*       const _Stream,
              char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 689 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
        {
            return _vfprintf_s_l(_Stream, _Format, 0 , _ArgList);
        }
    #line 693 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    #line 695 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vfprintf_p_l(
          FILE*       const _Stream,
           char const* const _Format,
         _locale_t   const _Locale,
                 va_list           _ArgList
        )
    

#line 706 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfprintf_p((*__local_stdio_printf_options()) , _Stream, _Format, _Locale, _ArgList);
    }
    #line 710 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vfprintf_p(
                               FILE*       const _Stream,
          char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 720 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return _vfprintf_p_l(_Stream, _Format, 0 , _ArgList);
    }
    #line 724 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vprintf_l(
          char const* const _Format,
                                        _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 734 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return _vfprintf_l((__acrt_iob_func(1)) , _Format, _Locale, _ArgList);
    }
    #line 738 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vprintf(
          char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 747 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return _vfprintf_l((__acrt_iob_func(1)) , _Format, 0 , _ArgList);
    }
    #line 751 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vprintf_s_l(
          char const* const _Format,
                                        _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 761 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return _vfprintf_s_l((__acrt_iob_func(1)) , _Format, _Locale, _ArgList);
    }
    #line 765 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl vprintf_s(
              char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 776 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
        {
            return _vfprintf_s_l((__acrt_iob_func(1)) , _Format, 0 , _ArgList);
        }
    #line 780 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    #line 782 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vprintf_p_l(
          char const* const _Format,
                                        _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 792 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return _vfprintf_p_l((__acrt_iob_func(1)) , _Format, _Locale, _ArgList);
    }
    #line 796 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vprintf_p(
          char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 805 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return _vfprintf_p_l((__acrt_iob_func(1)) , _Format, 0 , _ArgList);
    }
    #line 809 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _fprintf_l(
                                         FILE*       const _Stream,
          char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 819 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfprintf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 828 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl fprintf(
                               FILE*       const _Stream,
          char const* const _Format,
        ...)
    

#line 837 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vfprintf_l(_Stream, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 846 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    __declspec(dllimport) int __cdecl _set_printf_count_output(
         int _Value
        );

    __declspec(dllimport) int __cdecl _get_printf_count_output(void);

    
    __inline int __cdecl _fprintf_s_l(
                                         FILE*       const _Stream,
          char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 862 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfprintf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 871 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl fprintf_s(
                                   FILE*       const _Stream,
              char const* const _Format,
            ...)
    

#line 882 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
            _Result = _vfprintf_s_l(_Stream, _Format, 0 , _ArgList);
            ((void)(_ArgList = (va_list)0)) ;
            return _Result;
        }
    #line 891 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    #line 893 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _fprintf_p_l(
                                         FILE*       const _Stream,
          char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 903 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfprintf_p_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 912 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _fprintf_p(
                               FILE*       const _Stream,
          char const* const _Format,
        ...)
    

#line 921 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vfprintf_p_l(_Stream, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 930 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _printf_l(
          char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 939 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfprintf_l((__acrt_iob_func(1)) , _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 948 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl printf(
          char const* const _Format,
        ...)
    

#line 956 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vfprintf_l((__acrt_iob_func(1)) , _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 965 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _printf_s_l(
          char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 974 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfprintf_s_l((__acrt_iob_func(1)) , _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 983 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl printf_s(
              char const* const _Format,
            ...)
    

#line 993 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
            _Result = _vfprintf_s_l((__acrt_iob_func(1)) , _Format, 0 , _ArgList);
            ((void)(_ArgList = (va_list)0)) ;
            return _Result;
        }
    #line 1002 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    #line 1004 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _printf_p_l(
          char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 1013 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfprintf_p_l((__acrt_iob_func(1)) , _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1022 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _printf_p(
          char const* const _Format,
        ...)
    

#line 1030 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vfprintf_p_l((__acrt_iob_func(1)) , _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1039 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"


    
    
    
    
    
    __declspec(dllimport) int __cdecl __stdio_common_vfscanf(
                                           unsigned __int64 _Options,
                                        FILE*            _Stream,
          char const*      _Format,
                                       _locale_t        _Locale,
                                               va_list          _Arglist
        );

    
    __inline int __cdecl _vfscanf_l(
                               FILE*       const _Stream,
          char const* const _Format,
                              _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 1064 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfscanf(
            (*__local_stdio_scanf_options ()) ,
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 1070 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vfscanf(
                               FILE*       const _Stream,
          char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 1080 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return _vfscanf_l(_Stream, _Format, 0 , _ArgList);
    }
    #line 1084 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vfscanf_s_l(
                               FILE*       const _Stream,
          char const* const _Format,
                              _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 1095 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0) ,
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 1101 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"


    

        
        __inline int __cdecl vfscanf_s(
                                   FILE*       const _Stream,
              char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 1114 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
        {
            return _vfscanf_s_l(_Stream, _Format, 0 , _ArgList);
        }
    #line 1118 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    #line 1120 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscanf_l(
          char const* const _Format,
                              _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 1130 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return _vfscanf_l((__acrt_iob_func(0)) , _Format, _Locale, _ArgList);
    }
    #line 1134 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vscanf(
          char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 1143 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return _vfscanf_l((__acrt_iob_func(0)) , _Format, 0 , _ArgList);
    }
    #line 1147 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscanf_s_l(
          char const* const _Format,
                              _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 1157 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return _vfscanf_s_l((__acrt_iob_func(0)) , _Format, _Locale, _ArgList);
    }
    #line 1161 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl vscanf_s(
              char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 1172 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
        {
            return _vfscanf_s_l((__acrt_iob_func(0)) , _Format, 0 , _ArgList);
        }
    #line 1176 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    #line 1178 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _fscanf_l(
                                        FILE*       const _Stream,
          char const* const _Format,
                                       _locale_t   const _Locale,
        ...)
    

#line 1188 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfscanf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1197 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "fscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl fscanf(
                              FILE*       const _Stream,
          char const* const _Format,
        ...)
    

#line 1206 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vfscanf_l(_Stream, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1215 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _fscanf_s_l(
                                          FILE*       const _Stream,
          char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 1225 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfscanf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1234 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl fscanf_s(
                                    FILE*       const _Stream,
              char const* const _Format,
            ...)
    

#line 1245 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
            _Result = _vfscanf_s_l(_Stream, _Format, 0 , _ArgList);
            ((void)(_ArgList = (va_list)0)) ;
            return _Result;
        }
    #line 1254 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    #line 1256 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_scanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _scanf_l(
          char const* const _Format,
                                       _locale_t   const _Locale,
        ...)
    

#line 1265 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfscanf_l((__acrt_iob_func(0)) , _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1274 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "scanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl scanf(
          char const* const _Format,
        ...)
    

#line 1282 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vfscanf_l((__acrt_iob_func(0)) , _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1291 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _scanf_s_l(
          char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 1300 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfscanf_s_l((__acrt_iob_func(0)) , _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1309 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl scanf_s(
              char const* const _Format,
            ...)
    

#line 1319 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
            _Result = _vfscanf_s_l((__acrt_iob_func(0)) , _Format, 0 , _ArgList);
            ((void)(_ArgList = (va_list)0)) ;
            return _Result;
        }
    #line 1328 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    #line 1330 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"



    
    
    
    
    
    
    __declspec(dllimport) int __cdecl __stdio_common_vsprintf(
                                            unsigned __int64 _Options,
                char*            _Buffer,
                                            size_t           _BufferCount,
          char const*      _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __stdio_common_vsprintf_s(
                                            unsigned __int64 _Options,
                    char*            _Buffer,
                                            size_t           _BufferCount,
          char const*      _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __stdio_common_vsnprintf_s(
                                            unsigned __int64 _Options,
                char*            _Buffer,
                                            size_t           _BufferCount,
                                            size_t           _MaxCount,
          char const*      _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __stdio_common_vsprintf_p(
                                            unsigned __int64 _Options,
                    char*            _Buffer,
                                            size_t           _BufferCount,
          char const*      _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsnprintf_l(
          char*       const _Buffer,
                                                 size_t      const _BufferCount,
               char const* const _Format,
                                             _locale_t   const _Locale,
                                                     va_list           _ArgList
        )
    

#line 1391 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 0) ,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1399 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    
    __inline int __cdecl _vsnprintf(
          char*       const _Buffer,
                                                size_t      const _BufferCount,
                        char const* const _Format,
                                                    va_list           _ArgList
        )
    

#line 1411 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return _vsnprintf_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
    }
    #line 1415 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    








#line 1426 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    
    __inline int __cdecl vsnprintf(
          char*       const _Buffer,
                                                      size_t      const _BufferCount,
                              char const* const _Format,
                                                          va_list           _ArgList
        )
    

#line 1438 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1) ,
            _Buffer, _BufferCount, _Format, 0 , _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1446 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsprintf_l(
          char*       const _Buffer,
                                   char const* const _Format,
                                 _locale_t   const _Locale,
                                         va_list           _ArgList
        )
    

#line 1458 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 1462 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "vsprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl vsprintf(
          char*       const _Buffer,
             char const* const _Format,
                                         va_list           _ArgList
        )
    

#line 1473 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return _vsnprintf_l(_Buffer, (size_t)-1, _Format, 0 , _ArgList);
    }
    #line 1477 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    
    __inline int __cdecl _vsprintf_s_l(
          char*       const _Buffer,
                                                  size_t      const _BufferCount,
                char const* const _Format,
                                              _locale_t   const _Locale,
                                                      va_list           _ArgList
        )
    

#line 1490 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf_s(
            (*__local_stdio_printf_options()) ,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1498 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    

        
        
        __inline int __cdecl vsprintf_s(
              char*       const _Buffer,
                                                      size_t      const _BufferCount,
                              char const* const _Format,
                                                          va_list           _ArgList
            )
    

#line 1512 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
        {
            return _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
        }
    #line 1516 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

        extern "C++" { template <size_t _Size> inline int __cdecl vsprintf_s(char (&_Buffer)[_Size], char const* _Format, va_list _ArgList) throw() { return vsprintf_s(_Buffer, _Size, _Format, _ArgList); } }







    #line 1526 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    
    __inline int __cdecl _vsprintf_p_l(
          char*       const _Buffer,
                                                  size_t      const _BufferCount,
                char const* const _Format,
                                              _locale_t   const _Locale,
                                                      va_list           _ArgList
        )
    

#line 1539 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf_p(
            (*__local_stdio_printf_options()) ,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1547 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    
    __inline int __cdecl _vsprintf_p(
          char*       const _Buffer,
                                                  size_t      const _BufferCount,
                          char const* const _Format,
                                                      va_list           _ArgList
        )
    

#line 1559 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
    }
    #line 1563 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    
    __inline int __cdecl _vsnprintf_s_l(
          char*       const _Buffer,
                                                      size_t      const _BufferCount,
                                                      size_t      const _MaxCount,
                    char const* const _Format,
                                                  _locale_t   const _Locale,
                                                          va_list          _ArgList
        )
    

#line 1577 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsnprintf_s(
            (*__local_stdio_printf_options()) ,
            _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1585 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    
    __inline int __cdecl _vsnprintf_s(
          char*       const _Buffer,
                                                      size_t      const _BufferCount,
                                                      size_t      const _MaxCount,
                              char const* const _Format,
                                                          va_list           _ArgList
        )
    

#line 1598 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0 , _ArgList);
    }
    #line 1602 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    extern "C++" { template <size_t _Size> inline int __cdecl _vsnprintf_s(char (&_Buffer)[_Size], size_t _BufferCount, char const* _Format, va_list _ArgList) throw() { return _vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }








    

        
        
        __inline int __cdecl vsnprintf_s(
              char*       const _Buffer,
                                                          size_t      const _BufferCount,
                                                          size_t      const _MaxCount,
                                  char const* const _Format,
                                                              va_list           _ArgList
            )
    

#line 1626 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
        {
            return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0 , _ArgList);
        }
    #line 1630 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

        extern "C++" { template <size_t _Size> inline int __cdecl vsnprintf_s(char (&_Buffer)[_Size], size_t _BufferCount, char const* _Format, va_list _ArgList) throw() { return vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }








    #line 1641 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscprintf_l(
          char const* const _Format,
                                        _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 1651 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1) ,
            0 , 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1659 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscprintf(
          char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 1668 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return _vscprintf_l(_Format, 0 , _ArgList);
    }
    #line 1672 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscprintf_p_l(
          char const* const _Format,
                                        _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 1682 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf_p(
            (*__local_stdio_printf_options()) | (1ULL << 1) ,
            0 , 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1690 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscprintf_p(
          char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 1699 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return _vscprintf_p_l(_Format, 0 , _ArgList);
    }
    #line 1703 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vsnprintf_c_l(
                  char*       const _Buffer,
                                            size_t      const _BufferCount,
          char const* const _Format,
                                        _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 1715 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) ,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1723 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    
    __inline int __cdecl _vsnprintf_c(
         char*       const _Buffer,
                                   size_t      const _BufferCount,
           char const* const _Format,
                                       va_list           _ArgList
        )
    

#line 1735 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
    }
    #line 1739 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_sprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _sprintf_l(
                 char*       const _Buffer,
          char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 1750 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;

        _Result = _vsprintf_l(_Buffer, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1761 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    
    __inline int __cdecl sprintf(
          char*       const _Buffer,
             char const* const _Format,
        ...)
    

#line 1771 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;

        _Result = _vsprintf_l(_Buffer, _Format, 0 , _ArgList);

        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1782 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "sprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) int __cdecl sprintf( char *_Buffer, char const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "vsprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) int __cdecl vsprintf( char *_Buffer, char const* _Format, va_list _Args);






    
    
    __inline int __cdecl _sprintf_s_l(
          char*       const _Buffer,
                                                  size_t      const _BufferCount,
                char const* const _Format,
                                              _locale_t   const _Locale,
        ...)
    

#line 1801 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1810 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    

        
        
        __inline int __cdecl sprintf_s(
              char*       const _Buffer,
                                                      size_t      const _BufferCount,
                              char const* const _Format,
            ...)
    

#line 1823 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
            _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
            ((void)(_ArgList = (va_list)0)) ;
            return _Result;
        }
    #line 1832 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    #line 1834 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    extern "C++" { template <size_t _Size> inline int __cdecl sprintf_s(char (&_Buffer)[_Size], char const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return vsprintf_s(_Buffer, _Size, _Format, _ArgList); } }






    
    
    __inline int __cdecl _sprintf_p_l(
          char*       const _Buffer,
                                                  size_t      const _BufferCount,
                char const* const _Format,
                                              _locale_t   const _Locale,
        ...)
    

#line 1853 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1862 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    
    __inline int __cdecl _sprintf_p(
          char*       const _Buffer,
                                                  size_t      const _BufferCount,
                          char const* const _Format,
        ...)
    

#line 1873 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1882 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snprintf_l(
          char*       const _Buffer,
                                                 size_t      const _BufferCount,
               char const* const _Format,
                                             _locale_t   const _Locale,
        ...)
    

#line 1894 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;

        _Result = _vsnprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1905 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    








#line 1916 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    
    __inline int __cdecl snprintf(
          char*       const _Buffer,
                                                      size_t      const _BufferCount,
                              char const* const _Format,
        ...)
    

#line 1927 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1936 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    
    __inline int __cdecl _snprintf(
          char*       const _Buffer,
                                                 size_t      const _BufferCount,
                         char const* const _Format,
        ...)
    

#line 1947 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1956 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) int __cdecl _snprintf( char *_Buffer, size_t _BufferCount, char const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) int __cdecl _vsnprintf( char *_Buffer, size_t _BufferCount, char const* _Format, va_list _Args);








    
    
    __inline int __cdecl _snprintf_c_l(
                  char*       const _Buffer,
                                            size_t      const _BufferCount,
          char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 1977 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1986 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    
    __inline int __cdecl _snprintf_c(
         char*       const _Buffer,
                                   size_t      const _BufferCount,
           char const* const _Format,
        ...)
    

#line 1997 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2006 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    
    __inline int __cdecl _snprintf_s_l(
          char*       const _Buffer,
                                                      size_t      const _BufferCount,
                                                      size_t      const _MaxCount,
                    char const* const _Format,
                                                  _locale_t   const _Locale,
        ...)
    

#line 2019 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2028 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    
    __inline int __cdecl _snprintf_s(
          char*       const _Buffer,
                                                      size_t      const _BufferCount,
                                                      size_t      const _MaxCount,
                              char const* const _Format,
        ...)
    

#line 2040 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2049 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    extern "C++" { template <size_t _Size> inline int __cdecl _snprintf_s(char (&_Buffer)[_Size], size_t _BufferCount, char const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return _vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }







    
    __inline int __cdecl _scprintf_l(
          char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 2066 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vscprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2075 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _scprintf(
          char const* const _Format,
        ...)
    

#line 2083 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vscprintf_l(_Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2092 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _scprintf_p_l(
          char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 2101 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vscprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2110 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _scprintf_p(
          char const* const _Format,
        ...)
    

#line 2118 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vscprintf_p(_Format, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2127 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    
    
    
    
    __declspec(dllimport) int __cdecl __stdio_common_vsscanf(
                                           unsigned __int64 _Options,
                char const*      _Buffer,
                                           size_t           _BufferCount,
          char const*      _Format,
                                       _locale_t        _Locale,
                                               va_list          _ArgList
        );

    
    __inline int __cdecl _vsscanf_l(
                                char const* const _Buffer,
          char const* const _Format,
                              _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 2152 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) ,
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 2158 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vsscanf(
                                char const* const _Buffer,
          char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 2168 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return _vsscanf_l(_Buffer, _Format, 0 , _ArgList);
    }
    #line 2172 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vsscanf_s_l(
                                char const* const _Buffer,
          char const* const _Format,
                              _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 2183 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0) ,
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 2189 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    

        #pragma warning(push)
        #pragma warning(disable: 6530) 

        
        __inline int __cdecl vsscanf_s(
                                    char const* const _Buffer,
              char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 2204 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
        {
            return _vsscanf_s_l(_Buffer, _Format, 0 , _ArgList);
        }
    #line 2208 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

        extern "C++" { template <size_t _Size> inline int __cdecl vsscanf_s(char const (&_Buffer)[_Size], char const* _Format, va_list _ArgList) throw() { return vsscanf_s(_Buffer, _Size, _Format, _ArgList); } }






        #pragma warning(pop)

    #line 2219 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_sscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _sscanf_l(
                                         char const* const _Buffer,
          char const* const _Format,
                                       _locale_t   const _Locale,
        ...)
    

#line 2229 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vsscanf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2238 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "sscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl sscanf(
                               char const* const _Buffer,
          char const* const _Format,
        ...)
    

#line 2247 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vsscanf_l(_Buffer, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2256 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _sscanf_s_l(
                                           char const* const _Buffer,
          char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 2266 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vsscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2275 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl sscanf_s(
                                     char const* const _Buffer,
              char const* const _Format,
            ...)
    

#line 2286 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;

            _Result = vsscanf_s(_Buffer, _Format, _ArgList);

            ((void)(_ArgList = (va_list)0)) ;
            return _Result;
        }
    #line 2297 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    #line 2299 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    #pragma warning(push)
    #pragma warning(disable: 6530) 

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snscanf_l(
          char const* const _Buffer,
                                           size_t      const _BufferCount,
          char const* const _Format,
                                       _locale_t   const _Locale,
        ...)
    

#line 2313 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) ,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2326 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snscanf(
          char const* const _Buffer,
                                           size_t      const _BufferCount,
                    char const* const _Format,
        ...)
    

#line 2336 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) ,
            _Buffer, _BufferCount, _Format, 0 , _ArgList);

        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2349 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"


    
    __inline int __cdecl _snscanf_s_l(
            char const* const _Buffer,
                                             size_t      const _BufferCount,
          char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 2361 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0) ,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2374 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _snscanf_s(
          char const* const _Buffer,
                                           size_t      const _BufferCount,
                  char const* const _Format,
        ...)
    

#line 2384 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0) ,
            _Buffer, _BufferCount, _Format, 0 , _ArgList);

        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2397 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

    #pragma warning(pop)

    

#line 2403 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"



    
    
    
    
    
    

        

        


#line 2419 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_tempnam" ". See online help for details."))
        __declspec(dllimport) char* __cdecl tempnam(
             char const* _Directory,
             char const* _FilePrefix
            );

        

#line 2429 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"

         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fcloseall" ". See online help for details.")) __declspec(dllimport) int   __cdecl fcloseall(void);
             __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fdopen" ". See online help for details."))    __declspec(dllimport) FILE* __cdecl fdopen( int _FileHandle,  char const* _Format);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fgetchar" ". See online help for details."))  __declspec(dllimport) int   __cdecl fgetchar(void);
             __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fileno" ". See online help for details."))    __declspec(dllimport) int   __cdecl fileno( FILE* _Stream);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_flushall" ". See online help for details."))  __declspec(dllimport) int   __cdecl flushall(void);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fputchar" ". See online help for details."))  __declspec(dllimport) int   __cdecl fputchar( int _Ch);
             __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_getw" ". See online help for details."))      __declspec(dllimport) int   __cdecl getw( FILE* _Stream);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_putw" ". See online help for details."))      __declspec(dllimport) int   __cdecl putw( int _Ch,  FILE* _Stream);
             __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_rmtmp" ". See online help for details."))     __declspec(dllimport) int   __cdecl rmtmp(void);

    #line 2441 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
#line 2442 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#line 2449 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\stdio.h"
#pragma external_header(pop)
#line 13 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cstdio"

#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )
















namespace std {
#pragma warning(push)
#pragma warning(disable : 4995) 

using :: _Mbstatet;

 using :: size_t;
 using :: fpos_t;
 using :: FILE;
 using :: clearerr;
 using :: fclose;
 using :: feof;
 using :: ferror;
 using :: fflush;
 using :: fgetc;
 using :: fgetpos;
 using :: fgets;
 using :: fopen;
 using :: fprintf;
 using :: fputc;
 using :: fputs;
 using :: fread;
 using :: freopen;
 using :: fscanf;
 using :: fseek;
 using :: fsetpos;
 using :: ftell;
 using :: fwrite;
 using :: getc;
 using :: getchar;
 using :: perror;
 using :: putc;
 using :: putchar;
 using :: printf;
 using :: puts;
 using :: remove;
 using :: rename;
 using :: rewind;
 using :: scanf;
 using :: setbuf;
 using :: setvbuf;
 using :: sprintf;
 using :: sscanf;
 using :: tmpfile;
 using :: tmpnam;
 using :: ungetc;
 using :: vfprintf;
 using :: vprintf;
 using :: vsprintf;

 using :: snprintf;
 using :: vsnprintf;
 using :: vfscanf;
 using :: vscanf;
 using :: vsscanf;

#pragma warning(pop)
}



#pragma warning(pop)
#pragma pack(pop)

#line 98 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cstdio"
#line 99 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cstdio"
#pragma external_header(pop)
#line 13 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cwchar"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\wchar.h"









#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_memcpy_s.h"







#pragma once


#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\errno.h"







#pragma once





#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {




    __declspec(dllimport) int* __cdecl _errno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_errno( int _Value);
    __declspec(dllimport) errno_t __cdecl _get_errno( int* _Value);

    __declspec(dllimport) unsigned long* __cdecl __doserrno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_doserrno( unsigned long _Value);
    __declspec(dllimport) errno_t __cdecl _get_doserrno( unsigned long * _Value);
#line 35 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\errno.h"










































    
    
    
    
    
#line 83 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\errno.h"






    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
#line 131 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\errno.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#line 138 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\errno.h"
#pragma external_header(pop)
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_memcpy_s.h"
#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime_string.h"







#pragma once



#pragma warning(push)
#pragma warning(disable: 4514 4820 )



__pragma(pack(push, 8)) extern "C" {



[[nodiscard]] 
 void const * __cdecl memchr(
     void const* _Buf,
                                int         _Val,
                                size_t      _MaxCount
    );

[[nodiscard]] 
int __cdecl memcmp(
     void const* _Buf1,
     void const* _Buf2,
                        size_t      _Size
    );









void* __cdecl memcpy(
     void* _Dst,
           void const* _Src,
                              size_t      _Size
    );


 void* __cdecl memmove(
     void*       _Dst,
           void const* _Src,
                                  size_t      _Size
    );








void* __cdecl memset(
     void*  _Dst,
                              int    _Val,
                              size_t _Size
    );

[[nodiscard]] 
 char const * __cdecl strchr(
     char const* _Str,
       int         _Val
    );

[[nodiscard]] 
 char const * __cdecl strrchr(
     char const* _Str,
       int         _Ch
    );

[[nodiscard]]  
 char const * __cdecl strstr(
     char const* _Str,
     char const* _SubStr
    );

[[nodiscard]] 

 wchar_t const * __cdecl wcschr(
     wchar_t const* _Str,
       wchar_t        _Ch
    );

[[nodiscard]] 
 wchar_t const * __cdecl wcsrchr(
     wchar_t const* _Str,
       wchar_t        _Ch
    );

[[nodiscard]]  

 wchar_t const * __cdecl wcsstr(
     wchar_t const* _Str,
     wchar_t const* _SubStr
    );



} __pragma(pack(pop))

#line 112 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\vcruntime_string.h"

#pragma warning(pop) 
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_memcpy_s.h"

#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {


    
#line 23 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_memcpy_s.h"














    
    
    static __inline errno_t __cdecl memcpy_s(
         void*       const _Destination,
                                                             rsize_t     const _DestinationSize,
                                void const* const _Source,
                                                             rsize_t     const _SourceSize
        )
    {
        if (_SourceSize == 0)
        {
            return 0;
        }

        { int _Expr_val=!!(_Destination != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } } ;
        if (_Source == 0 || _DestinationSize < _SourceSize)
        {
            memset(_Destination, 0, _DestinationSize);

            { int _Expr_val=!!(_Source != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } } ;
            { int _Expr_val=!!(_DestinationSize >= _SourceSize); if (!(_Expr_val)) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; } } ;

            
            return 22 ;
        }
        memcpy(_Destination, _Source, _SourceSize);
        return 0;
    }

    
    static __inline errno_t __cdecl memmove_s(
         void*       const _Destination,
                                                             rsize_t     const _DestinationSize,
                                void const* const _Source,
                                                             rsize_t     const _SourceSize
        )
    {
        if (_SourceSize == 0)
        {
            return 0;
        }

        { int _Expr_val=!!(_Destination != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } } ;
        { int _Expr_val=!!(_Source != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } } ;
        { int _Expr_val=!!(_DestinationSize >= _SourceSize); if (!(_Expr_val)) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; } } ;

        memmove(_Destination, _Source, _SourceSize);
        return 0;
    }

#line 88 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_memcpy_s.h"




#pragma warning(pop) 
} __pragma(pack(pop))
#pragma external_header(pop)
#line 16 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\wchar.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"








#pragma once




#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {







    
    
    __declspec(dllimport) errno_t __cdecl _cgetws_s(
         wchar_t* _Buffer,
                                              size_t   _BufferCount,
                                             size_t*  _SizeRead
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _cgetws_s(wchar_t (&_Buffer)[_Size], size_t* _SizeRead) throw() { return _cgetws_s(_Buffer, _Size, _SizeRead); } }






    
    __declspec(dllimport) int __cdecl _cputws(
         wchar_t const* _Buffer
        );

         __declspec(dllimport) wint_t __cdecl _getwch  (void);
         __declspec(dllimport) wint_t __cdecl _getwche (void);
     __declspec(dllimport) wint_t __cdecl _putwch  ( wchar_t _Character);
     __declspec(dllimport) wint_t __cdecl _ungetwch( wint_t  _Character);

         __declspec(dllimport) wint_t __cdecl _getwch_nolock  (void);
         __declspec(dllimport) wint_t __cdecl _getwche_nolock (void);
     __declspec(dllimport) wint_t __cdecl _putwch_nolock  ( wchar_t _Character);
     __declspec(dllimport) wint_t __cdecl _ungetwch_nolock( wint_t  _Character);



    
    
    
    
    
    
    __declspec(dllimport) int __cdecl __conio_common_vcwprintf(
                                            unsigned __int64 _Options,
          wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __conio_common_vcwprintf_s(
                                            unsigned __int64 _Options,
          wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __conio_common_vcwprintf_p(
                                            unsigned __int64 _Options,
          wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __inline int __cdecl _vcwprintf_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                                va_list              _ArgList
        )


#line 96 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwprintf((*__local_stdio_printf_options()) , _Format, _Locale, _ArgList);
    }
#line 100 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf(
          wchar_t const* const _Format,
                                      va_list              _ArgList
        )


#line 109 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwprintf_l(_Format, 0 , _ArgList);
    }
#line 113 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_s_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                                va_list              _ArgList
        )


#line 123 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwprintf_s((*__local_stdio_printf_options()) , _Format, _Locale, _ArgList);
    }
#line 127 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_s(
          wchar_t const* const _Format,
                                      va_list              _ArgList
        )


#line 136 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwprintf_s_l(_Format, 0 , _ArgList);
    }
#line 140 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_p_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                                va_list              _ArgList
        )


#line 150 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwprintf_p((*__local_stdio_printf_options()) , _Format, _Locale, _ArgList);
    }
#line 154 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_p(
          const wchar_t* const _Format,
                                      va_list              _ArgList
        )


#line 163 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwprintf_p_l(_Format, 0 , _ArgList);
    }
#line 167 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)


#line 176 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vcwprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
#line 185 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf(
          wchar_t const* const _Format,
        ...)


#line 193 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vcwprintf_l(_Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
#line 202 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_s_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)


#line 211 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vcwprintf_s_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
#line 220 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_s(
          wchar_t const* const _Format,
        ...)


#line 228 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vcwprintf_s_l(_Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
#line 237 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_p_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)


#line 246 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vcwprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
#line 255 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_p(
          wchar_t const* const _Format,
        ...)


#line 263 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vcwprintf_p_l(_Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
#line 272 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"



    
    
    
    
    
    
    __declspec(dllimport) int __cdecl __conio_common_vcwscanf(
                                           unsigned __int64 _Options,
          wchar_t const*   _Format,
                                       _locale_t        _Locale,
                                               va_list          _ArgList
        );

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vcwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vcwscanf_l(
          wchar_t const* const _Format,
                                       _locale_t      const _Locale,
                                               va_list              _ArgList
        )


#line 297 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwscanf(
            (*__local_stdio_scanf_options ()) ,
            _Format, _Locale, _ArgList);
    }
#line 303 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vcwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vcwscanf(
          wchar_t const* const _Format,
                                               va_list              _ArgList
        )


#line 312 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwscanf_l(_Format, 0 , _ArgList);
    }
#line 316 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwscanf_s_l(
          wchar_t const* const _Format,
                                       _locale_t      const _Locale,
                                               va_list              _ArgList
        )


#line 326 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0) ,
            _Format, _Locale, _ArgList);
    }
#line 332 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwscanf_s(
          wchar_t const* const _Format,
                                               va_list              _ArgList
        )


#line 341 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwscanf_s_l(_Format, 0 , _ArgList);
    }
#line 345 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_cwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _cwscanf_l(
          wchar_t const* const _Format,
                                       _locale_t      const _Locale,
        ...)


#line 354 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;

        _Result = _vcwscanf_l(_Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
#line 365 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_cwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _cwscanf(
          wchar_t const* const _Format,
        ...)


#line 373 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;

        _Result = _vcwscanf_l(_Format, 0 , _ArgList);

        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
#line 384 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwscanf_s_l(
          wchar_t const* const _Format,
                                       _locale_t      const _Locale,
        ...)


#line 393 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vcwscanf_s_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
#line 402 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwscanf_s(
          wchar_t const* const _Format,
        ...)


#line 410 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vcwscanf_s_l(_Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
#line 419 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"

#line 421 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wconio.h"

} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 17 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\wchar.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wctype.h"








#pragma once



#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {











    

#line 32 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wctype.h"
        
    #line 34 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wctype.h"

    __declspec(dllimport) const unsigned short* __cdecl __pctype_func(void);
    __declspec(dllimport) const wctype_t*       __cdecl __pwctype_func(void);

    



        
        
    #line 45 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wctype.h"
#line 46 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wctype.h"





















 __declspec(dllimport) int __cdecl iswalnum  ( wint_t _C);
 __declspec(dllimport) int __cdecl iswalpha  ( wint_t _C);
 __declspec(dllimport) int __cdecl iswascii  ( wint_t _C);
 __declspec(dllimport) int __cdecl iswblank  ( wint_t _C);
 __declspec(dllimport) int __cdecl iswcntrl  ( wint_t _C);


 __declspec(dllimport) int __cdecl iswdigit  ( wint_t _C);

 __declspec(dllimport) int __cdecl iswgraph  ( wint_t _C);
 __declspec(dllimport) int __cdecl iswlower  ( wint_t _C);
 __declspec(dllimport) int __cdecl iswprint  ( wint_t _C);
 __declspec(dllimport) int __cdecl iswpunct  ( wint_t _C);
 __declspec(dllimport) int __cdecl iswspace  ( wint_t _C);
 __declspec(dllimport) int __cdecl iswupper  ( wint_t _C);
 __declspec(dllimport) int __cdecl iswxdigit ( wint_t _C);
 __declspec(dllimport) int __cdecl __iswcsymf( wint_t _C);
 __declspec(dllimport) int __cdecl __iswcsym ( wint_t _C);

 __declspec(dllimport) int __cdecl _iswalnum_l ( wint_t _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl _iswalpha_l ( wint_t _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl _iswblank_l ( wint_t _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl _iswcntrl_l ( wint_t _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl _iswdigit_l ( wint_t _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl _iswgraph_l ( wint_t _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl _iswlower_l ( wint_t _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl _iswprint_l ( wint_t _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl _iswpunct_l ( wint_t _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl _iswspace_l ( wint_t _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl _iswupper_l ( wint_t _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl _iswxdigit_l( wint_t _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl _iswcsymf_l ( wint_t _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl _iswcsym_l  ( wint_t _C,  _locale_t _Locale);


 __declspec(dllimport) wint_t __cdecl towupper( wint_t _C);
 __declspec(dllimport) wint_t __cdecl towlower( wint_t _C);
 __declspec(dllimport) int    __cdecl iswctype( wint_t _C,  wctype_t _Type);

 __declspec(dllimport) wint_t __cdecl _towupper_l( wint_t _C,  _locale_t _Locale);
 __declspec(dllimport) wint_t __cdecl _towlower_l( wint_t _C,  _locale_t _Locale);
 __declspec(dllimport) int    __cdecl _iswctype_l( wint_t _C,  wctype_t _Type,  _locale_t _Locale);



     __declspec(dllimport) int __cdecl isleadbyte( int _C);
     __declspec(dllimport) int __cdecl _isleadbyte_l( int _C,  _locale_t _Locale);

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "iswctype" " " "instead. See online help for details.")) __declspec(dllimport) int __cdecl is_wctype( wint_t _C,  wctype_t _Type);
#line 117 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wctype.h"


















































































#line 200 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wctype.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 18 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\wchar.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wdirect.h"








#pragma once



#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {







 
__declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wgetcwd(
     wchar_t* _DstBuf,
                                 int      _SizeInWords
    );


 
__declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wgetdcwd(
                                 int      _Drive,
     wchar_t* _DstBuf,
                                 int      _SizeInWords
    );







__declspec(dllimport) int __cdecl _wchdir(
     wchar_t const* _Path
    );


__declspec(dllimport) int __cdecl _wmkdir(
     wchar_t const* _Path
    );


__declspec(dllimport) int __cdecl _wrmdir(
     wchar_t const* _Path
    );



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 19 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\wchar.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wio.h"








#pragma once


#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_share.h"








#pragma once



#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )











    
    
    
    
#line 31 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_share.h"


#pragma warning(pop) 
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wio.h"

#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {










    
    
#line 32 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wio.h"

typedef unsigned long _fsize_t;

struct _wfinddata32_t
{
    unsigned   attrib;
    __time32_t time_create;    
    __time32_t time_access;    
    __time32_t time_write;
    _fsize_t   size;
    wchar_t    name[260];
};

struct _wfinddata32i64_t
{
    unsigned   attrib;
    __time32_t time_create;    
    __time32_t time_access;    
    __time32_t time_write;
    __int64    size;
    wchar_t    name[260];
};

struct _wfinddata64i32_t
{
    unsigned   attrib;
    __time64_t time_create;    
    __time64_t time_access;    
    __time64_t time_write;
    _fsize_t   size;
    wchar_t    name[260];
};

struct _wfinddata64_t
{
    unsigned   attrib;
    __time64_t time_create;    
    __time64_t time_access;    
    __time64_t time_write;
    __int64    size;
    wchar_t    name[260];
};














    
    
    
    
#line 93 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wio.h"


__declspec(dllimport) int __cdecl _waccess(
     wchar_t const* _FileName,
       int            _AccessMode
    );


__declspec(dllimport) errno_t __cdecl _waccess_s(
     wchar_t const* _FileName,
       int            _AccessMode
    );


__declspec(dllimport) int __cdecl _wchmod(
     wchar_t const* _FileName,
       int            _Mode
    );

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) int __cdecl _wcreat(
     wchar_t const* _FileName,
       int            _PermissionMode
    );



__declspec(dllimport) intptr_t __cdecl _wfindfirst32(
     wchar_t const*         _FileName,
      struct _wfinddata32_t* _FindData
    );



__declspec(dllimport) int __cdecl _wfindnext32(
      intptr_t               _FindHandle,
     struct _wfinddata32_t* _FindData
    );

__declspec(dllimport) int __cdecl _wunlink(
     wchar_t const* _FileName
    );


__declspec(dllimport) int __cdecl _wrename(
     wchar_t const* _OldFileName,
     wchar_t const* _NewFileName
    );

__declspec(dllimport) errno_t __cdecl _wmktemp_s(
     wchar_t* _TemplateName,
                                size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmktemp_s(wchar_t (&_TemplateName)[_Size]) throw() { return _wmktemp_s(_TemplateName, _Size); } }





__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wmktemp_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wmktemp( wchar_t *_TemplateName);






__declspec(dllimport) intptr_t __cdecl _wfindfirst32i64(
     wchar_t const*            _FileName,
      struct _wfinddata32i64_t* _FindData
    );



__declspec(dllimport) intptr_t __cdecl _wfindfirst64i32(
     wchar_t const*            _FileName,
      struct _wfinddata64i32_t* _FindData
    );



__declspec(dllimport) intptr_t __cdecl _wfindfirst64(
     wchar_t const*         _FileName,
      struct _wfinddata64_t* _FindData
    );



__declspec(dllimport) int __cdecl _wfindnext32i64(
      intptr_t                  _FindHandle,
     struct _wfinddata32i64_t* _FindData
    );



__declspec(dllimport) int __cdecl _wfindnext64i32(
      intptr_t                  _FindHandle,
     struct _wfinddata64i32_t* _FindData
    );



__declspec(dllimport) int __cdecl _wfindnext64(
      intptr_t               _FindHandle,
     struct _wfinddata64_t* _FindData
    );


__declspec(dllimport) errno_t __cdecl _wsopen_s(
      int*           _FileHandle,
     wchar_t const* _FileName,
       int            _OpenFlag,
       int            _ShareFlag,
       int            _PermissionFlag
    );

__declspec(dllimport) errno_t __cdecl _wsopen_dispatch(
     wchar_t const* _FileName,
       int            _OFlag,
       int            _ShFlag,
       int            _PMode,
      int*           _PFileHandle,
       int            _BSecure
    );





    
    extern "C++"  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    inline int __cdecl _wopen(
         wchar_t const* _FileName,
           int            _OFlag,
           int            _PMode = 0
        )
    {
        int _FileHandle;
        
        errno_t const _Result = _wsopen_dispatch(_FileName, _OFlag, 0x40 , _PMode, &_FileHandle, 0);
        return _Result ? -1 : _FileHandle;
    }

    extern "C++"  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    inline int __cdecl _wsopen(
         wchar_t const* _FileName,
           int            _OFlag,
           int            _ShFlag,
           int            _PMode = 0
        )
    {
        int _FileHandle;
        
        errno_t const _Result = _wsopen_dispatch(_FileName, _OFlag, _ShFlag, _PMode, &_FileHandle, 0);
        return _Result ? -1 : _FileHandle;
    }

















#line 267 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wio.h"

} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 20 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\wchar.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wprocess.h"








#pragma once



#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {




    

        __declspec(dllimport) intptr_t __cdecl _wexecl(
             wchar_t const* _FileName,
             wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wexecle(
             wchar_t const* _FileName,
             wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wexeclp(
             wchar_t const* _FileName,
             wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wexeclpe(
             wchar_t const* _FileName,
             wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wexecv(
             wchar_t const*        _FileName,
             wchar_t const* const* _ArgList
            );

        __declspec(dllimport) intptr_t __cdecl _wexecve(
                 wchar_t const*        _FileName,
                 wchar_t const* const* _ArgList,
             wchar_t const* const* _Env
            );

        __declspec(dllimport) intptr_t __cdecl _wexecvp(
             wchar_t const*        _FileName,
             wchar_t const* const* _ArgList
            );

        __declspec(dllimport) intptr_t __cdecl _wexecvpe(
                 wchar_t const*        _FileName,
                 wchar_t const* const* _ArgList,
             wchar_t const* const* _Env
            );

        __declspec(dllimport) intptr_t __cdecl _wspawnl(
               int            _Mode,
             wchar_t const* _FileName,
             wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wspawnle(
               int            _Mode,
             wchar_t const* _FileName,
             wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wspawnlp(
               int            _Mode,
             wchar_t const* _FileName,
             wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wspawnlpe(
               int            _Mode,
             wchar_t const* _FileName,
             wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wspawnv(
               int                   _Mode,
             wchar_t const*        _FileName,
             wchar_t const* const* _ArgList
            );

        __declspec(dllimport) intptr_t __cdecl _wspawnve(
                   int                   _Mode,
                 wchar_t const*        _FileName,
                 wchar_t const* const* _ArgList,
             wchar_t const* const* _Env
            );

        __declspec(dllimport) intptr_t __cdecl _wspawnvp(
               int                   _Mode,
             wchar_t const*        _FileName,
             wchar_t const* const* _ArgList
            );

        __declspec(dllimport) intptr_t __cdecl _wspawnvpe(
                   int                   _Mode,
                 wchar_t const*        _FileName,
                 wchar_t const* const* _ArgList,
             wchar_t const* const* _Env
            );

        __declspec(dllimport) int __cdecl _wsystem(
             wchar_t const* _Command
            );

    #line 121 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wprocess.h"
#line 122 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wprocess.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 21 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\wchar.h"


#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstring.h"








#pragma once




#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )




__pragma(pack(push, 8)) extern "C" {










    
    __declspec(dllimport) errno_t __cdecl wcscat_s(
         wchar_t* _Destination,
         rsize_t _SizeInWords,
         wchar_t const* _Source
        );

    
    __declspec(dllimport) errno_t __cdecl wcscpy_s(
         wchar_t* _Destination,
         rsize_t _SizeInWords,
         wchar_t const* _Source
        );

    
    __declspec(dllimport) errno_t __cdecl wcsncat_s(
         wchar_t*       _Destination,
                                    rsize_t        _SizeInWords,
              wchar_t const* _Source,
                                    rsize_t        _MaxCount
        );

    
    __declspec(dllimport) errno_t __cdecl wcsncpy_s(
         wchar_t*       _Destination,
                                 rsize_t        _SizeInWords,
           wchar_t const* _Source,
                                 rsize_t        _MaxCount
        );

    
    __declspec(dllimport) wchar_t* __cdecl wcstok_s(
                         wchar_t*       _String,
                                wchar_t const* _Delimiter,
          wchar_t**      _Context
        );

#line 69 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstring.h"











#line 81 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstring.h"


__declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wcsdup(
     wchar_t const* _String
    );



#line 90 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstring.h"



extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscat_s(wchar_t (&_Destination)[_Size], wchar_t const* _Source) throw() { return wcscat_s(_Destination, _Size, _Source); } }






    __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcscat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcscat( wchar_t *_Destination, wchar_t const* _Source);




#line 106 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstring.h"


__declspec(dllimport) int __cdecl wcscmp(
     wchar_t const* _String1,
     wchar_t const* _String2
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscpy_s(wchar_t (&_Destination)[_Size], wchar_t const* _Source) throw() { return wcscpy_s(_Destination, _Size, _Source); } }





__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcscpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcscpy( wchar_t *_Destination, wchar_t const* _Source);






__declspec(dllimport) size_t __cdecl wcscspn(
     wchar_t const* _String,
     wchar_t const* _Control
    );


__declspec(dllimport) size_t __cdecl wcslen(
     wchar_t const* _String
    );










__declspec(dllimport) size_t __cdecl wcsnlen(
     wchar_t const* _Source,
                           size_t         _MaxCount
    );



    
    



    



    static __inline size_t __cdecl wcsnlen_s(
         wchar_t const* _Source,
                               size_t         _MaxCount
        )
    {
        return (_Source == 0) ? 0 : wcsnlen(_Source, _MaxCount);
    }

#line 170 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstring.h"

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncat_s(wchar_t (&_Destination)[_Size], wchar_t const* _Source, size_t _Count) throw() { return wcsncat_s(_Destination, _Size, _Source, _Count); } }






__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsncat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcsncat( wchar_t *_Destination, wchar_t const* _Source, size_t _Count);








__declspec(dllimport) int __cdecl wcsncmp(
     wchar_t const* _String1,
     wchar_t const* _String2,
                           size_t         _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncpy_s(wchar_t (&_Destination)[_Size], wchar_t const* _Source, size_t _Count) throw() { return wcsncpy_s(_Destination, _Size, _Source, _Count); } }






__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsncpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcsncpy( wchar_t *_Destination, wchar_t const* _Source, size_t _Count);








__declspec(dllimport) wchar_t const * __cdecl wcspbrk(
     wchar_t const* _String,
     wchar_t const* _Control
    );


__declspec(dllimport) size_t __cdecl wcsspn(
     wchar_t const* _String,
     wchar_t const* _Control
    );

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl wcstok(
                         wchar_t*       _String,
                                wchar_t const* _Delimiter,
      wchar_t**      _Context
    );



    

#line 232 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstring.h"
        



    #line 237 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstring.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    static __inline wchar_t* __cdecl _wcstok(
         wchar_t*       const _String,
                wchar_t const* const _Delimiter
        )
    {
        return wcstok(_String, _Delimiter, 0);
    }

    

#line 250 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstring.h"

    
        extern "C++"  __declspec(deprecated("wcstok has been changed to conform with the ISO C standard, " "adding an extra context parameter. To use the legacy Microsoft " "wcstok, define _CRT_NON_CONFORMING_WCSTOK."))
        inline wchar_t* __cdecl wcstok(
             wchar_t*       _String,
                    wchar_t const* _Delimiter
            ) throw()
        {
            return wcstok(_String, _Delimiter, 0);
        }
    #line 261 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstring.h"

#line 263 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstring.h"




 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcserror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl _wcserror(
     int _ErrorNumber
    );


__declspec(dllimport) errno_t __cdecl _wcserror_s(
     wchar_t* _Buffer,
                                 size_t   _SizeInWords,
                                 int      _ErrorNumber
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcserror_s(wchar_t (&_Buffer)[_Size], int _Error) throw() { return _wcserror_s(_Buffer, _Size, _Error); } }







 __declspec(deprecated("This function or variable may be unsafe. Consider using " "__wcserror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl __wcserror(
     wchar_t const* _String
    );

 __declspec(dllimport) errno_t __cdecl __wcserror_s(
     wchar_t*       _Buffer,
                                 size_t         _SizeInWords,
                               wchar_t const* _ErrorMessage
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl __wcserror_s(wchar_t (&_Buffer)[_Size], wchar_t const* _ErrorMessage) throw() { return __wcserror_s(_Buffer, _Size, _ErrorMessage); } }





 __declspec(dllimport) int __cdecl _wcsicmp(
     wchar_t const* _String1,
     wchar_t const* _String2
    );

 __declspec(dllimport) int __cdecl _wcsicmp_l(
       wchar_t const* _String1,
       wchar_t const* _String2,
     _locale_t      _Locale
    );

 __declspec(dllimport) int __cdecl _wcsnicmp(
     wchar_t const* _String1,
     wchar_t const* _String2,
                           size_t         _MaxCount
    );

 __declspec(dllimport) int __cdecl _wcsnicmp_l(
     wchar_t const* _String1,
     wchar_t const* _String2,
                           size_t         _MaxCount,
                       _locale_t      _Locale
    );

 __declspec(dllimport) errno_t __cdecl _wcsnset_s(
     wchar_t* _Destination,
                                size_t   _SizeInWords,
                                wchar_t  _Value,
                                size_t   _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsnset_s(wchar_t (&_Destination)[_Size], wchar_t _Value, size_t _MaxCount) throw() { return _wcsnset_s(_Destination, _Size, _Value, _MaxCount); } }






__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsnset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcsnset( wchar_t *_String, wchar_t _Value, size_t _MaxCount);







__declspec(dllimport) wchar_t* __cdecl _wcsrev(
     wchar_t* _String
    );

 __declspec(dllimport) errno_t __cdecl _wcsset_s(
     wchar_t* _Destination,
                                size_t   _SizeInWords,
                                wchar_t  _Value
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsset_s(wchar_t (&_String)[_Size], wchar_t _Value) throw() { return _wcsset_s(_String, _Size, _Value); } }





__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcsset( wchar_t *_String, wchar_t _Value);






 __declspec(dllimport) errno_t __cdecl _wcslwr_s(
     wchar_t* _String,
                                size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s(wchar_t (&_String)[_Size]) throw() { return _wcslwr_s(_String, _Size); } }




__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcslwr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcslwr( wchar_t *_String);





__declspec(dllimport) errno_t __cdecl _wcslwr_s_l(
     wchar_t*  _String,
                                size_t    _SizeInWords,
                            _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s_l(wchar_t (&_String)[_Size], _locale_t _Locale) throw() { return _wcslwr_s_l(_String, _Size, _Locale); } }





__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcslwr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcslwr_l( wchar_t *_String, _locale_t _Locale);







__declspec(dllimport) errno_t __cdecl _wcsupr_s(
     wchar_t* _String,
                         size_t   _Size
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s(wchar_t (&_String)[_Size]) throw() { return _wcsupr_s(_String, _Size); } }




__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsupr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcsupr( wchar_t *_String);





__declspec(dllimport) errno_t __cdecl _wcsupr_s_l(
     wchar_t*  _String,
                         size_t    _Size,
                     _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s_l(wchar_t (&_String)[_Size], _locale_t _Locale) throw() { return _wcsupr_s_l(_String, _Size, _Locale); } }





__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsupr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcsupr_l( wchar_t *_String, _locale_t _Locale);








__declspec(dllimport) size_t __cdecl wcsxfrm(
      wchar_t*       _Destination,
                                        wchar_t const* _Source,
              size_t         _MaxCount
    );



__declspec(dllimport) size_t __cdecl _wcsxfrm_l(
      wchar_t*       _Destination,
                                        wchar_t const* _Source,
              size_t         _MaxCount,
                                      _locale_t      _Locale
    );


__declspec(dllimport) int __cdecl wcscoll(
     wchar_t const* _String1,
     wchar_t const* _String2
    );


__declspec(dllimport) int __cdecl _wcscoll_l(
       wchar_t const* _String1,
       wchar_t const* _String2,
     _locale_t      _Locale
    );


__declspec(dllimport) int __cdecl _wcsicoll(
     wchar_t const* _String1,
     wchar_t const* _String2
    );


__declspec(dllimport) int __cdecl _wcsicoll_l(
       wchar_t const* _String1,
       wchar_t const* _String2,
     _locale_t      _Locale
    );


__declspec(dllimport) int __cdecl _wcsncoll(
     wchar_t const* _String1,
     wchar_t const* _String2,
                           size_t         _MaxCount
    );


__declspec(dllimport) int __cdecl _wcsncoll_l(
     wchar_t const* _String1,
     wchar_t const* _String2,
                           size_t         _MaxCount,
                       _locale_t      _Locale
    );


__declspec(dllimport) int __cdecl _wcsnicoll(
     wchar_t const* _String1,
     wchar_t const* _String2,
                           size_t         _MaxCount
    );


__declspec(dllimport) int __cdecl _wcsnicoll_l(
     wchar_t const* _String1,
     wchar_t const* _String2,
                           size_t         _MaxCount,
                       _locale_t      _Locale
    );









extern "C++" {

    
    
    inline wchar_t* __cdecl wcschr( wchar_t* _String, wchar_t _C)
    {
        return const_cast<wchar_t*>(wcschr(static_cast<wchar_t const*>(_String), _C));
    }

    
    inline wchar_t* __cdecl wcspbrk( wchar_t* _String,  wchar_t const* _Control)
    {
        return const_cast<wchar_t*>(wcspbrk(static_cast<wchar_t const*>(_String), _Control));
    }

    
    inline wchar_t* __cdecl wcsrchr( wchar_t* _String,  wchar_t _C)
    {
        return const_cast<wchar_t*>(wcsrchr(static_cast<wchar_t const*>(_String), _C));
    }

     
    
    inline wchar_t* __cdecl wcsstr( wchar_t* _String,  wchar_t const*_SubStr)
    {
        return const_cast<wchar_t*>(wcsstr(static_cast<wchar_t const*>(_String), _SubStr));
    }

}
#line 555 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstring.h"









    


#line 568 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstring.h"

     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsdup" ". See online help for details."))
    __declspec(dllimport) wchar_t* __cdecl wcsdup(
         wchar_t const* _String
        );

    

#line 577 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstring.h"

    
    

     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl wcsicmp(
         wchar_t const* _String1,
         wchar_t const* _String2
        );

     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsnicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl wcsnicmp(
         wchar_t const* _String1,
         wchar_t const* _String2,
                               size_t         _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsnset" ". See online help for details."))
    
    __declspec(dllimport) wchar_t* __cdecl wcsnset(
         wchar_t* _String,
                                 wchar_t  _Value,
                                 size_t   _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsrev" ". See online help for details."))
    
    __declspec(dllimport) wchar_t* __cdecl wcsrev(
         wchar_t* _String
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsset" ". See online help for details."))
    
    __declspec(dllimport) wchar_t* __cdecl wcsset(
         wchar_t* _String,
              wchar_t  _Value
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcslwr" ". See online help for details."))
    
    __declspec(dllimport) wchar_t* __cdecl wcslwr(
         wchar_t* _String
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsupr" ". See online help for details."))
    
    __declspec(dllimport) wchar_t* __cdecl wcsupr(
         wchar_t* _String
        );

     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsicoll" ". See online help for details."))
    __declspec(dllimport) int __cdecl wcsicoll(
         wchar_t const* _String1,
         wchar_t const* _String2
        );

#line 634 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstring.h"



} __pragma(pack(pop))

#line 640 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wstring.h"

#pragma warning(pop) 
#pragma external_header(pop)
#line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\wchar.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wtime.h"








#pragma once



#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {








struct tm
{
    int tm_sec;   
    int tm_min;   
    int tm_hour;  
    int tm_mday;  
    int tm_mon;   
    int tm_year;  
    int tm_wday;  
    int tm_yday;  
    int tm_isdst; 
};







 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wasctime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))


__declspec(dllimport) wchar_t* __cdecl _wasctime(
     struct tm const* _Tm
    );



__declspec(dllimport) errno_t __cdecl _wasctime_s(
      wchar_t*         _Buffer,
                                         size_t           _SizeInWords,
                                                      struct tm const* _Tm
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wasctime_s(wchar_t (&_Buffer)[_Size], struct tm const* _Time) throw() { return _wasctime_s(_Buffer, _Size, _Time); } }








__declspec(dllimport) size_t __cdecl wcsftime(
      wchar_t*         _Buffer,
                              size_t           _SizeInWords,
                            wchar_t const*   _Format,
                              struct tm const* _Tm
    );



__declspec(dllimport) size_t __cdecl _wcsftime_l(
      wchar_t*         _Buffer,
                              size_t           _SizeInWords,
                            wchar_t const*   _Format,
                              struct tm const* _Tm,
                          _locale_t        _Locale
    );


 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctime32_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl _wctime32(
     __time32_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _wctime32_s(
      wchar_t*          _Buffer,
                                    size_t            _SizeInWords,
                                                      __time32_t const* _Time
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime32_s(wchar_t (&_Buffer)[_Size], __time32_t const* _Time) throw() { return _wctime32_s(_Buffer, _Size, _Time); } }







 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctime64_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl _wctime64(
     __time64_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _wctime64_s(
      wchar_t*          _Buffer,
                                    size_t            _SizeInWords,
                                                      __time64_t const* _Time);

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime64_s(wchar_t (&_Buffer)[_Size], __time64_t const* _Time) throw() { return _wctime64_s(_Buffer, _Size, _Time); } }






__declspec(dllimport) errno_t __cdecl _wstrdate_s(
      wchar_t* _Buffer,
                                                                               size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrdate_s(wchar_t (&_Buffer)[_Size]) throw() { return _wstrdate_s(_Buffer, _Size); } }




__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wstrdate_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wstrdate( wchar_t *_Buffer);





__declspec(dllimport) errno_t __cdecl _wstrtime_s(
      wchar_t* _Buffer,
                                                                               size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrtime_s(wchar_t (&_Buffer)[_Size]) throw() { return _wstrtime_s(_Buffer, _Size); } }




__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wstrtime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wstrtime( wchar_t *_Buffer);












    




















        
        static __inline wchar_t * __cdecl _wctime(
             time_t const* const _Time)
        {
            return _wctime64(_Time);
        }

        
        static __inline errno_t __cdecl _wctime_s(
               wchar_t*      const _Buffer,
                                                            size_t        const _SizeInWords,
                                                            time_t const* const _Time
            )
        {
            return _wctime64_s(_Buffer, _SizeInWords, _Time);
        }

    #line 203 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wtime.h"
#line 204 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_wtime.h"

} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\wchar.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\sys\\stat.h"







#pragma once


#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\sys\\types.h"







#pragma once



#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )



    

    typedef unsigned short _ino_t; 

    
        typedef _ino_t ino_t;
    #line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\sys\\types.h"
#line 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\sys\\types.h"




    

    typedef unsigned int _dev_t; 

    
        typedef _dev_t dev_t;
    #line 36 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\sys\\types.h"
#line 37 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\sys\\types.h"




    

    typedef long _off_t; 

    
        typedef _off_t off_t;
    #line 48 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\sys\\types.h"
#line 49 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\sys\\types.h"


#pragma warning(pop) 
#pragma external_header(pop)
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\sys\\stat.h"

#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {






struct _stat32
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    _off_t         st_size;
    __time32_t     st_atime;
    __time32_t     st_mtime;
    __time32_t     st_ctime;
};

struct _stat32i64
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    __int64        st_size;
    __time32_t     st_atime;
    __time32_t     st_mtime;
    __time32_t     st_ctime;
};

struct _stat64i32
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    _off_t         st_size;
    __time64_t     st_atime;
    __time64_t     st_mtime;
    __time64_t     st_ctime;
};

struct _stat64
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    __int64        st_size;
    __time64_t     st_atime;
    __time64_t     st_mtime;
    __time64_t     st_ctime;
};




    struct stat
    {
        _dev_t         st_dev;
        _ino_t         st_ino;
        unsigned short st_mode;
        short          st_nlink;
        short          st_uid;
        short          st_gid;
        _dev_t         st_rdev;
        _off_t         st_size;
        time_t         st_atime;
        time_t         st_mtime;
        time_t         st_ctime;
    };
#line 102 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\sys\\stat.h"


















    
    
    
    
    
    
    
#line 128 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\sys\\stat.h"
















    
    
    
    
    
    
#line 151 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\sys\\stat.h"



__declspec(dllimport) int __cdecl _fstat32(
      int             _FileHandle,
     struct _stat32* _Stat
    );

__declspec(dllimport) int __cdecl _fstat32i64(
      int                _FileHandle,
     struct _stat32i64* _Stat
    );

__declspec(dllimport) int __cdecl _fstat64i32(
      int                _FileHandle,
     struct _stat64i32* _Stat
    );

__declspec(dllimport) int __cdecl _fstat64(
      int             _FileHandle,
     struct _stat64* _Stat
    );

__declspec(dllimport) int __cdecl _stat32(
     char const*     _FileName,
      struct _stat32* _Stat
    );

__declspec(dllimport) int __cdecl _stat32i64(
     char const*        _FileName,
      struct _stat32i64* _Stat
    );

__declspec(dllimport) int __cdecl _stat64i32(
     char const*        _FileName,
      struct _stat64i32* _Stat
    );

__declspec(dllimport) int __cdecl _stat64(
     char const*     _FileName,
      struct _stat64* _Stat
    );

__declspec(dllimport) int __cdecl _wstat32(
     wchar_t const*  _FileName,
      struct _stat32* _Stat
    );

__declspec(dllimport) int __cdecl _wstat32i64(
     wchar_t const*     _FileName,
      struct _stat32i64* _Stat
    );

__declspec(dllimport) int __cdecl _wstat64i32(
     wchar_t const*     _FileName,
      struct _stat64i32* _Stat
    );

__declspec(dllimport) int __cdecl _wstat64(
     wchar_t const*  _FileName,
      struct _stat64* _Stat
    );




    















        static __inline int __cdecl fstat(int const _FileHandle, struct stat* const _Stat)
        {
            static_assert((sizeof(struct stat) == sizeof(struct _stat64i32)), "sizeof(struct stat) == sizeof(struct _stat64i32)") ;
            return _fstat64i32(_FileHandle, (struct _stat64i32*)_Stat);
        }
        static __inline int __cdecl stat(char const* const _FileName, struct stat* const _Stat)
        {
            static_assert((sizeof(struct stat) == sizeof(struct _stat64i32)), "sizeof(struct stat) == sizeof(struct _stat64i32)") ;
            return _stat64i32(_FileName, (struct _stat64i32*)_Stat);
        }

    #line 245 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\sys\\stat.h"
#line 246 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\sys\\stat.h"

} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 26 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\wchar.h"



#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {








typedef wchar_t _Wint_t;





      
    __declspec(dllimport) wchar_t* __cdecl _wsetlocale(
               int            _Category,
         wchar_t const* _Locale
        );

    
    __declspec(dllimport) _locale_t __cdecl _wcreate_locale(
           int            _Category,
         wchar_t const* _Locale
        );



    __declspec(dllimport) wint_t __cdecl btowc(
         int _Ch
        );

    __declspec(dllimport) size_t __cdecl mbrlen(
          char const* _Ch,
                                                   size_t      _SizeInBytes,
                                                mbstate_t*  _State
        );

    __declspec(dllimport) size_t __cdecl mbrtowc(
                                wchar_t*    _DstCh,
          char const* _SrcCh,
                                                   size_t      _SizeInBytes,
                                                mbstate_t*  _State
        );

    
    __declspec(dllimport) errno_t __cdecl mbsrtowcs_s(
                                 size_t*      _Retval,
                 wchar_t*     _Dst,
                                      size_t       _Size,
                         char const** _PSrc,
                                      size_t       _N,
                                   mbstate_t*   _State
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl mbsrtowcs_s(size_t* _Retval, wchar_t (&_Dest)[_Size], char const** _PSource, size_t _Count, mbstate_t* _State) throw() { return mbsrtowcs_s(_Retval, _Dest, _Size, _PSource, _Count, _State); } }









    __declspec(deprecated("This function or variable may be unsafe. Consider using " "mbsrtowcs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl mbsrtowcs( wchar_t *_Dest, char const** _PSrc, size_t _Count, mbstate_t* _State);







    
    __declspec(dllimport) errno_t __cdecl wcrtomb_s(
                                size_t*    _Retval,
         char*      _Dst,
                                     size_t     _SizeInBytes,
                                     wchar_t    _Ch,
                              mbstate_t* _State
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl wcrtomb_s(size_t* _Retval, char (&_Dest)[_Size], wchar_t _Source, mbstate_t* _State) throw() { return wcrtomb_s(_Retval, _Dest, _Size, _Source, _State); } }








    __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcrtomb_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl wcrtomb( char *_Dest, wchar_t _Source, mbstate_t* _State);






    
    __declspec(dllimport) errno_t __cdecl wcsrtombs_s(
                                                 size_t*         _Retval,
         char*           _Dst,
                                                      size_t          _SizeInBytes,
                                  wchar_t const** _Src,
                                                      size_t          _Size,
                                               mbstate_t*      _State
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsrtombs_s(size_t* _Retval, char (&_Dest)[_Size], wchar_t const** _PSrc, size_t _Count, mbstate_t* _State) throw() { return wcsrtombs_s(_Retval, _Dest, _Size, _PSrc, _Count, _State); } }









    __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsrtombs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl wcsrtombs( char *_Dest, wchar_t const** _PSource, size_t _Count, mbstate_t* _State);







    __declspec(dllimport) int __cdecl wctob(
         wint_t _WCh
        );

    

        
        errno_t __cdecl wmemcpy_s(
             wchar_t*       _S1,
                                     rsize_t        _N1,
                       wchar_t const* _S2,
                                     rsize_t        _N
            );

        
        errno_t __cdecl wmemmove_s(
             wchar_t*       _S1,
                                     rsize_t        _N1,
                       wchar_t const* _S2,
                                     rsize_t        _N
            );

    #line 183 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\wchar.h"

    __inline int __cdecl fwide(
         FILE* _F,
             int   _M
        )
    {
        (void)_F ;
        return (_M);
    }

    __inline int __cdecl mbsinit(
         mbstate_t const* _P
        )
    {
        return _P == 0 || _P->_Wchar == 0;
    }

    __inline wchar_t const * __cdecl wmemchr(
         wchar_t const* _S,
                   wchar_t        _C,
                   size_t         _N
        )
    {
        for (; 0 < _N; ++_S, --_N)
            if (*_S == _C)
                return (wchar_t const *)_S;

        return 0;
    }

    __inline int __cdecl wmemcmp(
         wchar_t const* _S1,
         wchar_t const* _S2,
                   size_t         _N
        )
    {
        for (; 0 < _N; ++_S1, ++_S2, --_N)
            if (*_S1 != *_S2)
                return *_S1 < *_S2 ? -1 : 1;

        return 0;
    }

    
    
    __inline 
    wchar_t* __cdecl wmemcpy(
         wchar_t*       _S1,
               wchar_t const* _S2,
                         size_t         _N
        )
    {
        #pragma warning(suppress: 6386) 
        return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));
    }

    __inline 
    wchar_t* __cdecl wmemmove(
         wchar_t*       _S1,
               wchar_t const* _S2,
                             size_t         _N
        )
    {
        #pragma warning(suppress: 6386) 
        return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));
    }

    
    
    __inline wchar_t* __cdecl wmemset(
         wchar_t* _S,
                         wchar_t  _C,
                         size_t   _N
        )
    {
        wchar_t *_Su = _S;
        for (; 0 < _N; ++_Su, --_N)
        {
            *_Su = _C;
        }
        return _S;
    }

    

        extern "C++" inline wchar_t* __cdecl wmemchr(
             wchar_t* _S,
                       wchar_t  _C,
                       size_t   _N
            )
        {
            wchar_t const* const _SC = _S;
            return const_cast<wchar_t*>(wmemchr(_SC, _C, _N));
        }

    #line 279 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\wchar.h"

#line 281 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\wchar.h"


} __pragma(pack(pop))

#pragma warning(pop) 
#line 287 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\wchar.h"
#pragma external_header(pop)
#line 14 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cwchar"

#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




using _Mbstatet = mbstate_t;

namespace std {
#pragma warning(push)
#pragma warning(disable : 4995) 

using :: _Mbstatet;

 using :: mbstate_t;
 using :: size_t;
 using :: tm;
 using :: wint_t;

 using :: btowc;
 using :: fgetwc;
 using :: fgetws;
 using :: fputwc;
 using :: fputws;
 using :: fwide;
 using :: fwprintf;
 using :: fwscanf;
 using :: getwc;
 using :: getwchar;
 using :: mbrlen;
 using :: mbrtowc;
 using :: mbsrtowcs;
 using :: mbsinit;
 using :: putwc;
 using :: putwchar;
 using :: swprintf;
 using :: swscanf;
 using :: ungetwc;
 using :: vfwprintf;
 using :: vswprintf;
 using :: vwprintf;
 using :: wcrtomb;
 using :: wprintf;
 using :: wscanf;
 using :: wcsrtombs;
 using :: wcstol;
 using :: wcscat;
 using :: wcschr;
 using :: wcscmp;
 using :: wcscoll;
 using :: wcscpy;
 using :: wcscspn;
 using :: wcslen;
 using :: wcsncat;
 using :: wcsncmp;
 using :: wcsncpy;
 using :: wcspbrk;
 using :: wcsrchr;
 using :: wcsspn;
 using :: wcstod;
 using :: wcstoul;
 using :: wcsstr;
 using :: wcstok;
 using :: wcsxfrm;
 using :: wctob;
 using :: wmemchr;
 using :: wmemcmp;
 using :: wmemcpy;
 using :: wmemmove;
 using :: wmemset;
 using :: wcsftime;

 using :: vfwscanf;
 using :: vswscanf;
 using :: vwscanf;
 using :: wcstof;
 using :: wcstold;
 using :: wcstoll;
 using :: wcstoull;

#pragma warning(pop)
}



#pragma warning(pop)
#pragma pack(pop)

#line 105 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cwchar"
#line 106 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cwchar"
#pragma external_header(pop)
#line 14 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"







#line 23 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"

#line 25 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"



#line 29 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"

#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




namespace std {
 enum float_denorm_style { 
    denorm_indeterminate = -1,
    denorm_absent        = 0,
    denorm_present       = 1
};

 enum float_round_style { 
    round_indeterminate       = -1,
    round_toward_zero         = 0,
    round_to_nearest          = 1,
    round_toward_infinity     = 2,
    round_toward_neg_infinity = 3
};

struct _Num_base { 
    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr bool has_denorm_loss          = false;
    static constexpr bool has_infinity             = false;
    static constexpr bool has_quiet_NaN            = false;
    static constexpr bool has_signaling_NaN        = false;
    static constexpr bool is_bounded               = false;
    static constexpr bool is_exact                 = false;
    static constexpr bool is_iec559                = false;
    static constexpr bool is_integer               = false;
    static constexpr bool is_modulo                = false;
    static constexpr bool is_signed                = false;
    static constexpr bool is_specialized           = false;
    static constexpr bool tinyness_before          = false;
    static constexpr bool traps                    = false;
    static constexpr float_round_style round_style = round_toward_zero;
    static constexpr int digits                    = 0;
    static constexpr int digits10                  = 0;
    static constexpr int max_digits10              = 0;
    static constexpr int max_exponent              = 0;
    static constexpr int max_exponent10            = 0;
    static constexpr int min_exponent              = 0;
    static constexpr int min_exponent10            = 0;
    static constexpr int radix                     = 0;
};

 template <class _Ty>
class numeric_limits : public _Num_base { 
public:
    [[nodiscard]] static constexpr _Ty(min)() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty(max)() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty lowest() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty epsilon() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty round_error() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty denorm_min() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty infinity() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty quiet_NaN() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty signaling_NaN() noexcept {
        return _Ty();
    }
};

template <class _Ty>
class numeric_limits<const _Ty> : public numeric_limits<_Ty> {}; 

template <class _Ty>
class numeric_limits<volatile _Ty> : public numeric_limits<_Ty> {}; 

template <class _Ty>
class numeric_limits<const volatile _Ty> : public numeric_limits<_Ty> {}; 

struct _Num_int_base : _Num_base { 
    static constexpr bool is_bounded     = true;
    static constexpr bool is_exact       = true;
    static constexpr bool is_integer     = true;
    static constexpr bool is_specialized = true;
    static constexpr int radix           = 2;
};

struct _Num_float_base : _Num_base { 
    static constexpr float_denorm_style has_denorm = denorm_present;
    static constexpr bool has_infinity             = true;
    static constexpr bool has_quiet_NaN            = true;
    static constexpr bool has_signaling_NaN        = true;
    static constexpr bool is_bounded               = true;
    static constexpr bool is_iec559                = true;
    static constexpr bool is_signed                = true;
    static constexpr bool is_specialized           = true;
    static constexpr float_round_style round_style = round_to_nearest;
    static constexpr int radix                     = 2 ;
};

template <>
class numeric_limits<bool> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr bool(min)() noexcept {
        return false;
    }

    [[nodiscard]] static constexpr bool(max)() noexcept {
        return true;
    }

    [[nodiscard]] static constexpr bool lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr bool epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr bool round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr bool denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr bool infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr bool quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr bool signaling_NaN() noexcept {
        return 0;
    }

    static constexpr int digits = 1;
};

template <>
class numeric_limits<char> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr char(min)() noexcept {
        return (-128) ;
    }

    [[nodiscard]] static constexpr char(max)() noexcept {
        return 127 ;
    }

    [[nodiscard]] static constexpr char lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr char epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_signed = (-128) != 0;
    static constexpr bool is_modulo = (-128) == 0;
    static constexpr int digits     = 8 - ((-128) != 0);
    static constexpr int digits10   = 2;
};

template <>
class numeric_limits<signed char> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr signed char(min)() noexcept {
        return (-128) ;
    }

    [[nodiscard]] static constexpr signed char(max)() noexcept {
        return 127 ;
    }

    [[nodiscard]] static constexpr signed char lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr signed char epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr signed char round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr signed char denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr signed char infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr signed char quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr signed char signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_signed = true;
    static constexpr int digits     = 7;
    static constexpr int digits10   = 2;
};

template <>
class numeric_limits<unsigned char> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr unsigned char(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned char(max)() noexcept {
        return 0xff ;
    }

    [[nodiscard]] static constexpr unsigned char lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr unsigned char epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned char round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned char denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned char infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned char quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned char signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 8;
    static constexpr int digits10   = 2;
};


template <>
class numeric_limits<char8_t> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr char8_t(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char8_t(max)() noexcept {
        return 0xff ;
    }

    [[nodiscard]] static constexpr char8_t lowest() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char8_t epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char8_t round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char8_t denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char8_t infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char8_t quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char8_t signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 8;
    static constexpr int digits10   = 2;
};
#line 368 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"

template <>
class numeric_limits<char16_t> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr char16_t(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char16_t(max)() noexcept {
        return 0xffff ;
    }

    [[nodiscard]] static constexpr char16_t lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr char16_t epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char16_t round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char16_t denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char16_t infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char16_t quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char16_t signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 16;
    static constexpr int digits10   = 4;
};

template <>
class numeric_limits<char32_t> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr char32_t(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char32_t(max)() noexcept {
        return 0xffffffff ;
    }

    [[nodiscard]] static constexpr char32_t lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr char32_t epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char32_t round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char32_t denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char32_t infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char32_t quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char32_t signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 32;
    static constexpr int digits10   = 9;
};

template <>
class numeric_limits<wchar_t> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr wchar_t(min)() noexcept {
        return 0x0000 ;
    }

    [[nodiscard]] static constexpr wchar_t(max)() noexcept {
        return 0xffff ;
    }

    [[nodiscard]] static constexpr wchar_t lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr wchar_t epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr wchar_t round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr wchar_t denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr wchar_t infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr wchar_t quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr wchar_t signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 16;
    static constexpr int digits10   = 4;
};

template <>
class numeric_limits<short> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr short(min)() noexcept {
        return (-32768) ;
    }

    [[nodiscard]] static constexpr short(max)() noexcept {
        return 32767 ;
    }

    [[nodiscard]] static constexpr short lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr short epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr short round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr short denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr short infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr short quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr short signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_signed = true;
    static constexpr int digits     = 15;
    static constexpr int digits10   = 4;
};

template <>
class numeric_limits<int> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr int(min)() noexcept {
        return (-2147483647 - 1) ;
    }

    [[nodiscard]] static constexpr int(max)() noexcept {
        return 2147483647 ;
    }

    [[nodiscard]] static constexpr int lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr int epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr int round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr int denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr int infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr int quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr int signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_signed = true;
    static constexpr int digits     = 31;
    static constexpr int digits10   = 9;
};

template <>
class numeric_limits<long> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr long(min)() noexcept {
        return (-2147483647L - 1) ;
    }

    [[nodiscard]] static constexpr long(max)() noexcept {
        return 2147483647L ;
    }

    [[nodiscard]] static constexpr long lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr long epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long signaling_NaN() noexcept {
        return 0;
    }

    static_assert(sizeof(int) == sizeof(long), "LLP64 assumption");
    static constexpr bool is_signed = true;
    static constexpr int digits     = 31;
    static constexpr int digits10   = 9;
};

template <>
class numeric_limits<long long> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr long long(min)() noexcept {
        return (-9223372036854775807i64 - 1) ;
    }

    [[nodiscard]] static constexpr long long(max)() noexcept {
        return 9223372036854775807i64 ;
    }

    [[nodiscard]] static constexpr long long lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr long long epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long long round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long long denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long long infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long long quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long long signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_signed = true;
    static constexpr int digits     = 63;
    static constexpr int digits10   = 18;
};


template <>
class numeric_limits<unsigned short> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr unsigned short(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned short(max)() noexcept {
        return 0xffff ;
    }

    [[nodiscard]] static constexpr unsigned short lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr unsigned short epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned short round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned short denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned short infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned short quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned short signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 16;
    static constexpr int digits10   = 4;
};
#line 723 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"

template <>
class numeric_limits<unsigned int> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr unsigned int(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned int(max)() noexcept {
        return 0xffffffff ;
    }

    [[nodiscard]] static constexpr unsigned int lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr unsigned int epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned int round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned int denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned int infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned int quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned int signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 32;
    static constexpr int digits10   = 9;
};

template <>
class numeric_limits<unsigned long> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr unsigned long(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long(max)() noexcept {
        return 0xffffffffUL ;
    }

    [[nodiscard]] static constexpr unsigned long lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr unsigned long epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long signaling_NaN() noexcept {
        return 0;
    }

    static_assert(sizeof(unsigned int) == sizeof(unsigned long), "LLP64 assumption");
    static constexpr bool is_modulo = true;
    static constexpr int digits     = 32;
    static constexpr int digits10   = 9;
};

template <>
class numeric_limits<unsigned long long> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr unsigned long long(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long long(max)() noexcept {
        return 0xffffffffffffffffui64 ;
    }

    [[nodiscard]] static constexpr unsigned long long lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr unsigned long long epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long long round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long long denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long long infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long long quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long long signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 64;
    static constexpr int digits10   = 19;
};

template <>
class numeric_limits<float> : public _Num_float_base {
public:
    [[nodiscard]] static constexpr float(min)() noexcept {
        return 1.175494351e-38F ;
    }

    [[nodiscard]] static constexpr float(max)() noexcept {
        return 3.402823466e+38F ;
    }

    [[nodiscard]] static constexpr float lowest() noexcept {
        return -(max) ();
    }

    [[nodiscard]] static constexpr float epsilon() noexcept {
        return 1.192092896e-07F ;
    }

    [[nodiscard]] static constexpr float round_error() noexcept {
        return 0.5F;
    }

    [[nodiscard]] static constexpr float denorm_min() noexcept {
        return 1.401298464e-45F ;
    }

    [[nodiscard]] static constexpr float infinity() noexcept {
        return __builtin_huge_valf();
    }

    [[nodiscard]] static constexpr float quiet_NaN() noexcept {
        return __builtin_nanf("0");
    }

    [[nodiscard]] static constexpr float signaling_NaN() noexcept {
        return __builtin_nansf("1");
    }

    static constexpr int digits         = 24 ;
    static constexpr int digits10       = 6 ;
    static constexpr int max_digits10   = 9;
    static constexpr int max_exponent   = 128 ;
    static constexpr int max_exponent10 = 38 ;
    static constexpr int min_exponent   = (-125) ;
    static constexpr int min_exponent10 = (-37) ;
};

template <>
class numeric_limits<double> : public _Num_float_base {
public:
    [[nodiscard]] static constexpr double(min)() noexcept {
        return 2.2250738585072014e-308 ;
    }

    [[nodiscard]] static constexpr double(max)() noexcept {
        return 1.7976931348623158e+308 ;
    }

    [[nodiscard]] static constexpr double lowest() noexcept {
        return -(max) ();
    }

    [[nodiscard]] static constexpr double epsilon() noexcept {
        return 2.2204460492503131e-016 ;
    }

    [[nodiscard]] static constexpr double round_error() noexcept {
        return 0.5;
    }

    [[nodiscard]] static constexpr double denorm_min() noexcept {
        return 4.9406564584124654e-324 ;
    }

    [[nodiscard]] static constexpr double infinity() noexcept {
        return __builtin_huge_val();
    }

    [[nodiscard]] static constexpr double quiet_NaN() noexcept {
        return __builtin_nan("0");
    }

    [[nodiscard]] static constexpr double signaling_NaN() noexcept {
        return __builtin_nans("1");
    }

    static constexpr int digits         = 53 ;
    static constexpr int digits10       = 15 ;
    static constexpr int max_digits10   = 17;
    static constexpr int max_exponent   = 1024 ;
    static constexpr int max_exponent10 = 308 ;
    static constexpr int min_exponent   = (-1021) ;
    static constexpr int min_exponent10 = (-307) ;
};

template <>
class numeric_limits<long double> : public _Num_float_base {
public:
    [[nodiscard]] static constexpr long double(min)() noexcept {
        return 2.2250738585072014e-308 ;
    }

    [[nodiscard]] static constexpr long double(max)() noexcept {
        return 1.7976931348623158e+308 ;
    }

    [[nodiscard]] static constexpr long double lowest() noexcept {
        return -(max) ();
    }

    [[nodiscard]] static constexpr long double epsilon() noexcept {
        return 2.2204460492503131e-016 ;
    }

    [[nodiscard]] static constexpr long double round_error() noexcept {
        return 0.5L;
    }

    [[nodiscard]] static constexpr long double denorm_min() noexcept {
        return 4.9406564584124654e-324 ;
    }

    [[nodiscard]] static constexpr long double infinity() noexcept {
        return __builtin_huge_val();
    }

    [[nodiscard]] static constexpr long double quiet_NaN() noexcept {
        return __builtin_nan("0");
    }

    [[nodiscard]] static constexpr long double signaling_NaN() noexcept {
        return __builtin_nans("1");
    }

    static constexpr int digits         = 53 ;
    static constexpr int digits10       = 15 ;
    static constexpr int max_digits10   = 2 + 53 * 301L / 1000;
    static constexpr int max_exponent   = 1024 ;
    static constexpr int max_exponent10 = 308 ;
    static constexpr int min_exponent   = (-1021) ;
    static constexpr int min_exponent10 = (-307) ;
};




template <class _Ty>
[[nodiscard]] constexpr int _Countl_zero_fallback(_Ty _Val) noexcept {
    _Ty _Yy = 0;

    unsigned int _Nn = numeric_limits<_Ty>::digits;
    unsigned int _Cc = numeric_limits<_Ty>::digits / 2;
    do {
        _Yy = static_cast<_Ty>(_Val >> _Cc);
        if (_Yy != 0) {
            _Nn -= _Cc;
            _Val = _Yy;
        }
        _Cc >>= 1;
    } while (_Cc != 0);
    return static_cast<int>(_Nn) - static_cast<int>(_Val);
}




template <class _Ty>
[[nodiscard]] constexpr int _Countr_zero_fallback(const _Ty _Val) noexcept {
    constexpr int _Digits = numeric_limits<_Ty>::digits;
    return _Digits - _Countl_zero_fallback(static_cast<_Ty>(static_cast<_Ty>(~_Val) & static_cast<_Ty>(_Val - 1)));
}



template <class _Ty>
[[nodiscard]] constexpr int _Popcount_fallback(_Ty _Val) noexcept {
    constexpr int _Digits = numeric_limits<_Ty>::digits;







#line 1043 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"
    
    _Val = static_cast<_Ty>(_Val - ((_Val >> 1) & static_cast<_Ty>(0x5555'5555'5555'5555ull)));
    _Val = static_cast<_Ty>((_Val & static_cast<_Ty>(0x3333'3333'3333'3333ull))
                            + ((_Val >> 2) & static_cast<_Ty>(0x3333'3333'3333'3333ull)));
    _Val = static_cast<_Ty>((_Val + (_Val >> 4)) & static_cast<_Ty>(0x0F0F'0F0F'0F0F'0F0Full));
    
    _Val = static_cast<_Ty>(_Val * static_cast<_Ty>(0x0101'0101'0101'0101ull));
    
    return static_cast<int>(_Val >> (_Digits - 8));
}





#line 1060 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"


extern "C" {
extern int __isa_available;
}







#line 1073 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"

template <class _Ty>
[[nodiscard]] int _Countr_zero_tzcnt(const _Ty _Val) noexcept {
    constexpr int _Digits = numeric_limits<_Ty>::digits;
    constexpr _Ty _Max    = (numeric_limits<_Ty>::max)();

    if constexpr (_Digits <= 32) {
        
        
        
        return static_cast<int>(_tzcnt_u32 (static_cast<unsigned int>(~_Max | _Val)));
    } else {









        return static_cast<int>(_tzcnt_u64 (_Val));
#line 1096 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"
    }
}




template <class _Ty>
[[nodiscard]] int _Countr_zero_bsf(const _Ty _Val) noexcept {
    constexpr int _Digits = numeric_limits<_Ty>::digits;
    constexpr _Ty _Max    = (numeric_limits<_Ty>::max)();

    unsigned long _Result;
    if constexpr (_Digits <= 32) {
        
        
        
        if (!_BitScanForward(&_Result, static_cast<unsigned int>(~_Max | _Val))) {
            return _Digits;
        }
    } else {













        if (!_BitScanForward64(&_Result, _Val)) {
            return _Digits;
        }
#line 1133 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"
    }
    return static_cast<int>(_Result);
}

template <class _Ty>
[[nodiscard]] int _Checked_x86_x64_countr_zero(const _Ty _Val) noexcept {



    const bool _Definitely_have_tzcnt = __isa_available >= __ISA_AVAILABLE_AVX2;
    if (_Definitely_have_tzcnt) {
        return _Countr_zero_tzcnt(_Val);
    } else {
        return _Countr_zero_bsf(_Val);
    }
#line 1149 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"
}

#line 1152 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"





#line 1159 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"


template <class _Ty>
[[nodiscard]] int _Unchecked_x86_x64_popcount(const _Ty _Val) noexcept {
    constexpr int _Digits = numeric_limits<_Ty>::digits;
    if constexpr (_Digits <= 16) {
        return static_cast<int>(__popcnt16(_Val));
    } else if constexpr (_Digits == 32) {
        return static_cast<int>(__popcnt(_Val));
    } else {



        return static_cast<int>(__popcnt64(_Val));
#line 1174 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"
    }
}

template <class _Ty>
[[nodiscard]] int _Checked_x86_x64_popcount(const _Ty _Val) noexcept {

    const bool _Definitely_have_popcnt = __isa_available >= __ISA_AVAILABLE_SSE42;
    if (!_Definitely_have_popcnt) {
        return _Popcount_fallback(_Val);
    }
#line 1185 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"
    return _Unchecked_x86_x64_popcount(_Val);
}
#line 1188 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"






#line 1195 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"

template <class _Ty>
constexpr bool _Is_standard_unsigned_integer =
    _Is_any_of_v<remove_cv_t<_Ty>, unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>;

template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> = 0>
[[nodiscard]] constexpr int _Countr_zero(const _Ty _Val) noexcept {


    if (!::std:: is_constant_evaluated())
#line 1206 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"
    {
        return _Checked_x86_x64_countr_zero(_Val);
    }
#line 1210 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"
    return _Countr_zero_fallback(_Val);
}

template <class _Ty, class _Fn>
constexpr decltype(auto) _Select_countr_zero_impl(_Fn _Callback) {
    

    if (!::std:: is_constant_evaluated()) {



        const bool _Definitely_have_tzcnt = __isa_available >= __ISA_AVAILABLE_AVX2;
        if (_Definitely_have_tzcnt) {
            return _Callback([](_Ty _Val) { return _Countr_zero_tzcnt(_Val); });
        } else {
            return _Callback([](_Ty _Val) { return _Countr_zero_bsf(_Val); });
        }
#line 1228 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"
    }
#line 1230 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"
    
    return _Callback([](_Ty _Val) { return _Countr_zero_fallback(_Val); });
}

template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> _Enabled = 0>
[[nodiscard]] constexpr int _Popcount(const _Ty _Val) noexcept {


    if (!::std:: is_constant_evaluated())
#line 1240 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"
    {

        return _Checked_x86_x64_popcount(_Val);


#line 1246 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"
    }
#line 1248 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"
    return _Popcount_fallback(_Val);
}

template <class _Ty, class _Fn>
constexpr decltype(auto) _Select_popcount_impl(_Fn _Callback) {
    


    if (!::std:: is_constant_evaluated())
#line 1258 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"
    {


        const bool _Definitely_have_popcnt = __isa_available >= __ISA_AVAILABLE_SSE42;
        if (!_Definitely_have_popcnt) {
            return _Callback([](_Ty _Val) { return _Popcount_fallback(_Val); });
        }
#line 1266 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"
        return _Callback([](_Ty _Val) { return _Unchecked_x86_x64_popcount(_Val); });


#line 1270 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"
    }
#line 1272 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"
    return _Callback([](_Ty _Val) { return _Popcount_fallback(_Val); });
}





}


#pragma warning(pop)
#pragma pack(pop)
#line 1285 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"
#line 1286 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\limits"
#pragma external_header(pop)
#line 18 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\bit"


#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




namespace std {

 template <class _To, class _From,
    enable_if_t<conjunction_v<bool_constant<sizeof(_To) == sizeof(_From)>, is_trivially_copyable<_To>,
                    is_trivially_copyable<_From>>,
        int> = 0>
[[nodiscard]] constexpr _To bit_cast(const _From& _Val) noexcept {
    return __builtin_bit_cast(_To, _Val);
}

 template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> = 0>
[[nodiscard]] constexpr int countl_zero(_Ty _Val) noexcept;

 template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> = 0>
[[nodiscard]] constexpr bool has_single_bit(const _Ty _Val) noexcept {
    return _Val != 0 && (_Val & (_Val - 1)) == 0;
}

inline void _Precondition_violation_in_bit_ceil() noexcept {}

 template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> = 0>
[[nodiscard]] constexpr _Ty bit_ceil(const _Ty _Val) noexcept   {
    if (_Val <= 1u) {
        return _Ty{1};
    }

    const int _Num = numeric_limits<_Ty>::digits - ::std:: countl_zero(static_cast<_Ty>(_Val - 1));

    if constexpr (sizeof(_Ty) < sizeof(unsigned int)) { 
        if (::std:: is_constant_evaluated()) {
            
            
            
            
            
            
            
            
            
            if (_Num == numeric_limits<_Ty>::digits) {
                _Precondition_violation_in_bit_ceil();
            }
        }
    }

    return static_cast<_Ty>(_Ty{1} << _Num);
}

 template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> = 0>
[[nodiscard]] constexpr _Ty bit_floor(const _Ty _Val) noexcept {
    if (_Val == 0) {
        return 0;
    }

    return static_cast<_Ty>(_Ty{1} << (numeric_limits<_Ty>::digits - 1 - ::std:: countl_zero(_Val)));
}

 template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> = 0>
[[nodiscard]] constexpr int bit_width(const _Ty _Val) noexcept {
    return numeric_limits<_Ty>::digits - ::std:: countl_zero(_Val);
}

 template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> = 0>
[[nodiscard]] constexpr _Ty rotr(_Ty _Val, int _Rotation) noexcept;

 template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> = 0>
[[nodiscard]] constexpr _Ty rotl(const _Ty _Val, const int _Rotation) noexcept {
    constexpr auto _Digits = numeric_limits<_Ty>::digits;

    if (!::std:: is_constant_evaluated()) {
        if constexpr (_Digits == 64) {
            return _rotl64(_Val, _Rotation);
        } else if constexpr (_Digits == 32) {
            return _rotl(_Val, _Rotation);
        } else if constexpr (_Digits == 16) {
            return _rotl16(_Val, static_cast<unsigned char>(_Rotation));
        } else {
             ;
            return _rotl8(_Val, static_cast<unsigned char>(_Rotation));
        }
    }

    const auto _Remainder = _Rotation % _Digits;
    if (_Remainder > 0) {
        return static_cast<_Ty>(
            static_cast<_Ty>(_Val << _Remainder) | static_cast<_Ty>(_Val >> (_Digits - _Remainder)));
    } else if (_Remainder == 0) {
        return _Val;
    } else { 
        return ::std:: rotr(_Val, -_Remainder);
    }
}

 template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> _Enabled>
[[nodiscard]] constexpr _Ty rotr(const _Ty _Val, const int _Rotation) noexcept {
    constexpr auto _Digits = numeric_limits<_Ty>::digits;

    if (!::std:: is_constant_evaluated()) {
        if constexpr (_Digits == 64) {
            return _rotr64(_Val, _Rotation);
        } else if constexpr (_Digits == 32) {
            return _rotr(_Val, _Rotation);
        } else if constexpr (_Digits == 16) {
            return _rotr16(_Val, static_cast<unsigned char>(_Rotation));
        } else {
             ;
            return _rotr8(_Val, static_cast<unsigned char>(_Rotation));
        }
    }

    const auto _Remainder = _Rotation % _Digits;
    if (_Remainder > 0) {
        return static_cast<_Ty>(
            static_cast<_Ty>(_Val >> _Remainder) | static_cast<_Ty>(_Val << (_Digits - _Remainder)));
    } else if (_Remainder == 0) {
        return _Val;
    } else { 
        return ::std:: rotl(_Val, -_Remainder);
    }
}



extern "C" {
extern int __isa_available;
}

template <class _Ty>
[[nodiscard]] int _Countl_zero_lzcnt(const _Ty _Val) noexcept {
    constexpr int _Digits = numeric_limits<_Ty>::digits;

    if constexpr (_Digits <= 16) {
        return static_cast<int>(__lzcnt16(_Val) - (16 - _Digits));
    } else if constexpr (_Digits == 32) {
        return static_cast<int>(__lzcnt(_Val));
    } else {









        return static_cast<int>(__lzcnt64(_Val));
#line 174 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\bit"
    }
}

template <class _Ty>
[[nodiscard]] int _Countl_zero_bsr(const _Ty _Val) noexcept {
    constexpr int _Digits = numeric_limits<_Ty>::digits;

    unsigned long _Result;
    if constexpr (_Digits <= 32) {
        if (!_BitScanReverse(&_Result, _Val)) {
            return _Digits;
        }
    } else {











        if (!_BitScanReverse64(&_Result, _Val)) {
            return _Digits;
        }
#line 202 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\bit"
    }
    return static_cast<int>(_Digits - 1 - _Result);
}

template <class _Ty>
[[nodiscard]] int _Checked_x86_x64_countl_zero(const _Ty _Val) noexcept {



    const bool _Definitely_have_lzcnt = __isa_available >= __ISA_AVAILABLE_AVX2;
    if (_Definitely_have_lzcnt) {
        return _Countl_zero_lzcnt(_Val);
    } else {
        return _Countl_zero_bsr(_Val);
    }
#line 218 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\bit"
}
#line 220 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\bit"










































#line 263 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\bit"



























#line 291 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\bit"

 template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> _Enabled>
[[nodiscard]] constexpr int countl_zero(const _Ty _Val) noexcept {

    if (!::std:: is_constant_evaluated()) {
        return _Checked_x86_x64_countl_zero(_Val);
    }




#line 303 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\bit"

    return _Countl_zero_fallback(_Val);
}

 template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> = 0>
[[nodiscard]] constexpr int countl_one(const _Ty _Val) noexcept {
    return ::std:: countl_zero(static_cast<_Ty>(~_Val));
}

 template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> = 0>
[[nodiscard]] constexpr int countr_zero(const _Ty _Val) noexcept {
    return _Countr_zero(_Val);
}

 template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> _Enabled = 0>
[[nodiscard]] constexpr int countr_one(const _Ty _Val) noexcept {
    return _Countr_zero(static_cast<_Ty>(~_Val));
}

 template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> = 0>
[[nodiscard]] constexpr int popcount(const _Ty _Val) noexcept {
    return _Popcount(_Val);
}
















#line 343 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\bit"

 enum class endian { little = 0, big = 1, native = little };

}


#pragma warning(pop)
#pragma pack(pop)
#line 352 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\bit"
#line 353 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\bit"
#line 354 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\bit"
#pragma external_header(pop)
#line 17 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\compare"



#line 21 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\compare"

#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




namespace std {
using _Literal_zero = decltype(nullptr);
using _Compare_t    = signed char;


enum class _Compare_eq : _Compare_t { equal = 0, equivalent = equal };
enum class _Compare_ord : _Compare_t { less = -1, greater = 1 };
enum class _Compare_ncmp : _Compare_t { unordered = -128 };

 struct partial_ordering {
    static const partial_ordering less;
    static const partial_ordering equivalent;
    static const partial_ordering greater;
    static const partial_ordering unordered;

    [[nodiscard]] friend constexpr bool operator==(const partial_ordering _Val, _Literal_zero) noexcept {
        return _Val._Value == 0;
    }

    [[nodiscard]] friend constexpr bool operator==(partial_ordering, partial_ordering) noexcept = default;

    [[nodiscard]] friend constexpr bool operator<(const partial_ordering _Val, _Literal_zero) noexcept {
        return _Val._Value == static_cast<_Compare_t>(_Compare_ord::less);
    }

    [[nodiscard]] friend constexpr bool operator>(const partial_ordering _Val, _Literal_zero) noexcept {
        return _Val._Value > 0;
    }

    [[nodiscard]] friend constexpr bool operator<=(const partial_ordering _Val, _Literal_zero) noexcept {
        
        
        
        return static_cast<signed char>(0 - static_cast<unsigned int>(_Val._Value)) >= 0;
    }

    [[nodiscard]] friend constexpr bool operator>=(const partial_ordering _Val, _Literal_zero) noexcept {
        return _Val._Value >= 0;
    }

    [[nodiscard]] friend constexpr bool operator<(_Literal_zero, const partial_ordering _Val) noexcept {
        return _Val > 0;
    }

    [[nodiscard]] friend constexpr bool operator>(_Literal_zero, const partial_ordering _Val) noexcept {
        return _Val < 0;
    }

    [[nodiscard]] friend constexpr bool operator<=(_Literal_zero, const partial_ordering _Val) noexcept {
        return _Val >= 0;
    }

    [[nodiscard]] friend constexpr bool operator>=(_Literal_zero, const partial_ordering _Val) noexcept {
        return _Val <= 0;
    }

    [[nodiscard]] friend constexpr partial_ordering operator<=>(const partial_ordering _Val, _Literal_zero) noexcept {
        return _Val;
    }

    [[nodiscard]] friend constexpr partial_ordering operator<=>(_Literal_zero, const partial_ordering _Val) noexcept {
        
        
        
        return {static_cast<_Compare_t>(0 - static_cast<unsigned int>(_Val._Value))};
    }

    _Compare_t _Value;
};

inline constexpr partial_ordering partial_ordering::less{static_cast<_Compare_t>(_Compare_ord::less)};
inline constexpr partial_ordering partial_ordering::equivalent{static_cast<_Compare_t>(_Compare_eq::equivalent)};
inline constexpr partial_ordering partial_ordering::greater{static_cast<_Compare_t>(_Compare_ord::greater)};
inline constexpr partial_ordering partial_ordering::unordered{static_cast<_Compare_t>(_Compare_ncmp::unordered)};

 struct weak_ordering {
    static const weak_ordering less;
    static const weak_ordering equivalent;
    static const weak_ordering greater;

    constexpr operator partial_ordering() const noexcept {
        return {static_cast<_Compare_t>(_Value)};
    }

    [[nodiscard]] friend constexpr bool operator==(const weak_ordering _Val, _Literal_zero) noexcept {
        return _Val._Value == 0;
    }

    [[nodiscard]] friend constexpr bool operator==(weak_ordering, weak_ordering) noexcept = default;

    [[nodiscard]] friend constexpr bool operator<(const weak_ordering _Val, _Literal_zero) noexcept {
        return _Val._Value < 0;
    }

    [[nodiscard]] friend constexpr bool operator>(const weak_ordering _Val, _Literal_zero) noexcept {
        return _Val._Value > 0;
    }

    [[nodiscard]] friend constexpr bool operator<=(const weak_ordering _Val, _Literal_zero) noexcept {
        return _Val._Value <= 0;
    }

    [[nodiscard]] friend constexpr bool operator>=(const weak_ordering _Val, _Literal_zero) noexcept {
        return _Val._Value >= 0;
    }

    [[nodiscard]] friend constexpr bool operator<(_Literal_zero, const weak_ordering _Val) noexcept {
        return _Val > 0;
    }

    [[nodiscard]] friend constexpr bool operator>(_Literal_zero, const weak_ordering _Val) noexcept {
        return _Val < 0;
    }

    [[nodiscard]] friend constexpr bool operator<=(_Literal_zero, const weak_ordering _Val) noexcept {
        return _Val >= 0;
    }

    [[nodiscard]] friend constexpr bool operator>=(_Literal_zero, const weak_ordering _Val) noexcept {
        return _Val <= 0;
    }

    [[nodiscard]] friend constexpr weak_ordering operator<=>(const weak_ordering _Val, _Literal_zero) noexcept {
        return _Val;
    }

    [[nodiscard]] friend constexpr weak_ordering operator<=>(_Literal_zero, const weak_ordering _Val) noexcept {
        return {static_cast<_Compare_t>(-_Val._Value)};
    }

    _Compare_t _Value;
};

inline constexpr weak_ordering weak_ordering::less{static_cast<_Compare_t>(_Compare_ord::less)};
inline constexpr weak_ordering weak_ordering::equivalent{static_cast<_Compare_t>(_Compare_eq::equivalent)};
inline constexpr weak_ordering weak_ordering::greater{static_cast<_Compare_t>(_Compare_ord::greater)};

 struct strong_ordering {
    static const strong_ordering less;
    static const strong_ordering equal;
    static const strong_ordering equivalent;
    static const strong_ordering greater;

    constexpr operator partial_ordering() const noexcept {
        return {static_cast<_Compare_t>(_Value)};
    }

    constexpr operator weak_ordering() const noexcept {
        return {static_cast<_Compare_t>(_Value)};
    }

    [[nodiscard]] friend constexpr bool operator==(const strong_ordering _Val, _Literal_zero) noexcept {
        return _Val._Value == 0;
    }

    [[nodiscard]] friend constexpr bool operator==(strong_ordering, strong_ordering) noexcept = default;

    [[nodiscard]] friend constexpr bool operator<(const strong_ordering _Val, _Literal_zero) noexcept {
        return _Val._Value < 0;
    }

    [[nodiscard]] friend constexpr bool operator>(const strong_ordering _Val, _Literal_zero) noexcept {
        return _Val._Value > 0;
    }

    [[nodiscard]] friend constexpr bool operator<=(const strong_ordering _Val, _Literal_zero) noexcept {
        return _Val._Value <= 0;
    }

    [[nodiscard]] friend constexpr bool operator>=(const strong_ordering _Val, _Literal_zero) noexcept {
        return _Val._Value >= 0;
    }

    [[nodiscard]] friend constexpr bool operator<(_Literal_zero, const strong_ordering _Val) noexcept {
        return _Val > 0;
    }

    [[nodiscard]] friend constexpr bool operator>(_Literal_zero, const strong_ordering _Val) noexcept {
        return _Val < 0;
    }

    [[nodiscard]] friend constexpr bool operator<=(_Literal_zero, const strong_ordering _Val) noexcept {
        return _Val >= 0;
    }

    [[nodiscard]] friend constexpr bool operator>=(_Literal_zero, const strong_ordering _Val) noexcept {
        return _Val <= 0;
    }

    [[nodiscard]] friend constexpr strong_ordering operator<=>(const strong_ordering _Val, _Literal_zero) noexcept {
        return _Val;
    }

    [[nodiscard]] friend constexpr strong_ordering operator<=>(_Literal_zero, const strong_ordering _Val) noexcept {
        return {static_cast<_Compare_t>(-_Val._Value)};
    }

    _Compare_t _Value;
};

inline constexpr strong_ordering strong_ordering::less{static_cast<_Compare_t>(_Compare_ord::less)};
inline constexpr strong_ordering strong_ordering::equal{static_cast<_Compare_t>(_Compare_eq::equal)};
inline constexpr strong_ordering strong_ordering::equivalent{static_cast<_Compare_t>(_Compare_eq::equivalent)};
inline constexpr strong_ordering strong_ordering::greater{static_cast<_Compare_t>(_Compare_ord::greater)};

 [[nodiscard]] constexpr bool is_eq(const partial_ordering _Comp) noexcept {
    return _Comp == 0;
}

 [[nodiscard]] constexpr bool is_neq(const partial_ordering _Comp) noexcept {
    return _Comp != 0;
}

 [[nodiscard]] constexpr bool is_lt(const partial_ordering _Comp) noexcept {
    return _Comp < 0;
}

 [[nodiscard]] constexpr bool is_lteq(const partial_ordering _Comp) noexcept {
    return _Comp <= 0;
}

 [[nodiscard]] constexpr bool is_gt(const partial_ordering _Comp) noexcept {
    return _Comp > 0;
}

 [[nodiscard]] constexpr bool is_gteq(const partial_ordering _Comp) noexcept {
    return _Comp >= 0;
}

enum _Comparison_category : unsigned char {
    _Comparison_category_none    = 1,
    _Comparison_category_partial = 2,
    _Comparison_category_weak    = 4,
    _Comparison_category_strong  = 0,
};

template <class... _Types>
inline constexpr unsigned char _Classify_category =
    _Comparison_category{(_Classify_category<_Types> | ... | _Comparison_category_strong)};
template <class _Ty>
inline constexpr unsigned char _Classify_category<_Ty> = _Comparison_category_none;
template <>
inline constexpr unsigned char _Classify_category<partial_ordering> = _Comparison_category_partial;
template <>
inline constexpr unsigned char _Classify_category<weak_ordering> = _Comparison_category_weak;
template <>
inline constexpr unsigned char _Classify_category<strong_ordering> = _Comparison_category_strong;

 template <class... _Types>
using common_comparison_category_t =
    conditional_t<(_Classify_category<_Types...> & _Comparison_category_none) != 0, void,
        conditional_t<(_Classify_category<_Types...> & _Comparison_category_partial) != 0, partial_ordering,
            conditional_t<(_Classify_category<_Types...> & _Comparison_category_weak) != 0, weak_ordering,
                strong_ordering>>>;

 template <class... _Types>
struct common_comparison_category {
    using type = common_comparison_category_t<_Types...>;
};


template <class _Ty, class _Cat>
concept _Compares_as = same_as<common_comparison_category_t<_Ty, _Cat>, _Cat>;

 template <class _Ty, class _Cat = partial_ordering>
concept three_way_comparable = _Half_equality_comparable<_Ty, _Ty> && _Half_ordered<_Ty, _Ty>
                            && requires(const remove_reference_t<_Ty>& __a, const remove_reference_t<_Ty>& __b) {
                                   { __a <=> __b } -> _Compares_as<_Cat>;
                               };

 template <class _Ty1, class _Ty2, class _Cat = partial_ordering>
concept three_way_comparable_with =
    three_way_comparable<_Ty1, _Cat> && three_way_comparable<_Ty2, _Cat>


#line 305 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\compare"
    && common_reference_with<const remove_reference_t<_Ty1>&, const remove_reference_t<_Ty2>&>
#line 307 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\compare"
    && three_way_comparable<common_reference_t<const remove_reference_t<_Ty1>&, const remove_reference_t<_Ty2>&>, _Cat>
    && _Weakly_equality_comparable_with<_Ty1, _Ty2> && _Partially_ordered_with<_Ty1, _Ty2>
    && requires(const remove_reference_t<_Ty1>& __t, const remove_reference_t<_Ty2>& __u) {
           { __t <=> __u } -> _Compares_as<_Cat>;
           { __u <=> __t } -> _Compares_as<_Cat>;
       };

 template <class _Ty1, class _Ty2 = _Ty1>
using compare_three_way_result_t =
    decltype(::std:: declval<const remove_reference_t<_Ty1>&>() <=> ::std:: declval<const remove_reference_t<_Ty2>&>());

 template <class _Ty1, class _Ty2 = _Ty1>
struct compare_three_way_result {};

template <class _Ty1, class _Ty2>
    requires requires { typename compare_three_way_result_t<_Ty1, _Ty2>; }
struct compare_three_way_result<_Ty1, _Ty2> {
    using type = compare_three_way_result_t<_Ty1, _Ty2>;
};

 struct compare_three_way {
    template <class _Ty1, class _Ty2>
        requires three_way_comparable_with<_Ty1, _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(::std:: forward<_Ty1>(_Left) <=> ::std:: forward<_Ty2>(_Right)))   {
        return ::std:: forward<_Ty1>(_Left) <=> ::std:: forward<_Ty2>(_Right);
    }

    using is_transparent = int;
};

struct _Synth_three_way {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(const _Ty1& _Left, const _Ty2& _Right) const
        requires requires {
                     { _Left < _Right } -> _Boolean_testable;
                     { _Right < _Left } -> _Boolean_testable;
                 }
    {
        if constexpr (three_way_comparable_with<_Ty1, _Ty2>) {
            return _Left <=> _Right;
        } else {
            if (_Left < _Right) {
                return weak_ordering::less;
            } else if (_Right < _Left) {
                return weak_ordering::greater;
            } else {
                return weak_ordering::equivalent;
            }
        }
    }
};

template <class _Ty1, class _Ty2 = _Ty1>
using _Synth_three_way_result = decltype(_Synth_three_way{}(::std:: declval<_Ty1&>(), ::std:: declval<_Ty2&>()));



namespace _Strong_order {


#line 369 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\compare"
    void strong_order();
#line 371 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\compare"

    template <class _Ty1, class _Ty2>
    concept _Has_ADL = requires(_Ty1& _Left, _Ty2& _Right) {
                           static_cast<strong_ordering>(strong_order(_Left, _Right)); 
                       };

    template <class _Ty1, class _Ty2>
    concept _Can_compare_three_way =
        requires(_Ty1& _Left, _Ty2& _Right) { static_cast<strong_ordering>(compare_three_way{}(_Left, _Right)); };

    class _Cpo {
    private:
        enum class _St { _None, _Adl, _Floating, _Three };

        template <class _Ty1, class _Ty2>
        [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
            if constexpr (!same_as<decay_t<_Ty1>, decay_t<_Ty2>>) {
                return {_St::_None};
            } else if constexpr (_Has_ADL<_Ty1, _Ty2>) {
                return {_St::_Adl, noexcept(static_cast<strong_ordering>(
                                       strong_order(::std:: declval<_Ty1&>(), ::std:: declval<_Ty2&>())))}; 
            } else if constexpr (floating_point<decay_t<_Ty1>>) {
                return {_St::_Floating, true};
            } else if constexpr (_Can_compare_three_way<_Ty1, _Ty2>) {
                return {_St::_Three, noexcept(static_cast<strong_ordering>(
                                         compare_three_way{}(::std:: declval<_Ty1&>(), ::std:: declval<_Ty2&>())))};
            } else {
                return {_St::_None};
            }
        }

        template <class _Ty1, class _Ty2>
        static constexpr _Choice_t<_St> _Choice = _Choose<_Ty1, _Ty2>();

    public:
        template <class _Ty1, class _Ty2>
            requires (_Choice<_Ty1&, _Ty2&>._Strategy != _St::_None)
        [[nodiscard]] constexpr strong_ordering operator()(_Ty1&& _Left, _Ty2&& _Right) const
            noexcept(_Choice<_Ty1&, _Ty2&>._No_throw) {
            constexpr _St _Strat = _Choice<_Ty1&, _Ty2&>._Strategy;
            if constexpr (_Strat == _St::_Adl) {
                return static_cast<strong_ordering>(strong_order(_Left, _Right)); 
            } else if constexpr (_Strat == _St::_Floating) {
                using _Floating_type = decay_t<_Ty1>;
                using _Traits        = _Floating_type_traits<_Floating_type>;
                using _Uint_type     = typename _Traits::_Uint_type;
                using _Sint_type     = make_signed_t<_Uint_type>;

                const auto _Left_uint  = ::std:: bit_cast<_Uint_type>(_Left);
                const auto _Right_uint = ::std:: bit_cast<_Uint_type>(_Right);

                
                if (_Left_uint == _Right_uint) {
                    return strong_ordering::equal;
                }

                
                const _Uint_type _Left_shifted_sign  = _Left_uint & _Traits::_Shifted_sign_mask;
                const _Uint_type _Right_shifted_sign = _Right_uint & _Traits::_Shifted_sign_mask;

                
                
                
                const _Uint_type _Left_sign  = _Left_shifted_sign >> _Traits::_Sign_shift;
                const _Uint_type _Right_sign = _Right_shifted_sign >> _Traits::_Sign_shift;

                const _Uint_type _Left_xor  = _Left_shifted_sign - _Left_sign;
                const _Uint_type _Right_xor = _Right_shifted_sign - _Right_sign;

                const _Uint_type _Left_ones_complement_uint  = _Left_uint ^ _Left_xor;
                const _Uint_type _Right_ones_complement_uint = _Right_uint ^ _Right_xor;

                const auto _Left_ones_complement  = static_cast<_Sint_type>(_Left_ones_complement_uint);
                const auto _Right_ones_complement = static_cast<_Sint_type>(_Right_ones_complement_uint);

                
                return _Left_ones_complement <=> _Right_ones_complement;
            } else if constexpr (_Strat == _St::_Three) {
                return static_cast<strong_ordering>(compare_three_way{}(_Left, _Right));
            } else {
                static_assert(_Always_false<_Ty1>, "should be unreachable");
            }
        }
    };
} 

inline namespace _Cpos {
     inline constexpr _Strong_order::_Cpo strong_order;
}

namespace _Weak_order {


#line 465 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\compare"
    void weak_order();
#line 467 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\compare"

    template <class _Ty1, class _Ty2>
    concept _Has_ADL = requires(_Ty1& _Left, _Ty2& _Right) {
                           static_cast<weak_ordering>(weak_order(_Left, _Right)); 
                       };

    template <class _Ty1, class _Ty2>
    concept _Can_compare_three_way =
        requires(_Ty1& _Left, _Ty2& _Right) { static_cast<weak_ordering>(compare_three_way{}(_Left, _Right)); };

    


#line 481 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\compare"
    void strong_order();
#line 483 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\compare"

    class _Cpo {
    private:
        enum class _St { _None, _Adl, _Floating, _Three, _Strong };

        template <class _Ty1, class _Ty2>
        [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
            if constexpr (!same_as<decay_t<_Ty1>, decay_t<_Ty2>>) {
                return {_St::_None};
            } else if constexpr (_Has_ADL<_Ty1, _Ty2>) {
                return {_St::_Adl, noexcept(static_cast<weak_ordering>(
                                       weak_order(::std:: declval<_Ty1&>(), ::std:: declval<_Ty2&>())))}; 
            } else if constexpr (floating_point<decay_t<_Ty1>>) {
                return {_St::_Floating, true};
            } else if constexpr (_Can_compare_three_way<_Ty1, _Ty2>) {
                return {_St::_Three, noexcept(static_cast<weak_ordering>(
                                         compare_three_way{}(::std:: declval<_Ty1&>(), ::std:: declval<_Ty2&>())))};
            } else if constexpr (_Strong_order::_Has_ADL<_Ty1, _Ty2>) {
                
                return {_St::_Strong, noexcept(static_cast<weak_ordering>(static_cast<strong_ordering>(strong_order(
                                          ::std:: declval<_Ty1&>(), ::std:: declval<_Ty2&>()))))}; 
            } else {
                return {_St::_None};
            }
        }

        template <class _Ty1, class _Ty2>
        static constexpr _Choice_t<_St> _Choice = _Choose<_Ty1, _Ty2>();

    public:
        template <class _Ty1, class _Ty2>
            requires (_Choice<_Ty1&, _Ty2&>._Strategy != _St::_None)
        [[nodiscard]] constexpr weak_ordering operator()(_Ty1&& _Left, _Ty2&& _Right) const
            noexcept(_Choice<_Ty1&, _Ty2&>._No_throw) {
            constexpr _St _Strat = _Choice<_Ty1&, _Ty2&>._Strategy;
            if constexpr (_Strat == _St::_Adl) {
                return static_cast<weak_ordering>(weak_order(_Left, _Right)); 
            } else if constexpr (_Strat == _St::_Floating) {
                using _Floating_type = decay_t<_Ty1>;
                using _Traits        = _Floating_type_traits<_Floating_type>;
                using _Uint_type     = typename _Traits::_Uint_type;
                using _Sint_type     = make_signed_t<_Uint_type>;

                auto _Left_uint  = ::std:: bit_cast<_Uint_type>(_Left);
                auto _Right_uint = ::std:: bit_cast<_Uint_type>(_Right);

                
                if (_Left_uint == _Right_uint) {
                    return weak_ordering::equivalent;
                }

                
                const _Uint_type _Left_shifted_sign  = _Left_uint & _Traits::_Shifted_sign_mask;
                const _Uint_type _Right_shifted_sign = _Right_uint & _Traits::_Shifted_sign_mask;

                
                
                constexpr _Uint_type _Infinity_plus_one = _Traits::_Shifted_exponent_mask + 1;

                const _Uint_type _Left_magnitude  = _Left_uint & ~_Traits::_Shifted_sign_mask;
                const _Uint_type _Right_magnitude = _Right_uint & ~_Traits::_Shifted_sign_mask;

                if (_Left_magnitude > _Infinity_plus_one) {
                    _Left_uint = _Left_shifted_sign | _Infinity_plus_one;
                }

                if (_Right_magnitude > _Infinity_plus_one) {
                    _Right_uint = _Right_shifted_sign | _Infinity_plus_one;
                }

                
                
                
                const _Uint_type _Left_sign  = _Left_shifted_sign >> _Traits::_Sign_shift;
                const _Uint_type _Right_sign = _Right_shifted_sign >> _Traits::_Sign_shift;

                const _Uint_type _Left_xor  = _Left_shifted_sign - _Left_sign;
                const _Uint_type _Right_xor = _Right_shifted_sign - _Right_sign;

                const _Uint_type _Left_twos_complement_uint  = (_Left_uint ^ _Left_xor) + _Left_sign;
                const _Uint_type _Right_twos_complement_uint = (_Right_uint ^ _Right_xor) + _Right_sign;

                const auto _Left_twos_complement  = static_cast<_Sint_type>(_Left_twos_complement_uint);
                const auto _Right_twos_complement = static_cast<_Sint_type>(_Right_twos_complement_uint);

                
                return static_cast<weak_ordering>(_Left_twos_complement <=> _Right_twos_complement);
            } else if constexpr (_Strat == _St::_Three) {
                return static_cast<weak_ordering>(compare_three_way{}(_Left, _Right));
            } else if constexpr (_Strat == _St::_Strong) {
                
                return static_cast<weak_ordering>(
                    static_cast<strong_ordering>(strong_order(_Left, _Right))); 
            } else {
                static_assert(_Always_false<_Ty1>, "should be unreachable");
            }
        }
    };
} 

inline namespace _Cpos {
     inline constexpr _Weak_order::_Cpo weak_order;
}

namespace _Partial_order {


#line 591 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\compare"
    void partial_order();
#line 593 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\compare"

    template <class _Ty1, class _Ty2>
    concept _Has_ADL = requires(_Ty1& _Left, _Ty2& _Right) {
                           static_cast<partial_ordering>(partial_order(_Left, _Right)); 
                       };

    template <class _Ty1, class _Ty2>
    concept _Can_compare_three_way =
        requires(_Ty1& _Left, _Ty2& _Right) { static_cast<partial_ordering>(compare_three_way{}(_Left, _Right)); };

    
    



#line 609 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\compare"
    void weak_order();
    void strong_order();
#line 612 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\compare"

    class _Cpo {
    private:
        enum class _St { _None, _Adl, _Three, _Weak, _Strong };

        template <class _Ty1, class _Ty2>
        [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
            if constexpr (!same_as<decay_t<_Ty1>, decay_t<_Ty2>>) {
                return {_St::_None};
            } else if constexpr (_Has_ADL<_Ty1, _Ty2>) {
                return {_St::_Adl, noexcept(static_cast<partial_ordering>(partial_order(
                                       ::std:: declval<_Ty1&>(), ::std:: declval<_Ty2&>())))}; 
            } else if constexpr (_Can_compare_three_way<_Ty1, _Ty2>) {
                return {_St::_Three, noexcept(static_cast<partial_ordering>(
                                         compare_three_way{}(::std:: declval<_Ty1&>(), ::std:: declval<_Ty2&>())))};
            } else if constexpr (_Weak_order::_Has_ADL<_Ty1, _Ty2>) {
                
                return {_St::_Weak, noexcept(static_cast<partial_ordering>(static_cast<weak_ordering>(
                                        weak_order(::std:: declval<_Ty1&>(), ::std:: declval<_Ty2&>()))))}; 
            } else if constexpr (_Strong_order::_Has_ADL<_Ty1, _Ty2>) {
                
                return {_St::_Strong, noexcept(static_cast<partial_ordering>(static_cast<strong_ordering>(strong_order(
                                          ::std:: declval<_Ty1&>(), ::std:: declval<_Ty2&>()))))}; 
            } else {
                return {_St::_None};
            }
        }

        template <class _Ty1, class _Ty2>
        static constexpr _Choice_t<_St> _Choice = _Choose<_Ty1, _Ty2>();

    public:
        template <class _Ty1, class _Ty2>
            requires (_Choice<_Ty1&, _Ty2&>._Strategy != _St::_None)
        [[nodiscard]] constexpr partial_ordering operator()(_Ty1&& _Left, _Ty2&& _Right) const
            noexcept(_Choice<_Ty1&, _Ty2&>._No_throw) {
            constexpr _St _Strat = _Choice<_Ty1&, _Ty2&>._Strategy;
            if constexpr (_Strat == _St::_Adl) {
                return static_cast<partial_ordering>(  partial_order(_Left, _Right));
            } else if constexpr (_Strat == _St::_Three) {
                return static_cast<partial_ordering>(compare_three_way{}(_Left, _Right));
            } else if constexpr (_Strat == _St::_Weak) {
                
                return static_cast<partial_ordering>(
                    static_cast<weak_ordering>(weak_order(_Left, _Right))); 
            } else if constexpr (_Strat == _St::_Strong) {
                
                return static_cast<partial_ordering>(
                    static_cast<strong_ordering>(strong_order(_Left, _Right))); 
            } else {
                static_assert(_Always_false<_Ty1>, "should be unreachable");
            }
        }
    };
} 

inline namespace _Cpos {
     inline constexpr _Partial_order::_Cpo partial_order;
}

template <class _Ty1, class _Ty2>
concept _Can_fallback_eq_lt = requires(_Ty1& _Left, _Ty2& _Right) {
                                  { _Left == _Right } -> _Boolean_testable;
                                  { _Left < _Right } -> _Boolean_testable;
                              };

template <class _Ty1, class _Ty2>
concept _Can_strong_order = requires(_Ty1& _Left, _Ty2& _Right) { ::std:: strong_order(_Left, _Right); };

namespace _Compare_strong_order_fallback {
    class _Cpo {
    private:
        enum class _St { _None, _Strong, _Fallback };

        template <class _Ty1, class _Ty2>
        [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
            if constexpr (!same_as<decay_t<_Ty1>, decay_t<_Ty2>>) {
                return {_St::_None};
            } else if constexpr (_Can_strong_order<_Ty1, _Ty2>) {
                return {_St::_Strong, noexcept(::std:: strong_order(::std:: declval<_Ty1&>(), ::std:: declval<_Ty2&>()))};
            } else if constexpr (_Can_fallback_eq_lt<_Ty1, _Ty2>) {
                return {_St::_Fallback,
                    noexcept(::std:: declval<_Ty1&>() == ::std:: declval<_Ty2&>()  ? strong_ordering::equal
                             : ::std:: declval<_Ty1&>() < ::std:: declval<_Ty2&>() ? strong_ordering::less
                                                                             : strong_ordering::greater)};
            } else {
                return {_St::_None};
            }
        }

        template <class _Ty1, class _Ty2>
        static constexpr _Choice_t<_St> _Choice = _Choose<_Ty1, _Ty2>();

    public:
        template <class _Ty1, class _Ty2>
            requires (_Choice<_Ty1&, _Ty2&>._Strategy != _St::_None)
        [[nodiscard]] constexpr strong_ordering operator()(_Ty1&& _Left, _Ty2&& _Right) const
            noexcept(_Choice<_Ty1&, _Ty2&>._No_throw) {
            constexpr _St _Strat = _Choice<_Ty1&, _Ty2&>._Strategy;
            if constexpr (_Strat == _St::_Strong) {
                return ::std:: strong_order(_Left, _Right);
            } else if constexpr (_Strat == _St::_Fallback) {
                return _Left == _Right ? strong_ordering::equal
                     : _Left < _Right  ? strong_ordering::less
                                       : strong_ordering::greater;
            } else {
                static_assert(_Always_false<_Ty1>, "should be unreachable");
            }
        }
    };
} 

inline namespace _Cpos {
     inline constexpr _Compare_strong_order_fallback::_Cpo compare_strong_order_fallback;
}

template <class _Ty1, class _Ty2>
concept _Can_weak_order = requires(_Ty1& _Left, _Ty2& _Right) { ::std:: weak_order(_Left, _Right); };

namespace _Compare_weak_order_fallback {
    class _Cpo {
    private:
        enum class _St { _None, _Weak, _Fallback };

        template <class _Ty1, class _Ty2>
        [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
            if constexpr (!same_as<decay_t<_Ty1>, decay_t<_Ty2>>) {
                return {_St::_None};
            } else if constexpr (_Can_weak_order<_Ty1, _Ty2>) {
                return {_St::_Weak, noexcept(::std:: weak_order(::std:: declval<_Ty1&>(), ::std:: declval<_Ty2&>()))};
            } else if constexpr (_Can_fallback_eq_lt<_Ty1, _Ty2>) {
                return {
                    _St::_Fallback, noexcept(::std:: declval<_Ty1&>() == ::std:: declval<_Ty2&>()  ? weak_ordering::equivalent
                                             : ::std:: declval<_Ty1&>() < ::std:: declval<_Ty2&>() ? weak_ordering::less
                                                                                             : weak_ordering::greater)};
            } else {
                return {_St::_None};
            }
        }

        template <class _Ty1, class _Ty2>
        static constexpr _Choice_t<_St> _Choice = _Choose<_Ty1, _Ty2>();

    public:
        template <class _Ty1, class _Ty2>
            requires (_Choice<_Ty1&, _Ty2&>._Strategy != _St::_None)
        [[nodiscard]] constexpr weak_ordering operator()(_Ty1&& _Left, _Ty2&& _Right) const
            noexcept(_Choice<_Ty1&, _Ty2&>._No_throw) {
            constexpr _St _Strat = _Choice<_Ty1&, _Ty2&>._Strategy;
            if constexpr (_Strat == _St::_Weak) {
                return ::std:: weak_order(_Left, _Right);
            } else if constexpr (_Strat == _St::_Fallback) {
                return _Left == _Right ? weak_ordering::equivalent
                     : _Left < _Right  ? weak_ordering::less
                                       : weak_ordering::greater;
            } else {
                static_assert(_Always_false<_Ty1>, "should be unreachable");
            }
        }
    };
} 

inline namespace _Cpos {
     inline constexpr _Compare_weak_order_fallback::_Cpo compare_weak_order_fallback;
}

template <class _Ty1, class _Ty2>
concept _Can_partial_order = requires(_Ty1& _Left, _Ty2& _Right) { ::std:: partial_order(_Left, _Right); };

namespace _Compare_partial_order_fallback {
    template <class _Ty1, class _Ty2>
    concept _Can_fallback_eq_lt_twice = requires(_Ty1& _Left, _Ty2& _Right) {
                                            { _Left == _Right } -> _Boolean_testable;
                                            { _Left < _Right } -> _Boolean_testable;
                                            { _Right < _Left } -> _Boolean_testable;
                                        };

    class _Cpo {
    private:
        enum class _St { _None, _Partial, _Fallback };

        template <class _Ty1, class _Ty2>
        [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
            if constexpr (!same_as<decay_t<_Ty1>, decay_t<_Ty2>>) {
                return {_St::_None};
            } else if constexpr (_Can_partial_order<_Ty1, _Ty2>) {
                return {_St::_Partial, noexcept(::std:: partial_order(::std:: declval<_Ty1&>(), ::std:: declval<_Ty2&>()))};
            } else if constexpr (_Can_fallback_eq_lt_twice<_Ty1, _Ty2>) {
                return {_St::_Fallback,
                    noexcept(::std:: declval<_Ty1&>() == ::std:: declval<_Ty2&>()  ? partial_ordering::equivalent
                             : ::std:: declval<_Ty1&>() < ::std:: declval<_Ty2&>() ? partial_ordering::less
                             : ::std:: declval<_Ty2&>() < ::std:: declval<_Ty1&>() ? partial_ordering::greater
                                                                             : partial_ordering::unordered)};
            } else {
                return {_St::_None};
            }
        }

        template <class _Ty1, class _Ty2>
        static constexpr _Choice_t<_St> _Choice = _Choose<_Ty1, _Ty2>();

    public:
        template <class _Ty1, class _Ty2>
            requires (_Choice<_Ty1&, _Ty2&>._Strategy != _St::_None)
        [[nodiscard]] constexpr partial_ordering operator()(_Ty1&& _Left, _Ty2&& _Right) const
            noexcept(_Choice<_Ty1&, _Ty2&>._No_throw) {
            constexpr _St _Strat = _Choice<_Ty1&, _Ty2&>._Strategy;
            if constexpr (_Strat == _St::_Partial) {
                return ::std:: partial_order(_Left, _Right);
            } else if constexpr (_Strat == _St::_Fallback) {
                return _Left == _Right ? partial_ordering::equivalent
                     : _Left < _Right  ? partial_ordering::less
                     : _Right < _Left  ? partial_ordering::greater
                                       : partial_ordering::unordered;
            } else {
                static_assert(_Always_false<_Ty1>, "should be unreachable");
            }
        }
    };
} 

inline namespace _Cpos {
     inline constexpr _Compare_partial_order_fallback::_Cpo compare_partial_order_fallback;
}

#line 838 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\compare"
}



#pragma warning(pop)
#pragma pack(pop)
#line 845 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\compare"

#line 847 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\compare"
#line 848 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\compare"
#pragma external_header(pop)
#line 20 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"
#line 21 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"

#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




namespace std {
 template <class _Ty, class _Pr>
[[nodiscard]] constexpr const _Ty&(max) (const _Ty& _Left, const _Ty& _Right, _Pr _Pred) noexcept(
    noexcept(_Pred(_Left, _Right)))   {
    
    return _Pred(_Left, _Right) ? _Right : _Left;
}

#pragma warning(push)
#pragma warning(disable : 28285) 
 template <class _Ty>
[[nodiscard]]  constexpr const _Ty& 
    (max) (const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Left < _Right))   {
    
    return _Left < _Right ? _Right : _Left;
}
#pragma warning(pop)

 template <class _Ty, class _Pr>
[[nodiscard]] constexpr _Ty(max)(initializer_list<_Ty>, _Pr); 

 template <class _Ty>
[[nodiscard]] constexpr _Ty(max)(initializer_list<_Ty>); 

 template <class _Ty, class _Pr>
[[nodiscard]] constexpr const _Ty&(min) (const _Ty& _Left, const _Ty& _Right, _Pr _Pred) noexcept(
    noexcept(_Pred(_Right, _Left)))   {
    
    return _Pred(_Right, _Left) ? _Right : _Left;
}

#pragma warning(push)
#pragma warning(disable : 28285) 
 template <class _Ty>
[[nodiscard]]  constexpr const _Ty& 
    (min) (const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Right < _Left))   {
    
    return _Right < _Left ? _Right : _Left;
}
#pragma warning(pop)

 template <class _Ty, class _Pr>
[[nodiscard]] constexpr _Ty(min)(initializer_list<_Ty>, _Pr); 

 template <class _Ty>
[[nodiscard]] constexpr _Ty(min)(initializer_list<_Ty>); 

 template <class _FwdIt1, class _FwdIt2>
constexpr void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right) { 
    swap(*_Left, *_Right);
}

 template <class _Ty, size_t _Size, enable_if_t<_Is_swappable<_Ty>::value, int> _Enabled>
constexpr void swap(_Ty (&_Left)[_Size], _Ty (&_Right)[_Size]) noexcept(_Is_nothrow_swappable<_Ty>::value) {
    if (&_Left != &_Right) {
        _Ty* _First1 = _Left;
        _Ty* _Last1  = _First1 + _Size;
        _Ty* _First2 = _Right;
        for (; _First1 != _Last1; ++_First1, ++_First2) {
            ::std:: iter_swap(_First1, _First2);
        }
    }
}


 template <class _Ty, enable_if_t<is_move_constructible_v<_Ty> && is_move_assignable_v<_Ty>, int> _Enabled>


#line 98 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"
constexpr void swap(_Ty& _Left, _Ty& _Right) noexcept(
    is_nothrow_move_constructible_v<_Ty>&& is_nothrow_move_assignable_v<_Ty>) {
    _Ty _Tmp = ::std:: move(_Left);
    _Left    = ::std:: move(_Right);
    _Right   = ::std:: move(_Tmp);
}

template <class _Ty>
constexpr void _Swap_adl(_Ty& _Left, _Ty& _Right) noexcept(_Is_nothrow_swappable<_Ty>::value) {
    swap(_Left, _Right);
}

 struct piecewise_construct_t { 
    explicit piecewise_construct_t() = default;
};

 inline constexpr piecewise_construct_t piecewise_construct{};

template <class _Ty, class _Alloc, class = void>
struct _Has_allocator_type : false_type {}; 

template <class _Ty, class _Alloc>
struct _Has_allocator_type<_Ty, _Alloc, void_t<typename _Ty::allocator_type>>
    : is_convertible<_Alloc, typename _Ty::allocator_type>::type {}; 

 struct allocator_arg_t { 
    explicit allocator_arg_t() = default;
};

 inline constexpr allocator_arg_t allocator_arg{};

 template <class _Ty, class _Alloc>
struct uses_allocator : _Has_allocator_type<_Ty, _Alloc>::type {
    
};

 template <class _Ty, class _Alloc>
inline constexpr bool uses_allocator_v = uses_allocator<_Ty, _Alloc>::value;

 template <class... _Types>
class tuple;

 template <class _Ty1, class _Ty2>
struct pair;

 template <class _Ty, size_t _Size>
class array;

 template <class _Tuple>
struct tuple_size;

 template <class _Ty>
inline constexpr size_t tuple_size_v = tuple_size<_Ty>::value;

 template <size_t _Index, class _Tuple>
struct tuple_element;

 template <size_t _Index, class _Tuple>
using tuple_element_t = typename tuple_element<_Index, _Tuple>::type;

   template <size_t _Index, class... _Types>
[[nodiscard]] constexpr auto&& _Tuple_get(tuple<_Types...>&& _Tuple) noexcept;

 template <size_t _Index, class... _Types>
[[nodiscard]] constexpr tuple_element_t<_Index, tuple<_Types...>>& get(tuple<_Types...>& _Tuple) noexcept;

 template <size_t _Index, class... _Types>
[[nodiscard]] constexpr const tuple_element_t<_Index, tuple<_Types...>>& get(const tuple<_Types...>& _Tuple) noexcept;

 template <size_t _Index, class... _Types>
[[nodiscard]] constexpr tuple_element_t<_Index, tuple<_Types...>>&& get(tuple<_Types...>&& _Tuple) noexcept;

 template <size_t _Index, class... _Types>
[[nodiscard]] constexpr const tuple_element_t<_Index, tuple<_Types...>>&& get(const tuple<_Types...>&& _Tuple) noexcept;

 template <size_t _Idx, class _Ty, size_t _Size>
[[nodiscard]] constexpr _Ty& get(array<_Ty, _Size>& _Arr) noexcept;

 template <size_t _Idx, class _Ty, size_t _Size>
[[nodiscard]] constexpr const _Ty& get(const array<_Ty, _Size>& _Arr) noexcept;

 template <size_t _Idx, class _Ty, size_t _Size>
[[nodiscard]] constexpr _Ty&& get(array<_Ty, _Size>&& _Arr) noexcept;

 template <size_t _Idx, class _Ty, size_t _Size>
[[nodiscard]] constexpr const _Ty&& get(const array<_Ty, _Size>&& _Arr) noexcept;


template <class _Ty1, class _Ty2>
concept _Different_from = (!same_as<remove_cvref_t<_Ty1>, remove_cvref_t<_Ty2>>);

template <class>
inline constexpr bool _Is_std_array_v = false;

template <class _Ty, size_t _Size>
inline constexpr bool _Is_std_array_v<array<_Ty, _Size>> = true;

template <class>
inline constexpr bool _Is_subrange_v = false;


















#line 216 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"
#line 217 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"

 template <class _Ty1, class _Ty2>
struct pair { 
    using first_type  = _Ty1;
    using second_type = _Ty2;

    template <class _Uty1 = _Ty1, class _Uty2 = _Ty2,
        enable_if_t<conjunction_v<is_default_constructible<_Uty1>, is_default_constructible<_Uty2>>, int> = 0>
    constexpr explicit(
        !conjunction_v<_Is_implicitly_default_constructible<_Uty1>, _Is_implicitly_default_constructible<_Uty2>>)
        pair() noexcept(
            is_nothrow_default_constructible_v<_Uty1>&& is_nothrow_default_constructible_v<_Uty2>) 
        : first(), second() {}

    template <class _Uty1 = _Ty1, class _Uty2 = _Ty2,
        enable_if_t<conjunction_v<is_copy_constructible<_Uty1>, is_copy_constructible<_Uty2>>, int> = 0>
    constexpr explicit(!conjunction_v<is_convertible<const _Uty1&, _Uty1>, is_convertible<const _Uty2&, _Uty2>>)
        pair(const _Ty1& _Val1, const _Ty2& _Val2) noexcept(
            is_nothrow_copy_constructible_v<_Uty1>&& is_nothrow_copy_constructible_v<_Uty2>) 
        : first(_Val1), second(_Val2) {}



#line 241 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"
    template <class _Other1, class _Other2,
#line 243 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"
        enable_if_t<conjunction_v<is_constructible<_Ty1, _Other1>, is_constructible<_Ty2, _Other2>>, int> = 0>
    constexpr explicit(!conjunction_v<is_convertible<_Other1, _Ty1>, is_convertible<_Other2, _Ty2>>)
        pair(_Other1&& _Val1, _Other2&& _Val2) noexcept(
            is_nothrow_constructible_v<_Ty1, _Other1>&& is_nothrow_constructible_v<_Ty2, _Other2>) 
        : first(::std:: forward<_Other1>(_Val1)), second(::std:: forward<_Other2>(_Val2)) {
    }

    pair(const pair&) = default;
    pair(pair&&)      = default;








#line 261 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"

    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<is_constructible<_Ty1, const _Other1&>, is_constructible<_Ty2, const _Other2&>>,
            int> = 0>
    constexpr explicit(!conjunction_v<is_convertible<const _Other1&, _Ty1>, is_convertible<const _Other2&, _Ty2>>)
        pair(const pair<_Other1, _Other2>& _Right) noexcept(is_nothrow_constructible_v<_Ty1, const _Other1&>&&
                is_nothrow_constructible_v<_Ty2, const _Other2&>) 
        : first(_Right.first), second(_Right.second) {}

    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<is_constructible<_Ty1, _Other1>, is_constructible<_Ty2, _Other2>>, int> = 0>
    constexpr explicit(!conjunction_v<is_convertible<_Other1, _Ty1>, is_convertible<_Other2, _Ty2>>)
        pair(pair<_Other1, _Other2>&& _Right) noexcept(
            is_nothrow_constructible_v<_Ty1, _Other1>&& is_nothrow_constructible_v<_Ty2, _Other2>) 
        : first(::std:: forward<_Other1>(_Right.first)), second(::std:: forward<_Other2>(_Right.second)) {}

























#line 302 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"

    template <class _Tuple1, class _Tuple2, size_t... _Indices1, size_t... _Indices2>
    constexpr pair(_Tuple1& _Val1, _Tuple2& _Val2, index_sequence<_Indices1...>, index_sequence<_Indices2...>)
        : first(_Tuple_get<_Indices1>(::std:: move(_Val1))...), second(_Tuple_get<_Indices2>(::std:: move(_Val2))...) {}

    template <class... _Types1, class... _Types2>
    constexpr pair(piecewise_construct_t, tuple<_Types1...> _Val1, tuple<_Types2...> _Val2)
        : pair(_Val1, _Val2, index_sequence_for<_Types1...>{}, index_sequence_for<_Types2...>{}) {}

    pair& operator=(const volatile pair&) = delete;

    template <class _Myself = pair,
        enable_if_t<conjunction_v<_Is_copy_assignable_no_precondition_check<typename _Myself::first_type>,
                        _Is_copy_assignable_no_precondition_check<typename _Myself::second_type>>,
            int>            = 0>
    constexpr pair& operator=(_Identity_t<const _Myself&> _Right) noexcept(
        conjunction_v<is_nothrow_copy_assignable<_Ty1>, is_nothrow_copy_assignable<_Ty2>>)   {
        first  = _Right.first;
        second = _Right.second;
        return *this;
    }













#line 337 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"

    template <class _Myself = pair,
        enable_if_t<conjunction_v<_Is_move_assignable_no_precondition_check<typename _Myself::first_type>,
                        _Is_move_assignable_no_precondition_check<typename _Myself::second_type>>,
            int>            = 0>
    constexpr pair& operator=(_Identity_t<_Myself&&> _Right) noexcept(
        conjunction_v<is_nothrow_move_assignable<_Ty1>, is_nothrow_move_assignable<_Ty2>>)   {
        first  = ::std:: forward<_Ty1>(_Right.first);
        second = ::std:: forward<_Ty2>(_Right.second);
        return *this;
    }













#line 362 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"

    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<negation<is_same<pair, pair<_Other1, _Other2>>>, is_assignable<_Ty1&, const _Other1&>,
                        is_assignable<_Ty2&, const _Other2&>>,
            int> = 0>
    constexpr pair& operator=(const pair<_Other1, _Other2>& _Right) noexcept(
        is_nothrow_assignable_v<_Ty1&, const _Other1&>&&
            is_nothrow_assignable_v<_Ty2&, const _Other2&>)   {
        first  = _Right.first;
        second = _Right.second;
        return *this;
    }













#line 388 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"

    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<negation<is_same<pair, pair<_Other1, _Other2>>>, is_assignable<_Ty1&, _Other1>,
                        is_assignable<_Ty2&, _Other2>>,
            int> = 0>
    constexpr pair& operator=(pair<_Other1, _Other2>&& _Right) noexcept(
        is_nothrow_assignable_v<_Ty1&, _Other1>&& is_nothrow_assignable_v<_Ty2&, _Other2>)   {
        first  = ::std:: forward<_Other1>(_Right.first);
        second = ::std:: forward<_Other2>(_Right.second);
        return *this;
    }







































#line 439 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"

    constexpr void swap(pair& _Right) noexcept(
        _Is_nothrow_swappable<_Ty1>::value&& _Is_nothrow_swappable<_Ty2>::value) {
        if (this != ::std:: addressof(_Right)) {
            _Swap_adl(first, _Right.first);
            _Swap_adl(second, _Right.second);
        }
    }










#line 458 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"

    _Ty1 first; 
    _Ty2 second; 
};


template <class _Ty1, class _Ty2>
pair(_Ty1, _Ty2) -> pair<_Ty1, _Ty2>;
#line 467 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"

 template <class _Ty1, class _Ty2,
    enable_if_t<_Is_swappable<_Ty1>::value && _Is_swappable<_Ty2>::value, int> = 0>
constexpr void swap(pair<_Ty1, _Ty2>& _Left, pair<_Ty1, _Ty2>& _Right) noexcept(noexcept(_Left.swap(_Right))) {
    _Left.swap(_Right);
}








#line 482 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"

 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool operator==(const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right) {
    return _Left.first == _Right.first && _Left.second == _Right.second;
}


 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr common_comparison_category_t<_Synth_three_way_result<_Ty1>, _Synth_three_way_result<_Ty2>>
    operator<=>(const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right) {
    if (auto _Result = _Synth_three_way{}(_Left.first, _Right.first); _Result != 0) {
        return _Result;
    }
    return _Synth_three_way{}(_Left.second, _Right.second);
}



























#line 525 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"


template <class _Ty1, class _Ty2, class _Uty1, class _Uty2, template <class> class _TQual,
    template <class> class _UQual>
    requires requires {
                 typename pair<common_reference_t<_TQual<_Ty1>, _UQual<_Uty1>>,
                     common_reference_t<_TQual<_Ty2>, _UQual<_Uty2>>>;
             }
struct basic_common_reference<pair<_Ty1, _Ty2>, pair<_Uty1, _Uty2>, _TQual, _UQual> {
    using type = pair<common_reference_t<_TQual<_Ty1>, _UQual<_Uty1>>, common_reference_t<_TQual<_Ty2>, _UQual<_Uty2>>>;
};

template <class _Ty1, class _Ty2, class _Uty1, class _Uty2>
    requires requires { typename pair<common_type_t<_Ty1, _Uty1>, common_type_t<_Ty2, _Uty2>>; }
struct common_type<pair<_Ty1, _Ty2>, pair<_Uty1, _Uty2>> {
    using type = pair<common_type_t<_Ty1, _Uty1>, common_type_t<_Ty2, _Uty2>>;
};
#line 543 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"

template <class _Ty>
struct _Unrefwrap_helper { 
    using type = _Ty;
};

template <class _Ty>
struct _Unrefwrap_helper<reference_wrapper<_Ty>> { 
    using type = _Ty&;
};


template <class _Ty>
using _Unrefwrap_t = typename _Unrefwrap_helper<decay_t<_Ty>>::type;

 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr pair<_Unrefwrap_t<_Ty1>, _Unrefwrap_t<_Ty2>> make_pair(_Ty1&& _Val1, _Ty2&& _Val2) noexcept(
    is_nothrow_constructible_v<_Unrefwrap_t<_Ty1>, _Ty1>&&
        is_nothrow_constructible_v<_Unrefwrap_t<_Ty2>, _Ty2>)   {
    
    using _Mypair = pair<_Unrefwrap_t<_Ty1>, _Unrefwrap_t<_Ty2>>;
    return _Mypair(::std:: forward<_Ty1>(_Val1), ::std:: forward<_Ty2>(_Val2));
}

namespace [[deprecated("warning STL4027: " "The namespace std::rel_ops and its contents are deprecated in C++20. " "Their use is superseded by C++20's <=> operator and automatic rewrites of relational expressions. " "You can define _SILENCE_CXX20_REL_OPS_DEPRECATION_WARNING or " "_SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] rel_ops {
     template <class _Ty>
    [[deprecated("warning STL4027: " "The namespace std::rel_ops and its contents are deprecated in C++20. " "Their use is superseded by C++20's <=> operator and automatic rewrites of relational expressions. " "You can define _SILENCE_CXX20_REL_OPS_DEPRECATION_WARNING or " "_SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] [[nodiscard]] bool operator!=(const _Ty& _Left, const _Ty& _Right) {
        return !(_Left == _Right);
    }

     template <class _Ty>
    [[deprecated("warning STL4027: " "The namespace std::rel_ops and its contents are deprecated in C++20. " "Their use is superseded by C++20's <=> operator and automatic rewrites of relational expressions. " "You can define _SILENCE_CXX20_REL_OPS_DEPRECATION_WARNING or " "_SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] [[nodiscard]] bool operator>(const _Ty& _Left, const _Ty& _Right) {
        return _Right < _Left;
    }

     template <class _Ty>
    [[deprecated("warning STL4027: " "The namespace std::rel_ops and its contents are deprecated in C++20. " "Their use is superseded by C++20's <=> operator and automatic rewrites of relational expressions. " "You can define _SILENCE_CXX20_REL_OPS_DEPRECATION_WARNING or " "_SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] [[nodiscard]] bool operator<=(const _Ty& _Left, const _Ty& _Right) {
        return !(_Right < _Left);
    }

     template <class _Ty>
    [[deprecated("warning STL4027: " "The namespace std::rel_ops and its contents are deprecated in C++20. " "Their use is superseded by C++20's <=> operator and automatic rewrites of relational expressions. " "You can define _SILENCE_CXX20_REL_OPS_DEPRECATION_WARNING or " "_SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] [[nodiscard]] bool operator>=(const _Ty& _Left, const _Ty& _Right) {
        return !(_Left < _Right);
    }
} 

template <class _Tuple, class = void>
struct _Tuple_size_sfinae {}; 

template <class _Tuple>
struct _Tuple_size_sfinae<_Tuple, void_t<decltype(tuple_size<_Tuple>::value)>>
    : integral_constant<size_t, tuple_size<_Tuple>::value> {}; 

template <class _Tuple>
struct tuple_size<const _Tuple> : _Tuple_size_sfinae<_Tuple> {}; 

template <class _Tuple>
struct [[deprecated("warning STL4030: " "Some operations on volatile-qualified types in the STL are deprecated in C++20. " "You can define _SILENCE_CXX20_VOLATILE_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] tuple_size<volatile _Tuple> : _Tuple_size_sfinae<_Tuple> {}; 

template <class _Tuple>
struct [[deprecated("warning STL4030: " "Some operations on volatile-qualified types in the STL are deprecated in C++20. " "You can define _SILENCE_CXX20_VOLATILE_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] tuple_size<const volatile _Tuple> : _Tuple_size_sfinae<_Tuple> {}; 

template <size_t _Index, class _Tuple>
struct [[msvc::known_semantics]] tuple_element<_Index, const _Tuple> : tuple_element<_Index, _Tuple> {
    using _Mybase = tuple_element<_Index, _Tuple>;
    using type    = add_const_t<typename _Mybase::type>;
};

template <size_t _Index, class _Tuple>
struct [[deprecated("warning STL4030: " "Some operations on volatile-qualified types in the STL are deprecated in C++20. " "You can define _SILENCE_CXX20_VOLATILE_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] [[msvc::known_semantics]] tuple_element<_Index, volatile _Tuple>
    : tuple_element<_Index, _Tuple> {
    using _Mybase = tuple_element<_Index, _Tuple>;
    using type    = add_volatile_t<typename _Mybase::type>;
};

template <size_t _Index, class _Tuple>
struct [[deprecated("warning STL4030: " "Some operations on volatile-qualified types in the STL are deprecated in C++20. " "You can define _SILENCE_CXX20_VOLATILE_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] [[msvc::known_semantics]] tuple_element<_Index, const volatile _Tuple>
    : tuple_element<_Index, _Tuple> {
    using _Mybase = tuple_element<_Index, _Tuple>;
    using type    = add_cv_t<typename _Mybase::type>;
};

template <class _Ty, size_t _Size>
struct tuple_size<array<_Ty, _Size>> : integral_constant<size_t, _Size> {}; 

template <size_t _Idx, class _Ty, size_t _Size>
struct [[msvc::known_semantics]] tuple_element<_Idx, array<_Ty, _Size>> {
    static_assert(_Idx < _Size, "array index out of bounds");

    using type = _Ty;
};

template <class... _Types>
struct tuple_size<tuple<_Types...>> : integral_constant<size_t, sizeof...(_Types)> {}; 

template <size_t _Index>
struct [[msvc::known_semantics]] tuple_element<_Index, tuple<>> { 
    static_assert(_Always_false<integral_constant<size_t, _Index>>, "tuple index out of bounds");
};

template <class _This, class... _Rest>
struct [[msvc::known_semantics]] tuple_element<0, tuple<_This, _Rest...>> { 
    using type = _This;
    
    using _Ttype = tuple<_This, _Rest...>;
};

template <size_t _Index, class _This, class... _Rest>
struct [[msvc::known_semantics]] tuple_element<_Index, tuple<_This, _Rest...>>
    : tuple_element<_Index - 1, tuple<_Rest...>> {}; 

template <class _Ty1, class _Ty2>
struct tuple_size<pair<_Ty1, _Ty2>> : integral_constant<size_t, 2> {}; 

template <size_t _Idx, class _Ty1, class _Ty2>
struct [[msvc::known_semantics]] tuple_element<_Idx, pair<_Ty1, _Ty2>> {
    static_assert(_Idx < 2, "pair index out of bounds");

    using type = conditional_t<_Idx == 0, _Ty1, _Ty2>;
};

 template <size_t _Idx, class _Ty1, class _Ty2>
[[nodiscard]] constexpr tuple_element_t<_Idx, pair<_Ty1, _Ty2>>& get(pair<_Ty1, _Ty2>& _Pr) noexcept {
    
    if constexpr (_Idx == 0) {
        return _Pr.first;
    } else {
        return _Pr.second;
    }
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr _Ty1& get(pair<_Ty1, _Ty2>& _Pr) noexcept {
    
    return _Pr.first;
}

 template <class _Ty2, class _Ty1>
[[nodiscard]] constexpr _Ty2& get(pair<_Ty1, _Ty2>& _Pr) noexcept {
    
    return _Pr.second;
}

 template <size_t _Idx, class _Ty1, class _Ty2>
[[nodiscard]] constexpr const tuple_element_t<_Idx, pair<_Ty1, _Ty2>>& get(const pair<_Ty1, _Ty2>& _Pr) noexcept {
    
    if constexpr (_Idx == 0) {
        return _Pr.first;
    } else {
        return _Pr.second;
    }
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr const _Ty1& get(const pair<_Ty1, _Ty2>& _Pr) noexcept {
    
    return _Pr.first;
}

 template <class _Ty2, class _Ty1>
[[nodiscard]] constexpr const _Ty2& get(const pair<_Ty1, _Ty2>& _Pr) noexcept {
    
    return _Pr.second;
}

 template <size_t _Idx, class _Ty1, class _Ty2>
[[nodiscard]] constexpr tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept {
    
    if constexpr (_Idx == 0) {
        return ::std:: forward<_Ty1>(_Pr.first);
    } else {
        return ::std:: forward<_Ty2>(_Pr.second);
    }
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr _Ty1&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept {
    
    return ::std:: forward<_Ty1>(_Pr.first);
}

 template <class _Ty2, class _Ty1>
[[nodiscard]] constexpr _Ty2&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept {
    
    return ::std:: forward<_Ty2>(_Pr.second);
}

 template <size_t _Idx, class _Ty1, class _Ty2>
[[nodiscard]] constexpr const tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&& get(const pair<_Ty1, _Ty2>&& _Pr) noexcept {
    
    if constexpr (_Idx == 0) {
        return ::std:: forward<const _Ty1>(_Pr.first);
    } else {
        return ::std:: forward<const _Ty2>(_Pr.second);
    }
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr const _Ty1&& get(const pair<_Ty1, _Ty2>&& _Pr) noexcept {
    
    return ::std:: forward<const _Ty1>(_Pr.first);
}

 template <class _Ty2, class _Ty1>
[[nodiscard]] constexpr const _Ty2&& get(const pair<_Ty1, _Ty2>&& _Pr) noexcept {
    
    return ::std:: forward<const _Ty2>(_Pr.second);
}

 template <class _Ty, class _Other = _Ty>
constexpr _Ty exchange(_Ty& _Val, _Other&& _New_val) noexcept(
    conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {
    
    _Ty _Old_val = static_cast<_Ty&&>(_Val);
    _Val         = static_cast<_Other&&>(_New_val);
    return _Old_val;
}

 template <class _Ty>
[[nodiscard]] constexpr add_const_t<_Ty>& as_const(_Ty& _Val) noexcept { 
    return _Val;
}

 template <class _Ty>
void as_const(const _Ty&&) = delete;


 struct in_place_t { 
    explicit in_place_t() = default;
};
 inline constexpr in_place_t in_place{};

 template <class>
struct in_place_type_t { 
    explicit in_place_type_t() = default;
};
 template <class _Ty>
inline constexpr in_place_type_t<_Ty> in_place_type{};

 template <size_t>
struct in_place_index_t { 
    explicit in_place_index_t() = default;
};
 template <size_t _Idx>
inline constexpr in_place_index_t<_Idx> in_place_index{};
#line 789 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"


template <class _Ty>
inline constexpr bool _Is_standard_integer = is_integral_v<_Ty>
                                          && !_Is_any_of_v<remove_cv_t<_Ty>, bool, char,

                                              wchar_t,
#line 797 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"

                                              char8_t,
#line 800 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"
                                              char16_t, char32_t>;

 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool cmp_equal(const _Ty1 _Left, const _Ty2 _Right) noexcept {
    static_assert(_Is_standard_integer<_Ty1> && _Is_standard_integer<_Ty2>,
        "The integer comparison functions only accept standard and extended integer types.");
    if constexpr (is_signed_v<_Ty1> == is_signed_v<_Ty2>) {
        return _Left == _Right;
    } else if constexpr (is_signed_v<_Ty2>) {
        return _Left == static_cast<make_unsigned_t<_Ty2>>(_Right) && _Right >= 0;
    } else {
        return static_cast<make_unsigned_t<_Ty1>>(_Left) == _Right && _Left >= 0;
    }
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool cmp_not_equal(const _Ty1 _Left, const _Ty2 _Right) noexcept {
    return !::std:: cmp_equal(_Left, _Right);
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool cmp_less(const _Ty1 _Left, const _Ty2 _Right) noexcept {
    static_assert(_Is_standard_integer<_Ty1> && _Is_standard_integer<_Ty2>,
        "The integer comparison functions only accept standard and extended integer types.");
    if constexpr (is_signed_v<_Ty1> == is_signed_v<_Ty2>) {
        return _Left < _Right;
    } else if constexpr (is_signed_v<_Ty2>) {
        return _Right > 0 && _Left < static_cast<make_unsigned_t<_Ty2>>(_Right);
    } else {
        return _Left < 0 || static_cast<make_unsigned_t<_Ty1>>(_Left) < _Right;
    }
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool cmp_greater(const _Ty1 _Left, const _Ty2 _Right) noexcept {
    return ::std:: cmp_less(_Right, _Left);
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool cmp_less_equal(const _Ty1 _Left, const _Ty2 _Right) noexcept {
    return !::std:: cmp_less(_Right, _Left);
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool cmp_greater_equal(const _Ty1 _Left, const _Ty2 _Right) noexcept {
    return !::std:: cmp_less(_Left, _Right);
}

template <class _Ty>
[[nodiscard]] consteval _Ty _Min_limit() noexcept { 
    static_assert(_Is_standard_integer<_Ty>); 
    if constexpr (is_signed_v<_Ty>) {
        constexpr auto _Unsigned_max = static_cast<make_unsigned_t<_Ty>>(-1);
        return static_cast<_Ty>((_Unsigned_max >> 1) + 1); 
    } else {
        return 0;
    }
}

template <class _Ty>
[[nodiscard]] consteval _Ty _Max_limit() noexcept { 
    static_assert(_Is_standard_integer<_Ty>); 
    if constexpr (is_signed_v<_Ty>) {
        constexpr auto _Unsigned_max = static_cast<make_unsigned_t<_Ty>>(-1);
        return static_cast<_Ty>(_Unsigned_max >> 1);
    } else {
        return static_cast<_Ty>(-1);
    }
}

 template <class _Rx, class _Ty>
[[nodiscard]] constexpr bool in_range(const _Ty _Value) noexcept {
    static_assert(_Is_standard_integer<_Rx> && _Is_standard_integer<_Ty>,
        "The integer comparison functions only accept standard and extended integer types.");

    constexpr auto _Ty_min = _Min_limit<_Ty>();
    constexpr auto _Rx_min = _Min_limit<_Rx>();

    if constexpr (::std:: cmp_less(_Ty_min, _Rx_min)) {
        if (_Value < _Ty{_Rx_min}) {
            return false;
        }
    }

    constexpr auto _Ty_max = _Max_limit<_Ty>();
    constexpr auto _Rx_max = _Max_limit<_Rx>();

    if constexpr (::std:: cmp_greater(_Ty_max, _Rx_max)) {
        if (_Value > _Ty{_Rx_max}) {
            return false;
        }
    }

    return true;
}


template <class _Ty>
using _With_reference = _Ty&;

template <class _Ty>
concept _Can_reference = requires { typename _With_reference<_Ty>; };






#line 909 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"
#line 910 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"





































#line 948 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"







#line 956 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"

}



#pragma warning(pop)
#pragma pack(pop)
#line 964 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"
#line 965 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\utility"
#pragma external_header(pop)
#line 12 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\__msvc_iter_core.hpp"

#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




namespace std {

 struct input_iterator_tag {};

 struct output_iterator_tag {};

 struct forward_iterator_tag : input_iterator_tag {};

 struct bidirectional_iterator_tag : forward_iterator_tag {};

 struct random_access_iterator_tag : bidirectional_iterator_tag {};


 struct contiguous_iterator_tag : random_access_iterator_tag {};

template <class _Ty>
concept _Dereferenceable = requires(_Ty& __t) {
                               { *__t } -> _Can_reference;
                           };

template <class _Ty>
concept _Has_member_iterator_concept = requires { typename _Ty::iterator_concept; };

template <class _Ty>
concept _Has_member_iterator_category = requires { typename _Ty::iterator_category; };

template <class _Ty>
concept _Has_member_value_type = requires { typename _Ty::value_type; };

template <class _Ty>
concept _Has_member_element_type = requires { typename _Ty::element_type; };

template <class _Ty>
concept _Has_member_difference_type = requires { typename _Ty::difference_type; };

template <class _Ty>
concept _Has_member_pointer = requires { typename _Ty::pointer; };

template <class _Ty>
concept _Has_member_reference = requires { typename _Ty::reference; };

 template <class>
struct incrementable_traits {};

template <class _Ty>
    requires is_object_v<_Ty>
struct incrementable_traits<_Ty*> {
    using difference_type = ptrdiff_t;
};

template <class _Ty>
struct incrementable_traits<const _Ty> : incrementable_traits<_Ty> {};

template <_Has_member_difference_type _Ty>
struct incrementable_traits<_Ty> {
    using difference_type = typename _Ty::difference_type;
};

template <class _Ty>
concept _Can_difference = requires(const _Ty& __a, const _Ty& __b) {
                              { __a - __b } -> integral;
                          };

template <class _Ty>
    requires (!_Has_member_difference_type<_Ty> && _Can_difference<_Ty>)
struct incrementable_traits<_Ty> {
    using difference_type = make_signed_t<decltype(::std:: declval<_Ty>() - ::std:: declval<_Ty>())>;
};

template <class _Ty>
concept _Is_from_primary = _Same_impl<typename _Ty::_From_primary, _Ty>;

 template <class>
struct iterator_traits;

 template <class _Ty>
using iter_difference_t = typename conditional_t<_Is_from_primary<iterator_traits<remove_cvref_t<_Ty>>>,
    incrementable_traits<remove_cvref_t<_Ty>>, iterator_traits<remove_cvref_t<_Ty>>>::difference_type;

template <class>
struct _Cond_value_type {};

template <class _Ty>
    requires is_object_v<_Ty>
struct _Cond_value_type<_Ty> {
    using value_type = remove_cv_t<_Ty>;
};

 template <class>
struct indirectly_readable_traits {};

template <class _Ty>
struct indirectly_readable_traits<_Ty*> : _Cond_value_type<_Ty> {};

template <class _Ty>
    requires is_array_v<_Ty>
struct indirectly_readable_traits<_Ty> {
    using value_type = remove_cv_t<remove_extent_t<_Ty>>;
};

template <class _Ty>
struct indirectly_readable_traits<const _Ty> : indirectly_readable_traits<_Ty> {};

template <_Has_member_value_type _Ty>
struct indirectly_readable_traits<_Ty> : _Cond_value_type<typename _Ty::value_type> {};

template <_Has_member_element_type _Ty>
struct indirectly_readable_traits<_Ty> : _Cond_value_type<typename _Ty::element_type> {};

template <_Has_member_value_type _Ty>
    requires _Has_member_element_type<_Ty>
struct indirectly_readable_traits<_Ty> {};

template <_Has_member_value_type _Ty>
    requires _Has_member_element_type<_Ty>
          && same_as<remove_cv_t<typename _Ty::value_type>, remove_cv_t<typename _Ty::element_type>>
struct indirectly_readable_traits<_Ty> : _Cond_value_type<typename _Ty::value_type> {};

 template <class _Ty>
using iter_value_t = typename conditional_t<_Is_from_primary<iterator_traits<remove_cvref_t<_Ty>>>,
    indirectly_readable_traits<remove_cvref_t<_Ty>>, iterator_traits<remove_cvref_t<_Ty>>>::value_type;

 template <_Dereferenceable _Ty>
using iter_reference_t = decltype(*::std:: declval<_Ty&>());

template <class>
struct _Iterator_traits_base {};

template <class _It>
concept _Has_iter_types = _Has_member_difference_type<_It> && _Has_member_value_type<_It> 
                       && _Has_member_reference<_It> && _Has_member_iterator_category<_It>;

template <bool _Has_member_typedef>
struct _Old_iter_traits_pointer {
    template <class _It>
    using _Apply = typename _It::pointer;
};

template <>
struct _Old_iter_traits_pointer<false> {
    template <class>
    using _Apply = void;
};

template <_Has_iter_types _It>
struct _Iterator_traits_base<_It> {
    using iterator_category = typename _It::iterator_category;
    using value_type        = typename _It::value_type;
    using difference_type   = typename _It::difference_type;
    using pointer           = typename _Old_iter_traits_pointer<_Has_member_pointer<_It>>::template _Apply<_It>;
    using reference         = typename _It::reference;
};

template <bool _Has_member_typedef>
struct _Iter_traits_difference {
    template <class _It>
    using _Apply = typename incrementable_traits<_It>::difference_type;
};

template <>
struct _Iter_traits_difference<false> {
    template <class>
    using _Apply = void;
};


template <class _It>
concept _Cpp17_iterator =
    requires(_It __i) {
        { *__i } -> _Can_reference;
        { ++__i } -> same_as<_It&>;
        { *__i++ } -> _Can_reference;
    }
    && copyable<_It>;

template <class _It>
concept _Cpp17_input_iterator = _Cpp17_iterator<_It>
    && equality_comparable<_It>
    && _Has_member_difference_type<incrementable_traits<_It>>
    && _Has_member_value_type<indirectly_readable_traits<_It>>
    && requires(_It __i) {
        typename common_reference_t<iter_reference_t<_It>&&, typename indirectly_readable_traits<_It>::value_type&>;
        typename common_reference_t<decltype(*__i++)&&, typename indirectly_readable_traits<_It>::value_type&>;
        requires signed_integral<typename incrementable_traits<_It>::difference_type>;
    };

template <class _It>
    requires (!_Has_iter_types<_It> && _Cpp17_iterator<_It> && !_Cpp17_input_iterator<_It>)
struct _Iterator_traits_base<_It> {
    using iterator_category = output_iterator_tag;
    using value_type = void;
    using difference_type =
        typename _Iter_traits_difference<_Has_member_difference_type<incrementable_traits<_It>>>::template _Apply<_It>;
    using pointer    = void;
    using reference  = void;
};


enum class _Itraits_pointer_strategy { _Use_void, _Use_member, _Use_decltype };

template <_Itraits_pointer_strategy>
struct _Iter_traits_pointer;

template <>
struct _Iter_traits_pointer<_Itraits_pointer_strategy::_Use_void> {
    template <class>
    using _Apply = void;
};

template <>
struct _Iter_traits_pointer<_Itraits_pointer_strategy::_Use_member> {
    template <class _It>
    using _Apply = typename _It::pointer;
};

template <>
struct _Iter_traits_pointer<_Itraits_pointer_strategy::_Use_decltype> {
    template <class _It>
    using _Apply = decltype(::std:: declval<_It&>().operator->());
};

template <class _Ty>
concept _Has_member_arrow = requires(_Ty&& __t) { static_cast<_Ty&&>(__t).operator->(); };

template <bool _Has_member_typedef>
struct _Iter_traits_reference {
    template <class _It>
    using _Apply = typename _It::reference;
};

template <>
struct _Iter_traits_reference<false> {
    template <class _It>
    using _Apply = iter_reference_t<_It>;
};

template <bool _Is_random>
struct _Iter_traits_category4 {
    using type = random_access_iterator_tag;
};

template <>
struct _Iter_traits_category4<false> {
    using type = bidirectional_iterator_tag;
};


template <class _It>
concept _Cpp17_random_delta = totally_ordered<_It>
    && requires(_It __i, typename incrementable_traits<_It>::difference_type __n) {
        { __i += __n } -> same_as<_It&>;
        { __i -= __n } -> same_as<_It&>;
        { __i +  __n } -> same_as<_It>;
        { __n +  __i } -> same_as<_It>;
        { __i -  __n } -> same_as<_It>;
        { __i -  __i } -> same_as<decltype(__n)>;
        {  __i[__n]  } -> convertible_to<iter_reference_t<_It>>;
    };


template <bool _Is_bidi>
struct _Iter_traits_category3 {
    template <class _It>
    using _Apply = typename _Iter_traits_category4<_Cpp17_random_delta<_It>>::type;
};

template <>
struct _Iter_traits_category3<false> {
    template <class>
    using _Apply = forward_iterator_tag;
};

template <class _It>
concept _Cpp17_bidi_delta = requires(_It __i) {
                                { --__i } -> same_as<_It&>;
                                { __i-- } -> convertible_to<const _It&>;
                                requires same_as<decltype(*__i--), iter_reference_t<_It>>;
                            };

template <bool _Is_forward>
struct _Iter_traits_category2 {
    template <class _It>
    using _Apply = typename _Iter_traits_category3<_Cpp17_bidi_delta<_It>>::template _Apply<_It>;
};

template <>
struct _Iter_traits_category2<false> {
    template <class>
    using _Apply = input_iterator_tag;
};


template <class _It>
concept _Cpp17_forward_delta = constructible_from<_It> && is_reference_v<iter_reference_t<_It>>
    && same_as<remove_cvref_t<iter_reference_t<_It>>, typename indirectly_readable_traits<_It>::value_type>
    && requires(_It __i) {
        { __i++ } -> convertible_to<const _It&>;
        requires same_as<decltype(*__i++), iter_reference_t<_It>>;
    };


template <bool _Has_member_typedef>
struct _Iter_traits_category {
    template <class _It>
    using _Apply = typename _It::iterator_category;
};

template <>
struct _Iter_traits_category<false> {
    template <class _It>
    using _Apply = typename _Iter_traits_category2<_Cpp17_forward_delta<_It>>::template _Apply<_It>;
};


template <class _It>
    requires (!_Has_iter_types<_It> && _Cpp17_input_iterator<_It>)
struct _Iterator_traits_base<_It> {
    using iterator_category = typename _Iter_traits_category<_Has_member_iterator_category<_It>>::template _Apply<_It>;
    using value_type        = typename indirectly_readable_traits<_It>::value_type;
    using difference_type   = typename incrementable_traits<_It>::difference_type;
    using pointer           = typename _Iter_traits_pointer<(
        _Has_member_pointer<_It> ? _Itraits_pointer_strategy::_Use_member
                                 : _Has_member_arrow<_It&> ? _Itraits_pointer_strategy::_Use_decltype
                                                       : _Itraits_pointer_strategy::_Use_void)>::template _Apply<_It>;
    using reference         = typename _Iter_traits_reference<_Has_member_reference<_It>>::template _Apply<_It>;
};


 template <class _Ty>
struct iterator_traits : _Iterator_traits_base<_Ty> {
    using _From_primary = iterator_traits;
};

template <class _Ty>
    requires is_object_v<_Ty>
struct iterator_traits<_Ty*> {
    using iterator_concept  = contiguous_iterator_tag;
    using iterator_category = random_access_iterator_tag;
    using value_type        = remove_cv_t<_Ty>;
    using difference_type   = ptrdiff_t;
    using pointer           = _Ty*;
    using reference         = _Ty&;
};

template <class _Ty>
inline constexpr bool _Integer_class = requires {
                                           typename _Ty::_Signed_type;
                                           typename _Ty::_Unsigned_type;
                                       };

template <class _Ty>
concept _Integer_like = _Is_nonbool_integral<remove_cv_t<_Ty>> || _Integer_class<_Ty>;

template <class _Ty>
concept _Signed_integer_like = _Integer_like<_Ty> && static_cast<_Ty>(-1) < static_cast<_Ty>(0);


 template <class _Ty>
concept weakly_incrementable = movable<_Ty>
    && requires(_Ty __i) {
        typename iter_difference_t<_Ty>;
        requires _Signed_integer_like<iter_difference_t<_Ty>>;
        { ++__i } -> same_as<_Ty&>;
        __i++;
    }



    ;

 template <class _It>
concept input_or_output_iterator = requires(_It __i) { { *__i } -> _Can_reference; }
    && weakly_incrementable<_It>;

 template <class _Se, class _It>
concept sentinel_for = semiregular<_Se>
    && input_or_output_iterator<_It>
    && _Weakly_equality_comparable_with<_Se, _It>;


 template <class _Se, class _It>
inline constexpr bool disable_sized_sentinel_for = false;


 template <class _Se, class _It>
concept sized_sentinel_for = sentinel_for<_Se, _It>
    && !disable_sized_sentinel_for<remove_cv_t<_Se>, remove_cv_t<_It>>
    && requires(const _It& __i, const _Se& __s) {
        { __s - __i } -> same_as<iter_difference_t<_It>>;
        { __i - __s } -> same_as<iter_difference_t<_It>>;
    };


namespace ranges {
     enum class subrange_kind : bool { unsized, sized };

     template <input_or_output_iterator _It, sentinel_for<_It> _Se = _It,
        subrange_kind _Ki = sized_sentinel_for<_Se, _It> ? subrange_kind::sized : subrange_kind::unsized>
        requires (_Ki == subrange_kind::sized || !sized_sentinel_for<_Se, _It>)
    class subrange;

     template <size_t _Idx, class _It, class _Se, subrange_kind _Ki>
        requires ((_Idx == 0 && copyable<_It>) || _Idx == 1)
    [[nodiscard]] constexpr auto get(const subrange<_It, _Se, _Ki>& _Val);

     template <size_t _Idx, class _It, class _Se, subrange_kind _Ki>
        requires (_Idx < 2)
    [[nodiscard]] constexpr auto get(subrange<_It, _Se, _Ki>&& _Val);
} 

 using ranges::get;

template <class _It, class _Se, ranges::subrange_kind _Ki>
inline constexpr bool _Is_subrange_v<ranges::subrange<_It, _Se, _Ki>> = true;

template <class _It, class _Se, ranges::subrange_kind _Ki>
struct tuple_size<ranges::subrange<_It, _Se, _Ki>> : integral_constant<size_t, 2> {};

template <class _It, class _Se, ranges::subrange_kind _Ki>
struct tuple_element<0, ranges::subrange<_It, _Se, _Ki>> {
    using type = _It;
};

template <class _It, class _Se, ranges::subrange_kind _Ki>
struct tuple_element<1, ranges::subrange<_It, _Se, _Ki>> {
    using type = _Se;
};

template <class _It, class _Se, ranges::subrange_kind _Ki>
struct tuple_element<0, const ranges::subrange<_It, _Se, _Ki>> {
    using type = _It;
};

template <class _It, class _Se, ranges::subrange_kind _Ki>
struct tuple_element<1, const ranges::subrange<_It, _Se, _Ki>> {
    using type = _Se;
};

































#line 491 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\__msvc_iter_core.hpp"
}



#pragma warning(pop)
#pragma pack(pop)
#line 498 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\__msvc_iter_core.hpp"
#line 499 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\__msvc_iter_core.hpp"
#pragma external_header(pop)
#line 13 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"


#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cstring"





#pragma once





#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\string.h"







#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_memory.h"










#pragma once





#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )




__pragma(pack(push, 8)) extern "C" {




__declspec(dllimport) int __cdecl _memicmp(
     void const* _Buf1,
     void const* _Buf2,
                            size_t      _Size
    );


__declspec(dllimport) int __cdecl _memicmp_l(
     void const* _Buf1,
     void const* _Buf2,
                            size_t      _Size,
                        _locale_t   _Locale
    );





    












#line 60 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_memory.h"

    












#line 75 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_memory.h"

#line 77 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_memory.h"





    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_memccpy" ". See online help for details."))
    __declspec(dllimport) void* __cdecl memccpy(
         void*       _Dst,
           void const* _Src,
                                  int         _Val,
                                  size_t      _Size
        );

     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_memicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl memicmp(
         void const* _Buf1,
         void const* _Buf2,
                                size_t      _Size
        );

#line 98 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_memory.h"





    extern "C++" 
    inline void* __cdecl memchr(
         void*  _Pv,
                             int    _C,
                             size_t _N
        )
    {
        void const* const _Pvc = _Pv;
        return const_cast<void*>(memchr(_Pvc, _C, _N));
    }

#line 115 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_memory.h"



} __pragma(pack(pop))

#line 121 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\corecrt_memory.h"

#pragma warning(pop) 
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\string.h"





#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {







    
    __declspec(dllimport) errno_t __cdecl strcpy_s(
         char*       _Destination,
                                 rsize_t     _SizeInBytes,
                               char const* _Source
        );

    
    __declspec(dllimport) errno_t __cdecl strcat_s(
         char*       _Destination,
                                    rsize_t     _SizeInBytes,
                                  char const* _Source
        );

    
    __declspec(dllimport) errno_t __cdecl strerror_s(
         char*  _Buffer,
                                 size_t _SizeInBytes,
                                 int    _ErrorNumber);

    
    __declspec(dllimport) errno_t __cdecl strncat_s(
         char*       _Destination,
                                    rsize_t     _SizeInBytes,
              char const* _Source,
                                    rsize_t     _MaxCount
        );

    
    __declspec(dllimport) errno_t __cdecl strncpy_s(
         char*       _Destination,
                                 rsize_t     _SizeInBytes,
           char const* _Source,
                                 rsize_t     _MaxCount
        );

    
    __declspec(dllimport) char*  __cdecl strtok_s(
                         char*       _String,
                                char const* _Delimiter,
          char**      _Context
        );

#line 75 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\string.h"

__declspec(dllimport) void* __cdecl _memccpy(
     void*       _Dst,
                                  void const* _Src,
                                  int         _Val,
                                  size_t      _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strcat_s(char (&_Destination)[_Size], char const* _Source) throw() { return strcat_s(_Destination, _Size, _Source); } }







    __declspec(deprecated("This function or variable may be unsafe. Consider using " "strcat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) char* __cdecl strcat( char *_Destination, char const* _Source);





#line 98 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\string.h"


int __cdecl strcmp(
     char const* _Str1,
     char const* _Str2
    );


__declspec(dllimport) int __cdecl _strcmpi(
     char const* _String1,
     char const* _String2
    );


__declspec(dllimport) int __cdecl strcoll(
     char const* _String1,
     char const* _String2
    );


__declspec(dllimport) int __cdecl _strcoll_l(
       char const* _String1,
       char const* _String2,
     _locale_t   _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strcpy_s(char (&_Destination)[_Size], char const* _Source) throw() { return strcpy_s(_Destination, _Size, _Source); } }





__declspec(deprecated("This function or variable may be unsafe. Consider using " "strcpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) char* __cdecl strcpy( char *_Destination, char const* _Source);






__declspec(dllimport) size_t __cdecl strcspn(
     char const* _Str,
     char const* _Control
    );




#line 146 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\string.h"


__declspec(dllimport) __declspec(allocator) char* __cdecl _strdup(
     char const* _Source
    );



#line 155 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\string.h"



 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_strerror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char*  __cdecl _strerror(
     char const* _ErrorMessage
    );


__declspec(dllimport) errno_t __cdecl _strerror_s(
     char*       _Buffer,
                             size_t      _SizeInBytes,
                       char const* _ErrorMessage
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strerror_s(char (&_Buffer)[_Size], char const* _ErrorMessage) throw() { return _strerror_s(_Buffer, _Size, _ErrorMessage); } }






 __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl strerror(
     int _ErrorMessage
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strerror_s(char (&_Buffer)[_Size], int _ErrorMessage) throw() { return strerror_s(_Buffer, _Size, _ErrorMessage); } }






__declspec(dllimport) int __cdecl _stricmp(
     char const* _String1,
     char const* _String2
    );


__declspec(dllimport) int __cdecl _stricoll(
     char const* _String1,
     char const* _String2
    );


__declspec(dllimport) int __cdecl _stricoll_l(
       char const* _String1,
       char const* _String2,
     _locale_t   _Locale
    );


__declspec(dllimport) int __cdecl _stricmp_l(
       char const* _String1,
       char const* _String2,
     _locale_t   _Locale
    );


size_t __cdecl strlen(
     char const* _Str
    );


__declspec(dllimport) errno_t __cdecl _strlwr_s(
     char*  _String,
                         size_t _Size
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s(char (&_String)[_Size]) throw() { return _strlwr_s(_String, _Size); } }




__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strlwr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strlwr( char *_String);





__declspec(dllimport) errno_t __cdecl _strlwr_s_l(
     char*     _String,
                         size_t    _Size,
                     _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s_l(char (&_String)[_Size], _locale_t _Locale) throw() { return _strlwr_s_l(_String, _Size, _Locale); } }





__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strlwr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strlwr_l( char *_String, _locale_t _Locale);






extern "C++" { template <size_t _Size> inline errno_t __cdecl strncat_s(char (&_Destination)[_Size], char const* _Source, size_t _Count) throw() { return strncat_s(_Destination, _Size, _Source, _Count); } }






__declspec(deprecated("This function or variable may be unsafe. Consider using " "strncat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl strncat( char *_Destination, char const* _Source, size_t _Count);








__declspec(dllimport) int __cdecl strncmp(
     char const* _Str1,
     char const* _Str2,
                           size_t      _MaxCount
    );


__declspec(dllimport) int __cdecl _strnicmp(
     char const* _String1,
     char const* _String2,
                           size_t      _MaxCount
    );


__declspec(dllimport) int __cdecl _strnicmp_l(
     char const* _String1,
     char const* _String2,
                           size_t      _MaxCount,
                       _locale_t   _Locale
    );


__declspec(dllimport) int __cdecl _strnicoll(
     char const* _String1,
     char const* _String2,
                           size_t      _MaxCount
    );


__declspec(dllimport) int __cdecl _strnicoll_l(
     char const* _String1,
     char const* _String2,
                           size_t      _MaxCount,
                       _locale_t   _Locale
    );


__declspec(dllimport) int __cdecl _strncoll(
     char const* _String1,
     char const* _String2,
                           size_t      _MaxCount
    );


__declspec(dllimport) int __cdecl _strncoll_l(
     char const* _String1,
     char const* _String2,
                           size_t      _MaxCount,
                       _locale_t   _Locale
    );

__declspec(dllimport) size_t __cdecl __strncnt(
     char const* _String,
                        size_t      _Count
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strncpy_s(char (&_Destination)[_Size], char const* _Source, size_t _Count) throw() { return strncpy_s(_Destination, _Size, _Source, _Count); } }






__declspec(deprecated("This function or variable may be unsafe. Consider using " "strncpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl strncpy( char *_Destination, char const* _Source, size_t _Count);
















__declspec(dllimport) size_t __cdecl strnlen(
     char const* _String,
                           size_t      _MaxCount
    );



    
    



    



    static __inline size_t __cdecl strnlen_s(
         char const* _String,
                               size_t      _MaxCount
        )
    {
        return _String == 0 ? 0 : strnlen(_String, _MaxCount);
    }

#line 376 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\string.h"


__declspec(dllimport) errno_t __cdecl _strnset_s(
     char*  _String,
                                size_t _SizeInBytes,
                                int    _Value,
                                size_t _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strnset_s(char (&_Destination)[_Size], int _Value, size_t _Count) throw() { return _strnset_s(_Destination, _Size, _Value, _Count); } }






__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strnset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strnset( char *_Destination, int _Value, size_t _Count);








__declspec(dllimport) char const * __cdecl strpbrk(
     char const* _Str,
     char const* _Control
    );

__declspec(dllimport) char* __cdecl _strrev(
     char* _Str
    );


__declspec(dllimport) errno_t __cdecl _strset_s(
     char*  _Destination,
                                    size_t _DestinationSize,
                                    int    _Value
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strset_s(char (&_Destination)[_Size], int _Value) throw() { return _strset_s(_Destination, _Size, _Value); } }





__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) char* __cdecl _strset( char *_Destination, int _Value);






__declspec(dllimport) size_t __cdecl strspn(
     char const* _Str,
     char const* _Control
    );

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "strtok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl strtok(
     char*       _String,
            char const* _Delimiter
    );


__declspec(dllimport) errno_t __cdecl _strupr_s(
     char*  _String,
                         size_t _Size
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s(char (&_String)[_Size]) throw() { return _strupr_s(_String, _Size); } }




__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strupr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strupr( char *_String);





__declspec(dllimport) errno_t __cdecl _strupr_s_l(
     char*     _String,
                         size_t    _Size,
                     _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s_l(char (&_String)[_Size], _locale_t _Locale) throw() { return _strupr_s_l(_String, _Size, _Locale); } }





__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strupr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strupr_l( char *_String, _locale_t _Locale);








__declspec(dllimport) size_t __cdecl strxfrm(
      char*       _Destination,
                                        char const* _Source,
               size_t      _MaxCount
    );



__declspec(dllimport) size_t __cdecl _strxfrm_l(
      char*       _Destination,
                                        char const* _Source,
               size_t      _MaxCount,
                                      _locale_t   _Locale
    );




extern "C++"
{
    
    inline char* __cdecl strchr( char* const _String,  int const _Ch)
    {
        return const_cast<char*>(strchr(static_cast<char const*>(_String), _Ch));
    }

    
    inline char* __cdecl strpbrk( char* const _String,  char const* const _Control)
    {
        return const_cast<char*>(strpbrk(static_cast<char const*>(_String), _Control));
    }

    
    inline char* __cdecl strrchr( char* const _String,  int const _Ch)
    {
        return const_cast<char*>(strrchr(static_cast<char const*>(_String), _Ch));
    }

     
    inline char* __cdecl strstr( char* const _String,  char const* const _SubString)
    {
        return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));
    }
}
#line 524 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\string.h"





    
    
     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strdup" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strdup(
         char const* _String
        );
    

    
     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strcmpi" ". See online help for details."))
    __declspec(dllimport) int __cdecl strcmpi(
         char const* _String1,
         char const* _String2
        );

     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_stricmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl stricmp(
         char const* _String1,
         char const* _String2
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strlwr" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strlwr(
         char* _String
        );

     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strnicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl strnicmp(
         char const* _String1,
         char const* _String2,
                               size_t      _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strnset" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strnset(
         char*  _String,
                                 int    _Value,
                                 size_t _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strrev" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strrev(
         char* _String
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strset" ". See online help for details."))
    char* __cdecl strset(
         char* _String,
              int   _Value);

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strupr" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strupr(
         char* _String
        );

#line 585 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\string.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#line 592 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\string.h"
#line 593 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\string.h"
#pragma external_header(pop)
#line 13 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cstring"

#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




namespace std {
#pragma warning(push)
#pragma warning(disable : 4995) 

 using :: size_t;
 using :: memchr;
 using :: memcmp;
 using :: memcpy;
 using :: memmove;
 using :: memset;
 using :: strcat;
 using :: strchr;
 using :: strcmp;
 using :: strcoll;
 using :: strcpy;
 using :: strcspn;
 using :: strerror;
 using :: strlen;
 using :: strncat;
 using :: strncmp;
 using :: strncpy;
 using :: strpbrk;
 using :: strrchr;
 using :: strspn;
 using :: strstr;
 using :: strtok;
 using :: strxfrm;

#pragma warning(pop)
}



#pragma warning(pop)
#pragma pack(pop)

#line 58 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cstring"
#line 59 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cstring"
#pragma external_header(pop)
#line 16 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )














#line 35 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"


#line 38 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"






#line 45 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"


extern "C" {







__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_1(void* _First, void* _Last) noexcept;
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_2(void* _First, void* _Last) noexcept;
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_4(void* _First, void* _Last) noexcept;
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_8(void* _First, void* _Last) noexcept;
__declspec(noalias) void __cdecl __std_swap_ranges_trivially_swappable_noalias(
    void* _First1, void* _Last1, void* _First2) noexcept;

__declspec(noalias) size_t
    __stdcall __std_count_trivial_1(const void* _First, const void* _Last, uint8_t _Val) noexcept;
__declspec(noalias) size_t
    __stdcall __std_count_trivial_2(const void* _First, const void* _Last, uint16_t _Val) noexcept;
__declspec(noalias) size_t
    __stdcall __std_count_trivial_4(const void* _First, const void* _Last, uint32_t _Val) noexcept;
__declspec(noalias) size_t
    __stdcall __std_count_trivial_8(const void* _First, const void* _Last, uint64_t _Val) noexcept;

const void* __stdcall __std_find_trivial_1(const void* _First, const void* _Last, uint8_t _Val) noexcept;
const void* __stdcall __std_find_trivial_2(const void* _First, const void* _Last, uint16_t _Val) noexcept;
const void* __stdcall __std_find_trivial_4(const void* _First, const void* _Last, uint32_t _Val) noexcept;
const void* __stdcall __std_find_trivial_8(const void* _First, const void* _Last, uint64_t _Val) noexcept;

const void* __stdcall __std_find_trivial_unsized_1(const void* _First, uint8_t _Val) noexcept;
const void* __stdcall __std_find_trivial_unsized_2(const void* _First, uint16_t _Val) noexcept;
const void* __stdcall __std_find_trivial_unsized_4(const void* _First, uint32_t _Val) noexcept;
const void* __stdcall __std_find_trivial_unsized_8(const void* _First, uint64_t _Val) noexcept;

const void* __stdcall __std_min_element_1(const void* _First, const void* _Last, bool _Signed) noexcept;
const void* __stdcall __std_min_element_2(const void* _First, const void* _Last, bool _Signed) noexcept;
const void* __stdcall __std_min_element_4(const void* _First, const void* _Last, bool _Signed) noexcept;
const void* __stdcall __std_min_element_8(const void* _First, const void* _Last, bool _Signed) noexcept;

const void* __stdcall __std_max_element_1(const void* _First, const void* _Last, bool _Signed) noexcept;
const void* __stdcall __std_max_element_2(const void* _First, const void* _Last, bool _Signed) noexcept;
const void* __stdcall __std_max_element_4(const void* _First, const void* _Last, bool _Signed) noexcept;
const void* __stdcall __std_max_element_8(const void* _First, const void* _Last, bool _Signed) noexcept;
}

template <class _Ty, class _TVal>
__declspec(noalias) size_t __std_count_trivial(_Ty* _First, _Ty* _Last, const _TVal _Val) noexcept {
    if constexpr (::std:: is_pointer_v<_TVal> || ::std:: is_null_pointer_v<_TVal>) {
        return __std_count_trivial(_First, _Last, reinterpret_cast<uintptr_t>(_Val));
    } else if constexpr (sizeof(_Ty) == 1) {
        return __std_count_trivial_1(_First, _Last, static_cast<uint8_t>(_Val));
    } else if constexpr (sizeof(_Ty) == 2) {
        return __std_count_trivial_2(_First, _Last, static_cast<uint16_t>(_Val));
    } else if constexpr (sizeof(_Ty) == 4) {
        return __std_count_trivial_4(_First, _Last, static_cast<uint32_t>(_Val));
    } else if constexpr (sizeof(_Ty) == 8) {
        return __std_count_trivial_8(_First, _Last, static_cast<uint64_t>(_Val));
    } else {
        static_assert(::std:: _Always_false<_Ty>, "Unexpected size");
    }
}

template <class _Ty, class _TVal>
_Ty* __std_find_trivial(_Ty* _First, _Ty* _Last, const _TVal _Val) noexcept {
    if constexpr (::std:: is_pointer_v<_TVal> || ::std:: is_null_pointer_v<_TVal>) {
        return __std_find_trivial(_First, _Last, reinterpret_cast<uintptr_t>(_Val));
    } else if constexpr (sizeof(_Ty) == 1) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(__std_find_trivial_1(_First, _Last, static_cast<uint8_t>(_Val))));
    } else if constexpr (sizeof(_Ty) == 2) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(__std_find_trivial_2(_First, _Last, static_cast<uint16_t>(_Val))));
    } else if constexpr (sizeof(_Ty) == 4) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(__std_find_trivial_4(_First, _Last, static_cast<uint32_t>(_Val))));
    } else if constexpr (sizeof(_Ty) == 8) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(__std_find_trivial_8(_First, _Last, static_cast<uint64_t>(_Val))));
    } else {
        static_assert(::std:: _Always_false<_Ty>, "Unexpected size");
    }
}

template <class _Ty, class _TVal>
_Ty* __std_find_trivial_unsized(_Ty* _First, const _TVal _Val) noexcept {
    if constexpr (::std:: is_pointer_v<_TVal> || ::std:: is_null_pointer_v<_TVal>) {
        return __std_find_trivial_unsized(_First, reinterpret_cast<uintptr_t>(_Val));
    } else if constexpr (sizeof(_Ty) == 1) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(__std_find_trivial_unsized_1(_First, static_cast<uint8_t>(_Val))));
    } else if constexpr (sizeof(_Ty) == 2) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(__std_find_trivial_unsized_2(_First, static_cast<uint16_t>(_Val))));
    } else if constexpr (sizeof(_Ty) == 4) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(__std_find_trivial_unsized_4(_First, static_cast<uint32_t>(_Val))));
    } else if constexpr (sizeof(_Ty) == 8) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(__std_find_trivial_unsized_8(_First, static_cast<uint64_t>(_Val))));
    } else {
        static_assert(::std:: _Always_false<_Ty>, "Unexpected size");
    }
}

template <class _Ty>
_Ty* __std_min_element(_Ty* _First, _Ty* _Last) noexcept {
    constexpr bool _Signed = ::std:: is_signed_v<_Ty>;

    if constexpr (sizeof(_Ty) == 1) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(__std_min_element_1(_First, _Last, _Signed)));
    } else if constexpr (sizeof(_Ty) == 2) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(__std_min_element_2(_First, _Last, _Signed)));
    } else if constexpr (sizeof(_Ty) == 4) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(__std_min_element_4(_First, _Last, _Signed)));
    } else if constexpr (sizeof(_Ty) == 8) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(__std_min_element_8(_First, _Last, _Signed)));
    } else {
        static_assert(::std:: _Always_false<_Ty>, "Unexpected size");
    }
}

template <class _Ty>
_Ty* __std_max_element(_Ty* _First, _Ty* _Last) noexcept {
    constexpr bool _Signed = ::std:: is_signed_v<_Ty>;

    if constexpr (sizeof(_Ty) == 1) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(__std_max_element_1(_First, _Last, _Signed)));
    } else if constexpr (sizeof(_Ty) == 2) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(__std_max_element_2(_First, _Last, _Signed)));
    } else if constexpr (sizeof(_Ty) == 4) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(__std_max_element_4(_First, _Last, _Signed)));
    } else if constexpr (sizeof(_Ty) == 8) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(__std_max_element_8(_First, _Last, _Signed)));
    } else {
        static_assert(::std:: _Always_false<_Ty>, "Unexpected size");
    }
}

#line 186 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

namespace std {

template <class _To, class _From,
    enable_if_t<conjunction_v<bool_constant<sizeof(_To) == sizeof(_From)>, is_trivially_copyable<_To>,
                    is_trivially_copyable<_From>>,
        int> = 0>
[[nodiscard]] constexpr _To _Bit_cast(const _From& _Val) noexcept {
    return __builtin_bit_cast(_To, _Val);
}

template <class _Ty>
struct _Get_first_parameter;

template <template <class, class...> class _Ty, class _First, class... _Rest>
struct _Get_first_parameter<_Ty<_First, _Rest...>> { 
    using type = _First;
};

template <class _Newfirst, class _Ty>
struct _Replace_first_parameter;

template <class _Newfirst, template <class, class...> class _Ty, class _First, class... _Rest>
struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...>> { 
    using type = _Ty<_Newfirst, _Rest...>;
};

template <class _Ty, class = void>
struct _Get_ptr_difference_type {
    using type = ptrdiff_t;
};

template <class _Ty>
struct _Get_ptr_difference_type<_Ty, void_t<typename _Ty::difference_type>> {
    using type = typename _Ty::difference_type;
};

template <class _Ty, class _Other, class = void>
struct _Get_rebind_alias {
    using type = typename _Replace_first_parameter<_Other, _Ty>::type;
};

template <class _Ty, class _Other>
struct _Get_rebind_alias<_Ty, _Other, void_t<typename _Ty::template rebind<_Other>>> {
    using type = typename _Ty::template rebind<_Other>;
};

template <class _Iter>
[[nodiscard]] constexpr void* _Voidify_iter(_Iter _It) noexcept {
    if constexpr (is_pointer_v<_Iter>) {
        return const_cast<void*>(static_cast<const volatile void*>(_It));
    } else {
        return const_cast<void*>(static_cast<const volatile void*>(::std:: addressof(*_It)));
    }
}






 template <class _Ty, class... _Types,
    void_t<decltype(::new(::std:: declval<void*>()) _Ty(::std:: declval<_Types>()...))>* = nullptr>
#line 250 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
constexpr _Ty* construct_at(_Ty* const _Location, _Types&&... _Args) noexcept(
    noexcept(::new(_Voidify_iter(_Location)) _Ty(::std:: forward<_Types>(_Args)...)))   {
    [[msvc::constexpr]] return ::new (_Voidify_iter(_Location)) _Ty(::std:: forward<_Types>(_Args)...);
}
#line 255 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

template <class _Ty, class... _Types>
constexpr void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(
    is_nothrow_constructible_v<_Ty, _Types...>) {

    if (::std:: is_constant_evaluated()) {
        ::std:: construct_at(::std:: addressof(_Obj), ::std:: forward<_Types>(_Args)...);
    } else
#line 264 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
    {
        ::new (_Voidify_iter(::std:: addressof(_Obj))) _Ty(::std:: forward<_Types>(_Args)...);
    }
}

template <class _Ty>
void _Default_construct_in_place(_Ty& _Obj) noexcept(is_nothrow_default_constructible_v<_Ty>) {
    ::new (_Voidify_iter(::std:: addressof(_Obj))) _Ty;
}

template <class _Ty, class _Elem>
struct _Ptr_traits_base {
    using pointer         = _Ty;
    using element_type    = _Elem;
    using difference_type = typename _Get_ptr_difference_type<_Ty>::type;

    template <class _Other>
    using rebind = typename _Get_rebind_alias<_Ty, _Other>::type;

    using _Reftype = conditional_t<is_void_v<_Elem>, char, _Elem>&;

    [[nodiscard]] static constexpr pointer pointer_to(_Reftype _Val) noexcept(
        noexcept(_Ty::pointer_to(_Val)))   { 
        return _Ty::pointer_to(_Val);
    }
};

template <class, class = void, class = void>
struct _Ptr_traits_sfinae_layer {};

template <class _Ty, class _Uty>
struct _Ptr_traits_sfinae_layer<_Ty, _Uty, void_t<typename _Get_first_parameter<_Ty>::type>>
    : _Ptr_traits_base<_Ty, typename _Get_first_parameter<_Ty>::type> {};

template <class _Ty>
struct _Ptr_traits_sfinae_layer<_Ty, void_t<typename _Ty::element_type>, void>
    : _Ptr_traits_base<_Ty, typename _Ty::element_type> {};

 template <class _Ty>
struct pointer_traits : _Ptr_traits_sfinae_layer<_Ty> {};

template <class _Ty>
struct pointer_traits<_Ty*> {
    using pointer         = _Ty*;
    using element_type    = _Ty;
    using difference_type = ptrdiff_t;

    template <class _Other>
    using rebind = _Other*;

    using _Reftype = conditional_t<is_void_v<_Ty>, char, _Ty>&;

    [[nodiscard]] static constexpr pointer pointer_to(_Reftype _Val) noexcept {
        return ::std:: addressof(_Val);
    }
};



template <class _Ty>
concept _Has_to_address = requires(const _Ty& _Val) {
                              typename pointer_traits<_Ty>;
                              pointer_traits<_Ty>::to_address(_Val);
                          };







#line 336 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

 template <class _Ty>
[[nodiscard]] constexpr _Ty* to_address(_Ty* const _Val) noexcept {
    static_assert(!is_function_v<_Ty>,
        "N4810 20.10.4 [pointer.conversion]/2: The program is ill-formed if T is a function type.");
    return _Val;
}

 template <class _Ptr>
[[nodiscard]] constexpr auto to_address(const _Ptr& _Val) noexcept {
    if constexpr (_Has_to_address<_Ptr>) {
        return pointer_traits<_Ptr>::to_address(_Val);
    } else {
        return ::std:: to_address(_Val.operator->()); 
    }
}

 struct identity {
    template <class _Ty>
    [[nodiscard]] constexpr _Ty&& operator()(_Ty&& _Left) const noexcept {
        return ::std:: forward<_Ty>(_Left);
    }

    using is_transparent = int;
};
#line 362 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

template <class _Fx>
struct _Ref_fn { 
    template <class... _Args>
    constexpr decltype(auto) operator()(_Args&&... _Vals) { 
        if constexpr (is_member_pointer_v<_Fx>) {
            return ::std:: invoke(_Fn, ::std:: forward<_Args>(_Vals)...);
        } else {
            return _Fn(::std:: forward<_Args>(_Vals)...);
        }
    }

    _Fx& _Fn;
};

template <class _Fn>
constexpr auto _Pass_fn(_Fn& _Func) noexcept {
    constexpr bool _Pass_by_value = conjunction_v<bool_constant<sizeof(_Fn) <= sizeof(void*)>,
        is_trivially_copy_constructible<_Fn>, is_trivially_destructible<_Fn>>;
    if constexpr (_Pass_by_value) {
        return _Func;
    } else {
        return _Ref_fn<_Fn>{_Func}; 
    }
}












#line 400 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

struct _Unused_parameter { 
    constexpr _Unused_parameter() noexcept = default;
    template <class _Ty>
    constexpr _Unused_parameter(_Ty&&) noexcept {}
};

template <class _Ty>
using _Algorithm_int_t = conditional_t<is_integral_v<_Ty>, _Ty, ptrdiff_t>;


template <class _Ty>
concept _Destructible_object = is_object_v<_Ty> && destructible<_Ty>;

template <template <class...> class _Template, class... _Args>
void _Derived_from_specialization_impl(const _Template<_Args...>&);

template <class _Ty, template <class...> class _Template>
concept _Derived_from_specialization_of =
    requires(const _Ty& _Obj) {
        ::std:: _Derived_from_specialization_impl<_Template>(_Obj); 
    };

namespace ranges {
    namespace _Iter_move {


#line 428 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        void iter_move();
#line 430 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

        
        template <class _Ty>
        concept _Has_ADL = _Has_class_or_enum_type<_Ty> && requires(_Ty&& __t) {
            iter_move(static_cast<_Ty&&>(__t)); 
        };

        template <class _Ty>
        concept _Can_deref = requires(_Ty&& __t) {
            *static_cast<_Ty&&>(__t);
        };
        

        class _Cpo {
        private:
            enum class _St { _None, _Custom, _Fallback };

            template <class _Ty>
            [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
                if constexpr (_Has_ADL<_Ty>) {
                    return {_St::_Custom, noexcept(iter_move(::std:: declval<_Ty>()))}; 
                } else if constexpr (_Can_deref<_Ty>) {
                    return {_St::_Fallback, noexcept(*::std:: declval<_Ty>())};
                } else {
                    return {_St::_None};
                }
            }

            template <class _Ty>
            static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();

        public:
            template <class _Ty>
                requires (_Choice<_Ty>._Strategy != _St::_None)
            [[nodiscard]] constexpr decltype(auto) operator()(_Ty&& _Val) const noexcept(_Choice<_Ty>._No_throw) {
                constexpr _St _Strat = _Choice<_Ty>._Strategy;

                if constexpr (_Strat == _St::_Custom) {
                    return iter_move(static_cast<_Ty&&>(_Val)); 
                } else if constexpr (_Strat == _St::_Fallback) {
                    using _Ref = decltype(*static_cast<_Ty&&>(_Val));
                    if constexpr (is_lvalue_reference_v<_Ref>) {
                        return ::std:: move(*static_cast<_Ty&&>(_Val));
                    } else {
                        return *static_cast<_Ty&&>(_Val);
                    }
                } else {
                    static_assert(_Always_false<_Ty>, "should be unreachable");
                }
            }
        };
    } 

    inline namespace _Cpos {
         inline constexpr _Iter_move::_Cpo iter_move;
    }
} 




 template <class _Ty>
    requires _Dereferenceable<_Ty> && requires(_Ty& __t) {
        { ::std::ranges:: iter_move(__t) } -> _Can_reference;
    }
using iter_rvalue_reference_t = decltype(::std::ranges:: iter_move(::std:: declval<_Ty&>()));

template <class _It>
concept _Indirectly_readable_impl = requires(const _It __i) {
    typename iter_value_t<_It>;
    typename iter_reference_t<_It>;
    typename iter_rvalue_reference_t<_It>;
    { *__i } -> same_as<iter_reference_t<_It>>;
    { ::std::ranges:: iter_move(__i) } -> same_as<iter_rvalue_reference_t<_It>>;
} && common_reference_with<iter_reference_t<_It>&&, iter_value_t<_It>&>
  && common_reference_with<iter_reference_t<_It>&&, iter_rvalue_reference_t<_It>&&>
  && common_reference_with<iter_rvalue_reference_t<_It>&&, const iter_value_t<_It>&>;

 template <class _It>
concept indirectly_readable = _Indirectly_readable_impl<remove_cvref_t<_It>>;


 template <indirectly_readable _Ty>
using iter_common_reference_t = common_reference_t<iter_reference_t<_Ty>, iter_value_t<_Ty>&>;

 template <class _It, class _Ty>
concept indirectly_writable =
    requires(_It && __i, _Ty&& __t) {
        *__i                                                                = static_cast<_Ty&&>(__t);
        *static_cast<_It&&>(__i)                                            = static_cast<_Ty&&>(__t);
        const_cast<const iter_reference_t<_It>&&>(*__i)                     = static_cast<_Ty&&>(__t);
        const_cast<const iter_reference_t<_It>&&>(*static_cast<_It&&>(__i)) = static_cast<_Ty&&>(__t);
    };

template <bool _Is_integer_class>
struct _Make_unsigned_like_impl {
    template <class _Ty>
    using _Apply = typename _Ty::_Unsigned_type;
};
template <>
struct _Make_unsigned_like_impl<false> {
    template <class _Ty>
    using _Apply = make_unsigned_t<_Ty>;
};

template <class _Ty>
using _Make_unsigned_like_t = typename _Make_unsigned_like_impl<_Integer_class<_Ty>>::template _Apply<_Ty>;

template <_Integer_like _Ty>
[[nodiscard]] constexpr auto _To_unsigned_like(const _Ty _Value) noexcept {
    return static_cast<_Make_unsigned_like_t<_Ty>>(_Value);
}

template <bool _Is_integer_class>
struct _Make_signed_like_impl {
    template <class _Ty>
    using _Apply = typename _Ty::_Signed_type;
};
template <>
struct _Make_signed_like_impl<false> {
    template <class _Ty>
    using _Apply = make_signed_t<_Ty>;
};

template <class _Ty>
using _Make_signed_like_t = typename _Make_signed_like_impl<_Integer_class<_Ty>>::template _Apply<_Ty>;

 template <class _Ty>
concept incrementable = regular<_Ty> && weakly_incrementable<_Ty> && requires(_Ty __t) {
                                                                         { __t++ } -> same_as<_Ty>;
                                                                     };

template <bool _Iterator_category_present>
struct _Iter_concept_impl2 {
    template <class _It, class _Traits>
    using _Apply = typename _Traits::iterator_category;
};
template <>
struct _Iter_concept_impl2<false> {
    template <class _It, class _Traits>
        requires _Is_from_primary<iterator_traits<_It>>
    using _Apply = random_access_iterator_tag;
};

template <bool _Iterator_concept_present>
struct _Iter_concept_impl1 {
    template <class _It, class _Traits>
    using _Apply = typename _Traits::iterator_concept;
};
template <>
struct _Iter_concept_impl1<false> {
    template <class _It, class _Traits>
    using _Apply = typename _Iter_concept_impl2<_Has_member_iterator_category<_Traits>>::template _Apply<_It, _Traits>;
};

template <class _It, class _Traits = conditional_t<_Is_from_primary<iterator_traits<_It>>, _It, iterator_traits<_It>>>
using _Iter_concept =
    typename _Iter_concept_impl1<_Has_member_iterator_concept<_Traits>>::template _Apply<_It, _Traits>;


 template <class _It>
concept input_iterator = input_or_output_iterator<_It> && indirectly_readable<_It>
    && requires { typename _Iter_concept<_It>; }
    && derived_from<_Iter_concept<_It>, input_iterator_tag>;

 template <class _It, class _Ty>
concept output_iterator = input_or_output_iterator<_It> && indirectly_writable<_It, _Ty>
    && requires(_It __i, _Ty&& __t) {
        *__i++ = static_cast<_Ty&&>(__t);
    };

 template <class _It>
concept forward_iterator = input_iterator<_It> && derived_from<_Iter_concept<_It>, forward_iterator_tag>
    && incrementable<_It> && sentinel_for<_It, _It>;

 template <class _It>
concept bidirectional_iterator = forward_iterator<_It> && derived_from<_Iter_concept<_It>, bidirectional_iterator_tag>
    && requires(_It __i) {
        { --__i } -> same_as<_It&>;
        { __i-- } -> same_as<_It>;
    };

 template <class _It>
concept random_access_iterator = bidirectional_iterator<_It>
    && derived_from<_Iter_concept<_It>, random_access_iterator_tag> && totally_ordered<_It>
    && sized_sentinel_for<_It, _It> && requires(_It __i, const _It __j, const iter_difference_t<_It> __n) {
        { __i += __n } -> same_as<_It&>;
        { __j + __n } -> same_as<_It>;
        { __n + __j } -> same_as<_It>;
        { __i -= __n } -> same_as<_It&>;
        { __j - __n } -> same_as<_It>;
        { __j[__n] } -> same_as<iter_reference_t<_It>>;
    };

 template <class _It>
concept contiguous_iterator = random_access_iterator<_It>
    && derived_from<_Iter_concept<_It>, contiguous_iterator_tag>
    && is_lvalue_reference_v<iter_reference_t<_It>>
    && same_as<iter_value_t<_It>, remove_cvref_t<iter_reference_t<_It>>>
    && requires(const _It& __i) {
        { ::std:: to_address(__i) } -> same_as<add_pointer_t<iter_reference_t<_It>>>;
    };

 template <class _Fn, class _It>
concept indirectly_unary_invocable = indirectly_readable<_It>
    && copy_constructible<_Fn>
    && invocable<_Fn&, iter_value_t<_It>&>
    && invocable<_Fn&, iter_reference_t<_It>>
    && invocable<_Fn&, iter_common_reference_t<_It>>
    && common_reference_with<
        invoke_result_t<_Fn&, iter_value_t<_It>&>,
        invoke_result_t<_Fn&, iter_reference_t<_It>>>;

 template <class _Fn, class _It>
concept indirectly_regular_unary_invocable = indirectly_readable<_It>
    && copy_constructible<_Fn>
    && regular_invocable<_Fn&, iter_value_t<_It>&>
    && regular_invocable<_Fn&, iter_reference_t<_It>>
    && regular_invocable<_Fn&, iter_common_reference_t<_It>>
    && common_reference_with<
        invoke_result_t<_Fn&, iter_value_t<_It>&>,
        invoke_result_t<_Fn&, iter_reference_t<_It>>>;

 template <class _Fn, class _It>
concept indirect_unary_predicate = indirectly_readable<_It>
    && copy_constructible<_Fn>
    && predicate<_Fn&, iter_value_t<_It>&>
    && predicate<_Fn&, iter_reference_t<_It>>
    && predicate<_Fn&, iter_common_reference_t<_It>>;

 template <class _Fn, class _It1, class _It2>
concept indirect_binary_predicate = indirectly_readable<_It1>
    && indirectly_readable<_It2>
    && copy_constructible<_Fn>
    && predicate<_Fn&, iter_value_t<_It1>&, iter_value_t<_It2>&>
    && predicate<_Fn&, iter_value_t<_It1>&, iter_reference_t<_It2>>
    && predicate<_Fn&, iter_reference_t<_It1>, iter_value_t<_It2>&>
    && predicate<_Fn&, iter_reference_t<_It1>, iter_reference_t<_It2>>
    && predicate<_Fn&, iter_common_reference_t<_It1>, iter_common_reference_t<_It2>>;

 template <class _Fn, class _It1, class _It2 = _It1>
concept indirect_equivalence_relation = indirectly_readable<_It1>
    && indirectly_readable<_It2>
    && copy_constructible<_Fn>
    && equivalence_relation<_Fn&, iter_value_t<_It1>&, iter_value_t<_It2>&>
    && equivalence_relation<_Fn&, iter_value_t<_It1>&, iter_reference_t<_It2>>
    && equivalence_relation<_Fn&, iter_reference_t<_It1>, iter_value_t<_It2>&>
    && equivalence_relation<_Fn&, iter_reference_t<_It1>, iter_reference_t<_It2>>
    && equivalence_relation<_Fn&, iter_common_reference_t<_It1>, iter_common_reference_t<_It2>>;

 template <class _Fn, class _It1, class _It2 = _It1>
concept indirect_strict_weak_order = indirectly_readable<_It1>
    && indirectly_readable<_It2>
    && copy_constructible<_Fn>
    && strict_weak_order<_Fn&, iter_value_t<_It1>&, iter_value_t<_It2>&>
    && strict_weak_order<_Fn&, iter_value_t<_It1>&, iter_reference_t<_It2>>
    && strict_weak_order<_Fn&, iter_reference_t<_It1>, iter_value_t<_It2>&>
    && strict_weak_order<_Fn&, iter_reference_t<_It1>, iter_reference_t<_It2>>
    && strict_weak_order<_Fn&, iter_common_reference_t<_It1>, iter_common_reference_t<_It2>>;

 template <class _Fn, class... _Its>
    requires (indirectly_readable<_Its> && ...)
        && invocable<_Fn, iter_reference_t<_Its>...>
using indirect_result_t = invoke_result_t<_Fn, iter_reference_t<_Its>...>;


 template <indirectly_readable _It, indirectly_regular_unary_invocable<_It> _Proj>
struct projected {
    using value_type = remove_cvref_t<indirect_result_t<_Proj&, _It>>;
    indirect_result_t<_Proj&, _It> operator*() const {
        :: abort();
    }
};

template <weakly_incrementable _It, class _Proj>
struct incrementable_traits<projected<_It, _Proj>> {
    using difference_type = iter_difference_t<_It>;
};

 template <class _In, class _Out>
concept indirectly_movable = indirectly_readable<_In> && indirectly_writable<_Out, iter_rvalue_reference_t<_In>>;


 template <class _In, class _Out>
concept indirectly_movable_storable = indirectly_movable<_In, _Out>
    && indirectly_writable<_Out, iter_value_t<_In>>
    && movable<iter_value_t<_In>>
    && constructible_from<iter_value_t<_In>, iter_rvalue_reference_t<_In>>
    && assignable_from<iter_value_t<_In>&, iter_rvalue_reference_t<_In> >;


 template <class _In, class _Out>
concept indirectly_copyable = indirectly_readable<_In> && indirectly_writable<_Out, iter_reference_t<_In>>;


 template <class _In, class _Out>
concept indirectly_copyable_storable = indirectly_copyable<_In, _Out>
    && indirectly_writable<_Out, iter_value_t<_In>&>
    && indirectly_writable<_Out, const iter_value_t<_In>&>
    && indirectly_writable<_Out, iter_value_t<_In>&&>
    && indirectly_writable<_Out, const iter_value_t<_In>&&>
    && copyable<iter_value_t<_In>>
    && constructible_from<iter_value_t<_In>, iter_reference_t<_In>>
    && assignable_from<iter_value_t<_In>&, iter_reference_t<_In>>;


namespace ranges {
    namespace _Iter_swap {
        template <class _Ty1, class _Ty2>
        void iter_swap(_Ty1, _Ty2) = delete;

        
        template <class _Ty1, class _Ty2>
        concept _Has_ADL = (_Has_class_or_enum_type<_Ty1> || _Has_class_or_enum_type<_Ty2>)
            && requires(_Ty1&& __t1, _Ty2&& __t2) {
                iter_swap(static_cast<_Ty1&&>(__t1), static_cast<_Ty2&&>(__t2)); 
            };

        template <class _Ty1, class _Ty2>
        concept _Can_swap_references = indirectly_readable<remove_reference_t<_Ty1>>
            && indirectly_readable<remove_reference_t<_Ty2>>
            && swappable_with<iter_reference_t<_Ty1>, iter_reference_t<_Ty2>>;

        template <class _Ty1, class _Ty2>
        concept _Symmetric_indirectly_movable_storable =
               indirectly_movable_storable<remove_reference_t<_Ty1>, remove_reference_t<_Ty2>>
            && indirectly_movable_storable<remove_reference_t<_Ty2>, remove_reference_t<_Ty1>>;
        

        template <class _Xty, class _Yty>
        [[nodiscard]] constexpr iter_value_t<remove_reference_t<_Xty>> _Iter_exchange_move(_Xty&& _XVal,
            _Yty&& _YVal) noexcept(noexcept(iter_value_t<remove_reference_t<_Xty>>(::std::ranges:: iter_move(_XVal)))) {
            iter_value_t<remove_reference_t<_Xty>> _Tmp(::std::ranges:: iter_move(_XVal));
            *_XVal = ::std::ranges:: iter_move(_YVal);
            return _Tmp;
        }

        class _Cpo {
        private:
            enum class _St { _None, _Custom, _Swap, _Exchange };

            template <class _Ty1, class _Ty2>
            [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
                if constexpr (_Has_ADL<_Ty1, _Ty2>) {
                    return {_St::_Custom,
                        noexcept(iter_swap(::std:: declval<_Ty1>(), ::std:: declval<_Ty2>()))}; 
                } else if constexpr (_Can_swap_references<_Ty1, _Ty2>) {
                    return {_St::_Swap, noexcept(::std::ranges:: swap(*::std:: declval<_Ty1>(), *::std:: declval<_Ty2>()))};
                } else if constexpr (_Symmetric_indirectly_movable_storable<_Ty1, _Ty2>) {
                    constexpr auto _Nothrow = noexcept(*::std:: declval<_Ty1>() = _Iter_swap::_Iter_exchange_move(
                                                           ::std:: declval<_Ty2>(), ::std:: declval<_Ty1>()));
                    return {_St::_Exchange, _Nothrow};
                } else {
                    return {_St::_None};
                }
            }

            template <class _Ty1, class _Ty2>
            static constexpr _Choice_t<_St> _Choice = _Choose<_Ty1, _Ty2>();

        public:
            template <class _Ty1, class _Ty2>
                requires (_Choice<_Ty1, _Ty2>._Strategy != _St::_None)
            constexpr void operator()(_Ty1&& _Val1, _Ty2&& _Val2) const noexcept(_Choice<_Ty1, _Ty2>._No_throw) {
                constexpr _St _Strat = _Choice<_Ty1, _Ty2>._Strategy;

                if constexpr (_Strat == _St::_Custom) {
                    (void) iter_swap(static_cast<_Ty1&&>(_Val1), static_cast<_Ty2&&>(_Val2)); 
                } else if constexpr (_Strat == _St::_Swap) {
                    ::std::ranges:: swap(*static_cast<_Ty1&&>(_Val1), *static_cast<_Ty2&&>(_Val2));
                } else if constexpr (_Strat == _St::_Exchange) {
                    *static_cast<_Ty1&&>(_Val1) =
                        _Iter_swap::_Iter_exchange_move(static_cast<_Ty2&&>(_Val2), static_cast<_Ty1&&>(_Val1));
                } else {
                    static_assert(_Always_false<_Ty1>, "should be unreachable");
                }
            }
        };
    } 

    inline namespace _Cpos {
         inline constexpr _Iter_swap::_Cpo iter_swap;
    }
} 


 template <class _It1, class _It2 = _It1>
concept indirectly_swappable = indirectly_readable<_It1> && indirectly_readable<_It2>
    && requires(const _It1 __i1, const _It2 __i2) {
        ::std::ranges:: iter_swap(__i1, __i1);
        ::std::ranges:: iter_swap(__i2, __i2);
        ::std::ranges:: iter_swap(__i1, __i2);
        ::std::ranges:: iter_swap(__i2, __i1);
    };


 template <class _It1, class _It2, class _Rel, class _Proj1 = identity, class _Proj2 = identity>
concept indirectly_comparable = indirect_binary_predicate<_Rel, projected<_It1, _Proj1>, projected<_It2, _Proj2>>;

 template <class _It>
concept permutable = forward_iterator<_It> && indirectly_movable_storable<_It, _It> && indirectly_swappable<_It, _It>;

namespace ranges {
     struct less;
} 

 template <class _It1, class _It2, class _Out, class _Pr = ranges::less, class _Pj1 = identity,
    class _Pj2 = identity>
concept mergeable = input_iterator<_It1> && input_iterator<_It2> 
                 && weakly_incrementable<_Out> 
                 && indirectly_copyable<_It1, _Out> 
                 && indirectly_copyable<_It2, _Out> 
                 && indirect_strict_weak_order<_Pr, projected<_It1, _Pj1>, projected<_It2, _Pj2>>;

 template <class _It, class _Pr = ranges::less, class _Proj = identity>
concept sortable = permutable<_It> && indirect_strict_weak_order<_Pr, projected<_It, _Proj>>;

template <class _Iter>
using _Iter_ref_t = iter_reference_t<_Iter>;

template <class _Iter>
using _Iter_value_t = iter_value_t<_Iter>;

template <class _Iter>
using _Iter_diff_t = iter_difference_t<_Iter>;













#line 869 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

template <class... _Iters>
using _Common_diff_t = common_type_t<_Iter_diff_t<_Iters>...>;

template <class _Iter>
using _Iter_cat_t = typename iterator_traits<_Iter>::iterator_category;

template <class _Ty, class = void>
inline constexpr bool _Is_iterator_v = false;

template <class _Ty>
inline constexpr bool _Is_iterator_v<_Ty, void_t<_Iter_cat_t<_Ty>>> = true;

template <class _Ty>
struct _Is_iterator : bool_constant<_Is_iterator_v<_Ty>> {};

template <class _Iter>
inline constexpr bool _Is_cpp17_input_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, input_iterator_tag>;

template <class _Iter>
inline constexpr bool _Is_ranges_input_iter_v =

    (input_iterator<_Iter> && sentinel_for<_Iter, _Iter>) ||
#line 893 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
    _Is_cpp17_input_iter_v<_Iter>;

template <class _Iter>
inline constexpr bool _Is_cpp17_fwd_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, forward_iterator_tag>;

template <class _Iter>
inline constexpr bool _Is_ranges_fwd_iter_v =

    forward_iterator<_Iter> ||
#line 903 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
    _Is_cpp17_fwd_iter_v<_Iter>;

template <class _Iter>
inline constexpr bool _Is_cpp17_bidi_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, bidirectional_iterator_tag>;

template <class _Iter>
inline constexpr bool _Is_ranges_bidi_iter_v =

    bidirectional_iterator<_Iter> ||
#line 913 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
    _Is_cpp17_bidi_iter_v<_Iter>;

template <class _Iter>
inline constexpr bool _Is_cpp17_random_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, random_access_iterator_tag>;

template <class _Iter>
inline constexpr bool _Is_ranges_random_iter_v =

    random_access_iterator<_Iter> ||
#line 923 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
    _Is_cpp17_random_iter_v<_Iter>;





template <class, class = void>
struct _Is_checked_helper {}; 







#line 939 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

template <class _Iter, class = void>
inline constexpr bool _Allow_inheriting_unwrap_v = true;

template <class _Iter>
inline constexpr bool _Allow_inheriting_unwrap_v<_Iter, void_t<typename _Iter::_Prevent_inheriting_unwrap>> =
    is_same_v<_Iter, typename _Iter::_Prevent_inheriting_unwrap>;

template <class _Iter, class _Sentinel = _Iter, class = void>
inline constexpr bool _Range_verifiable_v = false;

template <class _Iter, class _Sentinel>
inline constexpr bool _Range_verifiable_v<_Iter, _Sentinel,
    void_t<decltype(_Verify_range(::std:: declval<const _Iter&>(), ::std:: declval<const _Sentinel&>()))>> =
    _Allow_inheriting_unwrap_v<_Iter>;

template <class _Iter, class _Sentinel>
constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {
    
    if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
        _Verify_range(_First, _Last);
    }
}

template <class _Iter, class = void>
inline constexpr bool _Unwrappable_v = false;

template <class _Iter>
inline constexpr bool _Unwrappable_v<_Iter,
    void_t<decltype(::std:: declval<_Remove_cvref_t<_Iter>&>()._Seek_to(::std:: declval<_Iter>()._Unwrapped()))>> =
    _Allow_inheriting_unwrap_v<_Remove_cvref_t<_Iter>>;

template <class _Iter, class = void>
inline constexpr bool _Has_nothrow_unwrapped = false;
template <class _Iter>
inline constexpr bool _Has_nothrow_unwrapped<_Iter, void_t<decltype(::std:: declval<_Iter>()._Unwrapped())>> =
    noexcept(::std:: declval<_Iter>()._Unwrapped());

template <class _Iter>
[[nodiscard]] constexpr decltype(auto) _Get_unwrapped(_Iter&& _It) noexcept(
    !_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {
    
    if constexpr (is_pointer_v<decay_t<_Iter>>) { 
        return _It + 0;
    } else if constexpr (_Unwrappable_v<_Iter>) {
        return static_cast<_Iter&&>(_It)._Unwrapped();
    } else {
        return static_cast<_Iter&&>(_It);
    }
}

template <class _Iter>
using _Unwrapped_t = _Remove_cvref_t<decltype(_Get_unwrapped(::std:: declval<_Iter>()))>;

template <class _Iter, class = bool>
inline constexpr bool _Do_unwrap_when_unverified_v = false;

template <class _Iter>
inline constexpr bool
    _Do_unwrap_when_unverified_v<_Iter, decltype(static_cast<bool>(_Iter::_Unwrap_when_unverified))> =
        static_cast<bool>(_Iter::_Unwrap_when_unverified);

template <class _Iter>
inline constexpr bool _Unwrappable_for_unverified_v =
    _Unwrappable_v<_Iter> && _Do_unwrap_when_unverified_v<_Remove_cvref_t<_Iter>>;

template <class _Iter>
[[nodiscard]] constexpr decltype(auto) _Get_unwrapped_unverified(_Iter&& _It) {
    
    if constexpr (is_pointer_v<decay_t<_Iter>>) { 
        return _It + 0;
    } else if constexpr (_Unwrappable_for_unverified_v<_Iter>) {
        return static_cast<_Iter&&>(_It)._Unwrapped();
    } else {
        return static_cast<_Iter&&>(_It);
    }
}

template <class _Iter>
using _Unwrapped_unverified_t = _Remove_cvref_t<decltype(_Get_unwrapped_unverified(::std:: declval<_Iter>()))>;

struct _Distance_unknown {
    constexpr _Distance_unknown operator-() const noexcept {
        return {};
    }
};

template <class _Diff>
inline constexpr _Diff _Max_possible_v{static_cast<_Make_unsigned_like_t<_Diff>>(-1) >> 1};

template <class _Diff>
inline constexpr _Diff _Min_possible_v{-_Max_possible_v<_Diff> - 1};

template <class _Iter, class = void>
inline constexpr bool _Offset_verifiable_v = false;

template <class _Iter>
inline constexpr bool
    _Offset_verifiable_v<_Iter, void_t<decltype(::std:: declval<const _Iter&>()._Verify_offset(_Iter_diff_t<_Iter>{}))>> =
        true;

template <class _Iter>
inline constexpr bool _Unwrappable_for_offset_v =
    _Unwrappable_v<_Iter> && _Offset_verifiable_v<_Remove_cvref_t<_Iter>>;

template <class _Iter, class _Diff>
[[nodiscard]] constexpr decltype(auto) _Get_unwrapped_n(_Iter&& _It, const _Diff _Off) {
    if constexpr (is_pointer_v<decay_t<_Iter>>) {
        return _It + 0;
    } else if constexpr (_Unwrappable_for_offset_v<_Iter> && is_integral_v<_Diff>) {
        
        using _IDiff     = _Iter_diff_t<_Remove_cvref_t<_Iter>>;
        using _CDiff     = common_type_t<_Diff, _IDiff>;
        const auto _COff = static_cast<_CDiff>(_Off);

        

;
        (void) _COff;

        _It._Verify_offset(static_cast<_IDiff>(_Off));
        return static_cast<_Iter&&>(_It)._Unwrapped();
    } else if constexpr (_Unwrappable_for_unverified_v<_Iter>) {
        
        return static_cast<_Iter&&>(_It)._Unwrapped();
    } else {
        
        return static_cast<_Iter&&>(_It);
    }
}

template <class _Iter, class _UIter, class = void>
inline constexpr bool _Wrapped_seekable_v = false;

template <class _Iter, class _UIter>
inline constexpr bool
    _Wrapped_seekable_v<_Iter, _UIter, void_t<decltype(::std:: declval<_Iter&>()._Seek_to(::std:: declval<_UIter>()))>> =
        true;

template <class _Iter, class _UIter>
constexpr void _Seek_wrapped(_Iter& _It, _UIter&& _UIt) {
    if constexpr (_Wrapped_seekable_v<_Iter, _UIter>) {
        _It._Seek_to(::std:: forward<_UIter>(_UIt));
    } else {
        _It = ::std:: forward<_UIter>(_UIt);
    }
}


template <class _Ty, class = void>
struct _Is_allocator : false_type {}; 

template <class _Ty>
struct _Is_allocator<_Ty, void_t<typename _Ty::value_type, decltype(::std:: declval<_Ty&>().deallocate(
                                                               ::std:: declval<_Ty&>().allocate(size_t{1}), size_t{1}))>>
    : true_type {}; 


template <class _Iter>
using _Guide_key_t = remove_const_t<typename iterator_traits<_Iter>::value_type::first_type>;

template <class _Iter>
using _Guide_val_t = typename iterator_traits<_Iter>::value_type::second_type;

template <class _Iter>
using _Guide_pair_t = pair<add_const_t<typename iterator_traits<_Iter>::value_type::first_type>,
    typename iterator_traits<_Iter>::value_type::second_type>;

 template <class _Ty>
struct is_execution_policy : false_type {};

 template <class _Ty>
inline constexpr bool is_execution_policy_v = is_execution_policy<_Ty>::value;



template <class _ExPo>
using _Enable_if_execution_policy_t = typename remove_reference_t<_ExPo>::_Standard_execution_policy;




#line 1122 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

template <class _Checked, class _Iter>
[[nodiscard]] constexpr auto _Idl_distance(const _Iter& _First, const _Iter& _Last) {
    
    if constexpr (_Is_ranges_random_iter_v<_Iter>) {
        return static_cast<_Iter_diff_t<_Checked>>(_Last - _First);
    } else {
        return _Distance_unknown{};
    }
}

template <class _Elem, bool _Is_enum = is_enum_v<_Elem>>
struct _Unwrap_enum { 
    using type = underlying_type_t<_Elem>;
};

template <class _Elem>
struct _Unwrap_enum<_Elem, false> { 
    using type = _Elem;
};

template <class _Elem>
using _Unwrap_enum_t = typename _Unwrap_enum<_Elem>::type;



















































#line 1197 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"


 template <class _InIt, class _Diff>
constexpr void advance(_InIt& _Where, _Diff _Off) { 
    if constexpr (_Is_ranges_random_iter_v<_InIt>) {
        _Where += _Off;
    } else {
        if constexpr (is_signed_v<_Diff> && !_Is_ranges_bidi_iter_v<_InIt>) {
             ;
        }

        decltype(auto) _UWhere      = _Get_unwrapped_n(::std:: move(_Where), _Off);
        constexpr bool _Need_rewrap = !is_reference_v<decltype(_Get_unwrapped_n(::std:: move(_Where), _Off))>;

        if constexpr (is_signed_v<_Diff> && _Is_ranges_bidi_iter_v<_InIt>) {
            for (; _Off < 0; ++_Off) {
                --_UWhere;
            }
        }

        for (; 0 < _Off; --_Off) {
            ++_UWhere;
        }

        if constexpr (_Need_rewrap) {
            _Seek_wrapped(_Where, ::std:: move(_UWhere));
        }
    }
}

 template <class _InIt>
[[nodiscard]] constexpr _Iter_diff_t<_InIt> distance(_InIt _First, _InIt _Last) {
    if constexpr (_Is_ranges_random_iter_v<_InIt>) {
        return _Last - _First; 
    } else {
        _Adl_verify_range(_First, _Last);
        auto _UFirst             = _Get_unwrapped(_First);
        const auto _ULast        = _Get_unwrapped(_Last);
        _Iter_diff_t<_InIt> _Off = 0;
        for (; _UFirst != _ULast; ++_UFirst) {
            ++_Off;
        }

        return _Off;
    }
}

template <class _InIt>
constexpr _InIt _Next_iter(_InIt _First) { 
    return ++_First;
}

 template <class _InIt>
[[nodiscard]] constexpr _InIt next(_InIt _First, _Iter_diff_t<_InIt> _Off = 1) { 
    static_assert(_Is_ranges_input_iter_v<_InIt>, "next requires input iterator");

    ::std:: advance(_First, _Off);
    return _First;
}

template <class _BidIt>
constexpr _BidIt _Prev_iter(_BidIt _First) { 
    return --_First;
}

 template <class _BidIt>
[[nodiscard]] constexpr _BidIt prev(_BidIt _First, _Iter_diff_t<_BidIt> _Off = 1) { 
    static_assert(_Is_ranges_bidi_iter_v<_BidIt>, "prev requires bidirectional iterator");

    ::std:: advance(_First, -_Off);
    return _First;
}

template <class _Iter, class _Pointer, bool = is_pointer_v<_Remove_cvref_t<_Iter>>>
inline constexpr bool _Has_nothrow_operator_arrow = _Is_nothrow_convertible_v<_Iter, _Pointer>;

template <class _Iter, class _Pointer>
inline constexpr bool _Has_nothrow_operator_arrow<_Iter, _Pointer, false> =
    noexcept(_Fake_copy_init<_Pointer>(::std:: declval<_Iter>().operator->()));

 template <class _BidIt>
class reverse_iterator {
public:
    using iterator_type = _BidIt;


    using iterator_concept =
        conditional_t<random_access_iterator<_BidIt>, random_access_iterator_tag, bidirectional_iterator_tag>;
    using iterator_category = conditional_t<derived_from<_Iter_cat_t<_BidIt>, random_access_iterator_tag>,
        random_access_iterator_tag, _Iter_cat_t<_BidIt>>;


#line 1290 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
    using value_type      = _Iter_value_t<_BidIt>;
    using difference_type = _Iter_diff_t<_BidIt>;
    using pointer         = typename iterator_traits<_BidIt>::pointer;
    using reference       = _Iter_ref_t<_BidIt>;

    template <class>
    friend class reverse_iterator;

    constexpr reverse_iterator() = default;

    constexpr explicit reverse_iterator(_BidIt _Right) noexcept(
        is_nothrow_move_constructible_v<_BidIt>) 
        : current(::std:: move(_Right)) {}

    
    template <class _Other>

        requires (!is_same_v<_Other, _BidIt>) && convertible_to<const _Other&, _BidIt>
#line 1309 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
    constexpr reverse_iterator(const reverse_iterator<_Other>& _Right) noexcept(
        is_nothrow_constructible_v<_BidIt, const _Other&>) 
        : current(_Right.current) {}

    template <class _Other>

        requires (!is_same_v<_Other, _BidIt>) && convertible_to<const _Other&, _BidIt>
            && assignable_from<_BidIt&, const _Other&>
#line 1318 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
    constexpr reverse_iterator& operator=(const reverse_iterator<_Other>& _Right) noexcept(
        is_nothrow_assignable_v<_BidIt&, const _Other&>)   {
        current = _Right.current;
        return *this;
    }
    

    [[nodiscard]] constexpr _BidIt base() const noexcept(is_nothrow_copy_constructible_v<_BidIt>)   {
        return current;
    }

    [[nodiscard]] constexpr reference operator*() const
        noexcept(is_nothrow_copy_constructible_v<_BidIt>&& noexcept(*--(::std:: declval<_BidIt&>())))   {
        _BidIt _Tmp = current;
        return *--_Tmp;
    }

    [[nodiscard]] constexpr pointer operator->() const
        noexcept(is_nothrow_copy_constructible_v<_BidIt>&& noexcept(--(::std:: declval<_BidIt&>()))
                 && _Has_nothrow_operator_arrow<_BidIt&, pointer>)  

        requires (is_pointer_v<_BidIt> || requires(const _BidIt __i) { __i.operator->(); })
#line 1341 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
    {
        _BidIt _Tmp = current;
        --_Tmp;
        if constexpr (is_pointer_v<_BidIt>) {
            return _Tmp;
        } else {
            return _Tmp.operator->();
        }
    }

    constexpr reverse_iterator& operator++() noexcept(noexcept(--current))   {
        --current;
        return *this;
    }

    constexpr reverse_iterator operator++(int) noexcept(
        is_nothrow_copy_constructible_v<_BidIt>&& noexcept(--current))   {
        reverse_iterator _Tmp = *this;
        --current;
        return _Tmp;
    }

    constexpr reverse_iterator& operator--() noexcept(noexcept(++current))   {
        ++current;
        return *this;
    }

    constexpr reverse_iterator operator--(int) noexcept(
        is_nothrow_copy_constructible_v<_BidIt>&& noexcept(++current))   {
        reverse_iterator _Tmp = *this;
        ++current;
        return _Tmp;
    }

    [[nodiscard]] constexpr reverse_iterator operator+(const difference_type _Off) const
        noexcept(noexcept(reverse_iterator(current - _Off)))   {
        return reverse_iterator(current - _Off);
    }

    constexpr reverse_iterator& operator+=(const difference_type _Off) noexcept(
        noexcept(current -= _Off))   {
        current -= _Off;
        return *this;
    }

    [[nodiscard]] constexpr reverse_iterator operator-(const difference_type _Off) const
        noexcept(noexcept(reverse_iterator(current + _Off)))   {
        return reverse_iterator(current + _Off);
    }

    constexpr reverse_iterator& operator-=(const difference_type _Off) noexcept(
        noexcept(current += _Off))   {
        current += _Off;
        return *this;
    }

    [[nodiscard]] constexpr reference operator[](const difference_type _Off) const
        noexcept(noexcept(_Fake_copy_init<reference>(current[_Off])))   {
        return current[static_cast<difference_type>(-_Off - 1)];
    }


    [[nodiscard]] friend constexpr iter_rvalue_reference_t<_BidIt> iter_move(const reverse_iterator& _It) noexcept(
        is_nothrow_copy_constructible_v<_BidIt>&& noexcept(::std::ranges:: iter_move(--::std:: declval<_BidIt&>()))) {
        auto _Tmp = _It.current;
        --_Tmp;
        return ::std::ranges:: iter_move(_Tmp);
    }

    template <indirectly_swappable<_BidIt> _BidIt2>
    friend constexpr void iter_swap(const reverse_iterator& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
        is_nothrow_copy_constructible_v<_BidIt>&& is_nothrow_copy_constructible_v<_BidIt2>&& noexcept(
            ::std::ranges:: iter_swap(--::std:: declval<_BidIt&>(), --::std:: declval<_BidIt2&>()))) {
        auto _LTmp = _Left.current;
        auto _RTmp = _Right.base();
        --_LTmp;
        --_RTmp;
        ::std::ranges:: iter_swap(_LTmp, _RTmp);
    }
#line 1421 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

    using _Prevent_inheriting_unwrap = reverse_iterator;

    template <class _BidIt2, enable_if_t<_Range_verifiable_v<_BidIt, _BidIt2>, int> = 0>
    friend constexpr void _Verify_range(
        const reverse_iterator& _First, const reverse_iterator<_BidIt2>& _Last) noexcept {
        _Verify_range(_Last._Get_current(), _First.current); 
    }

    template <class _BidIt2 = _BidIt, enable_if_t<_Offset_verifiable_v<_BidIt2>, int> = 0>
    constexpr void _Verify_offset(const difference_type _Off) const noexcept {
        do { if (_Off != _Min_possible_v<difference_type>) { } else { do {; ::_invalid_parameter_noinfo_noreturn(); } while (false); }; } while (false) ;
        current._Verify_offset(-_Off);
    }

    template <class _BidIt2 = _BidIt, enable_if_t<_Unwrappable_v<const _BidIt2&>, int> = 0>
    [[nodiscard]] constexpr reverse_iterator<_Unwrapped_t<const _BidIt2&>> _Unwrapped() const& noexcept(
        noexcept(static_cast<reverse_iterator<_Unwrapped_t<const _BidIt2&>>>(current._Unwrapped()))) {
        return static_cast<reverse_iterator<_Unwrapped_t<const _BidIt2&>>>(current._Unwrapped());
    }
    template <class _BidIt2 = _BidIt, enable_if_t<_Unwrappable_v<_BidIt2>, int> = 0>
    [[nodiscard]] constexpr reverse_iterator<_Unwrapped_t<_BidIt2>> _Unwrapped() && noexcept(
        noexcept(static_cast<reverse_iterator<_Unwrapped_t<_BidIt2>>>(::std:: move(current)._Unwrapped()))) {
        return static_cast<reverse_iterator<_Unwrapped_t<_BidIt2>>>(::std:: move(current)._Unwrapped());
    }

    static constexpr bool _Unwrap_when_unverified = _Do_unwrap_when_unverified_v<_BidIt>;

    template <class _Src, enable_if_t<_Wrapped_seekable_v<_BidIt, const _Src&>, int> = 0>
    constexpr void _Seek_to(const reverse_iterator<_Src>& _It) noexcept(noexcept(current._Seek_to(_It.current))) {
        current._Seek_to(_It.current);
    }

    [[nodiscard]] constexpr const _BidIt& _Get_current() const noexcept {
        return current;
    }

protected:
    _BidIt current{};
};

 template <class _BidIt1, class _BidIt2>
[[nodiscard]] constexpr bool
    operator==(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
        noexcept(_Fake_copy_init<bool>(_Left._Get_current() == _Right._Get_current())))  

    
    requires requires {
        { _Left._Get_current() == _Right._Get_current() } -> _Implicitly_convertible_to<bool>;
    }

#line 1473 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
{
    return _Left._Get_current() == _Right._Get_current();
}

 template <class _BidIt1, class _BidIt2>
[[nodiscard]] constexpr bool
    operator!=(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
        noexcept(_Fake_copy_init<bool>(_Left._Get_current() != _Right._Get_current())))  

    
    requires requires {
        { _Left._Get_current() != _Right._Get_current() } -> _Implicitly_convertible_to<bool>;
    }

#line 1488 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
{
    return _Left._Get_current() != _Right._Get_current();
}

 template <class _BidIt1, class _BidIt2>
[[nodiscard]] constexpr bool
    operator<(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
        noexcept(_Fake_copy_init<bool>(_Left._Get_current() > _Right._Get_current())))  

    
    requires requires {
        { _Left._Get_current() > _Right._Get_current() } -> _Implicitly_convertible_to<bool>;
    }

#line 1503 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
{
    return _Left._Get_current() > _Right._Get_current();
}

 template <class _BidIt1, class _BidIt2>
[[nodiscard]] constexpr bool
    operator>(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
        noexcept(_Fake_copy_init<bool>(_Left._Get_current() < _Right._Get_current())))  

    
    requires requires {
        { _Left._Get_current() < _Right._Get_current() } -> _Implicitly_convertible_to<bool>;
    }

#line 1518 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
{
    return _Left._Get_current() < _Right._Get_current();
}

 template <class _BidIt1, class _BidIt2>
[[nodiscard]] constexpr bool
    operator<=(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
        noexcept(_Fake_copy_init<bool>(_Left._Get_current() >= _Right._Get_current())))  

    
    requires requires {
        { _Left._Get_current() >= _Right._Get_current() } -> _Implicitly_convertible_to<bool>;
    }

#line 1533 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
{
    return _Left._Get_current() >= _Right._Get_current();
}

 template <class _BidIt1, class _BidIt2>
[[nodiscard]] constexpr bool
    operator>=(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
        noexcept(_Fake_copy_init<bool>(_Left._Get_current() <= _Right._Get_current())))  

    
    requires requires {
        { _Left._Get_current() <= _Right._Get_current() } -> _Implicitly_convertible_to<bool>;
    }

#line 1548 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
{
    return _Left._Get_current() <= _Right._Get_current();
}


 template <class _BidIt1, three_way_comparable_with<_BidIt1> _BidIt2>
[[nodiscard]] constexpr compare_three_way_result_t<_BidIt1, _BidIt2>
    operator<=>(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
        noexcept(_Right._Get_current() <=> _Left._Get_current()))   {
    return _Right._Get_current() <=> _Left._Get_current();
}
#line 1560 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

 template <class _BidIt1, class _BidIt2>
[[nodiscard]] constexpr auto
    operator-(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
        noexcept(_Right._Get_current() - _Left._Get_current()))  
    -> decltype(_Right._Get_current() - _Left._Get_current()) {
    return _Right._Get_current() - _Left._Get_current();
}

 template <class _BidIt>
[[nodiscard]] constexpr reverse_iterator<_BidIt> operator+(typename reverse_iterator<_BidIt>::difference_type _Off,
    const reverse_iterator<_BidIt>& _Right) noexcept(noexcept(_Right + _Off))   {
    return _Right + _Off;
}

 template <class _BidIt>
[[nodiscard]] constexpr reverse_iterator<_BidIt> make_reverse_iterator(_BidIt _Iter) noexcept(
    is_nothrow_move_constructible_v<_BidIt>)   {
    return reverse_iterator<_BidIt>(::std:: move(_Iter));
}


template <class _BidIt1, class _BidIt2>
    requires (!sized_sentinel_for<_BidIt1, _BidIt2>)
inline constexpr bool disable_sized_sentinel_for<reverse_iterator<_BidIt1>, reverse_iterator<_BidIt2>> = true;
#line 1586 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

 template <class _Container>
[[nodiscard]] constexpr auto begin(_Container& _Cont) noexcept(noexcept(_Cont.begin()))  
    -> decltype(_Cont.begin()) {
    return _Cont.begin();
}

 template <class _Container>
[[nodiscard]] constexpr auto begin(const _Container& _Cont) noexcept(noexcept(_Cont.begin()))  
    -> decltype(_Cont.begin()) {
    return _Cont.begin();
}

 template <class _Container>
[[nodiscard]] constexpr auto end(_Container& _Cont) noexcept(noexcept(_Cont.end()))  
    -> decltype(_Cont.end()) {
    return _Cont.end();
}

 template <class _Container>
[[nodiscard]] constexpr auto end(const _Container& _Cont) noexcept(noexcept(_Cont.end()))  
    -> decltype(_Cont.end()) {
    return _Cont.end();
}

 template <class _Ty, size_t _Size>
[[nodiscard]] constexpr _Ty* begin(_Ty (&_Array)[_Size]) noexcept {
    return _Array;
}

 template <class _Ty, size_t _Size>
[[nodiscard]] constexpr _Ty* end(_Ty (&_Array)[_Size]) noexcept {
    return _Array + _Size;
}

 template <class _Container>
[[nodiscard]] constexpr auto cbegin(const _Container& _Cont) noexcept(noexcept(::std:: begin(_Cont)))
    -> decltype(::std:: begin(_Cont)) {
    return ::std:: begin(_Cont);
}

 template <class _Container>
[[nodiscard]] constexpr auto cend(const _Container& _Cont) noexcept(noexcept(::std:: end(_Cont)))
    -> decltype(::std:: end(_Cont)) {
    return ::std:: end(_Cont);
}

 template <class _Container>
[[nodiscard]] constexpr auto rbegin(_Container& _Cont) noexcept(noexcept(_Cont.rbegin()))  
    -> decltype(_Cont.rbegin()) {
    return _Cont.rbegin();
}

 template <class _Container>
[[nodiscard]] constexpr auto rbegin(const _Container& _Cont) noexcept(noexcept(_Cont.rbegin()))  
    -> decltype(_Cont.rbegin()) {
    return _Cont.rbegin();
}

 template <class _Container>
[[nodiscard]] constexpr auto rend(_Container& _Cont) noexcept(noexcept(_Cont.rend()))  
    -> decltype(_Cont.rend()) {
    return _Cont.rend();
}

 template <class _Container>
[[nodiscard]] constexpr auto rend(const _Container& _Cont) noexcept(noexcept(_Cont.rend()))  
    -> decltype(_Cont.rend()) {
    return _Cont.rend();
}

 template <class _Ty, size_t _Size>
[[nodiscard]] constexpr reverse_iterator<_Ty*> rbegin(_Ty (&_Array)[_Size]) noexcept   {
    return reverse_iterator<_Ty*>(_Array + _Size);
}

 template <class _Ty, size_t _Size>
[[nodiscard]] constexpr reverse_iterator<_Ty*> rend(_Ty (&_Array)[_Size]) noexcept   {
    return reverse_iterator<_Ty*>(_Array);
}

 template <class _Elem>
[[nodiscard]] constexpr reverse_iterator<const _Elem*> rbegin(initializer_list<_Elem> _Ilist) noexcept
  {
    return reverse_iterator<const _Elem*>(_Ilist.end());
}

 template <class _Elem>
[[nodiscard]] constexpr reverse_iterator<const _Elem*> rend(initializer_list<_Elem> _Ilist) noexcept
  {
    return reverse_iterator<const _Elem*>(_Ilist.begin());
}

 template <class _Container>
[[nodiscard]] constexpr auto crbegin(const _Container& _Cont) noexcept(noexcept(::std:: rbegin(_Cont)))  
    -> decltype(::std:: rbegin(_Cont)) {
    return ::std:: rbegin(_Cont);
}

 template <class _Container>
[[nodiscard]] constexpr auto crend(const _Container& _Cont) noexcept(noexcept(::std:: rend(_Cont)))  
    -> decltype(::std:: rend(_Cont)) {
    return ::std:: rend(_Cont);
}

 template <class _Container>
[[nodiscard]] constexpr auto size(const _Container& _Cont) noexcept(noexcept(_Cont.size()))  
    -> decltype(_Cont.size()) {
    return _Cont.size();
}

 template <class _Ty, size_t _Size>
[[nodiscard]] constexpr size_t size(const _Ty (&)[_Size]) noexcept {
    return _Size;
}


 template <class _Container>
[[nodiscard]] constexpr auto ssize(const _Container& _Cont) noexcept(noexcept(
    static_cast<common_type_t<ptrdiff_t, make_signed_t<decltype(_Cont.size())>>>(_Cont.size())))  
    -> common_type_t<ptrdiff_t, make_signed_t<decltype(_Cont.size())>> {
    using _Common = common_type_t<ptrdiff_t, make_signed_t<decltype(_Cont.size())>>;
    return static_cast<_Common>(_Cont.size());
}

 template <class _Ty, ptrdiff_t _Size>
[[nodiscard]] constexpr ptrdiff_t ssize(const _Ty (&)[_Size]) noexcept {
    return _Size;
}
#line 1716 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

 template <class _Container>
[[nodiscard("This function returns a bool indicating whether the container or container-like object is empty and " "has no other effects. It is not useful to call this function and discard the return value.")]] constexpr auto empty(const _Container& _Cont) noexcept(
    noexcept(_Cont.empty()))  
    -> decltype(_Cont.empty()) {
    return _Cont.empty();
}

 template <class _Ty, size_t _Size>
[[nodiscard("This function returns a bool indicating whether the container or container-like object is empty and " "has no other effects. It is not useful to call this function and discard the return value.")]] constexpr bool empty(const _Ty (&)[_Size]) noexcept {
    return false;
}

 template <class _Elem>
[[nodiscard("This function returns a bool indicating whether the container or container-like object is empty and " "has no other effects. It is not useful to call this function and discard the return value.")]] constexpr bool empty(initializer_list<_Elem> _Ilist) noexcept {
    return _Ilist.size() == 0;
}

 template <class _Container>
[[nodiscard]] constexpr auto data(_Container& _Cont) noexcept(noexcept(_Cont.data()))  
    -> decltype(_Cont.data()) {
    return _Cont.data();
}

 template <class _Container>
[[nodiscard]] constexpr auto data(const _Container& _Cont) noexcept(noexcept(_Cont.data()))  
    -> decltype(_Cont.data()) {
    return _Cont.data();
}

 template <class _Ty, size_t _Size>
[[nodiscard]] constexpr _Ty* data(_Ty (&_Array)[_Size]) noexcept {
    return _Array;
}

 template <class _Elem>
[[nodiscard]] constexpr const _Elem* data(initializer_list<_Elem> _Ilist) noexcept {
    return _Ilist.begin();
}















































































































































































































































































































































#line 2091 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

namespace ranges {
    template <class>
    inline constexpr bool _Has_complete_elements = false;

    template <class _Ty>
        requires requires(_Ty& __t) { sizeof(__t[0]); }
    inline constexpr bool _Has_complete_elements<_Ty> = true;

     template <class>
    inline constexpr bool enable_borrowed_range = false;

    template <class _Rng>
    concept _Should_range_access = is_lvalue_reference_v<_Rng> || enable_borrowed_range<remove_cvref_t<_Rng>>;

    namespace _Begin {


#line 2110 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        void begin();
#line 2112 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

        template <class _Ty>
        concept _Has_member = requires(_Ty __t) {
                                  { _Fake_copy_init(__t.begin()) } -> input_or_output_iterator;
                              };

        template <class _Ty>
        concept _Has_ADL = _Has_class_or_enum_type<_Ty> 
                        && requires(_Ty __t) {
                               { _Fake_copy_init(begin(__t)) } -> input_or_output_iterator; 
                           };

        class _Cpo {
        private:
            enum class _St { _None, _Array, _Member, _Non_member };

            template <class _Ty>
            [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
                 ;
                if constexpr (is_array_v<remove_reference_t<_Ty>>) {
                    static_assert(_Has_complete_elements<_Ty>,
                        "The range access customization point objects "
                        "std::ranges::begin, std::ranges::end, std::ranges::rbegin, std::ranges::rend, "
                        "and std::ranges::data do not accept arrays with incomplete element types.");
                    return {_St::_Array, true};
                } else if constexpr (_Has_member<_Ty>) {
                    return {_St::_Member, noexcept(_Fake_copy_init(::std:: declval<_Ty>().begin()))};
                } else if constexpr (_Has_ADL<_Ty>) {
                    return {_St::_Non_member, noexcept(_Fake_copy_init(begin(::std:: declval<_Ty>())))}; 
                } else {
                    return {_St::_None};
                }
            }

            template <class _Ty>
            static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();

        public:
            template <_Should_range_access _Ty>
                requires (_Choice<_Ty&>._Strategy != _St::_None)
            [[nodiscard]] constexpr auto operator()(_Ty&& _Val) const noexcept(_Choice<_Ty&>._No_throw) {
                constexpr _St _Strat = _Choice<_Ty&>._Strategy;

                if constexpr (_Strat == _St::_Array) {
                    return _Val;
                } else if constexpr (_Strat == _St::_Member) {
                    return _Val.begin();
                } else if constexpr (_Strat == _St::_Non_member) {
                    return begin(_Val); 
                } else {
                    static_assert(_Always_false<_Ty>, "Should be unreachable");
                }
            }
        };
    } 

    inline namespace _Cpos {
         inline constexpr _Begin::_Cpo begin;
    }

     template <class _Ty>
    using iterator_t = decltype(::std::ranges:: begin(::std:: declval<_Ty&>()));

    namespace _End {


#line 2179 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        void end();
#line 2181 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

        template <class _Ty>
        concept _Has_member = requires(_Ty __t) {
                                  { _Fake_copy_init(__t.end()) } -> sentinel_for<iterator_t<_Ty>>;
                              };

        template <class _Ty>
        concept _Has_ADL = _Has_class_or_enum_type<_Ty> 
                        && requires(_Ty __t) {
                               { _Fake_copy_init(end(__t)) } -> sentinel_for<iterator_t<_Ty>>; 
                           };

        class _Cpo {
        private:
            enum class _St { _None, _Array, _Member, _Non_member };

            template <class _Ty>
            [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
                 ;
                using _UnRef = remove_reference_t<_Ty>;

                if constexpr (is_array_v<_UnRef>) {
                    static_assert(_Has_complete_elements<_UnRef>,
                        "The range access customization point objects "
                        "std::ranges::begin, std::ranges::end, std::ranges::rbegin, std::ranges::rend, "
                        "and std::ranges::data do not accept arrays with incomplete element types.");
                    if constexpr (extent_v<_UnRef> != 0) {
                        return {_St::_Array, true};
                    } else {
                        return {_St::_None};
                    }
                } else if constexpr (_Has_member<_Ty>) {
                    return {_St::_Member, noexcept(_Fake_copy_init(::std:: declval<_Ty>().end()))};
                } else if constexpr (_Has_ADL<_Ty>) {
                    return {_St::_Non_member, noexcept(_Fake_copy_init(end(::std:: declval<_Ty>())))}; 
                } else {
                    return {_St::_None};
                }
            }

            template <class _Ty>
            static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();

        public:
            template <_Should_range_access _Ty>
                requires (_Choice<_Ty&>._Strategy != _St::_None)
            [[nodiscard]] constexpr auto operator()(_Ty&& _Val) const noexcept(_Choice<_Ty&>._No_throw) {
                constexpr _St _Strat = _Choice<_Ty&>._Strategy;

                if constexpr (_Strat == _St::_Array) {
                    
                    return _Val + extent_v<remove_reference_t<_Ty&>>;
                } else if constexpr (_Strat == _St::_Member) {
                    return _Val.end();
                } else if constexpr (_Strat == _St::_Non_member) {
                    return end(_Val); 
                } else {
                    static_assert(_Always_false<_Ty>, "should be unreachable");
                }
            }
        };
    } 

    inline namespace _Cpos {
         inline constexpr _End::_Cpo end;
    }

     template <class _Rng>
    concept range = requires(_Rng & __r) {
                        ::std::ranges:: begin(__r);
                        ::std::ranges:: end(__r);
                    };

     template <class _Rng>
    concept input_range = range<_Rng> && input_iterator<iterator_t<_Rng>>;

     template <range _Rng>
    using sentinel_t = decltype(::std::ranges:: end(::std:: declval<_Rng&>()));

    template <class _Wrapped>
    concept _Weakly_unwrappable =
        same_as<typename remove_cvref_t<_Wrapped>::_Prevent_inheriting_unwrap, remove_cvref_t<_Wrapped>>
        && requires(_Wrapped&& _Wr) { ::std:: forward<_Wrapped>(_Wr)._Unwrapped(); };

    template <class _Sent>
    concept _Weakly_unwrappable_sentinel = _Weakly_unwrappable<const remove_reference_t<_Sent>&>;

    template <class _Iter>
    concept _Weakly_unwrappable_iterator = 
        _Weakly_unwrappable<_Iter> 
        && requires(
            _Iter&& _It, remove_cvref_t<_Iter>& _MutIt) { _MutIt._Seek_to(::std:: forward<_Iter>(_It)._Unwrapped()); };

    template <class _Sent, class _Iter>
    concept _Unwrappable_sentinel_for = 
        _Weakly_unwrappable_sentinel<_Sent> 
        && _Weakly_unwrappable_iterator<_Iter> 
        && requires(_Iter&& _It, const remove_reference_t<_Sent>& _Se) {
               { _Se._Unwrapped() } -> sentinel_for<decltype(::std:: forward<_Iter>(_It)._Unwrapped())>;
           };

    template <class _Sent, class _Iter>
    [[nodiscard]] constexpr decltype(auto) _Unwrap_iter(_Iter&& _It) noexcept(
        !_Unwrappable_sentinel_for<_Sent, _Iter> || _Has_nothrow_unwrapped<_Iter>) {
         ;
        if constexpr (is_pointer_v<remove_cvref_t<_Iter>>) {
            return _It + 0;
        } else if constexpr (_Unwrappable_sentinel_for<_Sent, _Iter>) {
            return static_cast<_Iter&&>(_It)._Unwrapped();
        } else {
            return static_cast<_Iter&&>(_It);
        }
    }

    template <class _Iter, class _Sent>
    [[nodiscard]] constexpr decltype(auto) _Unwrap_sent(_Sent&& _Se) noexcept(
        !_Unwrappable_sentinel_for<_Sent, _Iter> || _Has_nothrow_unwrapped<_Sent>) {
         ;
        if constexpr (is_pointer_v<remove_cvref_t<_Sent>>) {
            return _Se + 0;
        } else if constexpr (_Unwrappable_sentinel_for<_Sent, _Iter>) {
            return static_cast<_Sent&&>(_Se)._Unwrapped();
        } else {
            return static_cast<_Sent&&>(_Se);
        }
    }

    template <range _Rng, class _Iter>
    [[nodiscard]] constexpr decltype(auto) _Unwrap_range_iter(_Iter&& _It) noexcept(
        noexcept(_Unwrap_iter<sentinel_t<_Rng>>(static_cast<_Iter&&>(_It)))) {
         ;
        return _Unwrap_iter<sentinel_t<_Rng>>(static_cast<_Iter&&>(_It));
    }

    template <range _Rng, class _Sent>
    [[nodiscard]] constexpr decltype(auto) _Unwrap_range_sent(_Sent&& _Se) noexcept(
        noexcept(_Unwrap_sent<iterator_t<_Rng>>(static_cast<_Sent&&>(_Se)))) {
         ;
        return _Unwrap_sent<iterator_t<_Rng>>(static_cast<_Sent&&>(_Se));
    }

    template <class _Iter, class _Sent>
    using _Unwrap_iter_t = remove_cvref_t<decltype(_Unwrap_iter<_Sent>(::std:: declval<_Iter>()))>;
    template <class _Sent, class _Iter>
    using _Unwrap_sent_t = remove_cvref_t<decltype(_Unwrap_sent<_Iter>(::std:: declval<_Sent>()))>;

    template <range _Rng>
    using _Unwrapped_iterator_t = _Unwrap_iter_t<iterator_t<_Rng>, sentinel_t<_Rng>>;
    template <range _Rng>
    using _Unwrapped_sentinel_t = _Unwrap_sent_t<sentinel_t<_Rng>, iterator_t<_Rng>>;

    namespace _Unchecked_begin {
        template <class _Ty>
        concept _Has_member = requires(_Ty& __t) {
                                  { __t._Unchecked_begin() } -> input_or_output_iterator;
                              };

        template <class _Ty>
        concept _Can_begin = requires(_Ty& __t) { _Unwrap_range_iter<_Ty>(::std::ranges:: begin(__t)); };

        class _Cpo {
        private:
            enum class _St { _None, _Member, _Unwrap };

            template <class _Ty>
            [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
                 ;
                if constexpr (_Has_member<_Ty>) {
                    
;
                    return {_St::_Member, noexcept(_Fake_copy_init(::std:: declval<_Ty>()._Unchecked_begin()))};
                } else if constexpr (_Can_begin<_Ty>) {
                    return {_St::_Unwrap,
                        noexcept(_Fake_copy_init(_Unwrap_range_iter<_Ty>(::std::ranges:: begin(::std:: declval<_Ty>()))))};
                } else {
                    return {_St::_None};
                }
            }

            template <class _Ty>
            static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();

        public:
            template <_Should_range_access _Ty>
                requires (_Choice<_Ty&>._Strategy != _St::_None)
            [[nodiscard]] constexpr auto operator()(_Ty&& _Val) const noexcept(_Choice<_Ty&>._No_throw) {
                constexpr _St _Strat = _Choice<_Ty&>._Strategy;

                if constexpr (_Strat == _St::_Member) {
                    return _Val._Unchecked_begin();
                } else if constexpr (_Strat == _St::_Unwrap) {
                    return _Unwrap_range_iter<_Ty>(::std::ranges:: begin(_Val));
                } else {
                    static_assert(_Always_false<_Ty>, "Should be unreachable");
                }
            }
        };
    } 

    inline namespace _Cpos {
        inline constexpr _Unchecked_begin::_Cpo _Ubegin;
    }

    namespace _Unchecked_end {
        template <class _Ty>
        concept _Has_member = _Unchecked_begin::_Has_member<_Ty>
                           && requires(_Ty& __t) {
                                  __t._Unchecked_begin(); 
                                  { __t._Unchecked_end() } -> sentinel_for<decltype(__t._Unchecked_begin())>;
                              };

        template <class _Ty>
        concept _Can_end = requires(_Ty& __t) { _Unwrap_range_sent<_Ty>(::std::ranges:: end(__t)); };

        class _Cpo {
        private:
            enum class _St { _None, _Member, _Unwrap };

            template <class _Ty>
            [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
                 ;
                if constexpr (_Has_member<_Ty>) {
                    return {_St::_Member, noexcept(::std:: declval<_Ty>()._Unchecked_end())};
                } else if constexpr (_Can_end<_Ty>) {
                    return {_St::_Unwrap, noexcept(_Unwrap_range_sent<_Ty>(::std::ranges:: end(::std:: declval<_Ty>())))};
                } else {
                    return {_St::_None};
                }
            }

            template <class _Ty>
            static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();

        public:
            template <_Should_range_access _Ty>
                requires (_Choice<_Ty&>._Strategy != _St::_None)
            [[nodiscard]] constexpr auto operator()(_Ty&& _Val) const noexcept(_Choice<_Ty&>._No_throw) {
                constexpr _St _Strat = _Choice<_Ty&>._Strategy;

                if constexpr (_Strat == _St::_Member) {
                    return _Val._Unchecked_end();
                } else if constexpr (_Strat == _St::_Unwrap) {
                    return _Unwrap_range_sent<_Ty>(::std::ranges:: end(_Val));
                } else {
                    static_assert(_Always_false<_Ty>, "Should be unreachable");
                }
            }
        };
    } 

    inline namespace _Cpos {
        inline constexpr _Unchecked_end::_Cpo _Uend;
    }

     template <class _Rng>
    concept borrowed_range = range<_Rng> && _Should_range_access<_Rng>;

     template <range _Rng>
    using range_difference_t = iter_difference_t<iterator_t<_Rng>>;

     template <range _Rng>
    using range_value_t = iter_value_t<iterator_t<_Rng>>;

     template <range _Rng>
    using range_reference_t = iter_reference_t<iterator_t<_Rng>>;

     template <range _Rng>
    using range_rvalue_reference_t = iter_rvalue_reference_t<iterator_t<_Rng>>;






































#line 2488 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

    struct _Cbegin_fn {






#line 2497 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        template <class _Ty, class _CTy = _Const_thru_ref<_Ty>>
        [[nodiscard]] constexpr auto operator()(_Ty&& _Val) const
            noexcept(noexcept(::std::ranges:: begin(static_cast<_CTy&&>(_Val))))
            requires requires { ::std::ranges:: begin(static_cast<_CTy&&>(_Val)); }
        {
            return ::std::ranges:: begin(static_cast<_CTy&&>(_Val));
        }
#line 2505 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
    };

    inline namespace _Cpos {
         inline constexpr _Cbegin_fn cbegin;
    }

    struct _Cend_fn {






#line 2519 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        template <class _Ty, class _CTy = _Const_thru_ref<_Ty>>
        [[nodiscard]] constexpr auto operator()(_Ty&& _Val) const
            noexcept(noexcept(::std::ranges:: end(static_cast<_CTy&&>(_Val))))
            requires requires { ::std::ranges:: end(static_cast<_CTy&&>(_Val)); }
        {
            return ::std::ranges:: end(static_cast<_CTy&&>(_Val));
        }
#line 2527 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
    };

    inline namespace _Cpos {
         inline constexpr _Cend_fn cend;
    }

    namespace _Rbegin {


#line 2537 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        void rbegin();
#line 2539 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

        template <class _Ty>
        concept _Has_member = requires(_Ty __t) {
                                  { _Fake_copy_init(__t.rbegin()) } -> input_or_output_iterator;
                              };

        template <class _Ty>
        concept _Has_ADL = _Has_class_or_enum_type<_Ty> 
                        && requires(_Ty __t) {
                               { _Fake_copy_init(rbegin(__t)) } -> input_or_output_iterator; 
                           };

        template <class _Ty>
        concept _Can_make_reverse = requires(_Ty __t) {
                                        { ::std::ranges:: begin(__t) } -> bidirectional_iterator;
                                        { ::std::ranges:: end(__t) } -> same_as<decltype(::std::ranges:: begin(__t))>;
                                    };

        class _Cpo {
        private:
            enum class _St { _None, _Member, _Non_member, _Make_reverse };

            template <class _Ty>
            [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
                 ;
                if constexpr (_Has_member<_Ty>) {
                    return {_St::_Member, noexcept(_Fake_copy_init(::std:: declval<_Ty>().rbegin()))};
                } else if constexpr (_Has_ADL<_Ty>) {
                    return {
                        _St::_Non_member, noexcept(_Fake_copy_init(rbegin(::std:: declval<_Ty>())))}; 
                } else if constexpr (_Can_make_reverse<_Ty>) {
                    return {_St::_Make_reverse, noexcept(::std:: make_reverse_iterator(::std::ranges:: end(::std:: declval<_Ty>())))};
                } else {
                    return {_St::_None};
                }
            }

            template <class _Ty>
            static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();

        public:
            template <_Should_range_access _Ty>
                requires (_Choice<_Ty&>._Strategy != _St::_None)
            [[nodiscard]] constexpr auto operator()(_Ty&& _Val) const noexcept(_Choice<_Ty&>._No_throw) {
                constexpr _St _Strat = _Choice<_Ty&>._Strategy;

                if constexpr (_Strat == _St::_Member) {
                    return _Val.rbegin();
                } else if constexpr (_Strat == _St::_Non_member) {
                    return rbegin(_Val); 
                } else if constexpr (_Strat == _St::_Make_reverse) {
                    return ::std:: make_reverse_iterator(::std::ranges:: end(_Val));
                } else {
                    static_assert(_Always_false<_Ty>, "should be unreachable");
                }
            }
        };
    } 

    inline namespace _Cpos {
         inline constexpr _Rbegin::_Cpo rbegin;
    }

    namespace _Rend {


#line 2606 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        void rend();
#line 2608 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

        template <class _Ty>
        concept _Has_member = requires(_Ty __t) {
                                  { _Fake_copy_init(__t.rend()) } -> sentinel_for<decltype(::std::ranges:: rbegin(__t))>;
                              };

        template <class _Ty>
        concept _Has_ADL = _Has_class_or_enum_type<_Ty> 
                        && requires(_Ty __t) {
                               
                               { _Fake_copy_init(rend(__t)) } -> sentinel_for<decltype(::std::ranges:: rbegin(__t))>;
                           };

        template <class _Ty>
        concept _Can_make_reverse = requires(_Ty __t) {
                                        { ::std::ranges:: begin(__t) } -> bidirectional_iterator;
                                        { ::std::ranges:: end(__t) } -> same_as<decltype(::std::ranges:: begin(__t))>;
                                    };

        class _Cpo {
        private:
            enum class _St { _None, _Member, _Non_member, _Make_reverse };

            template <class _Ty>
            [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
                 ;
                if constexpr (_Has_member<_Ty>) {
                    return {_St::_Member, noexcept(_Fake_copy_init(::std:: declval<_Ty>().rend()))};
                } else if constexpr (_Has_ADL<_Ty>) {
                    return {_St::_Non_member, noexcept(_Fake_copy_init(rend(::std:: declval<_Ty>())))}; 
                } else if constexpr (_Can_make_reverse<_Ty>) {
                    return {
                        _St::_Make_reverse, noexcept(::std:: make_reverse_iterator(::std::ranges:: begin(::std:: declval<_Ty>())))};
                } else {
                    return {_St::_None};
                }
            }

            template <class _Ty>
            static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();

        public:
            template <_Should_range_access _Ty>
                requires (_Choice<_Ty&>._Strategy != _St::_None)
            [[nodiscard]] constexpr auto operator()(_Ty&& _Val) const noexcept(_Choice<_Ty&>._No_throw) {
                constexpr _St _Strat = _Choice<_Ty&>._Strategy;

                if constexpr (_Strat == _St::_Member) {
                    return _Val.rend();
                } else if constexpr (_Strat == _St::_Non_member) {
                    return rend(_Val); 
                } else if constexpr (_Strat == _St::_Make_reverse) {
                    return ::std:: make_reverse_iterator(::std::ranges:: begin(_Val));
                } else {
                    static_assert(_Always_false<_Ty>, "should be unreachable");
                }
            }
        };
    } 

    inline namespace _Cpos {
         inline constexpr _Rend::_Cpo rend;
    }





















#line 2693 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

    struct _Crbegin_fn {






#line 2702 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        template <class _Ty, class _CTy = _Const_thru_ref<_Ty>>
        [[nodiscard]] constexpr auto operator()(_Ty&& _Val) const
            noexcept(noexcept(::std::ranges:: rbegin(static_cast<_CTy&&>(_Val))))
            requires requires { ::std::ranges:: rbegin(static_cast<_CTy&&>(_Val)); }
        {
            return ::std::ranges:: rbegin(static_cast<_CTy&&>(_Val));
        }
#line 2710 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
    };

    inline namespace _Cpos {
         inline constexpr _Crbegin_fn crbegin;
    }

    struct _Crend_fn {






#line 2724 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        template <class _Ty, class _CTy = _Const_thru_ref<_Ty>>
        [[nodiscard]] constexpr auto operator()(_Ty&& _Val) const
            noexcept(noexcept(::std::ranges:: rend(static_cast<_CTy&&>(_Val))))
            requires requires { ::std::ranges:: rend(static_cast<_CTy&&>(_Val)); }
        {
            return ::std::ranges:: rend(static_cast<_CTy&&>(_Val));
        }
#line 2732 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
    };

    inline namespace _Cpos {
         inline constexpr _Crend_fn crend;
    }

     template <class>
    inline constexpr bool disable_sized_range = false;

    namespace _Size {


#line 2745 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        void size();
#line 2747 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

        template <class _Ty, class _UnCV>
        concept _Has_member = (!disable_sized_range<_UnCV>) 
                           && requires(_Ty __t) {
                                  { _Fake_copy_init(__t.size()) } -> _Integer_like;
                              };

        template <class _Ty, class _UnCV>
        concept _Has_ADL = _Has_class_or_enum_type<_Ty> && (!disable_sized_range<_UnCV>) 
                        && requires(_Ty __t) {
                               { _Fake_copy_init(size(__t)) } -> _Integer_like; 
                           };

        template <class _Ty>
        concept _Can_difference = requires(_Ty __t) {
                                      { ::std::ranges:: begin(__t) } -> forward_iterator;
                                      { ::std::ranges:: end(__t) } -> sized_sentinel_for<decltype(::std::ranges:: begin(__t))>;
                                  };

        class _Cpo {
        private:
            enum class _St { _None, _Array, _Member, _Non_member, _Subtract };

            template <class _Ty>
            [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
                 ;
                using _UnCV = remove_cvref_t<_Ty>;

                if constexpr (is_array_v<_UnCV>) {
                    if constexpr (extent_v<_UnCV> != 0) {
                        return {_St::_Array, true};
                    } else {
                        return {_St::_None};
                    }
                } else if constexpr (_Has_member<_Ty, _UnCV>) {
                    return {_St::_Member, noexcept(_Fake_copy_init(::std:: declval<_Ty>().size()))};
                } else if constexpr (_Has_ADL<_Ty, _UnCV>) {
                    return {_St::_Non_member, noexcept(_Fake_copy_init(size(::std:: declval<_Ty>())))}; 
                } else if constexpr (_Can_difference<_Ty>) {
                    return {_St::_Subtract,
                        noexcept(::std::ranges:: end(::std:: declval<_Ty>()) - ::std::ranges:: begin(::std:: declval<_Ty>()))};
                } else {
                    return {_St::_None};
                }
            }

            template <class _Ty>
            static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();

        public:
            template <class _Ty>
                requires (_Choice<_Ty&>._Strategy != _St::_None)
            [[nodiscard]] constexpr auto operator()(_Ty&& _Val) const noexcept(_Choice<_Ty&>._No_throw) {
                constexpr _St _Strat = _Choice<_Ty&>._Strategy;

                if constexpr (_Strat == _St::_Array) {
                    
                    return extent_v<remove_cvref_t<_Ty&>>;
                } else if constexpr (_Strat == _St::_Member) {
                    return _Val.size();
                } else if constexpr (_Strat == _St::_Non_member) {
                    return size(_Val); 
                } else if constexpr (_Strat == _St::_Subtract) {
                    const auto _Delta = ::std::ranges:: end(_Val) - ::std::ranges:: begin(_Val);
                    return static_cast<_Make_unsigned_like_t<remove_cv_t<decltype(_Delta)>>>(_Delta);
                } else {
                    static_assert(_Always_false<_Ty>, "should be unreachable");
                }
            }
        };
    } 

    inline namespace _Cpos {
         inline constexpr _Size::_Cpo size;
    }

    namespace _Empty {
        template <class _Ty>
        concept _Has_member = requires(_Ty __t) { static_cast<bool>(__t.empty()); };

        template <class _Ty>
        concept _Has_size = requires(_Ty __t) { ::std::ranges:: size(__t); };

        template <class _Ty>
        concept _Can_begin_end = requires(_Ty __t) {
                                     { ::std::ranges:: begin(__t) } -> forward_iterator;
                                     ::std::ranges:: end(__t);
                                 };

        class _Cpo {
        private:
            enum class _St { _None, _Member, _Size, _Compare };

            template <class _Ty>
            [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
                 ;
                if constexpr (is_unbounded_array_v<remove_reference_t<_Ty>>) {
                    return {_St::_None};
                } else if constexpr (_Has_member<_Ty>) {
                    return {_St::_Member, noexcept(static_cast<bool>(::std:: declval<_Ty>().empty()))};
                } else if constexpr (_Has_size<_Ty>) {
                    return {_St::_Size, noexcept(::std::ranges:: size(::std:: declval<_Ty>()))};
                } else if constexpr (_Can_begin_end<_Ty>) {
                    constexpr auto _Nothrow = noexcept(
                        static_cast<bool>(::std::ranges:: begin(::std:: declval<_Ty>()) == ::std::ranges:: end(::std:: declval<_Ty>())));
                    return {_St::_Compare, _Nothrow};
                } else {
                    return {_St::_None};
                }
            }

            template <class _Ty>
            static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();

        public:
            
            template <class _Ty>
                requires (_Choice<_Ty&>._Strategy != _St::_None)
            [[nodiscard]] constexpr bool operator()(_Ty&& _Val) const noexcept(_Choice<_Ty&>._No_throw) {
                constexpr _St _Strat = _Choice<_Ty&>._Strategy;

                if constexpr (_Strat == _St::_Member) {
                    return static_cast<bool>(_Val.empty());
                } else if constexpr (_Strat == _St::_Size) {
                    return ::std::ranges:: size(_Val) == 0;
                } else if constexpr (_Strat == _St::_Compare) {
                    return static_cast<bool>(::std::ranges:: begin(_Val) == ::std::ranges:: end(_Val));
                } else {
                    static_assert(_Always_false<_Ty>, "should be unreachable");
                }
            }
            
        };
    } 

    inline namespace _Cpos {
         inline constexpr _Empty::_Cpo empty;
    }

    namespace _Data {
        template <class _Ty>
        concept _Points_to_object = is_pointer_v<_Ty> && is_object_v<remove_pointer_t<_Ty>>;

        template <class _Ty>
        concept _Has_member = requires(_Ty __t) {
                                  { _Fake_copy_init(__t.data()) } -> _Points_to_object;
                              };

        template <class _Ty>
        concept _Has_contiguous_iterator = requires(_Ty __t) {
                                               { ::std::ranges:: begin(__t) } -> contiguous_iterator;
                                           };

        class _Cpo {
        private:
            enum class _St { _None, _Member, _Address };

            template <class _Ty>
            [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
                 ;
                if constexpr (_Has_member<_Ty>) {
                    return {_St::_Member, noexcept(::std:: declval<_Ty>().data())};
                } else if constexpr (_Has_contiguous_iterator<_Ty>) {
                    return {_St::_Address, noexcept(::std:: to_address(::std::ranges:: begin(::std:: declval<_Ty>())))};
                } else {
                    return {_St::_None};
                }
            }

            template <class _Ty>
            static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();

        public:
            template <_Should_range_access _Ty>
                requires (_Choice<_Ty&>._Strategy != _St::_None)
            [[nodiscard]] constexpr auto operator()(_Ty&& _Val) const noexcept(_Choice<_Ty&>._No_throw) {
                constexpr _St _Strat = _Choice<_Ty&>._Strategy;

                if constexpr (_Strat == _St::_Member) {
                    return _Val.data();
                } else if constexpr (_Strat == _St::_Address) {
                    return ::std:: to_address(::std::ranges:: begin(_Val));
                } else {
                    static_assert(_Always_false<_Ty>, "should be unreachable");
                }
            }
        };
    } 

    inline namespace _Cpos {
         inline constexpr _Data::_Cpo data;
    }







#line 2947 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

    struct _Cdata_fn {






#line 2956 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        template <class _Ty, class _CTy = _Const_thru_ref<_Ty>>
        [[nodiscard]] constexpr auto operator()(_Ty&& _Val) const
            noexcept(noexcept(::std::ranges:: data(static_cast<_CTy&&>(_Val))))
            requires requires { ::std::ranges:: data(static_cast<_CTy&&>(_Val)); }
        {
            return ::std::ranges:: data(static_cast<_CTy&&>(_Val));
        }
#line 2964 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
    };

    inline namespace _Cpos {
         inline constexpr _Cdata_fn cdata;
    }

     template <class _Rng>
    concept sized_range = range<_Rng> && requires(_Rng & __r) { ::std::ranges:: size(__r); };

     template <sized_range _Rng>
    using range_size_t = decltype(::std::ranges:: size(::std:: declval<_Rng&>()));

     struct view_base {};

    template <class _Ty, template <class...> class _Template>
    concept _Strictly_derived_from_specialization_of =
        is_object_v<_Ty> && _Derived_from_specialization_of<_Ty, _Template>;

     template <class _Derived>
        requires is_class_v<_Derived> && same_as<_Derived, remove_cv_t<_Derived>>
    class view_interface;

     template <class _Ty>
    inline constexpr bool enable_view =
        derived_from<_Ty, view_base> || _Strictly_derived_from_specialization_of<_Ty, view_interface>;

     template <class _Ty>
    concept view = range<_Ty> && movable<_Ty> && enable_view<_Ty>;

     template <class _Rng, class _Ty>
    concept output_range = range<_Rng> && output_iterator<iterator_t<_Rng>, _Ty>;

     template <class _Rng>
    concept forward_range = range<_Rng> && forward_iterator<iterator_t<_Rng>>;

     template <class _Rng>
    concept bidirectional_range = range<_Rng> && bidirectional_iterator<iterator_t<_Rng>>;

     template <class _Rng>
    concept random_access_range = range<_Rng> && random_access_iterator<iterator_t<_Rng>>;

     template <class _Rng>
    concept contiguous_range = range<_Rng> && contiguous_iterator<iterator_t<_Rng>>
                            && requires(_Rng & __r) {
                                   { ::std::ranges:: data(__r) } -> same_as<add_pointer_t<range_reference_t<_Rng>>>;
                               };

    class _Not_quite_object {
    public:
        
        
        
        
        

        struct _Construct_tag {
            explicit _Construct_tag() = default;
        };

        _Not_quite_object() = delete;

        constexpr explicit _Not_quite_object(_Construct_tag) noexcept {}

        _Not_quite_object(const _Not_quite_object&)            = delete;
        _Not_quite_object& operator=(const _Not_quite_object&) = delete;

        void operator&() const = delete;

    protected:
        ~_Not_quite_object() = default;
    };

    class _Advance_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_or_output_iterator _It>
        constexpr void operator()(_It& _Where, iter_difference_t<_It> _Off) const {
            if constexpr (random_access_iterator<_It>) {
                _Where += _Off;
            } else {
                if constexpr (!bidirectional_iterator<_It>) {
                     ;
                }

                decltype(auto) _UWhere      = _Get_unwrapped_n(::std:: move(_Where), _Off);
                constexpr bool _Need_rewrap = !is_reference_v<decltype(_Get_unwrapped_n(::std:: move(_Where), _Off))>;

                if constexpr (bidirectional_iterator<_It>) {
                    for (; _Off < 0; ++_Off) {
                        --_UWhere;
                    }
                }

                for (; _Off > 0; --_Off) {
                    ++_UWhere;
                }

                if constexpr (_Need_rewrap) {
                    _Seek_wrapped(_Where, ::std:: move(_UWhere));
                }
            }
        }

        template <input_or_output_iterator _It, sentinel_for<_It> _Se>
        constexpr void operator()(_It& _Where, _Se _Last) const {
            if constexpr (assignable_from<_It&, _Se>) {
                _Where = static_cast<_Se&&>(_Last);
            } else if constexpr (sized_sentinel_for<_Se, _It>) {
                (*this)(_Where, _Last - _Where);
            } else {
                _Adl_verify_range(_Where, _Last);

                decltype(auto) _UWhere      = _Unwrap_iter<_Se>(static_cast<_It&&>(_Where));
                constexpr bool _Need_rewrap = !is_reference_v<decltype(_Unwrap_iter<_Se>(static_cast<_It&&>(_Where)))>;
                decltype(auto) _ULast       = _Unwrap_sent<_It>(static_cast<_Se&&>(_Last));

                while (_UWhere != _ULast) {
                    ++_UWhere;
                }

                if constexpr (_Need_rewrap) {
                    _Seek_wrapped(_Where, ::std:: move(_UWhere));
                }
            }
        }

        template <input_or_output_iterator _It, sentinel_for<_It> _Se>
        constexpr iter_difference_t<_It> operator()(_It& _Where, iter_difference_t<_It> _Off, _Se _Last) const {
            if constexpr (sized_sentinel_for<_Se, _It>) {
                const iter_difference_t<_It> _Delta = _Last - _Where;
                if ((_Off < 0 && _Off <= _Delta) || (_Off > 0 && _Off >= _Delta)) {
                    if constexpr (assignable_from<_It&, _Se>) {
                        _Where = static_cast<_Se&&>(_Last);
                    } else {
                        (*this)(_Where, _Delta);
                    }
                    return _Off - _Delta;
                }

                (*this)(_Where, _Off);
                return 0;
            } else {
                
                if constexpr (bidirectional_iterator<_It>) {
                    for (; _Off < 0 && _Where != _Last; ++_Off) {
                        --_Where;
                    }
                } else {
                     ;
                }

                for (; _Off > 0 && _Where != _Last; --_Off) {
                    ++_Where;
                }

                return _Off;
            }
        }
    };

     inline constexpr _Advance_fn advance{_Not_quite_object::_Construct_tag{}};

    class _Distance_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <class _It, sentinel_for<_It> _Se>
            requires (!sized_sentinel_for<_Se, _It>)
        [[nodiscard]] constexpr iter_difference_t<_It> operator()(_It _First, _Se _Last) const
            noexcept(noexcept(_Distance_unchecked(
                _Get_unwrapped(::std:: move(_First)), _Get_unwrapped(::std:: move(_Last)))))   {
            _Adl_verify_range(_First, _Last);
            return _Distance_unchecked(_Unwrap_iter<_Se>(::std:: move(_First)), _Unwrap_sent<_It>(::std:: move(_Last)));
        }

        template <class _It, sized_sentinel_for<decay_t<_It>> _Se>
        [[nodiscard]] constexpr iter_difference_t<decay_t<_It>> operator()(_It&& _First, const _Se _Last) const
            noexcept(noexcept(_Last - static_cast<const decay_t<_It>&>(_First)))   {
            return _Last - static_cast<const decay_t<_It>&>(_First);
        }

        template <range _Rng>
        [[nodiscard]] constexpr range_difference_t<_Rng> operator()(_Rng&& _Range) const
            noexcept(_Nothrow_size<_Rng>)   {
            if constexpr (sized_range<_Rng>) {
                return static_cast<range_difference_t<_Rng>>(::std::ranges:: size(_Range));
            } else {
                return _Distance_unchecked(_Ubegin(_Range), _Uend(_Range));
            }
        }

    private:
        template <class _It, class _Se>
        [[nodiscard]] static constexpr iter_difference_t<_It> _Distance_unchecked(_It _First, const _Se _Last) noexcept(
            noexcept(++_First != _Last)) {
             ;

            iter_difference_t<_It> _Count = 0;
            for (; _First != _Last; ++_First) {
                ++_Count;
            }

            return _Count;
        }

        template <class _Rng>
        static constexpr bool _Nothrow_size =
            noexcept(_Distance_unchecked(_Ubegin(::std:: declval<_Rng&>()), _Uend(::std:: declval<_Rng&>())));

        template <sized_range _Rng>
        static constexpr bool _Nothrow_size<_Rng> = noexcept(::std::ranges:: size(::std:: declval<_Rng&>()));
    };

     inline constexpr _Distance_fn distance{_Not_quite_object::_Construct_tag{}};

    class _Ssize_fn {
    public:
        
        template <class _Rng>
        [[nodiscard]] constexpr auto operator()(_Rng&& _Range) const requires requires { ::std::ranges:: size(_Range); } {
            using _Sty = _Make_signed_like_t<decltype(::std::ranges:: size(_Range))>;
            using _Ty  = common_type_t<conditional_t<is_integral_v<_Sty>, ptrdiff_t, _Sty>, _Sty>;
            return static_cast<_Ty>(::std::ranges:: size(_Range));
        }
        
    };

    inline namespace _Cpos {
         inline constexpr _Ssize_fn ssize;
    }

    class _Next_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_or_output_iterator _It>
        [[nodiscard]] constexpr _It operator()(_It _Where) const {
            ++_Where;
            return _Where;
        }

        template <input_or_output_iterator _It>
        [[nodiscard]] constexpr _It operator()(_It _Where, const iter_difference_t<_It> _Off) const {
            ::std::ranges:: advance(_Where, _Off);
            return _Where;
        }

        template <input_or_output_iterator _It, sentinel_for<_It> _Se>
        [[nodiscard]] constexpr _It operator()(_It _Where, _Se _Last) const {
            ::std::ranges:: advance(_Where, static_cast<_Se&&>(_Last));
            return _Where;
        }

        template <input_or_output_iterator _It, sentinel_for<_It> _Se>
        [[nodiscard]] constexpr _It operator()(_It _Where, const iter_difference_t<_It> _Off, _Se _Last) const {
            ::std::ranges:: advance(_Where, _Off, static_cast<_Se&&>(_Last));
            return _Where;
        }
    };

     inline constexpr _Next_fn next{_Not_quite_object::_Construct_tag{}};

    class _Prev_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <bidirectional_iterator _It>
        [[nodiscard]] constexpr _It operator()(_It _Where) const {
            --_Where;
            return _Where;
        }

        template <bidirectional_iterator _It>
        [[nodiscard]] constexpr _It operator()(_It _Where, const iter_difference_t<_It> _Off) const {
             ;
            ::std::ranges:: advance(_Where, -_Off);
            return _Where;
        }

        template <bidirectional_iterator _It>
        [[nodiscard]] constexpr _It operator()(_It _Where, const iter_difference_t<_It> _Off, _It _Last) const {
             ;
            ::std::ranges:: advance(_Where, -_Off, static_cast<_It&&>(_Last));
            return _Where;
        }
    };

     inline constexpr _Prev_fn prev{_Not_quite_object::_Construct_tag{}};

    template <forward_iterator _It, sentinel_for<_It> _Se>
    [[nodiscard]] constexpr _It _Find_last_iterator(
        const _It& _First, const _Se& _Last, const iter_difference_t<_It> _Count) {
        
         ;
        if constexpr (is_same_v<_It, _Se>) {
            return _Last;
        } else {
            return ::std::ranges:: next(_First, _Count);
        }
    }

     struct equal_to {
        
        template <class _Ty1, class _Ty2>
            requires equality_comparable_with<_Ty1, _Ty2>
        [[nodiscard]] constexpr bool operator()(_Ty1&& _Left, _Ty2&& _Right) const noexcept(noexcept(
            static_cast<bool>(static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right))))   {
            return static_cast<bool>(static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right));
        }
        

        using is_transparent = int;
    };

     struct less {
        
        template <class _Ty1, class _Ty2>
            requires totally_ordered_with<_Ty1, _Ty2>
        [[nodiscard]] constexpr bool operator()(_Ty1&& _Left, _Ty2&& _Right) const noexcept(noexcept(
            static_cast<bool>(static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right))))   {
            return static_cast<bool>(static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right));
        }
        

        using is_transparent = int;
    };

     struct greater {
        
        template <class _Ty1, class _Ty2>
            requires totally_ordered_with<_Ty1, _Ty2>
        [[nodiscard]] constexpr bool operator()(_Ty1&& _Left, _Ty2&& _Right) const noexcept(noexcept(
            static_cast<bool>(static_cast<_Ty2&&>(_Right) < static_cast<_Ty1&&>(_Left))))   {
            return static_cast<bool>(static_cast<_Ty2&&>(_Right) < static_cast<_Ty1&&>(_Left));
        }
        

        using is_transparent = int;
    };

     template <class _Rng>
    concept common_range = range<_Rng> && same_as<iterator_t<_Rng>, sentinel_t<_Rng>>;

    template <class _It, class _Se>
    concept _Bidi_common = is_same_v<_It, _Se> && bidirectional_iterator<_It>;
    template <class _Rng>
    concept _Bidi_common_range = common_range<_Rng> && bidirectional_iterator<iterator_t<_Rng>>;

    template <class _Ty>
    concept _Can_empty = requires(_Ty __t) { ::std::ranges:: empty(__t); };

     template <class _Derived>
        requires is_class_v<_Derived> && same_as<_Derived, remove_cv_t<_Derived>>
    class view_interface {
    private:
        [[nodiscard]] constexpr _Derived& _Cast() noexcept {
            static_assert(derived_from<_Derived, view_interface>,
                "view_interface's template argument D must derive from view_interface<D> (N4849 [view.interface]/2).");
            static_assert(view<_Derived>,
                "view_interface's template argument must model the view concept (N4849 [view.interface]/2).");
            return static_cast<_Derived&>(*this);
        }

        [[nodiscard]] constexpr const _Derived& _Cast() const noexcept {
            static_assert(derived_from<_Derived, view_interface>,
                "view_interface's template argument D must derive from view_interface<D> (N4849 [view.interface]/2).");
            static_assert(view<_Derived>,
                "view_interface's template argument must model the view concept (N4849 [view.interface]/2).");
            return static_cast<const _Derived&>(*this);
        }

    public:





        [[nodiscard]] constexpr bool empty()
            requires sized_range<_Derived> || forward_range<_Derived>
#line 3345 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        {
            auto& _Self = _Cast();
            if constexpr (sized_range<_Derived>) {
                return ::std::ranges:: size(_Self) == 0;
            } else {
                return ::std::ranges:: begin(_Self) == ::std::ranges:: end(_Self);
            }
        }






        [[nodiscard]] constexpr bool empty() const
            requires sized_range<const _Derived> || forward_range<const _Derived>
#line 3362 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        {
            auto& _Self = _Cast();
            if constexpr (sized_range<const _Derived>) {
                return ::std::ranges:: size(_Self) == 0;
            } else {
                return ::std::ranges:: begin(_Self) == ::std::ranges:: end(_Self);
            }
        }

















































#line 3420 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"






        constexpr explicit operator bool()
            requires _Can_empty<_Derived>
#line 3429 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        {
            return !::std::ranges:: empty(_Cast());
        }






        constexpr explicit operator bool() const
            requires _Can_empty<const _Derived>
#line 3441 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        {
            return !::std::ranges:: empty(_Cast());
        }






        [[nodiscard]] constexpr auto data()
            requires contiguous_iterator<iterator_t<_Derived>>
#line 3453 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        {
            return ::std:: to_address(::std::ranges:: begin(_Cast()));
        }






        [[nodiscard]] constexpr auto data() const
            requires range<const _Derived> && contiguous_iterator<iterator_t<const _Derived>>
#line 3465 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        {
            return ::std:: to_address(::std::ranges:: begin(_Cast()));
        }






        [[nodiscard]] constexpr auto size()
            requires forward_range<_Derived> && sized_sentinel_for<sentinel_t<_Derived>, iterator_t<_Derived>>
#line 3477 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        {
            auto& _Self = _Cast();
            return ::std:: _To_unsigned_like(::std::ranges:: end(_Self) - ::std::ranges:: begin(_Self));
        }






        [[nodiscard]] constexpr auto size() const
            requires forward_range<const _Derived>
                  && sized_sentinel_for<sentinel_t<const _Derived>, iterator_t<const _Derived>>
#line 3491 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        {
            auto& _Self = _Cast();
            return ::std:: _To_unsigned_like(::std::ranges:: end(_Self) - ::std::ranges:: begin(_Self));
        }






        [[nodiscard]] constexpr decltype(auto) front()
            requires forward_range<_Derived>
#line 3504 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        {
            auto& _Self = _Cast();


#line 3509 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
            return *::std::ranges:: begin(_Self);
        }






        [[nodiscard]] constexpr decltype(auto) front() const
            requires forward_range<const _Derived>
#line 3520 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        {
            auto& _Self = _Cast();


#line 3525 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
            return *::std::ranges:: begin(_Self);
        }






        [[nodiscard]] constexpr decltype(auto) back()
            requires bidirectional_range<_Derived> && common_range<_Derived>
#line 3536 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        {
            auto& _Self = _Cast();


#line 3541 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
            auto _Last = ::std::ranges:: end(_Self);
            return *--_Last;
        }






        [[nodiscard]] constexpr decltype(auto) back() const
            requires bidirectional_range<const _Derived> && common_range<const _Derived>
#line 3553 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        {
            auto& _Self = _Cast();


#line 3558 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
            auto _Last = ::std::ranges:: end(_Self);
            return *--_Last;
        }

        template <random_access_range _Rng = _Derived>
        [[nodiscard]] constexpr decltype(auto) operator[](const range_difference_t<_Rng> _Idx) {
            auto& _Self = _Cast();






#line 3572 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
            return ::std::ranges:: begin(_Self)[_Idx];
        }

        template <random_access_range _Rng = const _Derived>
        [[nodiscard]] constexpr decltype(auto) operator[](const range_difference_t<_Rng> _Idx) const {
            auto& _Self = _Cast();






#line 3585 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
            return ::std::ranges:: begin(_Self)[_Idx];
        }
    };
} 



 template <size_t _Index, class... _Types>
[[nodiscard]] constexpr tuple_element_t<_Index, tuple<_Types...>>& get(tuple<_Types...>& _Tuple) noexcept;
 template <size_t _Index, class... _Types>
[[nodiscard]] constexpr const tuple_element_t<_Index, tuple<_Types...>>& get(const tuple<_Types...>& _Tuple) noexcept;
 template <size_t _Index, class... _Types>
[[nodiscard]] constexpr tuple_element_t<_Index, tuple<_Types...>>&& get(tuple<_Types...>&& _Tuple) noexcept;
 template <size_t _Index, class... _Types>
[[nodiscard]] constexpr const tuple_element_t<_Index, tuple<_Types...>>&& get(const tuple<_Types...>&& _Tuple) noexcept;

namespace ranges {
    
    template <class _From, class _To>
    concept _Uses_nonqualification_pointer_conversion =
        is_pointer_v<_From> && is_pointer_v<_To>
        && !convertible_to<remove_pointer_t<_From>(*)[], remove_pointer_t<_To>(*)[]>;

    template <class _From, class _To>
    concept _Convertible_to_non_slicing = convertible_to<_From, _To>
        && !_Uses_nonqualification_pointer_conversion<decay_t<_From>, decay_t<_To>>;

    template <class _Ty>
    concept _Pair_like = !is_reference_v<_Ty> && requires(_Ty __t) {
        typename tuple_size<_Ty>::type;
        requires derived_from<tuple_size<_Ty>, integral_constant<size_t, 2>>;
        typename tuple_element_t<0, remove_const_t<_Ty>>;
        typename tuple_element_t<1, remove_const_t<_Ty>>;
        { ::std:: get<0>(__t) } -> convertible_to<const tuple_element_t<0, _Ty>&>;
        { ::std:: get<1>(__t) } -> convertible_to<const tuple_element_t<1, _Ty>&>;
    };

    template <class _Ty, class _First, class _Second>
    concept _Pair_like_convertible_from = !range<_Ty> && _Pair_like<_Ty>
        && constructible_from<_Ty, _First, _Second>
        && _Convertible_to_non_slicing<_First, tuple_element_t<0, _Ty>>
        && convertible_to<_Second, tuple_element_t<1, _Ty>>;
    

    template <class _It, class _Se, subrange_kind _Ki,
        bool _Store = _Ki == subrange_kind::sized && !sized_sentinel_for<_Se, _It>>
    class _Subrange_base : public view_interface<subrange<_It, _Se, _Ki>> { 
    protected:
        using _Size_type                  = _Make_unsigned_like_t<iter_difference_t<_It>>;
        static constexpr bool _Store_size = true;

        _Size_type _Size = 0;

    public:
        _Subrange_base() = default;
        constexpr explicit _Subrange_base(const _Size_type& _Size_) noexcept : _Size(_Size_) {}
    };

    template <class _It, class _Se, subrange_kind _Ki>
    class _Subrange_base<_It, _Se, _Ki, false> : public view_interface<subrange<_It, _Se, _Ki>> {
    protected:
        using _Size_type                  = _Make_unsigned_like_t<iter_difference_t<_It>>;
        static constexpr bool _Store_size = false;

    public:
        _Subrange_base() = default;
        constexpr explicit _Subrange_base(const _Size_type&) noexcept {}
    };


#pragma warning(push)
#pragma warning(disable : 4324) 
#line 3658 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
     template <input_or_output_iterator _It, sentinel_for<_It> _Se, subrange_kind _Ki>
        requires (_Ki == subrange_kind::sized || !sized_sentinel_for<_Se, _It>)
    class subrange : public _Subrange_base<_It, _Se, _Ki> {
    private:
        using _Mybase = _Subrange_base<_It, _Se, _Ki>;
        using _Mybase::_Store_size;
        using typename _Mybase::_Size_type;

        
          _It _First{};
          _Se _Last{};
        

        template <class _Rng>
        constexpr subrange(true_type, _Rng&& _Val)
            : subrange(::std:: forward<_Rng>(_Val), static_cast<_Size_type>(::std::ranges:: size(_Val))) {
            
             ;
        }

        template <class _Rng>
        constexpr subrange(false_type, _Rng&& _Val) : subrange(::std::ranges:: begin(_Val), ::std::ranges:: end(_Val)) {
            
             ;
        }

    public:
        
        subrange() requires default_initializable<_It> = default;

        template <_Convertible_to_non_slicing<_It> _It2>
        constexpr subrange(_It2 _First_, _Se _Last_) requires (!_Store_size)
            : _First(::std:: move(_First_)), _Last(::std:: move(_Last_)) {}

        template <_Convertible_to_non_slicing<_It> _It2>
        constexpr subrange(_It2 _First_, _Se _Last_, const _Size_type _Size_) requires (_Ki == subrange_kind::sized)
            : _Mybase(_Size_), _First(::std:: move(_First_)), _Last(::std:: move(_Last_)) {
            if constexpr (sized_sentinel_for<_Se, _It>) {
                

;
            }
        }

        template <_Different_from<subrange> _Rng>
            requires borrowed_range<_Rng>
                && _Convertible_to_non_slicing<iterator_t<_Rng>, _It>
                && convertible_to<sentinel_t<_Rng>, _Se>
        constexpr subrange(_Rng&& _Val) requires (!_Store_size || sized_range<_Rng>)
            : subrange{bool_constant<_Store_size>{}, ::std:: forward<_Rng>(_Val)} {}

        template <borrowed_range _Rng>
            requires _Convertible_to_non_slicing<iterator_t<_Rng>, _It> && convertible_to<sentinel_t<_Rng>, _Se>
        constexpr subrange(_Rng&& _Val, const _Size_type _Count) requires (_Ki == subrange_kind::sized)
            : subrange{::std::ranges:: begin(_Val), ::std::ranges:: end(_Val), _Count} {}
        

        template <_Different_from<subrange> _Pair_like>
            requires _Pair_like_convertible_from<_Pair_like, const _It&, const _Se&>
        constexpr operator _Pair_like() const {
            return _Pair_like(_First, _Last);
        }

        [[nodiscard]] constexpr _It begin() const
            requires copyable<_It>
        {
            return _First;
        }
        
        [[nodiscard]] constexpr _It begin() requires (!copyable<_It>) {
            
            return ::std:: move(_First);
        }

        [[nodiscard]] constexpr _Se end() const {
            return _Last;
        }

        [[nodiscard]] constexpr bool empty() const {
            return _First == _Last;
        }

        
        [[nodiscard]] constexpr _Size_type size() const requires (_Ki == subrange_kind::sized) {
            
            if constexpr (_Store_size) {
                return this->_Size;
            } else {
                return static_cast<_Size_type>(_Last - _First);
            }
        }

        [[nodiscard]] constexpr subrange next() const&
            requires forward_iterator<_It>
        {
            auto _Tmp = *this;
            if (_Tmp._First != _Tmp._Last) {
                ++_Tmp._First;
                if constexpr (_Store_size) {
                    --_Tmp._Size;
                }
            }
            return _Tmp;
        }
        [[nodiscard]] constexpr subrange next(const iter_difference_t<_It> _Count) const&
            requires forward_iterator<_It>
        {
            auto _Tmp = *this;
            _Tmp.advance(_Count);
            return _Tmp;
        }

        [[nodiscard]] constexpr subrange next() && {
            if (_First != _Last) {
                ++_First;
                if constexpr (_Store_size) {
                    --this->_Size;
                }
            }
            return ::std:: move(*this);
        }
        [[nodiscard]] constexpr subrange next(const iter_difference_t<_It> _Count) && {
            advance(_Count);
            return ::std:: move(*this);
        }

        [[nodiscard]] constexpr subrange prev() const
            requires bidirectional_iterator<_It>
        {
            auto _Tmp = *this;
            --_Tmp._First;
            if constexpr (_Store_size) {
                ++_Tmp._Size;
            }
            return _Tmp;
        }
        [[nodiscard]] constexpr subrange prev(const iter_difference_t<_It> _Count) const
            requires bidirectional_iterator<_It>
        {
            auto _Tmp = *this;
            _Tmp.advance(-_Count);
            return _Tmp;
        }

        constexpr subrange& advance(const iter_difference_t<_It> _Count) {
            if constexpr (bidirectional_iterator<_It>) {
                if (_Count < 0) {
                    ::std::ranges:: advance(_First, _Count);
                    if constexpr (_Store_size) {
                        this->_Size += static_cast<_Size_type>(-_Count);
                    }
                    return *this;
                }
            }

            const auto _Remainder = ::std::ranges:: advance(_First, _Count, _Last);
            if constexpr (_Store_size) {
                this->_Size -= static_cast<_Size_type>(_Count - _Remainder);
            }
            return *this;
        }
    };

#pragma warning(pop)
#line 3823 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

    template <input_or_output_iterator _It, sentinel_for<_It> _Se>
    subrange(_It, _Se) -> subrange<_It, _Se>;

    template <input_or_output_iterator _It, sentinel_for<_It> _Se>
    subrange(_It, _Se, _Make_unsigned_like_t<iter_difference_t<_It>>) -> subrange<_It, _Se, subrange_kind::sized>;

    template <borrowed_range _Rng>
    subrange(_Rng&&) -> subrange<iterator_t<_Rng>, sentinel_t<_Rng>,
        (sized_range<_Rng> || sized_sentinel_for<sentinel_t<_Rng>, iterator_t<_Rng>>) ? subrange_kind::sized
                                                                                      : subrange_kind::unsized>;

    template <borrowed_range _Rng>
    subrange(_Rng&&, _Make_unsigned_like_t<range_difference_t<_Rng>>)
        -> subrange<iterator_t<_Rng>, sentinel_t<_Rng>, subrange_kind::sized>;

    template <class _It, class _Se, subrange_kind _Ki>
    inline constexpr bool enable_borrowed_range<subrange<_It, _Se, _Ki>> = true;

     template <size_t _Idx, class _It, class _Se, subrange_kind _Ki>
        requires ((_Idx == 0 && copyable<_It>) || _Idx == 1)
    [[nodiscard]] constexpr auto get(const subrange<_It, _Se, _Ki>& _Val) {
        if constexpr (_Idx == 0) {
            return _Val.begin();
        } else {
            return _Val.end();
        }
    }

     template <size_t _Idx, class _It, class _Se, subrange_kind _Ki>
        requires (_Idx < 2)
    [[nodiscard]] constexpr auto get(subrange<_It, _Se, _Ki>&& _Val) {
        if constexpr (_Idx == 0) {
            return _Val.begin();
        } else {
            return _Val.end();
        }
    }

     struct dangling {
        constexpr dangling() noexcept = default;
        template <class... _Args>
        constexpr dangling(_Args&&...) noexcept {}
    };

     template <range _Rng>
    using borrowed_iterator_t = conditional_t<borrowed_range<_Rng>, iterator_t<_Rng>, dangling>;

     template <range _Rng>
    using borrowed_subrange_t = conditional_t<borrowed_range<_Rng>, subrange<iterator_t<_Rng>>, dangling>;
} 
#line 3875 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

struct _Container_proxy;
struct _Iterator_base12;

struct _Default_sentinel {}; 


 template <semiregular>
class move_sentinel;

template <class>
struct _Move_iterator_category {};


template <class _Iter>
    requires requires { typename _Iter_cat_t<_Iter>; }
struct _Move_iterator_category<_Iter> {
    using iterator_category = conditional_t<derived_from<_Iter_cat_t<_Iter>, random_access_iterator_tag>,
        random_access_iterator_tag, _Iter_cat_t<_Iter>>;
};






#line 3902 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

 template <class _Iter>
class move_iterator : public _Move_iterator_category<_Iter> {
public:
    using iterator_type   = _Iter;
    using value_type      = _Iter_value_t<_Iter>;
    using difference_type = _Iter_diff_t<_Iter>;
    using pointer         = _Iter;


private:
    static constexpr auto _Get_iter_concept() {
        if constexpr (random_access_iterator<_Iter>) {
            return random_access_iterator_tag{};
        } else if constexpr (bidirectional_iterator<_Iter>) {
            return bidirectional_iterator_tag{};
        } else if constexpr (forward_iterator<_Iter>) {
            return forward_iterator_tag{};
        } else {
            return input_iterator_tag{};
        }
    }

public:
    using iterator_concept = decltype(_Get_iter_concept());

    using reference = iter_rvalue_reference_t<_Iter>;



#line 3933 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

    constexpr move_iterator() = default;

    constexpr explicit move_iterator(_Iter _Right) noexcept(is_nothrow_move_constructible_v<_Iter>) 
        : _Current(::std:: move(_Right)) {}

    
    template <class _Other>

        requires (!is_same_v<_Other, _Iter>) && convertible_to<const _Other&, _Iter>
#line 3944 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
    constexpr move_iterator(const move_iterator<_Other>& _Right) noexcept(
        is_nothrow_constructible_v<_Iter, const _Other&>) 
        : _Current(_Right.base()) {}

    template <class _Other>

        requires (!is_same_v<_Other, _Iter>) && convertible_to<const _Other&, _Iter>
            && assignable_from<_Iter&, const _Other&>
#line 3953 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
    constexpr move_iterator& operator=(const move_iterator<_Other>& _Right) noexcept(
        is_nothrow_assignable_v<_Iter&, const _Other&>)   {
        _Current = _Right.base();
        return *this;
    }
    


    [[nodiscard]] constexpr const iterator_type& base() const& noexcept {
        return _Current;
    }
    [[nodiscard]] constexpr iterator_type base() && noexcept(is_nothrow_move_constructible_v<_Iter>)   {
        return ::std:: move(_Current);
    }





#line 3973 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

    [[nodiscard]] constexpr reference operator*() const

        noexcept(noexcept(::std::ranges:: iter_move(_Current)))   {
        return ::std::ranges:: iter_move(_Current);
    }




#line 3984 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

    [[deprecated("warning STL4031: " "std::move_iterator::operator->() is deprecated in C++20. " "You can define _SILENCE_CXX20_MOVE_ITERATOR_ARROW_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] [[nodiscard]] constexpr pointer operator->() const
        noexcept(is_nothrow_copy_constructible_v<_Iter>)   {
        return _Current;
    }

    constexpr move_iterator& operator++() noexcept(noexcept(++_Current))   {
        ++_Current;
        return *this;
    }

    constexpr auto operator++(int) noexcept(
        is_nothrow_copy_constructible_v<_Iter>&& noexcept(++_Current))   {

        if constexpr (forward_iterator<_Iter>) {
#line 4000 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
            move_iterator _Tmp = *this;
            ++_Current;
            return _Tmp;

        } else {
            ++_Current;
        }
#line 4008 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
    }

    constexpr move_iterator& operator--() noexcept(noexcept(--_Current))   {
        --_Current;
        return *this;
    }

    constexpr move_iterator operator--(int) noexcept(
        is_nothrow_copy_constructible_v<_Iter>&& noexcept(--_Current))   {
        move_iterator _Tmp = *this;
        --_Current;
        return _Tmp;
    }

    template <class _Iter2 = _Iter>
    [[nodiscard]] auto operator==(_Default_sentinel _Sentinel) const noexcept
        -> decltype(::std:: declval<const _Iter2&>() == _Sentinel) {
        return _Current == _Sentinel;
    }

    template <class _Iter2 = _Iter>
    [[nodiscard]] auto operator!=(_Default_sentinel _Sentinel) const noexcept
        -> decltype(::std:: declval<const _Iter2&>() != _Sentinel) {
        return _Current != _Sentinel;
    }

    [[nodiscard]] constexpr move_iterator operator+(const difference_type _Off) const
        noexcept(noexcept(move_iterator(_Current + _Off)))   {
        return move_iterator(_Current + _Off);
    }

    constexpr move_iterator& operator+=(const difference_type _Off) noexcept(
        noexcept(_Current += _Off))   {
        _Current += _Off;
        return *this;
    }

    [[nodiscard]] constexpr move_iterator operator-(const difference_type _Off) const
        noexcept(noexcept(move_iterator(_Current - _Off)))   {
        return move_iterator(_Current - _Off);
    }

    constexpr move_iterator& operator-=(const difference_type _Off) noexcept(
        noexcept(_Current -= _Off))   {
        _Current -= _Off;
        return *this;
    }

    [[nodiscard]] constexpr reference operator[](const difference_type _Off) const

        noexcept(noexcept(::std::ranges:: iter_move(_Current + _Off)))   {
        return ::std::ranges:: iter_move(_Current + _Off);



#line 4064 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
    }


    template <sentinel_for<_Iter> _Sent>
    [[nodiscard]] friend constexpr bool
        operator==(const move_iterator& _Left, const move_sentinel<_Sent>& _Right) noexcept(
            noexcept(_Fake_copy_init<bool>(_Left._Current == _Right._Get_last())))   {
        return _Left._Current == _Right._Get_last();
    }

    template <sized_sentinel_for<_Iter> _Sent>
    [[nodiscard]] friend constexpr difference_type operator-(const move_sentinel<_Sent>& _Left,
        const move_iterator& _Right) noexcept(noexcept(_Left._Get_last() - _Right._Current))   {
        return _Left._Get_last() - _Right._Current;
    }

    template <sized_sentinel_for<_Iter> _Sent>
    [[nodiscard]] friend constexpr difference_type operator-(const move_iterator& _Left,
        const move_sentinel<_Sent>& _Right) noexcept(noexcept(_Left._Current - _Right._Get_last()))   {
        return _Left._Current - _Right._Get_last();
    }

    [[nodiscard]] friend constexpr reference iter_move(const move_iterator& _It)



        noexcept(noexcept(::std::ranges:: iter_move(_It._Current)))
#line 4092 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
    {
        return ::std::ranges:: iter_move(_It._Current);
    }

    template <indirectly_swappable<_Iter> _Iter2>
    friend constexpr void iter_swap(const move_iterator& _Left, const move_iterator<_Iter2>& _Right)



        noexcept(noexcept(::std::ranges:: iter_swap(_Left._Current, _Right.base())))
#line 4103 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
    {
        ::std::ranges:: iter_swap(_Left._Current, _Right.base());
    }
#line 4107 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

    template <class _Iter2, enable_if_t<_Range_verifiable_v<_Iter, _Iter2>, int> = 0>
    friend constexpr void _Verify_range(const move_iterator& _First, const move_iterator<_Iter2>& _Last) noexcept {
        _Verify_range(_First._Current, _Last._Get_current());
    }

    template <sentinel_for<_Iter> _Sent, enable_if_t<_Range_verifiable_v<_Iter, _Sent>, int> = 0>
    friend constexpr void _Verify_range(const move_iterator& _First, const move_sentinel<_Sent>& _Last) noexcept {
        _Verify_range(_First._Current, _Last._Get_last());
    }
#line 4118 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

    using _Prevent_inheriting_unwrap = move_iterator;

    template <class _Iter2 = iterator_type, enable_if_t<_Offset_verifiable_v<_Iter2>, int> = 0>
    constexpr void _Verify_offset(const difference_type _Off) const noexcept {
        _Current._Verify_offset(_Off);
    }

    template <class _Iter2 = iterator_type, enable_if_t<_Unwrappable_v<const _Iter2&>, int> = 0>
    [[nodiscard]] constexpr move_iterator<_Unwrapped_t<const _Iter2&>> _Unwrapped() const& noexcept(
        noexcept(static_cast<move_iterator<_Unwrapped_t<const _Iter2&>>>(_Current._Unwrapped()))) {
        return static_cast<move_iterator<_Unwrapped_t<const _Iter2&>>>(_Current._Unwrapped());
    }
    template <class _Iter2 = iterator_type, enable_if_t<_Unwrappable_v<_Iter2>, int> = 0>
    [[nodiscard]] constexpr move_iterator<_Unwrapped_t<_Iter2>> _Unwrapped() && noexcept(
        noexcept(static_cast<move_iterator<_Unwrapped_t<_Iter2>>>(::std:: move(_Current)._Unwrapped()))) {
        return static_cast<move_iterator<_Unwrapped_t<_Iter2>>>(::std:: move(_Current)._Unwrapped());
    }

    static constexpr bool _Unwrap_when_unverified = _Do_unwrap_when_unverified_v<iterator_type>;

    template <class _Src, enable_if_t<_Wrapped_seekable_v<iterator_type, const _Src&>, int> = 0>
    constexpr void _Seek_to(const move_iterator<_Src>& _It) noexcept(noexcept(_Current._Seek_to(_It._Get_current()))) {
        _Current._Seek_to(_It._Get_current());
    }
    template <class _Src, enable_if_t<_Wrapped_seekable_v<iterator_type, _Src>, int> = 0>
    constexpr void _Seek_to(move_iterator<_Src>&& _It) noexcept(
        noexcept(_Current._Seek_to(::std:: move(_It)._Get_current()))) {
        _Current._Seek_to(::std:: move(_It)._Get_current());
    }

    [[nodiscard]] constexpr const iterator_type& _Get_current() const& noexcept {
        return _Current;
    }
    [[nodiscard]] constexpr iterator_type&& _Get_current() && noexcept {
        return ::std:: move(_Current);
    }

private:
    iterator_type _Current{};
};

 template <class _Iter1, class _Iter2>
[[nodiscard]] constexpr bool
    operator==(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right) noexcept(
        noexcept(_Fake_copy_init<bool>(_Left.base() == _Right.base())))  

    
    requires requires {
        { _Left.base() == _Right.base() } -> _Implicitly_convertible_to<bool>;
    }

#line 4171 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
{
    return _Left.base() == _Right.base();
}







#line 4182 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

 template <class _Iter1, class _Iter2>
[[nodiscard]] constexpr bool
    operator<(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right) noexcept(
        noexcept(_Fake_copy_init<bool>(_Left.base() < _Right.base())))  

    
    requires requires {
        { _Left.base() < _Right.base() } -> _Implicitly_convertible_to<bool>;
    }

#line 4194 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
{
    return _Left.base() < _Right.base();
}

 template <class _Iter1, class _Iter2>
[[nodiscard]] constexpr bool operator>(const move_iterator<_Iter1>& _Left,
    const move_iterator<_Iter2>& _Right) noexcept(noexcept(_Right < _Left))  

    requires requires { _Right < _Left; }
#line 4204 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
{
    return _Right < _Left;
}

 template <class _Iter1, class _Iter2>
[[nodiscard]] constexpr bool operator<=(const move_iterator<_Iter1>& _Left,
    const move_iterator<_Iter2>& _Right) noexcept(noexcept(_Right < _Left))  

    requires requires { _Right < _Left; }
#line 4214 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
{
    return !(_Right < _Left);
}

 template <class _Iter1, class _Iter2>
[[nodiscard]] constexpr bool operator>=(const move_iterator<_Iter1>& _Left,
    const move_iterator<_Iter2>& _Right) noexcept(noexcept(_Left < _Right))  

    requires requires { _Left < _Right; }
#line 4224 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
{
    return !(_Left < _Right);
}


 template <class _Iter1, three_way_comparable_with<_Iter1> _Iter2>
[[nodiscard]] constexpr compare_three_way_result_t<_Iter1, _Iter2> operator<=>(const move_iterator<_Iter1>& _Left,
    const move_iterator<_Iter2>& _Right) noexcept(noexcept(_Left.base() <=> _Right.base()))   {
    return _Left.base() <=> _Right.base();
}
#line 4235 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

 template <class _Iter1, class _Iter2>
[[nodiscard]] constexpr auto operator-(const move_iterator<_Iter1>& _Left,
    const move_iterator<_Iter2>& _Right) noexcept(noexcept(_Left.base() - _Right.base()))  
    -> decltype(_Left.base() - _Right.base()) {
    return _Left.base() - _Right.base();
}

 template <class _Iter>
[[nodiscard]] constexpr move_iterator<_Iter>
    operator+(typename move_iterator<_Iter>::difference_type _Off, const move_iterator<_Iter>& _Right) noexcept(
        noexcept(move_iterator<_Iter>(_Right.base() + _Off)))  

    
    requires requires {
        { _Right.base() + _Off } -> same_as<_Iter>;
    }

#line 4254 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
{
    return move_iterator<_Iter>(_Right.base() + _Off);
}

 template <class _Iter>
[[nodiscard]] constexpr move_iterator<_Iter> make_move_iterator(_Iter _It) noexcept(
    is_nothrow_move_constructible_v<_Iter>)   {
    return move_iterator<_Iter>(::std:: move(_It));
}


template <class _Iter1, class _Iter2>
    requires (!sized_sentinel_for<_Iter1, _Iter2>)
inline constexpr bool disable_sized_sentinel_for<move_iterator<_Iter1>, move_iterator<_Iter2>> = true;

 struct default_sentinel_t {};

 inline constexpr default_sentinel_t default_sentinel{};

 struct unreachable_sentinel_t;
namespace _Unreachable_sentinel_detail {
    struct _Base {
        template <weakly_incrementable _Winc>
        [[nodiscard]] friend constexpr bool operator==(const unreachable_sentinel_t&, const _Winc&) noexcept {
            return false;
        }
    };
} 
 struct unreachable_sentinel_t : _Unreachable_sentinel_detail::_Base {}; 

 inline constexpr unreachable_sentinel_t unreachable_sentinel{};
#line 4286 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"






template <class _Iter>
inline constexpr bool _Iterator_is_contiguous = contiguous_iterator<_Iter>;

template <class _Iter>
[[nodiscard]] constexpr auto _To_address(const _Iter& _Val) noexcept {
     ;
    return ::std:: to_address(_Val);
}










#line 4311 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

template <class _Iter>
[[nodiscard]] constexpr auto _To_address(const move_iterator<_Iter>& _Val) noexcept {
    return _To_address(_Val.base());
}



template <class _Iter1, class _Iter2>
inline constexpr bool _Iterators_are_contiguous =
    _Iterator_is_contiguous<_Iter1> && _Iterator_is_contiguous<_Iter2>;

template <class _Iter>
inline constexpr bool _Iterator_is_volatile = is_volatile_v<remove_reference_t<_Iter_ref_t<_Iter>>>;

template <class _Source, class _Dest>
inline constexpr bool _Is_pointer_address_convertible = is_void_v<_Source>
                                                          || is_void_v<_Dest>
                                                          
                                                          || is_same_v<remove_cv_t<_Source>, remove_cv_t<_Dest>>

                                                          || is_pointer_interconvertible_base_of_v<_Dest, _Source>
#line 4334 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
    ;

template <class _Source, class _Dest, class _SourceRef, class _DestRef>
struct _Trivial_cat {
    using _USource = _Unwrap_enum_t<_Source>;
    using _UDest   = _Unwrap_enum_t<_Dest>;

    static constexpr bool _Same_size_and_compatible =
        sizeof(_Source) == sizeof(_Dest)
        
        
        
        && is_same_v<bool, _USource> >= is_same_v<bool, _UDest>
        && (is_same_v<_USource, _UDest> || (is_integral_v<_USource> && is_integral_v<_UDest>)
            || (is_floating_point_v<_USource> && is_floating_point_v<_UDest>) );

    static constexpr bool _Bitcopy_constructible =
        _Same_size_and_compatible && is_trivially_constructible_v<_Dest, _SourceRef>;

    static constexpr bool _Bitcopy_assignable =
        _Same_size_and_compatible && is_trivially_assignable_v<_DestRef, _SourceRef>;
};

template <class _Source, class _Dest, class _SourceRef, class _DestRef>
struct _Trivial_cat<_Source*, _Dest*, _SourceRef, _DestRef> {
    static constexpr bool _Bitcopy_constructible =
        _Is_pointer_address_convertible<_Source, _Dest> && is_trivially_constructible_v<_Dest*, _SourceRef>;

    static constexpr bool _Bitcopy_assignable =
        _Is_pointer_address_convertible<_Source, _Dest> && is_trivially_assignable_v<_DestRef, _SourceRef>;
};

struct _False_trivial_cat {
    static constexpr bool _Bitcopy_constructible = false;
    static constexpr bool _Bitcopy_assignable    = false;
};

template <class _SourceIt, class _DestIt,
    bool _Are_contiguous = _Iterators_are_contiguous<_SourceIt, _DestIt> 
                        && !_Iterator_is_volatile<_SourceIt> && !_Iterator_is_volatile<_DestIt>>
struct _Iter_move_cat : _Trivial_cat<_Iter_value_t<_SourceIt>, _Iter_value_t<_DestIt>,
                            remove_reference_t<_Iter_ref_t<_SourceIt>>&&, _Iter_ref_t<_DestIt>> {};

template <class _SourceIt, class _DestIt>
struct _Iter_move_cat<_SourceIt, _DestIt, false> : _False_trivial_cat {};

template <class _SourceIt, class _DestIt>
struct _Iter_move_cat<move_iterator<_SourceIt>, _DestIt, false> : _Iter_move_cat<_SourceIt, _DestIt> {};

template <class _SourceIt, class _DestIt,
    bool _Are_contiguous = _Iterators_are_contiguous<_SourceIt, _DestIt> 
                        && !_Iterator_is_volatile<_SourceIt> && !_Iterator_is_volatile<_DestIt>>
struct _Iter_copy_cat
    : _Trivial_cat<_Iter_value_t<_SourceIt>, _Iter_value_t<_DestIt>, _Iter_ref_t<_SourceIt>, _Iter_ref_t<_DestIt>> {};

template <class _SourceIt, class _DestIt>
struct _Iter_copy_cat<_SourceIt, _DestIt, false> : _False_trivial_cat {};

template <class _SourceIt, class _DestIt>
struct _Iter_copy_cat<move_iterator<_SourceIt>, _DestIt, false> : _Iter_move_cat<_SourceIt, _DestIt> {};

template <class _Iter1, class _Sent1, class _Iter2>
constexpr void _Verify_ranges_do_not_overlap(const _Iter1& _First1, const _Sent1& _Last1, const _Iter2& _First2) {























#line 4421 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
    (void) _First1;
    (void) _Last1;
    (void) _First2;
#line 4425 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
}

template <class _CtgIt, class _OutCtgIt>
_OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {
    auto _FirstPtr              = _To_address(_First);
    auto _LastPtr               = _To_address(_Last);
    auto _DestPtr               = _To_address(_Dest);
    const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
    const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
    char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
    const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);
    :: memmove(_Dest_ch, _First_ch, _Count);
    if constexpr (is_pointer_v<_OutCtgIt>) {
        return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);
    } else {
        return _Dest + (_LastPtr - _FirstPtr);
    }
}

template <class _CtgIt, class _OutCtgIt>
_OutCtgIt _Copy_memmove_n(_CtgIt _First, const size_t _Count, _OutCtgIt _Dest) {
    const auto _Result = _Copy_memmove(_First, _First + _Count, _Dest);
    if constexpr (is_pointer_v<_OutCtgIt>) {
        return _Result;
    } else { 
        return _Dest + static_cast<_Iter_diff_t<_OutCtgIt>>(_Count);
    }
}

template <class _It, bool _RequiresMutable = false>
inline constexpr bool _Is_vb_iterator = false;

template <class _InIt, class _SizeTy, class _OutIt>
constexpr _OutIt _Copy_n_unchecked4(_InIt _First, _SizeTy _Count, _OutIt _Dest) {
    
    

     ;
#line 4464 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

    if constexpr (_Iter_copy_cat<_InIt, _OutIt>::_Bitcopy_assignable) {

        if (!::std:: is_constant_evaluated())
#line 4469 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        {
            return _Copy_memmove_n(_First, static_cast<size_t>(_Count), _Dest);
        }
    }

    for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {
        *_Dest = *_First;
    }

    return _Dest;
}

template <class _InIt, class _Sent, class _OutIt>
using _Sent_copy_cat = conditional_t<

    is_same_v<_Sent, _InIt> || sized_sentinel_for<_Sent, _InIt>,


#line 4488 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
    _Iter_copy_cat<_InIt, _OutIt>, _False_trivial_cat>;

template <class _InIt, class _Sent, class _OutIt>
constexpr _OutIt _Copy_unchecked(_InIt _First, _Sent _Last, _OutIt _Dest) {
    
    
    if constexpr (_Sent_copy_cat<_InIt, _Sent, _OutIt>::_Bitcopy_assignable) {

        if (!::std:: is_constant_evaluated())
#line 4498 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        {

            if constexpr (is_same_v<_InIt, _Sent>)
#line 4502 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
            {
                return _Copy_memmove(_First, _Last, _Dest);
            }

            else {
                return _Copy_memmove_n(_First, static_cast<size_t>(_Last - _First), _Dest);
            }
#line 4510 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        }
    }

    for (; _First != _Last; ++_Dest, (void) ++_First) {
        *_Dest = *_First;
    }

    return _Dest;
}

 template <class _InIt, class _OutIt>
constexpr _OutIt copy(_InIt _First, _InIt _Last, _OutIt _Dest) { 
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    const auto _UDest  = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
    _Seek_wrapped(_Dest, ::std:: _Copy_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}


 template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
_FwdIt2 copy(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last, _FwdIt2 _Dest) noexcept   {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.") ;
    static_assert(_Is_cpp17_fwd_iter_v<_FwdIt2>, "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.") ;
    return ::std:: copy(_First, _Last, _Dest);
}
#line 4540 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"


namespace ranges {
    template <class _To, class _From>
    concept _Convertible_from = convertible_to<_From, _To>;

     template <class _In, class _Out>
    struct in_out_result {
          _In in;
          _Out out;

        template <_Convertible_from<const _In&> _IIn, _Convertible_from<const _Out&> _OOut>
        constexpr operator in_out_result<_IIn, _OOut>() const& {
            return {in, out};
        }

        template <_Convertible_from<_In> _IIn, _Convertible_from<_Out> _OOut>
        constexpr operator in_out_result<_IIn, _OOut>() && {
            return {::std:: move(in), ::std:: move(out)};
        }
    };

    template <forward_iterator _It, class _Se>
        requires sentinel_for<remove_cvref_t<_Se>, _It>
    [[nodiscard]] constexpr _Unwrap_iter_t<_It, _Se> _Get_final_iterator_unwrapped(
        const _Unwrap_iter_t<_It, _Se>& _UFirst, _Se&& _Last) {
        
        
        if constexpr (is_same_v<_Unwrap_iter_t<_It, _Se>, _Unwrap_sent_t<_Se, _It>>) {
            return _Unwrap_sent<_It>(::std:: forward<_Se>(_Last));
        } else {
            return ::std::ranges:: next(_UFirst, _Unwrap_sent<_It>(::std:: forward<_Se>(_Last)));
        }
    }

    template <forward_range _Rng>
    [[nodiscard]] constexpr auto _Get_final_iterator_unwrapped(_Rng& _Range) {
        
        if constexpr (common_range<_Rng>) {
            if constexpr (same_as<decltype(_Uend(_Range)), _Unwrapped_iterator_t<_Rng>>) {
                return _Uend(_Range);
            } else {
                return _Unwrap_range_sent<_Rng>(::std::ranges:: end(_Range));
            }
        } else if constexpr (sized_range<_Rng>) {
            return ::std::ranges:: next(_Ubegin(_Range), ::std::ranges:: distance(_Range));
        } else {
            return ::std::ranges:: next(_Ubegin(_Range), _Uend(_Range));
        }
    }

    template <forward_range _Rng>
    [[nodiscard]] constexpr auto _Get_final_iterator_unwrapped(_Rng& _Range, const _Unwrapped_iterator_t<_Rng>& _Mid) {
        
        
        if constexpr (common_range<_Rng>) {
            if constexpr (same_as<decltype(_Uend(_Range)), _Unwrapped_iterator_t<_Rng>>) {
                return _Uend(_Range);
            } else {
                return _Unwrap_range_sent<_Rng>(::std::ranges:: end(_Range));
            }
        } else if constexpr (sized_range<_Rng>) {
            const auto _Dist = ::std::ranges:: distance(_Range);
            if constexpr (sized_sentinel_for<_Unwrapped_iterator_t<_Rng>, _Unwrapped_iterator_t<_Rng>>) {
                return ::std::ranges:: next(_Mid, _Dist - (_Mid - _Ubegin(_Range)));
            } else {
                return ::std::ranges:: next(_Ubegin(_Range), _Dist);
            }
        } else {
            return ::std::ranges:: next(_Mid, _Uend(_Range));
        }
    }

















#line 4630 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

     template <class _In, class _Out>
    using copy_result = in_out_result<_In, _Out>;

    template <input_iterator _It, sentinel_for<_It> _Se, weakly_incrementable _Out>
        requires indirectly_copyable<_It, _Out>
    [[nodiscard]] constexpr copy_result<_It, _Out> _Copy_unchecked(_It _First, _Se _Last, _Out _Result) {
        if constexpr (_Sent_copy_cat<_It, _Se, _Out>::_Bitcopy_assignable) {
            if (!::std:: is_constant_evaluated()) {
                if constexpr (is_same_v<_It, _Se>) {
                    _Result = _Copy_memmove(::std:: move(_First), _Last, ::std:: move(_Result));
                    return {::std:: move(_Last), ::std:: move(_Result)};
                } else {
                    const auto _Count = static_cast<size_t>(_Last - _First);
                    _Result           = _Copy_memmove_n(_First, _Count, ::std:: move(_Result));
                    _First += _Count;
                    return {::std:: move(_First), ::std:: move(_Result)};
                }
            }
        }

        for (; _First != _Last; ++_First, (void) ++_Result) {
            *_Result = *_First;
        }

        return {::std:: move(_First), ::std:: move(_Result)};
    }

    class _Copy_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It, sentinel_for<_It> _Se, weakly_incrementable _Out>
            requires indirectly_copyable<_It, _Out>
        constexpr copy_result<_It, _Out> operator()(_It _First, _Se _Last, _Out _Result) const {
            _Adl_verify_range(_First, _Last);
            auto _UResult = ::std::ranges:: _Copy_unchecked(
                _Unwrap_iter<_Se>(::std:: move(_First)), _Unwrap_sent<_It>(::std:: move(_Last)), ::std:: move(_Result));
            _Seek_wrapped(_First, ::std:: move(_UResult.in));
            return {::std:: move(_First), ::std:: move(_UResult.out)};
        }

        template <input_range _Rng, weakly_incrementable _Out>
            requires indirectly_copyable<iterator_t<_Rng>, _Out>
        constexpr copy_result<borrowed_iterator_t<_Rng>, _Out> operator()(_Rng&& _Range, _Out _Result) const {
            auto _First = ::std::ranges:: begin(_Range);
            auto _UResult =
                ::std::ranges:: _Copy_unchecked(_Unwrap_range_iter<_Rng>(::std:: move(_First)), _Uend(_Range), ::std:: move(_Result));
            _Seek_wrapped(_First, ::std:: move(_UResult.in));
            return {::std:: move(_First), ::std:: move(_UResult.out)};
        }
    };

     inline constexpr _Copy_fn copy{_Not_quite_object::_Construct_tag {}};
} 
#line 4686 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

 template <class _InIt, class _Diff, class _OutIt>
constexpr _OutIt copy_n(_InIt _First, _Diff _Count_raw, _OutIt _Dest) {
    
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        auto _UFirst = _Get_unwrapped_n(_First, _Count);
        auto _UDest  = _Get_unwrapped_n(_Dest, _Count);
        if constexpr (_Iter_copy_cat<decltype(_UFirst), decltype(_UDest)>::_Bitcopy_assignable) {

            if (!::std:: is_constant_evaluated())
#line 4698 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
            {
                _UDest = _Copy_memmove_n(_UFirst, static_cast<size_t>(_Count), _UDest);
                _Seek_wrapped(_Dest, _UDest);
                return _Dest;
            }
        }

        for (;;) {
            *_UDest = *_UFirst;
            ++_UDest;
            --_Count;
            if (_Count == 0) { 
                               
                break;
            }

            ++_UFirst;
        }

        _Seek_wrapped(_Dest, _UDest);
    }

    return _Dest;
}


 template <class _ExPo, class _FwdIt1, class _Diff, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
_FwdIt2 copy_n(_ExPo&&, _FwdIt1 _First, _Diff _Count_raw, _FwdIt2 _Dest) noexcept   {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.") ;
    static_assert(_Is_cpp17_fwd_iter_v<_FwdIt2>, "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.") ;
    return ::std:: copy_n(_First, _Count_raw, _Dest);
}
#line 4733 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

template <class _CtgIt1, class _CtgIt2>
_CtgIt2 _Copy_backward_memmove(_CtgIt1 _First, _CtgIt1 _Last, _CtgIt2 _Dest) {
    
    auto _FirstPtr              = _To_address(_First);
    auto _LastPtr               = _To_address(_Last);
    auto _DestPtr               = _To_address(_Dest);
    const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
    const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
    char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
    const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);
    auto _Result                = :: memmove(_Dest_ch - _Count, _First_ch, _Count);
    if constexpr (is_pointer_v<_CtgIt2>) {
        return static_cast<_CtgIt2>(_Result);
    } else {
        return _Dest - (_LastPtr - _FirstPtr);
    }
}

template <class _BidIt1, class _BidIt2>
_BidIt2 _Copy_backward_memmove(move_iterator<_BidIt1> _First, move_iterator<_BidIt1> _Last, _BidIt2 _Dest) {
    return _Copy_backward_memmove(_First.base(), _Last.base(), _Dest);
}

template <class _BidIt1, class _BidIt2>
[[nodiscard]] constexpr _BidIt2 _Copy_backward_unchecked(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {
    
    if constexpr (_Iter_copy_cat<_BidIt1, _BidIt2>::_Bitcopy_assignable) {

        if (!::std:: is_constant_evaluated())
#line 4764 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        {
            return _Copy_backward_memmove(_First, _Last, _Dest);
        }
    }

    while (_First != _Last) {
        *--_Dest = *--_Last;
    }

    return _Dest;
}

 template <class _BidIt1, class _BidIt2>
constexpr _BidIt2 copy_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {
    
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    const auto _UDest  = _Get_unwrapped_n(_Dest, -_Idl_distance<_BidIt1>(_UFirst, _ULast));
    _Seek_wrapped(_Dest, _Copy_backward_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}

template <class _InIt, class _OutIt>
constexpr _OutIt _Move_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest) {
    
    
    if constexpr (_Iter_move_cat<_InIt, _OutIt>::_Bitcopy_assignable) {

        if (!::std:: is_constant_evaluated())
#line 4795 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        {
            return _Copy_memmove(_First, _Last, _Dest);
        }
    }

    for (; _First != _Last; ++_Dest, (void) ++_First) {
        *_Dest = ::std:: move(*_First);
    }

    return _Dest;
}

 template <class _InIt, class _OutIt>
constexpr _OutIt move(_InIt _First, _InIt _Last, _OutIt _Dest) {
    
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    const auto _UDest  = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
    _Seek_wrapped(_Dest, ::std:: _Move_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}


 template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
_FwdIt2 move(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last, _FwdIt2 _Dest) noexcept   {
    
    
    static_assert(_Is_cpp17_fwd_iter_v<_FwdIt1>, "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.") ;
    static_assert(_Is_cpp17_fwd_iter_v<_FwdIt2>, "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.") ;
    return ::std:: move(_First, _Last, _Dest);
}
#line 4828 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

template <class _BidIt1, class _BidIt2>
constexpr _BidIt2 _Move_backward_unchecked(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {
    
    
    if constexpr (_Iter_move_cat<_BidIt1, _BidIt2>::_Bitcopy_assignable) {

        if (!::std:: is_constant_evaluated())
#line 4837 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        {
            return _Copy_backward_memmove(_First, _Last, _Dest);
        }
    }

    while (_First != _Last) {
        *--_Dest = ::std:: move(*--_Last);
    }

    return _Dest;
}

 template <class _BidIt1, class _BidIt2>
constexpr _BidIt2 move_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {
    
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    const auto _UDest  = _Get_unwrapped_n(_Dest, -_Idl_distance<_BidIt1>(_UFirst, _ULast));
    _Seek_wrapped(_Dest, _Move_backward_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}


template <class _Ty>
struct _Is_character : false_type {}; 

template <>
struct _Is_character<char> : true_type {}; 

template <>
struct _Is_character<signed char> : true_type {}; 

template <>
struct _Is_character<unsigned char> : true_type {}; 


template <>
struct _Is_character<char8_t> : true_type {}; 
#line 4877 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

template <class _Ty>
struct _Is_character_or_bool : _Is_character<_Ty>::type {};

template <>
struct _Is_character_or_bool<bool> : true_type {};

template <class _Ty>
struct _Is_character_or_byte_or_bool : _Is_character_or_bool<_Ty>::type {};


template <>
struct _Is_character_or_byte_or_bool<byte> : true_type {};
#line 4891 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"



template <class _FwdIt, class _Ty, bool = _Iterator_is_contiguous<_FwdIt>>
inline constexpr bool _Fill_memset_is_safe = conjunction_v<is_scalar<_Ty>,
    _Is_character_or_byte_or_bool<_Unwrap_enum_t<remove_reference_t<_Iter_ref_t<_FwdIt>>>>,
    negation<is_volatile<remove_reference_t<_Iter_ref_t<_FwdIt>>>>, is_assignable<_Iter_ref_t<_FwdIt>, const _Ty&>>;

template <class _FwdIt, class _Ty>
inline constexpr bool _Fill_memset_is_safe<_FwdIt, _Ty, false> = false;

template <class _FwdIt, class _Ty, bool = _Iterator_is_contiguous<_FwdIt>>
inline constexpr bool _Fill_zero_memset_is_safe =
    conjunction_v<is_scalar<_Ty>, is_scalar<_Iter_value_t<_FwdIt>>, negation<is_member_pointer<_Iter_value_t<_FwdIt>>>,
        negation<is_volatile<remove_reference_t<_Iter_ref_t<_FwdIt>>>>, is_assignable<_Iter_ref_t<_FwdIt>, const _Ty&>>;

template <class _FwdIt, class _Ty>
inline constexpr bool _Fill_zero_memset_is_safe<_FwdIt, _Ty, false> = false;

template <class _CtgIt, class _Ty>
void _Fill_memset(_CtgIt _Dest, const _Ty _Val, const size_t _Count) {
    
    _Iter_value_t<_CtgIt> _Dest_val = _Val;
    :: memset(_To_address(_Dest), static_cast<unsigned char>(_Dest_val), _Count);
}

template <class _CtgIt>
void _Fill_zero_memset(_CtgIt _Dest, const size_t _Count) {
    :: memset(_To_address(_Dest), 0, _Count * sizeof(_Iter_value_t<_CtgIt>));
}

template <class _Ty>
[[nodiscard]] bool _Is_all_bits_zero(const _Ty& _Val) {
    
     ;
    if constexpr (is_same_v<_Ty, nullptr_t>) {
        return true;
    } else {
        constexpr _Ty _Zero{};
        return :: memcmp(&_Val, &_Zero, sizeof(_Ty)) == 0;
    }
}

 template <class _FwdIt, class _Ty>
constexpr void fill(const _FwdIt _First, const _FwdIt _Last, const _Ty& _Val) {
    
    _Adl_verify_range(_First, _Last);
    if constexpr (_Is_vb_iterator<_FwdIt, true>) {
        _Fill_vbool(_First, _Last, _Val);
    } else {
        auto _UFirst      = _Get_unwrapped(_First);
        const auto _ULast = _Get_unwrapped(_Last);

        if (!::std:: is_constant_evaluated())
#line 4946 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        {
            if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
                _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
                return;
            } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
                if (_Is_all_bits_zero(_Val)) {
                    _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
                    return;
                }
            }
        }

        for (; _UFirst != _ULast; ++_UFirst) {
            *_UFirst = _Val;
        }
    }
}


 template <class _ExPo, class _FwdIt, class _Ty, _Enable_if_execution_policy_t<_ExPo> = 0>
void fill(_ExPo&&, _FwdIt _First, _FwdIt _Last, const _Ty& _Val) noexcept   {
    
    
    static_assert(_Is_cpp17_fwd_iter_v<_FwdIt>, "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.") ;
    return ::std:: fill(_First, _Last, _Val);
}
#line 4973 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

 template <class _OutIt, class _Diff, class _Ty>
constexpr _OutIt fill_n(_OutIt _Dest, const _Diff _Count_raw, const _Ty& _Val) {
    
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        if constexpr (_Is_vb_iterator<_OutIt, true>) {
            const auto _Last = _Dest + static_cast<typename _OutIt::difference_type>(_Count);
            _Fill_vbool(_Dest, _Last, _Val);
            return _Last;
        } else {
            auto _UDest = _Get_unwrapped_n(_Dest, _Count);

            if (!::std:: is_constant_evaluated())
#line 4988 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
            {
                if constexpr (_Fill_memset_is_safe<decltype(_UDest), _Ty>) {
                    _Fill_memset(_UDest, _Val, static_cast<size_t>(_Count));
                    _Seek_wrapped(_Dest, _UDest + _Count);
                    return _Dest;
                } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UDest), _Ty>) {
                    if (_Is_all_bits_zero(_Val)) {
                        _Fill_zero_memset(_UDest, static_cast<size_t>(_Count));
                        _Seek_wrapped(_Dest, _UDest + _Count);
                        return _Dest;
                    }
                }
            }

            for (; 0 < _Count; --_Count, (void) ++_UDest) {
                *_UDest = _Val;
            }

            _Seek_wrapped(_Dest, _UDest);
        }
    }
    return _Dest;
}


 template <class _ExPo, class _FwdIt, class _Diff, class _Ty, _Enable_if_execution_policy_t<_ExPo> = 0>
_FwdIt fill_n(_ExPo&&, _FwdIt _Dest, _Diff _Count_raw, const _Ty& _Val) noexcept   {
    
    
    static_assert(_Is_cpp17_fwd_iter_v<_FwdIt>, "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.") ;
    return ::std:: fill_n(_Dest, _Count_raw, _Val);
}
#line 5021 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"


namespace ranges {
    class _Fill_n_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <class _Ty, output_iterator<const _Ty&> _It>
        constexpr _It operator()(_It _First, iter_difference_t<_It> _Count, const _Ty& _Value) const {
            if (_Count > 0) {
                auto _UFirst = _Get_unwrapped_n(::std:: move(_First), _Count);
                if (!::std:: is_constant_evaluated()) {
                    if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
                        _Fill_memset(_UFirst, _Value, static_cast<size_t>(_Count));
                        _Seek_wrapped(_First, _UFirst + _Count); 
                        return _First;
                    } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
                        if (_Is_all_bits_zero(_Value)) {
                            _Fill_zero_memset(_UFirst, static_cast<size_t>(_Count));
                            _Seek_wrapped(_First, _UFirst + _Count); 
                            return _First;
                        }
                    }
                }

                for (; _Count > 0; ++_UFirst, (void) --_Count) {
                    *_UFirst = _Value;
                }

                _Seek_wrapped(_First, ::std:: move(_UFirst));
            }

            return _First;
        }
    };

     inline constexpr _Fill_n_fn fill_n{_Not_quite_object::_Construct_tag {}};
} 
#line 5060 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

template <class _Ty1, class _Ty2, class = void>
inline constexpr bool _Can_compare_with_operator_equal = false;

template <class _Ty1, class _Ty2>
inline constexpr bool
    _Can_compare_with_operator_equal<_Ty1, _Ty2, void_t<decltype(::std:: declval<_Ty1&>() == ::std:: declval<_Ty2&>())>> =
        true;

template <class _Ty1, class _Ty2>
inline constexpr bool _Is_pointer_address_comparable =
    _Can_compare_with_operator_equal<_Ty1*, _Ty2*>
    && (_Is_pointer_address_convertible<_Ty1, _Ty2> || _Is_pointer_address_convertible<_Ty2, _Ty1>);








#pragma warning(push)
#pragma warning(disable : 4806) 
template <class _Elem1, class _Elem2,
    bool = sizeof(_Elem1) == sizeof(_Elem2) && is_integral_v<_Elem1>&& is_integral_v<_Elem2>>
inline constexpr bool _Can_memcmp_elements =
    is_same_v<_Elem1, bool> || is_same_v<_Elem2, bool> || static_cast<_Elem1>(-1) == static_cast<_Elem2>(-1);
#pragma warning(pop)





template <>
inline constexpr bool _Can_memcmp_elements<byte, byte, false> = true;
#line 5096 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"



template <class _Ty1, class _Ty2>
inline constexpr bool _Can_memcmp_elements<_Ty1*, _Ty2*, false> = _Is_pointer_address_comparable<_Ty1, _Ty2>;

template <class _Elem1, class _Elem2>
inline constexpr bool _Can_memcmp_elements<_Elem1, _Elem2, false> = false;




template <class _Elem1, class _Elem2, class _Pr>
inline constexpr bool _Can_memcmp_elements_with_pred = false;



template <class _Elem1, class _Elem2, class _Elem3>
inline constexpr bool _Can_memcmp_elements_with_pred<_Elem1, _Elem2, equal_to<_Elem3>> =
    _Iter_copy_cat<_Elem1*, _Elem3*>::_Bitcopy_constructible && _Iter_copy_cat<_Elem2*, _Elem3*>::_Bitcopy_constructible
    && _Can_memcmp_elements<remove_cv_t<_Elem3>, remove_cv_t<_Elem3>>;


template <class _Elem1, class _Elem2>
inline constexpr bool _Can_memcmp_elements_with_pred<_Elem1, _Elem2, equal_to<>> =
    _Can_memcmp_elements<_Elem1, _Elem2>;



template <class _Elem1, class _Elem2>
inline constexpr bool _Can_memcmp_elements_with_pred<_Elem1, _Elem2, ::std::ranges:: equal_to> =
    _Can_memcmp_elements<_Elem1, _Elem2>;
#line 5129 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"




template <class _Iter1, class _Iter2, class _Pr>
inline constexpr bool _Equal_memcmp_is_safe_helper =
    _Iterators_are_contiguous<_Iter1, _Iter2> 
    && !_Iterator_is_volatile<_Iter1> && !_Iterator_is_volatile<_Iter2> 
    && _Can_memcmp_elements_with_pred<_Iter_value_t<_Iter1>, _Iter_value_t<_Iter2>, _Pr>;

template <class _Iter1, class _Iter2, class _Pr>
inline constexpr bool _Equal_memcmp_is_safe =
    _Equal_memcmp_is_safe_helper<remove_const_t<_Iter1>, remove_const_t<_Iter2>, _Pr>;

template <class _CtgIt1, class _CtgIt2>
[[nodiscard]] int _Memcmp_ranges(_CtgIt1 _First1, _CtgIt1 _Last1, _CtgIt2 _First2) {
     ;
    const auto _First1_ch = reinterpret_cast<const char*>(_To_address(_First1));
    const auto _Last1_ch  = reinterpret_cast<const char*>(_To_address(_Last1));
    const auto _First2_ch = reinterpret_cast<const char*>(_To_address(_First2));
    return :: memcmp(_First1_ch, _First2_ch, static_cast<size_t>(_Last1_ch - _First1_ch));
}

template <class _CtgIt1, class _CtgIt2>
[[nodiscard]] int _Memcmp_count(_CtgIt1 _First1, _CtgIt2 _First2, const size_t _Count) {
     ;
    const auto _First1_ch = reinterpret_cast<const char*>(_To_address(_First1));
    const auto _First2_ch = reinterpret_cast<const char*>(_To_address(_First2));
    return :: memcmp(_First1_ch, _First2_ch, _Count * sizeof(_Iter_value_t<_CtgIt1>));
}

 template <class _InIt1, class _InIt2, class _Pr>
[[nodiscard]] constexpr bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped_n(_First2, _Idl_distance<_InIt1>(_UFirst1, _ULast1));
    if constexpr (_Equal_memcmp_is_safe<decltype(_UFirst1), decltype(_UFirst2), _Pr>) {

        if (!::std:: is_constant_evaluated())
#line 5171 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        {
            return _Memcmp_ranges(_UFirst1, _ULast1, _UFirst2) == 0;
        }
    }

    for (; _UFirst1 != _ULast1; ++_UFirst1, (void) ++_UFirst2) {
        if (!_Pred(*_UFirst1, *_UFirst2)) {
            return false;
        }
    }

    return true;
}


 template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] bool equal(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
    _Pr _Pred) noexcept; 
#line 5190 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

 template <class _InIt1, class _InIt2>
[[nodiscard]] constexpr bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2) {
    
    return ::std:: equal(_First1, _Last1, _First2, equal_to<>{});
}


 template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] bool equal(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2) noexcept
  {
    
    return ::std:: equal(::std:: forward<_ExPo>(_Exec), _First1, _Last1, _First2, equal_to{});
}
#line 5205 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

 template <class _InIt1, class _InIt2, class _Pr>
[[nodiscard]] constexpr bool equal(
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);
    if constexpr (_Is_ranges_random_iter_v<_InIt1> && _Is_ranges_random_iter_v<_InIt2>) {
        if (_ULast1 - _UFirst1 != _ULast2 - _UFirst2) {
            return false;
        }

        return ::std:: equal(_UFirst1, _ULast1, _UFirst2, _Pass_fn(_Pred));
    } else {
        for (;;) {
            if (_UFirst1 == _ULast1) {
                return _UFirst2 == _ULast2;
            }

            if (_UFirst2 == _ULast2) {
                return false;
            }

            if (!_Pred(*_UFirst1, *_UFirst2)) {
                return false;
            }

            ++_UFirst1;
            ++_UFirst2;
        }
    }
}


 template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] bool equal(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
    const _FwdIt2 _Last2, _Pr _Pred) noexcept; 
#line 5247 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

 template <class _InIt1, class _InIt2>
[[nodiscard]] constexpr bool equal(
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2) {
    
    return ::std:: equal(_First1, _Last1, _First2, _Last2, equal_to<>{});
}


 template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] bool equal(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
    const _FwdIt2 _Last2) noexcept   {
    
    return ::std:: equal(::std:: forward<_ExPo>(_Exec), _First1, _Last1, _First2, _Last2, equal_to{});
}
#line 5263 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"


namespace ranges {
    template <forward_range _Rng, class _It>
    [[nodiscard]] constexpr iterator_t<_Rng> _Rewrap_iterator(_Rng&& _Range, _It&& _Val) {
         ;

        if constexpr (is_same_v<remove_cvref_t<_It>, iterator_t<_Rng>>) {
            return ::std:: forward<_It>(_Val);
        } else {
            auto _Result = ::std::ranges:: begin(_Range);
            _Result._Seek_to(::std:: forward<_It>(_Val));
            return _Result;
        }
    }

     template <class _In1, class _In2>
    struct in_in_result {
          _In1 in1;
          _In2 in2;

        template <_Convertible_from<const _In1&> _IIn1, _Convertible_from<const _In2&> _IIn2>
        constexpr operator in_in_result<_IIn1, _IIn2>() const& {
            return {in1, in2};
        }

        template <_Convertible_from<_In1> _IIn1, _Convertible_from<_In2> _IIn2>
        constexpr operator in_in_result<_IIn1, _IIn2>() && {
            return {::std:: move(in1), ::std:: move(in2)};
        }
    };

     template <class _In1, class _In2>
    using mismatch_result = in_in_result<_In1, _In2>;

    
    template <input_iterator _It1, input_iterator _It2, class _Pr, class _Pj1, class _Pj2>
        requires indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>
    [[nodiscard]] constexpr mismatch_result<_It1, _It2> _Mismatch_n(
        _It1 _First1, _It2 _First2, iter_difference_t<_It1> _Count, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
        
         ;
        for (; _Count != 0; ++_First1, (void) ++_First2, --_Count) {
            if (!::std:: invoke(_Pred, ::std:: invoke(_Proj1, *_First1), ::std:: invoke(_Proj2, *_First2))) {
                break;
            }
        }

        return {::std:: move(_First1), ::std:: move(_First2)};
    }

    template <input_iterator _It1, sentinel_for<_It1> _Se1, input_iterator _It2, sentinel_for<_It2> _Se2, class _Pr,
        class _Pj1, class _Pj2>
        requires indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>
    [[nodiscard]] constexpr mismatch_result<_It1, _It2> _Mismatch_4(
        _It1 _First1, _Se1 _Last1, _It2 _First2, _Se2 _Last2, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {

        for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void) ++_First2) {
            if (!::std:: invoke(_Pred, ::std:: invoke(_Proj1, *_First1), ::std:: invoke(_Proj2, *_First2))) {
                break;
            }
        }

        return {::std:: move(_First1), ::std:: move(_First2)};
    }

    class _Mismatch_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        
        template <input_iterator _It1, sentinel_for<_It1> _Se1, input_iterator _It2, sentinel_for<_It2> _Se2,
            class _Pr = ranges::equal_to, class _Pj1 = identity, class _Pj2 = identity>
            requires indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>
        [[nodiscard]] constexpr mismatch_result<_It1, _It2> operator()(_It1 _First1, _Se1 _Last1,
            _It2 _First2, _Se2 _Last2, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
            
            _Adl_verify_range(_First1, _Last1);
            _Adl_verify_range(_First2, _Last2);

            if constexpr (sized_sentinel_for<_Se1, _It1> && sized_sentinel_for<_Se2, _It2>) {
                iter_difference_t<_It1> _Count1       = _Last1 - _First1;
                const iter_difference_t<_It2> _Count2 = _Last2 - _First2;
                if (_Count1 > _Count2) {
                    _Count1 = static_cast<decltype(_Count1)>(_Count2);
                }

                auto _Result = ::std::ranges:: _Mismatch_n(_Get_unwrapped(::std:: move(_First1)),
                    _Get_unwrapped(::std:: move(_First2)), _Count1, _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
                _Seek_wrapped(_First1, ::std:: move(_Result.in1));
                _Seek_wrapped(_First2, ::std:: move(_Result.in2));
                return {::std:: move(_First1), ::std:: move(_First2)};
            } else {
                auto _Result = ::std::ranges:: _Mismatch_4(_Unwrap_iter<_Se1>(::std:: move(_First1)),
                    _Unwrap_sent<_It1>(::std:: move(_Last1)), _Unwrap_iter<_Se2>(::std:: move(_First2)),
                    _Unwrap_sent<_It2>(::std:: move(_Last2)), _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
                _Seek_wrapped(_First1, ::std:: move(_Result.in1));
                _Seek_wrapped(_First2, ::std:: move(_Result.in2));
                return {::std:: move(_First1), ::std:: move(_First2)};
            }
        }

        template <input_range _Rng1, input_range _Rng2, class _Pr = ranges::equal_to, class _Pj1 = identity,
            class _Pj2 = identity>
            requires indirectly_comparable<iterator_t<_Rng1>, iterator_t<_Rng2>, _Pr, _Pj1, _Pj2>
        [[nodiscard]] constexpr mismatch_result<borrowed_iterator_t<_Rng1>, borrowed_iterator_t<_Rng2>> operator()(
            _Rng1&& _Range1, _Rng2&& _Range2, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
            if constexpr (sized_range<_Rng1> && sized_range<_Rng2>) {
                range_difference_t<_Rng1> _Count1       = ::std::ranges:: distance(_Range1);
                const range_difference_t<_Rng2> _Count2 = ::std::ranges:: distance(_Range2);
                if (_Count1 > _Count2) {
                    _Count1 = static_cast<range_difference_t<_Rng1>>(_Count2);
                }

                auto _First1 = ::std::ranges:: begin(_Range1);
                auto _First2 = ::std::ranges:: begin(_Range2);
                auto _Result = ::std::ranges:: _Mismatch_n(_Get_unwrapped(::std:: move(_First1)),
                    _Get_unwrapped(::std:: move(_First2)), _Count1, _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
                _Seek_wrapped(_First1, ::std:: move(_Result.in1));
                _Seek_wrapped(_First2, ::std:: move(_Result.in2));
                return {::std:: move(_First1), ::std:: move(_First2)};
            } else {
                auto _First1 = ::std::ranges:: begin(_Range1);
                auto _First2 = ::std::ranges:: begin(_Range2);
                auto _Result = ::std::ranges:: _Mismatch_4(_Unwrap_range_iter<_Rng1>(::std:: move(_First1)), _Uend(_Range1),
                    _Unwrap_range_iter<_Rng2>(::std:: move(_First2)), _Uend(_Range2), _Pass_fn(_Pred), _Pass_fn(_Proj1),
                    _Pass_fn(_Proj2));
                _Seek_wrapped(_First1, ::std:: move(_Result.in1));
                _Seek_wrapped(_First2, ::std:: move(_Result.in2));
                return {::std:: move(_First1), ::std:: move(_First2)};
            }
        }
    };

     inline constexpr _Mismatch_fn mismatch{_Not_quite_object::_Construct_tag {}};
} 
#line 5400 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

template <class _Elem1, class _Elem2>
inline constexpr bool _Lex_compare_memcmp_classify_elements = conjunction_v<_Is_character_or_bool<_Elem1>,
    _Is_character_or_bool<_Elem2>, is_unsigned<_Elem1>, is_unsigned<_Elem2>>;


template <>
inline constexpr bool _Lex_compare_memcmp_classify_elements<byte, byte> = true;
#line 5409 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

template <class _Elem1, class _Elem2, class _Pr>
struct _Lex_compare_memcmp_classify_pred {
    using _Pred = void;
};

template <class _Elem1, class _Elem2, class _Elem3>
struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, less<_Elem3>> {
    using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem3, _Elem3>
                                    && _Iter_copy_cat<_Elem1*, _Elem3*>::_Bitcopy_constructible
                                    && _Iter_copy_cat<_Elem2*, _Elem3*>::_Bitcopy_constructible,
        less<int>, void>;
};

template <class _Elem1, class _Elem2>
struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, less<>> {
    using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>, less<int>, void>;
};

template <class _Elem1, class _Elem2, class _Elem3>
struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, greater<_Elem3>> {
    using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem3, _Elem3>
                                    && _Iter_copy_cat<_Elem1*, _Elem3*>::_Bitcopy_constructible
                                    && _Iter_copy_cat<_Elem2*, _Elem3*>::_Bitcopy_constructible,
        greater<int>, void>;
};

template <class _Elem1, class _Elem2>
struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, greater<>> {
    using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>, greater<int>, void>;
};


template <class _Elem1, class _Elem2>
struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, ::std::ranges:: less> {
    using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>, less<int>, void>;
};

template <class _Elem1, class _Elem2>
struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, ::std::ranges:: greater> {
    using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>, greater<int>, void>;
};
#line 5452 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

template <class _It1, class _It2, class _Pr>
using _Lex_compare_memcmp_classify =
    conditional_t<_Iterators_are_contiguous<_It1, _It2> && !_Iterator_is_volatile<_It1> && !_Iterator_is_volatile<_It2>,
        typename _Lex_compare_memcmp_classify_pred<_Iter_value_t<_It1>, _Iter_value_t<_It2>, _Pr>::_Pred, void>;

 template <class _InIt1, class _InIt2, class _Pr>
[[nodiscard]] constexpr bool lexicographical_compare(
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);

    using _Memcmp_pred = _Lex_compare_memcmp_classify<decltype(_UFirst1), decltype(_UFirst2), _Pr>;
    if constexpr (!is_void_v<_Memcmp_pred>) {

        if (!::std:: is_constant_evaluated())
#line 5474 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        {
            const auto _Num1 = static_cast<size_t>(_ULast1 - _UFirst1);
            const auto _Num2 = static_cast<size_t>(_ULast2 - _UFirst2);
            const int _Ans   = _Memcmp_count(_UFirst1, _UFirst2, (::std:: min)(_Num1, _Num2));
            return _Memcmp_pred{}(_Ans, 0) || (_Ans == 0 && _Num1 < _Num2);
        }
    }

    for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UFirst1, (void) ++_UFirst2) { 
        if (static_cast<bool>(_Pred(*_UFirst1, *_UFirst2)) ) {
            return true;
        } else if (_Pred(*_UFirst2, *_UFirst1)) {
            return false;
        }
    }

    return _UFirst1 == _ULast1 && _UFirst2 != _ULast2;
}

 template <class _InIt1, class _InIt2>
[[nodiscard]] constexpr bool lexicographical_compare(
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2) {
    
    return ::std:: lexicographical_compare(_First1, _Last1, _First2, _Last2, less<>{});
}


 template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] bool lexicographical_compare(_ExPo&&, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
    const _FwdIt2 _Last2, _Pr _Pred) noexcept   {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.") ;
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt2>, "Parallel algorithms require forward iterators or stronger.") ;
    return ::std:: lexicographical_compare(_First1, _Last1, _First2, _Last2, _Pass_fn(_Pred));
}

 template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] bool lexicographical_compare(_ExPo&&, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
    const _FwdIt2 _Last2) noexcept   {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.") ;
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt2>, "Parallel algorithms require forward iterators or stronger.") ;
    return ::std:: lexicographical_compare(_First1, _Last1, _First2, _Last2);
}
#line 5521 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"


template <class _Elem1, class _Elem2, class _Cmp>
struct _Lex_compare_three_way_memcmp_classify_comp {
    using _Comp = void;
};

template <class _Elem1, class _Elem2>
struct _Lex_compare_three_way_memcmp_classify_comp<_Elem1, _Elem2, compare_three_way> {
    using _Comp = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>
                                    && three_way_comparable_with<const _Elem1&, const _Elem2&>,
        compare_three_way, void>;
};

template <class _Elem1, class _Elem2>
struct _Lex_compare_three_way_memcmp_classify_comp<_Elem1, _Elem2, _Strong_order::_Cpo> {
    using _Comp =
        conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2> && _Can_strong_order<_Elem1, _Elem2>,
            _Strong_order::_Cpo, void>;
};

template <class _Elem1, class _Elem2>
struct _Lex_compare_three_way_memcmp_classify_comp<_Elem1, _Elem2, _Weak_order::_Cpo> {
    using _Comp =
        conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2> && _Can_weak_order<_Elem1, _Elem2>,
            _Weak_order::_Cpo, void>;
};

template <class _Elem1, class _Elem2>
struct _Lex_compare_three_way_memcmp_classify_comp<_Elem1, _Elem2, _Partial_order::_Cpo> {
    using _Comp =
        conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2> && _Can_partial_order<_Elem1, _Elem2>,
            _Partial_order::_Cpo, void>;
};

template <class _It1, class _It2, class _Cmp>
using _Lex_compare_three_way_memcmp_classify =
    conditional_t<_Iterators_are_contiguous<_It1, _It2> && !_Iterator_is_volatile<_It1> && !_Iterator_is_volatile<_It2>,
        typename _Lex_compare_three_way_memcmp_classify_comp<_Iter_value_t<_It1>, _Iter_value_t<_It2>, _Cmp>::_Comp,
        void>;

 template <class _InIt1, class _InIt2, class _Cmp>
[[nodiscard]] constexpr auto lexicographical_compare_three_way(const _InIt1 _First1, const _InIt1 _Last1,
    const _InIt2 _First2, const _InIt2 _Last2, _Cmp _Comp) -> decltype(_Comp(*_First1, *_First2)) {
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);

    using _Memcmp_pred = _Lex_compare_three_way_memcmp_classify<decltype(_UFirst1), decltype(_UFirst2), _Cmp>;
    if constexpr (!is_void_v<_Memcmp_pred>) {
        if (!::std:: is_constant_evaluated()) {
            const auto _Num1 = static_cast<size_t>(_ULast1 - _UFirst1);
            const auto _Num2 = static_cast<size_t>(_ULast2 - _UFirst2);
            const int _Ans   = _Memcmp_count(_UFirst1, _UFirst2, (::std:: min)(_Num1, _Num2));
            if (_Ans == 0) {
                return _Num1 <=> _Num2;
            } else {
                return _Memcmp_pred{}(_Ans, 0);
            }
        }
    }

    for (;;) {
        if (_UFirst1 == _ULast1) {
            return _UFirst2 == _ULast2 ? strong_ordering::equal : strong_ordering::less;
        }

        if (_UFirst2 == _ULast2) {
            return strong_ordering::greater;
        }

        if (const auto _CmpResult = _Comp(*_UFirst1, *_UFirst2); _CmpResult != 0) {
            return _CmpResult;
        }

        ++_UFirst1;
        ++_UFirst2;
    }
}

 template <class _InIt1, class _InIt2>
[[nodiscard]] constexpr auto lexicographical_compare_three_way(
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2) {
    return ::std:: lexicographical_compare_three_way(_First1, _Last1, _First2, _Last2, compare_three_way{});
}
#line 5610 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

template <class _Ty, class _Elem>
struct _Vector_alg_in_find_is_safe_object_pointers : false_type {};
template <class _Ty1, class _Ty2>
struct _Vector_alg_in_find_is_safe_object_pointers<_Ty1*, _Ty2*>
    : conjunction<
          
          disjunction<is_object<_Ty1>, is_void<_Ty1>>,
          
          disjunction<is_object<_Ty2>, is_void<_Ty2>>,
          
          disjunction<is_same<remove_cv_t<_Ty1>, remove_cv_t<_Ty2>>, is_void<_Ty1>, is_void<_Ty2>>> {};


template <class _Iter, class _Ty, class _Elem = _Iter_value_t<_Iter>>
inline constexpr bool _Vector_alg_in_find_is_safe =
    
    _Iterator_is_contiguous<_Iter>
    
    && !_Iterator_is_volatile<_Iter>
    
    && disjunction_v<

        
        conjunction<is_same<_Ty, byte>, is_same<_Elem, byte>>,
#line 5636 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
       
       
        conjunction<is_integral<_Ty>, is_integral<_Elem>>,
        
        conjunction<is_pointer<_Ty>, is_same<_Ty, _Elem>>,
        
        conjunction<is_same<_Ty, nullptr_t>, is_pointer<_Elem>>,
        
        
        
        _Vector_alg_in_find_is_safe_object_pointers<_Ty, _Elem>>;

template <class _InIt, class _Ty>
[[nodiscard]] constexpr bool _Could_compare_equal_to_value_type(const _Ty& _Val) {
    
     ;

    if constexpr (disjunction_v<

                      is_same<_Ty, byte>,
#line 5657 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
                      is_same<_Ty, bool>, is_pointer<_Ty>, is_same<_Ty, nullptr_t>>) {
        return true;
    } else {
        using _Elem = _Iter_value_t<_InIt>;
         ;

        if constexpr (is_same_v<_Elem, bool>) {
            return _Val == true || _Val == false;
        } else if constexpr (is_signed_v<_Elem>) {
            
            constexpr _Elem _Min = static_cast<_Elem>(_Elem{1} << (sizeof(_Elem) * 8 - 1));
            constexpr _Elem _Max = static_cast<_Elem>(~_Min);

            if constexpr (is_signed_v<_Ty>) {
                
                return _Min <= _Val && _Val <= _Max;
            } else {
                
                if constexpr (_Elem{-1} == static_cast<_Ty>(-1)) {
                    
                    return _Val <= _Max || static_cast<_Ty>(_Min) <= _Val;
                } else {
                    
                    return _Val <= _Max;
                }
            }
        } else {
            constexpr _Elem _Max = static_cast<_Elem>(~_Elem{0});

            if constexpr (is_unsigned_v<_Ty>) {
                
                return _Val <= _Max;
            } else {
                
                if constexpr (_Ty{-1} == static_cast<_Elem>(-1)) {
                    
                    return _Val <= _Max;
                } else {
                    
                    return 0 <= _Val && _Val <= _Max;
                }
            }
        }
    }
}

template <class _InIt, class _Ty>
[[nodiscard]] constexpr _InIt _Find_unchecked(_InIt _First, const _InIt _Last, const _Ty& _Val) {
    
    
    if constexpr (_Vector_alg_in_find_is_safe<_InIt, _Ty>) {

        if (!::std:: is_constant_evaluated())
#line 5711 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        {
            if (!::std:: _Could_compare_equal_to_value_type<_InIt>(_Val)) {
                return _Last;
            }

            const auto _First_ptr = _To_address(_First);
            const auto _Result    = __std_find_trivial(_First_ptr, _To_address(_Last), _Val);
            if constexpr (is_pointer_v<_InIt>) {
                return _Result;
            } else {
                return _First + (_Result - _First_ptr);
            }












#line 5736 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        }
    }

    for (; _First != _Last; ++_First) {
        if (*_First == _Val) {
            break;
        }
    }

    return _First;
}

 template <class _InIt, class _Ty>
[[nodiscard]] constexpr _InIt find(_InIt _First, const _InIt _Last, const _Ty& _Val) { 
    _Adl_verify_range(_First, _Last);
    if constexpr (_Is_vb_iterator<_InIt> && is_same_v<_Ty, bool>) {
        return _Find_vbool(_First, _Last, _Val);
    } else {
        _Seek_wrapped(_First, ::std:: _Find_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val));
        return _First;
    }
}


 template <class _ExPo, class _FwdIt, class _Ty, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] _FwdIt find(_ExPo&& _Exec, _FwdIt _First, const _FwdIt _Last, const _Ty& _Val) noexcept; 
#line 5763 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"


namespace ranges {
    template <class _Se, class _It>
    concept _Sized_or_unreachable_sentinel_for = sized_sentinel_for<_Se, _It> || same_as<_Se, unreachable_sentinel_t>;

    template <class _Rng>
    concept _Sized_or_infinite_range = range<_Rng>
                                    && (sized_range<_Rng> || same_as<sentinel_t<_Rng>, unreachable_sentinel_t>);

    
    template <input_iterator _It, sentinel_for<_It> _Se, class _Ty, class _Pj = identity>
        requires indirect_binary_predicate<ranges::equal_to, projected<_It, _Pj>, const _Ty*>
    [[nodiscard]] constexpr _It _Find_unchecked(_It _First, const _Se _Last, const _Ty& _Val, _Pj _Proj = {}) {
        constexpr bool _Is_sized = sized_sentinel_for<_Se, _It>;
        if constexpr (_Vector_alg_in_find_is_safe<_It, _Ty> && _Sized_or_unreachable_sentinel_for<_Se, _It>
                      && same_as<_Pj, identity>) {
            if (!::std:: is_constant_evaluated()) {
                if (!::std:: _Could_compare_equal_to_value_type<_It>(_Val)) {
                    if constexpr (_Is_sized) {
                        return ::std::ranges:: next(::std:: move(_First), _Last);
                    } else {
                        
;
                    }
                }

                using _Ptr_t = remove_reference_t<_Iter_ref_t<_It>>*;

                const auto _First_ptr = _To_address(_First);

                _Ptr_t _Result;

                if constexpr (_Is_sized) {
                    const auto _Last_ptr = _First_ptr + (_Last - _First);

                    _Result = __std_find_trivial(_First_ptr, _Last_ptr, _Val);
                } else {
                    _Result = __std_find_trivial_unsized(_First_ptr, _Val);
                }

                if constexpr (is_pointer_v<_It>) {
                    return _Result;
                } else {
                    return ::std::ranges:: next(::std:: move(_First), _Result - _First_ptr);
                }



























#line 5837 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
            }
        }

        for (; _First != _Last; ++_First) {
            if (::std:: invoke(_Proj, *_First) == _Val) {
                break;
            }
        }

        return _First;
    }

    class _Find_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        
        template <input_iterator _It, sentinel_for<_It> _Se, class _Ty, class _Pj = identity>
            requires indirect_binary_predicate<ranges::equal_to, projected<_It, _Pj>, const _Ty*>
        [[nodiscard]] constexpr _It operator()(_It _First, _Se _Last, const _Ty& _Val, _Pj _Proj = {}) const {
            
            _Adl_verify_range(_First, _Last);
            auto _UResult = ::std::ranges:: _Find_unchecked(
                _Unwrap_iter<_Se>(::std:: move(_First)), _Unwrap_sent<_It>(::std:: move(_Last)), _Val, _Pass_fn(_Proj));

            _Seek_wrapped(_First, ::std:: move(_UResult));
            return _First;
        }

        template <input_range _Rng, class _Ty, class _Pj = identity>
            requires indirect_binary_predicate<ranges::equal_to, projected<iterator_t<_Rng>, _Pj>, const _Ty*>
        [[nodiscard]] constexpr borrowed_iterator_t<_Rng> operator()(
            _Rng&& _Range, const _Ty& _Val, _Pj _Proj = {}) const {
            auto _First   = ::std::ranges:: begin(_Range);
            auto _UResult = ::std::ranges:: _Find_unchecked(
                _Unwrap_range_iter<_Rng>(::std:: move(_First)), _Uend(_Range), _Val, _Pass_fn(_Proj));

            _Seek_wrapped(_First, ::std:: move(_UResult));
            return _First;
        }
    };

     inline constexpr _Find_fn find{_Not_quite_object::_Construct_tag {}};
} 
#line 5882 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

 template <class _InIt, class _Ty>
[[nodiscard]] constexpr _Iter_diff_t<_InIt> count(const _InIt _First, const _InIt _Last, const _Ty& _Val) {
    
    _Adl_verify_range(_First, _Last);
    if constexpr (_Is_vb_iterator<_InIt> && is_same_v<_Ty, bool>) {
        return _Count_vbool(_First, _Last, _Val);
    } else {
        auto _UFirst      = _Get_unwrapped(_First);
        const auto _ULast = _Get_unwrapped(_Last);


        if constexpr (_Vector_alg_in_find_is_safe<decltype(_UFirst), _Ty>) {

            if (!::std:: is_constant_evaluated())
#line 5898 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
            {
                if (!::std:: _Could_compare_equal_to_value_type<decltype(_UFirst)>(_Val)) {
                    return 0;
                }

                return static_cast<_Iter_diff_t<_InIt>>(
                    __std_count_trivial(_To_address(_UFirst), _To_address(_ULast), _Val));
            }
        }
#line 5908 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

        _Iter_diff_t<_InIt> _Count = 0;

        for (; _UFirst != _ULast; ++_UFirst) {
            if (*_UFirst == _Val) {
                ++_Count;
            }
        }

        return _Count;
    }
}


 template <class _ExPo, class _FwdIt, class _Ty, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] _Iter_diff_t<_FwdIt> count(
    _ExPo&& _Exec, const _FwdIt _First, const _FwdIt _Last, const _Ty& _Val) noexcept; 
#line 5926 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

template <class _InIt, class _Ty, class _Pr>
[[nodiscard]] constexpr _InIt _Find_pr(_InIt _First, const _InIt _Last, const _Ty& _Val, _Pr _Pred) {
    for (; _First != _Last; ++_First) {
        if (_Pred(*_First, _Val)) {
            break;
        }
    }

    return _First;
}

template <class _InIt, class _Ty, class _Pr>
[[nodiscard]] constexpr _Iter_diff_t<_InIt> _Count_pr(_InIt _First, const _InIt _Last, const _Ty& _Val, _Pr _Pred) {
    _Iter_diff_t<_InIt> _Count = 0;

    for (; _First != _Last; ++_First) {
        if (_Pred(*_First, _Val)) {
            ++_Count;
        }
    }

    return _Count;
}

enum class _TrimResult : unsigned char { _KeepTrimming, _HaveWorkAfterTrimming, _ReturnFalse, _ReturnTrue };

template <class _BidIt1, class _BidIt2, class _Pr>
[[nodiscard]] constexpr _TrimResult _Trim_equal(
    _BidIt1& _First1, _BidIt1& _Back1, _BidIt2& _First2, _BidIt2& _Back2, _Pr _Pred) {
    
    
     ;
     ;
    if (_Pred(*_First1, *_First2)) {
        do {
            ++_First1;
            ++_First2;
            if (_First1 == _Back1) {
                
                return _Pred(*_First1, *_First2) ? _TrimResult::_ReturnTrue : _TrimResult::_ReturnFalse;
            }
        } while (_Pred(*_First1, *_First2));
    } else {
        if (!_Pred(*_Back1, *_Back2)) {
            
            return _TrimResult::_HaveWorkAfterTrimming;
        }
        --_Back1;
        --_Back2;
    }

    for (;;) {
        if (_First1 == _Back1) {
            
            return _TrimResult::_ReturnFalse;
        }

        if (!_Pred(*_Back1, *_Back2)) {
            return _TrimResult::_KeepTrimming;
        }
        --_Back1;
        --_Back2;
    }
}

template <class _BidIt1, class _BidIt2, class _Pr>
[[nodiscard]] constexpr _TrimResult _Trim_reversed(
    _BidIt1& _First1, _BidIt1& _Back1, _BidIt2& _First2, _BidIt2& _Back2, _Pr _Pred) {
    
    
     ;
     ;
    if (_Pred(*_First1, *_Back2)) {
        do {
            ++_First1;
            --_Back2;
            if (_First1 == _Back1) {
                
                return _Pred(*_First1, *_First2) ? _TrimResult::_ReturnTrue : _TrimResult::_ReturnFalse;
            }
        } while (_Pred(*_First1, *_Back2));
    } else {
        if (!_Pred(*_Back1, *_First2)) {
            
            return _TrimResult::_HaveWorkAfterTrimming;
        }
        --_Back1;
        ++_First2;
    }

    for (;;) {
        if (_First1 == _Back1) {
            
            return _TrimResult::_ReturnFalse;
        }

        if (!_Pred(*_Back1, *_First2)) {
            return _TrimResult::_KeepTrimming;
        }
        --_Back1;
        ++_First2;
    }
}

template <class _BidIt1, class _BidIt2, class _Pr>
[[nodiscard]] constexpr _TrimResult _Trim_completely(
    _BidIt1& _First1, _BidIt1& _Back1, _BidIt2& _First2, _BidIt2& _Back2, _Pr _Pred) {
    
    _TrimResult _Res = _TrimResult::_KeepTrimming;

    for (bool _Check_reversed = true; _Res == _TrimResult::_KeepTrimming; _Check_reversed = !_Check_reversed) {
        if (_Check_reversed) {
            _Res = _Trim_reversed(_First1, _Back1, _First2, _Back2, _Pred);
        } else {
            _Res = _Trim_equal(_First1, _Back1, _First2, _Back2, _Pred);
        }
    }

    return _Res;
}

template <class _FwdIt1, class _FwdIt2, class _Pr>
[[nodiscard]] constexpr bool _Check_match_counts(
    _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred) {
    
     ;
     ;
    if constexpr (_Is_ranges_bidi_iter_v<_FwdIt1> && _Is_ranges_bidi_iter_v<_FwdIt2>) {
        do { 
            --_Last1;
            --_Last2;
        } while (_Pred(*_Last1, *_Last2));

        if (_First1 == _Last1) {
            return false;
        }

        const _TrimResult _Res = _Trim_completely(_First1, _Last1, _First2, _Last2, _Pred);

        if (_Res != _TrimResult::_HaveWorkAfterTrimming) {
            return _Res == _TrimResult::_ReturnTrue;
        }

        ++_Last1;
        ++_Last2;
    }

    for (_FwdIt1 _Next1 = _First1; _Next1 != _Last1; ++_Next1) {
        if (_Next1 == _Find_pr(_First1, _Next1, *_Next1, _Pred)) { 
            _Iter_diff_t<_FwdIt2> _Count2 = _Count_pr(_First2, _Last2, *_Next1, _Pred);
            if (_Count2 == 0) {
                return false; 
            }

            _FwdIt1 _Skip1                = _Next_iter(_Next1);
            _Iter_diff_t<_FwdIt1> _Count1 = _Count_pr(_Skip1, _Last1, *_Next1, _Pred) + 1;
            if (_Count2 != _Count1) {
                return false; 
            }
        }
    }

    return true;
}

 template <class _BidIt>
constexpr void reverse(const _BidIt _First, const _BidIt _Last) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst = _Get_unwrapped(_First);
    auto _ULast  = _Get_unwrapped(_Last);

    using _Elem                         = remove_reference_t<_Iter_ref_t<decltype(_UFirst)>>;
    constexpr bool _Allow_vectorization = conjunction_v<bool_constant<_Iterator_is_contiguous<decltype(_UFirst)>>,
        _Is_trivially_swappable<_Elem>, negation<is_volatile<_Elem>>>;
    constexpr size_t _Nx                = sizeof(_Elem);

    if constexpr (_Allow_vectorization && _Nx <= 8 && (_Nx & (_Nx - 1)) == 0) {

        if (!::std:: is_constant_evaluated())
#line 6107 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        {
            if constexpr (_Nx == 1) {
                __std_reverse_trivially_swappable_1(_To_address(_UFirst), _To_address(_ULast));
            } else if constexpr (_Nx == 2) {
                __std_reverse_trivially_swappable_2(_To_address(_UFirst), _To_address(_ULast));
            } else if constexpr (_Nx == 4) {
                __std_reverse_trivially_swappable_4(_To_address(_UFirst), _To_address(_ULast));
            } else {
                __std_reverse_trivially_swappable_8(_To_address(_UFirst), _To_address(_ULast));
            }

            return;
        }
    }
#line 6122 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

    for (; _UFirst != _ULast && _UFirst != --_ULast; ++_UFirst) {
        ::std:: iter_swap(_UFirst, _ULast);
    }
}


 template <class _ExPo, class _BidIt, _Enable_if_execution_policy_t<_ExPo> = 0>
void reverse(_ExPo&&, _BidIt _First, _BidIt _Last) noexcept   {
    
    
    return ::std:: reverse(_First, _Last);
}
#line 6136 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

template <class _BidIt>
constexpr pair<_BidIt, _BidIt> _Reverse_until_sentinel_unchecked(_BidIt _First, _BidIt _Sentinel, _BidIt _Last) {
    
    while (_First != _Sentinel && _Last != _Sentinel) {
        ::std:: iter_swap(_First, --_Last);
        ++_First;
    }

    return pair<_BidIt, _BidIt>(_First, _Last);
}

 template <class _FwdIt>
constexpr _FwdIt rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last) {
    
    
    
    _Adl_verify_range(_First, _Mid);
    _Adl_verify_range(_Mid, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    auto _UMid        = _Get_unwrapped(_Mid);
    const auto _ULast = _Get_unwrapped(_Last);
    if (_UFirst == _UMid) {
        return _Last;
    }

    if (_UMid == _ULast) {
        return _First;
    }

    if constexpr (_Is_cpp17_random_iter_v<_FwdIt>) {
        ::std:: reverse(_UFirst, _UMid);
        ::std:: reverse(_UMid, _ULast);
        ::std:: reverse(_UFirst, _ULast);
        _Seek_wrapped(_First, _UFirst + (_ULast - _UMid));
    } else if constexpr (_Is_cpp17_bidi_iter_v<_FwdIt>) {
        ::std:: reverse(_UFirst, _UMid);
        ::std:: reverse(_UMid, _ULast);
        auto _Tmp = _Reverse_until_sentinel_unchecked(_UFirst, _UMid, _ULast);
        ::std:: reverse(_Tmp.first, _Tmp.second);
        _Seek_wrapped(_First, _UMid != _Tmp.first ? _Tmp.first : _Tmp.second);
    } else {
        auto _UNext = _UMid;
        do { 
            ::std:: iter_swap(_UFirst, _UNext);
            ++_UFirst;
            ++_UNext;
            if (_UFirst == _UMid) {
                _UMid = _UNext;
            }
        } while (_UNext != _ULast);
        _Seek_wrapped(_First, _UFirst);
        while (_UMid != _ULast) { 
            _UNext = _UMid;
            do {
                ::std:: iter_swap(_UFirst, _UNext);
                ++_UFirst;
                ++_UNext;
                if (_UFirst == _UMid) {
                    _UMid = _UNext;
                }
            } while (_UNext != _ULast);
        }
    }

    return _First;
}


 template <class _ExPo, class _FwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
_FwdIt rotate(_ExPo&&, _FwdIt _First, _FwdIt _Mid, _FwdIt _Last) noexcept   {
    
    
    return ::std:: rotate(_First, _Mid, _Last);
}
#line 6212 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

 template <class _InIt, class _Pr>
[[nodiscard]] constexpr _InIt find_if(_InIt _First, const _InIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (_Pred(*_UFirst)) {
            break;
        }
    }

    _Seek_wrapped(_First, _UFirst);
    return _First;
}


namespace ranges {
    template <class _Result, class _Wrapped, class _Unwrapped>
    [[nodiscard]] constexpr _Result _Rewrap_subrange(_Wrapped& _Val, subrange<_Unwrapped>&& _UResult) {
        
        if constexpr (is_same_v<_Result, dangling>) {
            return dangling{};
        } else if constexpr (is_same_v<_Result, subrange<_Unwrapped>>) {
            return ::std:: move(_UResult);
        } else if constexpr (range<_Wrapped>) {
             ;
             ;
             ;

            auto _First = ::std::ranges:: begin(_Val);
            auto _Last  = _First;
            _First._Seek_to(_UResult.begin());
            _Last._Seek_to(_UResult.end());
            return _Result{::std:: move(_First), ::std:: move(_Last)};
        } else {
             ;
             ;

            auto _Last = _Val;
            _Val._Seek_to(_UResult.begin());
            _Last._Seek_to(_UResult.end());
            return _Result{::std:: move(_Val), ::std:: move(_Last)};
        }
    }

    
    template <input_iterator _It, sentinel_for<_It> _Se, class _Pj, indirect_unary_predicate<projected<_It, _Pj>> _Pr>
    [[nodiscard]] constexpr _It _Find_if_unchecked(_It _First, const _Se _Last, _Pr _Pred, _Pj _Proj) {
        for (; _First != _Last; ++_First) {
            if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_First))) {
                break;
            }
        }

        return _First;
    }

    class _Find_if_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It, sentinel_for<_It> _Se, class _Pj = identity,
            indirect_unary_predicate<projected<_It, _Pj>> _Pr>
        [[nodiscard]] constexpr _It operator()(_It _First, _Se _Last, _Pr _Pred, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            auto _UResult = ::std::ranges:: _Find_if_unchecked(_Unwrap_iter<_Se>(::std:: move(_First)),
                _Unwrap_sent<_It>(::std:: move(_Last)), _Pass_fn(_Pred), _Pass_fn(_Proj));

            _Seek_wrapped(_First, ::std:: move(_UResult));
            return _First;
        }

        template <input_range _Rng, class _Pj = identity,
            indirect_unary_predicate<projected<iterator_t<_Rng>, _Pj>> _Pr>
        [[nodiscard]] constexpr borrowed_iterator_t<_Rng> operator()(_Rng&& _Range, _Pr _Pred, _Pj _Proj = {}) const {
            auto _First   = ::std::ranges:: begin(_Range);
            auto _UResult = ::std::ranges:: _Find_if_unchecked(
                _Unwrap_range_iter<_Rng>(::std:: move(_First)), _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj));

            _Seek_wrapped(_First, ::std:: move(_UResult));
            return _First;
        }
    };

     inline constexpr _Find_if_fn find_if{_Not_quite_object::_Construct_tag {}};

    class _Find_if_not_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It, sentinel_for<_It> _Se, class _Pj = identity,
            indirect_unary_predicate<projected<_It, _Pj>> _Pr>
        [[nodiscard]] constexpr _It operator()(_It _First, _Se _Last, _Pr _Pred, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);

            auto _UResult = _Find_if_not_unchecked(_Unwrap_iter<_Se>(::std:: move(_First)),
                _Unwrap_sent<_It>(::std:: move(_Last)), _Pass_fn(_Pred), _Pass_fn(_Proj));

            _Seek_wrapped(_First, ::std:: move(_UResult));
            return _First;
        }

        template <input_range _Rng, class _Pj = identity,
            indirect_unary_predicate<projected<iterator_t<_Rng>, _Pj>> _Pr>
        [[nodiscard]] constexpr borrowed_iterator_t<_Rng> operator()(_Rng&& _Range, _Pr _Pred, _Pj _Proj = {}) const {
            auto _First = ::std::ranges:: begin(_Range);

            auto _UResult = _Find_if_not_unchecked(
                _Unwrap_range_iter<_Rng>(::std:: move(_First)), _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj));

            _Seek_wrapped(_First, ::std:: move(_UResult));
            return _First;
        }

    private:
        template <class _It, class _Se, class _Pj, class _Pr>
        [[nodiscard]] static constexpr _It _Find_if_not_unchecked(_It _First, const _Se _Last, _Pr _Pred, _Pj _Proj) {
             ;
             ;
             ;

            for (; _First != _Last; ++_First) {
                if (!::std:: invoke(_Pred, ::std:: invoke(_Proj, *_First))) {
                    break;
                }
            }

            return _First;
        }
    };

     inline constexpr _Find_if_not_fn find_if_not{_Not_quite_object::_Construct_tag {}};

    class _Adjacent_find_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <forward_iterator _It, sentinel_for<_It> _Se, class _Pj = identity,
            indirect_binary_predicate<projected<_It, _Pj>, projected<_It, _Pj>> _Pr = ranges::equal_to>
        [[nodiscard]] constexpr _It operator()(_It _First, _Se _Last, _Pr _Pred = {}, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);

            auto _UResult = _Adjacent_find_unchecked(_Unwrap_iter<_Se>(::std:: move(_First)),
                _Unwrap_sent<_It>(::std:: move(_Last)), _Pass_fn(_Pred), _Pass_fn(_Proj));

            _Seek_wrapped(_First, ::std:: move(_UResult));
            return _First;
        }

        template <forward_range _Rng, class _Pj = identity,
            indirect_binary_predicate<projected<iterator_t<_Rng>, _Pj>, projected<iterator_t<_Rng>, _Pj>> _Pr =
                ranges::equal_to>
        [[nodiscard]] constexpr borrowed_iterator_t<_Rng> operator()(_Rng&& _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
            auto _UResult = _Adjacent_find_unchecked(_Ubegin(_Range), _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj));

            return _Rewrap_iterator(_Range, ::std:: move(_UResult));
        }

    private:
        template <class _It, class _Se, class _Pj, class _Pr>
        [[nodiscard]] static constexpr _It _Adjacent_find_unchecked(_It _First, const _Se _Last, _Pr _Pred, _Pj _Proj) {
            
             ;
             ;
             ;

            if (_First == _Last) {
                return _First;
            }

            for (auto _Next = _First;; ++_First) {
                if (++_Next == _Last) {
                    return _Next;
                }

                if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_First), ::std:: invoke(_Proj, *_Next))) {
                    return _First;
                }
            }
        }
    };

     inline constexpr _Adjacent_find_fn adjacent_find{_Not_quite_object::_Construct_tag {}};

    
    template <class _It1, class _It2, class _Se2, class _Pr, class _Pj1, class _Pj2>
    concept _Equal_rev_pred_can_memcmp = is_same_v<_Pj1, identity> && is_same_v<_Pj2, identity>
        && sized_sentinel_for<_Se2, _It2> && _Equal_memcmp_is_safe<_It1, _It2, _Pr>;

    template <input_iterator _It1, input_iterator _It2, sentinel_for<_It2> _Se2, class _Pr, class _Pj1, class _Pj2>
        requires indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>
    [[nodiscard]] constexpr pair<bool, _It1> _Equal_rev_pred(
        _It1 _First1, _It2 _First2, const _Se2 _Last2, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
        
        
        
        constexpr bool _Optimize = _Equal_rev_pred_can_memcmp<_It1, _It2, _Se2, _Pr, _Pj1, _Pj2>;
        if constexpr (_Optimize) {
            if (!::std:: is_constant_evaluated()) {
                bool _Ans;
                if constexpr (same_as<_It2, _Se2>) {
                    _Ans = _Memcmp_ranges(_First2, _Last2, _First1) == 0;
                } else {
                    _Ans = _Memcmp_count(_First1, _First2, static_cast<size_t>(_Last2 - _First2)) == 0;
                }

                if (_Ans) {
                    _First1 += (_Last2 - _First2);
                    return {true, ::std:: move(_First1)};
                } else {
                    return {false, _It1 {}};
                }
            }
        }

        for (; _First2 != _Last2; ++_First1, (void) ++_First2) {
            if (!::std:: invoke(_Pred, ::std:: invoke(_Proj1, *_First1), ::std:: invoke(_Proj2, *_First2))) {
                return {false, _It1 {}};
            }
        }

        return {true, ::std:: move(_First1)};
    }

    class _Search_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <forward_iterator _It1, sentinel_for<_It1> _Se1, forward_iterator _It2, sentinel_for<_It2> _Se2,
            class _Pr = ranges::equal_to, class _Pj1 = identity, class _Pj2 = identity>
            requires indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>
        [[nodiscard]] constexpr subrange<_It1> operator()(_It1 _First1, _Se1 _Last1, _It2 _First2, _Se2 _Last2,
            _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
            _Adl_verify_range(_First1, _Last1);
            _Adl_verify_range(_First2, _Last2);
            auto _UFirst1 = _Unwrap_iter<_Se1>(::std:: move(_First1));
            auto _ULast1  = _Unwrap_sent<_It1>(::std:: move(_Last1));
            auto _UFirst2 = _Unwrap_iter<_Se2>(::std:: move(_First2));
            auto _ULast2  = _Unwrap_sent<_It2>(::std:: move(_Last2));

            if constexpr (sized_sentinel_for<_Se1, _It1> && sized_sentinel_for<_Se2, _It2>) {
                const auto _Count1 = _ULast1 - _UFirst1;
                const auto _Count2 = _ULast2 - _UFirst2;
                auto _UResult = _Search_sized(::std:: move(_UFirst1), ::std:: move(_ULast1), _Count1, ::std:: move(_UFirst2),
                    ::std:: move(_ULast2), _Count2, _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
                return _Rewrap_subrange<subrange<_It1>>(_First1, ::std:: move(_UResult));
            } else {
                auto _UResult = _Search_unsized(::std:: move(_UFirst1), ::std:: move(_ULast1), ::std:: move(_UFirst2),
                    ::std:: move(_ULast2), _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
                return _Rewrap_subrange<subrange<_It1>>(_First1, ::std:: move(_UResult));
            }
        }

        template <forward_range _Rng1, forward_range _Rng2, class _Pr = ranges::equal_to, class _Pj1 = identity,
            class _Pj2 = identity>
            requires indirectly_comparable<iterator_t<_Rng1>, iterator_t<_Rng2>, _Pr, _Pj1, _Pj2>
        [[nodiscard]] constexpr borrowed_subrange_t<_Rng1> operator()(
            _Rng1&& _Range1, _Rng2&& _Range2, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
            if constexpr (sized_range<_Rng1> && sized_range<_Rng2>) {
                const auto _Count1 = ::std::ranges:: distance(_Range1);
                const auto _Count2 = ::std::ranges:: distance(_Range2);
                auto _UResult      = _Search_sized(_Ubegin(_Range1), _Uend(_Range1), _Count1, _Ubegin(_Range2),
                         _Uend(_Range2), _Count2, _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
                return _Rewrap_subrange<borrowed_subrange_t<_Rng1>>(_Range1, ::std:: move(_UResult));
            } else {
                auto _UResult = _Search_unsized(_Ubegin(_Range1), _Uend(_Range1), _Ubegin(_Range2), _Uend(_Range2),
                    _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
                return _Rewrap_subrange<borrowed_subrange_t<_Rng1>>(_Range1, ::std:: move(_UResult));
            }
        }

    private:
        template <class _It1, class _Se1, class _It2, class _Se2, class _Pr, class _Pj1, class _Pj2>
        [[nodiscard]] static constexpr subrange<_It1> _Search_sized(_It1 _First1, const _Se1 _Last1,
            iter_difference_t<_It1> _Count1, _It2 _First2, const _Se2 _Last2, const iter_difference_t<_It2> _Count2,
            _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
             ;
             ;
             ;
             ;
             ;
             ;
             ;

            for (; _Count1 >= _Count2; ++_First1, (void) --_Count1) {
                auto [_Match, _Mid1] = ::std::ranges:: _Equal_rev_pred(_First1, _First2, _Last2, _Pred, _Proj1, _Proj2);
                if (_Match) {
                    return {::std:: move(_First1), ::std:: move(_Mid1)};
                }
            }

            _First1 = _Find_last_iterator(_First1, _Last1, _Count1);
            return {_First1, _First1};
        }

        template <class _It1, class _Se1, class _It2, class _Se2, class _Pr, class _Pj1, class _Pj2>
        [[nodiscard]] static constexpr subrange<_It1> _Search_unsized(
            _It1 _First1, const _Se1 _Last1, _It2 _First2, const _Se2 _Last2, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
             ;
             ;
             ;
             ;
             ;

            for (;; ++_First1) {
                auto _Mid1 = _First1;
                for (auto _Mid2 = _First2;; ++_Mid1, (void) ++_Mid2) {
                    if (_Mid2 == _Last2) { 
                        return {::std:: move(_First1), ::std:: move(_Mid1)};
                    }

                    if (_Mid1 == _Last1) { 
                        return {_Mid1, _Mid1};
                    }

                    if (!::std:: invoke(_Pred, ::std:: invoke(_Proj1, *_Mid1), ::std:: invoke(_Proj2, *_Mid2))) { 
                        break;
                    }
                }
            }
        }
    };

     inline constexpr _Search_fn search{_Not_quite_object::_Construct_tag {}};
} 
#line 6539 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

template <class _Iter, class _Pr, class _Elem = _Iter_value_t<_Iter>>
inline constexpr bool _Is_min_max_optimization_safe = 
    _Iterator_is_contiguous<_Iter> 
    && !_Iterator_is_volatile<_Iter> 
    && conjunction_v<disjunction<is_integral<_Elem>, is_pointer<_Elem>>, 
        disjunction< 

            is_same<_Pr, ::std::ranges:: less>, 
#line 6549 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
            is_same<_Pr, less<>>, is_same<_Pr, less<_Elem>>>>; 

template <class _FwdIt, class _Pr>
constexpr _FwdIt _Max_element_unchecked(_FwdIt _First, _FwdIt _Last, _Pr _Pred) { 

    if constexpr (_Is_min_max_optimization_safe<_FwdIt, _Pr>) {
        if (!_Is_constant_evaluated()) {
            const auto _First_ptr = _To_address(_First);
            const auto _Result    = __std_max_element(_First_ptr, _To_address(_Last));
            if constexpr (is_pointer_v<_FwdIt>) {
                return _Result;
            } else {
                return _First + (_Result - _First_ptr);
            }
        }
    }
#line 6566 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

    _FwdIt _Found = _First;
    if (_First != _Last) {
        while (++_First != _Last) {
            if (static_cast<bool>(_Pred(*_Found, *_First)) ) {
                _Found = _First;
            }
        }
    }

    return _Found;
}

 template <class _FwdIt, class _Pr>
[[nodiscard]] constexpr _FwdIt max_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    _Seek_wrapped(_First, ::std:: _Max_element_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pass_fn(_Pred)));
    return _First;
}

 template <class _FwdIt>
[[nodiscard]] constexpr _FwdIt max_element(_FwdIt _First, _FwdIt _Last) { 
    return ::std:: max_element(_First, _Last, less<>{});
}


 template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] _FwdIt max_element(_ExPo&&, _FwdIt _First, _FwdIt _Last, _Pr _Pred) noexcept   {
    
    
    return ::std:: max_element(_First, _Last, _Pass_fn(_Pred));
}

 template <class _ExPo, class _FwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] _FwdIt max_element(_ExPo&&, _FwdIt _First, _FwdIt _Last) noexcept   {
    
    
    return ::std:: max_element(_First, _Last);
}


namespace ranges {
    template <class _It, class _Se, class _Pr, class _Pj>
    [[nodiscard]] constexpr _It _Max_element_unchecked(_It _First, const _Se _Last, _Pr _Pred, _Pj _Proj) {
         ;
         ;
         ;


        if constexpr (is_same_v<_Pj, identity> && _Is_min_max_optimization_safe<_It, _Pr>
                      && sized_sentinel_for<_Se, _It>) {
            if (!::std:: is_constant_evaluated()) {
                const auto _First_ptr = ::std:: to_address(_First);
                const auto _Last_ptr  = _First_ptr + (_Last - _First);
                const auto _Result    = __std_max_element(_First_ptr, _Last_ptr);
                if constexpr (is_pointer_v<_It>) {
                    return _Result;
                } else {
                    return _First + (_Result - _First_ptr);
                }
            }
        }
#line 6629 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

        auto _Found = _First;
        if (_First == _Last) {
            return _Found;
        }

        while (++_First != _Last) {
            if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_Found), ::std:: invoke(_Proj, *_First))) {
                _Found = _First;
            }
        }

        return _Found;
    }

    class _Max_element_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <forward_iterator _It, sentinel_for<_It> _Se, class _Pj = identity,
            indirect_strict_weak_order<projected<_It, _Pj>> _Pr = ranges::less>
        [[nodiscard]] constexpr _It operator()(_It _First, _Se _Last, _Pr _Pred = {}, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            _Seek_wrapped(_First, ::std::ranges:: _Max_element_unchecked(_Unwrap_iter<_Se>(::std:: move(_First)),
                                      _Unwrap_sent<_It>(::std:: move(_Last)), _Pass_fn(_Pred), _Pass_fn(_Proj)));
            return _First;
        }

        template <forward_range _Rng, class _Pj = identity,
            indirect_strict_weak_order<projected<iterator_t<_Rng>, _Pj>> _Pr = ranges::less>
        [[nodiscard]] constexpr borrowed_iterator_t<_Rng> operator()(_Rng&& _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
            auto _First = ::std::ranges:: begin(_Range);
            _Seek_wrapped(_First, ::std::ranges:: _Max_element_unchecked(_Unwrap_range_iter<_Rng>(::std:: move(_First)),
                                      _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj)));
            return _First;
        }
    };

     inline constexpr _Max_element_fn max_element{_Not_quite_object::_Construct_tag {}};
} 
#line 6670 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
#line 6671 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

 template <class _Ty, class _Pr>
[[nodiscard]] constexpr _Ty(max)(initializer_list<_Ty> _Ilist, _Pr _Pred) {
    
    const _Ty* _Res = ::std:: _Max_element_unchecked(_Ilist.begin(), _Ilist.end(), _Pass_fn(_Pred));
    return *_Res;
}

 template <class _Ty>
[[nodiscard]] constexpr _Ty(max)(initializer_list<_Ty> _Ilist) {
    
    return (::std:: max)(_Ilist, less<>{});
}


namespace ranges {
    template <class _It>
    concept _Prefer_iterator_copies = 
                                      
        sizeof(_It) <= 2 * sizeof(iter_value_t<_It>)
        && (is_trivially_copyable_v<_It> || !is_trivially_copyable_v<iter_value_t<_It>>);

    class _Max_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <class _Ty, class _Pj = identity,
            indirect_strict_weak_order<projected<const _Ty*, _Pj>> _Pr = ranges::less>
        [[nodiscard]] constexpr const _Ty& operator()(
            const _Ty& _Left, const _Ty& _Right, _Pr _Pred = {}, _Pj _Proj = {}) const {
            if (::std:: invoke(_Pred, ::std:: invoke(_Proj, _Left), ::std:: invoke(_Proj, _Right))) {
                return _Right;
            } else {
                return _Left;
            }
        }

        template <copyable _Ty, class _Pj = identity,
            indirect_strict_weak_order<projected<const _Ty*, _Pj>> _Pr = ranges::less>
        [[nodiscard]] constexpr _Ty operator()(initializer_list<_Ty> _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
            const auto _First = _Range.begin();
            const auto _Last  = _Range.end();
            
;
            return *::std::ranges:: _Max_element_unchecked(_First, _Last, _Pass_fn(_Pred), _Pass_fn(_Proj));
        }

        template <input_range _Rng, class _Pj = identity,
            indirect_strict_weak_order<projected<iterator_t<_Rng>, _Pj>> _Pr = ranges::less>
            requires indirectly_copyable_storable<iterator_t<_Rng>, range_value_t<_Rng>*>
        [[nodiscard]] constexpr range_value_t<_Rng> operator()(_Rng&& _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
            auto _UFirst = _Ubegin(_Range);
            auto _ULast  = _Uend(_Range);
            
;
            if constexpr (forward_range<_Rng> && _Prefer_iterator_copies<iterator_t<_Rng>>) {
                return static_cast<range_value_t<_Rng>>(*::std::ranges:: _Max_element_unchecked(
                    ::std:: move(_UFirst), ::std:: move(_ULast), _Pass_fn(_Pred), _Pass_fn(_Proj)));
            } else {
                range_value_t<_Rng> _Found(*_UFirst);
                while (++_UFirst != _ULast) {
                    if (::std:: invoke(_Pred, ::std:: invoke(_Proj, _Found), ::std:: invoke(_Proj, *_UFirst))) {
                        _Found = *_UFirst;
                    }
                }

                return _Found;
            }
        }
    };

     inline constexpr _Max_fn max{_Not_quite_object::_Construct_tag {}};
} 
#line 6745 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

template <class _FwdIt, class _Pr>
constexpr _FwdIt _Min_element_unchecked(_FwdIt _First, _FwdIt _Last, _Pr _Pred) { 

    if constexpr (_Is_min_max_optimization_safe<_FwdIt, _Pr>) {
        if (!_Is_constant_evaluated()) {
            const auto _First_ptr = _To_address(_First);
            const auto _Result    = __std_min_element(_First_ptr, _To_address(_Last));
            if constexpr (is_pointer_v<_FwdIt>) {
                return _Result;
            } else {
                return _First + (_Result - _First_ptr);
            }
        }
    }
#line 6761 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

    _FwdIt _Found = _First;
    if (_First != _Last) {
        while (++_First != _Last) {
            if (static_cast<bool>(_Pred(*_First, *_Found)) ) {
                _Found = _First;
            }
        }
    }

    return _Found;
}

 template <class _FwdIt, class _Pr>
[[nodiscard]] constexpr _FwdIt min_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    _Seek_wrapped(_First, ::std:: _Min_element_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pass_fn(_Pred)));
    return _First;
}

 template <class _FwdIt>
[[nodiscard]] constexpr _FwdIt min_element(_FwdIt _First, _FwdIt _Last) { 
    return ::std:: min_element(_First, _Last, less<>{});
}


 template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] _FwdIt min_element(_ExPo&&, _FwdIt _First, _FwdIt _Last, _Pr _Pred) noexcept   {
    
    
    return ::std:: min_element(_First, _Last, _Pass_fn(_Pred));
}

 template <class _ExPo, class _FwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] _FwdIt min_element(_ExPo&&, _FwdIt _First, _FwdIt _Last) noexcept   {
    
    
    return ::std:: min_element(_First, _Last);
}


namespace ranges {
    template <class _It, class _Se, class _Pr, class _Pj>
    [[nodiscard]] constexpr _It _Min_element_unchecked(_It _First, const _Se _Last, _Pr _Pred, _Pj _Proj) {
         ;
         ;
         ;


        if constexpr (is_same_v<_Pj, identity> && _Is_min_max_optimization_safe<_It, _Pr>
                      && sized_sentinel_for<_Se, _It>) {
            if (!::std:: is_constant_evaluated()) {
                const auto _First_ptr = ::std:: to_address(_First);
                const auto _Last_ptr  = _First_ptr + (_Last - _First);
                const auto _Result    = __std_min_element(_First_ptr, _Last_ptr);
                if constexpr (is_pointer_v<_It>) {
                    return _Result;
                } else {
                    return _First + (_Result - _First_ptr);
                }
            }
        }
#line 6824 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

        auto _Found = _First;
        if (_First == _Last) {
            return _Found;
        }

        while (++_First != _Last) {
            if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_First), ::std:: invoke(_Proj, *_Found))) {
                _Found = _First;
            }
        }

        return _Found;
    }

    class _Min_element_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <forward_iterator _It, sentinel_for<_It> _Se, class _Pj = identity,
            indirect_strict_weak_order<projected<_It, _Pj>> _Pr = ranges::less>
        [[nodiscard]] constexpr _It operator()(_It _First, _Se _Last, _Pr _Pred = {}, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            _Seek_wrapped(_First, ::std::ranges:: _Min_element_unchecked(_Unwrap_iter<_Se>(::std:: move(_First)),
                                      _Unwrap_sent<_It>(::std:: move(_Last)), _Pass_fn(_Pred), _Pass_fn(_Proj)));
            return _First;
        }

        template <forward_range _Rng, class _Pj = identity,
            indirect_strict_weak_order<projected<iterator_t<_Rng>, _Pj>> _Pr = ranges::less>
        [[nodiscard]] constexpr borrowed_iterator_t<_Rng> operator()(_Rng&& _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
            auto _First = ::std::ranges:: begin(_Range);
            _Seek_wrapped(_First, ::std::ranges:: _Min_element_unchecked(_Unwrap_range_iter<_Rng>(::std:: move(_First)),
                                      _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj)));
            return _First;
        }
    };

     inline constexpr _Min_element_fn min_element{_Not_quite_object::_Construct_tag {}};
} 
#line 6865 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
#line 6866 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

 template <class _Ty, class _Pr>
[[nodiscard]] constexpr _Ty(min)(initializer_list<_Ty> _Ilist, _Pr _Pred) {
    
    const _Ty* _Res = ::std:: _Min_element_unchecked(_Ilist.begin(), _Ilist.end(), _Pass_fn(_Pred));
    return *_Res;
}

 template <class _Ty>
[[nodiscard]] constexpr _Ty(min)(initializer_list<_Ty> _Ilist) {
    
    return (::std:: min)(_Ilist, less<>{});
}


namespace ranges {
    class _Min_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <class _Ty, class _Pj = identity,
            indirect_strict_weak_order<projected<const _Ty*, _Pj>> _Pr = ranges::less>
        [[nodiscard]] constexpr const _Ty& operator()(
            const _Ty& _Left, const _Ty& _Right, _Pr _Pred = {}, _Pj _Proj = {}) const {
            if (::std:: invoke(_Pred, ::std:: invoke(_Proj, _Right), ::std:: invoke(_Proj, _Left))) {
                return _Right;
            } else {
                return _Left;
            }
        }

        template <copyable _Ty, class _Pj = identity,
            indirect_strict_weak_order<projected<const _Ty*, _Pj>> _Pr = ranges::less>
        [[nodiscard]] constexpr _Ty operator()(initializer_list<_Ty> _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
            const auto _First = _Range.begin();
            const auto _Last  = _Range.end();
            
;
            return *::std::ranges:: _Min_element_unchecked(_First, _Last, _Pass_fn(_Pred), _Pass_fn(_Proj));
        }

        template <input_range _Rng, class _Pj = identity,
            indirect_strict_weak_order<projected<iterator_t<_Rng>, _Pj>> _Pr = ranges::less>
            requires indirectly_copyable_storable<iterator_t<_Rng>, range_value_t<_Rng>*>
        [[nodiscard]] constexpr range_value_t<_Rng> operator()(_Rng&& _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
            auto _UFirst = _Ubegin(_Range);
            auto _ULast  = _Uend(_Range);
            
;
            if constexpr (forward_range<_Rng> && _Prefer_iterator_copies<iterator_t<_Rng>>) {
                return static_cast<range_value_t<_Rng>>(*::std::ranges:: _Min_element_unchecked(
                    ::std:: move(_UFirst), ::std:: move(_ULast), _Pass_fn(_Pred), _Pass_fn(_Proj)));
            } else {
                range_value_t<_Rng> _Found(*_UFirst);
                while (++_UFirst != _ULast) {
                    if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_UFirst), ::std:: invoke(_Proj, _Found))) {
                        _Found = *_UFirst;
                    }
                }

                return _Found;
            }
        }
    };

     inline constexpr _Min_fn min{_Not_quite_object::_Construct_tag {}};
} 
#line 6934 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

 template <class _FwdIt, class _Ty, class _Pr>
[[nodiscard]] constexpr _FwdIt lower_bound(_FwdIt _First, const _FwdIt _Last, const _Ty& _Val, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst                = _Get_unwrapped(_First);
    _Iter_diff_t<_FwdIt> _Count = ::std:: distance(_UFirst, _Get_unwrapped(_Last));

    while (0 < _Count) { 
        const _Iter_diff_t<_FwdIt> _Count2 = _Count / 2;
        const auto _UMid                   = ::std:: next(_UFirst, _Count2);
        if (_Pred(*_UMid, _Val)) { 
            _UFirst = _Next_iter(_UMid);
            _Count -= _Count2 + 1;
        } else {
            _Count = _Count2;
        }
    }

    _Seek_wrapped(_First, _UFirst);
    return _First;
}

 template <class _FwdIt, class _Ty>
[[nodiscard]] constexpr _FwdIt lower_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val) {
    
    return ::std:: lower_bound(_First, _Last, _Val, less<>{});
}

 template <class _FwdIt, class _Ty, class _Pr>
[[nodiscard]] constexpr _FwdIt upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst                = _Get_unwrapped(_First);
    _Iter_diff_t<_FwdIt> _Count = ::std:: distance(_UFirst, _Get_unwrapped(_Last));

    while (0 < _Count) { 
        _Iter_diff_t<_FwdIt> _Count2 = _Count / 2;
        const auto _UMid             = ::std:: next(_UFirst, _Count2);
        if (_Pred(_Val, *_UMid)) {
            _Count = _Count2;
        } else { 
            _UFirst = _Next_iter(_UMid);
            _Count -= _Count2 + 1;
        }
    }

    _Seek_wrapped(_First, _UFirst);
    return _First;
}

 template <class _FwdIt, class _Ty>
[[nodiscard]] constexpr _FwdIt upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val) {
    
    return ::std:: upper_bound(_First, _Last, _Val, less<>{});
}

template <class _FwdIt1, class _FwdIt2>
constexpr _FwdIt2 _Swap_ranges_unchecked(_FwdIt1 _First1, const _FwdIt1 _Last1, _FwdIt2 _First2) {
    


    using _Elem1 = remove_reference_t<_Iter_ref_t<_FwdIt1>>;
    using _Elem2 = remove_reference_t<_Iter_ref_t<_FwdIt2>>;
    if constexpr (is_same_v<_Elem1, _Elem2> && _Is_trivially_swappable_v<_Elem1>
                  && _Iterators_are_contiguous<_FwdIt1, _FwdIt2>) {

        if (!::std:: is_constant_evaluated())
#line 7003 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
        {
            __std_swap_ranges_trivially_swappable_noalias(
                _To_address(_First1), _To_address(_Last1), _To_address(_First2));
            return _First2 + (_Last1 - _First1);
        }
    }
#line 7010 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

    for (; _First1 != _Last1; ++_First1, (void) ++_First2) {
        ::std:: iter_swap(_First1, _First2);
    }

    return _First2;
}

extern "C++" [[noreturn]]  void __cdecl _Xbad_alloc();
extern "C++" [[noreturn]]  void __cdecl _Xinvalid_argument( const char*);
extern "C++" [[noreturn]]  void __cdecl _Xlength_error( const char*);
extern "C++" [[noreturn]]  void __cdecl _Xout_of_range( const char*);
extern "C++" [[noreturn]]  void __cdecl _Xoverflow_error( const char*);
extern "C++" [[noreturn]]  void __cdecl _Xruntime_error( const char*);
extern "C++" [[noreturn]]  void __cdecl _XGetLastError();

 template <class _Category, class _Ty, class _Diff = ptrdiff_t, class _Pointer = _Ty*,
    class _Reference = _Ty&>
struct [[deprecated( "warning STL4015: " "The std::iterator class template (used as a base class to provide typedefs) is deprecated in C++17. " "(The <iterator> header is NOT deprecated.) The C++ Standard has never required user-defined iterators to " "derive from std::iterator. To fix this warning, stop deriving from std::iterator and start providing " "publicly accessible typedefs named iterator_category, value_type, difference_type, pointer, and reference. " "Note that value_type is required to be non-const, even for constant iterators. " "You can define _SILENCE_CXX17_ITERATOR_BASE_CLASS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] iterator { 
    using iterator_category = _Category;
    using value_type        = _Ty;
    using difference_type   = _Diff;
    using pointer           = _Pointer;
    using reference         = _Reference;
};

template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
[[nodiscard]] constexpr auto _Float_abs_bits(const _Ty& _Xx) {
    using _Traits    = _Floating_type_traits<_Ty>;
    using _Uint_type = typename _Traits::_Uint_type;
    const auto _Bits = _Bit_cast<_Uint_type>(_Xx);
    return _Bits & ~_Traits::_Shifted_sign_mask;
}

template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
[[nodiscard]] constexpr _Ty _Float_abs(const _Ty _Xx) { 
    return _Bit_cast<_Ty>(_Float_abs_bits(_Xx));
}

template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
[[nodiscard]] constexpr _Ty _Float_copysign(const _Ty _Magnitude, const _Ty _Sign) { 
    using _Traits       = _Floating_type_traits<_Ty>;
    using _Uint_type    = typename _Traits::_Uint_type;
    const auto _Signbit = _Bit_cast<_Uint_type>(_Sign) & _Traits::_Shifted_sign_mask;
    return _Bit_cast<_Ty>(_Float_abs_bits(_Magnitude) | _Signbit);
}

template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
[[nodiscard]] constexpr bool _Is_nan(const _Ty _Xx) { 
    using _Traits = _Floating_type_traits<_Ty>;
    return _Float_abs_bits(_Xx) > _Traits::_Shifted_exponent_mask;
}





template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
[[nodiscard]] constexpr bool _Is_signaling_nan(const _Ty& _Xx) { 
    using _Traits        = _Floating_type_traits<_Ty>;
    const auto _Abs_bits = _Float_abs_bits(_Xx);
    return _Abs_bits > _Traits::_Shifted_exponent_mask && ((_Abs_bits & _Traits::_Special_nan_mantissa_mask) == 0);
}

template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
[[nodiscard]] constexpr bool _Is_inf(const _Ty _Xx) { 
    using _Traits = _Floating_type_traits<_Ty>;
    return _Float_abs_bits(_Xx) == _Traits::_Shifted_exponent_mask;
}

template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
[[nodiscard]] constexpr bool _Is_finite(const _Ty _Xx) { 
    using _Traits = _Floating_type_traits<_Ty>;
    return _Float_abs_bits(_Xx) < _Traits::_Shifted_exponent_mask;
}


 struct monostate {};
#line 7089 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"

}


#pragma warning(pop)
#pragma pack(pop)
#line 7096 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
#line 7097 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xutility"
#pragma external_header(pop)
#line 28 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"
#line 29 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"

#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




[[nodiscard]]  inline float acos( float _Xx) noexcept   {
    return :: acosf(_Xx);
}

[[nodiscard]]  inline float acosh( float _Xx) noexcept   {
    return :: acoshf(_Xx);
}

[[nodiscard]]  inline float asin( float _Xx) noexcept   {
    return :: asinf(_Xx);
}

[[nodiscard]]  inline float asinh( float _Xx) noexcept   {
    return :: asinhf(_Xx);
}

[[nodiscard]]  inline float atan( float _Xx) noexcept   {
    return :: atanf(_Xx);
}

[[nodiscard]]  inline float atanh( float _Xx) noexcept   {
    return :: atanhf(_Xx);
}

[[nodiscard]]  inline float atan2( float _Yx,  float _Xx) noexcept   {
    return :: atan2f(_Yx, _Xx);
}

[[nodiscard]]  inline float cbrt( float _Xx) noexcept   {
    return :: cbrtf(_Xx);
}

[[nodiscard]]  inline float ceil( float _Xx) noexcept   {

    return __ceilf(_Xx);




#line 77 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"
}

[[nodiscard]]  inline float copysign( float _Number,  float _Sign) noexcept   {

    return __copysignf(_Number, _Sign);




#line 87 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"
}

[[nodiscard]]  inline float cos( float _Xx) noexcept   {
    return :: cosf(_Xx);
}

[[nodiscard]]  inline float cosh( float _Xx) noexcept   {
    return :: coshf(_Xx);
}

[[nodiscard]]  inline float erf( float _Xx) noexcept   {
    return :: erff(_Xx);
}

[[nodiscard]]  inline float erfc( float _Xx) noexcept   {
    return :: erfcf(_Xx);
}

[[nodiscard]]  inline float exp( float _Xx) noexcept   {
    return :: expf(_Xx);
}

[[nodiscard]]  inline float exp2( float _Xx) noexcept   {
    return :: exp2f(_Xx);
}

[[nodiscard]]  inline float expm1( float _Xx) noexcept   {
    return :: expm1f(_Xx);
}

[[nodiscard]]  inline float fabs( float _Xx) noexcept   {
    return :: fabsf(_Xx);
}

[[nodiscard]]  inline float fdim( float _Xx,  float _Yx) noexcept   {
    return :: fdimf(_Xx, _Yx);
}

[[nodiscard]]  inline float floor( float _Xx) noexcept   {

    return __floorf(_Xx);




#line 133 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"
}

[[nodiscard]]  inline float fma( float _Xx,  float _Yx,  float _Zx) noexcept   {
    return :: fmaf(_Xx, _Yx, _Zx);
}

[[nodiscard]]  inline float fmax( float _Xx,  float _Yx) noexcept   {
    return :: fmaxf(_Xx, _Yx);
}

[[nodiscard]]  inline float fmin( float _Xx,  float _Yx) noexcept   {
    return :: fminf(_Xx, _Yx);
}

[[nodiscard]]  inline float fmod( float _Xx,  float _Yx) noexcept   {
    return :: fmodf(_Xx, _Yx);
}

inline float frexp( float _Xx,  int* _Yx) noexcept   {
    return :: frexpf(_Xx, _Yx);
}

[[nodiscard]]  inline float hypot( float _Xx,  float _Yx) noexcept   {
    return :: hypotf(_Xx, _Yx);
}

[[nodiscard]]  inline int ilogb( float _Xx) noexcept   {
    return :: ilogbf(_Xx);
}

[[nodiscard]]  inline float ldexp( float _Xx,  int _Yx) noexcept   {
    return :: ldexpf(_Xx, _Yx);
}

[[nodiscard]]  inline float lgamma( float _Xx) noexcept   {
    return :: lgammaf(_Xx);
}

[[nodiscard]]  inline long long llrint( float _Xx) noexcept   {
    return :: llrintf(_Xx);
}

[[nodiscard]]  inline long long llround( float _Xx) noexcept   {
    return :: llroundf(_Xx);
}

[[nodiscard]]  inline float log( float _Xx) noexcept   {
    return :: logf(_Xx);
}

[[nodiscard]]  inline float log10( float _Xx) noexcept   {
    return :: log10f(_Xx);
}

[[nodiscard]]  inline float log1p( float _Xx) noexcept   {
    return :: log1pf(_Xx);
}

[[nodiscard]]  inline float log2( float _Xx) noexcept   {
    return :: log2f(_Xx);
}

[[nodiscard]]  inline float logb( float _Xx) noexcept   {
    return :: logbf(_Xx);
}

[[nodiscard]]  inline long lrint( float _Xx) noexcept   {
    return :: lrintf(_Xx);
}

[[nodiscard]]  inline long lround( float _Xx) noexcept   {
    return :: lroundf(_Xx);
}

inline float modf( float _Xx,  float* _Yx) noexcept   {
    return :: modff(_Xx, _Yx);
}

[[nodiscard]]  inline float nearbyint( float _Xx) noexcept   {
    return :: nearbyintf(_Xx);
}

[[nodiscard]]  inline float nextafter( float _Xx,  float _Yx) noexcept   {
    return :: nextafterf(_Xx, _Yx);
}

[[nodiscard]]  inline float nexttoward( float _Xx,  long double _Yx) noexcept   {
    return :: nexttowardf(_Xx, _Yx);
}

[[nodiscard]]  inline float pow( float _Xx,  float _Yx) noexcept   {
    return :: powf(_Xx, _Yx);
}

[[nodiscard]]  inline float remainder( float _Xx,  float _Yx) noexcept   {
    return :: remainderf(_Xx, _Yx);
}

inline float remquo( float _Xx,  float _Yx,  int* _Zx) noexcept   {
    return :: remquof(_Xx, _Yx, _Zx);
}

[[nodiscard]]  inline float rint( float _Xx) noexcept   {
    return :: rintf(_Xx);
}

[[nodiscard]]  inline float round( float _Xx) noexcept   {

    return __roundf(_Xx);




#line 247 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"
}

[[nodiscard]]  inline float scalbln( float _Xx,  long _Yx) noexcept   {
    return :: scalblnf(_Xx, _Yx);
}

[[nodiscard]]  inline float scalbn( float _Xx,  int _Yx) noexcept   {
    return :: scalbnf(_Xx, _Yx);
}

[[nodiscard]]  inline float sin( float _Xx) noexcept   {
    return :: sinf(_Xx);
}

[[nodiscard]]  inline float sinh( float _Xx) noexcept   {
    return :: sinhf(_Xx);
}

[[nodiscard]]  inline float sqrt( float _Xx) noexcept   {
    return :: sqrtf(_Xx);
}

[[nodiscard]]  inline float tan( float _Xx) noexcept   {
    return :: tanf(_Xx);
}

[[nodiscard]]  inline float tanh( float _Xx) noexcept   {
    return :: tanhf(_Xx);
}

[[nodiscard]]  inline float tgamma( float _Xx) noexcept   {
    return :: tgammaf(_Xx);
}

[[nodiscard]]  inline float trunc( float _Xx) noexcept   {

    return __truncf(_Xx);




#line 289 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"
}

[[nodiscard]]  inline long double acos( long double _Xx) noexcept   {
    return :: acosl(_Xx);
}

[[nodiscard]]  inline long double acosh( long double _Xx) noexcept   {
    return :: acoshl(_Xx);
}

[[nodiscard]]  inline long double asin( long double _Xx) noexcept   {
    return :: asinl(_Xx);
}

[[nodiscard]]  inline long double asinh( long double _Xx) noexcept   {
    return :: asinhl(_Xx);
}

[[nodiscard]]  inline long double atan( long double _Xx) noexcept   {
    return :: atanl(_Xx);
}

[[nodiscard]]  inline long double atanh( long double _Xx) noexcept   {
    return :: atanhl(_Xx);
}

[[nodiscard]]  inline long double atan2( long double _Yx,  long double _Xx) noexcept
  {
    return :: atan2l(_Yx, _Xx);
}

[[nodiscard]]  inline long double cbrt( long double _Xx) noexcept   {
    return :: cbrtl(_Xx);
}

[[nodiscard]]  inline long double ceil( long double _Xx) noexcept   {

    return __ceil(static_cast<double>(_Xx));




#line 332 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"
}

[[nodiscard]]  inline long double copysign( long double _Number,  long double _Sign) noexcept
  {

    return __copysign(static_cast<double>(_Number), static_cast<double>(_Sign));




#line 343 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"
}

[[nodiscard]]  inline long double cos( long double _Xx) noexcept   {
    return :: cosl(_Xx);
}

[[nodiscard]]  inline long double cosh( long double _Xx) noexcept   {
    return :: coshl(_Xx);
}

[[nodiscard]]  inline long double erf( long double _Xx) noexcept   {
    return :: erfl(_Xx);
}

[[nodiscard]]  inline long double erfc( long double _Xx) noexcept   {
    return :: erfcl(_Xx);
}

[[nodiscard]]  inline long double exp( long double _Xx) noexcept   {
    return :: expl(_Xx);
}

[[nodiscard]]  inline long double exp2( long double _Xx) noexcept   {
    return :: exp2l(_Xx);
}

[[nodiscard]]  inline long double expm1( long double _Xx) noexcept   {
    return :: expm1l(_Xx);
}

[[nodiscard]]  inline long double fabs( long double _Xx) noexcept   {
    return :: fabsl(_Xx);
}

[[nodiscard]]  inline long double fdim( long double _Xx,  long double _Yx) noexcept
  {
    return :: fdiml(_Xx, _Yx);
}

[[nodiscard]]  inline long double floor( long double _Xx) noexcept   {

    return __floor(static_cast<double>(_Xx));




#line 390 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"
}

[[nodiscard]]  inline long double fma(
     long double _Xx,  long double _Yx,  long double _Zx) noexcept   {
    return :: fmal(_Xx, _Yx, _Zx);
}

[[nodiscard]]  inline long double fmax( long double _Xx,  long double _Yx) noexcept
  {
    return :: fmaxl(_Xx, _Yx);
}

[[nodiscard]]  inline long double fmin( long double _Xx,  long double _Yx) noexcept
  {
    return :: fminl(_Xx, _Yx);
}

[[nodiscard]]  inline long double fmod( long double _Xx,  long double _Yx) noexcept
  {
    return :: fmodl(_Xx, _Yx);
}

inline long double frexp( long double _Xx,  int* _Yx) noexcept   {
    return :: frexpl(_Xx, _Yx);
}

[[nodiscard]]  inline long double hypot( long double _Xx,  long double _Yx) noexcept
  {
    return :: hypotl(_Xx, _Yx);
}

[[nodiscard]]  inline int ilogb( long double _Xx) noexcept   {
    return :: ilogbl(_Xx);
}

[[nodiscard]]  inline long double ldexp( long double _Xx,  int _Yx) noexcept   {
    return :: ldexpl(_Xx, _Yx);
}

[[nodiscard]]  inline long double lgamma( long double _Xx) noexcept   {
    return :: lgammal(_Xx);
}

[[nodiscard]]  inline long long llrint( long double _Xx) noexcept   {
    return :: llrintl(_Xx);
}

[[nodiscard]]  inline long long llround( long double _Xx) noexcept   {
    return :: llroundl(_Xx);
}

[[nodiscard]]  inline long double log( long double _Xx) noexcept   {
    return :: logl(_Xx);
}

[[nodiscard]]  inline long double log10( long double _Xx) noexcept   {
    return :: log10l(_Xx);
}

[[nodiscard]]  inline long double log1p( long double _Xx) noexcept   {
    return :: log1pl(_Xx);
}

[[nodiscard]]  inline long double log2( long double _Xx) noexcept   {
    return :: log2l(_Xx);
}

[[nodiscard]]  inline long double logb( long double _Xx) noexcept   {
    return :: logbl(_Xx);
}

[[nodiscard]]  inline long lrint( long double _Xx) noexcept   {
    return :: lrintl(_Xx);
}

[[nodiscard]]  inline long lround( long double _Xx) noexcept   {
    return :: lroundl(_Xx);
}

inline long double modf( long double _Xx,  long double* _Yx) noexcept   {
    return :: modfl(_Xx, _Yx);
}

[[nodiscard]]  inline long double nearbyint( long double _Xx) noexcept   {
    return :: nearbyintl(_Xx);
}

[[nodiscard]]  inline long double nextafter( long double _Xx,  long double _Yx) noexcept
  {
    return :: nextafterl(_Xx, _Yx);
}

[[nodiscard]]  inline long double nexttoward( long double _Xx,  long double _Yx) noexcept
  {
    return :: nexttowardl(_Xx, _Yx);
}

[[nodiscard]]  inline long double pow( long double _Xx,  long double _Yx) noexcept
  {
    return :: powl(_Xx, _Yx);
}

[[nodiscard]]  inline long double remainder( long double _Xx,  long double _Yx) noexcept
  {
    return :: remainderl(_Xx, _Yx);
}

inline long double remquo( long double _Xx,  long double _Yx,  int* _Zx) noexcept   {
    return :: remquol(_Xx, _Yx, _Zx);
}

[[nodiscard]]  inline long double rint( long double _Xx) noexcept   {
    return :: rintl(_Xx);
}

[[nodiscard]]  inline long double round( long double _Xx) noexcept   {

    return __round(static_cast<double>(_Xx));




#line 513 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"
}

[[nodiscard]]  inline long double scalbln( long double _Xx,  long _Yx) noexcept   {
    return :: scalblnl(_Xx, _Yx);
}

[[nodiscard]]  inline long double scalbn( long double _Xx,  int _Yx) noexcept   {
    return :: scalbnl(_Xx, _Yx);
}

[[nodiscard]]  inline long double sin( long double _Xx) noexcept   {
    return :: sinl(_Xx);
}

[[nodiscard]]  inline long double sinh( long double _Xx) noexcept   {
    return :: sinhl(_Xx);
}

[[nodiscard]]  inline long double sqrt( long double _Xx) noexcept   {
    return :: sqrtl(_Xx);
}

[[nodiscard]]  inline long double tan( long double _Xx) noexcept   {
    return :: tanl(_Xx);
}

[[nodiscard]]  inline long double tanh( long double _Xx) noexcept   {
    return :: tanhl(_Xx);
}

[[nodiscard]]  inline long double tgamma( long double _Xx) noexcept   {
    return :: tgammal(_Xx);
}

[[nodiscard]]  inline long double trunc( long double _Xx) noexcept   {

    return __trunc(static_cast<double>(_Xx));




#line 555 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"
}


namespace std {
template <class _Ty1, class _Ty2>
using _Common_float_type_t = conditional_t<is_same_v<_Ty1, long double> || is_same_v<_Ty2, long double>, long double,
    conditional_t<is_same_v<_Ty1, float> && is_same_v<_Ty2, float>, float,
        double>>; 
}

template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0>
double frexp(_Ty _Value,  int* const _Exp) noexcept   {
    return :: frexp(static_cast<double>(_Value), _Exp);
}

template <class _Ty1, class _Ty2, class _Ty3,
    ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2> && ::std:: is_arithmetic_v<_Ty3>, int> = 0>
[[nodiscard]] ::std:: _Common_float_type_t<_Ty1, ::std:: _Common_float_type_t<_Ty2, _Ty3>> fma(
    _Ty1 _Left, _Ty2 _Middle, _Ty3 _Right) noexcept   {
    using _Common = ::std:: _Common_float_type_t<_Ty1, ::std:: _Common_float_type_t<_Ty2, _Ty3>>;
    if constexpr (::std:: is_same_v<_Common, float>) {
        return :: fmaf(static_cast<_Common>(_Left), static_cast<_Common>(_Middle), static_cast<_Common>(_Right));
    } else if constexpr (::std:: is_same_v<_Common, double>) {
        return :: fma(static_cast<_Common>(_Left), static_cast<_Common>(_Middle), static_cast<_Common>(_Right));
    } else {
        return :: fmal(static_cast<_Common>(_Left), static_cast<_Common>(_Middle), static_cast<_Common>(_Right));
    }
}

template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0>
::std:: _Common_float_type_t<_Ty1, _Ty2> remquo(_Ty1 _Left, _Ty2 _Right, int* _Pquo) noexcept   {
    using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>;
    if constexpr (::std:: is_same_v<_Common, float>) {
        return :: remquof(static_cast<_Common>(_Left), static_cast<_Common>(_Right), _Pquo);
    } else if constexpr (::std:: is_same_v<_Common, double>) {
        return :: remquo(static_cast<_Common>(_Left), static_cast<_Common>(_Right), _Pquo);
    } else {
        return :: remquol(static_cast<_Common>(_Left), static_cast<_Common>(_Right), _Pquo);
    }
}
















#line 612 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"




























#line 641 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"


template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double acos(_Ty _Left) noexcept { return :: acos(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double asin(_Ty _Left) noexcept { return :: asin(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double atan(_Ty _Left) noexcept { return :: atan(static_cast<double>(_Left)); }
template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> atan2(_Ty1 _Left, _Ty2 _Right) noexcept { return :: atan2(static_cast<double>(_Left), static_cast<double>(_Right)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double cos(_Ty _Left) noexcept { return :: cos(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double sin(_Ty _Left) noexcept { return :: sin(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double tan(_Ty _Left) noexcept { return :: tan(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double acosh(_Ty _Left) noexcept { return :: acosh(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double asinh(_Ty _Left) noexcept { return :: asinh(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double atanh(_Ty _Left) noexcept { return :: atanh(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double cosh(_Ty _Left) noexcept { return :: cosh(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double sinh(_Ty _Left) noexcept { return :: sinh(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double tanh(_Ty _Left) noexcept { return :: tanh(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double exp(_Ty _Left) noexcept { return :: exp(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double exp2(_Ty _Left) noexcept { return :: exp2(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double expm1(_Ty _Left) noexcept { return :: expm1(static_cast<double>(_Left)); }

template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] int ilogb(_Ty _Left) noexcept { return :: ilogb(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double ldexp(_Ty _Left, int _Arg2) noexcept { return :: ldexp(static_cast<double>(_Left), _Arg2); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double log(_Ty _Left) noexcept { return :: log(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double log10(_Ty _Left) noexcept { return :: log10(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double log1p(_Ty _Left) noexcept { return :: log1p(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double log2(_Ty _Left) noexcept { return :: log2(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double logb(_Ty _Left) noexcept { return :: logb(static_cast<double>(_Left)); }

template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double scalbn(_Ty _Left, int _Arg2) noexcept { return :: scalbn(static_cast<double>(_Left), _Arg2); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double scalbln(_Ty _Left, long _Arg2) noexcept { return :: scalbln(static_cast<double>(_Left), _Arg2); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double cbrt(_Ty _Left) noexcept { return :: cbrt(static_cast<double>(_Left)); }

template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double fabs(_Ty _Left) noexcept { return :: fabs(static_cast<double>(_Left)); }
template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> hypot(_Ty1 _Left, _Ty2 _Right) noexcept { return :: hypot(static_cast<double>(_Left), static_cast<double>(_Right)); }

template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> pow(_Ty1 _Left, _Ty2 _Right) noexcept { return :: pow(static_cast<double>(_Left), static_cast<double>(_Right)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double sqrt(_Ty _Left) noexcept { return :: sqrt(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double erf(_Ty _Left) noexcept { return :: erf(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double erfc(_Ty _Left) noexcept { return :: erfc(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double lgamma(_Ty _Left) noexcept { return :: lgamma(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double tgamma(_Ty _Left) noexcept { return :: tgamma(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double ceil(_Ty _Left) noexcept { return __ceil(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double floor(_Ty _Left) noexcept { return __floor(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double nearbyint(_Ty _Left) noexcept { return :: nearbyint(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double rint(_Ty _Left) noexcept { return :: rint(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] long lrint(_Ty _Left) noexcept { return :: lrint(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] long long llrint(_Ty _Left) noexcept { return :: llrint(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double round(_Ty _Left) noexcept { return __round(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] long lround(_Ty _Left) noexcept { return :: lround(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] long long llround(_Ty _Left) noexcept { return :: llround(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double trunc(_Ty _Left) noexcept { return __trunc(static_cast<double>(_Left)); }
template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> fmod(_Ty1 _Left, _Ty2 _Right) noexcept { return :: fmod(static_cast<double>(_Left), static_cast<double>(_Right)); }
template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> remainder(_Ty1 _Left, _Ty2 _Right) noexcept { return :: remainder(static_cast<double>(_Left), static_cast<double>(_Right)); }

template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> copysign(_Ty1 _Left, _Ty2 _Right) noexcept { return __copysign(static_cast<double>(_Left), static_cast<double>(_Right)); }

template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> nextafter(_Ty1 _Left, _Ty2 _Right) noexcept { return :: nextafter(static_cast<double>(_Left), static_cast<double>(_Right)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double nexttoward(_Ty _Left, long double _Arg2) noexcept { return :: nexttoward(static_cast<double>(_Left), _Arg2); }
template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> fdim(_Ty1 _Left, _Ty2 _Right) noexcept { return :: fdim(static_cast<double>(_Left), static_cast<double>(_Right)); }
template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> fmax(_Ty1 _Left, _Ty2 _Right) noexcept { return :: fmax(static_cast<double>(_Left), static_cast<double>(_Right)); }
template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> fmin(_Ty1 _Left, _Ty2 _Right) noexcept { return :: fmin(static_cast<double>(_Left), static_cast<double>(_Right)); }















namespace std {
 using :: abs;
 using :: acos;
 using :: asin;
 using :: atan;
 using :: atan2;
 using :: ceil;
 using :: cos;
 using :: cosh;
 using :: exp;
 using :: fabs;
 using :: floor;
 using :: fmod;
 using :: frexp;
 using :: ldexp;
 using :: log;
 using :: log10;
 using :: modf;
 using :: pow;
 using :: sin;
 using :: sinh;
 using :: sqrt;
 using :: tan;
 using :: tanh;

 using :: acosf;
 using :: asinf;
 using :: atanf;
 using :: atan2f;
 using :: ceilf;
 using :: cosf;
 using :: coshf;
 using :: expf;
 using :: fabsf;
 using :: floorf;
 using :: fmodf;
 using :: frexpf;
 using :: ldexpf;
 using :: logf;
 using :: log10f;
 using :: modff;
 using :: powf;
 using :: sinf;
 using :: sinhf;
 using :: sqrtf;
 using :: tanf;
 using :: tanhf;

 using :: acosl;
 using :: asinl;
 using :: atanl;
 using :: atan2l;
 using :: ceill;
 using :: cosl;
 using :: coshl;
 using :: expl;
 using :: fabsl;
 using :: floorl;
 using :: fmodl;
 using :: frexpl;
 using :: ldexpl;
 using :: logl;
 using :: log10l;
 using :: modfl;
 using :: powl;
 using :: sinl;
 using :: sinhl;
 using :: sqrtl;
 using :: tanl;
 using :: tanhl;

 using :: float_t;
 using :: double_t;

 using :: acosh;
 using :: asinh;
 using :: atanh;
 using :: cbrt;
 using :: erf;
 using :: erfc;
 using :: expm1;
 using :: exp2;

inline namespace _Binary_hypot {
     using :: hypot;
} 

 using :: ilogb;
 using :: lgamma;
 using :: log1p;
 using :: log2;
 using :: logb;
 using :: llrint;
 using :: lrint;
 using :: nearbyint;
 using :: rint;
 using :: llround;
 using :: lround;
 using :: fdim;
 using :: fma;
 using :: fmax;
 using :: fmin;
 using :: round;
 using :: trunc;
 using :: remainder;
 using :: remquo;
 using :: copysign;
 using :: nan;
 using :: nextafter;
 using :: scalbn;
 using :: scalbln;
 using :: nexttoward;
 using :: tgamma;

 using :: acoshf;
 using :: asinhf;
 using :: atanhf;
 using :: cbrtf;
 using :: erff;
 using :: erfcf;
 using :: expm1f;
 using :: exp2f;
 using :: hypotf;
 using :: ilogbf;
 using :: lgammaf;
 using :: log1pf;
 using :: log2f;
 using :: logbf;
 using :: llrintf;
 using :: lrintf;
 using :: nearbyintf;
 using :: rintf;
 using :: llroundf;
 using :: lroundf;
 using :: fdimf;
 using :: fmaf;
 using :: fmaxf;
 using :: fminf;
 using :: roundf;
 using :: truncf;
 using :: remainderf;
 using :: remquof;
 using :: copysignf;
 using :: nanf;
 using :: nextafterf;
 using :: scalbnf;
 using :: scalblnf;
 using :: nexttowardf;
 using :: tgammaf;

 using :: acoshl;
 using :: asinhl;
 using :: atanhl;
 using :: cbrtl;
 using :: erfl;
 using :: erfcl;
 using :: expm1l;
 using :: exp2l;
 using :: hypotl;
 using :: ilogbl;
 using :: lgammal;
 using :: log1pl;
 using :: log2l;
 using :: logbl;
 using :: llrintl;
 using :: lrintl;
 using :: nearbyintl;
 using :: rintl;
 using :: llroundl;
 using :: lroundl;
 using :: fdiml;
 using :: fmal;
 using :: fmaxl;
 using :: fminl;
 using :: roundl;
 using :: truncl;
 using :: remainderl;
 using :: remquol;
 using :: copysignl;
 using :: nanl;
 using :: nextafterl;
 using :: scalbnl;
 using :: scalblnl;
 using :: nexttowardl;
 using :: tgammal;

 using :: fpclassify;
 using :: signbit;
 using :: isfinite;
 using :: isinf;
 using :: isnan;
 using :: isnormal;
 using :: isgreater;
 using :: isgreaterequal;
 using :: isless;
 using :: islessequal;
 using :: islessgreater;
 using :: isunordered;
}


extern "C" {
[[nodiscard]]  double __stdcall __std_smf_assoc_laguerre(unsigned int, unsigned int, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_assoc_laguerref(unsigned int, unsigned int, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_assoc_legendre(unsigned int, unsigned int, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_assoc_legendref(unsigned int, unsigned int, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_beta(double, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_betaf(float, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_comp_ellint_1(double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_comp_ellint_1f(float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_comp_ellint_2(double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_comp_ellint_2f(float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_comp_ellint_3(double, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_comp_ellint_3f(float, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_cyl_bessel_i(double, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_cyl_bessel_if(float, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_cyl_bessel_j(double, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_cyl_bessel_jf(float, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_cyl_bessel_k(double, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_cyl_bessel_kf(float, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_cyl_neumann(double, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_cyl_neumannf(float, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_ellint_1(double, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_ellint_1f(float, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_ellint_2(double, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_ellint_2f(float, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_ellint_3(double, double, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_ellint_3f(float, float, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_expint(double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_expintf(float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_hermite(unsigned int, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_hermitef(unsigned int, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_laguerre(unsigned int, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_laguerref(unsigned int, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_legendre(unsigned int, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_legendref(unsigned int, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_riemann_zeta(double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_riemann_zetaf(float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_sph_bessel(unsigned int, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_sph_besself(unsigned int, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_sph_legendre(unsigned int, unsigned int, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_sph_legendref(unsigned int, unsigned int, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_sph_neumann(unsigned int, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_sph_neumannf(unsigned int, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_hypot3(double, double, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_hypot3f(float, float, float) noexcept;
}

namespace std {
 [[nodiscard]] inline double assoc_laguerre(
    const unsigned int _Degree, const unsigned int _Order, const double _Value) noexcept   {
    return __std_smf_assoc_laguerre(_Degree, _Order, _Value);
}

 [[nodiscard]] inline float assoc_laguerref(
    const unsigned int _Degree, const unsigned int _Order, const float _Value) noexcept   {
    return __std_smf_assoc_laguerref(_Degree, _Order, _Value);
}

 [[nodiscard]] inline long double assoc_laguerrel(
    const unsigned int _Degree, const unsigned int _Order, const long double _Value) noexcept   {
    return __std_smf_assoc_laguerre(_Degree, _Order, static_cast<double>(_Value));
}

 [[nodiscard]] inline double assoc_legendre(
    const unsigned int _Degree, const unsigned int _Order, const double _Value) noexcept   {
    return __std_smf_assoc_legendre(_Degree, _Order, _Value);
}

 [[nodiscard]] inline float assoc_legendref(
    const unsigned int _Degree, const unsigned int _Order, const float _Value) noexcept   {
    return __std_smf_assoc_legendref(_Degree, _Order, _Value);
}

 [[nodiscard]] inline long double assoc_legendrel(
    const unsigned int _Degree, const unsigned int _Order, const long double _Value) noexcept   {
    return __std_smf_assoc_legendre(_Degree, _Order, static_cast<double>(_Value));
}

 [[nodiscard]] inline double beta(const double _Arg1, const double _Arg2) noexcept   {
    return __std_smf_beta(_Arg1, _Arg2);
}

 [[nodiscard]] inline float betaf(const float _Arg1, const float _Arg2) noexcept   {
    return __std_smf_betaf(_Arg1, _Arg2);
}

 [[nodiscard]] inline long double betal(const long double _Arg1, const long double _Arg2) noexcept
  {
    return __std_smf_beta(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}

 [[nodiscard]] inline double comp_ellint_1(const double _Arg) noexcept   {
    return __std_smf_comp_ellint_1(_Arg);
}

 [[nodiscard]] inline float comp_ellint_1f(const float _Arg) noexcept   {
    return __std_smf_comp_ellint_1f(_Arg);
}

 [[nodiscard]] inline long double comp_ellint_1l(const long double _Arg) noexcept   {
    return __std_smf_comp_ellint_1(static_cast<double>(_Arg));
}

 [[nodiscard]] inline double comp_ellint_2(const double _Arg) noexcept   {
    return __std_smf_comp_ellint_2(_Arg);
}

 [[nodiscard]] inline float comp_ellint_2f(const float _Arg) noexcept   {
    return __std_smf_comp_ellint_2f(_Arg);
}

 [[nodiscard]] inline long double comp_ellint_2l(const long double _Arg) noexcept   {
    return __std_smf_comp_ellint_2(static_cast<double>(_Arg));
}

 [[nodiscard]] inline double comp_ellint_3(const double _Arg1, const double _Arg2) noexcept   {
    return __std_smf_comp_ellint_3(_Arg1, _Arg2);
}

 [[nodiscard]] inline float comp_ellint_3f(const float _Arg1, const float _Arg2) noexcept   {
    return __std_smf_comp_ellint_3f(_Arg1, _Arg2);
}

 [[nodiscard]] inline long double comp_ellint_3l(const long double _Arg1, const long double _Arg2) noexcept
  {
    return __std_smf_comp_ellint_3(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}

 [[nodiscard]] inline double cyl_bessel_i(const double _Arg1, const double _Arg2) noexcept   {
    return __std_smf_cyl_bessel_i(_Arg1, _Arg2);
}

 [[nodiscard]] inline float cyl_bessel_if(const float _Arg1, const float _Arg2) noexcept   {
    return __std_smf_cyl_bessel_if(_Arg1, _Arg2);
}

 [[nodiscard]] inline long double cyl_bessel_il(const long double _Arg1, const long double _Arg2) noexcept
  {
    return __std_smf_cyl_bessel_i(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}

 [[nodiscard]] inline double cyl_bessel_j(const double _Arg1, const double _Arg2) noexcept   {
    return __std_smf_cyl_bessel_j(_Arg1, _Arg2);
}

 [[nodiscard]] inline float cyl_bessel_jf(const float _Arg1, const float _Arg2) noexcept   {
    return __std_smf_cyl_bessel_jf(_Arg1, _Arg2);
}

 [[nodiscard]] inline long double cyl_bessel_jl(const long double _Arg1, const long double _Arg2) noexcept
  {
    return __std_smf_cyl_bessel_j(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}

 [[nodiscard]] inline double cyl_bessel_k(const double _Arg1, const double _Arg2) noexcept   {
    return __std_smf_cyl_bessel_k(_Arg1, _Arg2);
}

 [[nodiscard]] inline float cyl_bessel_kf(const float _Arg1, const float _Arg2) noexcept   {
    return __std_smf_cyl_bessel_kf(_Arg1, _Arg2);
}

 [[nodiscard]] inline long double cyl_bessel_kl(const long double _Arg1, const long double _Arg2) noexcept
  {
    return __std_smf_cyl_bessel_k(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}

 [[nodiscard]] inline double cyl_neumann(const double _Arg1, const double _Arg2) noexcept   {
    return __std_smf_cyl_neumann(_Arg1, _Arg2);
}

 [[nodiscard]] inline float cyl_neumannf(const float _Arg1, const float _Arg2) noexcept   {
    return __std_smf_cyl_neumannf(_Arg1, _Arg2);
}

 [[nodiscard]] inline long double cyl_neumannl(const long double _Arg1, const long double _Arg2) noexcept
  {
    return __std_smf_cyl_neumann(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}

 [[nodiscard]] inline double ellint_1(const double _Arg1, const double _Arg2) noexcept   {
    return __std_smf_ellint_1(_Arg1, _Arg2);
}

 [[nodiscard]] inline float ellint_1f(const float _Arg1, const float _Arg2) noexcept   {
    return __std_smf_ellint_1f(_Arg1, _Arg2);
}

 [[nodiscard]] inline long double ellint_1l(const long double _Arg1, const long double _Arg2) noexcept
  {
    return __std_smf_ellint_1(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}

 [[nodiscard]] inline double ellint_2(const double _Arg1, const double _Arg2) noexcept   {
    return __std_smf_ellint_2(_Arg1, _Arg2);
}

 [[nodiscard]] inline float ellint_2f(const float _Arg1, const float _Arg2) noexcept   {
    return __std_smf_ellint_2f(_Arg1, _Arg2);
}

 [[nodiscard]] inline long double ellint_2l(const long double _Arg1, const long double _Arg2) noexcept
  {
    return __std_smf_ellint_2(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}

 [[nodiscard]] inline double ellint_3(const double _Arg1, const double _Arg2, const double _Arg3) noexcept
  {
    return __std_smf_ellint_3(_Arg1, _Arg2, _Arg3);
}

 [[nodiscard]] inline float ellint_3f(const float _Arg1, const float _Arg2, const float _Arg3) noexcept
  {
    return __std_smf_ellint_3f(_Arg1, _Arg2, _Arg3);
}

 [[nodiscard]] inline long double ellint_3l(
    const long double _Arg1, const long double _Arg2, const long double _Arg3) noexcept   {
    return __std_smf_ellint_3(static_cast<double>(_Arg1), static_cast<double>(_Arg2), static_cast<double>(_Arg3));
}

 [[nodiscard]] inline double expint(const double _Arg) noexcept   {
    return __std_smf_expint(_Arg);
}

 [[nodiscard]] inline float expintf(const float _Arg) noexcept   {
    return __std_smf_expintf(_Arg);
}

 [[nodiscard]] inline long double expintl(const long double _Arg) noexcept   {
    return __std_smf_expint(static_cast<double>(_Arg));
}

 [[nodiscard]] inline double hermite(const unsigned int _Arg1, const double _Arg2) noexcept   {
    return __std_smf_hermite(_Arg1, _Arg2);
}

 [[nodiscard]] inline float hermitef(const unsigned int _Arg1, const float _Arg2) noexcept   {
    return __std_smf_hermitef(_Arg1, _Arg2);
}

 [[nodiscard]] inline long double hermitel(const unsigned int _Arg1, const long double _Arg2) noexcept
  {
    return __std_smf_hermite(_Arg1, static_cast<double>(_Arg2));
}

 [[nodiscard]] inline double laguerre(const unsigned int _Arg1, const double _Arg2) noexcept
  {
    return __std_smf_laguerre(_Arg1, _Arg2);
}

 [[nodiscard]] inline float laguerref(const unsigned int _Arg1, const float _Arg2) noexcept   {
    return __std_smf_laguerref(_Arg1, _Arg2);
}

 [[nodiscard]] inline long double laguerrel(const unsigned int _Arg1, const long double _Arg2) noexcept
  {
    return __std_smf_laguerre(_Arg1, static_cast<double>(_Arg2));
}

 [[nodiscard]] inline double legendre(const unsigned int _Degree, const double _Value) noexcept
  {
    return __std_smf_legendre(_Degree, _Value);
}

 [[nodiscard]] inline float legendref(const unsigned int _Degree, const float _Value) noexcept
  {
    return __std_smf_legendref(_Degree, _Value);
}

 [[nodiscard]] inline long double legendrel(const unsigned int _Degree, const long double _Value) noexcept
  {
    return __std_smf_legendre(_Degree, static_cast<double>(_Value));
}

 [[nodiscard]] inline double riemann_zeta(const double _Arg) noexcept   {
    return __std_smf_riemann_zeta(_Arg);
}
 [[nodiscard]] inline float riemann_zetaf(const float _Arg) noexcept   {
    return __std_smf_riemann_zetaf(_Arg);
}

 [[nodiscard]] inline long double riemann_zetal(const long double _Arg) noexcept   {
    return __std_smf_riemann_zeta(static_cast<double>(_Arg));
}

 [[nodiscard]] inline double sph_bessel(const unsigned int _Arg1, const double _Arg2) noexcept
  {
    return __std_smf_sph_bessel(_Arg1, _Arg2);
}

 [[nodiscard]] inline float sph_besself(const unsigned int _Arg1, const float _Arg2) noexcept
  {
    return __std_smf_sph_besself(_Arg1, _Arg2);
}

 [[nodiscard]] inline long double sph_bessell(const unsigned int _Arg1, const long double _Arg2) noexcept
  {
    return __std_smf_sph_bessel(_Arg1, static_cast<double>(_Arg2));
}

 [[nodiscard]] inline double sph_legendre(
    const unsigned int _Arg1, const unsigned int _Arg2, const double _Theta) noexcept
  {
    return __std_smf_sph_legendre(_Arg1, _Arg2, _Theta);
}

 [[nodiscard]] inline float sph_legendref(
    const unsigned int _Arg1, const unsigned int _Arg2, const float _Theta) noexcept
  {
    return __std_smf_sph_legendref(_Arg1, _Arg2, _Theta);
}

 [[nodiscard]] inline long double sph_legendrel(
    const unsigned int _Arg1, const unsigned int _Arg2, const long double _Theta) noexcept   {
    return __std_smf_sph_legendre(_Arg1, _Arg2, static_cast<double>(_Theta));
}

 [[nodiscard]] inline double sph_neumann(const unsigned int _Arg1, const double _Arg2) noexcept
  {
    return __std_smf_sph_neumann(_Arg1, _Arg2);
}

 [[nodiscard]] inline float sph_neumannf(const unsigned int _Arg1, const float _Arg2) noexcept
  {
    return __std_smf_sph_neumannf(_Arg1, _Arg2);
}

 [[nodiscard]] inline long double sph_neumannl(const unsigned int _Arg1, const long double _Arg2) noexcept
  {
    return __std_smf_sph_neumann(_Arg1, static_cast<double>(_Arg2));
}





























































template <class _Ty, enable_if_t<is_arithmetic_v<_Ty>, int> = 0> [[nodiscard]] auto assoc_laguerre( const unsigned int _Arg1, const unsigned int _Arg2, const _Ty _Arg3) noexcept { using _Common = conditional_t<is_integral_v<_Ty>, double, _Ty>; if constexpr (is_same_v<_Common, float>) { return __std_smf_assoc_laguerref(_Arg1, _Arg2, _Arg3); } else { return static_cast<_Common>(__std_smf_assoc_laguerre(_Arg1, _Arg2, static_cast<double>(_Arg3))); } }
template <class _Ty, enable_if_t<is_arithmetic_v<_Ty>, int> = 0> [[nodiscard]] auto assoc_legendre( const unsigned int _Arg1, const unsigned int _Arg2, const _Ty _Arg3) noexcept { using _Common = conditional_t<is_integral_v<_Ty>, double, _Ty>; if constexpr (is_same_v<_Common, float>) { return __std_smf_assoc_legendref(_Arg1, _Arg2, _Arg3); } else { return static_cast<_Common>(__std_smf_assoc_legendre(_Arg1, _Arg2, static_cast<double>(_Arg3))); } }
template <class _Ty1, class _Ty2, enable_if_t<is_arithmetic_v<_Ty1> && is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] auto beta(const _Ty1 _Arg1, const _Ty2 _Arg2) noexcept { using _Common = _Common_float_type_t<_Ty1, _Ty2>; if constexpr (is_same_v<_Common, float>) { return __std_smf_betaf(_Arg1, _Arg2); } else { return static_cast<_Common>(__std_smf_beta(static_cast<double>(_Arg1), static_cast<double>(_Arg2))); } }
template <class _Ty, enable_if_t<is_arithmetic_v<_Ty>, int> = 0> [[nodiscard]] auto comp_ellint_1(const _Ty _Arg) noexcept { using _Common = conditional_t<is_integral_v<_Ty>, double, _Ty>; if constexpr (is_same_v<_Common, float>) { return __std_smf_comp_ellint_1f(_Arg); } else { return static_cast<_Common>(__std_smf_comp_ellint_1(static_cast<double>(_Arg))); } }
template <class _Ty, enable_if_t<is_arithmetic_v<_Ty>, int> = 0> [[nodiscard]] auto comp_ellint_2(const _Ty _Arg) noexcept { using _Common = conditional_t<is_integral_v<_Ty>, double, _Ty>; if constexpr (is_same_v<_Common, float>) { return __std_smf_comp_ellint_2f(_Arg); } else { return static_cast<_Common>(__std_smf_comp_ellint_2(static_cast<double>(_Arg))); } }
template <class _Ty1, class _Ty2, enable_if_t<is_arithmetic_v<_Ty1> && is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] auto comp_ellint_3(const _Ty1 _Arg1, const _Ty2 _Arg2) noexcept { using _Common = _Common_float_type_t<_Ty1, _Ty2>; if constexpr (is_same_v<_Common, float>) { return __std_smf_comp_ellint_3f(_Arg1, _Arg2); } else { return static_cast<_Common>(__std_smf_comp_ellint_3(static_cast<double>(_Arg1), static_cast<double>(_Arg2))); } }
template <class _Ty1, class _Ty2, enable_if_t<is_arithmetic_v<_Ty1> && is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] auto cyl_bessel_i(const _Ty1 _Arg1, const _Ty2 _Arg2) noexcept { using _Common = _Common_float_type_t<_Ty1, _Ty2>; if constexpr (is_same_v<_Common, float>) { return __std_smf_cyl_bessel_if(_Arg1, _Arg2); } else { return static_cast<_Common>(__std_smf_cyl_bessel_i(static_cast<double>(_Arg1), static_cast<double>(_Arg2))); } }
template <class _Ty1, class _Ty2, enable_if_t<is_arithmetic_v<_Ty1> && is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] auto cyl_bessel_j(const _Ty1 _Arg1, const _Ty2 _Arg2) noexcept { using _Common = _Common_float_type_t<_Ty1, _Ty2>; if constexpr (is_same_v<_Common, float>) { return __std_smf_cyl_bessel_jf(_Arg1, _Arg2); } else { return static_cast<_Common>(__std_smf_cyl_bessel_j(static_cast<double>(_Arg1), static_cast<double>(_Arg2))); } }
template <class _Ty1, class _Ty2, enable_if_t<is_arithmetic_v<_Ty1> && is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] auto cyl_bessel_k(const _Ty1 _Arg1, const _Ty2 _Arg2) noexcept { using _Common = _Common_float_type_t<_Ty1, _Ty2>; if constexpr (is_same_v<_Common, float>) { return __std_smf_cyl_bessel_kf(_Arg1, _Arg2); } else { return static_cast<_Common>(__std_smf_cyl_bessel_k(static_cast<double>(_Arg1), static_cast<double>(_Arg2))); } }
template <class _Ty1, class _Ty2, enable_if_t<is_arithmetic_v<_Ty1> && is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] auto cyl_neumann(const _Ty1 _Arg1, const _Ty2 _Arg2) noexcept { using _Common = _Common_float_type_t<_Ty1, _Ty2>; if constexpr (is_same_v<_Common, float>) { return __std_smf_cyl_neumannf(_Arg1, _Arg2); } else { return static_cast<_Common>(__std_smf_cyl_neumann(static_cast<double>(_Arg1), static_cast<double>(_Arg2))); } }
template <class _Ty1, class _Ty2, enable_if_t<is_arithmetic_v<_Ty1> && is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] auto ellint_1(const _Ty1 _Arg1, const _Ty2 _Arg2) noexcept { using _Common = _Common_float_type_t<_Ty1, _Ty2>; if constexpr (is_same_v<_Common, float>) { return __std_smf_ellint_1f(_Arg1, _Arg2); } else { return static_cast<_Common>(__std_smf_ellint_1(static_cast<double>(_Arg1), static_cast<double>(_Arg2))); } }
template <class _Ty1, class _Ty2, enable_if_t<is_arithmetic_v<_Ty1> && is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] auto ellint_2(const _Ty1 _Arg1, const _Ty2 _Arg2) noexcept { using _Common = _Common_float_type_t<_Ty1, _Ty2>; if constexpr (is_same_v<_Common, float>) { return __std_smf_ellint_2f(_Arg1, _Arg2); } else { return static_cast<_Common>(__std_smf_ellint_2(static_cast<double>(_Arg1), static_cast<double>(_Arg2))); } }
template <class _Ty1, class _Ty2, class _Ty3, enable_if_t<is_arithmetic_v<_Ty1> && is_arithmetic_v<_Ty2> && is_arithmetic_v<_Ty3>, int> = 0> [[nodiscard]] auto ellint_3(const _Ty1 _Arg1, const _Ty2 _Arg2, const _Ty3 _Arg3) noexcept { using _Common = _Common_float_type_t<_Ty1, _Common_float_type_t<_Ty2, _Ty3>>; if constexpr (is_same_v<_Common, float>) { return __std_smf_ellint_3f(_Arg1, _Arg2, _Arg3); } else { return static_cast<_Common>( __std_smf_ellint_3(static_cast<double>(_Arg1), static_cast<double>(_Arg2), static_cast<double>(_Arg3))); } }
template <class _Ty, enable_if_t<is_arithmetic_v<_Ty>, int> = 0> [[nodiscard]] auto expint(const _Ty _Arg) noexcept { using _Common = conditional_t<is_integral_v<_Ty>, double, _Ty>; if constexpr (is_same_v<_Common, float>) { return __std_smf_expintf(_Arg); } else { return static_cast<_Common>(__std_smf_expint(static_cast<double>(_Arg))); } }
template <class _Ty, enable_if_t<is_arithmetic_v<_Ty>, int> = 0> [[nodiscard]] auto hermite(const unsigned int _Arg1, const _Ty _Arg2) noexcept { using _Common = conditional_t<is_integral_v<_Ty>, double, _Ty>; if constexpr (is_same_v<_Common, float>) { return __std_smf_hermitef(_Arg1, _Arg2); } else { return static_cast<_Common>(__std_smf_hermite(_Arg1, static_cast<double>(_Arg2))); } }
template <class _Ty, enable_if_t<is_arithmetic_v<_Ty>, int> = 0> [[nodiscard]] auto laguerre(const unsigned int _Arg1, const _Ty _Arg2) noexcept { using _Common = conditional_t<is_integral_v<_Ty>, double, _Ty>; if constexpr (is_same_v<_Common, float>) { return __std_smf_laguerref(_Arg1, _Arg2); } else { return static_cast<_Common>(__std_smf_laguerre(_Arg1, static_cast<double>(_Arg2))); } }
template <class _Ty, enable_if_t<is_arithmetic_v<_Ty>, int> = 0> [[nodiscard]] auto legendre(const unsigned int _Arg1, const _Ty _Arg2) noexcept { using _Common = conditional_t<is_integral_v<_Ty>, double, _Ty>; if constexpr (is_same_v<_Common, float>) { return __std_smf_legendref(_Arg1, _Arg2); } else { return static_cast<_Common>(__std_smf_legendre(_Arg1, static_cast<double>(_Arg2))); } }
template <class _Ty, enable_if_t<is_arithmetic_v<_Ty>, int> = 0> [[nodiscard]] auto riemann_zeta(const _Ty _Arg) noexcept { using _Common = conditional_t<is_integral_v<_Ty>, double, _Ty>; if constexpr (is_same_v<_Common, float>) { return __std_smf_riemann_zetaf(_Arg); } else { return static_cast<_Common>(__std_smf_riemann_zeta(static_cast<double>(_Arg))); } }
template <class _Ty, enable_if_t<is_arithmetic_v<_Ty>, int> = 0> [[nodiscard]] auto sph_bessel(const unsigned int _Arg1, const _Ty _Arg2) noexcept { using _Common = conditional_t<is_integral_v<_Ty>, double, _Ty>; if constexpr (is_same_v<_Common, float>) { return __std_smf_sph_besself(_Arg1, _Arg2); } else { return static_cast<_Common>(__std_smf_sph_bessel(_Arg1, static_cast<double>(_Arg2))); } }
template <class _Ty, enable_if_t<is_arithmetic_v<_Ty>, int> = 0> [[nodiscard]] auto sph_legendre( const unsigned int _Arg1, const unsigned int _Arg2, const _Ty _Arg3) noexcept { using _Common = conditional_t<is_integral_v<_Ty>, double, _Ty>; if constexpr (is_same_v<_Common, float>) { return __std_smf_sph_legendref(_Arg1, _Arg2, _Arg3); } else { return static_cast<_Common>(__std_smf_sph_legendre(_Arg1, _Arg2, static_cast<double>(_Arg3))); } }
template <class _Ty, enable_if_t<is_arithmetic_v<_Ty>, int> = 0> [[nodiscard]] auto sph_neumann(const unsigned int _Arg1, const _Ty _Arg2) noexcept { using _Common = conditional_t<is_integral_v<_Ty>, double, _Ty>; if constexpr (is_same_v<_Common, float>) { return __std_smf_sph_neumannf(_Arg1, _Arg2); } else { return static_cast<_Common>(__std_smf_sph_neumann(_Arg1, static_cast<double>(_Arg2))); } }







 [[nodiscard]] inline double hypot(const double _Dx, const double _Dy, const double _Dz) {
    return __std_smf_hypot3(_Dx, _Dy, _Dz);
}

 [[nodiscard]] inline float hypot(const float _Dx, const float _Dy, const float _Dz) {
    return __std_smf_hypot3f(_Dx, _Dy, _Dz);
}

 [[nodiscard]] inline long double hypot(const long double _Dx, const long double _Dy, const long double _Dz) {
    return __std_smf_hypot3(static_cast<double>(_Dx), static_cast<double>(_Dy), static_cast<double>(_Dz));
}

 template <class _Ty1, class _Ty2, class _Ty3,
    enable_if_t<is_arithmetic_v<_Ty1> && is_arithmetic_v<_Ty2> && is_arithmetic_v<_Ty3>, int> = 0>
[[nodiscard]] auto hypot(const _Ty1 _Dx, const _Ty2 _Dy, const _Ty3 _Dz) {
    
    
    
    using _Common      = _Common_float_type_t<_Ty1, _Common_float_type_t<_Ty2, _Ty3>>; 
    const auto _Result = __std_smf_hypot3(static_cast<double>(_Dx), static_cast<double>(_Dy), static_cast<double>(_Dz));
    return static_cast<_Common>(_Result);
}


template <class _Ty>
[[nodiscard]] constexpr _Ty _Linear_for_lerp(const _Ty _ArgA, const _Ty _ArgB, const _Ty _ArgT) {
    if (::std:: is_constant_evaluated()) {
        auto _Smaller     = _ArgT;
        auto _Larger      = _ArgB - _ArgA;
        auto _Abs_smaller = _Float_abs(_Smaller);
        auto _Abs_larger  = _Float_abs(_Larger);
        if (_Abs_larger < _Abs_smaller) {
            ::std:: swap(_Smaller, _Larger);
            ::std:: swap(_Abs_smaller, _Abs_larger);
        }

        if (_Abs_smaller > 1) {
            
            
            
            return 2 * (_Ty{0.5} * _ArgA + _Smaller * (_Ty{0.5} * _Larger));
        } else {
            return _ArgA + _Smaller * _Larger;
        }
    }

    return ::std:: fma(_ArgT, _ArgB - _ArgA, _ArgA);
}

template <class _Ty>
[[nodiscard]] constexpr _Ty _Common_lerp(const _Ty _ArgA, const _Ty _ArgB, const _Ty _ArgT) noexcept {
    

    const bool _T_is_finite = _Is_finite(_ArgT);
    if (_T_is_finite && _Is_finite(_ArgA) && _Is_finite(_ArgB)) {
        
        if ((_ArgA <= 0 && _ArgB >= 0) || (_ArgA >= 0 && _ArgB <= 0)) {
            
            return _ArgT * _ArgB + (1 - _ArgT) * _ArgA;
        }

        if (_ArgT == 1) {
            
            return _ArgB;
        }

        
        const auto _Candidate = _Linear_for_lerp(_ArgA, _ArgB, _ArgT);
        
        if ((_ArgT > 1) == (_ArgB > _ArgA)) {
            if (_ArgB > _Candidate) {
                return _ArgB;
            }
        } else {
            if (_Candidate > _ArgB) {
                return _ArgB;
            }
        }

        return _Candidate;
    }

    if (::std:: is_constant_evaluated()) {
        if (_Is_nan(_ArgA)) {
            return _ArgA;
        }

        if (_Is_nan(_ArgB)) {
            return _ArgB;
        }

        if (_Is_nan(_ArgT)) {
            return _ArgT;
        }
    } else {
        
        if (_Is_nan(_ArgA) || _Is_nan(_ArgB)) {
            return (_ArgA + _ArgB) + _ArgT;
        }

        if (_Is_nan(_ArgT)) {
            return _ArgT + _ArgT;
        }
    }

    if (_T_is_finite) {
        
        if (_ArgT < 0) {
            
            return _ArgA - _ArgB;
        } else if (_ArgT <= 1) {
            
            
            
            return _ArgT * _ArgB + (1 - _ArgT) * _ArgA;
        } else {
            
            return _ArgB - _ArgA;
        }
    } else {
        
        return _ArgT * (_ArgB - _ArgA);
    }
}

 [[nodiscard]] constexpr inline float lerp(const float _ArgA, const float _ArgB, const float _ArgT) noexcept {
    return _Common_lerp(_ArgA, _ArgB, _ArgT);
}

 [[nodiscard]] constexpr inline double lerp(
    const double _ArgA, const double _ArgB, const double _ArgT) noexcept {
    return _Common_lerp(_ArgA, _ArgB, _ArgT);
}

 [[nodiscard]] constexpr inline long double lerp(
    const long double _ArgA, const long double _ArgB, const long double _ArgT) noexcept {
    return _Common_lerp(_ArgA, _ArgB, _ArgT);
}

 template <class _Ty1, class _Ty2, class _Ty3,
    enable_if_t<is_arithmetic_v<_Ty1> && is_arithmetic_v<_Ty2> && is_arithmetic_v<_Ty3>, int> = 0>
[[nodiscard]] constexpr auto lerp(const _Ty1 _ArgA, const _Ty2 _ArgB, const _Ty3 _ArgT) noexcept {
    using _Tgt = conditional_t<_Is_any_of_v<long double, _Ty1, _Ty2, _Ty3>, long double, double>;
    return _Common_lerp(static_cast<_Tgt>(_ArgA), static_cast<_Tgt>(_ArgB), static_cast<_Tgt>(_ArgT));
}
#line 1484 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"
}
#line 1486 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"



#pragma warning(pop)
#pragma pack(pop)

#line 1493 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"
#line 1494 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cmath"
#pragma external_header(pop)
#line 2 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\_fixes.hpp"


























#line 105 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\glm.hpp"

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"


#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cassert"








#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\assert.h"









#line 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\assert.h"



#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )

__pragma(pack(push, 8)) extern "C" {





#line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\assert.h"









    __declspec(dllimport) void __cdecl _wassert(
         wchar_t const* _Message,
         wchar_t const* _File,
           unsigned       _Line
        );

    




#line 45 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\assert.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 10 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cassert"
#pragma external_header(pop)
#line 4 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
































#line 37 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 39 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"




#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\simd\\platform.h"
#pragma once




















#line 23 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\simd\\platform.h"

#line 25 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\simd\\platform.h"

#line 27 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\simd\\platform.h"

#line 29 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\simd\\platform.h"











#line 41 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\simd\\platform.h"















































































































#line 153 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\simd\\platform.h"
















#line 170 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\simd\\platform.h"



#line 174 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\simd\\platform.h"





























































#line 236 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\simd\\platform.h"
























#line 261 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\simd\\platform.h"





































#line 299 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\simd\\platform.h"














































#line 346 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\simd\\platform.h"






#line 353 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\simd\\platform.h"


#line 356 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\simd\\platform.h"


#line 359 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\simd\\platform.h"


#line 362 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\simd\\platform.h"


#line 365 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\simd\\platform.h"


#line 368 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\simd\\platform.h"


#line 371 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\simd\\platform.h"


#line 374 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\simd\\platform.h"


#line 377 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\simd\\platform.h"





























#line 407 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\simd\\platform.h"










#line 418 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\simd\\platform.h"
#line 419 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\simd\\platform.h"



#line 423 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\simd\\platform.h"

#line 425 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\simd\\platform.h"




#line 430 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\simd\\platform.h"

#line 432 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\simd\\platform.h"

#line 434 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\simd\\platform.h"

#line 436 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\simd\\platform.h"

#line 438 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\simd\\platform.h"

#line 440 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\simd\\platform.h"













#line 454 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\simd\\platform.h"




#line 459 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\simd\\platform.h"




#line 464 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\simd\\platform.h"





#line 470 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\simd\\platform.h"
#line 44 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"










#line 55 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"



#line 59 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
































#line 92 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"



#line 96 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"


#line 99 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"


#line 102 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"


#line 105 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"


#line 108 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 110 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 112 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"











#line 124 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"


#line 127 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"















#line 143 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
#line 144 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"











#line 156 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 158 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 160 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"





#line 166 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"






#line 173 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"




#line 178 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"






#line 185 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"










#line 196 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"




#line 201 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"







#line 209 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"




#line 214 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"






#line 221 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"




#line 226 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"







#line 234 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"




#line 239 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"






#line 246 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"




#line 251 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"







#line 259 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"




#line 264 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"







#line 272 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"




#line 277 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"







#line 285 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"




#line 290 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"







#line 298 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"





#line 304 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 306 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"





#line 312 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"





#line 318 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"









#line 328 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"



#line 332 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"


#line 335 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"





#line 341 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"






#line 348 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"








#line 357 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"












#line 370 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"






#line 377 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 379 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"





#line 385 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"





#line 391 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

































#line 425 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"








#line 434 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"





#line 440 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"










#line 451 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"





















#line 473 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"


#line 476 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"















#line 492 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"


#line 495 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"













#line 509 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"






#line 516 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"













#line 530 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"



#line 534 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 536 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 538 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"










#line 549 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"










#line 560 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"




























#line 589 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
#line 590 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
















#line 607 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"







#line 615 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"















#line 631 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

namespace glm
{
	using std::size_t;


#line 638 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
		typedef int length_t;
#line 640 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
}







	namespace glm
	{
		template<typename T, std::size_t N>
		constexpr std::size_t countof(T const (&)[N])
		{
			return N;
		}
	}









#line 666 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"




namespace glm{
namespace detail
{
	template<typename T>
	struct is_int
	{
		enum test {value = 0};
	};

	template<>
	struct is_int<unsigned int>
	{
		enum test {value = ~0};
	};

	template<>
	struct is_int<signed int>
	{
		enum test {value = ~0};
	};
}

	typedef unsigned int	uint;
}






#line 701 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

namespace glm{
namespace detail
{

		typedef std::uint64_t						uint64;
		typedef std::int64_t						int64;

















#line 726 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
}
}







namespace glm{
namespace detail
{
	using std::make_unsigned;
}
}













































































#line 819 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"








#line 828 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"










#line 839 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 841 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 843 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"






#line 850 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 852 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"










#line 863 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"







#line 871 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"














#line 886 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 888 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"






#line 895 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 897 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"








#line 906 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"










#line 917 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 919 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 921 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 923 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"



#line 927 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 929 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 931 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 933 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"



#line 937 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 939 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 941 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 943 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"



#line 947 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 949 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 951 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 953 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"



#line 957 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 959 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 961 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 963 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

































































































































































































































#line 1189 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
#line 107 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\glm.hpp"

#pragma once





#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cassert"








#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\assert.h"









#line 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\assert.h"



#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )

__pragma(pack(push, 8)) extern "C" {





#line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\assert.h"









    __declspec(dllimport) void __cdecl _wassert(
         wchar_t const* _Message,
         wchar_t const* _File,
           unsigned       _Line
        );

    




#line 45 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\assert.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 10 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cassert"
#pragma external_header(pop)
#line 115 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\glm.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\fwd.hpp"
#pragma once

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\qualifier.hpp"
#pragma once

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 970 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
























































































































































































































#line 1187 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 1189 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
#line 4 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\qualifier.hpp"

namespace glm
{
	
	enum qualifier
	{
		packed_highp, 
		packed_mediump, 
		packed_lowp, 






#line 20 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\qualifier.hpp"

		highp = packed_highp, 
		mediump = packed_mediump, 
		lowp = packed_lowp, 
		packed = packed_highp, 



#line 29 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\qualifier.hpp"
			defaultp = highp
#line 31 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\qualifier.hpp"
	};

	typedef qualifier precision;

	template<length_t L, typename T, qualifier Q = defaultp> struct vec;
	template<length_t C, length_t R, typename T, qualifier Q = defaultp> struct mat;
	template<typename T, qualifier Q = defaultp> struct qua;


		template <typename T, qualifier Q = defaultp> using tvec1 = vec<1, T, Q>;
		template <typename T, qualifier Q = defaultp> using tvec2 = vec<2, T, Q>;
		template <typename T, qualifier Q = defaultp> using tvec3 = vec<3, T, Q>;
		template <typename T, qualifier Q = defaultp> using tvec4 = vec<4, T, Q>;
		template <typename T, qualifier Q = defaultp> using tmat2x2 = mat<2, 2, T, Q>;
		template <typename T, qualifier Q = defaultp> using tmat2x3 = mat<2, 3, T, Q>;
		template <typename T, qualifier Q = defaultp> using tmat2x4 = mat<2, 4, T, Q>;
		template <typename T, qualifier Q = defaultp> using tmat3x2 = mat<3, 2, T, Q>;
		template <typename T, qualifier Q = defaultp> using tmat3x3 = mat<3, 3, T, Q>;
		template <typename T, qualifier Q = defaultp> using tmat3x4 = mat<3, 4, T, Q>;
		template <typename T, qualifier Q = defaultp> using tmat4x2 = mat<4, 2, T, Q>;
		template <typename T, qualifier Q = defaultp> using tmat4x3 = mat<4, 3, T, Q>;
		template <typename T, qualifier Q = defaultp> using tmat4x4 = mat<4, 4, T, Q>;
		template <typename T, qualifier Q = defaultp> using tquat = qua<T, Q>;
#line 55 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\qualifier.hpp"

namespace detail
{
	template<glm::qualifier P>
	struct is_aligned
	{
		static const bool value = false;
	};



















#line 83 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\qualifier.hpp"

	template<length_t L, typename T, bool is_aligned>
	struct storage
	{
		typedef struct type {
			T data[L];
		} type;
	};


		template<length_t L, typename T>
		struct storage<L, T, true>
		{
			typedef struct alignas(L * sizeof(T)) type {
				T data[L];
			} type;
		};

		template<typename T>
		struct storage<3, T, true>
		{
			typedef struct alignas(4 * sizeof(T)) type {
				T data[4];
			} type;
		};
#line 109 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\qualifier.hpp"





































#line 147 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\qualifier.hpp"






#line 154 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\qualifier.hpp"













#line 168 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\qualifier.hpp"



















#line 188 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\qualifier.hpp"

	enum genTypeEnum
	{
		GENTYPE_VEC,
		GENTYPE_MAT,
		GENTYPE_QUAT
	};

	template <typename genType>
	struct genTypeTrait
	{};

	template <length_t C, length_t R, typename T>
	struct genTypeTrait<mat<C, R, T> >
	{
		static const genTypeEnum GENTYPE = GENTYPE_MAT;
	};

	template<typename genType, genTypeEnum type>
	struct init_gentype
	{
	};

	template<typename genType>
	struct init_gentype<genType, GENTYPE_QUAT>
	{
		inline constexpr static genType identity()
		{
			return genType(1, 0, 0, 0);
		}
	};

	template<typename genType>
	struct init_gentype<genType, GENTYPE_MAT>
	{
		inline constexpr static genType identity()
		{
			return genType(1);
		}
	};
}
}
#line 4 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\fwd.hpp"

namespace glm
{

	typedef std::int8_t				int8;
	typedef std::int16_t			int16;
	typedef std::int32_t			int32;
	typedef std::int64_t			int64;

	typedef std::uint8_t			uint8;
	typedef std::uint16_t			uint16;
	typedef std::uint32_t			uint32;
	typedef std::uint64_t			uint64;










#line 28 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\fwd.hpp"

	

	typedef int8					lowp_i8;
	typedef int8					mediump_i8;
	typedef int8					highp_i8;
	typedef int8					i8;

	typedef int8					lowp_int8;
	typedef int8					mediump_int8;
	typedef int8					highp_int8;

	typedef int8					lowp_int8_t;
	typedef int8					mediump_int8_t;
	typedef int8					highp_int8_t;
	typedef int8					int8_t;

	typedef int16					lowp_i16;
	typedef int16					mediump_i16;
	typedef int16					highp_i16;
	typedef int16					i16;

	typedef int16					lowp_int16;
	typedef int16					mediump_int16;
	typedef int16					highp_int16;

	typedef int16					lowp_int16_t;
	typedef int16					mediump_int16_t;
	typedef int16					highp_int16_t;
	typedef int16					int16_t;

	typedef int32					lowp_i32;
	typedef int32					mediump_i32;
	typedef int32					highp_i32;
	typedef int32					i32;

	typedef int32					lowp_int32;
	typedef int32					mediump_int32;
	typedef int32					highp_int32;

	typedef int32					lowp_int32_t;
	typedef int32					mediump_int32_t;
	typedef int32					highp_int32_t;
	typedef int32					int32_t;

	typedef int64					lowp_i64;
	typedef int64					mediump_i64;
	typedef int64					highp_i64;
	typedef int64					i64;

	typedef int64					lowp_int64;
	typedef int64					mediump_int64;
	typedef int64					highp_int64;

	typedef int64					lowp_int64_t;
	typedef int64					mediump_int64_t;
	typedef int64					highp_int64_t;
	typedef int64					int64_t;

	

	typedef unsigned int			uint;

	typedef uint8					lowp_u8;
	typedef uint8					mediump_u8;
	typedef uint8					highp_u8;
	typedef uint8					u8;

	typedef uint8					lowp_uint8;
	typedef uint8					mediump_uint8;
	typedef uint8					highp_uint8;

	typedef uint8					lowp_uint8_t;
	typedef uint8					mediump_uint8_t;
	typedef uint8					highp_uint8_t;
	typedef uint8					uint8_t;

	typedef uint16					lowp_u16;
	typedef uint16					mediump_u16;
	typedef uint16					highp_u16;
	typedef uint16					u16;

	typedef uint16					lowp_uint16;
	typedef uint16					mediump_uint16;
	typedef uint16					highp_uint16;

	typedef uint16					lowp_uint16_t;
	typedef uint16					mediump_uint16_t;
	typedef uint16					highp_uint16_t;
	typedef uint16					uint16_t;

	typedef uint32					lowp_u32;
	typedef uint32					mediump_u32;
	typedef uint32					highp_u32;
	typedef uint32					u32;

	typedef uint32					lowp_uint32;
	typedef uint32					mediump_uint32;
	typedef uint32					highp_uint32;

	typedef uint32					lowp_uint32_t;
	typedef uint32					mediump_uint32_t;
	typedef uint32					highp_uint32_t;
	typedef uint32					uint32_t;

	typedef uint64					lowp_u64;
	typedef uint64					mediump_u64;
	typedef uint64					highp_u64;
	typedef uint64					u64;

	typedef uint64					lowp_uint64;
	typedef uint64					mediump_uint64;
	typedef uint64					highp_uint64;

	typedef uint64					lowp_uint64_t;
	typedef uint64					mediump_uint64_t;
	typedef uint64					highp_uint64_t;
	typedef uint64					uint64_t;

	

	typedef float					lowp_f32;
	typedef float					mediump_f32;
	typedef float					highp_f32;
	typedef float					f32;

	typedef float					lowp_float32;
	typedef float					mediump_float32;
	typedef float					highp_float32;
	typedef float					float32;

	typedef float					lowp_float32_t;
	typedef float					mediump_float32_t;
	typedef float					highp_float32_t;
	typedef float					float32_t;


	typedef double					lowp_f64;
	typedef double					mediump_f64;
	typedef double					highp_f64;
	typedef double					f64;

	typedef double					lowp_float64;
	typedef double					mediump_float64;
	typedef double					highp_float64;
	typedef double					float64;

	typedef double					lowp_float64_t;
	typedef double					mediump_float64_t;
	typedef double					highp_float64_t;
	typedef double					float64_t;

	

	typedef vec<1, bool, lowp>		lowp_bvec1;
	typedef vec<2, bool, lowp>		lowp_bvec2;
	typedef vec<3, bool, lowp>		lowp_bvec3;
	typedef vec<4, bool, lowp>		lowp_bvec4;

	typedef vec<1, bool, mediump>	mediump_bvec1;
	typedef vec<2, bool, mediump>	mediump_bvec2;
	typedef vec<3, bool, mediump>	mediump_bvec3;
	typedef vec<4, bool, mediump>	mediump_bvec4;

	typedef vec<1, bool, highp>		highp_bvec1;
	typedef vec<2, bool, highp>		highp_bvec2;
	typedef vec<3, bool, highp>		highp_bvec3;
	typedef vec<4, bool, highp>		highp_bvec4;

	typedef vec<1, bool, defaultp>	bvec1;
	typedef vec<2, bool, defaultp>	bvec2;
	typedef vec<3, bool, defaultp>	bvec3;
	typedef vec<4, bool, defaultp>	bvec4;

	

	typedef vec<1, int, lowp>		lowp_ivec1;
	typedef vec<2, int, lowp>		lowp_ivec2;
	typedef vec<3, int, lowp>		lowp_ivec3;
	typedef vec<4, int, lowp>		lowp_ivec4;

	typedef vec<1, int, mediump>	mediump_ivec1;
	typedef vec<2, int, mediump>	mediump_ivec2;
	typedef vec<3, int, mediump>	mediump_ivec3;
	typedef vec<4, int, mediump>	mediump_ivec4;

	typedef vec<1, int, highp>		highp_ivec1;
	typedef vec<2, int, highp>		highp_ivec2;
	typedef vec<3, int, highp>		highp_ivec3;
	typedef vec<4, int, highp>		highp_ivec4;

	typedef vec<1, int, defaultp>	ivec1;
	typedef vec<2, int, defaultp>	ivec2;
	typedef vec<3, int, defaultp>	ivec3;
	typedef vec<4, int, defaultp>	ivec4;

	typedef vec<1, i8, lowp>		lowp_i8vec1;
	typedef vec<2, i8, lowp>		lowp_i8vec2;
	typedef vec<3, i8, lowp>		lowp_i8vec3;
	typedef vec<4, i8, lowp>		lowp_i8vec4;

	typedef vec<1, i8, mediump>		mediump_i8vec1;
	typedef vec<2, i8, mediump>		mediump_i8vec2;
	typedef vec<3, i8, mediump>		mediump_i8vec3;
	typedef vec<4, i8, mediump>		mediump_i8vec4;

	typedef vec<1, i8, highp>		highp_i8vec1;
	typedef vec<2, i8, highp>		highp_i8vec2;
	typedef vec<3, i8, highp>		highp_i8vec3;
	typedef vec<4, i8, highp>		highp_i8vec4;

	typedef vec<1, i8, defaultp>	i8vec1;
	typedef vec<2, i8, defaultp>	i8vec2;
	typedef vec<3, i8, defaultp>	i8vec3;
	typedef vec<4, i8, defaultp>	i8vec4;

	typedef vec<1, i16, lowp>		lowp_i16vec1;
	typedef vec<2, i16, lowp>		lowp_i16vec2;
	typedef vec<3, i16, lowp>		lowp_i16vec3;
	typedef vec<4, i16, lowp>		lowp_i16vec4;

	typedef vec<1, i16, mediump>	mediump_i16vec1;
	typedef vec<2, i16, mediump>	mediump_i16vec2;
	typedef vec<3, i16, mediump>	mediump_i16vec3;
	typedef vec<4, i16, mediump>	mediump_i16vec4;

	typedef vec<1, i16, highp>		highp_i16vec1;
	typedef vec<2, i16, highp>		highp_i16vec2;
	typedef vec<3, i16, highp>		highp_i16vec3;
	typedef vec<4, i16, highp>		highp_i16vec4;

	typedef vec<1, i16, defaultp>	i16vec1;
	typedef vec<2, i16, defaultp>	i16vec2;
	typedef vec<3, i16, defaultp>	i16vec3;
	typedef vec<4, i16, defaultp>	i16vec4;

	typedef vec<1, i32, lowp>		lowp_i32vec1;
	typedef vec<2, i32, lowp>		lowp_i32vec2;
	typedef vec<3, i32, lowp>		lowp_i32vec3;
	typedef vec<4, i32, lowp>		lowp_i32vec4;

	typedef vec<1, i32, mediump>	mediump_i32vec1;
	typedef vec<2, i32, mediump>	mediump_i32vec2;
	typedef vec<3, i32, mediump>	mediump_i32vec3;
	typedef vec<4, i32, mediump>	mediump_i32vec4;

	typedef vec<1, i32, highp>		highp_i32vec1;
	typedef vec<2, i32, highp>		highp_i32vec2;
	typedef vec<3, i32, highp>		highp_i32vec3;
	typedef vec<4, i32, highp>		highp_i32vec4;

	typedef vec<1, i32, defaultp>	i32vec1;
	typedef vec<2, i32, defaultp>	i32vec2;
	typedef vec<3, i32, defaultp>	i32vec3;
	typedef vec<4, i32, defaultp>	i32vec4;

	typedef vec<1, i64, lowp>		lowp_i64vec1;
	typedef vec<2, i64, lowp>		lowp_i64vec2;
	typedef vec<3, i64, lowp>		lowp_i64vec3;
	typedef vec<4, i64, lowp>		lowp_i64vec4;

	typedef vec<1, i64, mediump>	mediump_i64vec1;
	typedef vec<2, i64, mediump>	mediump_i64vec2;
	typedef vec<3, i64, mediump>	mediump_i64vec3;
	typedef vec<4, i64, mediump>	mediump_i64vec4;

	typedef vec<1, i64, highp>		highp_i64vec1;
	typedef vec<2, i64, highp>		highp_i64vec2;
	typedef vec<3, i64, highp>		highp_i64vec3;
	typedef vec<4, i64, highp>		highp_i64vec4;

	typedef vec<1, i64, defaultp>	i64vec1;
	typedef vec<2, i64, defaultp>	i64vec2;
	typedef vec<3, i64, defaultp>	i64vec3;
	typedef vec<4, i64, defaultp>	i64vec4;

	

	typedef vec<1, uint, lowp>		lowp_uvec1;
	typedef vec<2, uint, lowp>		lowp_uvec2;
	typedef vec<3, uint, lowp>		lowp_uvec3;
	typedef vec<4, uint, lowp>		lowp_uvec4;

	typedef vec<1, uint, mediump>	mediump_uvec1;
	typedef vec<2, uint, mediump>	mediump_uvec2;
	typedef vec<3, uint, mediump>	mediump_uvec3;
	typedef vec<4, uint, mediump>	mediump_uvec4;

	typedef vec<1, uint, highp>		highp_uvec1;
	typedef vec<2, uint, highp>		highp_uvec2;
	typedef vec<3, uint, highp>		highp_uvec3;
	typedef vec<4, uint, highp>		highp_uvec4;

	typedef vec<1, uint, defaultp>	uvec1;
	typedef vec<2, uint, defaultp>	uvec2;
	typedef vec<3, uint, defaultp>	uvec3;
	typedef vec<4, uint, defaultp>	uvec4;

	typedef vec<1, u8, lowp>		lowp_u8vec1;
	typedef vec<2, u8, lowp>		lowp_u8vec2;
	typedef vec<3, u8, lowp>		lowp_u8vec3;
	typedef vec<4, u8, lowp>		lowp_u8vec4;

	typedef vec<1, u8, mediump>		mediump_u8vec1;
	typedef vec<2, u8, mediump>		mediump_u8vec2;
	typedef vec<3, u8, mediump>		mediump_u8vec3;
	typedef vec<4, u8, mediump>		mediump_u8vec4;

	typedef vec<1, u8, highp>		highp_u8vec1;
	typedef vec<2, u8, highp>		highp_u8vec2;
	typedef vec<3, u8, highp>		highp_u8vec3;
	typedef vec<4, u8, highp>		highp_u8vec4;

	typedef vec<1, u8, defaultp>	u8vec1;
	typedef vec<2, u8, defaultp>	u8vec2;
	typedef vec<3, u8, defaultp>	u8vec3;
	typedef vec<4, u8, defaultp>	u8vec4;

	typedef vec<1, u16, lowp>		lowp_u16vec1;
	typedef vec<2, u16, lowp>		lowp_u16vec2;
	typedef vec<3, u16, lowp>		lowp_u16vec3;
	typedef vec<4, u16, lowp>		lowp_u16vec4;

	typedef vec<1, u16, mediump>	mediump_u16vec1;
	typedef vec<2, u16, mediump>	mediump_u16vec2;
	typedef vec<3, u16, mediump>	mediump_u16vec3;
	typedef vec<4, u16, mediump>	mediump_u16vec4;

	typedef vec<1, u16, highp>		highp_u16vec1;
	typedef vec<2, u16, highp>		highp_u16vec2;
	typedef vec<3, u16, highp>		highp_u16vec3;
	typedef vec<4, u16, highp>		highp_u16vec4;

	typedef vec<1, u16, defaultp>	u16vec1;
	typedef vec<2, u16, defaultp>	u16vec2;
	typedef vec<3, u16, defaultp>	u16vec3;
	typedef vec<4, u16, defaultp>	u16vec4;

	typedef vec<1, u32, lowp>		lowp_u32vec1;
	typedef vec<2, u32, lowp>		lowp_u32vec2;
	typedef vec<3, u32, lowp>		lowp_u32vec3;
	typedef vec<4, u32, lowp>		lowp_u32vec4;

	typedef vec<1, u32, mediump>	mediump_u32vec1;
	typedef vec<2, u32, mediump>	mediump_u32vec2;
	typedef vec<3, u32, mediump>	mediump_u32vec3;
	typedef vec<4, u32, mediump>	mediump_u32vec4;

	typedef vec<1, u32, highp>		highp_u32vec1;
	typedef vec<2, u32, highp>		highp_u32vec2;
	typedef vec<3, u32, highp>		highp_u32vec3;
	typedef vec<4, u32, highp>		highp_u32vec4;

	typedef vec<1, u32, defaultp>	u32vec1;
	typedef vec<2, u32, defaultp>	u32vec2;
	typedef vec<3, u32, defaultp>	u32vec3;
	typedef vec<4, u32, defaultp>	u32vec4;

	typedef vec<1, u64, lowp>		lowp_u64vec1;
	typedef vec<2, u64, lowp>		lowp_u64vec2;
	typedef vec<3, u64, lowp>		lowp_u64vec3;
	typedef vec<4, u64, lowp>		lowp_u64vec4;

	typedef vec<1, u64, mediump>	mediump_u64vec1;
	typedef vec<2, u64, mediump>	mediump_u64vec2;
	typedef vec<3, u64, mediump>	mediump_u64vec3;
	typedef vec<4, u64, mediump>	mediump_u64vec4;

	typedef vec<1, u64, highp>		highp_u64vec1;
	typedef vec<2, u64, highp>		highp_u64vec2;
	typedef vec<3, u64, highp>		highp_u64vec3;
	typedef vec<4, u64, highp>		highp_u64vec4;

	typedef vec<1, u64, defaultp>	u64vec1;
	typedef vec<2, u64, defaultp>	u64vec2;
	typedef vec<3, u64, defaultp>	u64vec3;
	typedef vec<4, u64, defaultp>	u64vec4;

	

	typedef vec<1, float, lowp>			lowp_vec1;
	typedef vec<2, float, lowp>			lowp_vec2;
	typedef vec<3, float, lowp>			lowp_vec3;
	typedef vec<4, float, lowp>			lowp_vec4;

	typedef vec<1, float, mediump>		mediump_vec1;
	typedef vec<2, float, mediump>		mediump_vec2;
	typedef vec<3, float, mediump>		mediump_vec3;
	typedef vec<4, float, mediump>		mediump_vec4;

	typedef vec<1, float, highp>		highp_vec1;
	typedef vec<2, float, highp>		highp_vec2;
	typedef vec<3, float, highp>		highp_vec3;
	typedef vec<4, float, highp>		highp_vec4;

	typedef vec<1, float, defaultp>		vec1;
	typedef vec<2, float, defaultp>		vec2;
	typedef vec<3, float, defaultp>		vec3;
	typedef vec<4, float, defaultp>		vec4;

	typedef vec<1, float, lowp>			lowp_fvec1;
	typedef vec<2, float, lowp>			lowp_fvec2;
	typedef vec<3, float, lowp>			lowp_fvec3;
	typedef vec<4, float, lowp>			lowp_fvec4;

	typedef vec<1, float, mediump>		mediump_fvec1;
	typedef vec<2, float, mediump>		mediump_fvec2;
	typedef vec<3, float, mediump>		mediump_fvec3;
	typedef vec<4, float, mediump>		mediump_fvec4;

	typedef vec<1, float, highp>		highp_fvec1;
	typedef vec<2, float, highp>		highp_fvec2;
	typedef vec<3, float, highp>		highp_fvec3;
	typedef vec<4, float, highp>		highp_fvec4;

	typedef vec<1, f32, defaultp>		fvec1;
	typedef vec<2, f32, defaultp>		fvec2;
	typedef vec<3, f32, defaultp>		fvec3;
	typedef vec<4, f32, defaultp>		fvec4;

	typedef vec<1, f32, lowp>			lowp_f32vec1;
	typedef vec<2, f32, lowp>			lowp_f32vec2;
	typedef vec<3, f32, lowp>			lowp_f32vec3;
	typedef vec<4, f32, lowp>			lowp_f32vec4;

	typedef vec<1, f32, mediump>		mediump_f32vec1;
	typedef vec<2, f32, mediump>		mediump_f32vec2;
	typedef vec<3, f32, mediump>		mediump_f32vec3;
	typedef vec<4, f32, mediump>		mediump_f32vec4;

	typedef vec<1, f32, highp>			highp_f32vec1;
	typedef vec<2, f32, highp>			highp_f32vec2;
	typedef vec<3, f32, highp>			highp_f32vec3;
	typedef vec<4, f32, highp>			highp_f32vec4;

	typedef vec<1, f32, defaultp>		f32vec1;
	typedef vec<2, f32, defaultp>		f32vec2;
	typedef vec<3, f32, defaultp>		f32vec3;
	typedef vec<4, f32, defaultp>		f32vec4;

	typedef vec<1, f64, lowp>			lowp_dvec1;
	typedef vec<2, f64, lowp>			lowp_dvec2;
	typedef vec<3, f64, lowp>			lowp_dvec3;
	typedef vec<4, f64, lowp>			lowp_dvec4;

	typedef vec<1, f64, mediump>		mediump_dvec1;
	typedef vec<2, f64, mediump>		mediump_dvec2;
	typedef vec<3, f64, mediump>		mediump_dvec3;
	typedef vec<4, f64, mediump>		mediump_dvec4;

	typedef vec<1, f64, highp>			highp_dvec1;
	typedef vec<2, f64, highp>			highp_dvec2;
	typedef vec<3, f64, highp>			highp_dvec3;
	typedef vec<4, f64, highp>			highp_dvec4;

	typedef vec<1, f64, defaultp>		dvec1;
	typedef vec<2, f64, defaultp>		dvec2;
	typedef vec<3, f64, defaultp>		dvec3;
	typedef vec<4, f64, defaultp>		dvec4;

	typedef vec<1, f64, lowp>			lowp_f64vec1;
	typedef vec<2, f64, lowp>			lowp_f64vec2;
	typedef vec<3, f64, lowp>			lowp_f64vec3;
	typedef vec<4, f64, lowp>			lowp_f64vec4;

	typedef vec<1, f64, mediump>		mediump_f64vec1;
	typedef vec<2, f64, mediump>		mediump_f64vec2;
	typedef vec<3, f64, mediump>		mediump_f64vec3;
	typedef vec<4, f64, mediump>		mediump_f64vec4;

	typedef vec<1, f64, highp>			highp_f64vec1;
	typedef vec<2, f64, highp>			highp_f64vec2;
	typedef vec<3, f64, highp>			highp_f64vec3;
	typedef vec<4, f64, highp>			highp_f64vec4;

	typedef vec<1, f64, defaultp>		f64vec1;
	typedef vec<2, f64, defaultp>		f64vec2;
	typedef vec<3, f64, defaultp>		f64vec3;
	typedef vec<4, f64, defaultp>		f64vec4;

	

	typedef mat<2, 2, f32, lowp>		lowp_mat2;
	typedef mat<3, 3, f32, lowp>		lowp_mat3;
	typedef mat<4, 4, f32, lowp>		lowp_mat4;

	typedef mat<2, 2, f32, mediump>		mediump_mat2;
	typedef mat<3, 3, f32, mediump>		mediump_mat3;
	typedef mat<4, 4, f32, mediump>		mediump_mat4;

	typedef mat<2, 2, f32, highp>		highp_mat2;
	typedef mat<3, 3, f32, highp>		highp_mat3;
	typedef mat<4, 4, f32, highp>		highp_mat4;

	typedef mat<2, 2, f32, defaultp>	mat2;
	typedef mat<3, 3, f32, defaultp>	mat3;
	typedef mat<4, 4, f32, defaultp>	mat4;

	typedef mat<2, 2, f32, lowp>		lowp_fmat2;
	typedef mat<3, 3, f32, lowp>		lowp_fmat3;
	typedef mat<4, 4, f32, lowp>		lowp_fmat4;

	typedef mat<2, 2, f32, mediump>		mediump_fmat2;
	typedef mat<3, 3, f32, mediump>		mediump_fmat3;
	typedef mat<4, 4, f32, mediump>		mediump_fmat4;

	typedef mat<2, 2, f32, highp>		highp_fmat2;
	typedef mat<3, 3, f32, highp>		highp_fmat3;
	typedef mat<4, 4, f32, highp>		highp_fmat4;

	typedef mat<2, 2, f32, defaultp>	fmat2;
	typedef mat<3, 3, f32, defaultp>	fmat3;
	typedef mat<4, 4, f32, defaultp>	fmat4;

	typedef mat<2, 2, f32, lowp>		lowp_f32mat2;
	typedef mat<3, 3, f32, lowp>		lowp_f32mat3;
	typedef mat<4, 4, f32, lowp>		lowp_f32mat4;

	typedef mat<2, 2, f32, mediump>		mediump_f32mat2;
	typedef mat<3, 3, f32, mediump>		mediump_f32mat3;
	typedef mat<4, 4, f32, mediump>		mediump_f32mat4;

	typedef mat<2, 2, f32, highp>		highp_f32mat2;
	typedef mat<3, 3, f32, highp>		highp_f32mat3;
	typedef mat<4, 4, f32, highp>		highp_f32mat4;

	typedef mat<2, 2, f32, defaultp>	f32mat2;
	typedef mat<3, 3, f32, defaultp>	f32mat3;
	typedef mat<4, 4, f32, defaultp>	f32mat4;

	typedef mat<2, 2, f64, lowp>		lowp_dmat2;
	typedef mat<3, 3, f64, lowp>		lowp_dmat3;
	typedef mat<4, 4, f64, lowp>		lowp_dmat4;

	typedef mat<2, 2, f64, mediump>		mediump_dmat2;
	typedef mat<3, 3, f64, mediump>		mediump_dmat3;
	typedef mat<4, 4, f64, mediump>		mediump_dmat4;

	typedef mat<2, 2, f64, highp>		highp_dmat2;
	typedef mat<3, 3, f64, highp>		highp_dmat3;
	typedef mat<4, 4, f64, highp>		highp_dmat4;

	typedef mat<2, 2, f64, defaultp>	dmat2;
	typedef mat<3, 3, f64, defaultp>	dmat3;
	typedef mat<4, 4, f64, defaultp>	dmat4;

	typedef mat<2, 2, f64, lowp>		lowp_f64mat2;
	typedef mat<3, 3, f64, lowp>		lowp_f64mat3;
	typedef mat<4, 4, f64, lowp>		lowp_f64mat4;

	typedef mat<2, 2, f64, mediump>		mediump_f64mat2;
	typedef mat<3, 3, f64, mediump>		mediump_f64mat3;
	typedef mat<4, 4, f64, mediump>		mediump_f64mat4;

	typedef mat<2, 2, f64, highp>		highp_f64mat2;
	typedef mat<3, 3, f64, highp>		highp_f64mat3;
	typedef mat<4, 4, f64, highp>		highp_f64mat4;

	typedef mat<2, 2, f64, defaultp>	f64mat2;
	typedef mat<3, 3, f64, defaultp>	f64mat3;
	typedef mat<4, 4, f64, defaultp>	f64mat4;

	

	typedef mat<2, 2, f32, lowp>		lowp_mat2x2;
	typedef mat<2, 3, f32, lowp>		lowp_mat2x3;
	typedef mat<2, 4, f32, lowp>		lowp_mat2x4;
	typedef mat<3, 2, f32, lowp>		lowp_mat3x2;
	typedef mat<3, 3, f32, lowp>		lowp_mat3x3;
	typedef mat<3, 4, f32, lowp>		lowp_mat3x4;
	typedef mat<4, 2, f32, lowp>		lowp_mat4x2;
	typedef mat<4, 3, f32, lowp>		lowp_mat4x3;
	typedef mat<4, 4, f32, lowp>		lowp_mat4x4;

	typedef mat<2, 2, f32, mediump>		mediump_mat2x2;
	typedef mat<2, 3, f32, mediump>		mediump_mat2x3;
	typedef mat<2, 4, f32, mediump>		mediump_mat2x4;
	typedef mat<3, 2, f32, mediump>		mediump_mat3x2;
	typedef mat<3, 3, f32, mediump>		mediump_mat3x3;
	typedef mat<3, 4, f32, mediump>		mediump_mat3x4;
	typedef mat<4, 2, f32, mediump>		mediump_mat4x2;
	typedef mat<4, 3, f32, mediump>		mediump_mat4x3;
	typedef mat<4, 4, f32, mediump>		mediump_mat4x4;

	typedef mat<2, 2, f32, highp>		highp_mat2x2;
	typedef mat<2, 3, f32, highp>		highp_mat2x3;
	typedef mat<2, 4, f32, highp>		highp_mat2x4;
	typedef mat<3, 2, f32, highp>		highp_mat3x2;
	typedef mat<3, 3, f32, highp>		highp_mat3x3;
	typedef mat<3, 4, f32, highp>		highp_mat3x4;
	typedef mat<4, 2, f32, highp>		highp_mat4x2;
	typedef mat<4, 3, f32, highp>		highp_mat4x3;
	typedef mat<4, 4, f32, highp>		highp_mat4x4;

	typedef mat<2, 2, f32, defaultp>	mat2x2;
	typedef mat<2, 3, f32, defaultp>	mat2x3;
	typedef mat<2, 4, f32, defaultp>	mat2x4;
	typedef mat<3, 2, f32, defaultp>	mat3x2;
	typedef mat<3, 3, f32, defaultp>	mat3x3;
	typedef mat<3, 4, f32, defaultp>	mat3x4;
	typedef mat<4, 2, f32, defaultp>	mat4x2;
	typedef mat<4, 3, f32, defaultp>	mat4x3;
	typedef mat<4, 4, f32, defaultp>	mat4x4;

	typedef mat<2, 2, f32, lowp>		lowp_fmat2x2;
	typedef mat<2, 3, f32, lowp>		lowp_fmat2x3;
	typedef mat<2, 4, f32, lowp>		lowp_fmat2x4;
	typedef mat<3, 2, f32, lowp>		lowp_fmat3x2;
	typedef mat<3, 3, f32, lowp>		lowp_fmat3x3;
	typedef mat<3, 4, f32, lowp>		lowp_fmat3x4;
	typedef mat<4, 2, f32, lowp>		lowp_fmat4x2;
	typedef mat<4, 3, f32, lowp>		lowp_fmat4x3;
	typedef mat<4, 4, f32, lowp>		lowp_fmat4x4;

	typedef mat<2, 2, f32, mediump>		mediump_fmat2x2;
	typedef mat<2, 3, f32, mediump>		mediump_fmat2x3;
	typedef mat<2, 4, f32, mediump>		mediump_fmat2x4;
	typedef mat<3, 2, f32, mediump>		mediump_fmat3x2;
	typedef mat<3, 3, f32, mediump>		mediump_fmat3x3;
	typedef mat<3, 4, f32, mediump>		mediump_fmat3x4;
	typedef mat<4, 2, f32, mediump>		mediump_fmat4x2;
	typedef mat<4, 3, f32, mediump>		mediump_fmat4x3;
	typedef mat<4, 4, f32, mediump>		mediump_fmat4x4;

	typedef mat<2, 2, f32, highp>		highp_fmat2x2;
	typedef mat<2, 3, f32, highp>		highp_fmat2x3;
	typedef mat<2, 4, f32, highp>		highp_fmat2x4;
	typedef mat<3, 2, f32, highp>		highp_fmat3x2;
	typedef mat<3, 3, f32, highp>		highp_fmat3x3;
	typedef mat<3, 4, f32, highp>		highp_fmat3x4;
	typedef mat<4, 2, f32, highp>		highp_fmat4x2;
	typedef mat<4, 3, f32, highp>		highp_fmat4x3;
	typedef mat<4, 4, f32, highp>		highp_fmat4x4;

	typedef mat<2, 2, f32, defaultp>	fmat2x2;
	typedef mat<2, 3, f32, defaultp>	fmat2x3;
	typedef mat<2, 4, f32, defaultp>	fmat2x4;
	typedef mat<3, 2, f32, defaultp>	fmat3x2;
	typedef mat<3, 3, f32, defaultp>	fmat3x3;
	typedef mat<3, 4, f32, defaultp>	fmat3x4;
	typedef mat<4, 2, f32, defaultp>	fmat4x2;
	typedef mat<4, 3, f32, defaultp>	fmat4x3;
	typedef mat<4, 4, f32, defaultp>	fmat4x4;

	typedef mat<2, 2, f32, lowp>		lowp_f32mat2x2;
	typedef mat<2, 3, f32, lowp>		lowp_f32mat2x3;
	typedef mat<2, 4, f32, lowp>		lowp_f32mat2x4;
	typedef mat<3, 2, f32, lowp>		lowp_f32mat3x2;
	typedef mat<3, 3, f32, lowp>		lowp_f32mat3x3;
	typedef mat<3, 4, f32, lowp>		lowp_f32mat3x4;
	typedef mat<4, 2, f32, lowp>		lowp_f32mat4x2;
	typedef mat<4, 3, f32, lowp>		lowp_f32mat4x3;
	typedef mat<4, 4, f32, lowp>		lowp_f32mat4x4;
	
	typedef mat<2, 2, f32, mediump>		mediump_f32mat2x2;
	typedef mat<2, 3, f32, mediump>		mediump_f32mat2x3;
	typedef mat<2, 4, f32, mediump>		mediump_f32mat2x4;
	typedef mat<3, 2, f32, mediump>		mediump_f32mat3x2;
	typedef mat<3, 3, f32, mediump>		mediump_f32mat3x3;
	typedef mat<3, 4, f32, mediump>		mediump_f32mat3x4;
	typedef mat<4, 2, f32, mediump>		mediump_f32mat4x2;
	typedef mat<4, 3, f32, mediump>		mediump_f32mat4x3;
	typedef mat<4, 4, f32, mediump>		mediump_f32mat4x4;

	typedef mat<2, 2, f32, highp>		highp_f32mat2x2;
	typedef mat<2, 3, f32, highp>		highp_f32mat2x3;
	typedef mat<2, 4, f32, highp>		highp_f32mat2x4;
	typedef mat<3, 2, f32, highp>		highp_f32mat3x2;
	typedef mat<3, 3, f32, highp>		highp_f32mat3x3;
	typedef mat<3, 4, f32, highp>		highp_f32mat3x4;
	typedef mat<4, 2, f32, highp>		highp_f32mat4x2;
	typedef mat<4, 3, f32, highp>		highp_f32mat4x3;
	typedef mat<4, 4, f32, highp>		highp_f32mat4x4;

	typedef mat<2, 2, f32, defaultp>	f32mat2x2;
	typedef mat<2, 3, f32, defaultp>	f32mat2x3;
	typedef mat<2, 4, f32, defaultp>	f32mat2x4;
	typedef mat<3, 2, f32, defaultp>	f32mat3x2;
	typedef mat<3, 3, f32, defaultp>	f32mat3x3;
	typedef mat<3, 4, f32, defaultp>	f32mat3x4;
	typedef mat<4, 2, f32, defaultp>	f32mat4x2;
	typedef mat<4, 3, f32, defaultp>	f32mat4x3;
	typedef mat<4, 4, f32, defaultp>	f32mat4x4;

	typedef mat<2, 2, double, lowp>		lowp_dmat2x2;
	typedef mat<2, 3, double, lowp>		lowp_dmat2x3;
	typedef mat<2, 4, double, lowp>		lowp_dmat2x4;
	typedef mat<3, 2, double, lowp>		lowp_dmat3x2;
	typedef mat<3, 3, double, lowp>		lowp_dmat3x3;
	typedef mat<3, 4, double, lowp>		lowp_dmat3x4;
	typedef mat<4, 2, double, lowp>		lowp_dmat4x2;
	typedef mat<4, 3, double, lowp>		lowp_dmat4x3;
	typedef mat<4, 4, double, lowp>		lowp_dmat4x4;

	typedef mat<2, 2, double, mediump>	mediump_dmat2x2;
	typedef mat<2, 3, double, mediump>	mediump_dmat2x3;
	typedef mat<2, 4, double, mediump>	mediump_dmat2x4;
	typedef mat<3, 2, double, mediump>	mediump_dmat3x2;
	typedef mat<3, 3, double, mediump>	mediump_dmat3x3;
	typedef mat<3, 4, double, mediump>	mediump_dmat3x4;
	typedef mat<4, 2, double, mediump>	mediump_dmat4x2;
	typedef mat<4, 3, double, mediump>	mediump_dmat4x3;
	typedef mat<4, 4, double, mediump>	mediump_dmat4x4;

	typedef mat<2, 2, double, highp>	highp_dmat2x2;
	typedef mat<2, 3, double, highp>	highp_dmat2x3;
	typedef mat<2, 4, double, highp>	highp_dmat2x4;
	typedef mat<3, 2, double, highp>	highp_dmat3x2;
	typedef mat<3, 3, double, highp>	highp_dmat3x3;
	typedef mat<3, 4, double, highp>	highp_dmat3x4;
	typedef mat<4, 2, double, highp>	highp_dmat4x2;
	typedef mat<4, 3, double, highp>	highp_dmat4x3;
	typedef mat<4, 4, double, highp>	highp_dmat4x4;

	typedef mat<2, 2, double, defaultp>	dmat2x2;
	typedef mat<2, 3, double, defaultp>	dmat2x3;
	typedef mat<2, 4, double, defaultp>	dmat2x4;
	typedef mat<3, 2, double, defaultp>	dmat3x2;
	typedef mat<3, 3, double, defaultp>	dmat3x3;
	typedef mat<3, 4, double, defaultp>	dmat3x4;
	typedef mat<4, 2, double, defaultp>	dmat4x2;
	typedef mat<4, 3, double, defaultp>	dmat4x3;
	typedef mat<4, 4, double, defaultp>	dmat4x4;

	typedef mat<2, 2, f64, lowp>		lowp_f64mat2x2;
	typedef mat<2, 3, f64, lowp>		lowp_f64mat2x3;
	typedef mat<2, 4, f64, lowp>		lowp_f64mat2x4;
	typedef mat<3, 2, f64, lowp>		lowp_f64mat3x2;
	typedef mat<3, 3, f64, lowp>		lowp_f64mat3x3;
	typedef mat<3, 4, f64, lowp>		lowp_f64mat3x4;
	typedef mat<4, 2, f64, lowp>		lowp_f64mat4x2;
	typedef mat<4, 3, f64, lowp>		lowp_f64mat4x3;
	typedef mat<4, 4, f64, lowp>		lowp_f64mat4x4;

	typedef mat<2, 2, f64, mediump>		mediump_f64mat2x2;
	typedef mat<2, 3, f64, mediump>		mediump_f64mat2x3;
	typedef mat<2, 4, f64, mediump>		mediump_f64mat2x4;
	typedef mat<3, 2, f64, mediump>		mediump_f64mat3x2;
	typedef mat<3, 3, f64, mediump>		mediump_f64mat3x3;
	typedef mat<3, 4, f64, mediump>		mediump_f64mat3x4;
	typedef mat<4, 2, f64, mediump>		mediump_f64mat4x2;
	typedef mat<4, 3, f64, mediump>		mediump_f64mat4x3;
	typedef mat<4, 4, f64, mediump>		mediump_f64mat4x4;

	typedef mat<2, 2, f64, highp>		highp_f64mat2x2;
	typedef mat<2, 3, f64, highp>		highp_f64mat2x3;
	typedef mat<2, 4, f64, highp>		highp_f64mat2x4;
	typedef mat<3, 2, f64, highp>		highp_f64mat3x2;
	typedef mat<3, 3, f64, highp>		highp_f64mat3x3;
	typedef mat<3, 4, f64, highp>		highp_f64mat3x4;
	typedef mat<4, 2, f64, highp>		highp_f64mat4x2;
	typedef mat<4, 3, f64, highp>		highp_f64mat4x3;
	typedef mat<4, 4, f64, highp>		highp_f64mat4x4;

	typedef mat<2, 2, f64, defaultp>	f64mat2x2;
	typedef mat<2, 3, f64, defaultp>	f64mat2x3;
	typedef mat<2, 4, f64, defaultp>	f64mat2x4;
	typedef mat<3, 2, f64, defaultp>	f64mat3x2;
	typedef mat<3, 3, f64, defaultp>	f64mat3x3;
	typedef mat<3, 4, f64, defaultp>	f64mat3x4;
	typedef mat<4, 2, f64, defaultp>	f64mat4x2;
	typedef mat<4, 3, f64, defaultp>	f64mat4x3;
	typedef mat<4, 4, f64, defaultp>	f64mat4x4;

	

	typedef mat<2, 2, int, lowp>		lowp_imat2x2;
	typedef mat<2, 3, int, lowp>		lowp_imat2x3;
	typedef mat<2, 4, int, lowp>		lowp_imat2x4;
	typedef mat<3, 2, int, lowp>		lowp_imat3x2;
	typedef mat<3, 3, int, lowp>		lowp_imat3x3;
	typedef mat<3, 4, int, lowp>		lowp_imat3x4;
	typedef mat<4, 2, int, lowp>		lowp_imat4x2;
	typedef mat<4, 3, int, lowp>		lowp_imat4x3;
	typedef mat<4, 4, int, lowp>		lowp_imat4x4;

	typedef mat<2, 2, int, mediump>		mediump_imat2x2;
	typedef mat<2, 3, int, mediump>		mediump_imat2x3;
	typedef mat<2, 4, int, mediump>		mediump_imat2x4;
	typedef mat<3, 2, int, mediump>		mediump_imat3x2;
	typedef mat<3, 3, int, mediump>		mediump_imat3x3;
	typedef mat<3, 4, int, mediump>		mediump_imat3x4;
	typedef mat<4, 2, int, mediump>		mediump_imat4x2;
	typedef mat<4, 3, int, mediump>		mediump_imat4x3;
	typedef mat<4, 4, int, mediump>		mediump_imat4x4;

	typedef mat<2, 2, int, highp>		highp_imat2x2;
	typedef mat<2, 3, int, highp>		highp_imat2x3;
	typedef mat<2, 4, int, highp>		highp_imat2x4;
	typedef mat<3, 2, int, highp>		highp_imat3x2;
	typedef mat<3, 3, int, highp>		highp_imat3x3;
	typedef mat<3, 4, int, highp>		highp_imat3x4;
	typedef mat<4, 2, int, highp>		highp_imat4x2;
	typedef mat<4, 3, int, highp>		highp_imat4x3;
	typedef mat<4, 4, int, highp>		highp_imat4x4;

	typedef mat<2, 2, int, defaultp>	imat2x2;
	typedef mat<2, 3, int, defaultp>	imat2x3;
	typedef mat<2, 4, int, defaultp>	imat2x4;
	typedef mat<3, 2, int, defaultp>	imat3x2;
	typedef mat<3, 3, int, defaultp>	imat3x3;
	typedef mat<3, 4, int, defaultp>	imat3x4;
	typedef mat<4, 2, int, defaultp>	imat4x2;
	typedef mat<4, 3, int, defaultp>	imat4x3;
	typedef mat<4, 4, int, defaultp>	imat4x4;


	typedef mat<2, 2, int8, lowp>		lowp_i8mat2x2;
	typedef mat<2, 3, int8, lowp>		lowp_i8mat2x3;
	typedef mat<2, 4, int8, lowp>		lowp_i8mat2x4;
	typedef mat<3, 2, int8, lowp>		lowp_i8mat3x2;
	typedef mat<3, 3, int8, lowp>		lowp_i8mat3x3;
	typedef mat<3, 4, int8, lowp>		lowp_i8mat3x4;
	typedef mat<4, 2, int8, lowp>		lowp_i8mat4x2;
	typedef mat<4, 3, int8, lowp>		lowp_i8mat4x3;
	typedef mat<4, 4, int8, lowp>		lowp_i8mat4x4;

	typedef mat<2, 2, int8, mediump>	mediump_i8mat2x2;
	typedef mat<2, 3, int8, mediump>	mediump_i8mat2x3;
	typedef mat<2, 4, int8, mediump>	mediump_i8mat2x4;
	typedef mat<3, 2, int8, mediump>	mediump_i8mat3x2;
	typedef mat<3, 3, int8, mediump>	mediump_i8mat3x3;
	typedef mat<3, 4, int8, mediump>	mediump_i8mat3x4;
	typedef mat<4, 2, int8, mediump>	mediump_i8mat4x2;
	typedef mat<4, 3, int8, mediump>	mediump_i8mat4x3;
	typedef mat<4, 4, int8, mediump>	mediump_i8mat4x4;

	typedef mat<2, 2, int8, highp>		highp_i8mat2x2;
	typedef mat<2, 3, int8, highp>		highp_i8mat2x3;
	typedef mat<2, 4, int8, highp>		highp_i8mat2x4;
	typedef mat<3, 2, int8, highp>		highp_i8mat3x2;
	typedef mat<3, 3, int8, highp>		highp_i8mat3x3;
	typedef mat<3, 4, int8, highp>		highp_i8mat3x4;
	typedef mat<4, 2, int8, highp>		highp_i8mat4x2;
	typedef mat<4, 3, int8, highp>		highp_i8mat4x3;
	typedef mat<4, 4, int8, highp>		highp_i8mat4x4;

	typedef mat<2, 2, int8, defaultp>	i8mat2x2;
	typedef mat<2, 3, int8, defaultp>	i8mat2x3;
	typedef mat<2, 4, int8, defaultp>	i8mat2x4;
	typedef mat<3, 2, int8, defaultp>	i8mat3x2;
	typedef mat<3, 3, int8, defaultp>	i8mat3x3;
	typedef mat<3, 4, int8, defaultp>	i8mat3x4;
	typedef mat<4, 2, int8, defaultp>	i8mat4x2;
	typedef mat<4, 3, int8, defaultp>	i8mat4x3;
	typedef mat<4, 4, int8, defaultp>	i8mat4x4;


	typedef mat<2, 2, int16, lowp>		lowp_i16mat2x2;
	typedef mat<2, 3, int16, lowp>		lowp_i16mat2x3;
	typedef mat<2, 4, int16, lowp>		lowp_i16mat2x4;
	typedef mat<3, 2, int16, lowp>		lowp_i16mat3x2;
	typedef mat<3, 3, int16, lowp>		lowp_i16mat3x3;
	typedef mat<3, 4, int16, lowp>		lowp_i16mat3x4;
	typedef mat<4, 2, int16, lowp>		lowp_i16mat4x2;
	typedef mat<4, 3, int16, lowp>		lowp_i16mat4x3;
	typedef mat<4, 4, int16, lowp>		lowp_i16mat4x4;

	typedef mat<2, 2, int16, mediump>	mediump_i16mat2x2;
	typedef mat<2, 3, int16, mediump>	mediump_i16mat2x3;
	typedef mat<2, 4, int16, mediump>	mediump_i16mat2x4;
	typedef mat<3, 2, int16, mediump>	mediump_i16mat3x2;
	typedef mat<3, 3, int16, mediump>	mediump_i16mat3x3;
	typedef mat<3, 4, int16, mediump>	mediump_i16mat3x4;
	typedef mat<4, 2, int16, mediump>	mediump_i16mat4x2;
	typedef mat<4, 3, int16, mediump>	mediump_i16mat4x3;
	typedef mat<4, 4, int16, mediump>	mediump_i16mat4x4;

	typedef mat<2, 2, int16, highp>		highp_i16mat2x2;
	typedef mat<2, 3, int16, highp>		highp_i16mat2x3;
	typedef mat<2, 4, int16, highp>		highp_i16mat2x4;
	typedef mat<3, 2, int16, highp>		highp_i16mat3x2;
	typedef mat<3, 3, int16, highp>		highp_i16mat3x3;
	typedef mat<3, 4, int16, highp>		highp_i16mat3x4;
	typedef mat<4, 2, int16, highp>		highp_i16mat4x2;
	typedef mat<4, 3, int16, highp>		highp_i16mat4x3;
	typedef mat<4, 4, int16, highp>		highp_i16mat4x4;

	typedef mat<2, 2, int16, defaultp>	i16mat2x2;
	typedef mat<2, 3, int16, defaultp>	i16mat2x3;
	typedef mat<2, 4, int16, defaultp>	i16mat2x4;
	typedef mat<3, 2, int16, defaultp>	i16mat3x2;
	typedef mat<3, 3, int16, defaultp>	i16mat3x3;
	typedef mat<3, 4, int16, defaultp>	i16mat3x4;
	typedef mat<4, 2, int16, defaultp>	i16mat4x2;
	typedef mat<4, 3, int16, defaultp>	i16mat4x3;
	typedef mat<4, 4, int16, defaultp>	i16mat4x4;


	typedef mat<2, 2, int32, lowp>		lowp_i32mat2x2;
	typedef mat<2, 3, int32, lowp>		lowp_i32mat2x3;
	typedef mat<2, 4, int32, lowp>		lowp_i32mat2x4;
	typedef mat<3, 2, int32, lowp>		lowp_i32mat3x2;
	typedef mat<3, 3, int32, lowp>		lowp_i32mat3x3;
	typedef mat<3, 4, int32, lowp>		lowp_i32mat3x4;
	typedef mat<4, 2, int32, lowp>		lowp_i32mat4x2;
	typedef mat<4, 3, int32, lowp>		lowp_i32mat4x3;
	typedef mat<4, 4, int32, lowp>		lowp_i32mat4x4;

	typedef mat<2, 2, int32, mediump>	mediump_i32mat2x2;
	typedef mat<2, 3, int32, mediump>	mediump_i32mat2x3;
	typedef mat<2, 4, int32, mediump>	mediump_i32mat2x4;
	typedef mat<3, 2, int32, mediump>	mediump_i32mat3x2;
	typedef mat<3, 3, int32, mediump>	mediump_i32mat3x3;
	typedef mat<3, 4, int32, mediump>	mediump_i32mat3x4;
	typedef mat<4, 2, int32, mediump>	mediump_i32mat4x2;
	typedef mat<4, 3, int32, mediump>	mediump_i32mat4x3;
	typedef mat<4, 4, int32, mediump>	mediump_i32mat4x4;

	typedef mat<2, 2, int32, highp>		highp_i32mat2x2;
	typedef mat<2, 3, int32, highp>		highp_i32mat2x3;
	typedef mat<2, 4, int32, highp>		highp_i32mat2x4;
	typedef mat<3, 2, int32, highp>		highp_i32mat3x2;
	typedef mat<3, 3, int32, highp>		highp_i32mat3x3;
	typedef mat<3, 4, int32, highp>		highp_i32mat3x4;
	typedef mat<4, 2, int32, highp>		highp_i32mat4x2;
	typedef mat<4, 3, int32, highp>		highp_i32mat4x3;
	typedef mat<4, 4, int32, highp>		highp_i32mat4x4;

	typedef mat<2, 2, int32, defaultp>	i32mat2x2;
	typedef mat<2, 3, int32, defaultp>	i32mat2x3;
	typedef mat<2, 4, int32, defaultp>	i32mat2x4;
	typedef mat<3, 2, int32, defaultp>	i32mat3x2;
	typedef mat<3, 3, int32, defaultp>	i32mat3x3;
	typedef mat<3, 4, int32, defaultp>	i32mat3x4;
	typedef mat<4, 2, int32, defaultp>	i32mat4x2;
	typedef mat<4, 3, int32, defaultp>	i32mat4x3;
	typedef mat<4, 4, int32, defaultp>	i32mat4x4;


	typedef mat<2, 2, int64, lowp>		lowp_i64mat2x2;
	typedef mat<2, 3, int64, lowp>		lowp_i64mat2x3;
	typedef mat<2, 4, int64, lowp>		lowp_i64mat2x4;
	typedef mat<3, 2, int64, lowp>		lowp_i64mat3x2;
	typedef mat<3, 3, int64, lowp>		lowp_i64mat3x3;
	typedef mat<3, 4, int64, lowp>		lowp_i64mat3x4;
	typedef mat<4, 2, int64, lowp>		lowp_i64mat4x2;
	typedef mat<4, 3, int64, lowp>		lowp_i64mat4x3;
	typedef mat<4, 4, int64, lowp>		lowp_i64mat4x4;

	typedef mat<2, 2, int64, mediump>	mediump_i64mat2x2;
	typedef mat<2, 3, int64, mediump>	mediump_i64mat2x3;
	typedef mat<2, 4, int64, mediump>	mediump_i64mat2x4;
	typedef mat<3, 2, int64, mediump>	mediump_i64mat3x2;
	typedef mat<3, 3, int64, mediump>	mediump_i64mat3x3;
	typedef mat<3, 4, int64, mediump>	mediump_i64mat3x4;
	typedef mat<4, 2, int64, mediump>	mediump_i64mat4x2;
	typedef mat<4, 3, int64, mediump>	mediump_i64mat4x3;
	typedef mat<4, 4, int64, mediump>	mediump_i64mat4x4;

	typedef mat<2, 2, int64, highp>		highp_i64mat2x2;
	typedef mat<2, 3, int64, highp>		highp_i64mat2x3;
	typedef mat<2, 4, int64, highp>		highp_i64mat2x4;
	typedef mat<3, 2, int64, highp>		highp_i64mat3x2;
	typedef mat<3, 3, int64, highp>		highp_i64mat3x3;
	typedef mat<3, 4, int64, highp>		highp_i64mat3x4;
	typedef mat<4, 2, int64, highp>		highp_i64mat4x2;
	typedef mat<4, 3, int64, highp>		highp_i64mat4x3;
	typedef mat<4, 4, int64, highp>		highp_i64mat4x4;

	typedef mat<2, 2, int64, defaultp>	i64mat2x2;
	typedef mat<2, 3, int64, defaultp>	i64mat2x3;
	typedef mat<2, 4, int64, defaultp>	i64mat2x4;
	typedef mat<3, 2, int64, defaultp>	i64mat3x2;
	typedef mat<3, 3, int64, defaultp>	i64mat3x3;
	typedef mat<3, 4, int64, defaultp>	i64mat3x4;
	typedef mat<4, 2, int64, defaultp>	i64mat4x2;
	typedef mat<4, 3, int64, defaultp>	i64mat4x3;
	typedef mat<4, 4, int64, defaultp>	i64mat4x4;


	

	typedef mat<2, 2, uint, lowp>		lowp_umat2x2;
	typedef mat<2, 3, uint, lowp>		lowp_umat2x3;
	typedef mat<2, 4, uint, lowp>		lowp_umat2x4;
	typedef mat<3, 2, uint, lowp>		lowp_umat3x2;
	typedef mat<3, 3, uint, lowp>		lowp_umat3x3;
	typedef mat<3, 4, uint, lowp>		lowp_umat3x4;
	typedef mat<4, 2, uint, lowp>		lowp_umat4x2;
	typedef mat<4, 3, uint, lowp>		lowp_umat4x3;
	typedef mat<4, 4, uint, lowp>		lowp_umat4x4;

	typedef mat<2, 2, uint, mediump>	mediump_umat2x2;
	typedef mat<2, 3, uint, mediump>	mediump_umat2x3;
	typedef mat<2, 4, uint, mediump>	mediump_umat2x4;
	typedef mat<3, 2, uint, mediump>	mediump_umat3x2;
	typedef mat<3, 3, uint, mediump>	mediump_umat3x3;
	typedef mat<3, 4, uint, mediump>	mediump_umat3x4;
	typedef mat<4, 2, uint, mediump>	mediump_umat4x2;
	typedef mat<4, 3, uint, mediump>	mediump_umat4x3;
	typedef mat<4, 4, uint, mediump>	mediump_umat4x4;

	typedef mat<2, 2, uint, highp>		highp_umat2x2;
	typedef mat<2, 3, uint, highp>		highp_umat2x3;
	typedef mat<2, 4, uint, highp>		highp_umat2x4;
	typedef mat<3, 2, uint, highp>		highp_umat3x2;
	typedef mat<3, 3, uint, highp>		highp_umat3x3;
	typedef mat<3, 4, uint, highp>		highp_umat3x4;
	typedef mat<4, 2, uint, highp>		highp_umat4x2;
	typedef mat<4, 3, uint, highp>		highp_umat4x3;
	typedef mat<4, 4, uint, highp>		highp_umat4x4;

	typedef mat<2, 2, uint, defaultp>	umat2x2;
	typedef mat<2, 3, uint, defaultp>	umat2x3;
	typedef mat<2, 4, uint, defaultp>	umat2x4;
	typedef mat<3, 2, uint, defaultp>	umat3x2;
	typedef mat<3, 3, uint, defaultp>	umat3x3;
	typedef mat<3, 4, uint, defaultp>	umat3x4;
	typedef mat<4, 2, uint, defaultp>	umat4x2;
	typedef mat<4, 3, uint, defaultp>	umat4x3;
	typedef mat<4, 4, uint, defaultp>	umat4x4;


	typedef mat<2, 2, uint8, lowp>		lowp_u8mat2x2;
	typedef mat<2, 3, uint8, lowp>		lowp_u8mat2x3;
	typedef mat<2, 4, uint8, lowp>		lowp_u8mat2x4;
	typedef mat<3, 2, uint8, lowp>		lowp_u8mat3x2;
	typedef mat<3, 3, uint8, lowp>		lowp_u8mat3x3;
	typedef mat<3, 4, uint8, lowp>		lowp_u8mat3x4;
	typedef mat<4, 2, uint8, lowp>		lowp_u8mat4x2;
	typedef mat<4, 3, uint8, lowp>		lowp_u8mat4x3;
	typedef mat<4, 4, uint8, lowp>		lowp_u8mat4x4;

	typedef mat<2, 2, uint8, mediump>	mediump_u8mat2x2;
	typedef mat<2, 3, uint8, mediump>	mediump_u8mat2x3;
	typedef mat<2, 4, uint8, mediump>	mediump_u8mat2x4;
	typedef mat<3, 2, uint8, mediump>	mediump_u8mat3x2;
	typedef mat<3, 3, uint8, mediump>	mediump_u8mat3x3;
	typedef mat<3, 4, uint8, mediump>	mediump_u8mat3x4;
	typedef mat<4, 2, uint8, mediump>	mediump_u8mat4x2;
	typedef mat<4, 3, uint8, mediump>	mediump_u8mat4x3;
	typedef mat<4, 4, uint8, mediump>	mediump_u8mat4x4;

	typedef mat<2, 2, uint8, highp>		highp_u8mat2x2;
	typedef mat<2, 3, uint8, highp>		highp_u8mat2x3;
	typedef mat<2, 4, uint8, highp>		highp_u8mat2x4;
	typedef mat<3, 2, uint8, highp>		highp_u8mat3x2;
	typedef mat<3, 3, uint8, highp>		highp_u8mat3x3;
	typedef mat<3, 4, uint8, highp>		highp_u8mat3x4;
	typedef mat<4, 2, uint8, highp>		highp_u8mat4x2;
	typedef mat<4, 3, uint8, highp>		highp_u8mat4x3;
	typedef mat<4, 4, uint8, highp>		highp_u8mat4x4;

	typedef mat<2, 2, uint8, defaultp>	u8mat2x2;
	typedef mat<2, 3, uint8, defaultp>	u8mat2x3;
	typedef mat<2, 4, uint8, defaultp>	u8mat2x4;
	typedef mat<3, 2, uint8, defaultp>	u8mat3x2;
	typedef mat<3, 3, uint8, defaultp>	u8mat3x3;
	typedef mat<3, 4, uint8, defaultp>	u8mat3x4;
	typedef mat<4, 2, uint8, defaultp>	u8mat4x2;
	typedef mat<4, 3, uint8, defaultp>	u8mat4x3;
	typedef mat<4, 4, uint8, defaultp>	u8mat4x4;


	typedef mat<2, 2, uint16, lowp>		lowp_u16mat2x2;
	typedef mat<2, 3, uint16, lowp>		lowp_u16mat2x3;
	typedef mat<2, 4, uint16, lowp>		lowp_u16mat2x4;
	typedef mat<3, 2, uint16, lowp>		lowp_u16mat3x2;
	typedef mat<3, 3, uint16, lowp>		lowp_u16mat3x3;
	typedef mat<3, 4, uint16, lowp>		lowp_u16mat3x4;
	typedef mat<4, 2, uint16, lowp>		lowp_u16mat4x2;
	typedef mat<4, 3, uint16, lowp>		lowp_u16mat4x3;
	typedef mat<4, 4, uint16, lowp>		lowp_u16mat4x4;

	typedef mat<2, 2, uint16, mediump>	mediump_u16mat2x2;
	typedef mat<2, 3, uint16, mediump>	mediump_u16mat2x3;
	typedef mat<2, 4, uint16, mediump>	mediump_u16mat2x4;
	typedef mat<3, 2, uint16, mediump>	mediump_u16mat3x2;
	typedef mat<3, 3, uint16, mediump>	mediump_u16mat3x3;
	typedef mat<3, 4, uint16, mediump>	mediump_u16mat3x4;
	typedef mat<4, 2, uint16, mediump>	mediump_u16mat4x2;
	typedef mat<4, 3, uint16, mediump>	mediump_u16mat4x3;
	typedef mat<4, 4, uint16, mediump>	mediump_u16mat4x4;

	typedef mat<2, 2, uint16, highp>	highp_u16mat2x2;
	typedef mat<2, 3, uint16, highp>	highp_u16mat2x3;
	typedef mat<2, 4, uint16, highp>	highp_u16mat2x4;
	typedef mat<3, 2, uint16, highp>	highp_u16mat3x2;
	typedef mat<3, 3, uint16, highp>	highp_u16mat3x3;
	typedef mat<3, 4, uint16, highp>	highp_u16mat3x4;
	typedef mat<4, 2, uint16, highp>	highp_u16mat4x2;
	typedef mat<4, 3, uint16, highp>	highp_u16mat4x3;
	typedef mat<4, 4, uint16, highp>	highp_u16mat4x4;

	typedef mat<2, 2, uint16, defaultp>	u16mat2x2;
	typedef mat<2, 3, uint16, defaultp>	u16mat2x3;
	typedef mat<2, 4, uint16, defaultp>	u16mat2x4;
	typedef mat<3, 2, uint16, defaultp>	u16mat3x2;
	typedef mat<3, 3, uint16, defaultp>	u16mat3x3;
	typedef mat<3, 4, uint16, defaultp>	u16mat3x4;
	typedef mat<4, 2, uint16, defaultp>	u16mat4x2;
	typedef mat<4, 3, uint16, defaultp>	u16mat4x3;
	typedef mat<4, 4, uint16, defaultp>	u16mat4x4;


	typedef mat<2, 2, uint32, lowp>		lowp_u32mat2x2;
	typedef mat<2, 3, uint32, lowp>		lowp_u32mat2x3;
	typedef mat<2, 4, uint32, lowp>		lowp_u32mat2x4;
	typedef mat<3, 2, uint32, lowp>		lowp_u32mat3x2;
	typedef mat<3, 3, uint32, lowp>		lowp_u32mat3x3;
	typedef mat<3, 4, uint32, lowp>		lowp_u32mat3x4;
	typedef mat<4, 2, uint32, lowp>		lowp_u32mat4x2;
	typedef mat<4, 3, uint32, lowp>		lowp_u32mat4x3;
	typedef mat<4, 4, uint32, lowp>		lowp_u32mat4x4;

	typedef mat<2, 2, uint32, mediump>	mediump_u32mat2x2;
	typedef mat<2, 3, uint32, mediump>	mediump_u32mat2x3;
	typedef mat<2, 4, uint32, mediump>	mediump_u32mat2x4;
	typedef mat<3, 2, uint32, mediump>	mediump_u32mat3x2;
	typedef mat<3, 3, uint32, mediump>	mediump_u32mat3x3;
	typedef mat<3, 4, uint32, mediump>	mediump_u32mat3x4;
	typedef mat<4, 2, uint32, mediump>	mediump_u32mat4x2;
	typedef mat<4, 3, uint32, mediump>	mediump_u32mat4x3;
	typedef mat<4, 4, uint32, mediump>	mediump_u32mat4x4;

	typedef mat<2, 2, uint32, highp>	highp_u32mat2x2;
	typedef mat<2, 3, uint32, highp>	highp_u32mat2x3;
	typedef mat<2, 4, uint32, highp>	highp_u32mat2x4;
	typedef mat<3, 2, uint32, highp>	highp_u32mat3x2;
	typedef mat<3, 3, uint32, highp>	highp_u32mat3x3;
	typedef mat<3, 4, uint32, highp>	highp_u32mat3x4;
	typedef mat<4, 2, uint32, highp>	highp_u32mat4x2;
	typedef mat<4, 3, uint32, highp>	highp_u32mat4x3;
	typedef mat<4, 4, uint32, highp>	highp_u32mat4x4;

	typedef mat<2, 2, uint32, defaultp>	u32mat2x2;
	typedef mat<2, 3, uint32, defaultp>	u32mat2x3;
	typedef mat<2, 4, uint32, defaultp>	u32mat2x4;
	typedef mat<3, 2, uint32, defaultp>	u32mat3x2;
	typedef mat<3, 3, uint32, defaultp>	u32mat3x3;
	typedef mat<3, 4, uint32, defaultp>	u32mat3x4;
	typedef mat<4, 2, uint32, defaultp>	u32mat4x2;
	typedef mat<4, 3, uint32, defaultp>	u32mat4x3;
	typedef mat<4, 4, uint32, defaultp>	u32mat4x4;


	typedef mat<2, 2, uint64, lowp>		lowp_u64mat2x2;
	typedef mat<2, 3, uint64, lowp>		lowp_u64mat2x3;
	typedef mat<2, 4, uint64, lowp>		lowp_u64mat2x4;
	typedef mat<3, 2, uint64, lowp>		lowp_u64mat3x2;
	typedef mat<3, 3, uint64, lowp>		lowp_u64mat3x3;
	typedef mat<3, 4, uint64, lowp>		lowp_u64mat3x4;
	typedef mat<4, 2, uint64, lowp>		lowp_u64mat4x2;
	typedef mat<4, 3, uint64, lowp>		lowp_u64mat4x3;
	typedef mat<4, 4, uint64, lowp>		lowp_u64mat4x4;

	typedef mat<2, 2, uint64, mediump>	mediump_u64mat2x2;
	typedef mat<2, 3, uint64, mediump>	mediump_u64mat2x3;
	typedef mat<2, 4, uint64, mediump>	mediump_u64mat2x4;
	typedef mat<3, 2, uint64, mediump>	mediump_u64mat3x2;
	typedef mat<3, 3, uint64, mediump>	mediump_u64mat3x3;
	typedef mat<3, 4, uint64, mediump>	mediump_u64mat3x4;
	typedef mat<4, 2, uint64, mediump>	mediump_u64mat4x2;
	typedef mat<4, 3, uint64, mediump>	mediump_u64mat4x3;
	typedef mat<4, 4, uint64, mediump>	mediump_u64mat4x4;

	typedef mat<2, 2, uint64, highp>	highp_u64mat2x2;
	typedef mat<2, 3, uint64, highp>	highp_u64mat2x3;
	typedef mat<2, 4, uint64, highp>	highp_u64mat2x4;
	typedef mat<3, 2, uint64, highp>	highp_u64mat3x2;
	typedef mat<3, 3, uint64, highp>	highp_u64mat3x3;
	typedef mat<3, 4, uint64, highp>	highp_u64mat3x4;
	typedef mat<4, 2, uint64, highp>	highp_u64mat4x2;
	typedef mat<4, 3, uint64, highp>	highp_u64mat4x3;
	typedef mat<4, 4, uint64, highp>	highp_u64mat4x4;

	typedef mat<2, 2, uint64, defaultp>	u64mat2x2;
	typedef mat<2, 3, uint64, defaultp>	u64mat2x3;
	typedef mat<2, 4, uint64, defaultp>	u64mat2x4;
	typedef mat<3, 2, uint64, defaultp>	u64mat3x2;
	typedef mat<3, 3, uint64, defaultp>	u64mat3x3;
	typedef mat<3, 4, uint64, defaultp>	u64mat3x4;
	typedef mat<4, 2, uint64, defaultp>	u64mat4x2;
	typedef mat<4, 3, uint64, defaultp>	u64mat4x3;
	typedef mat<4, 4, uint64, defaultp>	u64mat4x4;

	

	typedef qua<float, lowp>			lowp_quat;
	typedef qua<float, mediump>			mediump_quat;
	typedef qua<float, highp>			highp_quat;
	typedef qua<float, defaultp>		quat;

	typedef qua<float, lowp>			lowp_fquat;
	typedef qua<float, mediump>			mediump_fquat;
	typedef qua<float, highp>			highp_fquat;
	typedef qua<float, defaultp>		fquat;

	typedef qua<f32, lowp>				lowp_f32quat;
	typedef qua<f32, mediump>			mediump_f32quat;
	typedef qua<f32, highp>				highp_f32quat;
	typedef qua<f32, defaultp>			f32quat;

	typedef qua<double, lowp>			lowp_dquat;
	typedef qua<double, mediump>		mediump_dquat;
	typedef qua<double, highp>			highp_dquat;
	typedef qua<double, defaultp>		dquat;

	typedef qua<f64, lowp>				lowp_f64quat;
	typedef qua<f64, mediump>			mediump_f64quat;
	typedef qua<f64, highp>				highp_f64quat;
	typedef qua<f64, defaultp>			f64quat;
}


#line 116 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\glm.hpp"

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\vec2.hpp"



#pragma once
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_bool2.hpp"



#pragma once
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec2.hpp"



#pragma once




#line 10 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec2.hpp"

#line 12 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec2.hpp"


namespace glm
{
	template<typename T, qualifier Q>
	struct vec<2, T, Q>
	{
		

		typedef T value_type;
		typedef vec<2, T, Q> type;
		typedef vec<2, bool, Q> bool_type;

		





#line 32 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec2.hpp"



#line 36 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec2.hpp"
#pragma warning(push)
#pragma warning(disable: 4201)  
#line 39 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec2.hpp"
#line 40 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec2.hpp"






#line 47 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec2.hpp"




















#line 68 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec2.hpp"
			union {T x, r, s;};
			union {T y, g, t;};



#line 74 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec2.hpp"
#line 75 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec2.hpp"




#line 80 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec2.hpp"

#line 82 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec2.hpp"
#pragma warning(pop)
#line 84 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec2.hpp"
#line 85 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec2.hpp"

		

		
		typedef length_t length_type;
		[[nodiscard]] static constexpr length_type length(){return 2;}

		[[nodiscard]] constexpr T& operator[](length_type i);
		[[nodiscard]] constexpr T const& operator[](length_type i) const;

		

		 constexpr vec() = default ;
		 constexpr vec(vec const& v) = default ;
		template<qualifier P>
		constexpr vec(vec<2, T, P> const& v);

		

		constexpr explicit vec(T scalar);
		constexpr vec(T x, T y);

		

		template<typename U, qualifier P>
		constexpr explicit vec(vec<1, U, P> const& v);

		
		template<typename A, typename B>
		constexpr vec(A x, B y);
		template<typename A, typename B>
		constexpr vec(vec<1, A, Q> const& x, B y);
		template<typename A, typename B>
		constexpr vec(A x, vec<1, B, Q> const& y);
		template<typename A, typename B>
		constexpr vec(vec<1, A, Q> const& x, vec<1, B, Q> const& y);

		

		
		template<typename U, qualifier P>
		constexpr  vec(vec<3, U, P> const& v);
		
		template<typename U, qualifier P>
		constexpr  vec(vec<4, U, P> const& v);

		
		template<typename U, qualifier P>
		constexpr  vec(vec<2, U, P> const& v);

		






#line 143 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec2.hpp"

		

		 constexpr vec<2, T, Q> & operator=(vec const& v) = default ;

		template<typename U>
		 constexpr vec<2, T, Q> & operator=(vec<2, U, Q> const& v);
		template<typename U>
		 constexpr vec<2, T, Q> & operator+=(U scalar);
		template<typename U>
		 constexpr vec<2, T, Q> & operator+=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<2, T, Q> & operator+=(vec<2, U, Q> const& v);
		template<typename U>
		 constexpr vec<2, T, Q> & operator-=(U scalar);
		template<typename U>
		 constexpr vec<2, T, Q> & operator-=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<2, T, Q> & operator-=(vec<2, U, Q> const& v);
		template<typename U>
		 constexpr vec<2, T, Q> & operator*=(U scalar);
		template<typename U>
		 constexpr vec<2, T, Q> & operator*=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<2, T, Q> & operator*=(vec<2, U, Q> const& v);
		template<typename U>
		 constexpr vec<2, T, Q> & operator/=(U scalar);
		template<typename U>
		 constexpr vec<2, T, Q> & operator/=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<2, T, Q> & operator/=(vec<2, U, Q> const& v);

		

		 constexpr vec<2, T, Q> & operator++();
		 constexpr vec<2, T, Q> & operator--();
		[[nodiscard]] constexpr vec<2, T, Q> operator++(int);
		[[nodiscard]] constexpr vec<2, T, Q> operator--(int);

		

		template<typename U>
		 constexpr vec<2, T, Q> & operator%=(U scalar);
		template<typename U>
		 constexpr vec<2, T, Q> & operator%=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<2, T, Q> & operator%=(vec<2, U, Q> const& v);
		template<typename U>
		 constexpr vec<2, T, Q> & operator&=(U scalar);
		template<typename U>
		 constexpr vec<2, T, Q> & operator&=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<2, T, Q> & operator&=(vec<2, U, Q> const& v);
		template<typename U>
		 constexpr vec<2, T, Q> & operator|=(U scalar);
		template<typename U>
		 constexpr vec<2, T, Q> & operator|=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<2, T, Q> & operator|=(vec<2, U, Q> const& v);
		template<typename U>
		 constexpr vec<2, T, Q> & operator^=(U scalar);
		template<typename U>
		 constexpr vec<2, T, Q> & operator^=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<2, T, Q> & operator^=(vec<2, U, Q> const& v);
		template<typename U>
		 constexpr vec<2, T, Q> & operator<<=(U scalar);
		template<typename U>
		 constexpr vec<2, T, Q> & operator<<=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<2, T, Q> & operator<<=(vec<2, U, Q> const& v);
		template<typename U>
		 constexpr vec<2, T, Q> & operator>>=(U scalar);
		template<typename U>
		 constexpr vec<2, T, Q> & operator>>=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<2, T, Q> & operator>>=(vec<2, U, Q> const& v);
	};

	

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v);

	

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator+(T scalar, vec<2, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator+(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator-(T scalar, vec<2, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator-(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator*(vec<2, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator*(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator*(T scalar, vec<2, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator*(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator*(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator/(vec<2, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator/(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator/(T scalar, vec<2, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator/(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator/(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator%(vec<2, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator%(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator%(T scalar, vec<2, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator%(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator%(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator&(vec<2, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator&(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator&(T scalar, vec<2, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator&(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator&(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator|(vec<2, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator|(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator|(T scalar, vec<2, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator|(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator|(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator^(vec<2, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator^(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator^(T scalar, vec<2, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator^(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator^(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator<<(vec<2, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator<<(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator<<(T scalar, vec<2, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator<<(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator<<(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator>>(vec<2, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator>>(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator>>(T scalar, vec<2, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator>>(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator>>(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<2, T, Q> operator~(vec<2, T, Q> const& v);

	

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr bool operator==(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr bool operator!=(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

	template<qualifier Q>
	[[nodiscard]] constexpr vec<2, bool, Q> operator&&(vec<2, bool, Q> const& v1, vec<2, bool, Q> const& v2);

	template<qualifier Q>
	[[nodiscard]] constexpr vec<2, bool, Q> operator||(vec<2, bool, Q> const& v1, vec<2, bool, Q> const& v2);
}


#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec2.inl"


#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\compute_vector_relational.hpp"
#pragma once


#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 970 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
























































































































































































































#line 1187 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 1189 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
#line 5 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\compute_vector_relational.hpp"


namespace glm{
namespace detail
{
	template <typename T, bool isFloat>
	struct compute_equal
	{
		inline constexpr static bool call(T a, T b)
		{
			return a == b;
		}
	};











}
}
#line 4 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec2.inl"

namespace glm
{
	








#line 17 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec2.inl"






#line 24 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec2.inl"

	template<typename T, qualifier Q>
	template<qualifier P>
	inline constexpr vec<2, T, Q>::vec(vec<2, T, P> const& v)
		: x(v.x), y(v.y)
	{}

	

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q>::vec(T scalar)
		: x(scalar), y(scalar)
	{}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q>::vec(T _x, T _y)
		: x(_x), y(_y)
	{}

	

	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	inline constexpr vec<2, T, Q>::vec(vec<1, U, P> const& v)
		: x(static_cast<T>(v.x))
		, y(static_cast<T>(v.x))
	{}

	template<typename T, qualifier Q>
	template<typename A, typename B>
	inline constexpr vec<2, T, Q>::vec(A _x, B _y)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_y))
	{}

	template<typename T, qualifier Q>
	template<typename A, typename B>
	inline constexpr vec<2, T, Q>::vec(vec<1, A, Q> const& _x, B _y)
		: x(static_cast<T>(_x.x))
		, y(static_cast<T>(_y))
	{}

	template<typename T, qualifier Q>
	template<typename A, typename B>
	inline constexpr vec<2, T, Q>::vec(A _x, vec<1, B, Q> const& _y)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_y.x))
	{}

	template<typename T, qualifier Q>
	template<typename A, typename B>
	inline constexpr vec<2, T, Q>::vec(vec<1, A, Q> const& _x, vec<1, B, Q> const& _y)
		: x(static_cast<T>(_x.x))
		, y(static_cast<T>(_y.x))
	{}

	

	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	inline constexpr vec<2, T, Q>::vec(vec<2, U, P> const& v)
		: x(static_cast<T>(v.x))
		, y(static_cast<T>(v.y))
	{}

	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	inline constexpr vec<2, T, Q>::vec(vec<3, U, P> const& v)
		: x(static_cast<T>(v.x))
		, y(static_cast<T>(v.y))
	{}

	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	inline constexpr vec<2, T, Q>::vec(vec<4, U, P> const& v)
		: x(static_cast<T>(v.x))
		, y(static_cast<T>(v.y))
	{}

	

	template<typename T, qualifier Q>
	inline constexpr T & vec<2, T, Q>::operator[](typename vec<2, T, Q>::length_type i)
	{
		((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec2.inl", (unsigned)(108)), 0) )) ;
		switch(i)
		{
		default:
		case 0:
			return x;
		case 1:
			return y;
		}
	}

	template<typename T, qualifier Q>
	inline constexpr T const& vec<2, T, Q>::operator[](typename vec<2, T, Q>::length_type i) const
	{
		((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec2.inl", (unsigned)(122)), 0) )) ;
		switch(i)
		{
		default:
		case 0:
			return x;
		case 1:
			return y;
		}
	}

	









#line 144 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec2.inl"

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator=(vec<2, U, Q> const& v)
	{
		this->x = static_cast<T>(v.x);
		this->y = static_cast<T>(v.y);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator+=(U scalar)
	{
		this->x += static_cast<T>(scalar);
		this->y += static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator+=(vec<1, U, Q> const& v)
	{
		this->x += static_cast<T>(v.x);
		this->y += static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator+=(vec<2, U, Q> const& v)
	{
		this->x += static_cast<T>(v.x);
		this->y += static_cast<T>(v.y);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator-=(U scalar)
	{
		this->x -= static_cast<T>(scalar);
		this->y -= static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator-=(vec<1, U, Q> const& v)
	{
		this->x -= static_cast<T>(v.x);
		this->y -= static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator-=(vec<2, U, Q> const& v)
	{
		this->x -= static_cast<T>(v.x);
		this->y -= static_cast<T>(v.y);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator*=(U scalar)
	{
		this->x *= static_cast<T>(scalar);
		this->y *= static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator*=(vec<1, U, Q> const& v)
	{
		this->x *= static_cast<T>(v.x);
		this->y *= static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator*=(vec<2, U, Q> const& v)
	{
		this->x *= static_cast<T>(v.x);
		this->y *= static_cast<T>(v.y);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator/=(U scalar)
	{
		this->x /= static_cast<T>(scalar);
		this->y /= static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator/=(vec<1, U, Q> const& v)
	{
		this->x /= static_cast<T>(v.x);
		this->y /= static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator/=(vec<2, U, Q> const& v)
	{
		this->x /= static_cast<T>(v.x);
		this->y /= static_cast<T>(v.y);
		return *this;
	}

	

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator++()
	{
		++this->x;
		++this->y;
		return *this;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator--()
	{
		--this->x;
		--this->y;
		return *this;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> vec<2, T, Q>::operator++(int)
	{
		vec<2, T, Q> Result(*this);
		++*this;
		return Result;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> vec<2, T, Q>::operator--(int)
	{
		vec<2, T, Q> Result(*this);
		--*this;
		return Result;
	}

	

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator%=(U scalar)
	{
		this->x %= static_cast<T>(scalar);
		this->y %= static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator%=(vec<1, U, Q> const& v)
	{
		this->x %= static_cast<T>(v.x);
		this->y %= static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator%=(vec<2, U, Q> const& v)
	{
		this->x %= static_cast<T>(v.x);
		this->y %= static_cast<T>(v.y);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator&=(U scalar)
	{
		this->x &= static_cast<T>(scalar);
		this->y &= static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator&=(vec<1, U, Q> const& v)
	{
		this->x &= static_cast<T>(v.x);
		this->y &= static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator&=(vec<2, U, Q> const& v)
	{
		this->x &= static_cast<T>(v.x);
		this->y &= static_cast<T>(v.y);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator|=(U scalar)
	{
		this->x |= static_cast<T>(scalar);
		this->y |= static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator|=(vec<1, U, Q> const& v)
	{
		this->x |= static_cast<T>(v.x);
		this->y |= static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator|=(vec<2, U, Q> const& v)
	{
		this->x |= static_cast<T>(v.x);
		this->y |= static_cast<T>(v.y);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator^=(U scalar)
	{
		this->x ^= static_cast<T>(scalar);
		this->y ^= static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator^=(vec<1, U, Q> const& v)
	{
		this->x ^= static_cast<T>(v.x);
		this->y ^= static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator^=(vec<2, U, Q> const& v)
	{
		this->x ^= static_cast<T>(v.x);
		this->y ^= static_cast<T>(v.y);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator<<=(U scalar)
	{
		this->x <<= static_cast<T>(scalar);
		this->y <<= static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator<<=(vec<1, U, Q> const& v)
	{
		this->x <<= static_cast<T>(v.x);
		this->y <<= static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator<<=(vec<2, U, Q> const& v)
	{
		this->x <<= static_cast<T>(v.x);
		this->y <<= static_cast<T>(v.y);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator>>=(U scalar)
	{
		this->x >>= static_cast<T>(scalar);
		this->y >>= static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator>>=(vec<1, U, Q> const& v)
	{
		this->x >>= static_cast<T>(v.x);
		this->y >>= static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator>>=(vec<2, U, Q> const& v)
	{
		this->x >>= static_cast<T>(v.x);
		this->y >>= static_cast<T>(v.y);
		return *this;
	}

	

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v)
	{
		return v;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v)
	{
		return vec<2, T, Q>(
			-v.x,
			-v.y);
	}

	

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v, T scalar)
	{
		return vec<2, T, Q>(
			v.x + scalar,
			v.y + scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x + v2.x,
			v1.y + v2.x);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator+(T scalar, vec<2, T, Q> const& v)
	{
		return vec<2, T, Q>(
			scalar + v.x,
			scalar + v.y);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator+(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x + v2.x,
			v1.x + v2.y);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x + v2.x,
			v1.y + v2.y);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v, T scalar)
	{
		return vec<2, T, Q>(
			v.x - scalar,
			v.y - scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x - v2.x,
			v1.y - v2.x);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator-(T scalar, vec<2, T, Q> const& v)
	{
		return vec<2, T, Q>(
			scalar - v.x,
			scalar - v.y);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator-(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x - v2.x,
			v1.x - v2.y);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x - v2.x,
			v1.y - v2.y);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator*(vec<2, T, Q> const& v, T scalar)
	{
		return vec<2, T, Q>(
			v.x * scalar,
			v.y * scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator*(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x * v2.x,
			v1.y * v2.x);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator*(T scalar, vec<2, T, Q> const& v)
	{
		return vec<2, T, Q>(
			scalar * v.x,
			scalar * v.y);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator*(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x * v2.x,
			v1.x * v2.y);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator*(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x * v2.x,
			v1.y * v2.y);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator/(vec<2, T, Q> const& v, T scalar)
	{
		return vec<2, T, Q>(
			v.x / scalar,
			v.y / scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator/(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x / v2.x,
			v1.y / v2.x);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator/(T scalar, vec<2, T, Q> const& v)
	{
		return vec<2, T, Q>(
			scalar / v.x,
			scalar / v.y);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator/(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x / v2.x,
			v1.x / v2.y);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator/(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x / v2.x,
			v1.y / v2.y);
	}

	

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator%(vec<2, T, Q> const& v, T scalar)
	{
		return vec<2, T, Q>(
			v.x % scalar,
			v.y % scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator%(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x % v2.x,
			v1.y % v2.x);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator%(T scalar, vec<2, T, Q> const& v)
	{
		return vec<2, T, Q>(
			scalar % v.x,
			scalar % v.y);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator%(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x % v2.x,
			v1.x % v2.y);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator%(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x % v2.x,
			v1.y % v2.y);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator&(vec<2, T, Q> const& v, T scalar)
	{
		return vec<2, T, Q>(
			v.x & scalar,
			v.y & scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator&(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x & v2.x,
			v1.y & v2.x);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator&(T scalar, vec<2, T, Q> const& v)
	{
		return vec<2, T, Q>(
			scalar & v.x,
			scalar & v.y);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator&(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x & v2.x,
			v1.x & v2.y);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator&(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x & v2.x,
			v1.y & v2.y);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator|(vec<2, T, Q> const& v, T scalar)
	{
		return vec<2, T, Q>(
			v.x | scalar,
			v.y | scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator|(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x | v2.x,
			v1.y | v2.x);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator|(T scalar, vec<2, T, Q> const& v)
	{
		return vec<2, T, Q>(
			scalar | v.x,
			scalar | v.y);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator|(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x | v2.x,
			v1.x | v2.y);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator|(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x | v2.x,
			v1.y | v2.y);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator^(vec<2, T, Q> const& v, T scalar)
	{
		return vec<2, T, Q>(
			v.x ^ scalar,
			v.y ^ scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator^(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x ^ v2.x,
			v1.y ^ v2.x);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator^(T scalar, vec<2, T, Q> const& v)
	{
		return vec<2, T, Q>(
			scalar ^ v.x,
			scalar ^ v.y);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator^(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x ^ v2.x,
			v1.x ^ v2.y);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator^(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x ^ v2.x,
			v1.y ^ v2.y);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator<<(vec<2, T, Q> const& v, T scalar)
	{
		return vec<2, T, Q>(
			v.x << scalar,
			v.y << scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator<<(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x << v2.x,
			v1.y << v2.x);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator<<(T scalar, vec<2, T, Q> const& v)
	{
		return vec<2, T, Q>(
			scalar << v.x,
			scalar << v.y);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator<<(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x << v2.x,
			v1.x << v2.y);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator<<(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x << v2.x,
			v1.y << v2.y);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator>>(vec<2, T, Q> const& v, T scalar)
	{
		return vec<2, T, Q>(
			v.x >> scalar,
			v.y >> scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator>>(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x >> v2.x,
			v1.y >> v2.x);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator>>(T scalar, vec<2, T, Q> const& v)
	{
		return vec<2, T, Q>(
			scalar >> v.x,
			scalar >> v.y);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator>>(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x >> v2.x,
			v1.x >> v2.y);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator>>(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x >> v2.x,
			v1.y >> v2.y);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<2, T, Q> operator~(vec<2, T, Q> const& v)
	{
		return vec<2, T, Q>(
			~v.x,
			~v.y);
	}

	

	template<typename T, qualifier Q>
	inline constexpr bool operator==(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return
			detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.x, v2.x) &&
			detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.y, v2.y);
	}

	template<typename T, qualifier Q>
	inline constexpr bool operator!=(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return !(v1 == v2);
	}

	template<qualifier Q>
	inline constexpr vec<2, bool, Q> operator&&(vec<2, bool, Q> const& v1, vec<2, bool, Q> const& v2)
	{
		return vec<2, bool, Q>(v1.x && v2.x, v1.y && v2.y);
	}

	template<qualifier Q>
	inline constexpr vec<2, bool, Q> operator||(vec<2, bool, Q> const& v1, vec<2, bool, Q> const& v2)
	{
		return vec<2, bool, Q>(v1.x || v2.x, v1.y || v2.y);
	}
}
#line 402 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec2.hpp"
#line 403 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec2.hpp"
#line 6 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_bool2.hpp"

namespace glm
{
	
	

	
	
	
	typedef vec<2, bool, defaultp>		bvec2;

	
}
#line 6 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\vec2.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_bool2_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef vec<2, bool, highp>		highp_bvec2;

	
	
	
	
	typedef vec<2, bool, mediump>	mediump_bvec2;

	
	
	
	
	typedef vec<2, bool, lowp>		lowp_bvec2;

	
}
#line 7 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\vec2.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_float2.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef vec<2, float, defaultp>	vec2;

	
}
#line 8 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\vec2.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_float2_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef vec<2, float, highp>		highp_vec2;

	
	
	
	
	typedef vec<2, float, mediump>		mediump_vec2;

	
	
	
	
	typedef vec<2, float, lowp>			lowp_vec2;

	
}
#line 9 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\vec2.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_double2.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef vec<2, double, defaultp>		dvec2;

	
}
#line 10 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\vec2.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_double2_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef vec<2, double, highp>		highp_dvec2;

	
	
	
	
	typedef vec<2, double, mediump>		mediump_dvec2;

	
	
	
	
	typedef vec<2, double, lowp>		lowp_dvec2;

	
}
#line 11 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\vec2.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_int2.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef vec<2, int, defaultp>		ivec2;

	
}
#line 12 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\vec2.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_int2_sized.hpp"













#pragma once


#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_int_sized.hpp"












#pragma once

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 970 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
























































































































































































































#line 1187 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 1189 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
#line 16 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_int_sized.hpp"



#line 20 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_int_sized.hpp"

namespace glm{
namespace detail
{

		typedef std::int8_t			int8;
		typedef std::int16_t		int16;
		typedef std::int32_t		int32;




#line 33 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_int_sized.hpp"

	template<>
	struct is_int<int8>
	{
		enum test {value = ~0};
	};

	template<>
	struct is_int<int16>
	{
		enum test {value = ~0};
	};

	template<>
	struct is_int<int64>
	{
		enum test {value = ~0};
	};
}


	
	

	
	typedef detail::int8		int8;

	
	typedef detail::int16		int16;

	
	typedef detail::int32		int32;

	
	typedef detail::int64		int64;

	
}
#line 18 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_int2_sized.hpp"



#line 22 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_int2_sized.hpp"

namespace glm
{
	
	

	
	
	
	typedef vec<2, int8, defaultp>		i8vec2;

	
	
	
	typedef vec<2, int16, defaultp>		i16vec2;

	
	
	
	typedef vec<2, int32, defaultp>		i32vec2;

	
	
	
	typedef vec<2, int64, defaultp>		i64vec2;

	
}
#line 13 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\vec2.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_uint2.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef vec<2, unsigned int, defaultp>		uvec2;

	
}
#line 14 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\vec2.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_uint2_sized.hpp"













#pragma once


#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_uint_sized.hpp"












#pragma once

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 970 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
























































































































































































































#line 1187 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 1189 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
#line 16 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_uint_sized.hpp"



#line 20 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_uint_sized.hpp"

namespace glm{
namespace detail
{

		typedef std::uint8_t		uint8;
		typedef std::uint16_t		uint16;
		typedef std::uint32_t		uint32;




#line 33 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_uint_sized.hpp"

	template<>
	struct is_int<uint8>
	{
		enum test {value = ~0};
	};

	template<>
	struct is_int<uint16>
	{
		enum test {value = ~0};
	};

	template<>
	struct is_int<uint64>
	{
		enum test {value = ~0};
	};
}


	
	

	
	typedef detail::uint8		uint8;

	
	typedef detail::uint16		uint16;

	
	typedef detail::uint32		uint32;

	
	typedef detail::uint64		uint64;

	
}
#line 18 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_uint2_sized.hpp"



#line 22 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_uint2_sized.hpp"

namespace glm
{
	
	

	
	
	
	typedef vec<2, uint8, defaultp>		u8vec2;

	
	
	
	typedef vec<2, uint16, defaultp>	u16vec2;

	
	
	
	typedef vec<2, uint32, defaultp>	u32vec2;

	
	
	
	typedef vec<2, uint64, defaultp>	u64vec2;

	
}
#line 15 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\vec2.hpp"
#line 118 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\glm.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\vec3.hpp"



#pragma once
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_bool3.hpp"



#pragma once
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec3.hpp"



#pragma once




#line 10 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec3.hpp"

#line 12 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec3.hpp"


namespace glm
{
	template<typename T, qualifier Q>
	struct vec<3, T, Q>
	{
		

		typedef T value_type;
		typedef vec<3, T, Q> type;
		typedef vec<3, bool, Q> bool_type;

		





#line 32 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec3.hpp"




#line 37 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec3.hpp"
#pragma warning(push)
#pragma warning(disable: 4201)  


#line 42 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec3.hpp"
#line 43 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec3.hpp"
#line 44 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec3.hpp"






#line 51 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec3.hpp"




















#line 72 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec3.hpp"
			union { T x, r, s; };
			union { T y, g, t; };
			union { T z, b, p; };



#line 79 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec3.hpp"
#line 80 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec3.hpp"




#line 85 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec3.hpp"

#line 87 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec3.hpp"
#pragma warning(pop)
#line 89 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec3.hpp"
#line 90 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec3.hpp"

		

		
		typedef length_t length_type;
		[[nodiscard]] static constexpr length_type length(){return 3;}

		[[nodiscard]] constexpr T & operator[](length_type i);
		[[nodiscard]] constexpr T const& operator[](length_type i) const;

		

		 constexpr vec() = default ;
		 constexpr vec(vec const& v) = default ;
		template<qualifier P>
		constexpr vec(vec<3, T, P> const& v);

		

		constexpr explicit vec(T scalar);
		constexpr vec(T a, T b, T c);

		

		template<typename U, qualifier P>
		constexpr explicit vec(vec<1, U, P> const& v);

		
		template<typename X, typename Y, typename Z>
		constexpr vec(X x, Y y, Z z);
		template<typename X, typename Y, typename Z>
		constexpr vec(vec<1, X, Q> const& _x, Y _y, Z _z);
		template<typename X, typename Y, typename Z>
		constexpr vec(X _x, vec<1, Y, Q> const& _y, Z _z);
		template<typename X, typename Y, typename Z>
		constexpr vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, Z _z);
		template<typename X, typename Y, typename Z>
		constexpr vec(X _x, Y _y, vec<1, Z, Q> const& _z);
		template<typename X, typename Y, typename Z>
		constexpr vec(vec<1, X, Q> const& _x, Y _y, vec<1, Z, Q> const& _z);
		template<typename X, typename Y, typename Z>
		constexpr vec(X _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z);
		template<typename X, typename Y, typename Z>
		constexpr vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z);

		

		
		template<typename A, typename B, qualifier P>
		constexpr vec(vec<2, A, P> const& _xy, B _z);
		
		template<typename A, typename B, qualifier P>
		constexpr vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z);
		
		template<typename A, typename B, qualifier P>
		constexpr vec(A _x, vec<2, B, P> const& _yz);
		
		template<typename A, typename B, qualifier P>
		constexpr vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz);
		
		template<typename U, qualifier P>
		constexpr  vec(vec<4, U, P> const& v);

		
		template<typename U, qualifier P>
		constexpr  vec(vec<3, U, P> const& v);

		


















#line 177 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec3.hpp"

		

		 constexpr vec<3, T, Q>& operator=(vec<3, T, Q> const& v) = default ;

		template<typename U>
		 constexpr vec<3, T, Q> & operator=(vec<3, U, Q> const& v);
		template<typename U>
		 constexpr vec<3, T, Q> & operator+=(U scalar);
		template<typename U>
		 constexpr vec<3, T, Q> & operator+=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<3, T, Q> & operator+=(vec<3, U, Q> const& v);
		template<typename U>
		 constexpr vec<3, T, Q> & operator-=(U scalar);
		template<typename U>
		 constexpr vec<3, T, Q> & operator-=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<3, T, Q> & operator-=(vec<3, U, Q> const& v);
		template<typename U>
		 constexpr vec<3, T, Q> & operator*=(U scalar);
		template<typename U>
		 constexpr vec<3, T, Q> & operator*=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<3, T, Q> & operator*=(vec<3, U, Q> const& v);
		template<typename U>
		 constexpr vec<3, T, Q> & operator/=(U scalar);
		template<typename U>
		 constexpr vec<3, T, Q> & operator/=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<3, T, Q> & operator/=(vec<3, U, Q> const& v);

		

		 constexpr vec<3, T, Q> & operator++();
		 constexpr vec<3, T, Q> & operator--();
		[[nodiscard]] constexpr vec<3, T, Q> operator++(int);
		[[nodiscard]] constexpr vec<3, T, Q> operator--(int);

		

		template<typename U>
		 constexpr vec<3, T, Q> & operator%=(U scalar);
		template<typename U>
		 constexpr vec<3, T, Q> & operator%=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<3, T, Q> & operator%=(vec<3, U, Q> const& v);
		template<typename U>
		 constexpr vec<3, T, Q> & operator&=(U scalar);
		template<typename U>
		 constexpr vec<3, T, Q> & operator&=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<3, T, Q> & operator&=(vec<3, U, Q> const& v);
		template<typename U>
		 constexpr vec<3, T, Q> & operator|=(U scalar);
		template<typename U>
		 constexpr vec<3, T, Q> & operator|=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<3, T, Q> & operator|=(vec<3, U, Q> const& v);
		template<typename U>
		 constexpr vec<3, T, Q> & operator^=(U scalar);
		template<typename U>
		 constexpr vec<3, T, Q> & operator^=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<3, T, Q> & operator^=(vec<3, U, Q> const& v);
		template<typename U>
		 constexpr vec<3, T, Q> & operator<<=(U scalar);
		template<typename U>
		 constexpr vec<3, T, Q> & operator<<=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<3, T, Q> & operator<<=(vec<3, U, Q> const& v);
		template<typename U>
		 constexpr vec<3, T, Q> & operator>>=(U scalar);
		template<typename U>
		 constexpr vec<3, T, Q> & operator>>=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<3, T, Q> & operator>>=(vec<3, U, Q> const& v);
	};

	

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v);

	

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator+(T scalar, vec<3, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator+(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator-(T scalar, vec<3, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator-(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator*(vec<3, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator*(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator*(T scalar, vec<3, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator*(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator*(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator/(vec<3, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator/(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator/(T scalar, vec<3, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator/(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator/(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator%(vec<3, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator%(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator%(T scalar, vec<3, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator%(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator%(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator&(vec<3, T, Q> const& v1, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator&(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator&(T scalar, vec<3, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator&(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator&(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator|(vec<3, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator|(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator|(T scalar, vec<3, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator|(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator|(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator^(vec<3, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator^(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator^(T scalar, vec<3, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator^(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator^(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator<<(vec<3, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator<<(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator<<(T scalar, vec<3, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator<<(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator<<(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator>>(vec<3, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator>>(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator>>(T scalar, vec<3, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator>>(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator>>(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator~(vec<3, T, Q> const& v);

	

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr bool operator==(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr bool operator!=(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

	template<qualifier Q>
	[[nodiscard]] constexpr vec<3, bool, Q> operator&&(vec<3, bool, Q> const& v1, vec<3, bool, Q> const& v2);

	template<qualifier Q>
	[[nodiscard]] constexpr vec<3, bool, Q> operator||(vec<3, bool, Q> const& v1, vec<3, bool, Q> const& v2);
}


#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec3.inl"




namespace glm
{
	








#line 17 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec3.inl"






#line 24 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec3.inl"

	template<typename T, qualifier Q>
	template<qualifier P>
	inline constexpr vec<3, T, Q>::vec(vec<3, T, P> const& v)
		: x(v.x), y(v.y), z(v.z)
	{}

	

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q>::vec(T scalar)
		: x(scalar), y(scalar), z(scalar)
	{}

	template <typename T, qualifier Q>
	inline constexpr vec<3, T, Q>::vec(T _x, T _y, T _z)
		: x(_x), y(_y), z(_z)
	{}

	

	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	inline constexpr vec<3, T, Q>::vec(vec<1, U, P> const& v)
		: x(static_cast<T>(v.x))
		, y(static_cast<T>(v.x))
		, z(static_cast<T>(v.x))
	{}

	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z>
	inline constexpr vec<3, T, Q>::vec(X _x, Y _y, Z _z)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_y))
		, z(static_cast<T>(_z))
	{}

	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z>
	inline constexpr vec<3, T, Q>::vec(vec<1, X, Q> const& _x, Y _y, Z _z)
		: x(static_cast<T>(_x.x))
		, y(static_cast<T>(_y))
		, z(static_cast<T>(_z))
	{}

	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z>
	inline constexpr vec<3, T, Q>::vec(X _x, vec<1, Y, Q> const& _y, Z _z)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_y.x))
		, z(static_cast<T>(_z))
	{}

	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z>
	inline constexpr vec<3, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, Z _z)
		: x(static_cast<T>(_x.x))
		, y(static_cast<T>(_y.x))
		, z(static_cast<T>(_z))
	{}

	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z>
	inline constexpr vec<3, T, Q>::vec(X _x, Y _y, vec<1, Z, Q> const& _z)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_y))
		, z(static_cast<T>(_z.x))
	{}

	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z>
	inline constexpr vec<3, T, Q>::vec(vec<1, X, Q> const& _x, Y _y, vec<1, Z, Q> const& _z)
		: x(static_cast<T>(_x.x))
		, y(static_cast<T>(_y))
		, z(static_cast<T>(_z.x))
	{}

	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z>
	inline constexpr vec<3, T, Q>::vec(X _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_y.x))
		, z(static_cast<T>(_z.x))
	{}

	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z>
	inline constexpr vec<3, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z)
		: x(static_cast<T>(_x.x))
		, y(static_cast<T>(_y.x))
		, z(static_cast<T>(_z.x))
	{}

	

	template<typename T, qualifier Q>
	template<typename A, typename B, qualifier P>
	inline constexpr vec<3, T, Q>::vec(vec<2, A, P> const& _xy, B _z)
		: x(static_cast<T>(_xy.x))
		, y(static_cast<T>(_xy.y))
		, z(static_cast<T>(_z))
	{}

	template<typename T, qualifier Q>
	template<typename A, typename B, qualifier P>
	inline constexpr vec<3, T, Q>::vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z)
		: x(static_cast<T>(_xy.x))
		, y(static_cast<T>(_xy.y))
		, z(static_cast<T>(_z.x))
	{}

	template<typename T, qualifier Q>
	template<typename A, typename B, qualifier P>
	inline constexpr vec<3, T, Q>::vec(A _x, vec<2, B, P> const& _yz)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_yz.x))
		, z(static_cast<T>(_yz.y))
	{}

	template<typename T, qualifier Q>
	template<typename A, typename B, qualifier P>
	inline constexpr vec<3, T, Q>::vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz)
		: x(static_cast<T>(_x.x))
		, y(static_cast<T>(_yz.x))
		, z(static_cast<T>(_yz.y))
	{}

	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	inline constexpr vec<3, T, Q>::vec(vec<3, U, P> const& v)
		: x(static_cast<T>(v.x))
		, y(static_cast<T>(v.y))
		, z(static_cast<T>(v.z))
	{}

	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	inline constexpr vec<3, T, Q>::vec(vec<4, U, P> const& v)
		: x(static_cast<T>(v.x))
		, y(static_cast<T>(v.y))
		, z(static_cast<T>(v.z))
	{}

	

	template<typename T, qualifier Q>
	inline constexpr T & vec<3, T, Q>::operator[](typename vec<3, T, Q>::length_type i)
	{
		((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec3.inl", (unsigned)(172)), 0) )) ;
		switch(i)
		{
		default:
			case 0:
		return x;
			case 1:
		return y;
			case 2:
		return z;
		}
	}

	template<typename T, qualifier Q>
	inline constexpr T const& vec<3, T, Q>::operator[](typename vec<3, T, Q>::length_type i) const
	{
		((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec3.inl", (unsigned)(188)), 0) )) ;
		switch(i)
		{
		default:
		case 0:
			return x;
		case 1:
			return y;
		case 2:
			return z;
		}
	}

	










#line 213 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec3.inl"

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<3, T, Q>& vec<3, T, Q>::operator=(vec<3, U, Q> const& v)
	{
		this->x = static_cast<T>(v.x);
		this->y = static_cast<T>(v.y);
		this->z = static_cast<T>(v.z);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator+=(U scalar)
	{
		this->x += static_cast<T>(scalar);
		this->y += static_cast<T>(scalar);
		this->z += static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator+=(vec<1, U, Q> const& v)
	{
		this->x += static_cast<T>(v.x);
		this->y += static_cast<T>(v.x);
		this->z += static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator+=(vec<3, U, Q> const& v)
	{
		this->x += static_cast<T>(v.x);
		this->y += static_cast<T>(v.y);
		this->z += static_cast<T>(v.z);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator-=(U scalar)
	{
		this->x -= static_cast<T>(scalar);
		this->y -= static_cast<T>(scalar);
		this->z -= static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator-=(vec<1, U, Q> const& v)
	{
		this->x -= static_cast<T>(v.x);
		this->y -= static_cast<T>(v.x);
		this->z -= static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator-=(vec<3, U, Q> const& v)
	{
		this->x -= static_cast<T>(v.x);
		this->y -= static_cast<T>(v.y);
		this->z -= static_cast<T>(v.z);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator*=(U scalar)
	{
		this->x *= static_cast<T>(scalar);
		this->y *= static_cast<T>(scalar);
		this->z *= static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator*=(vec<1, U, Q> const& v)
	{
		this->x *= static_cast<T>(v.x);
		this->y *= static_cast<T>(v.x);
		this->z *= static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator*=(vec<3, U, Q> const& v)
	{
		this->x *= static_cast<T>(v.x);
		this->y *= static_cast<T>(v.y);
		this->z *= static_cast<T>(v.z);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator/=(U v)
	{
		this->x /= static_cast<T>(v);
		this->y /= static_cast<T>(v);
		this->z /= static_cast<T>(v);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator/=(vec<1, U, Q> const& v)
	{
		this->x /= static_cast<T>(v.x);
		this->y /= static_cast<T>(v.x);
		this->z /= static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator/=(vec<3, U, Q> const& v)
	{
		this->x /= static_cast<T>(v.x);
		this->y /= static_cast<T>(v.y);
		this->z /= static_cast<T>(v.z);
		return *this;
	}

	

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator++()
	{
		++this->x;
		++this->y;
		++this->z;
		return *this;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator--()
	{
		--this->x;
		--this->y;
		--this->z;
		return *this;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> vec<3, T, Q>::operator++(int)
	{
		vec<3, T, Q> Result(*this);
		++*this;
		return Result;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> vec<3, T, Q>::operator--(int)
	{
		vec<3, T, Q> Result(*this);
		--*this;
		return Result;
	}

	

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator%=(U scalar)
	{
		this->x %= scalar;
		this->y %= scalar;
		this->z %= scalar;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator%=(vec<1, U, Q> const& v)
	{
		this->x %= v.x;
		this->y %= v.x;
		this->z %= v.x;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator%=(vec<3, U, Q> const& v)
	{
		this->x %= v.x;
		this->y %= v.y;
		this->z %= v.z;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator&=(U scalar)
	{
		this->x &= scalar;
		this->y &= scalar;
		this->z &= scalar;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator&=(vec<1, U, Q> const& v)
	{
		this->x &= v.x;
		this->y &= v.x;
		this->z &= v.x;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator&=(vec<3, U, Q> const& v)
	{
		this->x &= v.x;
		this->y &= v.y;
		this->z &= v.z;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator|=(U scalar)
	{
		this->x |= scalar;
		this->y |= scalar;
		this->z |= scalar;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator|=(vec<1, U, Q> const& v)
	{
		this->x |= v.x;
		this->y |= v.x;
		this->z |= v.x;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator|=(vec<3, U, Q> const& v)
	{
		this->x |= v.x;
		this->y |= v.y;
		this->z |= v.z;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator^=(U scalar)
	{
		this->x ^= scalar;
		this->y ^= scalar;
		this->z ^= scalar;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator^=(vec<1, U, Q> const& v)
	{
		this->x ^= v.x;
		this->y ^= v.x;
		this->z ^= v.x;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator^=(vec<3, U, Q> const& v)
	{
		this->x ^= v.x;
		this->y ^= v.y;
		this->z ^= v.z;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator<<=(U scalar)
	{
		this->x <<= scalar;
		this->y <<= scalar;
		this->z <<= scalar;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator<<=(vec<1, U, Q> const& v)
	{
		this->x <<= static_cast<T>(v.x);
		this->y <<= static_cast<T>(v.x);
		this->z <<= static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator<<=(vec<3, U, Q> const& v)
	{
		this->x <<= static_cast<T>(v.x);
		this->y <<= static_cast<T>(v.y);
		this->z <<= static_cast<T>(v.z);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator>>=(U scalar)
	{
		this->x >>= static_cast<T>(scalar);
		this->y >>= static_cast<T>(scalar);
		this->z >>= static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator>>=(vec<1, U, Q> const& v)
	{
		this->x >>= static_cast<T>(v.x);
		this->y >>= static_cast<T>(v.x);
		this->z >>= static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator>>=(vec<3, U, Q> const& v)
	{
		this->x >>= static_cast<T>(v.x);
		this->y >>= static_cast<T>(v.y);
		this->z >>= static_cast<T>(v.z);
		return *this;
	}

	

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v)
	{
		return v;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			-v.x,
			-v.y,
			-v.z);
	}

	

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v, T scalar)
	{
		return vec<3, T, Q>(
			v.x + scalar,
			v.y + scalar,
			v.z + scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
	{
		return vec<3, T, Q>(
			v.x + scalar.x,
			v.y + scalar.x,
			v.z + scalar.x);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator+(T scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar + v.x,
			scalar + v.y,
			scalar + v.z);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator+(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar.x + v.x,
			scalar.x + v.y,
			scalar.x + v.z);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
	{
		return vec<3, T, Q>(
			v1.x + v2.x,
			v1.y + v2.y,
			v1.z + v2.z);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v, T scalar)
	{
		return vec<3, T, Q>(
			v.x - scalar,
			v.y - scalar,
			v.z - scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
	{
		return vec<3, T, Q>(
			v.x - scalar.x,
			v.y - scalar.x,
			v.z - scalar.x);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator-(T scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar - v.x,
			scalar - v.y,
			scalar - v.z);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator-(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar.x - v.x,
			scalar.x - v.y,
			scalar.x - v.z);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
	{
		return vec<3, T, Q>(
			v1.x - v2.x,
			v1.y - v2.y,
			v1.z - v2.z);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator*(vec<3, T, Q> const& v, T scalar)
	{
		return vec<3, T, Q>(
			v.x * scalar,
			v.y * scalar,
			v.z * scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator*(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
	{
		return vec<3, T, Q>(
			v.x * scalar.x,
			v.y * scalar.x,
			v.z * scalar.x);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator*(T scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar * v.x,
			scalar * v.y,
			scalar * v.z);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator*(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar.x * v.x,
			scalar.x * v.y,
			scalar.x * v.z);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator*(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
	{
		return vec<3, T, Q>(
			v1.x * v2.x,
			v1.y * v2.y,
			v1.z * v2.z);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator/(vec<3, T, Q> const& v, T scalar)
	{
		return vec<3, T, Q>(
			v.x / scalar,
			v.y / scalar,
			v.z / scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator/(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
	{
		return vec<3, T, Q>(
			v.x / scalar.x,
			v.y / scalar.x,
			v.z / scalar.x);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator/(T scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar / v.x,
			scalar / v.y,
			scalar / v.z);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator/(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar.x / v.x,
			scalar.x / v.y,
			scalar.x / v.z);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator/(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
	{
		return vec<3, T, Q>(
			v1.x / v2.x,
			v1.y / v2.y,
			v1.z / v2.z);
	}

	

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator%(vec<3, T, Q> const& v, T scalar)
	{
		return vec<3, T, Q>(
			v.x % scalar,
			v.y % scalar,
			v.z % scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator%(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
	{
		return vec<3, T, Q>(
			v.x % scalar.x,
			v.y % scalar.x,
			v.z % scalar.x);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator%(T scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar % v.x,
			scalar % v.y,
			scalar % v.z);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator%(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar.x % v.x,
			scalar.x % v.y,
			scalar.x % v.z);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator%(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
	{
		return vec<3, T, Q>(
			v1.x % v2.x,
			v1.y % v2.y,
			v1.z % v2.z);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator&(vec<3, T, Q> const& v, T scalar)
	{
		return vec<3, T, Q>(
			v.x & scalar,
			v.y & scalar,
			v.z & scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator&(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
	{
		return vec<3, T, Q>(
			v.x & scalar.x,
			v.y & scalar.x,
			v.z & scalar.x);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator&(T scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar & v.x,
			scalar & v.y,
			scalar & v.z);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator&(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar.x & v.x,
			scalar.x & v.y,
			scalar.x & v.z);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator&(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
	{
		return vec<3, T, Q>(
			v1.x & v2.x,
			v1.y & v2.y,
			v1.z & v2.z);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator|(vec<3, T, Q> const& v, T scalar)
	{
		return vec<3, T, Q>(
			v.x | scalar,
			v.y | scalar,
			v.z | scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator|(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
	{
		return vec<3, T, Q>(
			v.x | scalar.x,
			v.y | scalar.x,
			v.z | scalar.x);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator|(T scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar | v.x,
			scalar | v.y,
			scalar | v.z);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator|(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar.x | v.x,
			scalar.x | v.y,
			scalar.x | v.z);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator|(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
	{
		return vec<3, T, Q>(
			v1.x | v2.x,
			v1.y | v2.y,
			v1.z | v2.z);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator^(vec<3, T, Q> const& v, T scalar)
	{
		return vec<3, T, Q>(
			v.x ^ scalar,
			v.y ^ scalar,
			v.z ^ scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator^(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
	{
		return vec<3, T, Q>(
			v.x ^ scalar.x,
			v.y ^ scalar.x,
			v.z ^ scalar.x);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator^(T scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar ^ v.x,
			scalar ^ v.y,
			scalar ^ v.z);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator^(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar.x ^ v.x,
			scalar.x ^ v.y,
			scalar.x ^ v.z);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator^(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
	{
		return vec<3, T, Q>(
			v1.x ^ v2.x,
			v1.y ^ v2.y,
			v1.z ^ v2.z);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator<<(vec<3, T, Q> const& v, T scalar)
	{
		return vec<3, T, Q>(
			v.x << scalar,
			v.y << scalar,
			v.z << scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator<<(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
	{
		return vec<3, T, Q>(
			v.x << scalar.x,
			v.y << scalar.x,
			v.z << scalar.x);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator<<(T scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar << v.x,
			scalar << v.y,
			scalar << v.z);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator<<(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar.x << v.x,
			scalar.x << v.y,
			scalar.x << v.z);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator<<(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
	{
		return vec<3, T, Q>(
			v1.x << v2.x,
			v1.y << v2.y,
			v1.z << v2.z);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator>>(vec<3, T, Q> const& v, T scalar)
	{
		return vec<3, T, Q>(
			v.x >> scalar,
			v.y >> scalar,
			v.z >> scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator>>(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
	{
		return vec<3, T, Q>(
			v.x >> scalar.x,
			v.y >> scalar.x,
			v.z >> scalar.x);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator>>(T scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar >> v.x,
			scalar >> v.y,
			scalar >> v.z);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator>>(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar.x >> v.x,
			scalar.x >> v.y,
			scalar.x >> v.z);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator>>(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
	{
		return vec<3, T, Q>(
			v1.x >> v2.x,
			v1.y >> v2.y,
			v1.z >> v2.z);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator~(vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			~v.x,
			~v.y,
			~v.z);
	}

	

	template<typename T, qualifier Q>
	inline constexpr bool operator==(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
	{
		return
			detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.x, v2.x) &&
			detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.y, v2.y) &&
			detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.z, v2.z);
	}

	template<typename T, qualifier Q>
	inline constexpr bool operator!=(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
	{
		return !(v1 == v2);
	}

	template<qualifier Q>
	inline constexpr vec<3, bool, Q> operator&&(vec<3, bool, Q> const& v1, vec<3, bool, Q> const& v2)
	{
		return vec<3, bool, Q>(v1.x && v2.x, v1.y && v2.y, v1.z && v2.z);
	}

	template<qualifier Q>
	inline constexpr vec<3, bool, Q> operator||(vec<3, bool, Q> const& v1, vec<3, bool, Q> const& v2)
	{
		return vec<3, bool, Q>(v1.x || v2.x, v1.y || v2.y, v1.z || v2.z);
	}
}
#line 436 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec3.hpp"
#line 437 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec3.hpp"
#line 6 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_bool3.hpp"

namespace glm
{
	
	

	
	
	
	typedef vec<3, bool, defaultp>		bvec3;

	
}
#line 6 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\vec3.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_bool3_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef vec<3, bool, highp>		highp_bvec3;

	
	
	
	
	typedef vec<3, bool, mediump>	mediump_bvec3;

	
	
	
	
	typedef vec<3, bool, lowp>		lowp_bvec3;

	
}
#line 7 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\vec3.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_float3.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef vec<3, float, defaultp>		vec3;

	
}
#line 8 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\vec3.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_float3_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef vec<3, float, highp>		highp_vec3;

	
	
	
	
	typedef vec<3, float, mediump>		mediump_vec3;

	
	
	
	
	typedef vec<3, float, lowp>			lowp_vec3;

	
}
#line 9 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\vec3.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_double3.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef vec<3, double, defaultp>		dvec3;

	
}
#line 10 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\vec3.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_double3_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	
	typedef vec<3, double, highp>		highp_dvec3;

	
	
	
	
	
	typedef vec<3, double, mediump>		mediump_dvec3;

	
	
	
	
	
	typedef vec<3, double, lowp>		lowp_dvec3;

	
}
#line 11 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\vec3.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_int3.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef vec<3, int, defaultp>		ivec3;

	
}
#line 12 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\vec3.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_int3_sized.hpp"













#pragma once






#line 22 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_int3_sized.hpp"

namespace glm
{
	
	

	
	
	
	typedef vec<3, int8, defaultp>		i8vec3;

	
	
	
	typedef vec<3, int16, defaultp>		i16vec3;

	
	
	
	typedef vec<3, int32, defaultp>		i32vec3;

	
	
	
	typedef vec<3, int64, defaultp>		i64vec3;

	
}
#line 13 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\vec3.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_uint3.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef vec<3, unsigned int, defaultp>		uvec3;

	
}
#line 14 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\vec3.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_uint3_sized.hpp"













#pragma once






#line 22 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_uint3_sized.hpp"

namespace glm
{
	
	

	
	
	
	typedef vec<3, uint8, defaultp>		u8vec3;

	
	
	
	typedef vec<3, uint16, defaultp>	u16vec3;

	
	
	
	typedef vec<3, uint32, defaultp>	u32vec3;

	
	
	
	typedef vec<3, uint64, defaultp>	u64vec3;

	
}
#line 15 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\vec3.hpp"
#line 119 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\glm.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\vec4.hpp"



#pragma once
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_bool4.hpp"



#pragma once
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec4.hpp"



#pragma once




#line 10 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec4.hpp"

#line 12 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec4.hpp"


namespace glm
{
	template<typename T, qualifier Q>
	struct vec<4, T, Q>
	{
		

		typedef T value_type;
		typedef vec<4, T, Q> type;
		typedef vec<4, bool, Q> bool_type;

		





#line 32 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec4.hpp"



#line 36 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec4.hpp"
#pragma warning(push)
#pragma warning(disable: 4201)  
#line 39 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec4.hpp"
#line 40 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec4.hpp"






#line 47 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec4.hpp"




















#line 68 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec4.hpp"
			union { T x, r, s; };
			union { T y, g, t; };
			union { T z, b, p; };
			union { T w, a, q; };



#line 76 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec4.hpp"
#line 77 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec4.hpp"




#line 82 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec4.hpp"

#line 84 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec4.hpp"
#pragma warning(pop)
#line 86 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec4.hpp"
#line 87 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec4.hpp"

		

		typedef length_t length_type;

		
		[[nodiscard]] static constexpr length_type length(){return 4;}

		[[nodiscard]] constexpr T & operator[](length_type i);
		[[nodiscard]] constexpr T const& operator[](length_type i) const;

		

		 constexpr vec() = default ;
		 constexpr vec(vec<4, T, Q> const& v) = default ;
		template<qualifier P>
		constexpr vec(vec<4, T, P> const& v);

		

		constexpr explicit vec(T scalar);
		constexpr vec(T x, T y, T z, T w);

		

		template<typename U, qualifier P>
		constexpr explicit vec(vec<1, U, P> const& v);

		
		template<typename X, typename Y, typename Z, typename W>
		constexpr vec(X _x, Y _y, Z _z, W _w);
		template<typename X, typename Y, typename Z, typename W>
		constexpr vec(vec<1, X, Q> const& _x, Y _y, Z _z, W _w);
		template<typename X, typename Y, typename Z, typename W>
		constexpr vec(X _x, vec<1, Y, Q> const& _y, Z _z, W _w);
		template<typename X, typename Y, typename Z, typename W>
		constexpr vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, Z _z, W _w);
		template<typename X, typename Y, typename Z, typename W>
		constexpr vec(X _x, Y _y, vec<1, Z, Q> const& _z, W _w);
		template<typename X, typename Y, typename Z, typename W>
		constexpr vec(vec<1, X, Q> const& _x, Y _y, vec<1, Z, Q> const& _z, W _w);
		template<typename X, typename Y, typename Z, typename W>
		constexpr vec(X _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, W _w);
		template<typename X, typename Y, typename Z, typename W>
		constexpr vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, W _w);
		template<typename X, typename Y, typename Z, typename W>
		constexpr vec(vec<1, X, Q> const& _x, Y _y, Z _z, vec<1, W, Q> const& _w);
		template<typename X, typename Y, typename Z, typename W>
		constexpr vec(X _x, vec<1, Y, Q> const& _y, Z _z, vec<1, W, Q> const& _w);
		template<typename X, typename Y, typename Z, typename W>
		constexpr vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, Z _z, vec<1, W, Q> const& _w);
		template<typename X, typename Y, typename Z, typename W>
		constexpr vec(X _x, Y _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w);
		template<typename X, typename Y, typename Z, typename W>
		constexpr vec(vec<1, X, Q> const& _x, Y _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w);
		template<typename X, typename Y, typename Z, typename W>
		constexpr vec(X _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w);
		template<typename X, typename Y, typename Z, typename W>
		constexpr vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w);

		

		
		template<typename A, typename B, typename C, qualifier P>
		constexpr vec(vec<2, A, P> const& _xy, B _z, C _w);
		
		template<typename A, typename B, typename C, qualifier P>
		constexpr vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z, C _w);
		
		template<typename A, typename B, typename C, qualifier P>
		constexpr vec(vec<2, A, P> const& _xy, B _z, vec<1, C, P> const& _w);
		
		template<typename A, typename B, typename C, qualifier P>
		constexpr vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z, vec<1, C, P> const& _w);
		
		template<typename A, typename B, typename C, qualifier P>
		constexpr vec(A _x, vec<2, B, P> const& _yz, C _w);
		
		template<typename A, typename B, typename C, qualifier P>
		constexpr vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz, C _w);
		
		template<typename A, typename B, typename C, qualifier P>
		constexpr vec(A _x, vec<2, B, P> const& _yz, vec<1, C, P> const& _w);
		
		template<typename A, typename B, typename C, qualifier P>
		constexpr vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz, vec<1, C, P> const& _w);
		
		template<typename A, typename B, typename C, qualifier P>
		constexpr vec(A _x, B _y, vec<2, C, P> const& _zw);
		
		template<typename A, typename B, typename C, qualifier P>
		constexpr vec(vec<1, A, P> const& _x, B _y, vec<2, C, P> const& _zw);
		
		template<typename A, typename B, typename C, qualifier P>
		constexpr vec(A _x, vec<1, B, P> const& _y, vec<2, C, P> const& _zw);
		
		template<typename A, typename B, typename C, qualifier P>
		constexpr vec(vec<1, A, P> const& _x, vec<1, B, P> const& _y, vec<2, C, P> const& _zw);
		
		template<typename A, typename B, qualifier P>
		constexpr vec(vec<3, A, P> const& _xyz, B _w);
		
		template<typename A, typename B, qualifier P>
		constexpr vec(vec<3, A, P> const& _xyz, vec<1, B, P> const& _w);
		
		template<typename A, typename B, qualifier P>
		constexpr vec(A _x, vec<3, B, P> const& _yzw);
		
		template<typename A, typename B, qualifier P>
		constexpr vec(vec<1, A, P> const& _x, vec<3, B, P> const& _yzw);
		
		template<typename A, typename B, qualifier P>
		constexpr vec(vec<2, A, P> const& _xy, vec<2, B, P> const& _zw);

		
		template<typename U, qualifier P>
		constexpr  vec(vec<4, U, P> const& v);

		










































#line 249 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec4.hpp"

		

		 constexpr vec<4, T, Q>& operator=(vec<4, T, Q> const& v) = default ;

		template<typename U>
		 constexpr vec<4, T, Q>& operator=(vec<4, U, Q> const& v);
		template<typename U>
		 constexpr vec<4, T, Q>& operator+=(U scalar);
		template<typename U>
		 constexpr vec<4, T, Q>& operator+=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<4, T, Q>& operator+=(vec<4, U, Q> const& v);
		template<typename U>
		 constexpr vec<4, T, Q>& operator-=(U scalar);
		template<typename U>
		 constexpr vec<4, T, Q>& operator-=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<4, T, Q>& operator-=(vec<4, U, Q> const& v);
		template<typename U>
		 constexpr vec<4, T, Q>& operator*=(U scalar);
		template<typename U>
		 constexpr vec<4, T, Q>& operator*=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<4, T, Q>& operator*=(vec<4, U, Q> const& v);
		template<typename U>
		 constexpr vec<4, T, Q>& operator/=(U scalar);
		template<typename U>
		 constexpr vec<4, T, Q>& operator/=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<4, T, Q>& operator/=(vec<4, U, Q> const& v);

		

		 constexpr vec<4, T, Q> & operator++();
		 constexpr vec<4, T, Q> & operator--();
		[[nodiscard]] constexpr vec<4, T, Q> operator++(int);
		[[nodiscard]] constexpr vec<4, T, Q> operator--(int);

		

		template<typename U>
		[[nodiscard]] constexpr vec<4, T, Q> & operator%=(U scalar);
		template<typename U>
		[[nodiscard]] constexpr vec<4, T, Q> & operator%=(vec<1, U, Q> const& v);
		template<typename U>
		[[nodiscard]] constexpr vec<4, T, Q> & operator%=(vec<4, U, Q> const& v);
		template<typename U>
		[[nodiscard]] constexpr vec<4, T, Q> & operator&=(U scalar);
		template<typename U>
		[[nodiscard]] constexpr vec<4, T, Q> & operator&=(vec<1, U, Q> const& v);
		template<typename U>
		[[nodiscard]] constexpr vec<4, T, Q> & operator&=(vec<4, U, Q> const& v);
		template<typename U>
		[[nodiscard]] constexpr vec<4, T, Q> & operator|=(U scalar);
		template<typename U>
		[[nodiscard]] constexpr vec<4, T, Q> & operator|=(vec<1, U, Q> const& v);
		template<typename U>
		[[nodiscard]] constexpr vec<4, T, Q> & operator|=(vec<4, U, Q> const& v);
		template<typename U>
		[[nodiscard]] constexpr vec<4, T, Q> & operator^=(U scalar);
		template<typename U>
		[[nodiscard]] constexpr vec<4, T, Q> & operator^=(vec<1, U, Q> const& v);
		template<typename U>
		[[nodiscard]] constexpr vec<4, T, Q> & operator^=(vec<4, U, Q> const& v);
		template<typename U>
		[[nodiscard]] constexpr vec<4, T, Q> & operator<<=(U scalar);
		template<typename U>
		[[nodiscard]] constexpr vec<4, T, Q> & operator<<=(vec<1, U, Q> const& v);
		template<typename U>
		[[nodiscard]] constexpr vec<4, T, Q> & operator<<=(vec<4, U, Q> const& v);
		template<typename U>
		[[nodiscard]] constexpr vec<4, T, Q> & operator>>=(U scalar);
		template<typename U>
		[[nodiscard]] constexpr vec<4, T, Q> & operator>>=(vec<1, U, Q> const& v);
		template<typename U>
		[[nodiscard]] constexpr vec<4, T, Q> & operator>>=(vec<4, U, Q> const& v);
	};

	

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v);

	

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator+(T scalar, vec<4, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator+(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator-(T scalar, vec<4, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator-(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator*(vec<4, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator*(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator*(T scalar, vec<4, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator*(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator*(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator/(vec<4, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator/(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator/(T scalar, vec<4, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator/(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator/(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator%(vec<4, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator%(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator%(T scalar, vec<4, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator%(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator%(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator&(vec<4, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator&(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator&(T scalar, vec<4, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator&(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator&(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator|(vec<4, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator|(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator|(T scalar, vec<4, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator|(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator|(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator^(vec<4, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator^(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator^(T scalar, vec<4, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator^(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator^(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator<<(vec<4, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator<<(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator<<(T scalar, vec<4, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator<<(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator<<(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator>>(vec<4, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator>>(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator>>(T scalar, vec<4, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator>>(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator>>(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator~(vec<4, T, Q> const& v);

	

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr bool operator==(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr bool operator!=(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

	template<qualifier Q>
	[[nodiscard]] constexpr vec<4, bool, Q> operator&&(vec<4, bool, Q> const& v1, vec<4, bool, Q> const& v2);

	template<qualifier Q>
	[[nodiscard]] constexpr vec<4, bool, Q> operator||(vec<4, bool, Q> const& v1, vec<4, bool, Q> const& v2);
}


#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec4.inl"




namespace glm{
namespace detail
{
	template<typename T, qualifier Q, bool Aligned>
	struct compute_vec4_add
	{
		inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
		{
			return vec<4, T, Q>(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);
		}
	};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_vec4_sub
	{
		inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
		{
			return vec<4, T, Q>(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);
		}
	};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_vec4_mul
	{
		inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
		{
			return vec<4, T, Q>(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);
		}
	};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_vec4_div
	{
		inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
		{
			return vec<4, T, Q>(a.x / b.x, a.y / b.y, a.z / b.z, a.w / b.w);
		}
	};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_vec4_mod
	{
		inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
		{
			return vec<4, T, Q>(a.x % b.x, a.y % b.y, a.z % b.z, a.w % b.w);
		}
	};

	template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_and
	{
		inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
		{
			return vec<4, T, Q>(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);
		}
	};

	template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_or
	{
		inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
		{
			return vec<4, T, Q>(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);
		}
	};

	template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_xor
	{
		inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
		{
			return vec<4, T, Q>(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);
		}
	};

	template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_shift_left
	{
		inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
		{
			return vec<4, T, Q>(a.x << b.x, a.y << b.y, a.z << b.z, a.w << b.w);
		}
	};

	template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_shift_right
	{
		inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
		{
			return vec<4, T, Q>(a.x >> b.x, a.y >> b.y, a.z >> b.z, a.w >> b.w);
		}
	};

	template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_equal
	{
		inline constexpr static bool call(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
		{
			return
				detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.x, v2.x) &&
				detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.y, v2.y) &&
				detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.z, v2.z) &&
				detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.w, v2.w);
		}
	};

	template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_nequal
	{
		inline constexpr static bool call(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
		{
			return !compute_vec4_equal<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(v1, v2);
		}
	};

	template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_bitwise_not
	{
		inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& v)
		{
			return vec<4, T, Q>(~v.x, ~v.y, ~v.z, ~v.w);
		}
	};
}

	








#line 140 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec4.inl"






#line 147 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec4.inl"

	template<typename T, qualifier Q>
	template<qualifier P>
	inline constexpr vec<4, T, Q>::vec(vec<4, T, P> const& v)
		: x(v.x), y(v.y), z(v.z), w(v.w)
	{}

	

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q>::vec(T scalar)
		: x(scalar), y(scalar), z(scalar), w(scalar)
	{}

	template <typename T, qualifier Q>
	inline constexpr vec<4, T, Q>::vec(T _x, T _y, T _z, T _w)
		: x(_x), y(_y), z(_z), w(_w)
	{}

	

	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	inline constexpr vec<4, T, Q>::vec(vec<1, U, P> const& v)
		: x(static_cast<T>(v.x))
		, y(static_cast<T>(v.x))
		, z(static_cast<T>(v.x))
		, w(static_cast<T>(v.x))
	{}

	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z, typename W>
	inline constexpr vec<4, T, Q>::vec(X _x, Y _y, Z _z, W _w)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_y))
		, z(static_cast<T>(_z))
		, w(static_cast<T>(_w))
	{}

	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z, typename W>
	inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, Y _y, Z _z, W _w)
		: x(static_cast<T>(_x.x))
		, y(static_cast<T>(_y))
		, z(static_cast<T>(_z))
		, w(static_cast<T>(_w))
	{}

	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z, typename W>
	inline constexpr vec<4, T, Q>::vec(X _x, vec<1, Y, Q> const& _y, Z _z, W _w)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_y.x))
		, z(static_cast<T>(_z))
		, w(static_cast<T>(_w))
	{}

	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z, typename W>
	inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, Z _z, W _w)
		: x(static_cast<T>(_x.x))
		, y(static_cast<T>(_y.x))
		, z(static_cast<T>(_z))
		, w(static_cast<T>(_w))
	{}

	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z, typename W>
	inline constexpr vec<4, T, Q>::vec(X _x, Y _y, vec<1, Z, Q> const& _z, W _w)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_y))
		, z(static_cast<T>(_z.x))
		, w(static_cast<T>(_w))
	{}

	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z, typename W>
	inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, Y _y, vec<1, Z, Q> const& _z, W _w)
		: x(static_cast<T>(_x.x))
		, y(static_cast<T>(_y))
		, z(static_cast<T>(_z.x))
		, w(static_cast<T>(_w))
	{}

	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z, typename W>
	inline constexpr vec<4, T, Q>::vec(X _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, W _w)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_y.x))
		, z(static_cast<T>(_z.x))
		, w(static_cast<T>(_w))
	{}

	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z, typename W>
	inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, W _w)
		: x(static_cast<T>(_x.x))
		, y(static_cast<T>(_y.x))
		, z(static_cast<T>(_z.x))
		, w(static_cast<T>(_w))
	{}

	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z, typename W>
	inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, Y _y, Z _z, vec<1, W, Q> const& _w)
		: x(static_cast<T>(_x.x))
		, y(static_cast<T>(_y))
		, z(static_cast<T>(_z))
		, w(static_cast<T>(_w.x))
	{}

	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z, typename W>
	inline constexpr vec<4, T, Q>::vec(X _x, vec<1, Y, Q> const& _y, Z _z, vec<1, W, Q> const& _w)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_y.x))
		, z(static_cast<T>(_z))
		, w(static_cast<T>(_w.x))
	{}

	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z, typename W>
	inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, Z _z, vec<1, W, Q> const& _w)
		: x(static_cast<T>(_x.x))
		, y(static_cast<T>(_y.x))
		, z(static_cast<T>(_z))
		, w(static_cast<T>(_w.x))
	{}

	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z, typename W>
	inline constexpr vec<4, T, Q>::vec(X _x, Y _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_y))
		, z(static_cast<T>(_z.x))
		, w(static_cast<T>(_w.x))
	{}

	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z, typename W>
	inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, Y _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w)
		: x(static_cast<T>(_x.x))
		, y(static_cast<T>(_y))
		, z(static_cast<T>(_z.x))
		, w(static_cast<T>(_w.x))
	{}

	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z, typename W>
	inline constexpr vec<4, T, Q>::vec(X _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_y.x))
		, z(static_cast<T>(_z.x))
		, w(static_cast<T>(_w.x))
	{}

	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z, typename W>
	inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w)
		: x(static_cast<T>(_x.x))
		, y(static_cast<T>(_y.x))
		, z(static_cast<T>(_z.x))
		, w(static_cast<T>(_w.x))
	{}

	

	template<typename T, qualifier Q>
	template<typename A, typename B, typename C, qualifier P>
	inline constexpr vec<4, T, Q>::vec(vec<2, A, P> const& _xy, B _z, C _w)
		: x(static_cast<T>(_xy.x))
		, y(static_cast<T>(_xy.y))
		, z(static_cast<T>(_z))
		, w(static_cast<T>(_w))
	{}

	template<typename T, qualifier Q>
	template<typename A, typename B, typename C, qualifier P>
	inline constexpr vec<4, T, Q>::vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z, C _w)
		: x(static_cast<T>(_xy.x))
		, y(static_cast<T>(_xy.y))
		, z(static_cast<T>(_z.x))
		, w(static_cast<T>(_w))
	{}

	template<typename T, qualifier Q>
	template<typename A, typename B, typename C, qualifier P>
	inline constexpr vec<4, T, Q>::vec(vec<2, A, P> const& _xy, B _z, vec<1, C, P> const& _w)
		: x(static_cast<T>(_xy.x))
		, y(static_cast<T>(_xy.y))
		, z(static_cast<T>(_z))
		, w(static_cast<T>(_w.x))
	{}

	template<typename T, qualifier Q>
	template<typename A, typename B, typename C, qualifier P>
	inline constexpr vec<4, T, Q>::vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z, vec<1, C, P> const& _w)
		: x(static_cast<T>(_xy.x))
		, y(static_cast<T>(_xy.y))
		, z(static_cast<T>(_z.x))
		, w(static_cast<T>(_w.x))
	{}

	template<typename T, qualifier Q>
	template<typename A, typename B, typename C, qualifier P>
	inline constexpr vec<4, T, Q>::vec(A _x, vec<2, B, P> const& _yz, C _w)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_yz.x))
		, z(static_cast<T>(_yz.y))
		, w(static_cast<T>(_w))
	{}

	template<typename T, qualifier Q>
	template<typename A, typename B, typename C, qualifier P>
	inline constexpr vec<4, T, Q>::vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz, C _w)
		: x(static_cast<T>(_x.x))
		, y(static_cast<T>(_yz.x))
		, z(static_cast<T>(_yz.y))
		, w(static_cast<T>(_w))
	{}

	template<typename T, qualifier Q>
	template<typename A, typename B, typename C, qualifier P>
	inline constexpr vec<4, T, Q>::vec(A _x, vec<2, B, P> const& _yz, vec<1, C, P> const& _w)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_yz.x))
		, z(static_cast<T>(_yz.y))
		, w(static_cast<T>(_w.x))
	{}

	template<typename T, qualifier Q>
	template<typename A, typename B, typename C, qualifier P>
	inline constexpr vec<4, T, Q>::vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz, vec<1, C, P> const& _w)
		: x(static_cast<T>(_x.x))
		, y(static_cast<T>(_yz.x))
		, z(static_cast<T>(_yz.y))
		, w(static_cast<T>(_w.x))
	{}

	template<typename T, qualifier Q>
	template<typename A, typename B, typename C, qualifier P>
	inline constexpr vec<4, T, Q>::vec(A _x, B _y, vec<2, C, P> const& _zw)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_y))
		, z(static_cast<T>(_zw.x))
		, w(static_cast<T>(_zw.y))
	{}

	template<typename T, qualifier Q>
	template<typename A, typename B, typename C, qualifier P>
	inline constexpr vec<4, T, Q>::vec(vec<1, A, P> const& _x, B _y, vec<2, C, P> const& _zw)
		: x(static_cast<T>(_x.x))
		, y(static_cast<T>(_y))
		, z(static_cast<T>(_zw.x))
		, w(static_cast<T>(_zw.y))
	{}

	template<typename T, qualifier Q>
	template<typename A, typename B, typename C, qualifier P>
	inline constexpr vec<4, T, Q>::vec(A _x, vec<1, B, P> const& _y, vec<2, C, P> const& _zw)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_y.x))
		, z(static_cast<T>(_zw.x))
		, w(static_cast<T>(_zw.y))
	{}

	template<typename T, qualifier Q>
	template<typename A, typename B, typename C, qualifier P>
	inline constexpr vec<4, T, Q>::vec(vec<1, A, P> const& _x, vec<1, B, P> const& _y, vec<2, C, P> const& _zw)
		: x(static_cast<T>(_x.x))
		, y(static_cast<T>(_y.x))
		, z(static_cast<T>(_zw.x))
		, w(static_cast<T>(_zw.y))
	{}

	template<typename T, qualifier Q>
	template<typename A, typename B, qualifier P>
	inline constexpr vec<4, T, Q>::vec(vec<3, A, P> const& _xyz, B _w)
		: x(static_cast<T>(_xyz.x))
		, y(static_cast<T>(_xyz.y))
		, z(static_cast<T>(_xyz.z))
		, w(static_cast<T>(_w))
	{}

	template<typename T, qualifier Q>
	template<typename A, typename B, qualifier P>
	inline constexpr vec<4, T, Q>::vec(vec<3, A, P> const& _xyz, vec<1, B, P> const& _w)
		: x(static_cast<T>(_xyz.x))
		, y(static_cast<T>(_xyz.y))
		, z(static_cast<T>(_xyz.z))
		, w(static_cast<T>(_w.x))
	{}

	template<typename T, qualifier Q>
	template<typename A, typename B, qualifier P>
	inline constexpr vec<4, T, Q>::vec(A _x, vec<3, B, P> const& _yzw)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_yzw.x))
		, z(static_cast<T>(_yzw.y))
		, w(static_cast<T>(_yzw.z))
	{}

	template<typename T, qualifier Q>
	template<typename A, typename B, qualifier P>
	inline constexpr vec<4, T, Q>::vec(vec<1, A, P> const& _x, vec<3, B, P> const& _yzw)
		: x(static_cast<T>(_x.x))
		, y(static_cast<T>(_yzw.x))
		, z(static_cast<T>(_yzw.y))
		, w(static_cast<T>(_yzw.z))
	{}

	template<typename T, qualifier Q>
	template<typename A, typename B, qualifier P>
	inline constexpr vec<4, T, Q>::vec(vec<2, A, P> const& _xy, vec<2, B, P> const& _zw)
		: x(static_cast<T>(_xy.x))
		, y(static_cast<T>(_xy.y))
		, z(static_cast<T>(_zw.x))
		, w(static_cast<T>(_zw.y))
	{}

	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	inline constexpr vec<4, T, Q>::vec(vec<4, U, P> const& v)
		: x(static_cast<T>(v.x))
		, y(static_cast<T>(v.y))
		, z(static_cast<T>(v.z))
		, w(static_cast<T>(v.w))
	{}

	

	template<typename T, qualifier Q>
	inline constexpr T& vec<4, T, Q>::operator[](typename vec<4, T, Q>::length_type i)
	{
		((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec4.inl", (unsigned)(481)), 0) )) ;
		switch(i)
		{
		default:
		case 0:
			return x;
		case 1:
			return y;
		case 2:
			return z;
		case 3:
			return w;
		}
	}

	template<typename T, qualifier Q>
	inline constexpr T const& vec<4, T, Q>::operator[](typename vec<4, T, Q>::length_type i) const
	{
		((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec4.inl", (unsigned)(499)), 0) )) ;
		switch(i)
		{
		default:
		case 0:
			return x;
		case 1:
			return y;
		case 2:
			return z;
		case 3:
			return w;
		}
	}

	











#line 527 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec4.inl"

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<4, T, Q>& vec<4, T, Q>::operator=(vec<4, U, Q> const& v)
	{
		this->x = static_cast<T>(v.x);
		this->y = static_cast<T>(v.y);
		this->z = static_cast<T>(v.z);
		this->w = static_cast<T>(v.w);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator+=(U scalar)
	{
		return (*this = detail::compute_vec4_add<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator+=(vec<1, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_add<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v.x)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator+=(vec<4, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_add<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator-=(U scalar)
	{
		return (*this = detail::compute_vec4_sub<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator-=(vec<1, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_sub<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v.x)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator-=(vec<4, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_sub<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator*=(U scalar)
	{
		return (*this = detail::compute_vec4_mul<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator*=(vec<1, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_mul<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v.x)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator*=(vec<4, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_mul<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator/=(U scalar)
	{
		return (*this = detail::compute_vec4_div<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator/=(vec<1, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_div<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v.x)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator/=(vec<4, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_div<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}

	

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator++()
	{
		++this->x;
		++this->y;
		++this->z;
		++this->w;
		return *this;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator--()
	{
		--this->x;
		--this->y;
		--this->z;
		--this->w;
		return *this;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> vec<4, T, Q>::operator++(int)
	{
		vec<4, T, Q> Result(*this);
		++*this;
		return Result;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> vec<4, T, Q>::operator--(int)
	{
		vec<4, T, Q> Result(*this);
		--*this;
		return Result;
	}

	

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator%=(U scalar)
	{
		return (*this = detail::compute_vec4_mod<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator%=(vec<1, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_mod<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator%=(vec<4, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_mod<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator&=(U scalar)
	{
		return (*this = detail::compute_vec4_and<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator&=(vec<1, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_and<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator&=(vec<4, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_and<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator|=(U scalar)
	{
		return (*this = detail::compute_vec4_or<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator|=(vec<1, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_or<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator|=(vec<4, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_or<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator^=(U scalar)
	{
		return (*this = detail::compute_vec4_xor<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator^=(vec<1, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_xor<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator^=(vec<4, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_xor<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator<<=(U scalar)
	{
		return (*this = detail::compute_vec4_shift_left<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator<<=(vec<1, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_shift_left<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator<<=(vec<4, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_shift_left<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator>>=(U scalar)
	{
		return (*this = detail::compute_vec4_shift_right<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator>>=(vec<1, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_shift_right<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator>>=(vec<4, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_shift_right<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}

	

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v)
	{
		return v;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v)
	{
		return vec<4, T, Q>(0) -= v;
	}

	

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v, T scalar)
	{
		return vec<4, T, Q>(v) += scalar;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) += v2;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator+(T scalar, vec<4, T, Q> const& v)
	{
		return vec<4, T, Q>(v) += scalar;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator+(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v2) += v1;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) += v2;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v, T scalar)
	{
		return vec<4, T, Q>(v) -= scalar;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) -= v2;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator-(T scalar, vec<4, T, Q> const& v)
	{
		return vec<4, T, Q>(scalar) -= v;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator-(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1.x) -= v2;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) -= v2;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator*(vec<4, T, Q> const& v, T scalar)
	{
		return vec<4, T, Q>(v) *= scalar;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator*(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) *= v2;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator*(T scalar, vec<4, T, Q> const& v)
	{
		return vec<4, T, Q>(v) *= scalar;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator*(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v2) *= v1;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator*(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) *= v2;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator/(vec<4, T, Q> const& v, T scalar)
	{
		return vec<4, T, Q>(v) /= scalar;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator/(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) /= v2;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator/(T scalar, vec<4, T, Q> const& v)
	{
		return vec<4, T, Q>(scalar) /= v;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator/(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1.x) /= v2;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator/(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) /= v2;
	}

	

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator%(vec<4, T, Q> const& v, T scalar)
	{
		return vec<4, T, Q>(v) %= scalar;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator%(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) %= v2.x;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator%(T scalar, vec<4, T, Q> const& v)
	{
		return vec<4, T, Q>(scalar) %= v;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator%(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v)
	{
		return vec<4, T, Q>(scalar.x) %= v;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator%(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) %= v2;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator&(vec<4, T, Q> const& v, T scalar)
	{
		return vec<4, T, Q>(v) &= scalar;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator&(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar)
	{
		return vec<4, T, Q>(v) &= scalar;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator&(T scalar, vec<4, T, Q> const& v)
	{
		return vec<4, T, Q>(scalar) &= v;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator&(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1.x) &= v2;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator&(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) &= v2;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator|(vec<4, T, Q> const& v, T scalar)
	{
		return vec<4, T, Q>(v) |= scalar;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator|(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) |= v2.x;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator|(T scalar, vec<4, T, Q> const& v)
	{
		return vec<4, T, Q>(scalar) |= v;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator|(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1.x) |= v2;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator|(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) |= v2;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator^(vec<4, T, Q> const& v, T scalar)
	{
		return vec<4, T, Q>(v) ^= scalar;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator^(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) ^= v2.x;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator^(T scalar, vec<4, T, Q> const& v)
	{
		return vec<4, T, Q>(scalar) ^= v;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator^(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1.x) ^= v2;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator^(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) ^= v2;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator<<(vec<4, T, Q> const& v, T scalar)
	{
		return vec<4, T, Q>(v) <<= scalar;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator<<(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) <<= v2.x;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator<<(T scalar, vec<4, T, Q> const& v)
	{
		return vec<4, T, Q>(scalar) <<= v;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator<<(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1.x) <<= v2;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator<<(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) <<= v2;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator>>(vec<4, T, Q> const& v, T scalar)
	{
		return vec<4, T, Q>(v) >>= scalar;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator>>(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) >>= v2.x;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator>>(T scalar, vec<4, T, Q> const& v)
	{
		return vec<4, T, Q>(scalar) >>= v;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator>>(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1.x) >>= v2;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator>>(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) >>= v2;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator~(vec<4, T, Q> const& v)
	{
		return detail::compute_vec4_bitwise_not<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(v);
	}

	

	template<typename T, qualifier Q>
	inline constexpr bool operator==(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return detail::compute_vec4_equal<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(v1, v2);
	}

	template<typename T, qualifier Q>
	inline constexpr bool operator!=(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return detail::compute_vec4_nequal<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(v1, v2);
	}

	template<qualifier Q>
	inline constexpr vec<4, bool, Q> operator&&(vec<4, bool, Q> const& v1, vec<4, bool, Q> const& v2)
	{
		return vec<4, bool, Q>(v1.x && v2.x, v1.y && v2.y, v1.z && v2.z, v1.w && v2.w);
	}

	template<qualifier Q>
	inline constexpr vec<4, bool, Q> operator||(vec<4, bool, Q> const& v1, vec<4, bool, Q> const& v2)
	{
		return vec<4, bool, Q>(v1.x || v2.x, v1.y || v2.y, v1.z || v2.z, v1.w || v2.w);
	}
}



#line 1143 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec4.inl"
#line 508 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec4.hpp"
#line 509 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec4.hpp"
#line 6 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_bool4.hpp"

namespace glm
{
	
	

	
	
	
	typedef vec<4, bool, defaultp>		bvec4;

	
}
#line 6 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\vec4.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_bool4_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef vec<4, bool, highp>		highp_bvec4;

	
	
	
	
	typedef vec<4, bool, mediump>	mediump_bvec4;

	
	
	
	
	typedef vec<4, bool, lowp>		lowp_bvec4;

	
}
#line 7 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\vec4.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_float4.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef vec<4, float, defaultp>		vec4;

	
}
#line 8 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\vec4.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_float4_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef vec<4, float, highp>		highp_vec4;

	
	
	
	
	typedef vec<4, float, mediump>		mediump_vec4;

	
	
	
	
	typedef vec<4, float, lowp>			lowp_vec4;

	
}
#line 9 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\vec4.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_double4.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef vec<4, double, defaultp>		dvec4;

	
}
#line 10 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\vec4.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_double4_precision.hpp"



#pragma once
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 970 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
























































































































































































































#line 1187 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 1189 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
#line 6 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_double4_precision.hpp"


namespace glm
{
	
	

	
	
	
	
	
	typedef vec<4, double, highp>		highp_dvec4;

	
	
	
	
	
	typedef vec<4, double, mediump>		mediump_dvec4;

	
	
	
	
	
	typedef vec<4, double, lowp>		lowp_dvec4;

	
}
#line 11 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\vec4.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_int4.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef vec<4, int, defaultp>		ivec4;

	
}
#line 12 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\vec4.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_int4_sized.hpp"













#pragma once






#line 22 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_int4_sized.hpp"

namespace glm
{
	
	

	
	
	
	typedef vec<4, int8, defaultp>		i8vec4;

	
	
	
	typedef vec<4, int16, defaultp>		i16vec4;

	
	
	
	typedef vec<4, int32, defaultp>		i32vec4;

	
	
	
	typedef vec<4, int64, defaultp>		i64vec4;

	
}
#line 13 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\vec4.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_uint4.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef vec<4, unsigned int, defaultp>		uvec4;

	
}
#line 14 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\vec4.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_uint4_sized.hpp"













#pragma once






#line 22 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_uint4_sized.hpp"

namespace glm
{
	
	

	
	
	
	typedef vec<4, uint8, defaultp>		u8vec4;

	
	
	
	typedef vec<4, uint16, defaultp>	u16vec4;

	
	
	
	typedef vec<4, uint32, defaultp>	u32vec4;

	
	
	
	typedef vec<4, uint64, defaultp>	u64vec4;

	
}
#line 15 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\vec4.hpp"

#line 120 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\glm.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\mat2x2.hpp"



#pragma once
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_double2x2.hpp"



#pragma once
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x2.hpp"



#pragma once





namespace glm
{
	template<typename T, qualifier Q>
	struct mat<2, 2, T, Q>
	{
		typedef vec<2, T, Q> col_type;
		typedef vec<2, T, Q> row_type;
		typedef mat<2, 2, T, Q> type;
		typedef mat<2, 2, T, Q> transpose_type;
		typedef T value_type;

	private:
		col_type value[2];

	public:
		

		typedef length_t length_type;
		[[nodiscard]] static constexpr length_type length() { return 2; }

		[[nodiscard]] constexpr col_type & operator[](length_type i) noexcept ;
		[[nodiscard]] constexpr col_type const& operator[](length_type i) const noexcept ;

		

		 constexpr mat() = default ;
		template<qualifier P>
		constexpr mat(mat<2, 2, T, P> const& m);

		constexpr  mat(T scalar);
		constexpr mat(
			T const& x1, T const& y1,
			T const& x2, T const& y2);
		constexpr mat(
			col_type const& v1,
			col_type const& v2);

		

		template<typename U, typename V, typename M, typename N>
		constexpr mat(
			U const& x1, V const& y1,
			M const& x2, N const& y2);

		template<typename U, typename V>
		constexpr mat(
			vec<2, U, Q> const& v1,
			vec<2, V, Q> const& v2);

		

		template<typename U, qualifier P>
		constexpr  mat(mat<2, 2, U, P> const& m);

		constexpr  mat(mat<3, 3, T, Q> const& x);
		constexpr  mat(mat<4, 4, T, Q> const& x);
		constexpr  mat(mat<2, 3, T, Q> const& x);
		constexpr  mat(mat<3, 2, T, Q> const& x);
		constexpr  mat(mat<2, 4, T, Q> const& x);
		constexpr  mat(mat<4, 2, T, Q> const& x);
		constexpr  mat(mat<3, 4, T, Q> const& x);
		constexpr  mat(mat<4, 3, T, Q> const& x);

		

		template<typename U>
		 constexpr mat<2, 2, T, Q> & operator=(mat<2, 2, U, Q> const& m);
		template<typename U>
		 constexpr mat<2, 2, T, Q> & operator+=(U s);
		template<typename U>
		 constexpr mat<2, 2, T, Q> & operator+=(mat<2, 2, U, Q> const& m);
		template<typename U>
		 constexpr mat<2, 2, T, Q> & operator-=(U s);
		template<typename U>
		 constexpr mat<2, 2, T, Q> & operator-=(mat<2, 2, U, Q> const& m);
		template<typename U>
		 constexpr mat<2, 2, T, Q> & operator*=(U s);
		template<typename U>
		 constexpr mat<2, 2, T, Q> & operator*=(mat<2, 2, U, Q> const& m);
		template<typename U>
		 constexpr mat<2, 2, T, Q> & operator/=(U s);
		template<typename U>
		 constexpr mat<2, 2, T, Q> & operator/=(mat<2, 2, U, Q> const& m);

		

		 constexpr mat<2, 2, T, Q> & operator++ ();
		 constexpr mat<2, 2, T, Q> & operator-- ();
		[[nodiscard]] constexpr mat<2, 2, T, Q> operator++(int);
		[[nodiscard]] constexpr mat<2, 2, T, Q> operator--(int);
	};

	

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m);

	

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<2, 2, T, Q> operator+(T scalar, mat<2, 2, T, Q> const& m);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<2, 2, T, Q> operator-(T scalar, mat<2, 2, T, Q> const& m);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<2, 2, T, Q> operator*(mat<2, 2, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<2, 2, T, Q> operator*(T scalar, mat<2, 2, T, Q> const& m);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr typename mat<2, 2, T, Q>::col_type operator*(mat<2, 2, T, Q> const& m, typename mat<2, 2, T, Q>::row_type const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr typename mat<2, 2, T, Q>::row_type operator*(typename mat<2, 2, T, Q>::col_type const& v, mat<2, 2, T, Q> const& m);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<2, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<3, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<4, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<2, 2, T, Q> operator/(mat<2, 2, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<2, 2, T, Q> operator/(T scalar, mat<2, 2, T, Q> const& m);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr typename mat<2, 2, T, Q>::col_type operator/(mat<2, 2, T, Q> const& m, typename mat<2, 2, T, Q>::row_type const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr typename mat<2, 2, T, Q>::row_type operator/(typename mat<2, 2, T, Q>::col_type const& v, mat<2, 2, T, Q> const& m);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<2, 2, T, Q> operator/(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);

	

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr bool operator==(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr bool operator!=(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);
} 


#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x2.inl"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\matrix.hpp"












#pragma once



#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 970 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
























































































































































































































#line 1187 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 1189 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
#line 18 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\matrix.hpp"




#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\mat2x3.hpp"



#pragma once
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_double2x3.hpp"



#pragma once
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x3.hpp"



#pragma once






namespace glm
{
	template<typename T, qualifier Q>
	struct mat<2, 3, T, Q>
	{
		typedef vec<3, T, Q> col_type;
		typedef vec<2, T, Q> row_type;
		typedef mat<2, 3, T, Q> type;
		typedef mat<3, 2, T, Q> transpose_type;
		typedef T value_type;

	private:
		col_type value[2];

	public:
		

		typedef length_t length_type;
		[[nodiscard]] static constexpr length_type length() { return 2; }

		[[nodiscard]] constexpr col_type & operator[](length_type i) noexcept ;
		[[nodiscard]] constexpr col_type const& operator[](length_type i) const noexcept ;

		

		 constexpr mat() = default ;
		template<qualifier P>
		constexpr mat(mat<2, 3, T, P> const& m);

		constexpr  mat(T scalar);
		constexpr mat(
			T x0, T y0, T z0,
			T x1, T y1, T z1);
		constexpr mat(
			col_type const& v0,
			col_type const& v1);

		

		template<typename X1, typename Y1, typename Z1, typename X2, typename Y2, typename Z2>
		constexpr mat(
			X1 x1, Y1 y1, Z1 z1,
			X2 x2, Y2 y2, Z2 z2);

		template<typename U, typename V>
		constexpr mat(
			vec<3, U, Q> const& v1,
			vec<3, V, Q> const& v2);

		

		template<typename U, qualifier P>
		constexpr  mat(mat<2, 3, U, P> const& m);

		constexpr  mat(mat<2, 2, T, Q> const& x);
		constexpr  mat(mat<3, 3, T, Q> const& x);
		constexpr  mat(mat<4, 4, T, Q> const& x);
		constexpr  mat(mat<2, 4, T, Q> const& x);
		constexpr  mat(mat<3, 2, T, Q> const& x);
		constexpr  mat(mat<3, 4, T, Q> const& x);
		constexpr  mat(mat<4, 2, T, Q> const& x);
		constexpr  mat(mat<4, 3, T, Q> const& x);

		

		template<typename U>
		 constexpr mat<2, 3, T, Q> & operator=(mat<2, 3, U, Q> const& m);
		template<typename U>
		 constexpr mat<2, 3, T, Q> & operator+=(U s);
		template<typename U>
		 constexpr mat<2, 3, T, Q> & operator+=(mat<2, 3, U, Q> const& m);
		template<typename U>
		 constexpr mat<2, 3, T, Q> & operator-=(U s);
		template<typename U>
		 constexpr mat<2, 3, T, Q> & operator-=(mat<2, 3, U, Q> const& m);
		template<typename U>
		 constexpr mat<2, 3, T, Q> & operator*=(U s);
		template<typename U>
		 constexpr mat<2, 3, T, Q> & operator/=(U s);

		

		 constexpr mat<2, 3, T, Q> & operator++ ();
		 constexpr mat<2, 3, T, Q> & operator-- ();
		[[nodiscard]] constexpr mat<2, 3, T, Q> operator++(int);
		[[nodiscard]] constexpr mat<2, 3, T, Q> operator--(int);
	};

	

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m);

	

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<2, 3, T, Q> operator*(mat<2, 3, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<2, 3, T, Q> operator*(T scalar, mat<2, 3, T, Q> const& m);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr typename mat<2, 3, T, Q>::col_type operator*(mat<2, 3, T, Q> const& m, typename mat<2, 3, T, Q>::row_type const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr typename mat<2, 3, T, Q>::row_type operator*(typename mat<2, 3, T, Q>::col_type const& v, mat<2, 3, T, Q> const& m);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<2, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<2, 2, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<3, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<4, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<4, 2, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<2, 3, T, Q> operator/(mat<2, 3, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<2, 3, T, Q> operator/(T scalar, mat<2, 3, T, Q> const& m);

	

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr bool operator==(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr bool operator!=(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2);
}


#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x3.inl"
namespace glm
{
	













#line 18 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x3.inl"

	template<typename T, qualifier Q>
	template<qualifier P>
	inline constexpr mat<2, 3, T, Q>::mat(mat<2, 3, T, P> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 25 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x3.inl"
	{



#line 30 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x3.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 3, T, Q>::mat(T scalar)

			: value{col_type(scalar, 0, 0), col_type(0, scalar, 0)}
#line 37 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x3.inl"
	{



#line 42 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x3.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 3, T, Q>::mat
	(
		T x0, T y0, T z0,
		T x1, T y1, T z1
	)

			: value{col_type(x0, y0, z0), col_type(x1, y1, z1)}
#line 53 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x3.inl"
	{



#line 58 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x3.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 3, T, Q>::mat(col_type const& v0, col_type const& v1)

			: value{col_type(v0), col_type(v1)}
#line 65 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x3.inl"
	{



#line 70 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x3.inl"
	}

	

	template<typename T, qualifier Q>
	template<
		typename X1, typename Y1, typename Z1,
		typename X2, typename Y2, typename Z2>
	inline constexpr mat<2, 3, T, Q>::mat
	(
		X1 x1, Y1 y1, Z1 z1,
		X2 x2, Y2 y2, Z2 z2
	)

			: value{col_type(x1, y1, z1), col_type(x2, y2, z2)}
#line 86 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x3.inl"
	{



#line 91 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x3.inl"
	}

	template<typename T, qualifier Q>
	template<typename V1, typename V2>
	inline constexpr mat<2, 3, T, Q>::mat(vec<3, V1, Q> const& v1, vec<3, V2, Q> const& v2)

			: value{col_type(v1), col_type(v2)}
#line 99 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x3.inl"
	{



#line 104 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x3.inl"
	}

	

	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	inline constexpr mat<2, 3, T, Q>::mat(mat<2, 3, U, P> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 114 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x3.inl"
	{



#line 119 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x3.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 3, T, Q>::mat(mat<2, 2, T, Q> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0)}
#line 126 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x3.inl"
	{



#line 131 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x3.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr  mat<2, 3, T, Q>::mat(mat<3, 3, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 138 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x3.inl"
	{



#line 143 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x3.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 3, T, Q>::mat(mat<4, 4, T, Q> const& m)

		: value{col_type(m[0]), col_type(m[1])}
#line 150 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x3.inl"
	{



#line 155 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x3.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 3, T, Q>::mat(mat<2, 4, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 162 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x3.inl"
	{



#line 167 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x3.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 3, T, Q>::mat(mat<3, 2, T, Q> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0)}
#line 174 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x3.inl"
	{



#line 179 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x3.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 3, T, Q>::mat(mat<3, 4, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 186 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x3.inl"
	{



#line 191 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x3.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 3, T, Q>::mat(mat<4, 2, T, Q> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0)}
#line 198 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x3.inl"
	{



#line 203 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x3.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 3, T, Q>::mat(mat<4, 3, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 210 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x3.inl"
	{



#line 215 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x3.inl"
	}

	

	template<typename T, qualifier Q>
	inline constexpr typename mat<2, 3, T, Q>::col_type & mat<2, 3, T, Q>::operator[](typename mat<2, 3, T, Q>::length_type i) noexcept
	{
		((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x3.inl", (unsigned)(222)), 0) )) ;
		return this->value[i];
	}

	template<typename T, qualifier Q>
	inline constexpr typename mat<2, 3, T, Q>::col_type const& mat<2, 3, T, Q>::operator[](typename mat<2, 3, T, Q>::length_type i) const noexcept
	{
		((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x3.inl", (unsigned)(229)), 0) )) ;
		return this->value[i];
	}

	

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<2, 3, T, Q>& mat<2, 3, T, Q>::operator=(mat<2, 3, U, Q> const& m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<2, 3, T, Q> & mat<2, 3, T, Q>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<2, 3, T, Q>& mat<2, 3, T, Q>::operator+=(mat<2, 3, U, Q> const& m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<2, 3, T, Q>& mat<2, 3, T, Q>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<2, 3, T, Q>& mat<2, 3, T, Q>::operator-=(mat<2, 3, U, Q> const& m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<2, 3, T, Q>& mat<2, 3, T, Q>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<2, 3, T, Q> & mat<2, 3, T, Q>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		return *this;
	}

	

	template<typename T, qualifier Q>
	inline constexpr mat<2, 3, T, Q> & mat<2, 3, T, Q>::operator++()
	{
		++this->value[0];
		++this->value[1];
		return *this;
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 3, T, Q> & mat<2, 3, T, Q>::operator--()
	{
		--this->value[0];
		--this->value[1];
		return *this;
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 3, T, Q> mat<2, 3, T, Q>::operator++(int)
	{
		mat<2, 3, T, Q> Result(*this);
		++*this;
		return Result;
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 3, T, Q> mat<2, 3, T, Q>::operator--(int)
	{
		mat<2, 3, T, Q> Result(*this);
		--*this;
		return Result;
	}

	

	template<typename T, qualifier Q>
	inline constexpr mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m)
	{
		return m;
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m)
	{
		return mat<2, 3, T, Q>(
			-m[0],
			-m[1]);
	}

	

	template<typename T, qualifier Q>
	inline constexpr mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m, T scalar)
	{
		return mat<2, 3, T, Q>(
			m[0] + scalar,
			m[1] + scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
	{
		return mat<2, 3, T, Q>(
			m1[0] + m2[0],
			m1[1] + m2[1]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m, T scalar)
	{
		return mat<2, 3, T, Q>(
			m[0] - scalar,
			m[1] - scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
	{
		return mat<2, 3, T, Q>(
			m1[0] - m2[0],
			m1[1] - m2[1]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 3, T, Q> operator*(mat<2, 3, T, Q> const& m, T scalar)
	{
		return mat<2, 3, T, Q>(
			m[0] * scalar,
			m[1] * scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 3, T, Q> operator*(T scalar, mat<2, 3, T, Q> const& m)
	{
		return mat<2, 3, T, Q>(
			m[0] * scalar,
			m[1] * scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr typename mat<2, 3, T, Q>::col_type operator*
	(
		mat<2, 3, T, Q> const& m,
		typename mat<2, 3, T, Q>::row_type const& v)
	{
		return typename mat<2, 3, T, Q>::col_type(
			m[0][0] * v.x + m[1][0] * v.y,
			m[0][1] * v.x + m[1][1] * v.y,
			m[0][2] * v.x + m[1][2] * v.y);
	}

	template<typename T, qualifier Q>
	inline constexpr typename mat<2, 3, T, Q>::row_type operator*
	(
		typename mat<2, 3, T, Q>::col_type const& v,
		mat<2, 3, T, Q> const& m)
	{
		return typename mat<2, 3, T, Q>::row_type(
			v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2],
			v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
	{
		return mat<2, 3, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
	{
		T SrcA00 = m1[0][0];
		T SrcA01 = m1[0][1];
		T SrcA02 = m1[0][2];
		T SrcA10 = m1[1][0];
		T SrcA11 = m1[1][1];
		T SrcA12 = m1[1][2];

		T SrcB00 = m2[0][0];
		T SrcB01 = m2[0][1];
		T SrcB10 = m2[1][0];
		T SrcB11 = m2[1][1];
		T SrcB20 = m2[2][0];
		T SrcB21 = m2[2][1];

		mat<3, 3, T, Q> Result;
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01;
		Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11;
		Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11;
		Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21;
		Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21;
		Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21;
		return Result;
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
	{
		return mat<4, 3, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1],
			m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 3, T, Q> operator/(mat<2, 3, T, Q> const& m, T scalar)
	{
		return mat<2, 3, T, Q>(
			m[0] / scalar,
			m[1] / scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 3, T, Q> operator/(T scalar, mat<2, 3, T, Q> const& m)
	{
		return mat<2, 3, T, Q>(
			scalar / m[0],
			scalar / m[1]);
	}

	

	template<typename T, qualifier Q>
	inline constexpr bool operator==(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]);
	}

	template<typename T, qualifier Q>
	inline constexpr bool operator!=(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]);
	}
} 
#line 159 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x3.hpp"
#line 160 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x3.hpp"
#line 6 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_double2x3.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<2, 3, double, defaultp>		dmat2x3;

	
}
#line 6 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\mat2x3.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_double2x3_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef mat<2, 3, double, lowp>		lowp_dmat2x3;

	
	
	
	
	typedef mat<2, 3, double, mediump>	mediump_dmat2x3;

	
	
	
	
	typedef mat<2, 3, double, highp>	highp_dmat2x3;

	
}
#line 7 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\mat2x3.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_float2x3.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef mat<2, 3, float, defaultp>		mat2x3;

	
}
#line 8 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\mat2x3.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_float2x3_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef mat<2, 3, float, lowp>		lowp_mat2x3;

	
	
	
	
	typedef mat<2, 3, float, mediump>	mediump_mat2x3;

	
	
	
	
	typedef mat<2, 3, float, highp>		highp_mat2x3;

	
}
#line 9 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\mat2x3.hpp"

#line 23 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\matrix.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\mat2x4.hpp"



#pragma once
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_double2x4.hpp"



#pragma once
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x4.hpp"



#pragma once






namespace glm
{
	template<typename T, qualifier Q>
	struct mat<2, 4, T, Q>
	{
		typedef vec<4, T, Q> col_type;
		typedef vec<2, T, Q> row_type;
		typedef mat<2, 4, T, Q> type;
		typedef mat<4, 2, T, Q> transpose_type;
		typedef T value_type;

	private:
		col_type value[2];

	public:
		

		typedef length_t length_type;
		[[nodiscard]] static constexpr length_type length() { return 2; }

		[[nodiscard]] constexpr col_type & operator[](length_type i) noexcept ;
		[[nodiscard]] constexpr col_type const& operator[](length_type i) const noexcept ;

		

		 constexpr mat() = default ;
		template<qualifier P>
		constexpr mat(mat<2, 4, T, P> const& m);

		constexpr  mat(T scalar);
		constexpr mat(
			T x0, T y0, T z0, T w0,
			T x1, T y1, T z1, T w1);
		constexpr mat(
			col_type const& v0,
			col_type const& v1);

		

		template<
			typename X1, typename Y1, typename Z1, typename W1,
			typename X2, typename Y2, typename Z2, typename W2>
		constexpr mat(
			X1 x1, Y1 y1, Z1 z1, W1 w1,
			X2 x2, Y2 y2, Z2 z2, W2 w2);

		template<typename U, typename V>
		constexpr mat(
			vec<4, U, Q> const& v1,
			vec<4, V, Q> const& v2);

		

		template<typename U, qualifier P>
		constexpr  mat(mat<2, 4, U, P> const& m);

		constexpr  mat(mat<2, 2, T, Q> const& x);
		constexpr  mat(mat<3, 3, T, Q> const& x);
		constexpr  mat(mat<4, 4, T, Q> const& x);
		constexpr  mat(mat<2, 3, T, Q> const& x);
		constexpr  mat(mat<3, 2, T, Q> const& x);
		constexpr  mat(mat<3, 4, T, Q> const& x);
		constexpr  mat(mat<4, 2, T, Q> const& x);
		constexpr  mat(mat<4, 3, T, Q> const& x);

		

		template<typename U>
		 constexpr mat<2, 4, T, Q> & operator=(mat<2, 4, U, Q> const& m);
		template<typename U>
		 constexpr mat<2, 4, T, Q> & operator+=(U s);
		template<typename U>
		 constexpr mat<2, 4, T, Q> & operator+=(mat<2, 4, U, Q> const& m);
		template<typename U>
		 constexpr mat<2, 4, T, Q> & operator-=(U s);
		template<typename U>
		 constexpr mat<2, 4, T, Q> & operator-=(mat<2, 4, U, Q> const& m);
		template<typename U>
		 constexpr mat<2, 4, T, Q> & operator*=(U s);
		template<typename U>
		 constexpr mat<2, 4, T, Q> & operator/=(U s);

		

		 constexpr mat<2, 4, T, Q> & operator++ ();
		 constexpr mat<2, 4, T, Q> & operator-- ();
		[[nodiscard]] constexpr mat<2, 4, T, Q> operator++(int);
		[[nodiscard]] constexpr mat<2, 4, T, Q> operator--(int);
	};

	

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m);

	

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<2, 4, T, Q> operator*(mat<2, 4, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<2, 4, T, Q> operator*(T scalar, mat<2, 4, T, Q> const& m);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr typename mat<2, 4, T, Q>::col_type operator*(mat<2, 4, T, Q> const& m, typename mat<2, 4, T, Q>::row_type const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr typename mat<2, 4, T, Q>::row_type operator*(typename mat<2, 4, T, Q>::col_type const& v, mat<2, 4, T, Q> const& m);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<4, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<4, 2, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<2, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<2, 2, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<3, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<2, 4, T, Q> operator/(mat<2, 4, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<2, 4, T, Q> operator/(T scalar, mat<2, 4, T, Q> const& m);

	

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr bool operator==(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr bool operator!=(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2);
}


#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x4.inl"
namespace glm
{
	













#line 18 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x4.inl"

	template<typename T, qualifier Q>
	template<qualifier P>
	inline constexpr mat<2, 4, T, Q>::mat(mat<2, 4, T, P> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 25 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x4.inl"
	{



#line 30 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x4.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 4, T, Q>::mat(T s)

			: value{col_type(s, 0, 0, 0), col_type(0, s, 0, 0)}
#line 37 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x4.inl"
	{



#line 42 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x4.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 4, T, Q>::mat
	(
		T x0, T y0, T z0, T w0,
		T x1, T y1, T z1, T w1
	)

			: value{col_type(x0, y0, z0, w0), col_type(x1, y1, z1, w1)}
#line 53 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x4.inl"
	{



#line 58 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x4.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 4, T, Q>::mat(col_type const& v0, col_type const& v1)

			: value{col_type(v0), col_type(v1)}
#line 65 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x4.inl"
	{



#line 70 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x4.inl"
	}

	

	template<typename T, qualifier Q>
	template<
		typename X1, typename Y1, typename Z1, typename W1,
		typename X2, typename Y2, typename Z2, typename W2>
	inline constexpr mat<2, 4, T, Q>::mat
	(
		X1 x1, Y1 y1, Z1 z1, W1 w1,
		X2 x2, Y2 y2, Z2 z2, W2 w2
	)

			: value{
				col_type(x1, y1, z1, w1),
				col_type(x2, y2, z2, w2)}
#line 88 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x4.inl"
	{



#line 93 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x4.inl"
	}

	template<typename T, qualifier Q>
	template<typename V1, typename V2>
	inline constexpr mat<2, 4, T, Q>::mat(vec<4, V1, Q> const& v1, vec<4, V2, Q> const& v2)

			: value{col_type(v1), col_type(v2)}
#line 101 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x4.inl"
	{



#line 106 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x4.inl"
	}

	

	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	inline constexpr mat<2, 4, T, Q>::mat(mat<2, 4, U, P> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 116 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x4.inl"
	{



#line 121 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x4.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 4, T, Q>::mat(mat<2, 2, T, Q> const& m)

			: value{col_type(m[0], 0, 0), col_type(m[1], 0, 0)}
#line 128 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x4.inl"
	{



#line 133 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x4.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 4, T, Q>::mat(mat<3, 3, T, Q> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0)}
#line 140 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x4.inl"
	{



#line 145 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x4.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 4, T, Q>::mat(mat<4, 4, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 152 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x4.inl"
	{



#line 157 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x4.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 4, T, Q>::mat(mat<2, 3, T, Q> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0)}
#line 164 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x4.inl"
	{



#line 169 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x4.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 4, T, Q>::mat(mat<3, 2, T, Q> const& m)

			: value{col_type(m[0], 0, 0), col_type(m[1], 0, 0)}
#line 176 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x4.inl"
	{



#line 181 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x4.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 4, T, Q>::mat(mat<3, 4, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 188 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x4.inl"
	{



#line 193 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x4.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 4, T, Q>::mat(mat<4, 2, T, Q> const& m)

			: value{col_type(m[0], 0, 0), col_type(m[1], 0, 0)}
#line 200 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x4.inl"
	{



#line 205 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x4.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 4, T, Q>::mat(mat<4, 3, T, Q> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0)}
#line 212 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x4.inl"
	{



#line 217 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x4.inl"
	}

	

	template<typename T, qualifier Q>
	inline constexpr typename mat<2, 4, T, Q>::col_type & mat<2, 4, T, Q>::operator[](typename mat<2, 4, T, Q>::length_type i) noexcept
	{
		((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x4.inl", (unsigned)(224)), 0) )) ;
		return this->value[i];
	}

	template<typename T, qualifier Q>
	inline constexpr typename mat<2, 4, T, Q>::col_type const& mat<2, 4, T, Q>::operator[](typename mat<2, 4, T, Q>::length_type i) const noexcept
	{
		((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x4.inl", (unsigned)(231)), 0) )) ;
		return this->value[i];
	}

	

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator=(mat<2, 4, U, Q> const& m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator+=(mat<2, 4, U, Q> const& m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator-=(mat<2, 4, U, Q> const& m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<2, 4, T, Q> & mat<2, 4, T, Q>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		return *this;
	}

	

	template<typename T, qualifier Q>
	inline constexpr mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator++()
	{
		++this->value[0];
		++this->value[1];
		return *this;
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator--()
	{
		--this->value[0];
		--this->value[1];
		return *this;
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 4, T, Q> mat<2, 4, T, Q>::operator++(int)
	{
		mat<2, 4, T, Q> Result(*this);
		++*this;
		return Result;
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 4, T, Q> mat<2, 4, T, Q>::operator--(int)
	{
		mat<2, 4, T, Q> Result(*this);
		--*this;
		return Result;
	}

	

	template<typename T, qualifier Q>
	inline constexpr mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m)
	{
		return m;
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m)
	{
		return mat<2, 4, T, Q>(
			-m[0],
			-m[1]);
	}

	

	template<typename T, qualifier Q>
	inline constexpr mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m, T scalar)
	{
		return mat<2, 4, T, Q>(
			m[0] + scalar,
			m[1] + scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
	{
		return mat<2, 4, T, Q>(
			m1[0] + m2[0],
			m1[1] + m2[1]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m, T scalar)
	{
		return mat<2, 4, T, Q>(
			m[0] - scalar,
			m[1] - scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
	{
		return mat<2, 4, T, Q>(
			m1[0] - m2[0],
			m1[1] - m2[1]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 4, T, Q> operator*(mat<2, 4, T, Q> const& m, T scalar)
	{
		return mat<2, 4, T, Q>(
			m[0] * scalar,
			m[1] * scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 4, T, Q> operator*(T scalar, mat<2, 4, T, Q> const& m)
	{
		return mat<2, 4, T, Q>(
			m[0] * scalar,
			m[1] * scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr typename mat<2, 4, T, Q>::col_type operator*(mat<2, 4, T, Q> const& m, typename mat<2, 4, T, Q>::row_type const& v)
	{
		return typename mat<2, 4, T, Q>::col_type(
			m[0][0] * v.x + m[1][0] * v.y,
			m[0][1] * v.x + m[1][1] * v.y,
			m[0][2] * v.x + m[1][2] * v.y,
			m[0][3] * v.x + m[1][3] * v.y);
	}

	template<typename T, qualifier Q>
	inline constexpr typename mat<2, 4, T, Q>::row_type operator*(typename mat<2, 4, T, Q>::col_type const& v, mat<2, 4, T, Q> const& m)
	{
		return typename mat<2, 4, T, Q>::row_type(
			v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2] + v.w * m[0][3],
			v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2] + v.w * m[1][3]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
	{
		T SrcA00 = m1[0][0];
		T SrcA01 = m1[0][1];
		T SrcA02 = m1[0][2];
		T SrcA03 = m1[0][3];
		T SrcA10 = m1[1][0];
		T SrcA11 = m1[1][1];
		T SrcA12 = m1[1][2];
		T SrcA13 = m1[1][3];

		T SrcB00 = m2[0][0];
		T SrcB01 = m2[0][1];
		T SrcB10 = m2[1][0];
		T SrcB11 = m2[1][1];
		T SrcB20 = m2[2][0];
		T SrcB21 = m2[2][1];
		T SrcB30 = m2[3][0];
		T SrcB31 = m2[3][1];

		mat<4, 4, T, Q> Result;
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01;
		Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01;
		Result[0][3] = SrcA03 * SrcB00 + SrcA13 * SrcB01;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11;
		Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11;
		Result[1][3] = SrcA03 * SrcB10 + SrcA13 * SrcB11;
		Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21;
		Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21;
		Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21;
		Result[2][3] = SrcA03 * SrcB20 + SrcA13 * SrcB21;
		Result[3][0] = SrcA00 * SrcB30 + SrcA10 * SrcB31;
		Result[3][1] = SrcA01 * SrcB30 + SrcA11 * SrcB31;
		Result[3][2] = SrcA02 * SrcB30 + SrcA12 * SrcB31;
		Result[3][3] = SrcA03 * SrcB30 + SrcA13 * SrcB31;
		return Result;
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
	{
		return mat<2, 4, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
	{
		return mat<3, 4, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1],
			m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 4, T, Q> operator/(mat<2, 4, T, Q> const& m, T scalar)
	{
		return mat<2, 4, T, Q>(
			m[0] / scalar,
			m[1] / scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 4, T, Q> operator/(T scalar, mat<2, 4, T, Q> const& m)
	{
		return mat<2, 4, T, Q>(
			scalar / m[0],
			scalar / m[1]);
	}

	

	template<typename T, qualifier Q>
	inline constexpr bool operator==(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]);
	}

	template<typename T, qualifier Q>
	inline constexpr bool operator!=(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]);
	}
} 
#line 161 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x4.hpp"
#line 162 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x4.hpp"
#line 6 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_double2x4.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<2, 4, double, defaultp>		dmat2x4;

	
}
#line 6 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\mat2x4.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_double2x4_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef mat<2, 4, double, lowp>		lowp_dmat2x4;

	
	
	
	
	typedef mat<2, 4, double, mediump>	mediump_dmat2x4;

	
	
	
	
	typedef mat<2, 4, double, highp>	highp_dmat2x4;

	
}
#line 7 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\mat2x4.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_float2x4.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef mat<2, 4, float, defaultp>		mat2x4;

	
}
#line 8 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\mat2x4.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_float2x4_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef mat<2, 4, float, lowp>		lowp_mat2x4;

	
	
	
	
	typedef mat<2, 4, float, mediump>	mediump_mat2x4;

	
	
	
	
	typedef mat<2, 4, float, highp>		highp_mat2x4;

	
}
#line 9 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\mat2x4.hpp"

#line 24 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\matrix.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\mat3x2.hpp"



#pragma once
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_double3x2.hpp"



#pragma once
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x2.hpp"



#pragma once






namespace glm
{
	template<typename T, qualifier Q>
	struct mat<3, 2, T, Q>
	{
		typedef vec<2, T, Q> col_type;
		typedef vec<3, T, Q> row_type;
		typedef mat<3, 2, T, Q> type;
		typedef mat<2, 3, T, Q> transpose_type;
		typedef T value_type;

	private:
		col_type value[3];

	public:
		

		typedef length_t length_type;
		[[nodiscard]] static constexpr length_type length() { return 3; }

		[[nodiscard]] constexpr col_type & operator[](length_type i) noexcept ;
		[[nodiscard]] constexpr col_type const& operator[](length_type i) const noexcept ;

		

		 constexpr mat() = default ;
		template<qualifier P>
		constexpr mat(mat<3, 2, T, P> const& m);

		constexpr  mat(T scalar);
		constexpr mat(
			T x0, T y0,
			T x1, T y1,
			T x2, T y2);
		constexpr mat(
			col_type const& v0,
			col_type const& v1,
			col_type const& v2);

		

		template<
			typename X1, typename Y1,
			typename X2, typename Y2,
			typename X3, typename Y3>
			constexpr mat(
			X1 x1, Y1 y1,
			X2 x2, Y2 y2,
			X3 x3, Y3 y3);

		template<typename V1, typename V2, typename V3>
		constexpr mat(
			vec<2, V1, Q> const& v1,
			vec<2, V2, Q> const& v2,
			vec<2, V3, Q> const& v3);

		

		template<typename U, qualifier P>
		constexpr  mat(mat<3, 2, U, P> const& m);

		constexpr  mat(mat<2, 2, T, Q> const& x);
		constexpr  mat(mat<3, 3, T, Q> const& x);
		constexpr  mat(mat<4, 4, T, Q> const& x);
		constexpr  mat(mat<2, 3, T, Q> const& x);
		constexpr  mat(mat<2, 4, T, Q> const& x);
		constexpr  mat(mat<3, 4, T, Q> const& x);
		constexpr  mat(mat<4, 2, T, Q> const& x);
		constexpr  mat(mat<4, 3, T, Q> const& x);

		

		template<typename U>
		 constexpr mat<3, 2, T, Q> & operator=(mat<3, 2, U, Q> const& m);
		template<typename U>
		 constexpr mat<3, 2, T, Q> & operator+=(U s);
		template<typename U>
		 constexpr mat<3, 2, T, Q> & operator+=(mat<3, 2, U, Q> const& m);
		template<typename U>
		 constexpr mat<3, 2, T, Q> & operator-=(U s);
		template<typename U>
		 constexpr mat<3, 2, T, Q> & operator-=(mat<3, 2, U, Q> const& m);
		template<typename U>
		 constexpr mat<3, 2, T, Q> & operator*=(U s);
		template<typename U>
		 constexpr mat<3, 2, T, Q> & operator/=(U s);

		

		 constexpr mat<3, 2, T, Q> & operator++ ();
		 constexpr mat<3, 2, T, Q> & operator-- ();
		[[nodiscard]] constexpr mat<3, 2, T, Q> operator++(int);
		[[nodiscard]] constexpr mat<3, 2, T, Q> operator--(int);
	};

	

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m);

	

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<3, 2, T, Q> operator*(mat<3, 2, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<3, 2, T, Q> operator*(T scalar, mat<3, 2, T, Q> const& m);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr typename mat<3, 2, T, Q>::col_type operator*(mat<3, 2, T, Q> const& m, typename mat<3, 2, T, Q>::row_type const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr typename mat<3, 2, T, Q>::row_type operator*(typename mat<3, 2, T, Q>::col_type const& v, mat<3, 2, T, Q> const& m);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<2, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<2, 3, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<3, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<3, 3, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<4, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<4, 3, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<3, 2, T, Q> operator/(mat<3, 2, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<3, 2, T, Q> operator/(T scalar, mat<3, 2, T, Q> const& m);

	

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr bool operator==(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr bool operator!=(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

}


#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x2.inl"
namespace glm
{
	














#line 19 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x2.inl"

	template<typename T, qualifier Q>
	template<qualifier P>
	inline constexpr mat<3, 2, T, Q>::mat(mat<3, 2, T, P> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2])}
#line 26 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x2.inl"
	{




#line 32 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x2.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 2, T, Q>::mat(T s)

			: value{col_type(s, 0), col_type(0, s), col_type(0, 0)}
#line 39 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x2.inl"
	{




#line 45 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x2.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 2, T, Q>::mat
	(
		T x0, T y0,
		T x1, T y1,
		T x2, T y2
	)

			: value{col_type(x0, y0), col_type(x1, y1), col_type(x2, y2)}
#line 57 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x2.inl"
	{




#line 63 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x2.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 2, T, Q>::mat(col_type const& v0, col_type const& v1, col_type const& v2)

			: value{col_type(v0), col_type(v1), col_type(v2)}
#line 70 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x2.inl"
	{




#line 76 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x2.inl"
	}

	

	template<typename T, qualifier Q>
	template<
		typename X0, typename Y0,
		typename X1, typename Y1,
		typename X2, typename Y2>
	inline constexpr mat<3, 2, T, Q>::mat
	(
		X0 x0, Y0 y0,
		X1 x1, Y1 y1,
		X2 x2, Y2 y2
	)

			: value{col_type(x0, y0), col_type(x1, y1), col_type(x2, y2)}
#line 94 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x2.inl"
	{




#line 100 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x2.inl"
	}

	template<typename T, qualifier Q>
	template<typename V0, typename V1, typename V2>
	inline constexpr mat<3, 2, T, Q>::mat(vec<2, V0, Q> const& v0, vec<2, V1, Q> const& v1, vec<2, V2, Q> const& v2)

			: value{col_type(v0), col_type(v1), col_type(v2)}
#line 108 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x2.inl"
	{




#line 114 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x2.inl"
	}

	

	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	inline constexpr mat<3, 2, T, Q>::mat(mat<3, 2, U, P> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2])}
#line 124 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x2.inl"
	{




#line 130 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x2.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 2, T, Q>::mat(mat<2, 2, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(0)}
#line 137 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x2.inl"
	{




#line 143 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x2.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 2, T, Q>::mat(mat<3, 3, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2])}
#line 150 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x2.inl"
	{




#line 156 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x2.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 2, T, Q>::mat(mat<4, 4, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2])}
#line 163 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x2.inl"
	{




#line 169 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x2.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 2, T, Q>::mat(mat<2, 3, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(0)}
#line 176 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x2.inl"
	{




#line 182 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x2.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 2, T, Q>::mat(mat<2, 4, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(0)}
#line 189 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x2.inl"
	{




#line 195 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x2.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 2, T, Q>::mat(mat<3, 4, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2])}
#line 202 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x2.inl"
	{




#line 208 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x2.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 2, T, Q>::mat(mat<4, 2, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2])}
#line 215 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x2.inl"
	{




#line 221 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x2.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 2, T, Q>::mat(mat<4, 3, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2])}
#line 228 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x2.inl"
	{




#line 234 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x2.inl"
	}

	

	template<typename T, qualifier Q>
	inline constexpr typename mat<3, 2, T, Q>::col_type & mat<3, 2, T, Q>::operator[](typename mat<3, 2, T, Q>::length_type i) noexcept
	{
		((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x2.inl", (unsigned)(241)), 0) )) ;
		return this->value[i];
	}

	template<typename T, qualifier Q>
	inline constexpr typename mat<3, 2, T, Q>::col_type const& mat<3, 2, T, Q>::operator[](typename mat<3, 2, T, Q>::length_type i) const noexcept
	{
		((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x2.inl", (unsigned)(248)), 0) )) ;
		return this->value[i];
	}

	

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator=(mat<3, 2, U, Q> const& m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator+=(mat<3, 2, U, Q> const& m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator-=(mat<3, 2, U, Q> const& m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<3, 2, T, Q> & mat<3, 2, T, Q>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		return *this;
	}

	

	template<typename T, qualifier Q>
	inline constexpr mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator++()
	{
		++this->value[0];
		++this->value[1];
		++this->value[2];
		return *this;
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator--()
	{
		--this->value[0];
		--this->value[1];
		--this->value[2];
		return *this;
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 2, T, Q> mat<3, 2, T, Q>::operator++(int)
	{
		mat<3, 2, T, Q> Result(*this);
		++*this;
		return Result;
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 2, T, Q> mat<3, 2, T, Q>::operator--(int)
	{
		mat<3, 2, T, Q> Result(*this);
		--*this;
		return Result;
	}

	

	template<typename T, qualifier Q>
	inline constexpr mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m)
	{
		return m;
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m)
	{
		return mat<3, 2, T, Q>(
			-m[0],
			-m[1],
			-m[2]);
	}

	

	template<typename T, qualifier Q>
	inline constexpr mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m, T scalar)
	{
		return mat<3, 2, T, Q>(
			m[0] + scalar,
			m[1] + scalar,
			m[2] + scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
	{
		return mat<3, 2, T, Q>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m, T scalar)
	{
		return mat<3, 2, T, Q>(
			m[0] - scalar,
			m[1] - scalar,
			m[2] - scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
	{
		return mat<3, 2, T, Q>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 2, T, Q> operator*(mat<3, 2, T, Q> const& m, T scalar)
	{
		return mat<3, 2, T, Q>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 2, T, Q> operator*(T scalar, mat<3, 2, T, Q> const& m)
	{
		return mat<3, 2, T, Q>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr typename mat<3, 2, T, Q>::col_type operator*(mat<3, 2, T, Q> const& m, typename mat<3, 2, T, Q>::row_type const& v)
	{
		return typename mat<3, 2, T, Q>::col_type(
			m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
			m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z);
	}

	template<typename T, qualifier Q>
	inline constexpr typename mat<3, 2, T, Q>::row_type operator*(typename mat<3, 2, T, Q>::col_type const& v, mat<3, 2, T, Q> const& m)
	{
		return typename mat<3, 2, T, Q>::row_type(
			v.x * m[0][0] + v.y * m[0][1],
			v.x * m[1][0] + v.y * m[1][1],
			v.x * m[2][0] + v.y * m[2][1]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
	{
		const T SrcA00 = m1[0][0];
		const T SrcA01 = m1[0][1];
		const T SrcA10 = m1[1][0];
		const T SrcA11 = m1[1][1];
		const T SrcA20 = m1[2][0];
		const T SrcA21 = m1[2][1];

		const T SrcB00 = m2[0][0];
		const T SrcB01 = m2[0][1];
		const T SrcB02 = m2[0][2];
		const T SrcB10 = m2[1][0];
		const T SrcB11 = m2[1][1];
		const T SrcB12 = m2[1][2];

		mat<2, 2, T, Q> Result;
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
		return Result;
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
	{
		return mat<3, 2, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
	{
		return mat<4, 2, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 2, T, Q> operator/(mat<3, 2, T, Q> const& m, T scalar)
	{
		return mat<3, 2, T, Q>(
			m[0] / scalar,
			m[1] / scalar,
			m[2] / scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 2, T, Q> operator/(T scalar, mat<3, 2, T, Q> const& m)
	{
		return mat<3, 2, T, Q>(
			scalar / m[0],
			scalar / m[1],
			scalar / m[2]);
	}

	

	template<typename T, qualifier Q>
	inline constexpr bool operator==(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
	}

	template<typename T, qualifier Q>
	inline constexpr bool operator!=(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
	}
} 
#line 167 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x2.hpp"
#line 168 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x2.hpp"
#line 6 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_double3x2.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<3, 2, double, defaultp>		dmat3x2;

	
}
#line 6 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\mat3x2.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_double3x2_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef mat<3, 2, double, lowp>		lowp_dmat3x2;

	
	
	
	
	typedef mat<3, 2, double, mediump>	mediump_dmat3x2;

	
	
	
	
	typedef mat<3, 2, double, highp>	highp_dmat3x2;

	
}
#line 7 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\mat3x2.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_float3x2.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef mat<3, 2, float, defaultp>			mat3x2;

	
}
#line 8 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\mat3x2.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_float3x2_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef mat<3, 2, float, lowp>		lowp_mat3x2;

	
	
	
	
	typedef mat<3, 2, float, mediump>	mediump_mat3x2;

	
	
	
	
	typedef mat<3, 2, float, highp>		highp_mat3x2;

	
}
#line 9 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\mat3x2.hpp"

#line 25 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\matrix.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\mat3x3.hpp"



#pragma once
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_double3x3.hpp"



#pragma once
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x3.hpp"



#pragma once





namespace glm
{
	template<typename T, qualifier Q>
	struct mat<3, 3, T, Q>
	{
		typedef vec<3, T, Q> col_type;
		typedef vec<3, T, Q> row_type;
		typedef mat<3, 3, T, Q> type;
		typedef mat<3, 3, T, Q> transpose_type;
		typedef T value_type;

	private:
		col_type value[3];

	public:
		

		typedef length_t length_type;
		[[nodiscard]] static constexpr length_type length() { return 3; }

		[[nodiscard]] constexpr col_type & operator[](length_type i) noexcept ;
		[[nodiscard]] constexpr col_type const& operator[](length_type i) const noexcept ;

		

		 constexpr mat() = default ;
		template<qualifier P>
		constexpr mat(mat<3, 3, T, P> const& m);

		constexpr  mat(T scalar);
		constexpr mat(
			T x0, T y0, T z0,
			T x1, T y1, T z1,
			T x2, T y2, T z2);
		constexpr mat(
			col_type const& v0,
			col_type const& v1,
			col_type const& v2);

		

		template<
			typename X1, typename Y1, typename Z1,
			typename X2, typename Y2, typename Z2,
			typename X3, typename Y3, typename Z3>
		constexpr mat(
			X1 x1, Y1 y1, Z1 z1,
			X2 x2, Y2 y2, Z2 z2,
			X3 x3, Y3 y3, Z3 z3);

		template<typename V1, typename V2, typename V3>
		constexpr mat(
			vec<3, V1, Q> const& v1,
			vec<3, V2, Q> const& v2,
			vec<3, V3, Q> const& v3);

		

		template<typename U, qualifier P>
		constexpr  mat(mat<3, 3, U, P> const& m);

		constexpr  mat(mat<2, 2, T, Q> const& x);
		constexpr  mat(mat<4, 4, T, Q> const& x);
		constexpr  mat(mat<2, 3, T, Q> const& x);
		constexpr  mat(mat<3, 2, T, Q> const& x);
		constexpr  mat(mat<2, 4, T, Q> const& x);
		constexpr  mat(mat<4, 2, T, Q> const& x);
		constexpr  mat(mat<3, 4, T, Q> const& x);
		constexpr  mat(mat<4, 3, T, Q> const& x);

		

		template<typename U>
		 constexpr mat<3, 3, T, Q> & operator=(mat<3, 3, U, Q> const& m);
		template<typename U>
		 constexpr mat<3, 3, T, Q> & operator+=(U s);
		template<typename U>
		 constexpr mat<3, 3, T, Q> & operator+=(mat<3, 3, U, Q> const& m);
		template<typename U>
		 constexpr mat<3, 3, T, Q> & operator-=(U s);
		template<typename U>
		 constexpr mat<3, 3, T, Q> & operator-=(mat<3, 3, U, Q> const& m);
		template<typename U>
		 constexpr mat<3, 3, T, Q> & operator*=(U s);
		template<typename U>
		 constexpr mat<3, 3, T, Q> & operator*=(mat<3, 3, U, Q> const& m);
		template<typename U>
		 constexpr mat<3, 3, T, Q> & operator/=(U s);
		template<typename U>
		 constexpr mat<3, 3, T, Q> & operator/=(mat<3, 3, U, Q> const& m);

		

		 constexpr mat<3, 3, T, Q> & operator++();
		 constexpr mat<3, 3, T, Q> & operator--();
		[[nodiscard]] constexpr mat<3, 3, T, Q> operator++(int);
		[[nodiscard]] constexpr mat<3, 3, T, Q> operator--(int);
	};

	

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m);

	

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<3, 3, T, Q> operator+(T scalar, mat<3, 3, T, Q> const& m);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<3, 3, T, Q> operator-(T scalar, mat<3, 3, T, Q> const& m);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<3, 3, T, Q> operator*(mat<3, 3, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<3, 3, T, Q> operator*(T scalar, mat<3, 3, T, Q> const& m);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr typename mat<3, 3, T, Q>::col_type operator*(mat<3, 3, T, Q> const& m, typename mat<3, 3, T, Q>::row_type const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr typename mat<3, 3, T, Q>::row_type operator*(typename mat<3, 3, T, Q>::col_type const& v, mat<3, 3, T, Q> const& m);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<3, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<2, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<4, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<3, 3, T, Q> operator/(mat<3, 3, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<3, 3, T, Q> operator/(T scalar, mat<3, 3, T, Q> const& m);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr typename mat<3, 3, T, Q>::col_type operator/(mat<3, 3, T, Q> const& m, typename mat<3, 3, T, Q>::row_type const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr typename mat<3, 3, T, Q>::row_type operator/(typename mat<3, 3, T, Q>::col_type const& v, mat<3, 3, T, Q> const& m);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<3, 3, T, Q> operator/(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);

	

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr bool operator==(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr bool operator!=(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);
}


#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x3.inl"


namespace glm
{
	














#line 21 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x3.inl"

	template<typename T, qualifier Q>
	template<qualifier P>
	inline constexpr mat<3, 3, T, Q>::mat(mat<3, 3, T, P> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2])}
#line 28 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x3.inl"
	{




#line 34 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x3.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 3, T, Q>::mat(T s)

			: value{col_type(s, 0, 0), col_type(0, s, 0), col_type(0, 0, s)}
#line 41 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x3.inl"
	{




#line 47 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x3.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 3, T, Q>::mat
	(
		T x0, T y0, T z0,
		T x1, T y1, T z1,
		T x2, T y2, T z2
	)

			: value{col_type(x0, y0, z0), col_type(x1, y1, z1), col_type(x2, y2, z2)}
#line 59 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x3.inl"
	{




#line 65 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x3.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 3, T, Q>::mat(col_type const& v0, col_type const& v1, col_type const& v2)

			: value{col_type(v0), col_type(v1), col_type(v2)}
#line 72 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x3.inl"
	{




#line 78 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x3.inl"
	}

	

	template<typename T, qualifier Q>
	template<
		typename X1, typename Y1, typename Z1,
		typename X2, typename Y2, typename Z2,
		typename X3, typename Y3, typename Z3>
	inline constexpr mat<3, 3, T, Q>::mat
	(
		X1 x1, Y1 y1, Z1 z1,
		X2 x2, Y2 y2, Z2 z2,
		X3 x3, Y3 y3, Z3 z3
	)

			: value{col_type(x1, y1, z1), col_type(x2, y2, z2), col_type(x3, y3, z3)}
#line 96 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x3.inl"
	{




#line 102 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x3.inl"
	}

	template<typename T, qualifier Q>
	template<typename V1, typename V2, typename V3>
	inline constexpr mat<3, 3, T, Q>::mat(vec<3, V1, Q> const& v1, vec<3, V2, Q> const& v2, vec<3, V3, Q> const& v3)

			: value{col_type(v1), col_type(v2), col_type(v3)}
#line 110 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x3.inl"
	{




#line 116 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x3.inl"
	}

	

	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	inline constexpr mat<3, 3, T, Q>::mat(mat<3, 3, U, P> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2])}
#line 126 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x3.inl"
	{




#line 132 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x3.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 3, T, Q>::mat(mat<2, 2, T, Q> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0), col_type(0, 0, 1)}
#line 139 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x3.inl"
	{




#line 145 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x3.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 3, T, Q>::mat(mat<4, 4, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2])}
#line 152 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x3.inl"
	{




#line 158 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x3.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 3, T, Q>::mat(mat<2, 3, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(0, 0, 1)}
#line 165 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x3.inl"
	{




#line 171 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x3.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 3, T, Q>::mat(mat<3, 2, T, Q> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 1)}
#line 178 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x3.inl"
	{




#line 184 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x3.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 3, T, Q>::mat(mat<2, 4, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(0, 0, 1)}
#line 191 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x3.inl"
	{




#line 197 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x3.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 3, T, Q>::mat(mat<4, 2, T, Q> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 1)}
#line 204 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x3.inl"
	{




#line 210 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x3.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 3, T, Q>::mat(mat<3, 4, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2])}
#line 217 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x3.inl"
	{




#line 223 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x3.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 3, T, Q>::mat(mat<4, 3, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2])}
#line 230 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x3.inl"
	{




#line 236 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x3.inl"
	}

	

	template<typename T, qualifier Q>
	inline constexpr typename mat<3, 3, T, Q>::col_type & mat<3, 3, T, Q>::operator[](typename mat<3, 3, T, Q>::length_type i) noexcept
	{
		((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x3.inl", (unsigned)(243)), 0) )) ;
		return this->value[i];
	}

	template<typename T, qualifier Q>
	inline constexpr typename mat<3, 3, T, Q>::col_type const& mat<3, 3, T, Q>::operator[](typename mat<3, 3, T, Q>::length_type i) const noexcept
	{
		((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x3.inl", (unsigned)(250)), 0) )) ;
		return this->value[i];
	}

	

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator=(mat<3, 3, U, Q> const& m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator+=(mat<3, 3, U, Q> const& m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator-=(mat<3, 3, U, Q> const& m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator*=(mat<3, 3, U, Q> const& m)
	{
		return (*this = *this * m);
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator/=(mat<3, 3, U, Q> const& m)
	{
		return *this *= inverse(m);
	}

	

	template<typename T, qualifier Q>
	inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator++()
	{
		++this->value[0];
		++this->value[1];
		++this->value[2];
		return *this;
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator--()
	{
		--this->value[0];
		--this->value[1];
		--this->value[2];
		return *this;
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 3, T, Q> mat<3, 3, T, Q>::operator++(int)
	{
		mat<3, 3, T, Q> Result(*this);
		++*this;
		return Result;
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 3, T, Q> mat<3, 3, T, Q>::operator--(int)
	{
		mat<3, 3, T, Q> Result(*this);
		--*this;
		return Result;
	}

	

	template<typename T, qualifier Q>
	inline constexpr mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m)
	{
		return m;
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m)
	{
		return mat<3, 3, T, Q>(
			-m[0],
			-m[1],
			-m[2]);
	}

	

	template<typename T, qualifier Q>
	inline constexpr mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m, T scalar)
	{
		return mat<3, 3, T, Q>(
			m[0] + scalar,
			m[1] + scalar,
			m[2] + scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 3, T, Q> operator+(T scalar, mat<3, 3, T, Q> const& m)
	{
		return mat<3, 3, T, Q>(
			m[0] + scalar,
			m[1] + scalar,
			m[2] + scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
	{
		return mat<3, 3, T, Q>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m, T scalar)
	{
		return mat<3, 3, T, Q>(
			m[0] - scalar,
			m[1] - scalar,
			m[2] - scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 3, T, Q> operator-(T scalar, mat<3, 3, T, Q> const& m)
	{
		return mat<3, 3, T, Q>(
			scalar - m[0],
			scalar - m[1],
			scalar - m[2]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
	{
		return mat<3, 3, T, Q>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 3, T, Q> operator*(mat<3, 3, T, Q> const& m, T scalar)
	{
		return mat<3, 3, T, Q>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 3, T, Q> operator*(T scalar, mat<3, 3, T, Q> const& m)
	{
		return mat<3, 3, T, Q>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr typename mat<3, 3, T, Q>::col_type operator*(mat<3, 3, T, Q> const& m, typename mat<3, 3, T, Q>::row_type const& v)
	{
		return typename mat<3, 3, T, Q>::col_type(
			m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
			m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z,
			m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z);
	}

	template<typename T, qualifier Q>
	inline constexpr typename mat<3, 3, T, Q>::row_type operator*(typename mat<3, 3, T, Q>::col_type const& v, mat<3, 3, T, Q> const& m)
	{
		return typename mat<3, 3, T, Q>::row_type(
			m[0][0] * v.x + m[0][1] * v.y + m[0][2] * v.z,
			m[1][0] * v.x + m[1][1] * v.y + m[1][2] * v.z,
			m[2][0] * v.x + m[2][1] * v.y + m[2][2] * v.z);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
	{
		T const SrcA00 = m1[0][0];
		T const SrcA01 = m1[0][1];
		T const SrcA02 = m1[0][2];
		T const SrcA10 = m1[1][0];
		T const SrcA11 = m1[1][1];
		T const SrcA12 = m1[1][2];
		T const SrcA20 = m1[2][0];
		T const SrcA21 = m1[2][1];
		T const SrcA22 = m1[2][2];

		T const SrcB00 = m2[0][0];
		T const SrcB01 = m2[0][1];
		T const SrcB02 = m2[0][2];
		T const SrcB10 = m2[1][0];
		T const SrcB11 = m2[1][1];
		T const SrcB12 = m2[1][2];
		T const SrcB20 = m2[2][0];
		T const SrcB21 = m2[2][1];
		T const SrcB22 = m2[2][2];

		mat<3, 3, T, Q> Result;
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
		Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
		Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12;
		Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22;
		Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22;
		Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22;
		return Result;
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
	{
		return mat<2, 3, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
	{
		return mat<4, 3, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2],
			m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1] + m1[2][2] * m2[3][2]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 3, T, Q> operator/(mat<3, 3, T, Q> const& m,	T scalar)
	{
		return mat<3, 3, T, Q>(
			m[0] / scalar,
			m[1] / scalar,
			m[2] / scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 3, T, Q> operator/(T scalar, mat<3, 3, T, Q> const& m)
	{
		return mat<3, 3, T, Q>(
			scalar / m[0],
			scalar / m[1],
			scalar / m[2]);
	}

	template<typename T, qualifier Q>
	inline constexpr typename mat<3, 3, T, Q>::col_type operator/(mat<3, 3, T, Q> const& m, typename mat<3, 3, T, Q>::row_type const& v)
	{
		return  inverse(m) * v;
	}

	template<typename T, qualifier Q>
	inline constexpr typename mat<3, 3, T, Q>::row_type operator/(typename mat<3, 3, T, Q>::col_type const& v, mat<3, 3, T, Q> const& m)
	{
		return v * inverse(m);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 3, T, Q> operator/(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
	{
		mat<3, 3, T, Q> m1_copy(m1);
		return m1_copy /= m2;
	}

	

	template<typename T, qualifier Q>
	inline constexpr bool operator==(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
	}

	template<typename T, qualifier Q>
	inline constexpr bool operator!=(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
	}
} 
#line 184 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x3.hpp"
#line 185 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x3.hpp"
#line 6 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_double3x3.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<3, 3, double, defaultp>		dmat3x3;

	
	
	
	typedef mat<3, 3, double, defaultp>		dmat3;

	
}
#line 6 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\mat3x3.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_double3x3_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef mat<3, 3, double, lowp>		lowp_dmat3;

	
	
	
	
	typedef mat<3, 3, double, mediump>	mediump_dmat3;

	
	
	
	
	typedef mat<3, 3, double, highp>	highp_dmat3;

	
	
	
	
	typedef mat<3, 3, double, lowp>		lowp_dmat3x3;

	
	
	
	
	typedef mat<3, 3, double, mediump>	mediump_dmat3x3;

	
	
	
	
	typedef mat<3, 3, double, highp>	highp_dmat3x3;

	
}
#line 7 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\mat3x3.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_float3x3.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef mat<3, 3, float, defaultp>			mat3x3;

	
	
	
	typedef mat<3, 3, float, defaultp>			mat3;

	
}
#line 8 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\mat3x3.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_float3x3_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef mat<3, 3, float, lowp>		lowp_mat3;

	
	
	
	
	typedef mat<3, 3, float, mediump>	mediump_mat3;

	
	
	
	
	typedef mat<3, 3, float, highp>		highp_mat3;

	
	
	
	
	typedef mat<3, 3, float, lowp>		lowp_mat3x3;

	
	
	
	
	typedef mat<3, 3, float, mediump>	mediump_mat3x3;

	
	
	
	
	typedef mat<3, 3, float, highp>		highp_mat3x3;

	
}
#line 9 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\mat3x3.hpp"
#line 26 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\matrix.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\mat3x4.hpp"



#pragma once
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_double3x4.hpp"



#pragma once
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x4.hpp"



#pragma once






namespace glm
{
	template<typename T, qualifier Q>
	struct mat<3, 4, T, Q>
	{
		typedef vec<4, T, Q> col_type;
		typedef vec<3, T, Q> row_type;
		typedef mat<3, 4, T, Q> type;
		typedef mat<4, 3, T, Q> transpose_type;
		typedef T value_type;

	private:
		col_type value[3];

	public:
		

		typedef length_t length_type;
		[[nodiscard]] static constexpr length_type length() { return 3; }

		[[nodiscard]] constexpr col_type & operator[](length_type i) noexcept ;
		[[nodiscard]] constexpr col_type const& operator[](length_type i) const noexcept ;

		

		 constexpr mat() = default ;
		template<qualifier P>
		constexpr mat(mat<3, 4, T, P> const& m);

		constexpr  mat(T scalar);
		constexpr mat(
			T x0, T y0, T z0, T w0,
			T x1, T y1, T z1, T w1,
			T x2, T y2, T z2, T w2);
		constexpr mat(
			col_type const& v0,
			col_type const& v1,
			col_type const& v2);

		

		template<
			typename X1, typename Y1, typename Z1, typename W1,
			typename X2, typename Y2, typename Z2, typename W2,
			typename X3, typename Y3, typename Z3, typename W3>
		constexpr mat(
			X1 x1, Y1 y1, Z1 z1, W1 w1,
			X2 x2, Y2 y2, Z2 z2, W2 w2,
			X3 x3, Y3 y3, Z3 z3, W3 w3);

		template<typename V1, typename V2, typename V3>
		constexpr mat(
			vec<4, V1, Q> const& v1,
			vec<4, V2, Q> const& v2,
			vec<4, V3, Q> const& v3);

		

		template<typename U, qualifier P>
		constexpr  mat(mat<3, 4, U, P> const& m);

		constexpr  mat(mat<2, 2, T, Q> const& x);
		constexpr  mat(mat<3, 3, T, Q> const& x);
		constexpr  mat(mat<4, 4, T, Q> const& x);
		constexpr  mat(mat<2, 3, T, Q> const& x);
		constexpr  mat(mat<3, 2, T, Q> const& x);
		constexpr  mat(mat<2, 4, T, Q> const& x);
		constexpr  mat(mat<4, 2, T, Q> const& x);
		constexpr  mat(mat<4, 3, T, Q> const& x);

		

		template<typename U>
		 constexpr mat<3, 4, T, Q> & operator=(mat<3, 4, U, Q> const& m);
		template<typename U>
		 constexpr mat<3, 4, T, Q> & operator+=(U s);
		template<typename U>
		 constexpr mat<3, 4, T, Q> & operator+=(mat<3, 4, U, Q> const& m);
		template<typename U>
		 constexpr mat<3, 4, T, Q> & operator-=(U s);
		template<typename U>
		 constexpr mat<3, 4, T, Q> & operator-=(mat<3, 4, U, Q> const& m);
		template<typename U>
		 constexpr mat<3, 4, T, Q> & operator*=(U s);
		template<typename U>
		 constexpr mat<3, 4, T, Q> & operator/=(U s);

		

		 constexpr mat<3, 4, T, Q> & operator++();
		 constexpr mat<3, 4, T, Q> & operator--();
		[[nodiscard]] constexpr mat<3, 4, T, Q> operator++(int);
		[[nodiscard]] constexpr mat<3, 4, T, Q> operator--(int);
	};

	

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m);

	

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<3, 4, T, Q> operator*(mat<3, 4, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<3, 4, T, Q> operator*(T scalar, mat<3, 4, T, Q> const& m);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr typename mat<3, 4, T, Q>::col_type operator*(mat<3, 4, T, Q> const& m, typename mat<3, 4, T, Q>::row_type const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr typename mat<3, 4, T, Q>::row_type operator*(typename mat<3, 4, T, Q>::col_type const& v, mat<3, 4, T, Q> const& m);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<4, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1,	mat<4, 3, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<2, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1, mat<2, 3, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<3, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1,	mat<3, 3, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<3, 4, T, Q> operator/(mat<3, 4, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<3, 4, T, Q> operator/(T scalar, mat<3, 4, T, Q> const& m);

	

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr bool operator==(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr bool operator!=(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2);
}


#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x4.inl"
namespace glm
{
	














#line 19 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x4.inl"

	template<typename T, qualifier Q>
	template<qualifier P>
	inline constexpr mat<3, 4, T, Q>::mat(mat<3, 4, T, P> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2])}
#line 26 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x4.inl"
	{




#line 32 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x4.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 4, T, Q>::mat(T s)

			: value{col_type(s, 0, 0, 0), col_type(0, s, 0, 0), col_type(0, 0, s, 0)}
#line 39 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x4.inl"
	{




#line 45 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x4.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 4, T, Q>::mat
	(
		T x0, T y0, T z0, T w0,
		T x1, T y1, T z1, T w1,
		T x2, T y2, T z2, T w2
	)

			: value{
				col_type(x0, y0, z0, w0),
				col_type(x1, y1, z1, w1),
				col_type(x2, y2, z2, w2)}
#line 60 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x4.inl"
	{




#line 66 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x4.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 4, T, Q>::mat(col_type const& v0, col_type const& v1, col_type const& v2)

			: value{col_type(v0), col_type(v1), col_type(v2)}
#line 73 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x4.inl"
	{




#line 79 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x4.inl"
	}

	

	template<typename T, qualifier Q>
	template<
		typename X0, typename Y0, typename Z0, typename W0,
		typename X1, typename Y1, typename Z1, typename W1,
		typename X2, typename Y2, typename Z2, typename W2>
	inline constexpr mat<3, 4, T, Q>::mat
	(
		X0 x0, Y0 y0, Z0 z0, W0 w0,
		X1 x1, Y1 y1, Z1 z1, W1 w1,
		X2 x2, Y2 y2, Z2 z2, W2 w2
	)

			: value{
				col_type(x0, y0, z0, w0),
				col_type(x1, y1, z1, w1),
				col_type(x2, y2, z2, w2)}
#line 100 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x4.inl"
	{




#line 106 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x4.inl"
	}

	template<typename T, qualifier Q>
	template<typename V1, typename V2, typename V3>
	inline constexpr mat<3, 4, T, Q>::mat(vec<4, V1, Q> const& v0, vec<4, V2, Q> const& v1, vec<4, V3, Q> const& v2)

			: value{col_type(v0), col_type(v1), col_type(v2)}
#line 114 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x4.inl"
	{




#line 120 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x4.inl"
	}

	

	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	inline constexpr mat<3, 4, T, Q>::mat(mat<3, 4, U, P> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2])}
#line 130 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x4.inl"
	{




#line 136 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x4.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 4, T, Q>::mat(mat<2, 2, T, Q> const& m)

			: value{col_type(m[0], 0, 0), col_type(m[1], 0, 0), col_type(0, 0, 1, 0)}
#line 143 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x4.inl"
	{




#line 149 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x4.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 4, T, Q>::mat(mat<3, 3, T, Q> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 0)}
#line 156 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x4.inl"
	{




#line 162 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x4.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 4, T, Q>::mat(mat<4, 4, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2])}
#line 169 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x4.inl"
	{




#line 175 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x4.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 4, T, Q>::mat(mat<2, 3, T, Q> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0), col_type(0, 0, 1, 0)}
#line 182 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x4.inl"
	{




#line 188 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x4.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 4, T, Q>::mat(mat<3, 2, T, Q> const& m)

			: value{col_type(m[0], 0, 0), col_type(m[1], 0, 0), col_type(m[2], 1, 0)}
#line 195 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x4.inl"
	{




#line 201 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x4.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 4, T, Q>::mat(mat<2, 4, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(0, 0, 1, 0)}
#line 208 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x4.inl"
	{




#line 214 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x4.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 4, T, Q>::mat(mat<4, 2, T, Q> const& m)

			: value{col_type(m[0], 0, 0), col_type(m[1], 0, 0), col_type(m[2], 1, 0)}
#line 221 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x4.inl"
	{




#line 227 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x4.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 4, T, Q>::mat(mat<4, 3, T, Q> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 0)}
#line 234 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x4.inl"
	{




#line 240 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x4.inl"
	}

	

	template<typename T, qualifier Q>
	inline constexpr typename mat<3, 4, T, Q>::col_type & mat<3, 4, T, Q>::operator[](typename mat<3, 4, T, Q>::length_type i) noexcept
	{
		((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x4.inl", (unsigned)(247)), 0) )) ;
		return this->value[i];
	}

	template<typename T, qualifier Q>
	inline constexpr typename mat<3, 4, T, Q>::col_type const& mat<3, 4, T, Q>::operator[](typename mat<3, 4, T, Q>::length_type i) const noexcept
	{
		((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x4.inl", (unsigned)(254)), 0) )) ;
		return this->value[i];
	}

	

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator=(mat<3, 4, U, Q> const& m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator+=(mat<3, 4, U, Q> const& m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator-=(mat<3, 4, U, Q> const& m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<3, 4, T, Q> & mat<3, 4, T, Q>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		return *this;
	}

	

	template<typename T, qualifier Q>
	inline constexpr mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator++()
	{
		++this->value[0];
		++this->value[1];
		++this->value[2];
		return *this;
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator--()
	{
		--this->value[0];
		--this->value[1];
		--this->value[2];
		return *this;
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 4, T, Q> mat<3, 4, T, Q>::operator++(int)
	{
		mat<3, 4, T, Q> Result(*this);
		++*this;
		return Result;
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 4, T, Q> mat<3, 4, T, Q>::operator--(int)
	{
		mat<3, 4, T, Q> Result(*this);
		--*this;
		return Result;
	}

	

	template<typename T, qualifier Q>
	inline constexpr mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m)
	{
		return m;
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m)
	{
		return mat<3, 4, T, Q>(
			-m[0],
			-m[1],
			-m[2]);
	}

	

	template<typename T, qualifier Q>
	inline constexpr mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m, T scalar)
	{
		return mat<3, 4, T, Q>(
			m[0] + scalar,
			m[1] + scalar,
			m[2] + scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
	{
		return mat<3, 4, T, Q>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m,	T scalar)
	{
		return mat<3, 4, T, Q>(
			m[0] - scalar,
			m[1] - scalar,
			m[2] - scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
	{
		return mat<3, 4, T, Q>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 4, T, Q> operator*(mat<3, 4, T, Q> const& m, T scalar)
	{
		return mat<3, 4, T, Q>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 4, T, Q> operator*(T scalar, mat<3, 4, T, Q> const& m)
	{
		return mat<3, 4, T, Q>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr typename mat<3, 4, T, Q>::col_type operator*
	(
		mat<3, 4, T, Q> const& m,
		typename mat<3, 4, T, Q>::row_type const& v
	)
	{
		return typename mat<3, 4, T, Q>::col_type(
			m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
			m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z,
			m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z,
			m[0][3] * v.x + m[1][3] * v.y + m[2][3] * v.z);
	}

	template<typename T, qualifier Q>
	inline constexpr typename mat<3, 4, T, Q>::row_type operator*
	(
		typename mat<3, 4, T, Q>::col_type const& v,
		mat<3, 4, T, Q> const& m
	)
	{
		return typename mat<3, 4, T, Q>::row_type(
			v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2] + v.w * m[0][3],
			v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2] + v.w * m[1][3],
			v.x * m[2][0] + v.y * m[2][1] + v.z * m[2][2] + v.w * m[2][3]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
	{
		const T SrcA00 = m1[0][0];
		const T SrcA01 = m1[0][1];
		const T SrcA02 = m1[0][2];
		const T SrcA03 = m1[0][3];
		const T SrcA10 = m1[1][0];
		const T SrcA11 = m1[1][1];
		const T SrcA12 = m1[1][2];
		const T SrcA13 = m1[1][3];
		const T SrcA20 = m1[2][0];
		const T SrcA21 = m1[2][1];
		const T SrcA22 = m1[2][2];
		const T SrcA23 = m1[2][3];

		const T SrcB00 = m2[0][0];
		const T SrcB01 = m2[0][1];
		const T SrcB02 = m2[0][2];
		const T SrcB10 = m2[1][0];
		const T SrcB11 = m2[1][1];
		const T SrcB12 = m2[1][2];
		const T SrcB20 = m2[2][0];
		const T SrcB21 = m2[2][1];
		const T SrcB22 = m2[2][2];
		const T SrcB30 = m2[3][0];
		const T SrcB31 = m2[3][1];
		const T SrcB32 = m2[3][2];

		mat<4, 4, T, Q> Result;
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
		Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02;
		Result[0][3] = SrcA03 * SrcB00 + SrcA13 * SrcB01 + SrcA23 * SrcB02;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
		Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12;
		Result[1][3] = SrcA03 * SrcB10 + SrcA13 * SrcB11 + SrcA23 * SrcB12;
		Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22;
		Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22;
		Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22;
		Result[2][3] = SrcA03 * SrcB20 + SrcA13 * SrcB21 + SrcA23 * SrcB22;
		Result[3][0] = SrcA00 * SrcB30 + SrcA10 * SrcB31 + SrcA20 * SrcB32;
		Result[3][1] = SrcA01 * SrcB30 + SrcA11 * SrcB31 + SrcA21 * SrcB32;
		Result[3][2] = SrcA02 * SrcB30 + SrcA12 * SrcB31 + SrcA22 * SrcB32;
		Result[3][3] = SrcA03 * SrcB30 + SrcA13 * SrcB31 + SrcA23 * SrcB32;
		return Result;
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
	{
		return mat<2, 4, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
	{
		return mat<3, 4, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2],
			m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1] + m1[2][3] * m2[2][2]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 4, T, Q> operator/(mat<3, 4, T, Q> const& m,	T scalar)
	{
		return mat<3, 4, T, Q>(
			m[0] / scalar,
			m[1] / scalar,
			m[2] / scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 4, T, Q> operator/(T scalar, mat<3, 4, T, Q> const& m)
	{
		return mat<3, 4, T, Q>(
			scalar / m[0],
			scalar / m[1],
			scalar / m[2]);
	}

	

	template<typename T, qualifier Q>
	inline constexpr bool operator==(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
	}

	template<typename T, qualifier Q>
	inline constexpr bool operator!=(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
	}
} 
#line 166 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x4.hpp"
#line 167 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat3x4.hpp"
#line 6 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_double3x4.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<3, 4, double, defaultp>		dmat3x4;

	
}
#line 6 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\mat3x4.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_double3x4_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef mat<3, 4, double, lowp>		lowp_dmat3x4;

	
	
	
	
	typedef mat<3, 4, double, mediump>	mediump_dmat3x4;

	
	
	
	
	typedef mat<3, 4, double, highp>	highp_dmat3x4;

	
}
#line 7 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\mat3x4.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_float3x4.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef mat<3, 4, float, defaultp>			mat3x4;

	
}
#line 8 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\mat3x4.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_float3x4_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef mat<3, 4, float, lowp>		lowp_mat3x4;

	
	
	
	
	typedef mat<3, 4, float, mediump>	mediump_mat3x4;

	
	
	
	
	typedef mat<3, 4, float, highp>		highp_mat3x4;

	
}
#line 9 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\mat3x4.hpp"
#line 27 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\matrix.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\mat4x2.hpp"



#pragma once
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_double4x2.hpp"



#pragma once
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x2.hpp"



#pragma once






namespace glm
{
	template<typename T, qualifier Q>
	struct mat<4, 2, T, Q>
	{
		typedef vec<2, T, Q> col_type;
		typedef vec<4, T, Q> row_type;
		typedef mat<4, 2, T, Q> type;
		typedef mat<2, 4, T, Q> transpose_type;
		typedef T value_type;

	private:
		col_type value[4];

	public:
		

		typedef length_t length_type;
		[[nodiscard]] static constexpr length_type length() { return 4; }

		[[nodiscard]] constexpr col_type & operator[](length_type i) noexcept ;
		[[nodiscard]] constexpr col_type const& operator[](length_type i) const noexcept ;

		

		 constexpr mat() = default ;
		template<qualifier P>
		constexpr mat(mat<4, 2, T, P> const& m);

		constexpr mat(T scalar);
		constexpr mat(
			T x0, T y0,
			T x1, T y1,
			T x2, T y2,
			T x3, T y3);
		constexpr mat(
			col_type const& v0,
			col_type const& v1,
			col_type const& v2,
			col_type const& v3);

		

		template<
			typename X0, typename Y0,
			typename X1, typename Y1,
			typename X2, typename Y2,
			typename X3, typename Y3>
		constexpr mat(
			X0 x0, Y0 y0,
			X1 x1, Y1 y1,
			X2 x2, Y2 y2,
			X3 x3, Y3 y3);

		template<typename V1, typename V2, typename V3, typename V4>
		constexpr mat(
			vec<2, V1, Q> const& v1,
			vec<2, V2, Q> const& v2,
			vec<2, V3, Q> const& v3,
			vec<2, V4, Q> const& v4);

		

		template<typename U, qualifier P>
		constexpr mat(mat<4, 2, U, P> const& m);

		constexpr mat(mat<2, 2, T, Q> const& x);
		constexpr mat(mat<3, 3, T, Q> const& x);
		constexpr mat(mat<4, 4, T, Q> const& x);
		constexpr mat(mat<2, 3, T, Q> const& x);
		constexpr mat(mat<3, 2, T, Q> const& x);
		constexpr mat(mat<2, 4, T, Q> const& x);
		constexpr mat(mat<4, 3, T, Q> const& x);
		constexpr mat(mat<3, 4, T, Q> const& x);

		

		template<typename U>
		 constexpr mat<4, 2, T, Q> & operator=(mat<4, 2, U, Q> const& m);
		template<typename U>
		 constexpr mat<4, 2, T, Q> & operator+=(U s);
		template<typename U>
		 constexpr mat<4, 2, T, Q> & operator+=(mat<4, 2, U, Q> const& m);
		template<typename U>
		 constexpr mat<4, 2, T, Q> & operator-=(U s);
		template<typename U>
		 constexpr mat<4, 2, T, Q> & operator-=(mat<4, 2, U, Q> const& m);
		template<typename U>
		 constexpr mat<4, 2, T, Q> & operator*=(U s);
		template<typename U>
		 constexpr mat<4, 2, T, Q> & operator/=(U s);

		

		 constexpr mat<4, 2, T, Q> & operator++ ();
		 constexpr mat<4, 2, T, Q> & operator-- ();
		[[nodiscard]] constexpr mat<4, 2, T, Q> operator++(int);
		[[nodiscard]] constexpr mat<4, 2, T, Q> operator--(int);
	};

	

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m);

	

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m1,	mat<4, 2, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<4, 2, T, Q> operator*(mat<4, 2, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<4, 2, T, Q> operator*(T scalar, mat<4, 2, T, Q> const& m);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr typename mat<4, 2, T, Q>::col_type operator*(mat<4, 2, T, Q> const& m, typename mat<4, 2, T, Q>::row_type const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr typename mat<4, 2, T, Q>::row_type operator*(typename mat<4, 2, T, Q>::col_type const& v, mat<4, 2, T, Q> const& m);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<2, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<2, 4, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<3, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<3, 4, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<4, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<4, 4, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<4, 2, T, Q> operator/(mat<4, 2, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<4, 2, T, Q> operator/(T scalar, mat<4, 2, T, Q> const& m);

	

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr bool operator==(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr bool operator!=(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2);
}


#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x2.inl"
namespace glm
{
	















#line 20 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x2.inl"

	template<typename T, qualifier Q>
	template<qualifier P>
	inline constexpr mat<4, 2, T, Q>::mat(mat<4, 2, T, P> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}
#line 27 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x2.inl"
	{





#line 34 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x2.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 2, T, Q>::mat(T s)

			: value{col_type(s, 0), col_type(0, s), col_type(0, 0), col_type(0, 0)}
#line 41 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x2.inl"
	{





#line 48 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x2.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 2, T, Q>::mat
	(
		T x0, T y0,
		T x1, T y1,
		T x2, T y2,
		T x3, T y3
	)

			: value{col_type(x0, y0), col_type(x1, y1), col_type(x2, y2), col_type(x3, y3)}
#line 61 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x2.inl"
	{





#line 68 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x2.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 2, T, Q>::mat(col_type const& v0, col_type const& v1, col_type const& v2, col_type const& v3)

			: value{col_type(v0), col_type(v1), col_type(v2), col_type(v3)}
#line 75 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x2.inl"
	{





#line 82 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x2.inl"
	}

	

	template<typename T, qualifier Q>
	template<
		typename X0, typename Y0,
		typename X1, typename Y1,
		typename X2, typename Y2,
		typename X3, typename Y3>
	inline constexpr mat<4, 2, T, Q>::mat
	(
		X0 x0, Y0 y0,
		X1 x1, Y1 y1,
		X2 x2, Y2 y2,
		X3 x3, Y3 y3
	)

			: value{col_type(x0, y0), col_type(x1, y1), col_type(x2, y2), col_type(x3, y3)}
#line 102 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x2.inl"
	{





#line 109 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x2.inl"
	}

	template<typename T, qualifier Q>
	template<typename V0, typename V1, typename V2, typename V3>
	inline constexpr mat<4, 2, T, Q>::mat(vec<2, V0, Q> const& v0, vec<2, V1, Q> const& v1, vec<2, V2, Q> const& v2, vec<2, V3, Q> const& v3)

			: value{col_type(v0), col_type(v1), col_type(v2), col_type(v3)}
#line 117 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x2.inl"
	{





#line 124 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x2.inl"
	}

	

	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	inline constexpr mat<4, 2, T, Q>::mat(mat<4, 2, U, P> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}
#line 134 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x2.inl"
	{





#line 141 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x2.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 2, T, Q>::mat(mat<2, 2, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(0), col_type(0)}
#line 148 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x2.inl"
	{





#line 155 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x2.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 2, T, Q>::mat(mat<3, 3, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(0)}
#line 162 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x2.inl"
	{





#line 169 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x2.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 2, T, Q>::mat(mat<4, 4, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}
#line 176 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x2.inl"
	{





#line 183 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x2.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 2, T, Q>::mat(mat<2, 3, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(0), col_type(0)}
#line 190 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x2.inl"
	{





#line 197 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x2.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 2, T, Q>::mat(mat<3, 2, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(0)}
#line 204 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x2.inl"
	{





#line 211 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x2.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 2, T, Q>::mat(mat<2, 4, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(0), col_type(0)}
#line 218 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x2.inl"
	{





#line 225 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x2.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 2, T, Q>::mat(mat<4, 3, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}
#line 232 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x2.inl"
	{





#line 239 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x2.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 2, T, Q>::mat(mat<3, 4, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(0)}
#line 246 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x2.inl"
	{





#line 253 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x2.inl"
	}

	

	template<typename T, qualifier Q>
	inline constexpr typename mat<4, 2, T, Q>::col_type & mat<4, 2, T, Q>::operator[](typename mat<4, 2, T, Q>::length_type i) noexcept
	{
		((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x2.inl", (unsigned)(260)), 0) )) ;
		return this->value[i];
	}

	template<typename T, qualifier Q>
	inline constexpr typename mat<4, 2, T, Q>::col_type const& mat<4, 2, T, Q>::operator[](typename mat<4, 2, T, Q>::length_type i) const noexcept
	{
		((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x2.inl", (unsigned)(267)), 0) )) ;
		return this->value[i];
	}

	

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<4, 2, T, Q>& mat<4, 2, T, Q>::operator=(mat<4, 2, U, Q> const& m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		this->value[3] = m[3];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		this->value[3] += s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator+=(mat<4, 2, U, Q> const& m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		this->value[3] += m[3];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		this->value[3] -= s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator-=(mat<4, 2, U, Q> const& m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		this->value[3] -= m[3];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		this->value[3] *= s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		this->value[3] /= s;
		return *this;
	}

	

	template<typename T, qualifier Q>
	inline constexpr mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator++()
	{
		++this->value[0];
		++this->value[1];
		++this->value[2];
		++this->value[3];
		return *this;
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator--()
	{
		--this->value[0];
		--this->value[1];
		--this->value[2];
		--this->value[3];
		return *this;
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 2, T, Q> mat<4, 2, T, Q>::operator++(int)
	{
		mat<4, 2, T, Q> Result(*this);
		++*this;
		return Result;
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 2, T, Q> mat<4, 2, T, Q>::operator--(int)
	{
		mat<4, 2, T, Q> Result(*this);
		--*this;
		return Result;
	}

	

	template<typename T, qualifier Q>
	inline constexpr mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m)
	{
		return m;
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m)
	{
		return mat<4, 2, T, Q>(
			-m[0],
			-m[1],
			-m[2],
			-m[3]);
	}

	

	template<typename T, qualifier Q>
	inline constexpr mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m, T scalar)
	{
		return mat<4, 2, T, Q>(
			m[0] + scalar,
			m[1] + scalar,
			m[2] + scalar,
			m[3] + scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
	{
		return mat<4, 2, T, Q>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2],
			m1[3] + m2[3]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m, T scalar)
	{
		return mat<4, 2, T, Q>(
			m[0] - scalar,
			m[1] - scalar,
			m[2] - scalar,
			m[3] - scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
	{
		return mat<4, 2, T, Q>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2],
			m1[3] - m2[3]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 2, T, Q> operator*(mat<4, 2, T, Q> const& m, T scalar)
	{
		return mat<4, 2, T, Q>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar,
			m[3] * scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 2, T, Q> operator*(T scalar, mat<4, 2, T, Q> const& m)
	{
		return mat<4, 2, T, Q>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar,
			m[3] * scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr typename mat<4, 2, T, Q>::col_type operator*(mat<4, 2, T, Q> const& m, typename mat<4, 2, T, Q>::row_type const& v)
	{
		return typename mat<4, 2, T, Q>::col_type(
			m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z + m[3][0] * v.w,
			m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z + m[3][1] * v.w);
	}

	template<typename T, qualifier Q>
	inline constexpr typename mat<4, 2, T, Q>::row_type operator*(typename mat<4, 2, T, Q>::col_type const& v, mat<4, 2, T, Q> const& m)
	{
		return typename mat<4, 2, T, Q>::row_type(
			v.x * m[0][0] + v.y * m[0][1],
			v.x * m[1][0] + v.y * m[1][1],
			v.x * m[2][0] + v.y * m[2][1],
			v.x * m[3][0] + v.y * m[3][1]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
	{
		T const SrcA00 = m1[0][0];
		T const SrcA01 = m1[0][1];
		T const SrcA10 = m1[1][0];
		T const SrcA11 = m1[1][1];
		T const SrcA20 = m1[2][0];
		T const SrcA21 = m1[2][1];
		T const SrcA30 = m1[3][0];
		T const SrcA31 = m1[3][1];

		T const SrcB00 = m2[0][0];
		T const SrcB01 = m2[0][1];
		T const SrcB02 = m2[0][2];
		T const SrcB03 = m2[0][3];
		T const SrcB10 = m2[1][0];
		T const SrcB11 = m2[1][1];
		T const SrcB12 = m2[1][2];
		T const SrcB13 = m2[1][3];

		mat<2, 2, T, Q> Result;
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02 + SrcA30 * SrcB03;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02 + SrcA31 * SrcB03;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12 + SrcA30 * SrcB13;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12 + SrcA31 * SrcB13;
		return Result;
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
	{
		return mat<3, 2, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
	{
		return mat<4, 2, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2] + m1[3][0] * m2[3][3],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2] + m1[3][1] * m2[3][3]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 2, T, Q> operator/(mat<4, 2, T, Q> const& m, T scalar)
	{
		return mat<4, 2, T, Q>(
			m[0] / scalar,
			m[1] / scalar,
			m[2] / scalar,
			m[3] / scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 2, T, Q> operator/(T scalar, mat<4, 2, T, Q> const& m)
	{
		return mat<4, 2, T, Q>(
			scalar / m[0],
			scalar / m[1],
			scalar / m[2],
			scalar / m[3]);
	}

	

	template<typename T, qualifier Q>
	inline constexpr bool operator==(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
	}

	template<typename T, qualifier Q>
	inline constexpr bool operator!=(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
	}
} 
#line 171 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x2.hpp"
#line 172 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x2.hpp"
#line 6 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_double4x2.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<4, 2, double, defaultp>		dmat4x2;

	
}
#line 6 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\mat4x2.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_double4x2_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef mat<4, 2, double, lowp>		lowp_dmat4x2;

	
	
	
	
	typedef mat<4, 2, double, mediump>	mediump_dmat4x2;

	
	
	
	
	typedef mat<4, 2, double, highp>	highp_dmat4x2;

	
}
#line 7 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\mat4x2.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_float4x2.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef mat<4, 2, float, defaultp>			mat4x2;

	
}
#line 8 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\mat4x2.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_float4x2_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef mat<4, 2, float, lowp>		lowp_mat4x2;

	
	
	
	
	typedef mat<4, 2, float, mediump>	mediump_mat4x2;

	
	
	
	
	typedef mat<4, 2, float, highp>		highp_mat4x2;

	
}
#line 9 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\mat4x2.hpp"

#line 28 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\matrix.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\mat4x3.hpp"



#pragma once
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_double4x3.hpp"



#pragma once
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x3.hpp"



#pragma once






namespace glm
{
	template<typename T, qualifier Q>
	struct mat<4, 3, T, Q>
	{
		typedef vec<3, T, Q> col_type;
		typedef vec<4, T, Q> row_type;
		typedef mat<4, 3, T, Q> type;
		typedef mat<3, 4, T, Q> transpose_type;
		typedef T value_type;

	private:
		col_type value[4];

	public:
		

		typedef length_t length_type;
		[[nodiscard]] static constexpr length_type length() { return 4; }

		[[nodiscard]] constexpr col_type & operator[](length_type i) noexcept ;
		[[nodiscard]] constexpr col_type const& operator[](length_type i) const noexcept ;

		

		 constexpr mat() = default ;
		template<qualifier P>
		constexpr mat(mat<4, 3, T, P> const& m);

		constexpr  mat(T s);
		constexpr mat(
			T const& x0, T const& y0, T const& z0,
			T const& x1, T const& y1, T const& z1,
			T const& x2, T const& y2, T const& z2,
			T const& x3, T const& y3, T const& z3);
		constexpr mat(
			col_type const& v0,
			col_type const& v1,
			col_type const& v2,
			col_type const& v3);

		

		template<
			typename X1, typename Y1, typename Z1,
			typename X2, typename Y2, typename Z2,
			typename X3, typename Y3, typename Z3,
			typename X4, typename Y4, typename Z4>
		constexpr mat(
			X1 const& x1, Y1 const& y1, Z1 const& z1,
			X2 const& x2, Y2 const& y2, Z2 const& z2,
			X3 const& x3, Y3 const& y3, Z3 const& z3,
			X4 const& x4, Y4 const& y4, Z4 const& z4);

		template<typename V1, typename V2, typename V3, typename V4>
		constexpr mat(
			vec<3, V1, Q> const& v1,
			vec<3, V2, Q> const& v2,
			vec<3, V3, Q> const& v3,
			vec<3, V4, Q> const& v4);

		

		template<typename U, qualifier P>
		constexpr mat(mat<4, 3, U, P> const& m);

		constexpr mat(mat<2, 2, T, Q> const& x);
		constexpr mat(mat<3, 3, T, Q> const& x);
		constexpr mat(mat<4, 4, T, Q> const& x);
		constexpr mat(mat<2, 3, T, Q> const& x);
		constexpr mat(mat<3, 2, T, Q> const& x);
		constexpr mat(mat<2, 4, T, Q> const& x);
		constexpr mat(mat<4, 2, T, Q> const& x);
		constexpr mat(mat<3, 4, T, Q> const& x);

		

		template<typename U>
		 constexpr mat<4, 3, T, Q> & operator=(mat<4, 3, U, Q> const& m);
		template<typename U>
		 constexpr mat<4, 3, T, Q> & operator+=(U s);
		template<typename U>
		 constexpr mat<4, 3, T, Q> & operator+=(mat<4, 3, U, Q> const& m);
		template<typename U>
		 constexpr mat<4, 3, T, Q> & operator-=(U s);
		template<typename U>
		 constexpr mat<4, 3, T, Q> & operator-=(mat<4, 3, U, Q> const& m);
		template<typename U>
		 constexpr mat<4, 3, T, Q> & operator*=(U s);
		template<typename U>
		 constexpr mat<4, 3, T, Q> & operator/=(U s);

		

		 constexpr mat<4, 3, T, Q>& operator++();
		 constexpr mat<4, 3, T, Q>& operator--();
		[[nodiscard]] constexpr mat<4, 3, T, Q> operator++(int);
		[[nodiscard]] constexpr mat<4, 3, T, Q> operator--(int);
	};

	

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m);

	

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<4, 3, T, Q> operator*(mat<4, 3, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<4, 3, T, Q> operator*(T scalar, mat<4, 3, T, Q> const& m);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr typename mat<4, 3, T, Q>::col_type operator*(mat<4, 3, T, Q> const& m, typename mat<4, 3, T, Q>::row_type const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr typename mat<4, 3, T, Q>::row_type operator*(typename mat<4, 3, T, Q>::col_type const& v, mat<4, 3, T, Q> const& m);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<2, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1, mat<2, 4, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<3, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1,	mat<3, 4, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<4, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1, mat<4, 4, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<4, 3, T, Q> operator/(mat<4, 3, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<4, 3, T, Q> operator/(T scalar, mat<4, 3, T, Q> const& m);

	

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr bool operator==(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr bool operator!=(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2);
}


#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x3.inl"
namespace glm
{
	















#line 20 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x3.inl"

	template<typename T, qualifier Q>
	template<qualifier P>
	inline constexpr mat<4, 3, T, Q>::mat(mat<4, 3, T, P> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}
#line 27 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x3.inl"
	{





#line 34 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x3.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 3, T, Q>::mat(T s)

			: value{col_type(s, 0, 0), col_type(0, s, 0), col_type(0, 0, s), col_type(0, 0, 0)}
#line 41 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x3.inl"
	{





#line 48 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x3.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 3, T, Q>::mat
	(
		T const& x0, T const& y0, T const& z0,
		T const& x1, T const& y1, T const& z1,
		T const& x2, T const& y2, T const& z2,
		T const& x3, T const& y3, T const& z3
	)

			: value{col_type(x0, y0, z0), col_type(x1, y1, z1), col_type(x2, y2, z2), col_type(x3, y3, z3)}
#line 61 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x3.inl"
	{





#line 68 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x3.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 3, T, Q>::mat(col_type const& v0, col_type const& v1, col_type const& v2, col_type const& v3)

			: value{col_type(v0), col_type(v1), col_type(v2), col_type(v3)}
#line 75 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x3.inl"
	{





#line 82 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x3.inl"
	}

	

	template<typename T, qualifier Q>
	template<
		typename X0, typename Y0, typename Z0,
		typename X1, typename Y1, typename Z1,
		typename X2, typename Y2, typename Z2,
		typename X3, typename Y3, typename Z3>
	inline constexpr mat<4, 3, T, Q>::mat
	(
		X0 const& x0, Y0 const& y0, Z0 const& z0,
		X1 const& x1, Y1 const& y1, Z1 const& z1,
		X2 const& x2, Y2 const& y2, Z2 const& z2,
		X3 const& x3, Y3 const& y3, Z3 const& z3
	)

			: value{col_type(x0, y0, z0), col_type(x1, y1, z1), col_type(x2, y2, z2), col_type(x3, y3, z3)}
#line 102 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x3.inl"
	{





#line 109 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x3.inl"
	}

	template<typename T, qualifier Q>
	template<typename V1, typename V2, typename V3, typename V4>
	inline constexpr mat<4, 3, T, Q>::mat(vec<3, V1, Q> const& v1, vec<3, V2, Q> const& v2, vec<3, V3, Q> const& v3, vec<3, V4, Q> const& v4)

			: value{col_type(v1), col_type(v2), col_type(v3), col_type(v4)}
#line 117 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x3.inl"
	{





#line 124 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x3.inl"
	}

	

	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	inline constexpr mat<4, 3, T, Q>::mat(mat<4, 3, U, P> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}
#line 134 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x3.inl"
	{





#line 141 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x3.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 3, T, Q>::mat(mat<2, 2, T, Q> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0), col_type(0, 0, 1), col_type(0)}
#line 148 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x3.inl"
	{





#line 155 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x3.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 3, T, Q>::mat(mat<3, 3, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(0)}
#line 162 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x3.inl"
	{





#line 169 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x3.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 3, T, Q>::mat(mat<4, 4, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}
#line 176 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x3.inl"
	{





#line 183 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x3.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 3, T, Q>::mat(mat<2, 3, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(0, 0, 1), col_type(0)}
#line 190 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x3.inl"
	{





#line 197 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x3.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 3, T, Q>::mat(mat<3, 2, T, Q> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 1), col_type(0)}
#line 204 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x3.inl"
	{





#line 211 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x3.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 3, T, Q>::mat(mat<2, 4, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(0, 0, 1), col_type(0)}
#line 218 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x3.inl"
	{





#line 225 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x3.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 3, T, Q>::mat(mat<4, 2, T, Q> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 1), col_type(m[3], 0)}
#line 232 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x3.inl"
	{





#line 239 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x3.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 3, T, Q>::mat(mat<3, 4, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(0)}
#line 246 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x3.inl"
	{





#line 253 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x3.inl"
	}

	

	template<typename T, qualifier Q>
	inline constexpr typename mat<4, 3, T, Q>::col_type & mat<4, 3, T, Q>::operator[](typename mat<4, 3, T, Q>::length_type i) noexcept
	{
		((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x3.inl", (unsigned)(260)), 0) )) ;
		return this->value[i];
	}

	template<typename T, qualifier Q>
	inline constexpr typename mat<4, 3, T, Q>::col_type const& mat<4, 3, T, Q>::operator[](typename mat<4, 3, T, Q>::length_type i) const noexcept
	{
		((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x3.inl", (unsigned)(267)), 0) )) ;
		return this->value[i];
	}

	

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<4, 3, T, Q>& mat<4, 3, T, Q>::operator=(mat<4, 3, U, Q> const& m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		this->value[3] = m[3];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		this->value[3] += s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator+=(mat<4, 3, U, Q> const& m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		this->value[3] += m[3];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		this->value[3] -= s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator-=(mat<4, 3, U, Q> const& m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		this->value[3] -= m[3];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		this->value[3] *= s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		this->value[3] /= s;
		return *this;
	}

	

	template<typename T, qualifier Q>
	inline constexpr mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator++()
	{
		++this->value[0];
		++this->value[1];
		++this->value[2];
		++this->value[3];
		return *this;
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator--()
	{
		--this->value[0];
		--this->value[1];
		--this->value[2];
		--this->value[3];
		return *this;
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 3, T, Q> mat<4, 3, T, Q>::operator++(int)
	{
		mat<4, 3, T, Q> Result(*this);
		++*this;
		return Result;
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 3, T, Q> mat<4, 3, T, Q>::operator--(int)
	{
		mat<4, 3, T, Q> Result(*this);
		--*this;
		return Result;
	}

	

	template<typename T, qualifier Q>
	inline constexpr mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m)
	{
		return m;
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m)
	{
		return mat<4, 3, T, Q>(
			-m[0],
			-m[1],
			-m[2],
			-m[3]);
	}

	

	template<typename T, qualifier Q>
	inline constexpr mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m, T scalar)
	{
		return mat<4, 3, T, Q>(
			m[0] + scalar,
			m[1] + scalar,
			m[2] + scalar,
			m[3] + scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
	{
		return mat<4, 3, T, Q>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2],
			m1[3] + m2[3]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m, T scalar)
	{
		return mat<4, 3, T, Q>(
			m[0] - scalar,
			m[1] - scalar,
			m[2] - scalar,
			m[3] - scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
	{
		return mat<4, 3, T, Q>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2],
			m1[3] - m2[3]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 3, T, Q> operator*(mat<4, 3, T, Q> const& m, T scalar)
	{
		return mat<4, 3, T, Q>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar,
			m[3] * scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 3, T, Q> operator*(T scalar, mat<4, 3, T, Q> const& m)
	{
		return mat<4, 3, T, Q>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar,
			m[3] * scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr typename mat<4, 3, T, Q>::col_type operator*
	(
		mat<4, 3, T, Q> const& m,
		typename mat<4, 3, T, Q>::row_type const& v)
	{
		return typename mat<4, 3, T, Q>::col_type(
			m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z + m[3][0] * v.w,
			m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z + m[3][1] * v.w,
			m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z + m[3][2] * v.w);
	}

	template<typename T, qualifier Q>
	inline constexpr typename mat<4, 3, T, Q>::row_type operator*
	(
		typename mat<4, 3, T, Q>::col_type const& v,
		mat<4, 3, T, Q> const& m)
	{
		return typename mat<4, 3, T, Q>::row_type(
			v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2],
			v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2],
			v.x * m[2][0] + v.y * m[2][1] + v.z * m[2][2],
			v.x * m[3][0] + v.y * m[3][1] + v.z * m[3][2]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
	{
		return mat<2, 3, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
	{
		T const SrcA00 = m1[0][0];
		T const SrcA01 = m1[0][1];
		T const SrcA02 = m1[0][2];
		T const SrcA10 = m1[1][0];
		T const SrcA11 = m1[1][1];
		T const SrcA12 = m1[1][2];
		T const SrcA20 = m1[2][0];
		T const SrcA21 = m1[2][1];
		T const SrcA22 = m1[2][2];
		T const SrcA30 = m1[3][0];
		T const SrcA31 = m1[3][1];
		T const SrcA32 = m1[3][2];

		T const SrcB00 = m2[0][0];
		T const SrcB01 = m2[0][1];
		T const SrcB02 = m2[0][2];
		T const SrcB03 = m2[0][3];
		T const SrcB10 = m2[1][0];
		T const SrcB11 = m2[1][1];
		T const SrcB12 = m2[1][2];
		T const SrcB13 = m2[1][3];
		T const SrcB20 = m2[2][0];
		T const SrcB21 = m2[2][1];
		T const SrcB22 = m2[2][2];
		T const SrcB23 = m2[2][3];

		mat<3, 3, T, Q> Result;
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02 + SrcA30 * SrcB03;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02 + SrcA31 * SrcB03;
		Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02 + SrcA32 * SrcB03;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12 + SrcA30 * SrcB13;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12 + SrcA31 * SrcB13;
		Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12 + SrcA32 * SrcB13;
		Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22 + SrcA30 * SrcB23;
		Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22 + SrcA31 * SrcB23;
		Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22 + SrcA32 * SrcB23;
		return Result;
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
	{
		return mat<4, 3, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2] + m1[3][2] * m2[2][3],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2] + m1[3][0] * m2[3][3],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2] + m1[3][1] * m2[3][3],
			m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1] + m1[2][2] * m2[3][2] + m1[3][2] * m2[3][3]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 3, T, Q> operator/(mat<4, 3, T, Q> const& m, T scalar)
	{
		return mat<4, 3, T, Q>(
			m[0] / scalar,
			m[1] / scalar,
			m[2] / scalar,
			m[3] / scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 3, T, Q> operator/(T scalar, mat<4, 3, T, Q> const& m)
	{
		return mat<4, 3, T, Q>(
			scalar / m[0],
			scalar / m[1],
			scalar / m[2],
			scalar / m[3]);
	}

	

	template<typename T, qualifier Q>
	inline constexpr bool operator==(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
	}

	template<typename T, qualifier Q>
	inline constexpr bool operator!=(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
	}
} 
#line 171 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x3.hpp"
#line 172 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x3.hpp"
#line 6 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_double4x3.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<4, 3, double, defaultp>		dmat4x3;

	
}
#line 6 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\mat4x3.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_double4x3_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef mat<4, 3, double, lowp>		lowp_dmat4x3;

	
	
	
	
	typedef mat<4, 3, double, mediump>	mediump_dmat4x3;

	
	
	
	
	typedef mat<4, 3, double, highp>	highp_dmat4x3;

	
}
#line 7 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\mat4x3.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_float4x3.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef mat<4, 3, float, defaultp>			mat4x3;

	
}
#line 8 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\mat4x3.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_float4x3_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef mat<4, 3, float, lowp>		lowp_mat4x3;

	
	
	
	
	typedef mat<4, 3, float, mediump>	mediump_mat4x3;

	
	
	
	
	typedef mat<4, 3, float, highp>		highp_mat4x3;

	
}
#line 9 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\mat4x3.hpp"
#line 29 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\matrix.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\mat4x4.hpp"



#pragma once
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_double4x4.hpp"



#pragma once
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x4.hpp"



#pragma once





namespace glm
{
	template<typename T, qualifier Q>
	struct mat<4, 4, T, Q>
	{
		typedef vec<4, T, Q> col_type;
		typedef vec<4, T, Q> row_type;
		typedef mat<4, 4, T, Q> type;
		typedef mat<4, 4, T, Q> transpose_type;
		typedef T value_type;

	private:
		col_type value[4];

	public:
		

		typedef length_t length_type;
		[[nodiscard]] static constexpr length_type length(){return 4;}

		[[nodiscard]] constexpr col_type & operator[](length_type i) noexcept ;
		[[nodiscard]] constexpr col_type const& operator[](length_type i) const noexcept ;

		

		 constexpr mat() = default ;
		template<qualifier P>
		constexpr mat(mat<4, 4, T, P> const& m);

		constexpr  mat(T s);
		constexpr mat(
			T const& x0, T const& y0, T const& z0, T const& w0,
			T const& x1, T const& y1, T const& z1, T const& w1,
			T const& x2, T const& y2, T const& z2, T const& w2,
			T const& x3, T const& y3, T const& z3, T const& w3);
		constexpr mat(
			col_type const& v0,
			col_type const& v1,
			col_type const& v2,
			col_type const& v3);

		

		template<
			typename X1, typename Y1, typename Z1, typename W1,
			typename X2, typename Y2, typename Z2, typename W2,
			typename X3, typename Y3, typename Z3, typename W3,
			typename X4, typename Y4, typename Z4, typename W4>
		constexpr mat(
			X1 const& x1, Y1 const& y1, Z1 const& z1, W1 const& w1,
			X2 const& x2, Y2 const& y2, Z2 const& z2, W2 const& w2,
			X3 const& x3, Y3 const& y3, Z3 const& z3, W3 const& w3,
			X4 const& x4, Y4 const& y4, Z4 const& z4, W4 const& w4);

		template<typename V1, typename V2, typename V3, typename V4>
		constexpr mat(
			vec<4, V1, Q> const& v1,
			vec<4, V2, Q> const& v2,
			vec<4, V3, Q> const& v3,
			vec<4, V4, Q> const& v4);

		

		template<typename U, qualifier P>
		constexpr  mat(mat<4, 4, U, P> const& m);

		constexpr  mat(mat<2, 2, T, Q> const& x);
		constexpr  mat(mat<3, 3, T, Q> const& x);
		constexpr  mat(mat<2, 3, T, Q> const& x);
		constexpr  mat(mat<3, 2, T, Q> const& x);
		constexpr  mat(mat<2, 4, T, Q> const& x);
		constexpr  mat(mat<4, 2, T, Q> const& x);
		constexpr  mat(mat<3, 4, T, Q> const& x);
		constexpr  mat(mat<4, 3, T, Q> const& x);

		

		template<typename U>
		 constexpr mat<4, 4, T, Q> & operator=(mat<4, 4, U, Q> const& m);
		template<typename U>
		 constexpr mat<4, 4, T, Q> & operator+=(U s);
		template<typename U>
		 constexpr mat<4, 4, T, Q> & operator+=(mat<4, 4, U, Q> const& m);
		template<typename U>
		 constexpr mat<4, 4, T, Q> & operator-=(U s);
		template<typename U>
		 constexpr mat<4, 4, T, Q> & operator-=(mat<4, 4, U, Q> const& m);
		template<typename U>
		 constexpr mat<4, 4, T, Q> & operator*=(U s);
		template<typename U>
		 constexpr mat<4, 4, T, Q> & operator*=(mat<4, 4, U, Q> const& m);
		template<typename U>
		 constexpr mat<4, 4, T, Q> & operator/=(U s);
		template<typename U>
		 constexpr mat<4, 4, T, Q> & operator/=(mat<4, 4, U, Q> const& m);

		

		 constexpr mat<4, 4, T, Q> & operator++();
		 constexpr mat<4, 4, T, Q> & operator--();
		[[nodiscard]] constexpr mat<4, 4, T, Q> operator++(int);
		[[nodiscard]] constexpr mat<4, 4, T, Q> operator--(int);
	};

	

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m);

	

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<4, 4, T, Q> operator+(T scalar, mat<4, 4, T, Q> const& m);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<4, 4, T, Q> operator-(T scalar, mat<4, 4, T, Q> const& m);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m1,	mat<4, 4, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<4, 4, T, Q> operator*(mat<4, 4, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<4, 4, T, Q> operator*(T scalar, mat<4, 4, T, Q> const& m);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr typename mat<4, 4, T, Q>::col_type operator*(mat<4, 4, T, Q> const& m, typename mat<4, 4, T, Q>::row_type const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr typename mat<4, 4, T, Q>::row_type operator*(typename mat<4, 4, T, Q>::col_type const& v, mat<4, 4, T, Q> const& m);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<2, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<3, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<4, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<4, 4, T, Q> operator/(mat<4, 4, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<4, 4, T, Q> operator/(T scalar, mat<4, 4, T, Q> const& m);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr typename mat<4, 4, T, Q>::col_type operator/(mat<4, 4, T, Q> const& m, typename mat<4, 4, T, Q>::row_type const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr typename mat<4, 4, T, Q>::row_type operator/(typename mat<4, 4, T, Q>::col_type const& v, mat<4, 4, T, Q> const& m);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<4, 4, T, Q> operator/(mat<4, 4, T, Q> const& m1,	mat<4, 4, T, Q> const& m2);

	

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr bool operator==(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr bool operator!=(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2);
}


#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x4.inl"


namespace glm
{
	















#line 22 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x4.inl"

	template<typename T, qualifier Q>
	template<qualifier P>
	inline constexpr mat<4, 4, T, Q>::mat(mat<4, 4, T, P> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}
#line 29 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x4.inl"
	{





#line 36 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x4.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 4, T, Q>::mat(T s)

			: value{col_type(s, 0, 0, 0), col_type(0, s, 0, 0), col_type(0, 0, s, 0), col_type(0, 0, 0, s)}
#line 43 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x4.inl"
	{





#line 50 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x4.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 4, T, Q>::mat
	(
		T const& x0, T const& y0, T const& z0, T const& w0,
		T const& x1, T const& y1, T const& z1, T const& w1,
		T const& x2, T const& y2, T const& z2, T const& w2,
		T const& x3, T const& y3, T const& z3, T const& w3
	)

			: value{
				col_type(x0, y0, z0, w0),
				col_type(x1, y1, z1, w1),
				col_type(x2, y2, z2, w2),
				col_type(x3, y3, z3, w3)}
#line 67 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x4.inl"
	{





#line 74 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x4.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 4, T, Q>::mat(col_type const& v0, col_type const& v1, col_type const& v2, col_type const& v3)

			: value{col_type(v0), col_type(v1), col_type(v2), col_type(v3)}
#line 81 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x4.inl"
	{





#line 88 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x4.inl"
	}

	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	inline constexpr mat<4, 4, T, Q>::mat(mat<4, 4, U, P> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}
#line 96 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x4.inl"
	{





#line 103 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x4.inl"
	}

	

	template<typename T, qualifier Q>
	template<
		typename X1, typename Y1, typename Z1, typename W1,
		typename X2, typename Y2, typename Z2, typename W2,
		typename X3, typename Y3, typename Z3, typename W3,
		typename X4, typename Y4, typename Z4, typename W4>
	inline constexpr mat<4, 4, T, Q>::mat
	(
		X1 const& x1, Y1 const& y1, Z1 const& z1, W1 const& w1,
		X2 const& x2, Y2 const& y2, Z2 const& z2, W2 const& w2,
		X3 const& x3, Y3 const& y3, Z3 const& z3, W3 const& w3,
		X4 const& x4, Y4 const& y4, Z4 const& z4, W4 const& w4
	)

			: value{col_type(x1, y1, z1, w1), col_type(x2, y2, z2, w2), col_type(x3, y3, z3, w3), col_type(x4, y4, z4, w4)}
#line 123 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x4.inl"
	{
		static_assert(std::numeric_limits<X1>::is_iec559 || std::numeric_limits<X1>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 1st parameter type invalid.") ;
		static_assert(std::numeric_limits<Y1>::is_iec559 || std::numeric_limits<Y1>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 2nd parameter type invalid.") ;
		static_assert(std::numeric_limits<Z1>::is_iec559 || std::numeric_limits<Z1>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 3rd parameter type invalid.") ;
		static_assert(std::numeric_limits<W1>::is_iec559 || std::numeric_limits<W1>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 4th parameter type invalid.") ;

		static_assert(std::numeric_limits<X2>::is_iec559 || std::numeric_limits<X2>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 5th parameter type invalid.") ;
		static_assert(std::numeric_limits<Y2>::is_iec559 || std::numeric_limits<Y2>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 6th parameter type invalid.") ;
		static_assert(std::numeric_limits<Z2>::is_iec559 || std::numeric_limits<Z2>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 7th parameter type invalid.") ;
		static_assert(std::numeric_limits<W2>::is_iec559 || std::numeric_limits<W2>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 8th parameter type invalid.") ;

		static_assert(std::numeric_limits<X3>::is_iec559 || std::numeric_limits<X3>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 9th parameter type invalid.") ;
		static_assert(std::numeric_limits<Y3>::is_iec559 || std::numeric_limits<Y3>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 10th parameter type invalid.") ;
		static_assert(std::numeric_limits<Z3>::is_iec559 || std::numeric_limits<Z3>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 11th parameter type invalid.") ;
		static_assert(std::numeric_limits<W3>::is_iec559 || std::numeric_limits<W3>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 12th parameter type invalid.") ;

		static_assert(std::numeric_limits<X4>::is_iec559 || std::numeric_limits<X4>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 13th parameter type invalid.") ;
		static_assert(std::numeric_limits<Y4>::is_iec559 || std::numeric_limits<Y4>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 14th parameter type invalid.") ;
		static_assert(std::numeric_limits<Z4>::is_iec559 || std::numeric_limits<Z4>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 15th parameter type invalid.") ;
		static_assert(std::numeric_limits<W4>::is_iec559 || std::numeric_limits<W4>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 16th parameter type invalid.") ;






#line 150 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x4.inl"
	}

	template<typename T, qualifier Q>
	template<typename V1, typename V2, typename V3, typename V4>
	inline constexpr mat<4, 4, T, Q>::mat(vec<4, V1, Q> const& v1, vec<4, V2, Q> const& v2, vec<4, V3, Q> const& v3, vec<4, V4, Q> const& v4)

			: value{col_type(v1), col_type(v2), col_type(v3), col_type(v4)}
#line 158 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x4.inl"
	{
		static_assert(std::numeric_limits<V1>::is_iec559 || std::numeric_limits<V1>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 1st parameter type invalid.") ;
		static_assert(std::numeric_limits<V2>::is_iec559 || std::numeric_limits<V2>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 2nd parameter type invalid.") ;
		static_assert(std::numeric_limits<V3>::is_iec559 || std::numeric_limits<V3>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 3rd parameter type invalid.") ;
		static_assert(std::numeric_limits<V4>::is_iec559 || std::numeric_limits<V4>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 4th parameter type invalid.") ;






#line 170 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x4.inl"
	}

	

	template<typename T, qualifier Q>
	inline constexpr mat<4, 4, T, Q>::mat(mat<2, 2, T, Q> const& m)

			: value{col_type(m[0], 0, 0), col_type(m[1], 0, 0), col_type(0, 0, 1, 0), col_type(0, 0, 0, 1)}
#line 179 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x4.inl"
	{





#line 186 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x4.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 4, T, Q>::mat(mat<3, 3, T, Q> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 0), col_type(0, 0, 0, 1)}
#line 193 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x4.inl"
	{





#line 200 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x4.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 4, T, Q>::mat(mat<2, 3, T, Q> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0), col_type(0, 0, 1, 0), col_type(0, 0, 0, 1)}
#line 207 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x4.inl"
	{





#line 214 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x4.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 4, T, Q>::mat(mat<3, 2, T, Q> const& m)

			: value{col_type(m[0], 0, 0), col_type(m[1], 0, 0), col_type(m[2], 1, 0), col_type(0, 0, 0, 1)}
#line 221 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x4.inl"
	{





#line 228 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x4.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 4, T, Q>::mat(mat<2, 4, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(0, 0, 1, 0), col_type(0, 0, 0, 1)}
#line 235 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x4.inl"
	{





#line 242 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x4.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 4, T, Q>::mat(mat<4, 2, T, Q> const& m)

			: value{col_type(m[0], 0, 0), col_type(m[1], 0, 0), col_type(0, 0, 1, 0), col_type(0, 0, 0, 1)}
#line 249 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x4.inl"
	{





#line 256 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x4.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 4, T, Q>::mat(mat<3, 4, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(0, 0, 0, 1)}
#line 263 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x4.inl"
	{





#line 270 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x4.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 4, T, Q>::mat(mat<4, 3, T, Q> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 0), col_type(m[3], 1)}
#line 277 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x4.inl"
	{





#line 284 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x4.inl"
	}

	

	template<typename T, qualifier Q>
	inline constexpr typename mat<4, 4, T, Q>::col_type & mat<4, 4, T, Q>::operator[](typename mat<4, 4, T, Q>::length_type i) noexcept
	{
		((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x4.inl", (unsigned)(291)), 0) )) ;
		return this->value[i];
	}

	template<typename T, qualifier Q>
	inline constexpr typename mat<4, 4, T, Q>::col_type const& mat<4, 4, T, Q>::operator[](typename mat<4, 4, T, Q>::length_type i) const noexcept
	{
		((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x4.inl", (unsigned)(298)), 0) )) ;
		return this->value[i];
	}

	

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<4, 4, T, Q>& mat<4, 4, T, Q>::operator=(mat<4, 4, U, Q> const& m)
	{
		
		
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		this->value[3] = m[3];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<4, 4, T, Q>& mat<4, 4, T, Q>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		this->value[3] += s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<4, 4, T, Q>& mat<4, 4, T, Q>::operator+=(mat<4, 4, U, Q> const& m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		this->value[3] += m[3];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		this->value[3] -= s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator-=(mat<4, 4, U, Q> const& m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		this->value[3] -= m[3];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		this->value[3] *= s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator*=(mat<4, 4, U, Q> const& m)
	{
		return (*this = *this * m);
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		this->value[3] /= s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator/=(mat<4, 4, U, Q> const& m)
	{
		return *this *= inverse(m);
	}

	

	template<typename T, qualifier Q>
	inline constexpr mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator++()
	{
		++this->value[0];
		++this->value[1];
		++this->value[2];
		++this->value[3];
		return *this;
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator--()
	{
		--this->value[0];
		--this->value[1];
		--this->value[2];
		--this->value[3];
		return *this;
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 4, T, Q> mat<4, 4, T, Q>::operator++(int)
	{
		mat<4, 4, T, Q> Result(*this);
		++*this;
		return Result;
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 4, T, Q> mat<4, 4, T, Q>::operator--(int)
	{
		mat<4, 4, T, Q> Result(*this);
		--*this;
		return Result;
	}

	

	template<typename T, qualifier Q>
	inline constexpr mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m)
	{
		return m;
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m)
	{
		return mat<4, 4, T, Q>(
			-m[0],
			-m[1],
			-m[2],
			-m[3]);
	}

	

	template<typename T, qualifier Q>
	inline constexpr mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m, T scalar)
	{
		return mat<4, 4, T, Q>(
			m[0] + scalar,
			m[1] + scalar,
			m[2] + scalar,
			m[3] + scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 4, T, Q> operator+(T scalar, mat<4, 4, T, Q> const& m)
	{
		return mat<4, 4, T, Q>(
			m[0] + scalar,
			m[1] + scalar,
			m[2] + scalar,
			m[3] + scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
	{
		return mat<4, 4, T, Q>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2],
			m1[3] + m2[3]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m, T scalar)
	{
		return mat<4, 4, T, Q>(
			m[0] - scalar,
			m[1] - scalar,
			m[2] - scalar,
			m[3] - scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 4, T, Q> operator-(T scalar, mat<4, 4, T, Q> const& m)
	{
		return mat<4, 4, T, Q>(
			scalar - m[0],
			scalar - m[1],
			scalar - m[2],
			scalar - m[3]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
	{
		return mat<4, 4, T, Q>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2],
			m1[3] - m2[3]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 4, T, Q> operator*(mat<4, 4, T, Q> const& m, T scalar)
	{
		return mat<4, 4, T, Q>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar,
			m[3] * scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 4, T, Q> operator*(T scalar, mat<4, 4, T, Q> const& m)
	{
		return mat<4, 4, T, Q>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar,
			m[3] * scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr typename mat<4, 4, T, Q>::col_type operator*
	(
		mat<4, 4, T, Q> const& m,
		typename mat<4, 4, T, Q>::row_type const& v
	)
	{



















		typename mat<4, 4, T, Q>::col_type const Mov0(v[0]);
		typename mat<4, 4, T, Q>::col_type const Mov1(v[1]);
		typename mat<4, 4, T, Q>::col_type const Mul0 = m[0] * Mov0;
		typename mat<4, 4, T, Q>::col_type const Mul1 = m[1] * Mov1;
		typename mat<4, 4, T, Q>::col_type const Add0 = Mul0 + Mul1;
		typename mat<4, 4, T, Q>::col_type const Mov2(v[2]);
		typename mat<4, 4, T, Q>::col_type const Mov3(v[3]);
		typename mat<4, 4, T, Q>::col_type const Mul2 = m[2] * Mov2;
		typename mat<4, 4, T, Q>::col_type const Mul3 = m[3] * Mov3;
		typename mat<4, 4, T, Q>::col_type const Add1 = Mul2 + Mul3;
		typename mat<4, 4, T, Q>::col_type const Add2 = Add0 + Add1;
		return Add2;








	}

	template<typename T, qualifier Q>
	inline constexpr typename mat<4, 4, T, Q>::row_type operator*
	(
		typename mat<4, 4, T, Q>::col_type const& v,
		mat<4, 4, T, Q> const& m
	)
	{
		return typename mat<4, 4, T, Q>::row_type(
			m[0][0] * v[0] + m[0][1] * v[1] + m[0][2] * v[2] + m[0][3] * v[3],
			m[1][0] * v[0] + m[1][1] * v[1] + m[1][2] * v[2] + m[1][3] * v[3],
			m[2][0] * v[0] + m[2][1] * v[1] + m[2][2] * v[2] + m[2][3] * v[3],
			m[3][0] * v[0] + m[3][1] * v[1] + m[3][2] * v[2] + m[3][3] * v[3]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
	{
		return mat<2, 4, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2] + m1[3][3] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2] + m1[3][3] * m2[1][3]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
	{
		return mat<3, 4, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2] + m1[3][3] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2] + m1[3][3] * m2[1][3],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2] + m1[3][2] * m2[2][3],
			m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1] + m1[2][3] * m2[2][2] + m1[3][3] * m2[2][3]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
	{
		typename mat<4, 4, T, Q>::col_type const SrcA0 = m1[0];
		typename mat<4, 4, T, Q>::col_type const SrcA1 = m1[1];
		typename mat<4, 4, T, Q>::col_type const SrcA2 = m1[2];
		typename mat<4, 4, T, Q>::col_type const SrcA3 = m1[3];

		typename mat<4, 4, T, Q>::col_type const SrcB0 = m2[0];
		typename mat<4, 4, T, Q>::col_type const SrcB1 = m2[1];
		typename mat<4, 4, T, Q>::col_type const SrcB2 = m2[2];
		typename mat<4, 4, T, Q>::col_type const SrcB3 = m2[3];

		mat<4, 4, T, Q> Result;
		Result[0] = SrcA0 * SrcB0[0] + SrcA1 * SrcB0[1] + SrcA2 * SrcB0[2] + SrcA3 * SrcB0[3];
		Result[1] = SrcA0 * SrcB1[0] + SrcA1 * SrcB1[1] + SrcA2 * SrcB1[2] + SrcA3 * SrcB1[3];
		Result[2] = SrcA0 * SrcB2[0] + SrcA1 * SrcB2[1] + SrcA2 * SrcB2[2] + SrcA3 * SrcB2[3];
		Result[3] = SrcA0 * SrcB3[0] + SrcA1 * SrcB3[1] + SrcA2 * SrcB3[2] + SrcA3 * SrcB3[3];
		return Result;
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 4, T, Q> operator/(mat<4, 4, T, Q> const& m, T scalar)
	{
		return mat<4, 4, T, Q>(
			m[0] / scalar,
			m[1] / scalar,
			m[2] / scalar,
			m[3] / scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 4, T, Q> operator/(T scalar,	mat<4, 4, T, Q> const& m)
	{
		return mat<4, 4, T, Q>(
			scalar / m[0],
			scalar / m[1],
			scalar / m[2],
			scalar / m[3]);
	}

	template<typename T, qualifier Q>
	inline constexpr typename mat<4, 4, T, Q>::col_type operator/(mat<4, 4, T, Q> const& m, typename mat<4, 4, T, Q>::row_type const& v)
	{
		return inverse(m) * v;
	}

	template<typename T, qualifier Q>
	inline constexpr typename mat<4, 4, T, Q>::row_type operator/(typename mat<4, 4, T, Q>::col_type const& v, mat<4, 4, T, Q> const& m)
	{
		return v * inverse(m);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 4, T, Q> operator/(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
	{
		mat<4, 4, T, Q> m1_copy(m1);
		return m1_copy /= m2;
	}

	

	template<typename T, qualifier Q>
	inline constexpr bool operator==(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
	}

	template<typename T, qualifier Q>
	inline constexpr bool operator!=(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
	}
}



#line 707 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x4.inl"
#line 189 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x4.hpp"
#line 190 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat4x4.hpp"
#line 6 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_double4x4.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<4, 4, double, defaultp>		dmat4x4;

	
	
	
	typedef mat<4, 4, double, defaultp>		dmat4;

	
}
#line 6 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\mat4x4.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_double4x4_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef mat<4, 4, double, lowp>		lowp_dmat4;

	
	
	
	
	typedef mat<4, 4, double, mediump>	mediump_dmat4;

	
	
	
	
	typedef mat<4, 4, double, highp>	highp_dmat4;

	
	
	
	
	typedef mat<4, 4, double, lowp>		lowp_dmat4x4;

	
	
	
	
	typedef mat<4, 4, double, mediump>	mediump_dmat4x4;

	
	
	
	
	typedef mat<4, 4, double, highp>	highp_dmat4x4;

	
}
#line 7 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\mat4x4.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_float4x4.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef mat<4, 4, float, defaultp>			mat4x4;

	
	
	
	typedef mat<4, 4, float, defaultp>			mat4;

	
}
#line 8 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\mat4x4.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_float4x4_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef mat<4, 4, float, lowp>		lowp_mat4;

	
	
	
	
	typedef mat<4, 4, float, mediump>	mediump_mat4;

	
	
	
	
	typedef mat<4, 4, float, highp>		highp_mat4;

	
	
	
	
	typedef mat<4, 4, float, lowp>		lowp_mat4x4;

	
	
	
	
	typedef mat<4, 4, float, mediump>	mediump_mat4x4;

	
	
	
	
	typedef mat<4, 4, float, highp>		highp_mat4x4;

	
}
#line 9 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\mat4x4.hpp"

#line 30 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\matrix.hpp"

namespace glm {
namespace detail
{
	template<length_t C, length_t R, typename T, qualifier Q>
	struct outerProduct_trait{};

	template<typename T, qualifier Q>
	struct outerProduct_trait<2, 2, T, Q>
	{
		typedef mat<2, 2, T, Q> type;
	};

	template<typename T, qualifier Q>
	struct outerProduct_trait<2, 3, T, Q>
	{
		typedef mat<3, 2, T, Q> type;
	};

	template<typename T, qualifier Q>
	struct outerProduct_trait<2, 4, T, Q>
	{
		typedef mat<4, 2, T, Q> type;
	};

	template<typename T, qualifier Q>
	struct outerProduct_trait<3, 2, T, Q>
	{
		typedef mat<2, 3, T, Q> type;
	};

	template<typename T, qualifier Q>
	struct outerProduct_trait<3, 3, T, Q>
	{
		typedef mat<3, 3, T, Q> type;
	};

	template<typename T, qualifier Q>
	struct outerProduct_trait<3, 4, T, Q>
	{
		typedef mat<4, 3, T, Q> type;
	};

	template<typename T, qualifier Q>
	struct outerProduct_trait<4, 2, T, Q>
	{
		typedef mat<2, 4, T, Q> type;
	};

	template<typename T, qualifier Q>
	struct outerProduct_trait<4, 3, T, Q>
	{
		typedef mat<3, 4, T, Q> type;
	};

	template<typename T, qualifier Q>
	struct outerProduct_trait<4, 4, T, Q>
	{
		typedef mat<4, 4, T, Q> type;
	};
}

	 
	 

	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	template<length_t C, length_t R, typename T, qualifier Q>
	[[nodiscard]] mat<C, R, T, Q> matrixCompMult(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y);

	
	
	
	
	
	
	
	
	
	
	
	template<length_t C, length_t R, typename T, qualifier Q>
	[[nodiscard]] typename detail::outerProduct_trait<C, R, T, Q>::type outerProduct(vec<C, T, Q> const& c, vec<R, T, Q> const& r);

	
	
	
	
	
	
	
	
	
	template<length_t C, length_t R, typename T, qualifier Q>
	[[nodiscard]] typename mat<C, R, T, Q>::transpose_type transpose(mat<C, R, T, Q> const& x);

	
	
	
	
	
	
	
	
	
	template<length_t C, length_t R, typename T, qualifier Q>
	[[nodiscard]] T determinant(mat<C, R, T, Q> const& m);

	
	
	
	
	
	
	
	
	
	template<length_t C, length_t R, typename T, qualifier Q>
	[[nodiscard]] mat<C, R, T, Q> inverse(mat<C, R, T, Q> const& m);

	
}

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\func_matrix.inl"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\geometric.hpp"












#pragma once



namespace glm
{
	
	

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] T length(vec<L, T, Q> const& x);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] T distance(vec<L, T, Q> const& p0, vec<L, T, Q> const& p1);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] constexpr T dot(vec<L, T, Q> const& x, vec<L, T, Q> const& y);

	
	
	
	
	
	
	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> cross(vec<3, T, Q> const& x, vec<3, T, Q> const& y);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> normalize(vec<L, T, Q> const& x);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> faceforward(
		vec<L, T, Q> const& N,
		vec<L, T, Q> const& I,
		vec<L, T, Q> const& Nref);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> reflect(
		vec<L, T, Q> const& I,
		vec<L, T, Q> const& N);

	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> refract(
		vec<L, T, Q> const& I,
		vec<L, T, Q> const& N,
		T eta);

	
}

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\func_geometric.inl"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\exponential.hpp"














#pragma once

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec1.hpp"



#pragma once




#line 10 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec1.hpp"

#line 12 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec1.hpp"


namespace glm
{
	template<typename T, qualifier Q>
	struct vec<1, T, Q>
	{
		

		typedef T value_type;
		typedef vec<1, T, Q> type;
		typedef vec<1, bool, Q> bool_type;

		





#line 32 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec1.hpp"



#line 36 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec1.hpp"
#pragma warning(push)
#pragma warning(disable: 4201)  
#line 39 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec1.hpp"
#line 40 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec1.hpp"



#line 44 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec1.hpp"





















#line 66 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec1.hpp"
			union {T x, r, s;};





#line 73 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec1.hpp"




#line 78 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec1.hpp"

#line 80 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec1.hpp"
#pragma warning(pop)
#line 82 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec1.hpp"
#line 83 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec1.hpp"

		

		
		typedef length_t length_type;
		[[nodiscard]] static constexpr length_type length(){return 1;}

		[[nodiscard]] constexpr T & operator[](length_type i);
		[[nodiscard]] constexpr T const& operator[](length_type i) const;

		

		 constexpr vec() = default ;
		 constexpr vec(vec const& v) = default ;
		template<qualifier P>
		constexpr vec(vec<1, T, P> const& v);

		

		constexpr explicit vec(T scalar);

		

		
		template<typename U, qualifier P>
		constexpr  vec(vec<2, U, P> const& v);
		
		template<typename U, qualifier P>
		constexpr  vec(vec<3, U, P> const& v);
		
		template<typename U, qualifier P>
		constexpr  vec(vec<4, U, P> const& v);

		
		template<typename U, qualifier P>
		constexpr  vec(vec<1, U, P> const& v);

		









		

		 constexpr vec<1, T, Q> & operator=(vec const& v) = default ;

		template<typename U>
		 constexpr vec<1, T, Q> & operator=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<1, T, Q> & operator+=(U scalar);
		template<typename U>
		 constexpr vec<1, T, Q> & operator+=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<1, T, Q> & operator-=(U scalar);
		template<typename U>
		 constexpr vec<1, T, Q> & operator-=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<1, T, Q> & operator*=(U scalar);
		template<typename U>
		 constexpr vec<1, T, Q> & operator*=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<1, T, Q> & operator/=(U scalar);
		template<typename U>
		 constexpr vec<1, T, Q> & operator/=(vec<1, U, Q> const& v);

		

		 constexpr vec<1, T, Q> & operator++();
		 constexpr vec<1, T, Q> & operator--();
		[[nodiscard]] constexpr vec<1, T, Q> operator++(int);
		[[nodiscard]] constexpr vec<1, T, Q> operator--(int);

		

		template<typename U>
		 constexpr vec<1, T, Q> & operator%=(U scalar);
		template<typename U>
		 constexpr vec<1, T, Q> & operator%=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<1, T, Q> & operator&=(U scalar);
		template<typename U>
		 constexpr vec<1, T, Q> & operator&=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<1, T, Q> & operator|=(U scalar);
		template<typename U>
		 constexpr vec<1, T, Q> & operator|=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<1, T, Q> & operator^=(U scalar);
		template<typename U>
		 constexpr vec<1, T, Q> & operator^=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<1, T, Q> & operator<<=(U scalar);
		template<typename U>
		 constexpr vec<1, T, Q> & operator<<=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<1, T, Q> & operator>>=(U scalar);
		template<typename U>
		 constexpr vec<1, T, Q> & operator>>=(vec<1, U, Q> const& v);
	};

	

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<1, T, Q> operator+(vec<1, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<1, T, Q> operator-(vec<1, T, Q> const& v);

	

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<1, T, Q> operator+(vec<1, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<1, T, Q> operator+(T scalar, vec<1, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<1, T, Q> operator+(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<1, T, Q> operator-(vec<1, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<1, T, Q> operator-(T scalar, vec<1, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<1, T, Q> operator-(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<1, T, Q> operator*(vec<1, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<1, T, Q> operator*(T scalar, vec<1, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<1, T, Q> operator*(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<1, T, Q> operator/(vec<1, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<1, T, Q> operator/(T scalar, vec<1, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<1, T, Q> operator/(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<1, T, Q> operator%(vec<1, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<1, T, Q> operator%(T scalar, vec<1, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<1, T, Q> operator%(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<1, T, Q> operator&(vec<1, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<1, T, Q> operator&(T scalar, vec<1, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<1, T, Q> operator&(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<1, T, Q> operator|(vec<1, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<1, T, Q> operator|(T scalar, vec<1, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<1, T, Q> operator|(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<1, T, Q> operator^(vec<1, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<1, T, Q> operator^(T scalar, vec<1, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<1, T, Q> operator^(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<1, T, Q> operator<<(vec<1, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<1, T, Q> operator<<(T scalar, vec<1, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<1, T, Q> operator<<(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<1, T, Q> operator>>(vec<1, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<1, T, Q> operator>>(T scalar, vec<1, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<1, T, Q> operator>>(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<1, T, Q> operator~(vec<1, T, Q> const& v);

	

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr bool operator==(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr bool operator!=(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<qualifier Q>
	[[nodiscard]] constexpr vec<1, bool, Q> operator&&(vec<1, bool, Q> const& v1, vec<1, bool, Q> const& v2);

	template<qualifier Q>
	[[nodiscard]] constexpr vec<1, bool, Q> operator||(vec<1, bool, Q> const& v1, vec<1, bool, Q> const& v2);
}


#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec1.inl"




namespace glm
{
	








#line 17 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec1.inl"






#line 24 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec1.inl"

	template<typename T, qualifier Q>
	template<qualifier P>
	inline constexpr vec<1, T, Q>::vec(vec<1, T, P> const& v)
		: x(v.x)
	{}

	

	template<typename T, qualifier Q>
	inline constexpr vec<1, T, Q>::vec(T scalar)
		: x(scalar)
	{}

	

	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	inline constexpr vec<1, T, Q>::vec(vec<1, U, P> const& v)
		: x(static_cast<T>(v.x))
	{}

	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	inline constexpr vec<1, T, Q>::vec(vec<2, U, P> const& v)
		: x(static_cast<T>(v.x))
	{}

	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	inline constexpr vec<1, T, Q>::vec(vec<3, U, P> const& v)
		: x(static_cast<T>(v.x))
	{}

	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	inline constexpr vec<1, T, Q>::vec(vec<4, U, P> const& v)
		: x(static_cast<T>(v.x))
	{}

	

	template<typename T, qualifier Q>
	inline constexpr T & vec<1, T, Q>::operator[](typename vec<1, T, Q>::length_type)
	{
		return x;
	}

	template<typename T, qualifier Q>
	inline constexpr T const& vec<1, T, Q>::operator[](typename vec<1, T, Q>::length_type) const
	{
		return x;
	}

	








#line 88 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec1.inl"

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator=(vec<1, U, Q> const& v)
	{
		this->x = static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator+=(U scalar)
	{
		this->x += static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator+=(vec<1, U, Q> const& v)
	{
		this->x += static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator-=(U scalar)
	{
		this->x -= static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator-=(vec<1, U, Q> const& v)
	{
		this->x -= static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator*=(U scalar)
	{
		this->x *= static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator*=(vec<1, U, Q> const& v)
	{
		this->x *= static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator/=(U scalar)
	{
		this->x /= static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator/=(vec<1, U, Q> const& v)
	{
		this->x /= static_cast<T>(v.x);
		return *this;
	}

	

	template<typename T, qualifier Q>
	inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator++()
	{
		++this->x;
		return *this;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator--()
	{
		--this->x;
		return *this;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<1, T, Q> vec<1, T, Q>::operator++(int)
	{
		vec<1, T, Q> Result(*this);
		++*this;
		return Result;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<1, T, Q> vec<1, T, Q>::operator--(int)
	{
		vec<1, T, Q> Result(*this);
		--*this;
		return Result;
	}

	

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator%=(U scalar)
	{
		this->x %= static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator%=(vec<1, U, Q> const& v)
	{
		this->x %= static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator&=(U scalar)
	{
		this->x &= static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator&=(vec<1, U, Q> const& v)
	{
		this->x &= static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator|=(U scalar)
	{
		this->x |= static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator|=(vec<1, U, Q> const& v)
	{
		this->x |= static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator^=(U scalar)
	{
		this->x ^= static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator^=(vec<1, U, Q> const& v)
	{
		this->x ^= static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator<<=(U scalar)
	{
		this->x <<= static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator<<=(vec<1, U, Q> const& v)
	{
		this->x <<= static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator>>=(U scalar)
	{
		this->x >>= static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator>>=(vec<1, U, Q> const& v)
	{
		this->x >>= static_cast<T>(v.x);
		return *this;
	}

	

	template<typename T, qualifier Q>
	inline constexpr vec<1, T, Q> operator+(vec<1, T, Q> const& v)
	{
		return v;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<1, T, Q> operator-(vec<1, T, Q> const& v)
	{
		return vec<1, T, Q>(
			-v.x);
	}

	

	template<typename T, qualifier Q>
	inline constexpr vec<1, T, Q> operator+(vec<1, T, Q> const& v, T scalar)
	{
		return vec<1, T, Q>(
			v.x + scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<1, T, Q> operator+(T scalar, vec<1, T, Q> const& v)
	{
		return vec<1, T, Q>(
			scalar + v.x);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<1, T, Q> operator+(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<1, T, Q>(
			v1.x + v2.x);
	}

	
	template<typename T, qualifier Q>
	inline constexpr vec<1, T, Q> operator-(vec<1, T, Q> const& v, T scalar)
	{
		return vec<1, T, Q>(
			v.x - scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<1, T, Q> operator-(T scalar, vec<1, T, Q> const& v)
	{
		return vec<1, T, Q>(
			scalar - v.x);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<1, T, Q> operator-(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<1, T, Q>(
			v1.x - v2.x);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<1, T, Q> operator*(vec<1, T, Q> const& v, T scalar)
	{
		return vec<1, T, Q>(
			v.x * scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<1, T, Q> operator*(T scalar, vec<1, T, Q> const& v)
	{
		return vec<1, T, Q>(
			scalar * v.x);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<1, T, Q> operator*(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<1, T, Q>(
			v1.x * v2.x);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<1, T, Q> operator/(vec<1, T, Q> const& v, T scalar)
	{
		return vec<1, T, Q>(
			v.x / scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<1, T, Q> operator/(T scalar, vec<1, T, Q> const& v)
	{
		return vec<1, T, Q>(
			scalar / v.x);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<1, T, Q> operator/(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<1, T, Q>(
			v1.x / v2.x);
	}

	

	template<typename T, qualifier Q>
	inline constexpr vec<1, T, Q> operator%(vec<1, T, Q> const& v, T scalar)
	{
		return vec<1, T, Q>(
			v.x % scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<1, T, Q> operator%(T scalar, vec<1, T, Q> const& v)
	{
		return vec<1, T, Q>(
			scalar % v.x);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<1, T, Q> operator%(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<1, T, Q>(
			v1.x % v2.x);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<1, T, Q> operator&(vec<1, T, Q> const& v, T scalar)
	{
		return vec<1, T, Q>(
			v.x & scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<1, T, Q> operator&(T scalar, vec<1, T, Q> const& v)
	{
		return vec<1, T, Q>(
			scalar & v.x);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<1, T, Q> operator&(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<1, T, Q>(
			v1.x & v2.x);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<1, T, Q> operator|(vec<1, T, Q> const& v, T scalar)
	{
		return vec<1, T, Q>(
			v.x | scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<1, T, Q> operator|(T scalar, vec<1, T, Q> const& v)
	{
		return vec<1, T, Q>(
			scalar | v.x);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<1, T, Q> operator|(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<1, T, Q>(
			v1.x | v2.x);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<1, T, Q> operator^(vec<1, T, Q> const& v, T scalar)
	{
		return vec<1, T, Q>(
			v.x ^ scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<1, T, Q> operator^(T scalar, vec<1, T, Q> const& v)
	{
		return vec<1, T, Q>(
			scalar ^ v.x);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<1, T, Q> operator^(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<1, T, Q>(
			v1.x ^ v2.x);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<1, T, Q> operator<<(vec<1, T, Q> const& v, T scalar)
	{
		return vec<1, T, Q>(
			static_cast<T>(v.x << scalar));
	}

	template<typename T, qualifier Q>
	inline constexpr vec<1, T, Q> operator<<(T scalar, vec<1, T, Q> const& v)
	{
		return vec<1, T, Q>(
			static_cast<T>(scalar << v.x));
	}

	template<typename T, qualifier Q>
	inline constexpr vec<1, T, Q> operator<<(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<1, T, Q>(
			static_cast<T>(v1.x << v2.x));
	}

	template<typename T, qualifier Q>
	inline constexpr vec<1, T, Q> operator>>(vec<1, T, Q> const& v, T scalar)
	{
		return vec<1, T, Q>(
			static_cast<T>(v.x >> scalar));
	}

	template<typename T, qualifier Q>
	inline constexpr vec<1, T, Q> operator>>(T scalar, vec<1, T, Q> const& v)
	{
		return vec<1, T, Q>(
			static_cast<T>(scalar >> v.x));
	}

	template<typename T, qualifier Q>
	inline constexpr vec<1, T, Q> operator>>(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<1, T, Q>(
			static_cast<T>(v1.x >> v2.x));
	}

	template<typename T, qualifier Q>
	inline constexpr vec<1, T, Q> operator~(vec<1, T, Q> const& v)
	{
		return vec<1, T, Q>(
			~v.x);
	}

	

	template<typename T, qualifier Q>
	inline constexpr bool operator==(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.x, v2.x);
	}

	template<typename T, qualifier Q>
	inline constexpr bool operator!=(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return !(v1 == v2);
	}

	template<qualifier Q>
	inline constexpr vec<1, bool, Q> operator&&(vec<1, bool, Q> const& v1, vec<1, bool, Q> const& v2)
	{
		return vec<1, bool, Q>(v1.x && v2.x);
	}

	template<qualifier Q>
	inline constexpr vec<1, bool, Q> operator||(vec<1, bool, Q> const& v1, vec<1, bool, Q> const& v2)
	{
		return vec<1, bool, Q>(v1.x || v2.x);
	}
}
#line 308 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec1.hpp"
#line 309 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_vec1.hpp"
#line 18 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\exponential.hpp"





namespace glm
{
	
	

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> pow(vec<L, T, Q> const& base, vec<L, T, Q> const& exponent);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> exp(vec<L, T, Q> const& v);

	
	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> log(vec<L, T, Q> const& v);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> exp2(vec<L, T, Q> const& v);

	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> log2(vec<L, T, Q> const& v);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> sqrt(vec<L, T, Q> const& v);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> inversesqrt(vec<L, T, Q> const& v);

	
}

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\func_exponential.inl"



#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\vector_relational.hpp"



















#pragma once


#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 970 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
























































































































































































































#line 1187 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 1189 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
#line 24 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\vector_relational.hpp"

namespace glm
{
	
	

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] constexpr vec<L, bool, Q> lessThan(vec<L, T, Q> const& x, vec<L, T, Q> const& y);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] constexpr vec<L, bool, Q> lessThanEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] constexpr vec<L, bool, Q> greaterThan(vec<L, T, Q> const& x, vec<L, T, Q> const& y);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] constexpr vec<L, bool, Q> greaterThanEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y);

	
	
	
	
	
	
	template<length_t L, qualifier Q>
	[[nodiscard]] constexpr bool any(vec<L, bool, Q> const& v);

	
	
	
	
	
	
	template<length_t L, qualifier Q>
	[[nodiscard]] constexpr bool all(vec<L, bool, Q> const& v);

	
	
	
	
	
	
	
	template<length_t L, qualifier Q>
	[[nodiscard]] constexpr vec<L, bool, Q> not_(vec<L, bool, Q> const& v);

	
}

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\func_vector_relational.inl"
namespace glm
{
	template<length_t L, typename T, qualifier Q>
	inline constexpr vec<L, bool, Q> lessThan(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
	{
		vec<L, bool, Q> Result(true);
		for(length_t i = 0; i < L; ++i)
			Result[i] = x[i] < y[i];
		return Result;
	}

	template<length_t L, typename T, qualifier Q>
	inline constexpr vec<L, bool, Q> lessThanEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
	{
		vec<L, bool, Q> Result(true);
		for(length_t i = 0; i < L; ++i)
			Result[i] = x[i] <= y[i];
		return Result;
	}

	template<length_t L, typename T, qualifier Q>
	inline constexpr vec<L, bool, Q> greaterThan(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
	{
		vec<L, bool, Q> Result(true);
		for(length_t i = 0; i < L; ++i)
			Result[i] = x[i] > y[i];
		return Result;
	}

	template<length_t L, typename T, qualifier Q>
	inline constexpr vec<L, bool, Q> greaterThanEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
	{
		vec<L, bool, Q> Result(true);
		for(length_t i = 0; i < L; ++i)
			Result[i] = x[i] >= y[i];
		return Result;
	}

	template<length_t L, typename T, qualifier Q>
	inline constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
	{
		vec<L, bool, Q> Result(true);
		for(length_t i = 0; i < L; ++i)
			Result[i] = x[i] == y[i];
		return Result;
	}

	template<length_t L, typename T, qualifier Q>
	inline constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
	{
		vec<L, bool, Q> Result(true);
		for(length_t i = 0; i < L; ++i)
			Result[i] = x[i] != y[i];
		return Result;
	}

	template<length_t L, qualifier Q>
	inline constexpr bool any(vec<L, bool, Q> const& v)
	{
		bool Result = false;
		for(length_t i = 0; i < L; ++i)
			Result = Result || v[i];
		return Result;
	}

	template<length_t L, qualifier Q>
	inline constexpr bool all(vec<L, bool, Q> const& v)
	{
		bool Result = true;
		for(length_t i = 0; i < L; ++i)
			Result = Result && v[i];
		return Result;
	}

	template<length_t L, qualifier Q>
	inline constexpr vec<L, bool, Q> not_(vec<L, bool, Q> const& v)
	{
		vec<L, bool, Q> Result(true);
		for(length_t i = 0; i < L; ++i)
			Result[i] = !v[i];
		return Result;
	}
}



#line 88 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\func_vector_relational.inl"
#line 122 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\vector_relational.hpp"
#line 5 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\func_exponential.inl"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\_vectorize.hpp"
#pragma once

namespace glm{
namespace detail
{
	template<template<length_t L, typename T, qualifier Q> class vec, length_t L, typename R, typename T, qualifier Q>
	struct functor1{};

	template<template<length_t L, typename T, qualifier Q> class vec, typename R, typename T, qualifier Q>
	struct functor1<vec, 1, R, T, Q>
	{
		inline constexpr static vec<1, R, Q> call(R (*Func) (T x), vec<1, T, Q> const& v)
		{
			return vec<1, R, Q>(Func(v.x));
		}
	};

	template<template<length_t L, typename T, qualifier Q> class vec, typename R, typename T, qualifier Q>
	struct functor1<vec, 2, R, T, Q>
	{
		inline constexpr static vec<2, R, Q> call(R (*Func) (T x), vec<2, T, Q> const& v)
		{
			return vec<2, R, Q>(Func(v.x), Func(v.y));
		}
	};

	template<template<length_t L, typename T, qualifier Q> class vec, typename R, typename T, qualifier Q>
	struct functor1<vec, 3, R, T, Q>
	{
		inline constexpr static vec<3, R, Q> call(R (*Func) (T x), vec<3, T, Q> const& v)
		{
			return vec<3, R, Q>(Func(v.x), Func(v.y), Func(v.z));
		}
	};

	template<template<length_t L, typename T, qualifier Q> class vec, typename R, typename T, qualifier Q>
	struct functor1<vec, 4, R, T, Q>
	{
		inline constexpr static vec<4, R, Q> call(R (*Func) (T x), vec<4, T, Q> const& v)
		{
			return vec<4, R, Q>(Func(v.x), Func(v.y), Func(v.z), Func(v.w));
		}
	};

	template<template<length_t L, typename T, qualifier Q> class vec, length_t L, typename T, qualifier Q>
	struct functor2{};

	template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
	struct functor2<vec, 1, T, Q>
	{
		inline static vec<1, T, Q> call(T (*Func) (T x, T y), vec<1, T, Q> const& a, vec<1, T, Q> const& b)
		{
			return vec<1, T, Q>(Func(a.x, b.x));
		}
	};

	template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
	struct functor2<vec, 2, T, Q>
	{
		inline static vec<2, T, Q> call(T (*Func) (T x, T y), vec<2, T, Q> const& a, vec<2, T, Q> const& b)
		{
			return vec<2, T, Q>(Func(a.x, b.x), Func(a.y, b.y));
		}
	};

	template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
	struct functor2<vec, 3, T, Q>
	{
		inline static vec<3, T, Q> call(T (*Func) (T x, T y), vec<3, T, Q> const& a, vec<3, T, Q> const& b)
		{
			return vec<3, T, Q>(Func(a.x, b.x), Func(a.y, b.y), Func(a.z, b.z));
		}
	};

	template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
	struct functor2<vec, 4, T, Q>
	{
		inline static vec<4, T, Q> call(T (*Func) (T x, T y), vec<4, T, Q> const& a, vec<4, T, Q> const& b)
		{
			return vec<4, T, Q>(Func(a.x, b.x), Func(a.y, b.y), Func(a.z, b.z), Func(a.w, b.w));
		}
	};

	template<template<length_t L, typename T, qualifier Q> class vec, length_t L, typename T, qualifier Q>
	struct functor2_vec_sca{};

	template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
	struct functor2_vec_sca<vec, 1, T, Q>
	{
		inline static vec<1, T, Q> call(T (*Func) (T x, T y), vec<1, T, Q> const& a, T b)
		{
			return vec<1, T, Q>(Func(a.x, b));
		}
	};

	template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
	struct functor2_vec_sca<vec, 2, T, Q>
	{
		inline static vec<2, T, Q> call(T (*Func) (T x, T y), vec<2, T, Q> const& a, T b)
		{
			return vec<2, T, Q>(Func(a.x, b), Func(a.y, b));
		}
	};

	template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
	struct functor2_vec_sca<vec, 3, T, Q>
	{
		inline static vec<3, T, Q> call(T (*Func) (T x, T y), vec<3, T, Q> const& a, T b)
		{
			return vec<3, T, Q>(Func(a.x, b), Func(a.y, b), Func(a.z, b));
		}
	};

	template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
	struct functor2_vec_sca<vec, 4, T, Q>
	{
		inline static vec<4, T, Q> call(T (*Func) (T x, T y), vec<4, T, Q> const& a, T b)
		{
			return vec<4, T, Q>(Func(a.x, b), Func(a.y, b), Func(a.z, b), Func(a.w, b));
		}
	};

	template<length_t L, typename T, qualifier Q>
	struct functor2_vec_int {};

	template<typename T, qualifier Q>
	struct functor2_vec_int<1, T, Q>
	{
		inline static vec<1, int, Q> call(int (*Func) (T x, int y), vec<1, T, Q> const& a, vec<1, int, Q> const& b)
		{
			return vec<1, int, Q>(Func(a.x, b.x));
		}
	};

	template<typename T, qualifier Q>
	struct functor2_vec_int<2, T, Q>
	{
		inline static vec<2, int, Q> call(int (*Func) (T x, int y), vec<2, T, Q> const& a, vec<2, int, Q> const& b)
		{
			return vec<2, int, Q>(Func(a.x, b.x), Func(a.y, b.y));
		}
	};

	template<typename T, qualifier Q>
	struct functor2_vec_int<3, T, Q>
	{
		inline static vec<3, int, Q> call(int (*Func) (T x, int y), vec<3, T, Q> const& a, vec<3, int, Q> const& b)
		{
			return vec<3, int, Q>(Func(a.x, b.x), Func(a.y, b.y), Func(a.z, b.z));
		}
	};

	template<typename T, qualifier Q>
	struct functor2_vec_int<4, T, Q>
	{
		inline static vec<4, int, Q> call(int (*Func) (T x, int y), vec<4, T, Q> const& a, vec<4, int, Q> const& b)
		{
			return vec<4, int, Q>(Func(a.x, b.x), Func(a.y, b.y), Func(a.z, b.z), Func(a.w, b.w));
		}
	};
}
}
#line 6 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\func_exponential.inl"


#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cassert"








#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\assert.h"









#line 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\assert.h"



#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )

__pragma(pack(push, 8)) extern "C" {





#line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\assert.h"









    __declspec(dllimport) void __cdecl _wassert(
         wchar_t const* _Message,
         wchar_t const* _File,
           unsigned       _Line
        );

    




#line 45 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\assert.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 10 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cassert"
#pragma external_header(pop)
#line 9 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\func_exponential.inl"

namespace glm{
namespace detail
{

		using std::log2;






#line 22 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\func_exponential.inl"

	template<length_t L, typename T, qualifier Q, bool isFloat, bool Aligned>
	struct compute_log2
	{
		inline static vec<L, T, Q> call(vec<L, T, Q> const& v)
		{
			static_assert(std::numeric_limits<T>::is_iec559 || 0, "'log2' only accept floating-point inputs. Include <glm/gtc/integer.hpp> for integer inputs.") ;

			return detail::functor1<vec, L, T, T, Q>::call(log2, v);
		}
	};

	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_sqrt
	{
		inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
		{
			return detail::functor1<vec, L, T, T, Q>::call(std::sqrt, x);
		}
	};

	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_inversesqrt
	{
		inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
		{
			return static_cast<T>(1) / sqrt(x);
		}
	};

	template<length_t L, bool Aligned>
	struct compute_inversesqrt<L, float, lowp, Aligned>
	{
		inline static vec<L, float, lowp> call(vec<L, float, lowp> const& x)
		{
			vec<L, float, lowp> tmp(x);
			vec<L, float, lowp> xhalf(tmp * 0.5f);
			vec<L, uint, lowp>* p = reinterpret_cast<vec<L, uint, lowp>*>(const_cast<vec<L, float, lowp>*>(&x));
			vec<L, uint, lowp> i = vec<L, uint, lowp>(0x5f375a86) - (*p >> vec<L, uint, lowp>(1));
			vec<L, float, lowp>* ptmp = reinterpret_cast<vec<L, float, lowp>*>(&i);
			tmp = *ptmp;
			tmp = tmp * (1.5f - xhalf * tmp * tmp);
			return tmp;
		}
	};
}

	
	using std::pow;
	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> pow(vec<L, T, Q> const& base, vec<L, T, Q> const& exponent)
	{
		return detail::functor2<vec, L, T, Q>::call(pow, base, exponent);
	}

	
	using std::exp;
	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> exp(vec<L, T, Q> const& x)
	{
		return detail::functor1<vec, L, T, T, Q>::call(exp, x);
	}

	
	using std::log;
	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> log(vec<L, T, Q> const& x)
	{
		return detail::functor1<vec, L, T, T, Q>::call(log, x);
	}


    using std::exp2;









#line 105 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\func_exponential.inl"

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> exp2(vec<L, T, Q> const& x)
	{
		return detail::functor1<vec, L, T, T, Q>::call(exp2, x);
	}

	
	template<typename genType>
	inline genType log2(genType x)
	{
		return log2(vec<1, genType>(x)).x;
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> log2(vec<L, T, Q> const& x)
	{
		return detail::compute_log2<L, T, Q, std::numeric_limits<T>::is_iec559, detail::is_aligned<Q>::value>::call(x);
	}

	
	using std::sqrt;
	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> sqrt(vec<L, T, Q> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'sqrt' only accept floating-point inputs") ;
		return detail::compute_sqrt<L, T, Q, detail::is_aligned<Q>::value>::call(x);
	}

	
	template<typename genType>
	inline genType inversesqrt(genType x)
	{
		return static_cast<genType>(1) / sqrt(x);
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> inversesqrt(vec<L, T, Q> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'inversesqrt' only accept floating-point inputs") ;
		return detail::compute_inversesqrt<L, T, Q, detail::is_aligned<Q>::value>::call(x);
	}
}



#line 152 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\func_exponential.inl"

#line 111 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\exponential.hpp"
#line 2 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\func_geometric.inl"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\common.hpp"














#pragma once


#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\_fixes.hpp"



























#line 19 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\common.hpp"

namespace glm
{
	
	

	
	
	
	
	
	
	template<typename genType>
	[[nodiscard]] constexpr genType abs(genType x);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] constexpr vec<L, T, Q> abs(vec<L, T, Q> const& x);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] constexpr vec<L, T, Q> sign(vec<L, T, Q> const& x);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> floor(vec<L, T, Q> const& x);

	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> trunc(vec<L, T, Q> const& x);

	
	
	
	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> round(vec<L, T, Q> const& x);

	
	
	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> roundEven(vec<L, T, Q> const& x);

	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> ceil(vec<L, T, Q> const& x);

	
	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType fract(genType x);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> fract(vec<L, T, Q> const& x);

	template<typename genType>
	[[nodiscard]] genType mod(genType x, genType y);

	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> mod(vec<L, T, Q> const& x, T y);

	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> mod(vec<L, T, Q> const& x, vec<L, T, Q> const& y);

	
	
	
	
	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType modf(genType x, genType& i);

	
	
	
	
	
	
	template<typename genType>
	[[nodiscard]] constexpr genType min(genType x, genType y);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] constexpr vec<L, T, Q> min(vec<L, T, Q> const& x, T y);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] constexpr vec<L, T, Q> min(vec<L, T, Q> const& x, vec<L, T, Q> const& y);

	
	
	
	
	
	
	template<typename genType>
	[[nodiscard]] constexpr genType max(genType x, genType y);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] constexpr vec<L, T, Q> max(vec<L, T, Q> const& x, T y);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] constexpr vec<L, T, Q> max(vec<L, T, Q> const& x, vec<L, T, Q> const& y);

	
	
	
	
	
	
	
	template<typename genType>
	[[nodiscard]] constexpr genType clamp(genType x, genType minVal, genType maxVal);

	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] constexpr vec<L, T, Q> clamp(vec<L, T, Q> const& x, T minVal, T maxVal);

	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] constexpr vec<L, T, Q> clamp(vec<L, T, Q> const& x, vec<L, T, Q> const& minVal, vec<L, T, Q> const& maxVal);

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	template<typename genTypeT, typename genTypeU>
	[[nodiscard]] constexpr genTypeT mix(genTypeT x, genTypeT y, genTypeU a);

	template<length_t L, typename T, typename U, qualifier Q>
	[[nodiscard]] constexpr vec<L, T, Q> mix(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, U, Q> const& a);

	template<length_t L, typename T, typename U, qualifier Q>
	[[nodiscard]] constexpr vec<L, T, Q> mix(vec<L, T, Q> const& x, vec<L, T, Q> const& y, U a);

	
	
	
	
	template<typename genType>
	[[nodiscard]] genType step(genType edge, genType x);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> step(T edge, vec<L, T, Q> const& x);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> step(vec<L, T, Q> const& edge, vec<L, T, Q> const& x);

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType smoothstep(genType edge0, genType edge1, genType x);

	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> smoothstep(T edge0, T edge1, vec<L, T, Q> const& x);

	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> smoothstep(vec<L, T, Q> const& edge0, vec<L, T, Q> const& edge1, vec<L, T, Q> const& x);

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, bool, Q> isnan(vec<L, T, Q> const& x);

	
	
	
	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, bool, Q> isinf(vec<L, T, Q> const& x);

	
	
	
	
	
	
	[[nodiscard]] int floatBitsToInt(float v);

	
	
	
	
	
	
	
	
	
	template<length_t L, qualifier Q>
	[[nodiscard]] vec<L, int, Q> floatBitsToInt(vec<L, float, Q> const& v);

	
	
	
	
	
	
	[[nodiscard]] uint floatBitsToUint(float v);

	
	
	
	
	
	
	
	
	
	template<length_t L, qualifier Q>
	[[nodiscard]] vec<L, uint, Q> floatBitsToUint(vec<L, float, Q> const& v);

	
	
	
	
	
	
	
	
	[[nodiscard]] float intBitsToFloat(int v);

	
	
	
	
	
	
	
	
	
	
	
	template<length_t L, qualifier Q>
	[[nodiscard]] vec<L, float, Q> intBitsToFloat(vec<L, int, Q> const& v);

	
	
	
	
	
	
	
	
	[[nodiscard]] float uintBitsToFloat(uint v);

	
	
	
	
	
	
	
	
	
	
	
	template<length_t L, qualifier Q>
	[[nodiscard]] vec<L, float, Q> uintBitsToFloat(vec<L, uint, Q> const& v);

	
	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType fma(genType const& a, genType const& b, genType const& c);

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType frexp(genType x, int& exp);
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> frexp(vec<L, T, Q> const& v, vec<L, int, Q>& exp);

	
	
	
	
	
	
	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType ldexp(genType const& x, int const& exp);
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> ldexp(vec<L, T, Q> const& v, vec<L, int, Q> const& exp);

	
}

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\func_common.inl"




#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\compute_common.hpp"
#pragma once

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 970 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
























































































































































































































#line 1187 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 1189 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
#line 4 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\compute_common.hpp"


namespace glm{
namespace detail
{
	template<typename genFIType, bool  >
	struct compute_abs
	{};

	template<typename genFIType>
	struct compute_abs<genFIType, true>
	{
		inline constexpr static genFIType call(genFIType x)
		{
			static_assert(std::numeric_limits<genFIType>::is_iec559 || 0 || std::numeric_limits<genFIType>::is_signed, "'abs' only accept floating-point and integer scalar or vector inputs")

;

			return x >= genFIType(0) ? x : -x;
			
		}
	};










#line 37 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\compute_common.hpp"

	template<typename genFIType>
	struct compute_abs<genFIType, false>
	{
		inline constexpr static genFIType call(genFIType x)
		{
			static_assert((!std::numeric_limits<genFIType>::is_signed && std::numeric_limits<genFIType>::is_integer), "'abs' only accept floating-point and integer scalar or vector inputs")

;
			return x;
		}
	};
}
}
#line 6 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\func_common.inl"







namespace glm
{
	
	template<typename genType>
	inline constexpr genType min(genType x, genType y)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || 0 || std::numeric_limits<genType>::is_integer, "'min' only accept floating-point or integer inputs") ;
		return (y < x) ? y : x;
	}

	
	template<typename genType>
	inline constexpr genType max(genType x, genType y)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || 0 || std::numeric_limits<genType>::is_integer, "'max' only accept floating-point or integer inputs") ;

		return (x < y) ? y : x;
	}

	
	template<>
	inline constexpr int abs(int x)
	{
		int const y = x >> (sizeof(int) * 8 - 1);
		return (x ^ y) - y;
	}

	

		using ::std::round;








#line 52 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\func_common.inl"

	

		using ::std::trunc;








#line 65 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\func_common.inl"

}

namespace glm{
namespace detail
{
	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_abs_vector
	{
		inline constexpr static vec<L, T, Q> call(vec<L, T, Q> const& x)
		{
			return detail::functor1<vec, L, T, T, Q>::call(abs, x);
		}
	};

	template<length_t L, typename T, typename U, qualifier Q, bool Aligned>
	struct compute_mix_vector
	{
		inline constexpr static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, U, Q> const& a)
		{
			static_assert(std::numeric_limits<U>::is_iec559 || 0 || 0, "'mix' only accept floating-point inputs for the interpolator a") ;

			return vec<L, T, Q>(vec<L, U, Q>(x) * (static_cast<U>(1) - a) + vec<L, U, Q>(y) * a);
		}
	};

	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_mix_vector<L, T, bool, Q, Aligned>
	{
		inline constexpr static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, bool, Q> const& a)
		{
			vec<L, T, Q> Result(0);
			for(length_t i = 0; i < x.length(); ++i)
				Result[i] = a[i] ? y[i] : x[i];
			return Result;
		}
	};

	template<length_t L, typename T, typename U, qualifier Q, bool Aligned>
	struct compute_mix_scalar
	{
		inline constexpr static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y, U const& a)
		{
			static_assert(std::numeric_limits<U>::is_iec559 || 0 || 0, "'mix' only accept floating-point inputs for the interpolator a") ;

			return vec<L, T, Q>(vec<L, U, Q>(x) * (static_cast<U>(1) - a) + vec<L, U, Q>(y) * a);
		}
	};

	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_mix_scalar<L, T, bool, Q, Aligned>
	{
		inline constexpr static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y, bool const& a)
		{
			return a ? y : x;
		}
	};

	template<typename T, typename U>
	struct compute_mix
	{
		inline constexpr static T call(T const& x, T const& y, U const& a)
		{
			static_assert(std::numeric_limits<U>::is_iec559 || 0 || 0, "'mix' only accept floating-point inputs for the interpolator a") ;

			return static_cast<T>(static_cast<U>(x) * (static_cast<U>(1) - a) + static_cast<U>(y) * a);
		}
	};

	template<typename T>
	struct compute_mix<T, bool>
	{
		inline constexpr static T call(T const& x, T const& y, bool const& a)
		{
			return a ? y : x;
		}
	};

	template<length_t L, typename T, qualifier Q, bool isFloat, bool Aligned>
	struct compute_sign
	{
		inline constexpr static vec<L, T, Q> call(vec<L, T, Q> const& x)
		{
			return vec<L, T, Q>(glm::lessThan(vec<L, T, Q>(0), x)) - vec<L, T, Q>(glm::lessThan(x, vec<L, T, Q>(0)));
		}
	};


	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_sign<L, T, Q, false, Aligned>
	{
		inline constexpr static vec<L, T, Q> call(vec<L, T, Q> const& x)
		{
			T const Shift(static_cast<T>(sizeof(T) * 8 - 1));
			vec<L, T, Q> const y(vec<L, typename detail::make_unsigned<T>::type, Q>(-x) >> typename detail::make_unsigned<T>::type(Shift));

			return (x >> Shift) | y;
		}
	};
#line 165 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\func_common.inl"

	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_floor
	{
		inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
		{
			return detail::functor1<vec, L, T, T, Q>::call(std::floor, x);
		}
	};

	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_ceil
	{
		inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
		{
			return detail::functor1<vec, L, T, T, Q>::call(std::ceil, x);
		}
	};

	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_fract
	{
		inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
		{
			return x - floor(x);
		}
	};

	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_trunc
	{
		inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
		{
			return detail::functor1<vec, L, T, T, Q>::call(trunc, x);
		}
	};

	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_round
	{
		inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
		{
			return detail::functor1<vec, L, T, T, Q>::call(round, x);
		}
	};

	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_mod
	{
		inline static vec<L, T, Q> call(vec<L, T, Q> const& a, vec<L, T, Q> const& b)
		{
			static_assert(std::numeric_limits<T>::is_iec559 || 0, "'mod' only accept floating-point inputs. Include <glm/gtc/integer.hpp> for integer inputs.") ;
			return a - b * floor(a / b);
		}
	};

	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_min_vector
	{
		inline static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
		{
			return detail::functor2<vec, L, T, Q>::call(min, x, y);
		}
	};

	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_max_vector
	{
		inline static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
		{
			return detail::functor2<vec, L, T, Q>::call(max, x, y);
		}
	};

	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_clamp_vector
	{
		inline static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& minVal, vec<L, T, Q> const& maxVal)
		{
			return min(max(x, minVal), maxVal);
		}
	};

	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_step_vector
	{
		inline static vec<L, T, Q> call(vec<L, T, Q> const& edge, vec<L, T, Q> const& x)
		{
			return mix(vec<L, T, Q>(1), vec<L, T, Q>(0), glm::lessThan(x, edge));
		}
	};

	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_smoothstep_vector
	{
		inline static vec<L, T, Q> call(vec<L, T, Q> const& edge0, vec<L, T, Q> const& edge1, vec<L, T, Q> const& x)
		{
			static_assert(std::numeric_limits<T>::is_iec559 || 0 || 0, "'smoothstep' only accept floating-point inputs") ;
			vec<L, T, Q> const tmp(clamp((x - edge0) / (edge1 - edge0), static_cast<T>(0), static_cast<T>(1)));
			return tmp * tmp * (static_cast<T>(3) - static_cast<T>(2) * tmp);
		}
	};
}

	template<typename genFIType>
	inline constexpr genFIType abs(genFIType x)
	{
		return detail::compute_abs<genFIType, std::numeric_limits<genFIType>::is_signed>::call(x);
	}

	template<length_t L, typename T, qualifier Q>
	inline constexpr vec<L, T, Q> abs(vec<L, T, Q> const& x)
	{
		return detail::compute_abs_vector<L, T, Q, detail::is_aligned<Q>::value>::call(x);
	}

	
	
	template<typename genFIType>
	inline constexpr genFIType sign(genFIType x)
	{
		static_assert(std::numeric_limits<genFIType>::is_iec559 || 0 || (std::numeric_limits<genFIType>::is_signed && std::numeric_limits<genFIType>::is_integer), "'sign' only accept signed inputs")

;

		return detail::compute_sign<1, genFIType, defaultp,
                                    std::numeric_limits<genFIType>::is_iec559, detail::is_aligned<highp>::value>::call(vec<1, genFIType>(x)).x;
	}

	template<length_t L, typename T, qualifier Q>
	inline constexpr vec<L, T, Q> sign(vec<L, T, Q> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0 || (std::numeric_limits<T>::is_signed && std::numeric_limits<T>::is_integer), "'sign' only accept signed inputs")

;

		return detail::compute_sign<L, T, Q, std::numeric_limits<T>::is_iec559, detail::is_aligned<Q>::value>::call(x);
	}

	
	using ::std::floor;
	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> floor(vec<L, T, Q> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'floor' only accept floating-point inputs.") ;
		return detail::compute_floor<L, T, Q, detail::is_aligned<Q>::value>::call(x);
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> trunc(vec<L, T, Q> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'trunc' only accept floating-point inputs") ;
		return detail::compute_trunc<L, T, Q, detail::is_aligned<Q>::value>::call(x);
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> round(vec<L, T, Q> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'round' only accept floating-point inputs") ;
		return detail::compute_round<L, T, Q, detail::is_aligned<Q>::value>::call(x);
	}












	
	template<typename genType>
	inline genType roundEven(genType x)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'roundEven' only accept floating-point inputs") ;

		int Integer = static_cast<int>(x);
		genType IntegerPart = static_cast<genType>(Integer);
		genType FractionalPart = fract(x);

		if(FractionalPart > static_cast<genType>(0.5) || FractionalPart < static_cast<genType>(0.5))
		{
			return round(x);
		}
		else if((Integer % 2) == 0)
		{
			return IntegerPart;
		}
		else if(x <= static_cast<genType>(0)) 
		{
			return IntegerPart - static_cast<genType>(1);
		}
		else
		{
			return IntegerPart + static_cast<genType>(1);
		}
		
		
		
		
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> roundEven(vec<L, T, Q> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'roundEven' only accept floating-point inputs") ;
		return detail::functor1<vec, L, T, T, Q>::call(roundEven, x);
	}

	
	using ::std::ceil;
	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> ceil(vec<L, T, Q> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'ceil' only accept floating-point inputs") ;
		return detail::compute_ceil<L, T, Q, detail::is_aligned<Q>::value>::call(x);
	}

	
	template<typename genType>
	inline genType fract(genType x)
	{
		return fract(vec<1, genType>(x)).x;
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> fract(vec<L, T, Q> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'fract' only accept floating-point inputs") ;
		return detail::compute_fract<L, T, Q, detail::is_aligned<Q>::value>::call(x);
	}

	
	template<typename genType>
	inline genType mod(genType x, genType y)
	{




#line 409 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\func_common.inl"
			return mod(vec<1, genType, defaultp>(x), y).x;
#line 411 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\func_common.inl"
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> mod(vec<L, T, Q> const& x, T y)
	{
		return detail::compute_mod<L, T, Q, detail::is_aligned<Q>::value>::call(x, vec<L, T, Q>(y));
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> mod(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
	{
		return detail::compute_mod<L, T, Q, detail::is_aligned<Q>::value>::call(x, y);
	}

	
	template<typename genType>
	inline genType modf(genType x, genType & i)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'modf' only accept floating-point inputs") ;
		return std::modf(x, &i);
	}

	template<typename T, qualifier Q>
	inline vec<1, T, Q> modf(vec<1, T, Q> const& x, vec<1, T, Q> & i)
	{
		return vec<1, T, Q>(
			modf(x.x, i.x));
	}

	template<typename T, qualifier Q>
	inline vec<2, T, Q> modf(vec<2, T, Q> const& x, vec<2, T, Q> & i)
	{
		return vec<2, T, Q>(
			modf(x.x, i.x),
			modf(x.y, i.y));
	}

	template<typename T, qualifier Q>
	inline vec<3, T, Q> modf(vec<3, T, Q> const& x, vec<3, T, Q> & i)
	{
		return vec<3, T, Q>(
			modf(x.x, i.x),
			modf(x.y, i.y),
			modf(x.z, i.z));
	}

	template<typename T, qualifier Q>
	inline vec<4, T, Q> modf(vec<4, T, Q> const& x, vec<4, T, Q> & i)
	{
		return vec<4, T, Q>(
			modf(x.x, i.x),
			modf(x.y, i.y),
			modf(x.z, i.z),
			modf(x.w, i.w));
	}

	
	
	
	
	
	
	

	
	template<length_t L, typename T, qualifier Q>
	inline constexpr vec<L, T, Q> min(vec<L, T, Q> const& a, T b)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0 || std::numeric_limits<T>::is_integer, "'min' only accept floating-point or integer inputs") ;
		return detail::compute_min_vector<L, T, Q, detail::is_aligned<Q>::value>::call(a, vec<L, T, Q>(b));
	}

	template<length_t L, typename T, qualifier Q>
	inline constexpr vec<L, T, Q> min(vec<L, T, Q> const& a, vec<L, T, Q> const& b)
	{
		return detail::compute_min_vector<L, T, Q, detail::is_aligned<Q>::value>::call(a, b);
	}

	
	template<length_t L, typename T, qualifier Q>
	inline constexpr vec<L, T, Q> max(vec<L, T, Q> const& a, T b)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0 || std::numeric_limits<T>::is_integer, "'max' only accept floating-point or integer inputs") ;
		return detail::compute_max_vector<L, T, Q, detail::is_aligned<Q>::value>::call(a, vec<L, T, Q>(b));
	}

	template<length_t L, typename T, qualifier Q>
	inline constexpr vec<L, T, Q> max(vec<L, T, Q> const& a, vec<L, T, Q> const& b)
	{
		return detail::compute_max_vector<L, T, Q, detail::is_aligned<Q>::value>::call(a, b);
	}

	
	template<typename genType>
	inline constexpr genType clamp(genType x, genType minVal, genType maxVal)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || 0 || std::numeric_limits<genType>::is_integer, "'clamp' only accept floating-point or integer inputs") ;
		return min(max(x, minVal), maxVal);
	}

	template<length_t L, typename T, qualifier Q>
	inline constexpr vec<L, T, Q> clamp(vec<L, T, Q> const& x, T minVal, T maxVal)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0 || std::numeric_limits<T>::is_integer, "'clamp' only accept floating-point or integer inputs") ;
		return detail::compute_clamp_vector<L, T, Q, detail::is_aligned<Q>::value>::call(x, vec<L, T, Q>(minVal), vec<L, T, Q>(maxVal));
	}

	template<length_t L, typename T, qualifier Q>
	inline constexpr vec<L, T, Q> clamp(vec<L, T, Q> const& x, vec<L, T, Q> const& minVal, vec<L, T, Q> const& maxVal)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0 || std::numeric_limits<T>::is_integer, "'clamp' only accept floating-point or integer inputs") ;
		return detail::compute_clamp_vector<L, T, Q, detail::is_aligned<Q>::value>::call(x, minVal, maxVal);
	}

	template<typename genTypeT, typename genTypeU>
	inline constexpr genTypeT mix(genTypeT x, genTypeT y, genTypeU a)
	{
		return detail::compute_mix<genTypeT, genTypeU>::call(x, y, a);
	}

	template<length_t L, typename T, typename U, qualifier Q>
	inline constexpr vec<L, T, Q> mix(vec<L, T, Q> const& x, vec<L, T, Q> const& y, U a)
	{
		return detail::compute_mix_scalar<L, T, U, Q, detail::is_aligned<Q>::value>::call(x, y, a);
	}

	template<length_t L, typename T, typename U, qualifier Q>
	inline constexpr vec<L, T, Q> mix(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, U, Q> const& a)
	{
		return detail::compute_mix_vector<L, T, U, Q, detail::is_aligned<Q>::value>::call(x, y, a);
	}

	
	template<typename genType>
	inline genType step(genType edge, genType x)
	{
		return mix(static_cast<genType>(1), static_cast<genType>(0), x < edge);
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> step(T edge, vec<L, T, Q> const& x)
	{
		return detail::compute_step_vector<L, T, Q, detail::is_aligned<Q>::value>::call(vec<L, T, Q>(edge), x);
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> step(vec<L, T, Q> const& edge, vec<L, T, Q> const& x)
	{
		return detail::compute_step_vector<L, T, Q, detail::is_aligned<Q>::value>::call(edge, x);
	}

	
	template<typename genType>
	inline genType smoothstep(genType edge0, genType edge1, genType x)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || 0 || 0, "'smoothstep' only accept floating-point inputs") ;

		genType const tmp(clamp((x - edge0) / (edge1 - edge0), genType(0), genType(1)));
		return tmp * tmp * (genType(3) - genType(2) * tmp);
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> smoothstep(T edge0, T edge1, vec<L, T, Q> const& x)
	{
		return detail::compute_smoothstep_vector<L, T, Q, detail::is_aligned<Q>::value>::call(vec<L, T, Q>(edge0), vec<L, T, Q>(edge1), x);
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> smoothstep(vec<L, T, Q> const& edge0, vec<L, T, Q> const& edge1, vec<L, T, Q> const& x)
	{
		return detail::compute_smoothstep_vector<L, T, Q, detail::is_aligned<Q>::value>::call(edge0, edge1, x);
	}


		using std::isnan;
























#line 611 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\func_common.inl"

	template<length_t L, typename T, qualifier Q>
	inline vec<L, bool, Q> isnan(vec<L, T, Q> const& v)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'isnan' only accept floating-point inputs") ;

		vec<L, bool, Q> Result(0);
		for (length_t l = 0; l < v.length(); ++l)
			Result[l] = glm::isnan(v[l]);
		return Result;
	}


		using std::isinf;



























#line 653 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\func_common.inl"

	template<length_t L, typename T, qualifier Q>
	inline vec<L, bool, Q> isinf(vec<L, T, Q> const& v)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'isinf' only accept floating-point inputs") ;

		vec<L, bool, Q> Result(0);
		for (length_t l = 0; l < v.length(); ++l)
			Result[l] = glm::isinf(v[l]);
		return Result;
	}

	inline int floatBitsToInt(float v)
	{
		union
		{
			float in;
			int out;
		} u;

		u.in = v;

		return u.out;
	}

	template<length_t L, qualifier Q>
	inline vec<L, int, Q> floatBitsToInt(vec<L, float, Q> const& v)
	{
		return detail::functor1<vec, L, int, float, Q>::call(floatBitsToInt, v);
	}

	inline uint floatBitsToUint(float v)
	{
		union
		{
			float in;
			uint out;
		} u;

		u.in = v;

		return u.out;
	}

	template<length_t L, qualifier Q>
	inline vec<L, uint, Q> floatBitsToUint(vec<L, float, Q> const& v)
	{
		return detail::functor1<vec, L, uint, float, Q>::call(floatBitsToUint, v);
	}

	inline float intBitsToFloat(int v)
	{
		union
		{
			int in;
			float out;
		} u;

		u.in = v;

		return u.out;
	}

	template<length_t L, qualifier Q>
	inline vec<L, float, Q> intBitsToFloat(vec<L, int, Q> const& v)
	{
		return detail::functor1<vec, L, float, int, Q>::call(intBitsToFloat, v);
	}

	inline float uintBitsToFloat(uint v)
	{
		union
		{
			uint in;
			float out;
		} u;

		u.in = v;

		return u.out;
	}

	template<length_t L, qualifier Q>
	inline vec<L, float, Q> uintBitsToFloat(vec<L, uint, Q> const& v)
	{
		return reinterpret_cast<vec<L, float, Q>&>(const_cast<vec<L, uint, Q>&>(v));
	}


		using std::fma;






#line 750 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\func_common.inl"

	template<typename genType>
	inline genType frexp(genType x, int& exp)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'frexp' only accept floating-point inputs") ;

		return std::frexp(x, &exp);
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> frexp(vec<L, T, Q> const& v, vec<L, int, Q>& exp)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'frexp' only accept floating-point inputs") ;

		vec<L, T, Q> Result(0);
		for (length_t l = 0; l < v.length(); ++l)
			Result[l] = std::frexp(v[l], &exp[l]);
		return Result;
	}

	template<typename genType>
	inline genType ldexp(genType const& x, int const& exp)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'ldexp' only accept floating-point inputs") ;

		return std::ldexp(x, exp);
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> ldexp(vec<L, T, Q> const& v, vec<L, int, Q> const& exp)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'ldexp' only accept floating-point inputs") ;

		vec<L, T, Q> Result(0);
		for (length_t l = 0; l < v.length(); ++l)
			Result[l] = std::ldexp(v[l], exp[l]);
		return Result;
	}
}



#line 793 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\func_common.inl"
#line 539 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\common.hpp"

#line 3 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\func_geometric.inl"

namespace glm{
namespace detail
{
	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_length
	{
		inline static T call(vec<L, T, Q> const& v)
		{
			return sqrt(dot(v, v));
		}
	};

	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_distance
	{
		inline static T call(vec<L, T, Q> const& p0, vec<L, T, Q> const& p1)
		{
			return length(p1 - p0);
		}
	};

	template<typename V, typename T, bool Aligned>
	struct compute_dot{};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_dot<vec<1, T, Q>, T, Aligned>
	{
		inline constexpr static T call(vec<1, T, Q> const& a, vec<1, T, Q> const& b)
		{
			return a.x * b.x;
		}
	};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_dot<vec<2, T, Q>, T, Aligned>
	{
		inline constexpr static T call(vec<2, T, Q> const& a, vec<2, T, Q> const& b)
		{
			vec<2, T, Q> tmp(a * b);
			return tmp.x + tmp.y;
		}
	};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_dot<vec<3, T, Q>, T, Aligned>
	{
		inline constexpr static T call(vec<3, T, Q> const& a, vec<3, T, Q> const& b)
		{
			vec<3, T, Q> tmp(a * b);
			return tmp.x + tmp.y + tmp.z;
		}
	};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_dot<vec<4, T, Q>, T, Aligned>
	{
		inline constexpr static T call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
		{
			vec<4, T, Q> tmp(a * b);
			return (tmp.x + tmp.y) + (tmp.z + tmp.w);
		}
	};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_cross
	{
		inline constexpr static vec<3, T, Q> call(vec<3, T, Q> const& x, vec<3, T, Q> const& y)
		{
			static_assert(std::numeric_limits<T>::is_iec559, "'cross' accepts only floating-point inputs") ;

			return vec<3, T, Q>(
				x.y * y.z - y.y * x.z,
				x.z * y.x - y.z * x.x,
				x.x * y.y - y.x * x.y);
		}
	};

	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_normalize
	{
		inline static vec<L, T, Q> call(vec<L, T, Q> const& v)
		{
			static_assert(std::numeric_limits<T>::is_iec559, "'normalize' accepts only floating-point inputs") ;

			return v * inversesqrt(dot(v, v));
		}
	};

	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_faceforward
	{
		inline static vec<L, T, Q> call(vec<L, T, Q> const& N, vec<L, T, Q> const& I, vec<L, T, Q> const& Nref)
		{
			static_assert(std::numeric_limits<T>::is_iec559, "'normalize' accepts only floating-point inputs") ;

			return dot(Nref, I) < static_cast<T>(0) ? N : -N;
		}
	};

	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_reflect
	{
		inline static vec<L, T, Q> call(vec<L, T, Q> const& I, vec<L, T, Q> const& N)
		{
			return I - N * dot(N, I) * static_cast<T>(2);
		}
	};

	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_refract
	{
		inline static vec<L, T, Q> call(vec<L, T, Q> const& I, vec<L, T, Q> const& N, T eta)
		{
			T const dotValue(dot(N, I));
			T const k(static_cast<T>(1) - eta * eta * (static_cast<T>(1) - dotValue * dotValue));
			vec<L, T, Q> const Result =
                (k >= static_cast<T>(0)) ? (eta * I - (eta * dotValue + std::sqrt(k)) * N) : vec<L, T, Q>(0);
			return Result;
		}
	};
}

	
	template<typename genType>
	inline genType length(genType x)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'length' accepts only floating-point inputs") ;

		return abs(x);
	}

	template<length_t L, typename T, qualifier Q>
	inline T length(vec<L, T, Q> const& v)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'length' accepts only floating-point inputs") ;

		return detail::compute_length<L, T, Q, detail::is_aligned<Q>::value>::call(v);
	}

	
	template<typename genType>
	inline genType distance(genType const& p0, genType const& p1)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'distance' accepts only floating-point inputs") ;

		return length(p1 - p0);
	}

	template<length_t L, typename T, qualifier Q>
	inline T distance(vec<L, T, Q> const& p0, vec<L, T, Q> const& p1)
	{
		return detail::compute_distance<L, T, Q, detail::is_aligned<Q>::value>::call(p0, p1);
	}

	
	template<typename T>
	inline constexpr T dot(T x, T y)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'dot' accepts only floating-point inputs") ;
		return x * y;
	}

	template<length_t L, typename T, qualifier Q>
	inline constexpr T dot(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'dot' accepts only floating-point inputs") ;
		return detail::compute_dot<vec<L, T, Q>, T, detail::is_aligned<Q>::value>::call(x, y);
	}

	
	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> cross(vec<3, T, Q> const& x, vec<3, T, Q> const& y)
	{
		return detail::compute_cross<T, Q, detail::is_aligned<Q>::value>::call(x, y);
	}










	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> normalize(vec<L, T, Q> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'normalize' accepts only floating-point inputs") ;

		return detail::compute_normalize<L, T, Q, detail::is_aligned<Q>::value>::call(x);
	}

	
	template<typename genType>
	inline genType faceforward(genType const& N, genType const& I, genType const& Nref)
	{
		return dot(Nref, I) < static_cast<genType>(0) ? N : -N;
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> faceforward(vec<L, T, Q> const& N, vec<L, T, Q> const& I, vec<L, T, Q> const& Nref)
	{
		return detail::compute_faceforward<L, T, Q, detail::is_aligned<Q>::value>::call(N, I, Nref);
	}

	
	template<typename genType>
	inline genType reflect(genType const& I, genType const& N)
	{
		return I - N * dot(N, I) * genType(2);
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> reflect(vec<L, T, Q> const& I, vec<L, T, Q> const& N)
	{
		return detail::compute_reflect<L, T, Q, detail::is_aligned<Q>::value>::call(I, N);
	}

	
	template<typename genType>
	inline genType refract(genType const& I, genType const& N, genType eta)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'refract' accepts only floating-point inputs") ;
		genType const dotValue(dot(N, I));
		genType const k(static_cast<genType>(1) - eta * eta * (static_cast<genType>(1) - dotValue * dotValue));
		return (eta * I - (eta * dotValue + sqrt(k)) * N) * static_cast<genType>(k >= static_cast<genType>(0));
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> refract(vec<L, T, Q> const& I, vec<L, T, Q> const& N, T eta)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'refract' accepts only floating-point inputs") ;
		return detail::compute_refract<L, T, Q, detail::is_aligned<Q>::value>::call(I, N, eta);
	}
}



#line 244 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\func_geometric.inl"
#line 117 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\geometric.hpp"
#line 2 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\func_matrix.inl"


namespace glm{
namespace detail
{
	template<length_t C, length_t R, typename T, qualifier Q, bool Aligned>
	struct compute_matrixCompMult
	{
		inline static mat<C, R, T, Q> call(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y)
		{
			mat<C, R, T, Q> Result(1);
			for(length_t i = 0; i < Result.length(); ++i)
				Result[i] = x[i] * y[i];
			return Result;
		}
	};

	template<length_t C, length_t R, typename T, qualifier Q, bool IsFloat, bool Aligned>
	struct compute_matrixCompMult_type {
		inline static mat<C, R, T, Q> call(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y)
		{
			static_assert(std::numeric_limits<T>::is_iec559 || 0, "'matrixCompMult' only accept floating-point inputs, include <glm/ext/matrix_integer.hpp> to discard this restriction.")
;
			return detail::compute_matrixCompMult<C, R, T, Q, detail::is_aligned<Q>::value>::call(x, y);
		}
	};

	template<length_t DA, length_t DB, typename T, qualifier Q>
	struct compute_outerProduct {
		inline static typename detail::outerProduct_trait<DA, DB, T, Q>::type call(vec<DA, T, Q> const& c, vec<DB, T, Q> const& r)
		{
			typename detail::outerProduct_trait<DA, DB, T, Q>::type m(0);
			for(length_t i = 0; i < m.length(); ++i)
				m[i] = c * r[i];
			return m;
		}
	};

	template<length_t DA, length_t DB, typename T, qualifier Q, bool IsFloat>
	struct compute_outerProduct_type {
		inline static typename detail::outerProduct_trait<DA, DB, T, Q>::type call(vec<DA, T, Q> const& c, vec<DB, T, Q> const& r)
		{
			static_assert(std::numeric_limits<T>::is_iec559 || 0, "'outerProduct' only accept floating-point inputs, include <glm/ext/matrix_integer.hpp> to discard this restriction.")
;

			return detail::compute_outerProduct<DA, DB, T, Q>::call(c, r);
		}
	};

	template<length_t C, length_t R, typename T, qualifier Q, bool Aligned>
	struct compute_transpose{};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_transpose<2, 2, T, Q, Aligned>
	{
		inline static mat<2, 2, T, Q> call(mat<2, 2, T, Q> const& m)
		{
			mat<2, 2, T, Q> Result(1);
			Result[0][0] = m[0][0];
			Result[0][1] = m[1][0];
			Result[1][0] = m[0][1];
			Result[1][1] = m[1][1];
			return Result;
		}
	};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_transpose<2, 3, T, Q, Aligned>
	{
		inline static mat<3, 2, T, Q> call(mat<2, 3, T, Q> const& m)
		{
			mat<3,2, T, Q> Result(1);
			Result[0][0] = m[0][0];
			Result[0][1] = m[1][0];
			Result[1][0] = m[0][1];
			Result[1][1] = m[1][1];
			Result[2][0] = m[0][2];
			Result[2][1] = m[1][2];
			return Result;
		}
	};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_transpose<2, 4, T, Q, Aligned>
	{
		inline static mat<4, 2, T, Q> call(mat<2, 4, T, Q> const& m)
		{
			mat<4, 2, T, Q> Result(1);
			Result[0][0] = m[0][0];
			Result[0][1] = m[1][0];
			Result[1][0] = m[0][1];
			Result[1][1] = m[1][1];
			Result[2][0] = m[0][2];
			Result[2][1] = m[1][2];
			Result[3][0] = m[0][3];
			Result[3][1] = m[1][3];
			return Result;
		}
	};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_transpose<3, 2, T, Q, Aligned>
	{
		inline static mat<2, 3, T, Q> call(mat<3, 2, T, Q> const& m)
		{
			mat<2, 3, T, Q> Result(1);
			Result[0][0] = m[0][0];
			Result[0][1] = m[1][0];
			Result[0][2] = m[2][0];
			Result[1][0] = m[0][1];
			Result[1][1] = m[1][1];
			Result[1][2] = m[2][1];
			return Result;
		}
	};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_transpose<3, 3, T, Q, Aligned>
	{
		inline static mat<3, 3, T, Q> call(mat<3, 3, T, Q> const& m)
		{
			mat<3, 3, T, Q> Result(1);
			Result[0][0] = m[0][0];
			Result[0][1] = m[1][0];
			Result[0][2] = m[2][0];

			Result[1][0] = m[0][1];
			Result[1][1] = m[1][1];
			Result[1][2] = m[2][1];

			Result[2][0] = m[0][2];
			Result[2][1] = m[1][2];
			Result[2][2] = m[2][2];
			return Result;
		}
	};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_transpose<3, 4, T, Q, Aligned>
	{
		inline static mat<4, 3, T, Q> call(mat<3, 4, T, Q> const& m)
		{
			mat<4, 3, T, Q> Result(1);
			Result[0][0] = m[0][0];
			Result[0][1] = m[1][0];
			Result[0][2] = m[2][0];
			Result[1][0] = m[0][1];
			Result[1][1] = m[1][1];
			Result[1][2] = m[2][1];
			Result[2][0] = m[0][2];
			Result[2][1] = m[1][2];
			Result[2][2] = m[2][2];
			Result[3][0] = m[0][3];
			Result[3][1] = m[1][3];
			Result[3][2] = m[2][3];
			return Result;
		}
	};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_transpose<4, 2, T, Q, Aligned>
	{
		inline static mat<2, 4, T, Q> call(mat<4, 2, T, Q> const& m)
		{
			mat<2, 4, T, Q> Result(1);
			Result[0][0] = m[0][0];
			Result[0][1] = m[1][0];
			Result[0][2] = m[2][0];
			Result[0][3] = m[3][0];
			Result[1][0] = m[0][1];
			Result[1][1] = m[1][1];
			Result[1][2] = m[2][1];
			Result[1][3] = m[3][1];
			return Result;
		}
	};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_transpose<4, 3, T, Q, Aligned>
	{
		inline static mat<3, 4, T, Q> call(mat<4, 3, T, Q> const& m)
		{
			mat<3, 4, T, Q> Result(1);
			Result[0][0] = m[0][0];
			Result[0][1] = m[1][0];
			Result[0][2] = m[2][0];
			Result[0][3] = m[3][0];
			Result[1][0] = m[0][1];
			Result[1][1] = m[1][1];
			Result[1][2] = m[2][1];
			Result[1][3] = m[3][1];
			Result[2][0] = m[0][2];
			Result[2][1] = m[1][2];
			Result[2][2] = m[2][2];
			Result[2][3] = m[3][2];
			return Result;
		}
	};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_transpose<4, 4, T, Q, Aligned>
	{
		inline static mat<4, 4, T, Q> call(mat<4, 4, T, Q> const& m)
		{
			mat<4, 4, T, Q> Result(1);
			Result[0][0] = m[0][0];
			Result[0][1] = m[1][0];
			Result[0][2] = m[2][0];
			Result[0][3] = m[3][0];

			Result[1][0] = m[0][1];
			Result[1][1] = m[1][1];
			Result[1][2] = m[2][1];
			Result[1][3] = m[3][1];

			Result[2][0] = m[0][2];
			Result[2][1] = m[1][2];
			Result[2][2] = m[2][2];
			Result[2][3] = m[3][2];

			Result[3][0] = m[0][3];
			Result[3][1] = m[1][3];
			Result[3][2] = m[2][3];
			Result[3][3] = m[3][3];
			return Result;
		}
	};

	template<length_t C, length_t R, typename T, qualifier Q, bool IsFloat, bool Aligned>
	struct compute_transpose_type {
		inline static mat<R, C, T, Q> call(mat<C, R, T, Q> const& m)
		{
			static_assert(std::numeric_limits<T>::is_iec559 || 0, "'transpose' only accept floating-point inputs, include <glm/ext/matrix_integer.hpp> to discard this restriction.")
;
			return detail::compute_transpose<C, R, T, Q, detail::is_aligned<Q>::value>::call(m);
		}
	};

	template<length_t C, length_t R, typename T, qualifier Q, bool Aligned>
	struct compute_determinant{};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_determinant<2, 2, T, Q, Aligned>
	{
		inline static T call(mat<2, 2, T, Q> const& m)
		{
			return m[0][0] * m[1][1] - m[1][0] * m[0][1];
		}
	};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_determinant<3, 3, T, Q, Aligned>
	{
		inline static T call(mat<3, 3, T, Q> const& m)
		{
			return
				+ m[0][0] * (m[1][1] * m[2][2] - m[2][1] * m[1][2])
				- m[1][0] * (m[0][1] * m[2][2] - m[2][1] * m[0][2])
				+ m[2][0] * (m[0][1] * m[1][2] - m[1][1] * m[0][2]);
		}
	};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_determinant<4, 4, T, Q, Aligned>
	{
		inline static T call(mat<4, 4, T, Q> const& m)
		{
			T SubFactor00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
			T SubFactor01 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
			T SubFactor02 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
			T SubFactor03 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
			T SubFactor04 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
			T SubFactor05 = m[2][0] * m[3][1] - m[3][0] * m[2][1];

			vec<4, T, Q> DetCof(
				+ (m[1][1] * SubFactor00 - m[1][2] * SubFactor01 + m[1][3] * SubFactor02),
				- (m[1][0] * SubFactor00 - m[1][2] * SubFactor03 + m[1][3] * SubFactor04),
				+ (m[1][0] * SubFactor01 - m[1][1] * SubFactor03 + m[1][3] * SubFactor05),
				- (m[1][0] * SubFactor02 - m[1][1] * SubFactor04 + m[1][2] * SubFactor05));

			return
				m[0][0] * DetCof[0] + m[0][1] * DetCof[1] +
				m[0][2] * DetCof[2] + m[0][3] * DetCof[3];
		}
	};

	template<length_t C, length_t R, typename T, qualifier Q, bool IsFloat, bool Aligned>
	struct compute_determinant_type{
	
		inline static T call(mat<C, R, T, Q> const& m)
		{
			static_assert(std::numeric_limits<T>::is_iec559 || 0, "'determinant' only accept floating-point inputs, include <glm/ext/matrix_integer.hpp> to discard this restriction.")
;
			return detail::compute_determinant<C, R, T, Q, detail::is_aligned<Q>::value>::call(m);
		}
	};

	template<length_t C, length_t R, typename T, qualifier Q, bool Aligned>
	struct compute_inverse{};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_inverse<2, 2, T, Q, Aligned>
	{
		inline static mat<2, 2, T, Q> call(mat<2, 2, T, Q> const& m)
		{
			T OneOverDeterminant = static_cast<T>(1) / (
				+ m[0][0] * m[1][1]
				- m[1][0] * m[0][1]);

			mat<2, 2, T, Q> Inverse(
				+ m[1][1] * OneOverDeterminant,
				- m[0][1] * OneOverDeterminant,
				- m[1][0] * OneOverDeterminant,
				+ m[0][0] * OneOverDeterminant);

			return Inverse;
		}
	};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_inverse<3, 3, T, Q, Aligned>
	{
		inline static mat<3, 3, T, Q> call(mat<3, 3, T, Q> const& m)
		{
			T OneOverDeterminant = static_cast<T>(1) / (
				+ m[0][0] * (m[1][1] * m[2][2] - m[2][1] * m[1][2])
				- m[1][0] * (m[0][1] * m[2][2] - m[2][1] * m[0][2])
				+ m[2][0] * (m[0][1] * m[1][2] - m[1][1] * m[0][2]));

			mat<3, 3, T, Q> Inverse;
			Inverse[0][0] = + (m[1][1] * m[2][2] - m[2][1] * m[1][2]) * OneOverDeterminant;
			Inverse[1][0] = - (m[1][0] * m[2][2] - m[2][0] * m[1][2]) * OneOverDeterminant;
			Inverse[2][0] = + (m[1][0] * m[2][1] - m[2][0] * m[1][1]) * OneOverDeterminant;
			Inverse[0][1] = - (m[0][1] * m[2][2] - m[2][1] * m[0][2]) * OneOverDeterminant;
			Inverse[1][1] = + (m[0][0] * m[2][2] - m[2][0] * m[0][2]) * OneOverDeterminant;
			Inverse[2][1] = - (m[0][0] * m[2][1] - m[2][0] * m[0][1]) * OneOverDeterminant;
			Inverse[0][2] = + (m[0][1] * m[1][2] - m[1][1] * m[0][2]) * OneOverDeterminant;
			Inverse[1][2] = - (m[0][0] * m[1][2] - m[1][0] * m[0][2]) * OneOverDeterminant;
			Inverse[2][2] = + (m[0][0] * m[1][1] - m[1][0] * m[0][1]) * OneOverDeterminant;

			return Inverse;
		}
	};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_inverse<4, 4, T, Q, Aligned>
	{
		inline static mat<4, 4, T, Q> call(mat<4, 4, T, Q> const& m)
		{
			T Coef00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
			T Coef02 = m[1][2] * m[3][3] - m[3][2] * m[1][3];
			T Coef03 = m[1][2] * m[2][3] - m[2][2] * m[1][3];

			T Coef04 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
			T Coef06 = m[1][1] * m[3][3] - m[3][1] * m[1][3];
			T Coef07 = m[1][1] * m[2][3] - m[2][1] * m[1][3];

			T Coef08 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
			T Coef10 = m[1][1] * m[3][2] - m[3][1] * m[1][2];
			T Coef11 = m[1][1] * m[2][2] - m[2][1] * m[1][2];

			T Coef12 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
			T Coef14 = m[1][0] * m[3][3] - m[3][0] * m[1][3];
			T Coef15 = m[1][0] * m[2][3] - m[2][0] * m[1][3];

			T Coef16 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
			T Coef18 = m[1][0] * m[3][2] - m[3][0] * m[1][2];
			T Coef19 = m[1][0] * m[2][2] - m[2][0] * m[1][2];

			T Coef20 = m[2][0] * m[3][1] - m[3][0] * m[2][1];
			T Coef22 = m[1][0] * m[3][1] - m[3][0] * m[1][1];
			T Coef23 = m[1][0] * m[2][1] - m[2][0] * m[1][1];

			vec<4, T, Q> Fac0(Coef00, Coef00, Coef02, Coef03);
			vec<4, T, Q> Fac1(Coef04, Coef04, Coef06, Coef07);
			vec<4, T, Q> Fac2(Coef08, Coef08, Coef10, Coef11);
			vec<4, T, Q> Fac3(Coef12, Coef12, Coef14, Coef15);
			vec<4, T, Q> Fac4(Coef16, Coef16, Coef18, Coef19);
			vec<4, T, Q> Fac5(Coef20, Coef20, Coef22, Coef23);

			vec<4, T, Q> Vec0(m[1][0], m[0][0], m[0][0], m[0][0]);
			vec<4, T, Q> Vec1(m[1][1], m[0][1], m[0][1], m[0][1]);
			vec<4, T, Q> Vec2(m[1][2], m[0][2], m[0][2], m[0][2]);
			vec<4, T, Q> Vec3(m[1][3], m[0][3], m[0][3], m[0][3]);

			vec<4, T, Q> Inv0(Vec1 * Fac0 - Vec2 * Fac1 + Vec3 * Fac2);
			vec<4, T, Q> Inv1(Vec0 * Fac0 - Vec2 * Fac3 + Vec3 * Fac4);
			vec<4, T, Q> Inv2(Vec0 * Fac1 - Vec1 * Fac3 + Vec3 * Fac5);
			vec<4, T, Q> Inv3(Vec0 * Fac2 - Vec1 * Fac4 + Vec2 * Fac5);

			vec<4, T, Q> SignA(+1, -1, +1, -1);
			vec<4, T, Q> SignB(-1, +1, -1, +1);
			mat<4, 4, T, Q> Inverse(Inv0 * SignA, Inv1 * SignB, Inv2 * SignA, Inv3 * SignB);

			vec<4, T, Q> Row0(Inverse[0][0], Inverse[1][0], Inverse[2][0], Inverse[3][0]);

			vec<4, T, Q> Dot0(m[0] * Row0);
			T Dot1 = (Dot0.x + Dot0.y) + (Dot0.z + Dot0.w);

			T OneOverDeterminant = static_cast<T>(1) / Dot1;

			return Inverse * OneOverDeterminant;
		}
	};
}

	template<length_t C, length_t R, typename T, qualifier Q>
	inline mat<C, R, T, Q> matrixCompMult(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y)
	{
		return detail::compute_matrixCompMult_type<C, R, T, Q, std::numeric_limits<T>::is_iec559, detail::is_aligned<Q>::value>::call(x, y);
	}

	template<length_t DA, length_t DB, typename T, qualifier Q>
	inline typename detail::outerProduct_trait<DA, DB, T, Q>::type outerProduct(vec<DA, T, Q> const& c, vec<DB, T, Q> const& r)
	{
		return detail::compute_outerProduct_type<DA, DB, T, Q, std::numeric_limits<T>::is_iec559>::call(c, r);
	}

	template<length_t C, length_t R, typename T, qualifier Q>
	inline typename mat<C, R, T, Q>::transpose_type transpose(mat<C, R, T, Q> const& m)
	{
		return detail::compute_transpose_type<C, R, T, Q, std::numeric_limits<T>::is_iec559, detail::is_aligned<Q>::value>::call(m);
	}

	template<length_t C, length_t R, typename T, qualifier Q>
	inline T determinant(mat<C, R, T, Q> const& m)
	{
		return detail::compute_determinant_type<C, R, T, Q, std::numeric_limits<T>::is_iec559, detail::is_aligned<Q>::value>::call(m);
	}

	template<length_t C, length_t R, typename T, qualifier Q>
	inline mat<C, R, T, Q> inverse(mat<C, R, T, Q> const& m)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'inverse' only accept floating-point inputs") ;
		return detail::compute_inverse<C, R, T, Q, detail::is_aligned<Q>::value>::call(m);
	}
}



#line 443 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\func_matrix.inl"

#line 162 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\matrix.hpp"
#line 2 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x2.inl"

namespace glm
{
	













#line 20 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x2.inl"

	template<typename T, qualifier Q>
	template<qualifier P>
	inline constexpr mat<2, 2, T, Q>::mat(mat<2, 2, T, P> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 27 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x2.inl"
	{



#line 32 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x2.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 2, T, Q>::mat(T scalar)

			: value{col_type(scalar, 0), col_type(0, scalar)}
#line 39 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x2.inl"
	{



#line 44 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x2.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 2, T, Q>::mat
	(
		T const& x0, T const& y0,
		T const& x1, T const& y1
	)

			: value{col_type(x0, y0), col_type(x1, y1)}
#line 55 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x2.inl"
	{



#line 60 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x2.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 2, T, Q>::mat(col_type const& v0, col_type const& v1)

			: value{v0, v1}
#line 67 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x2.inl"
	{



#line 72 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x2.inl"
	}

	

	template<typename T, qualifier Q>
	template<typename X1, typename Y1, typename X2, typename Y2>
	inline constexpr mat<2, 2, T, Q>::mat
	(
		X1 const& x1, Y1 const& y1,
		X2 const& x2, Y2 const& y2
	)

			: value{col_type(static_cast<T>(x1), value_type(y1)), col_type(static_cast<T>(x2), value_type(y2)) }
#line 86 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x2.inl"
	{



#line 91 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x2.inl"
	}

	template<typename T, qualifier Q>
	template<typename V1, typename V2>
	inline constexpr mat<2, 2, T, Q>::mat(vec<2, V1, Q> const& v1, vec<2, V2, Q> const& v2)

			: value{col_type(v1), col_type(v2)}
#line 99 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x2.inl"
	{



#line 104 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x2.inl"
	}

	

	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	inline constexpr mat<2, 2, T, Q>::mat(mat<2, 2, U, P> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 114 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x2.inl"
	{



#line 119 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x2.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 2, T, Q>::mat(mat<3, 3, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 126 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x2.inl"
	{



#line 131 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x2.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 2, T, Q>::mat(mat<4, 4, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 138 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x2.inl"
	{



#line 143 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x2.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 2, T, Q>::mat(mat<2, 3, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 150 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x2.inl"
	{



#line 155 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x2.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 2, T, Q>::mat(mat<3, 2, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 162 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x2.inl"
	{



#line 167 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x2.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 2, T, Q>::mat(mat<2, 4, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 174 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x2.inl"
	{



#line 179 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x2.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 2, T, Q>::mat(mat<4, 2, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 186 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x2.inl"
	{



#line 191 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x2.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 2, T, Q>::mat(mat<3, 4, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 198 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x2.inl"
	{



#line 203 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x2.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 2, T, Q>::mat(mat<4, 3, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 210 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x2.inl"
	{



#line 215 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x2.inl"
	}

	

	template<typename T, qualifier Q>
	inline constexpr typename mat<2, 2, T, Q>::col_type& mat<2, 2, T, Q>::operator[](typename mat<2, 2, T, Q>::length_type i) noexcept
	{
		((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x2.inl", (unsigned)(222)), 0) )) ;
		return this->value[i];
	}

	template<typename T, qualifier Q>
	inline constexpr typename mat<2, 2, T, Q>::col_type const& mat<2, 2, T, Q>::operator[](typename mat<2, 2, T, Q>::length_type i) const noexcept
	{
		((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x2.inl", (unsigned)(229)), 0) )) ;
		return this->value[i];
	}

	

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator=(mat<2, 2, U, Q> const& m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator+=(U scalar)
	{
		this->value[0] += scalar;
		this->value[1] += scalar;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator+=(mat<2, 2, U, Q> const& m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator-=(U scalar)
	{
		this->value[0] -= scalar;
		this->value[1] -= scalar;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator-=(mat<2, 2, U, Q> const& m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator*=(U scalar)
	{
		this->value[0] *= scalar;
		this->value[1] *= scalar;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator*=(mat<2, 2, U, Q> const& m)
	{
		return (*this = *this * m);
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator/=(U scalar)
	{
		this->value[0] /= scalar;
		this->value[1] /= scalar;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator/=(mat<2, 2, U, Q> const& m)
	{
		return *this *= inverse(m);
	}

	

	template<typename T, qualifier Q>
	inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator++()
	{
		++this->value[0];
		++this->value[1];
		return *this;
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator--()
	{
		--this->value[0];
		--this->value[1];
		return *this;
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 2, T, Q> mat<2, 2, T, Q>::operator++(int)
	{
		mat<2, 2, T, Q> Result(*this);
		++*this;
		return Result;
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 2, T, Q> mat<2, 2, T, Q>::operator--(int)
	{
		mat<2, 2, T, Q> Result(*this);
		--*this;
		return Result;
	}

	

	template<typename T, qualifier Q>
	inline constexpr mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m)
	{
		return m;
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m)
	{
		return mat<2, 2, T, Q>(
			-m[0],
			-m[1]);
	}

	

	template<typename T, qualifier Q>
	inline constexpr mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m, T scalar)
	{
		return mat<2, 2, T, Q>(
			m[0] + scalar,
			m[1] + scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 2, T, Q> operator+(T scalar, mat<2, 2, T, Q> const& m)
	{
		return mat<2, 2, T, Q>(
			m[0] + scalar,
			m[1] + scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
	{
		return mat<2, 2, T, Q>(
			m1[0] + m2[0],
			m1[1] + m2[1]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m, T scalar)
	{
		return mat<2, 2, T, Q>(
			m[0] - scalar,
			m[1] - scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 2, T, Q> operator-(T scalar, mat<2, 2, T, Q> const& m)
	{
		return mat<2, 2, T, Q>(
			scalar - m[0],
			scalar - m[1]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
	{
		return mat<2, 2, T, Q>(
			m1[0] - m2[0],
			m1[1] - m2[1]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 2, T, Q> operator*(mat<2, 2, T, Q> const& m, T scalar)
	{
		return mat<2, 2, T, Q>(
			m[0] * scalar,
			m[1] * scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 2, T, Q> operator*(T scalar, mat<2, 2, T, Q> const& m)
	{
		return mat<2, 2, T, Q>(
			m[0] * scalar,
			m[1] * scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr typename mat<2, 2, T, Q>::col_type operator*
	(
		mat<2, 2, T, Q> const& m,
		typename mat<2, 2, T, Q>::row_type const& v
	)
	{
		return vec<2, T, Q>(
			m[0][0] * v.x + m[1][0] * v.y,
			m[0][1] * v.x + m[1][1] * v.y);
	}

	template<typename T, qualifier Q>
	inline constexpr typename mat<2, 2, T, Q>::row_type operator*
	(
		typename mat<2, 2, T, Q>::col_type const& v,
		mat<2, 2, T, Q> const& m
	)
	{
		return vec<2, T, Q>(
			v.x * m[0][0] + v.y * m[0][1],
			v.x * m[1][0] + v.y * m[1][1]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
	{
		return mat<2, 2, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<3, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
	{
		return mat<3, 2, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
	{
		return mat<4, 2, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1]);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 2, T, Q> operator/(mat<2, 2, T, Q> const& m, T scalar)
	{
		return mat<2, 2, T, Q>(
			m[0] / scalar,
			m[1] / scalar);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 2, T, Q> operator/(T scalar, mat<2, 2, T, Q> const& m)
	{
		return mat<2, 2, T, Q>(
			scalar / m[0],
			scalar / m[1]);
	}

	template<typename T, qualifier Q>
	inline constexpr typename mat<2, 2, T, Q>::col_type operator/(mat<2, 2, T, Q> const& m, typename mat<2, 2, T, Q>::row_type const& v)
	{
		return inverse(m) * v;
	}

	template<typename T, qualifier Q>
	inline constexpr typename mat<2, 2, T, Q>::row_type operator/(typename mat<2, 2, T, Q>::col_type const& v, mat<2, 2, T, Q> const& m)
	{
		return v *  inverse(m);
	}

	template<typename T, qualifier Q>
	inline constexpr mat<2, 2, T, Q> operator/(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
	{
		mat<2, 2, T, Q> m1_copy(m1);
		return m1_copy /= m2;
	}

	

	template<typename T, qualifier Q>
	inline constexpr bool operator==(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]);
	}

	template<typename T, qualifier Q>
	inline constexpr bool operator!=(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]);
	}
} 
#line 177 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x2.hpp"
#line 178 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_mat2x2.hpp"
#line 6 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_double2x2.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<2, 2, double, defaultp>		dmat2x2;

	
	
	
	typedef mat<2, 2, double, defaultp>		dmat2;

	
}
#line 6 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\mat2x2.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_double2x2_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef mat<2, 2, double, lowp>		lowp_dmat2;

	
	
	
	
	typedef mat<2, 2, double, mediump>	mediump_dmat2;

	
	
	
	
	typedef mat<2, 2, double, highp>	highp_dmat2;

	
	
	
	
	typedef mat<2, 2, double, lowp>		lowp_dmat2x2;

	
	
	
	
	typedef mat<2, 2, double, mediump>	mediump_dmat2x2;

	
	
	
	
	typedef mat<2, 2, double, highp>	highp_dmat2x2;

	
}
#line 7 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\mat2x2.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_float2x2.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef mat<2, 2, float, defaultp>		mat2x2;

	
	
	
	typedef mat<2, 2, float, defaultp>		mat2;

	
}
#line 8 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\mat2x2.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_float2x2_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef mat<2, 2, float, lowp>		lowp_mat2;

	
	
	
	
	typedef mat<2, 2, float, mediump>	mediump_mat2;

	
	
	
	
	typedef mat<2, 2, float, highp>		highp_mat2;

	
	
	
	
	typedef mat<2, 2, float, lowp>		lowp_mat2x2;

	
	
	
	
	typedef mat<2, 2, float, mediump>	mediump_mat2x2;

	
	
	
	
	typedef mat<2, 2, float, highp>		highp_mat2x2;

	
}
#line 9 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\mat2x2.hpp"

#line 121 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\glm.hpp"









#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\trigonometric.hpp"


















#pragma once

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 970 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
























































































































































































































#line 1187 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 1189 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
#line 22 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\trigonometric.hpp"


namespace glm
{
	
	

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] constexpr vec<L, T, Q> radians(vec<L, T, Q> const& degrees);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] constexpr vec<L, T, Q> degrees(vec<L, T, Q> const& radians);

	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> sin(vec<L, T, Q> const& angle);

	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> cos(vec<L, T, Q> const& angle);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> tan(vec<L, T, Q> const& angle);

	
	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> asin(vec<L, T, Q> const& x);

	
	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> acos(vec<L, T, Q> const& x);

	
	
	
	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> atan(vec<L, T, Q> const& y, vec<L, T, Q> const& x);

	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> atan(vec<L, T, Q> const& y_over_x);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> sinh(vec<L, T, Q> const& angle);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> cosh(vec<L, T, Q> const& angle);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> tanh(vec<L, T, Q> const& angle);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> asinh(vec<L, T, Q> const& x);

	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> acosh(vec<L, T, Q> const& x);

	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> atanh(vec<L, T, Q> const& x);

	
}

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\func_trigonometric.inl"




namespace glm
{
	
	template<typename genType>
	inline constexpr genType radians(genType degrees)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'radians' only accept floating-point input") ;

		return degrees * static_cast<genType>(0.01745329251994329576923690768489);
	}

	template<length_t L, typename T, qualifier Q>
	inline constexpr vec<L, T, Q> radians(vec<L, T, Q> const& v)
	{
		return detail::functor1<vec, L, T, T, Q>::call(radians, v);
	}

	
	template<typename genType>
	inline constexpr genType degrees(genType radians)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'degrees' only accept floating-point input") ;

		return radians * static_cast<genType>(57.295779513082320876798154814105);
	}

	template<length_t L, typename T, qualifier Q>
	inline constexpr vec<L, T, Q> degrees(vec<L, T, Q> const& v)
	{
		return detail::functor1<vec, L, T, T, Q>::call(degrees, v);
	}

	
	using ::std::sin;

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> sin(vec<L, T, Q> const& v)
	{
		return detail::functor1<vec, L, T, T, Q>::call(sin, v);
	}

	
	using std::cos;

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> cos(vec<L, T, Q> const& v)
	{
		return detail::functor1<vec, L, T, T, Q>::call(cos, v);
	}

	
	using std::tan;

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> tan(vec<L, T, Q> const& v)
	{
		return detail::functor1<vec, L, T, T, Q>::call(tan, v);
	}

	
	using std::asin;

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> asin(vec<L, T, Q> const& v)
	{
		return detail::functor1<vec, L, T, T, Q>::call(asin, v);
	}

	
	using std::acos;

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> acos(vec<L, T, Q> const& v)
	{
		return detail::functor1<vec, L, T, T, Q>::call(acos, v);
	}

	
	template<typename genType>
	inline genType atan(genType y, genType x)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'atan' only accept floating-point input") ;

		return ::std::atan2(y, x);
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> atan(vec<L, T, Q> const& y, vec<L, T, Q> const& x)
	{
		return detail::functor2<vec, L, T, Q>::call(::std::atan2, y, x);
	}

	using std::atan;

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> atan(vec<L, T, Q> const& v)
	{
		return detail::functor1<vec, L, T, T, Q>::call(atan, v);
	}

	
	using std::sinh;

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> sinh(vec<L, T, Q> const& v)
	{
		return detail::functor1<vec, L, T, T, Q>::call(sinh, v);
	}

	
	using std::cosh;

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> cosh(vec<L, T, Q> const& v)
	{
		return detail::functor1<vec, L, T, T, Q>::call(cosh, v);
	}

	
	using std::tanh;

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> tanh(vec<L, T, Q> const& v)
	{
		return detail::functor1<vec, L, T, T, Q>::call(tanh, v);
	}

	

		using std::asinh;








#line 144 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\func_trigonometric.inl"

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> asinh(vec<L, T, Q> const& v)
	{
		return detail::functor1<vec, L, T, T, Q>::call(asinh, v);
	}

	

		using std::acosh;










#line 165 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\func_trigonometric.inl"

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> acosh(vec<L, T, Q> const& v)
	{
		return detail::functor1<vec, L, T, T, Q>::call(acosh, v);
	}

	

		using std::atanh;










#line 186 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\func_trigonometric.inl"

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> atanh(vec<L, T, Q> const& v)
	{
		return detail::functor1<vec, L, T, T, Q>::call(atanh, v);
	}
}



#line 197 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\func_trigonometric.inl"

#line 211 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\trigonometric.hpp"
#line 131 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\glm.hpp"


#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\packing.hpp"















#pragma once





namespace glm
{
	
	

	
	
	
	
	
	
	
	
	
	
	
	[[nodiscard]] uint packUnorm2x16(vec2 const& v);

	
	
	
	
	
	
	
	
	
	
	
	[[nodiscard]] uint packSnorm2x16(vec2 const& v);

	
	
	
	
	
	
	
	
	
	
	
	[[nodiscard]] uint packUnorm4x8(vec4 const& v);

	
	
	
	
	
	
	
	
	
	
	
	[[nodiscard]] uint packSnorm4x8(vec4 const& v);

	
	
	
	
	
	
	
	
	
	
	
	[[nodiscard]] vec2 unpackUnorm2x16(uint p);

	
	
	
	
	
	
	
	
	
	
	
	[[nodiscard]] vec2 unpackSnorm2x16(uint p);

	
	
	
	
	
	
	
	
	
	
	
	[[nodiscard]] vec4 unpackUnorm4x8(uint p);

	
	
	
	
	
	
	
	
	
	
	
	[[nodiscard]] vec4 unpackSnorm4x8(uint p);

	
	
	
	
	
	
	
	
	[[nodiscard]] double packDouble2x32(uvec2 const& v);

	
	
	
	
	
	
	
	[[nodiscard]] uvec2 unpackDouble2x32(double v);

	
	
	
	
	
	
	
	
	[[nodiscard]] uint packHalf2x16(vec2 const& v);

	
	
	
	
	
	
	
	
	[[nodiscard]] vec2 unpackHalf2x16(uint v);

	
}

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\func_packing.inl"




#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_half.hpp"
#pragma once

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 970 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
























































































































































































































#line 1187 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 1189 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
#line 4 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_half.hpp"

namespace glm{
namespace detail
{
	typedef short hdata;

	[[nodiscard]] float toFloat32(hdata value);
	[[nodiscard]] hdata toFloat16(float const& value);

}
}

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_half.inl"
namespace glm{
namespace detail
{
	inline float overflow()
	{
		volatile float f = 1e10;

		for(int i = 0; i < 10; ++i)
			f = f * f; 
		return f;
	}

	union uif32
	{
		inline uif32() :
			i(0)
		{}

		inline uif32(float f_) :
			f(f_)
		{}

		inline uif32(unsigned int i_) :
			i(i_)
		{}

		float f;
		unsigned int i;
	};

	inline float toFloat32(hdata value)
	{
		int s = (value >> 15) & 0x00000001;
		int e = (value >> 10) & 0x0000001f;
		int m =  value        & 0x000003ff;

		if(e == 0)
		{
			if(m == 0)
			{
				
				
				

				detail::uif32 result;
				result.i = static_cast<unsigned int>(s << 31);
				return result.f;
			}
			else
			{
				
				
				

				while(!(m & 0x00000400))
				{
					m <<= 1;
					e -=  1;
				}

				e += 1;
				m &= ~0x00000400;
			}
		}
		else if(e == 31)
		{
			if(m == 0)
			{
				
				
				

				uif32 result;
				result.i = static_cast<unsigned int>((s << 31) | 0x7f800000);
				return result.f;
			}
			else
			{
				
				
				

				uif32 result;
				result.i = static_cast<unsigned int>((s << 31) | 0x7f800000 | (m << 13));
				return result.f;
			}
		}

		
		
		

		e = e + (127 - 15);
		m = m << 13;

		
		
		

		uif32 Result;
		Result.i = static_cast<unsigned int>((s << 31) | (e << 23) | m);
		return Result.f;
	}

	inline hdata toFloat16(float const& f)
	{
		uif32 Entry;
		Entry.f = f;
		int i = static_cast<int>(Entry.i);

		
		
		
		
		
		
		
		
		

		int s =  (i >> 16) & 0x00008000;
		int e = ((i >> 23) & 0x000000ff) - (127 - 15);
		int m =   i        & 0x007fffff;

		
		
		

		if(e <= 0)
		{
			if(e < -10)
			{
				
				
				
				
				
				
				

				return hdata(s);
			}

			
			
			
			
			
			

			m = (m | 0x00800000) >> (1 - e);

			
			
			
			
			
			
			
			

			if(m & 0x00001000)
				m += 0x00002000;

			
			
			

			return hdata(s | (m >> 13));
		}
		else if(e == 0xff - (127 - 15))
		{
			if(m == 0)
			{
				
				
				
				

				return hdata(s | 0x7c00);
			}
			else
			{
				
				
				
				
				
				
				
				

				m >>= 13;

				return hdata(s | 0x7c00 | m | (m == 0));
			}
		}
		else
		{
			
			
			
			

			
			
			

			if(m &  0x00001000)
			{
				m += 0x00002000;

				if(m & 0x00800000)
				{
					m =  0;     
					e += 1;     
				}
			}

			
			
			

			if (e > 30)
			{
				overflow();        

				return hdata(s | 0x7c00);
				
			}   

			
			
			

			return hdata(s | (e << 10) | (m >> 13));
		}
	}

}
}
#line 17 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_half.hpp"
#line 6 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\func_packing.inl"

namespace glm
{
	inline uint packUnorm2x16(vec2 const& v)
	{
		union
		{
			unsigned short in[2];
			uint out;
		} u;

		vec<2, unsigned short, defaultp> result(round(clamp(v, 0.0f, 1.0f) * 65535.0f));

		u.in[0] = result[0];
		u.in[1] = result[1];

		return u.out;
	}

	inline vec2 unpackUnorm2x16(uint p)
	{
		union
		{
			uint in;
			unsigned short out[2];
		} u;

		u.in = p;

		return vec2(u.out[0], u.out[1]) * 1.5259021896696421759365224689097e-5f;
	}

	inline uint packSnorm2x16(vec2 const& v)
	{
		union
		{
			signed short in[2];
			uint out;
		} u;
 
		vec<2, short, defaultp> result(round(clamp(v, -1.0f, 1.0f) * 32767.0f));

		u.in[0] = result[0];
		u.in[1] = result[1];

		return u.out;
	}

	inline vec2 unpackSnorm2x16(uint p)
	{
		union
		{
			uint in;
			signed short out[2];
		} u;

		u.in = p;

		return clamp(vec2(u.out[0], u.out[1]) * 3.0518509475997192297128208258309e-5f, -1.0f, 1.0f);
	}

	inline uint packUnorm4x8(vec4 const& v)
	{
		union
		{
			unsigned char in[4];
			uint out;
		} u;

		vec<4, unsigned char, defaultp> result(round(clamp(v, 0.0f, 1.0f) * 255.0f));

		u.in[0] = result[0];
		u.in[1] = result[1];
		u.in[2] = result[2];
		u.in[3] = result[3];

		return u.out;
	}

	inline vec4 unpackUnorm4x8(uint p)
	{
		union
		{
			uint in;
			unsigned char out[4];
		} u;

		u.in = p;

		return vec4(u.out[0], u.out[1], u.out[2], u.out[3]) * 0.0039215686274509803921568627451f;
	}

	inline uint packSnorm4x8(vec4 const& v)
	{
		union
		{
			signed char in[4];
			uint out;
		} u;

		vec<4, signed char, defaultp> result(round(clamp(v, -1.0f, 1.0f) * 127.0f));

		u.in[0] = result[0];
		u.in[1] = result[1];
		u.in[2] = result[2];
		u.in[3] = result[3];

		return u.out;
	}

	inline glm::vec4 unpackSnorm4x8(uint p)
	{
		union
		{
			uint in;
			signed char out[4];
		} u;

		u.in = p;

		return clamp(vec4(u.out[0], u.out[1], u.out[2], u.out[3]) * 0.0078740157480315f, -1.0f, 1.0f);
	}

	inline double packDouble2x32(uvec2 const& v)
	{
		union
		{
			uint   in[2];
			double out;
		} u;

		u.in[0] = v[0];
		u.in[1] = v[1];

		return u.out;
	}

	inline uvec2 unpackDouble2x32(double v)
	{
		union
		{
			double in;
			uint   out[2];
		} u;

		u.in = v;

		return uvec2(u.out[0], u.out[1]);
	}

	inline uint packHalf2x16(vec2 const& v)
	{
		union
		{
			signed short in[2];
			uint out;
		} u;

		u.in[0] = detail::toFloat16(v.x);
		u.in[1] = detail::toFloat16(v.y);

		return u.out;
	}

	inline vec2 unpackHalf2x16(uint v)
	{
		union
		{
			uint in;
			signed short out[2];
		} u;

		u.in = v;

		return vec2(
			detail::toFloat32(u.out[0]),
			detail::toFloat32(u.out[1]));
	}
}



#line 189 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\func_packing.inl"

#line 174 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\packing.hpp"
#line 134 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\glm.hpp"



#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\integer.hpp"
















#pragma once





namespace glm
{
	
	

	
	
	
	
	
	
	
	
	template<length_t L, qualifier Q>
	[[nodiscard]] vec<L, uint, Q> uaddCarry(
		vec<L, uint, Q> const& x,
		vec<L, uint, Q> const& y,
		vec<L, uint, Q> & carry);

	
	
	
	
	
	
	
	
	template<length_t L, qualifier Q>
	[[nodiscard]] vec<L, uint, Q> usubBorrow(
		vec<L, uint, Q> const& x,
		vec<L, uint, Q> const& y,
		vec<L, uint, Q> & borrow);

	
	
	
	
	
	
	
	
	template<length_t L, qualifier Q>
	 void umulExtended(
		vec<L, uint, Q> const& x,
		vec<L, uint, Q> const& y,
		vec<L, uint, Q> & msb,
		vec<L, uint, Q> & lsb);

	
	
	
	
	
	
	
	
	template<length_t L, qualifier Q>
	 void imulExtended(
		vec<L, int, Q> const& x,
		vec<L, int, Q> const& y,
		vec<L, int, Q> & msb,
		vec<L, int, Q> & lsb);

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> bitfieldExtract(
		vec<L, T, Q> const& Value,
		int Offset,
		int Bits);

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> bitfieldInsert(
		vec<L, T, Q> const& Base,
		vec<L, T, Q> const& Insert,
		int Offset,
		int Bits);

	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> bitfieldReverse(vec<L, T, Q> const& v);

	
	
	
	
	
	
	template<typename genType>
	[[nodiscard]] int bitCount(genType v);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, int, Q> bitCount(vec<L, T, Q> const& v);

	
	
	
	
	
	
	
	
	template<typename genIUType>
	[[nodiscard]] int findLSB(genIUType x);

	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, int, Q> findLSB(vec<L, T, Q> const& v);

	
	
	
	
	
	
	
	
	
	template<typename genIUType>
	[[nodiscard]] int findMSB(genIUType x);

	
	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, int, Q> findMSB(vec<L, T, Q> const& v);

	
}

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\func_integer.inl"




#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin.h"












#pragma once








#pragma warning(push)
#pragma warning(disable: 4514 4820 )


#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\setjmp.h"







#pragma once












#pragma warning(push)
#pragma warning(disable: 4514 4820 )

__pragma(pack(push, 8)) extern "C" {
























#line 50 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\setjmp.h"

    typedef struct __declspec(align(16)) _SETJMP_FLOAT128
    {
        unsigned __int64 Part[2];
    } SETJMP_FLOAT128;

    
    typedef SETJMP_FLOAT128 _JBTYPE;

    typedef struct _JUMP_BUFFER
    {
        unsigned __int64 Frame;
        unsigned __int64 Rbx;
        unsigned __int64 Rsp;
        unsigned __int64 Rbp;
        unsigned __int64 Rsi;
        unsigned __int64 Rdi;
        unsigned __int64 R12;
        unsigned __int64 R13;
        unsigned __int64 R14;
        unsigned __int64 R15;
        unsigned __int64 Rip;
        unsigned long MxCsr;
        unsigned short FpCsr;
        unsigned short Spare;

        SETJMP_FLOAT128 Xmm6;
        SETJMP_FLOAT128 Xmm7;
        SETJMP_FLOAT128 Xmm8;
        SETJMP_FLOAT128 Xmm9;
        SETJMP_FLOAT128 Xmm10;
        SETJMP_FLOAT128 Xmm11;
        SETJMP_FLOAT128 Xmm12;
        SETJMP_FLOAT128 Xmm13;
        SETJMP_FLOAT128 Xmm14;
        SETJMP_FLOAT128 Xmm15;
    } _JUMP_BUFFER;






















































#line 142 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\setjmp.h"





    
    typedef _JBTYPE jmp_buf[16 ];
#line 150 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\setjmp.h"




    
#line 156 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\setjmp.h"




int __cdecl _setjmp (
     jmp_buf _Buf
    );


    __declspec(noreturn) void __cdecl longjmp(
         jmp_buf _Buf,
         int     _Value
        ) noexcept(false);





#line 175 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\setjmp.h"


} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 27 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin.h"



#line 31 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin.h"



    
        #pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\immintrin.h"











#pragma once



#line 17 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\immintrin.h"



#line 21 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\immintrin.h"







#line 29 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\immintrin.h"

#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\wmmintrin.h"












#pragma once



#line 18 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\wmmintrin.h"



#line 22 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\wmmintrin.h"







#line 30 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\wmmintrin.h"

#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\nmmintrin.h"













#pragma once



#line 19 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\nmmintrin.h"



#line 23 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\nmmintrin.h"







#line 31 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\nmmintrin.h"

#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\smmintrin.h"













#pragma once



#line 19 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\smmintrin.h"



#line 23 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\smmintrin.h"







#line 31 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\smmintrin.h"

#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\tmmintrin.h"






#pragma once



#line 12 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\tmmintrin.h"



#line 16 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\tmmintrin.h"







#line 24 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\tmmintrin.h"

#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\pmmintrin.h"












#pragma once



#line 18 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\pmmintrin.h"



#line 22 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\pmmintrin.h"







#line 30 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\pmmintrin.h"




#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\emmintrin.h"
















#pragma once



#line 22 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\emmintrin.h"



#line 26 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\emmintrin.h"







#line 34 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\emmintrin.h"




#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmmintrin.h"























#pragma once



#line 29 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmmintrin.h"



#line 33 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmmintrin.h"







#line 41 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmmintrin.h"





#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\mmintrin.h"










#pragma once






#line 19 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\mmintrin.h"



#line 23 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\mmintrin.h"



#line 27 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\mmintrin.h"


extern "C" {  


#line 33 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\mmintrin.h"

typedef union __declspec(intrin_type) __declspec(align(8)) __m64
{
    unsigned __int64    m64_u64;
    float               m64_f32[2];
    __int8              m64_i8[8];
    __int16             m64_i16[4];
    __int32             m64_i32[2];
    __int64             m64_i64;
    unsigned __int8     m64_u8[8];
    unsigned __int16    m64_u16[4];
    unsigned __int32    m64_u32[2];
} __m64;









































































































































#line 184 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\mmintrin.h"


};  
#line 188 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\mmintrin.h"

#line 190 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\mmintrin.h"
#line 191 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\mmintrin.h"
#line 192 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\mmintrin.h"
#pragma external_header(pop)
#line 47 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmmintrin.h"
#line 48 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmmintrin.h"

















typedef union __declspec(intrin_type) __declspec(align(16)) __m128 {
     float               m128_f32[4];
     unsigned __int64    m128_u64[2];
     __int8              m128_i8[16];
     __int16             m128_i16[8];
     __int32             m128_i32[4];
     __int64             m128_i64[2];
     unsigned __int8     m128_u8[16];
     unsigned __int16    m128_u16[8];
     unsigned __int32    m128_u32[4];
 } __m128;


 
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\malloc.h"







#pragma once






#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {





    


#line 29 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\malloc.h"













typedef struct _heapinfo
{
    int* _pentry;
    size_t _size;
    int _useflag;
} _HEAPINFO;






 
void* __cdecl _alloca( size_t _Size);





    __declspec(dllimport) intptr_t __cdecl _get_heap_handle(void);

    
    __declspec(dllimport) int __cdecl _heapmin(void);

    
        __declspec(dllimport) int __cdecl _heapwalk( _HEAPINFO* _EntryInfo);
    #line 69 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\malloc.h"

    
         __declspec(dllimport) int __cdecl _heapchk(void);
    #line 73 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\malloc.h"

    __declspec(dllimport) int __cdecl _resetstkoflw(void);

    
    
    

    
        
    

#line 85 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\malloc.h"

    static_assert((sizeof(unsigned int) <= 16), "sizeof(unsigned int) <= _ALLOCA_S_MARKER_SIZE") ;


    #pragma warning(push)
    #pragma warning(disable: 6540) 
                                   

    __inline void* _MarkAllocaS(  void* _Ptr, unsigned int _Marker)
    {
        if (_Ptr)
        {
            *((unsigned int*)_Ptr) = _Marker;
            _Ptr = (char*)_Ptr + 16 ;
        }
        return _Ptr;
    }

    __inline size_t _MallocaComputeSize(size_t _Size)
    {
        size_t _MarkedSize = _Size + 16 ;
        return _MarkedSize > _Size ? _MarkedSize : 0;
    }

    #pragma warning(pop)

#line 112 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\malloc.h"

















    
    







#line 139 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\malloc.h"




#line 144 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\malloc.h"
#line 145 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\malloc.h"

    

    #pragma warning(push)
    #pragma warning(disable: 6014) 
    __inline void __cdecl _freea(  void* _Memory)
    {
        unsigned int _Marker;
        if (_Memory)
        {
            _Memory = (char*)_Memory - 16 ;
            _Marker = *(unsigned int*)_Memory;
            if (_Marker == 0xDDDD )
            {
                free(_Memory);
            }
            
            else if (_Marker != 0xCCCC )
            {
                ((void)0) ;
            }
            #line 167 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\malloc.h"
        }
    }
    #pragma warning(pop)

#line 172 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\malloc.h"




    
#line 178 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\malloc.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#line 185 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\malloc.h"
#pragma external_header(pop)
#line 80 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmmintrin.h"
#line 81 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmmintrin.h"
#line 82 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmmintrin.h"

  
  
  
  
  
  
  
  
  
  




  
  
  
  
  
  
  
  
  
  















 





 



#line 133 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmmintrin.h"





 


 














































  
  
  


extern "C" {  
   
#line 196 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmmintrin.h"





extern __m128 _mm_add_ss(__m128 _A, __m128 _B);
extern __m128 _mm_add_ps(__m128 _A, __m128 _B);
extern __m128 _mm_sub_ss(__m128 _A, __m128 _B);
extern __m128 _mm_sub_ps(__m128 _A, __m128 _B);
extern __m128 _mm_mul_ss(__m128 _A, __m128 _B);
extern __m128 _mm_mul_ps(__m128 _A, __m128 _B);
extern __m128 _mm_div_ss(__m128 _A, __m128 _B);
extern __m128 _mm_div_ps(__m128 _A, __m128 _B);
extern __m128 _mm_sqrt_ss(__m128 _A);
extern __m128 _mm_sqrt_ps(__m128 _A);
extern __m128 _mm_rcp_ss(__m128 _A);
extern __m128 _mm_rcp_ps(__m128 _A);
extern __m128 _mm_rsqrt_ss(__m128 _A);
extern __m128 _mm_rsqrt_ps(__m128 _A);
extern __m128 _mm_min_ss(__m128 _A, __m128 _B);
extern __m128 _mm_min_ps(__m128 _A, __m128 _B);
extern __m128 _mm_max_ss(__m128 _A, __m128 _B);
extern __m128 _mm_max_ps(__m128 _A, __m128 _B);





extern __m128 _mm_and_ps(__m128 _A, __m128 _B);
extern __m128 _mm_andnot_ps(__m128 _A, __m128 _B);
extern __m128 _mm_or_ps(__m128 _A, __m128 _B);
extern __m128 _mm_xor_ps(__m128 _A, __m128 _B);





extern __m128 _mm_cmpeq_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpeq_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmplt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmplt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmple_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmple_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpgt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpgt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpge_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpge_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpneq_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpneq_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnlt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnlt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnle_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnle_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpngt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpngt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnge_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnge_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpord_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpord_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpunord_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpunord_ps(__m128 _A, __m128 _B);
extern int _mm_comieq_ss(__m128 _A, __m128 _B);
extern int _mm_comilt_ss(__m128 _A, __m128 _B);
extern int _mm_comile_ss(__m128 _A, __m128 _B);
extern int _mm_comigt_ss(__m128 _A, __m128 _B);
extern int _mm_comige_ss(__m128 _A, __m128 _B);
extern int _mm_comineq_ss(__m128 _A, __m128 _B);
extern int _mm_ucomieq_ss(__m128 _A, __m128 _B);
extern int _mm_ucomilt_ss(__m128 _A, __m128 _B);
extern int _mm_ucomile_ss(__m128 _A, __m128 _B);
extern int _mm_ucomigt_ss(__m128 _A, __m128 _B);
extern int _mm_ucomige_ss(__m128 _A, __m128 _B);
extern int _mm_ucomineq_ss(__m128 _A, __m128 _B);





extern int _mm_cvt_ss2si(__m128 _A);
extern int _mm_cvtt_ss2si(__m128 _A);
extern __m128 _mm_cvt_si2ss(__m128, int);
extern float _mm_cvtss_f32(__m128 _A);








#line 287 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmmintrin.h"





extern __int64 _mm_cvtss_si64(__m128 _A);
extern __int64 _mm_cvttss_si64(__m128 _A);
extern __m128  _mm_cvtsi64_ss(__m128 _A, __int64 _B);
#line 296 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmmintrin.h"





extern __m128 _mm_shuffle_ps(__m128 _A, __m128 _B, unsigned int _Imm8);
extern __m128 _mm_unpackhi_ps(__m128 _A, __m128 _B);
extern __m128 _mm_unpacklo_ps(__m128 _A, __m128 _B);
extern __m128 _mm_loadh_pi(__m128, __m64 const*);
extern __m128 _mm_movehl_ps(__m128, __m128);
extern __m128 _mm_movelh_ps(__m128, __m128);
extern void _mm_storeh_pi(__m64 *, __m128);
extern __m128 _mm_loadl_pi(__m128, __m64 const*);
extern void _mm_storel_pi(__m64 *, __m128);
extern int _mm_movemask_ps(__m128 _A);



















#line 331 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmmintrin.h"





extern __m128 _mm_set_ss(float _A);
extern __m128 _mm_set_ps1(float _A);
extern __m128 _mm_set_ps(float _A, float _B, float _C, float _D);
extern __m128 _mm_setr_ps(float _A, float _B, float _C, float _D);
extern __m128 _mm_setzero_ps(void);
extern __m128 _mm_load_ss(float const*_A);
extern __m128 _mm_load_ps1(float const*_A);
extern __m128 _mm_load_ps(float const*_A);
extern __m128 _mm_loadr_ps(float const*_A);
extern __m128 _mm_loadu_ps(float const*_A);
extern void _mm_store_ss(float *_V, __m128 _A);
extern void _mm_store_ps1(float *_V, __m128 _A);
extern void _mm_store_ps(float *_V, __m128 _A);
extern void _mm_storer_ps(float *_V, __m128 _A);
extern void _mm_storeu_ps(float *_V, __m128 _A);
extern void _mm_prefetch(char const*_A, int _Sel);


#line 355 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmmintrin.h"
extern void _mm_stream_ps(float *, __m128);
extern __m128 _mm_move_ss(__m128 _A, __m128 _B);

extern void _mm_sfence(void);
extern unsigned int _mm_getcsr(void);
extern void _mm_setcsr(unsigned int);






 

















#line 386 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmmintrin.h"







  
  
  





















































































































#line 514 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmmintrin.h"



};  
#line 519 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmmintrin.h"

#line 521 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmmintrin.h"
#line 522 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmmintrin.h"
#line 523 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\xmmintrin.h"
#pragma external_header(pop)
#line 39 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\emmintrin.h"

typedef union __declspec(intrin_type) __declspec(align(16)) __m128i {
    __int8              m128i_i8[16];
    __int16             m128i_i16[8];
    __int32             m128i_i32[4];
    __int64             m128i_i64[2];
    unsigned __int8     m128i_u8[16];
    unsigned __int16    m128i_u16[8];
    unsigned __int32    m128i_u32[4];
    unsigned __int64    m128i_u64[2];
} __m128i;

typedef struct __declspec(intrin_type) __declspec(align(16)) __m128d {
    double              m128d_f64[2];
} __m128d;






  
  
  


extern "C" {  
   
#line 68 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\emmintrin.h"





extern __m128d _mm_add_sd(__m128d _A, __m128d _B);
extern __m128d _mm_add_pd(__m128d _A, __m128d _B);
extern __m128d _mm_sub_sd(__m128d _A, __m128d _B);
extern __m128d _mm_sub_pd(__m128d _A, __m128d _B);
extern __m128d _mm_mul_sd(__m128d _A, __m128d _B);
extern __m128d _mm_mul_pd(__m128d _A, __m128d _B);
extern __m128d _mm_sqrt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_sqrt_pd(__m128d _A);
extern __m128d _mm_div_sd(__m128d _A, __m128d _B);
extern __m128d _mm_div_pd(__m128d _A, __m128d _B);
extern __m128d _mm_min_sd(__m128d _A, __m128d _B);
extern __m128d _mm_min_pd(__m128d _A, __m128d _B);
extern __m128d _mm_max_sd(__m128d _A, __m128d _B);
extern __m128d _mm_max_pd(__m128d _A, __m128d _B);





extern __m128d _mm_and_pd(__m128d _A, __m128d _B);
extern __m128d _mm_andnot_pd(__m128d _A, __m128d _B);
extern __m128d _mm_or_pd(__m128d _A, __m128d _B);
extern __m128d _mm_xor_pd(__m128d _A, __m128d _B);





extern __m128d _mm_cmpeq_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpeq_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmplt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmplt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmple_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmple_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpgt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpgt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpge_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpge_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpneq_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpneq_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnlt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnlt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnle_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnle_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpngt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpngt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnge_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnge_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpord_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpord_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpunord_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpunord_sd(__m128d _A, __m128d _B);
extern int _mm_comieq_sd(__m128d _A, __m128d _B);
extern int _mm_comilt_sd(__m128d _A, __m128d _B);
extern int _mm_comile_sd(__m128d _A, __m128d _B);
extern int _mm_comigt_sd(__m128d _A, __m128d _B);
extern int _mm_comige_sd(__m128d _A, __m128d _B);
extern int _mm_comineq_sd(__m128d _A, __m128d _B);
extern int _mm_ucomieq_sd(__m128d _A, __m128d _B);
extern int _mm_ucomilt_sd(__m128d _A, __m128d _B);
extern int _mm_ucomile_sd(__m128d _A, __m128d _B);
extern int _mm_ucomigt_sd(__m128d _A, __m128d _B);
extern int _mm_ucomige_sd(__m128d _A, __m128d _B);
extern int _mm_ucomineq_sd(__m128d _A, __m128d _B);





extern __m128d _mm_cvtepi32_pd(__m128i _A);
extern __m128i _mm_cvtpd_epi32(__m128d _A);
extern __m128i _mm_cvttpd_epi32(__m128d _A);
extern __m128 _mm_cvtepi32_ps(__m128i _A);
extern __m128i _mm_cvtps_epi32(__m128 _A);
extern __m128i _mm_cvttps_epi32(__m128 _A);
extern __m128 _mm_cvtpd_ps(__m128d _A);
extern __m128d _mm_cvtps_pd(__m128 _A);
extern __m128 _mm_cvtsd_ss(__m128 _A, __m128d _B);
extern __m128d _mm_cvtss_sd(__m128d _A, __m128 _B);

extern int _mm_cvtsd_si32(__m128d _A);
extern int _mm_cvttsd_si32(__m128d _A);
extern __m128d _mm_cvtsi32_sd(__m128d _A, int _B);





#line 162 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\emmintrin.h"





extern __m128d _mm_unpackhi_pd(__m128d _A, __m128d _B);
extern __m128d _mm_unpacklo_pd(__m128d _A, __m128d _B);
extern int _mm_movemask_pd(__m128d _A);
extern __m128d _mm_shuffle_pd(__m128d _A, __m128d _B, int _I);





extern __m128d _mm_load_pd(double const*_Dp);
extern __m128d _mm_load1_pd(double const*_Dp);
extern __m128d _mm_loadr_pd(double const*_Dp);
extern __m128d _mm_loadu_pd(double const*_Dp);
extern __m128d _mm_load_sd(double const*_Dp);
extern __m128d _mm_loadh_pd(__m128d _A, double const*_Dp);
extern __m128d _mm_loadl_pd(__m128d _A, double const*_Dp);





extern __m128d _mm_set_sd(double _W);
extern __m128d _mm_set1_pd(double _A);
extern __m128d _mm_set_pd(double _Z, double _Y);
extern __m128d _mm_setr_pd(double _Y, double _Z);
extern __m128d _mm_setzero_pd(void);
extern __m128d _mm_move_sd(__m128d _A, __m128d _B);





extern void _mm_store_sd(double *_Dp, __m128d _A);
extern void _mm_store1_pd(double *_Dp, __m128d _A);
extern void _mm_store_pd(double *_Dp, __m128d _A);
extern void _mm_storeu_pd(double *_Dp, __m128d _A);
extern void _mm_storer_pd(double *_Dp, __m128d _A);
extern void _mm_storeh_pd(double *_Dp, __m128d _A);
extern void _mm_storel_pd(double *_Dp, __m128d _A);

 








extern __m128i _mm_add_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_add_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_add_epi32(__m128i _A, __m128i _B);


#line 222 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\emmintrin.h"
extern __m128i _mm_add_epi64(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epu16(__m128i _A, __m128i _B);
extern __m128i _mm_avg_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_avg_epu16(__m128i _A, __m128i _B);
extern __m128i _mm_madd_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_max_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_max_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_min_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_min_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_mulhi_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_mulhi_epu16(__m128i _A, __m128i _B);
extern __m128i _mm_mullo_epi16(__m128i _A, __m128i _B);


#line 240 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\emmintrin.h"
extern __m128i _mm_mul_epu32(__m128i _A, __m128i _B);
extern __m128i _mm_sad_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_sub_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_sub_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_sub_epi32(__m128i _A, __m128i _B);


#line 248 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\emmintrin.h"
extern __m128i _mm_sub_epi64(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epu16(__m128i _A, __m128i _B);





extern __m128i _mm_and_si128(__m128i _A, __m128i _B);
extern __m128i _mm_andnot_si128(__m128i _A, __m128i _B);
extern __m128i _mm_or_si128(__m128i _A, __m128i _B);
extern __m128i _mm_xor_si128(__m128i _A, __m128i _B);





extern __m128i _mm_slli_si128(__m128i _A, int _Imm);

extern __m128i _mm_slli_epi16(__m128i _A, int _Count);
extern __m128i _mm_sll_epi16(__m128i _A, __m128i _Count);
extern __m128i _mm_slli_epi32(__m128i _A, int _Count);
extern __m128i _mm_sll_epi32(__m128i _A, __m128i _Count);
extern __m128i _mm_slli_epi64(__m128i _A, int _Count);
extern __m128i _mm_sll_epi64(__m128i _A, __m128i _Count);
extern __m128i _mm_srai_epi16(__m128i _A, int _Count);
extern __m128i _mm_sra_epi16(__m128i _A, __m128i _Count);
extern __m128i _mm_srai_epi32(__m128i _A, int _Count);
extern __m128i _mm_sra_epi32(__m128i _A, __m128i _Count);
extern __m128i _mm_srli_si128(__m128i _A, int _Imm);

extern __m128i _mm_srli_epi16(__m128i _A, int _Count);
extern __m128i _mm_srl_epi16(__m128i _A, __m128i _Count);
extern __m128i _mm_srli_epi32(__m128i _A, int _Count);
extern __m128i _mm_srl_epi32(__m128i _A, __m128i _Count);
extern __m128i _mm_srli_epi64(__m128i _A, int _Count);
extern __m128i _mm_srl_epi64(__m128i _A, __m128i _Count);





extern __m128i _mm_cmpeq_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_cmpeq_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_cmpeq_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_cmpgt_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_cmpgt_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_cmpgt_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_cmplt_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_cmplt_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_cmplt_epi32(__m128i _A, __m128i _B);





extern __m128i _mm_cvtsi32_si128(int _A);
extern int _mm_cvtsi128_si32(__m128i _A);





extern __m128i _mm_packs_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_packs_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_packus_epi16(__m128i _A, __m128i _B);
extern int _mm_extract_epi16(__m128i _A, int _Imm);
extern __m128i _mm_insert_epi16(__m128i _A, int _B, int _Imm);
extern int _mm_movemask_epi8(__m128i _A);
extern __m128i _mm_shuffle_epi32(__m128i _A, int _Imm);
extern __m128i _mm_shufflehi_epi16(__m128i _A, int _Imm);
extern __m128i _mm_shufflelo_epi16(__m128i _A, int _Imm);
extern __m128i _mm_unpackhi_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_unpackhi_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_unpackhi_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_unpackhi_epi64(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi64(__m128i _A, __m128i _B);





extern __m128i _mm_load_si128(__m128i const*_P);
extern __m128i _mm_loadu_si128(__m128i const*_P);
extern __m128i _mm_loadl_epi64(__m128i const*_P);







#line 346 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\emmintrin.h"
extern __m128i _mm_set_epi64x(__int64 _I1,__int64 _I0);
extern __m128i _mm_set_epi32(int _I3, int _I2, int _I1, int _I0);
extern __m128i _mm_set_epi16(short _W7, short _W6, short _W5, short _W4,
                             short _W3, short _W2, short _W1, short _W0);
extern __m128i _mm_set_epi8(char _B15, char _B14, char _B13, char _B12,
                            char _B11, char _B10, char _B9, char _B8,
                            char _B7, char _B6, char _B5, char _B4,
                            char _B3, char _B2, char _B1, char _B0);


#line 357 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\emmintrin.h"
extern __m128i _mm_set1_epi64x(__int64 i);
extern __m128i _mm_set1_epi32(int _I);
extern __m128i _mm_set1_epi16(short _W);
extern __m128i _mm_set1_epi8(char _B);
extern __m128i _mm_setl_epi64(__m128i _Q);


#line 365 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\emmintrin.h"
extern __m128i _mm_setr_epi32(int _I0, int _I1, int _I2, int _I3);
extern __m128i _mm_setr_epi16(short _W0, short _W1, short _W2, short _W3,
                              short _W4, short _W5, short _W6, short _W7);
extern __m128i _mm_setr_epi8(char _B15, char _B14, char _B13, char _B12,
                             char _B11, char _B10, char _B9, char _B8,
                             char _B7, char _B6, char _B5, char _B4,
                             char _B3, char _B2, char _B1, char _B0);
extern __m128i _mm_setzero_si128(void);





extern void _mm_store_si128(__m128i *_P, __m128i _B);
extern void _mm_storeu_si128(__m128i *_P, __m128i _B);
extern void _mm_storel_epi64(__m128i *_P, __m128i _Q);
extern void _mm_maskmoveu_si128(__m128i _D, __m128i _N, char *_P);





extern __m128i _mm_move_epi64(__m128i _Q);



#line 392 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\emmintrin.h"





extern void _mm_stream_pd(double *_Dp, __m128d _A);
extern void _mm_stream_si128(__m128i *_P, __m128i _A);
extern void _mm_clflush(void const*_P);
extern void _mm_lfence(void);
extern void _mm_mfence(void);
extern void _mm_stream_si32(int *_P, int _I);
extern void _mm_pause(void);





extern double _mm_cvtsd_f64(__m128d _A);







extern __m128  _mm_castpd_ps(__m128d);
extern __m128i _mm_castpd_si128(__m128d);
extern __m128d _mm_castps_pd(__m128);
extern __m128i _mm_castps_si128(__m128);
extern __m128  _mm_castsi128_ps(__m128i);
extern __m128d _mm_castsi128_pd(__m128i);






extern __int64 _mm_cvtsd_si64(__m128d);
extern __int64 _mm_cvttsd_si64(__m128d);
extern __m128d _mm_cvtsi64_sd(__m128d, __int64);
extern __m128i _mm_cvtsi64_si128(__int64);
extern __int64 _mm_cvtsi128_si64(__m128i);
 

#line 437 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\emmintrin.h"


};  
#line 441 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\emmintrin.h"

#line 443 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\emmintrin.h"
#line 444 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\emmintrin.h"
#line 445 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\emmintrin.h"
#pragma external_header(pop)
#line 35 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\pmmintrin.h"

  
  
  














  
  
  


extern "C" {  
   
#line 61 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\pmmintrin.h"





extern __m128 _mm_addsub_ps(__m128  , __m128  );
extern __m128 _mm_hadd_ps(__m128  , __m128  );
extern __m128 _mm_hsub_ps(__m128  , __m128  );
extern __m128 _mm_movehdup_ps(__m128  );
extern __m128 _mm_moveldup_ps(__m128  );





extern __m128d _mm_addsub_pd(__m128d  , __m128d  );
extern __m128d _mm_hadd_pd(__m128d  , __m128d  );
extern __m128d _mm_hsub_pd(__m128d  , __m128d  );
extern __m128d _mm_loaddup_pd(double const *  );
extern __m128d _mm_movedup_pd(__m128d  );




extern __m128i _mm_lddqu_si128(__m128i const *  );







extern void _mm_monitor(void const *  , unsigned  , unsigned  );




extern void _mm_mwait(unsigned  , unsigned  );


};  
#line 103 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\pmmintrin.h"

#line 105 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\pmmintrin.h"
#line 106 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\pmmintrin.h"
#line 107 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\pmmintrin.h"
#pragma external_header(pop)
#line 26 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\tmmintrin.h"









extern "C" {
#line 37 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\tmmintrin.h"

    
    
    
    
    
    

    extern __m128i _mm_hadd_epi16 (__m128i, __m128i);
    extern __m128i _mm_hadd_epi32 (__m128i, __m128i);
    extern __m128i _mm_hadds_epi16 (__m128i, __m128i);





#line 54 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\tmmintrin.h"

    
    
    
    
    
    
    

    extern __m128i _mm_hsub_epi16 (__m128i, __m128i);
    extern __m128i _mm_hsub_epi32 (__m128i, __m128i);
    extern __m128i _mm_hsubs_epi16 (__m128i, __m128i);





#line 72 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\tmmintrin.h"

    
    
    
    
    
    
    
    

    extern __m128i _mm_maddubs_epi16 (__m128i, __m128i);



#line 87 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\tmmintrin.h"

    
    

    extern __m128i _mm_mulhrs_epi16 (__m128i, __m128i);



#line 96 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\tmmintrin.h"

    
    

    extern __m128i _mm_shuffle_epi8 (__m128i, __m128i);



#line 105 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\tmmintrin.h"

    
    

    extern __m128i _mm_sign_epi8 (__m128i, __m128i);
    extern __m128i _mm_sign_epi16 (__m128i, __m128i);
    extern __m128i _mm_sign_epi32 (__m128i, __m128i);





#line 118 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\tmmintrin.h"

    
    

    extern __m128i _mm_alignr_epi8 (__m128i, __m128i, int);



#line 127 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\tmmintrin.h"

    
    

    extern __m128i _mm_abs_epi8 (__m128i);
    extern __m128i _mm_abs_epi16 (__m128i);
    extern __m128i _mm_abs_epi32 (__m128i);





#line 140 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\tmmintrin.h"


};
#line 144 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\tmmintrin.h"

#line 146 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\tmmintrin.h"
#line 147 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\tmmintrin.h"
#line 148 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\tmmintrin.h"
#pragma external_header(pop)
#line 33 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\smmintrin.h"


















































extern "C" {
#line 85 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\smmintrin.h"

        
        

        extern __m128i _mm_blend_epi16 (__m128i, __m128i, const int  );
        extern __m128i _mm_blendv_epi8 (__m128i, __m128i, __m128i mask);

        
        

        extern __m128  _mm_blend_ps (__m128, __m128, const int  );
        extern __m128  _mm_blendv_ps(__m128, __m128, __m128  );

        
        

        extern __m128d _mm_blend_pd (__m128d, __m128d, const int  );
        extern __m128d _mm_blendv_pd(__m128d, __m128d, __m128d  );

        
        

        extern __m128  _mm_dp_ps(__m128, __m128, const int  );
        extern __m128d _mm_dp_pd(__m128d, __m128d, const int  );

        
        

        extern __m128i _mm_cmpeq_epi64(__m128i, __m128i);

        

        extern __m128i _mm_min_epi8 (__m128i, __m128i);
        extern __m128i _mm_max_epi8 (__m128i, __m128i);

        extern __m128i _mm_min_epu16(__m128i, __m128i);
        extern __m128i _mm_max_epu16(__m128i, __m128i);

        extern __m128i _mm_min_epi32(__m128i, __m128i);
        extern __m128i _mm_max_epi32(__m128i, __m128i);
        extern __m128i _mm_min_epu32(__m128i, __m128i);
        extern __m128i _mm_max_epu32(__m128i, __m128i);

        
        

        extern __m128i _mm_mullo_epi32(__m128i, __m128i);

        
        

        extern __m128i _mm_mul_epi32(__m128i, __m128i);

        
        

        extern int _mm_testz_si128(__m128i  , __m128i  );

        
        

        extern int _mm_testc_si128(__m128i  , __m128i  );

        
        
        

        extern int _mm_testnzc_si128(__m128i  , __m128i  );

        
        
        
        
        

        extern __m128 _mm_insert_ps(__m128  , __m128  , const int  );

        




        
        

        extern int _mm_extract_ps(__m128  , const int  );

        
        




        
        





        
        

        extern __m128i _mm_insert_epi8 (__m128i  , int  , const int  );
        extern __m128i _mm_insert_epi32(__m128i  , int  , const int  );


        extern __m128i _mm_insert_epi64(__m128i  , __int64  , const int  );
#line 194 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\smmintrin.h"
        
        

        extern int   _mm_extract_epi8 (__m128i  , const int  );
        extern int   _mm_extract_epi32(__m128i  , const int  );


        extern __int64 _mm_extract_epi64(__m128i  , const int  );
#line 203 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\smmintrin.h"

        
        

        extern __m128i _mm_minpos_epu16(__m128i);

        

        extern __m128d _mm_round_pd(__m128d  , int  );
        extern __m128d _mm_round_sd(__m128d  , __m128d  , int  );

        

        extern __m128  _mm_round_ps(__m128   , int  );
        extern __m128  _mm_round_ss(__m128  , __m128   , int  );

        

        extern __m128i _mm_cvtepi8_epi32 (__m128i);
        extern __m128i _mm_cvtepi16_epi32(__m128i);
        extern __m128i _mm_cvtepi8_epi64 (__m128i);
        extern __m128i _mm_cvtepi32_epi64(__m128i);
        extern __m128i _mm_cvtepi16_epi64(__m128i);
        extern __m128i _mm_cvtepi8_epi16 (__m128i);

        

        extern __m128i _mm_cvtepu8_epi32 (__m128i);
        extern __m128i _mm_cvtepu16_epi32(__m128i);
        extern __m128i _mm_cvtepu8_epi64 (__m128i);
        extern __m128i _mm_cvtepu32_epi64(__m128i);
        extern __m128i _mm_cvtepu16_epi64(__m128i);
        extern __m128i _mm_cvtepu8_epi16 (__m128i);


        
        

        extern __m128i _mm_packus_epi32(__m128i, __m128i);

        
        
        

        extern __m128i _mm_mpsadbw_epu8(__m128i  , __m128i  , const int  );

        





#line 256 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\smmintrin.h"
        extern __m128i _mm_stream_load_si128(const __m128i*);
#line 258 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\smmintrin.h"


};  
#line 262 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\smmintrin.h"

#line 264 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\smmintrin.h"
#line 265 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\smmintrin.h"
#line 266 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\smmintrin.h"
#pragma external_header(pop)
#line 33 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\nmmintrin.h"



extern "C" {
#line 38 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\nmmintrin.h"













































    extern __m128i _mm_cmpistrm (__m128i  , __m128i  , const int  );
    extern int     _mm_cmpistri (__m128i  , __m128i  , const int  );

    extern __m128i _mm_cmpestrm (__m128i  , int  , __m128i  , int  , const int  );
    extern int     _mm_cmpestri (__m128i  , int  , __m128i  , int  , const int  );





    extern int     _mm_cmpistrz (__m128i  , __m128i  , const int  );
    extern int     _mm_cmpistrc (__m128i  , __m128i  , const int  );
    extern int     _mm_cmpistrs (__m128i  , __m128i  , const int  );
    extern int     _mm_cmpistro (__m128i  , __m128i  , const int  );
    extern int     _mm_cmpistra (__m128i  , __m128i  , const int  );

    extern int     _mm_cmpestrz (__m128i  , int  , __m128i  , int  , const int  );
    extern int     _mm_cmpestrc (__m128i  , int  , __m128i  , int  , const int  );
    extern int     _mm_cmpestrs (__m128i  , int  , __m128i  , int  , const int  );
    extern int     _mm_cmpestro (__m128i  , int  , __m128i  , int  , const int  );
    extern int     _mm_cmpestra (__m128i  , int  , __m128i  , int  , const int  );






    extern __m128i _mm_cmpgt_epi64(__m128i  , __m128i  );





    extern int _mm_popcnt_u32(unsigned int  );


    extern __int64 _mm_popcnt_u64(unsigned __int64  );
#line 121 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\nmmintrin.h"





    extern unsigned int _mm_crc32_u8 (unsigned int  , unsigned char  );
    extern unsigned int _mm_crc32_u16(unsigned int  , unsigned short  );
    extern unsigned int _mm_crc32_u32(unsigned int  , unsigned int  );


    extern unsigned __int64 _mm_crc32_u64(unsigned __int64  , unsigned __int64  );
#line 133 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\nmmintrin.h"


};  
#line 137 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\nmmintrin.h"

#line 139 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\nmmintrin.h"
#line 140 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\nmmintrin.h"
#line 141 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\nmmintrin.h"
#pragma external_header(pop)
#line 32 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\wmmintrin.h"



extern "C" {
#line 37 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\wmmintrin.h"





extern __m128i _mm_aesdec_si128(__m128i  , __m128i  );





extern __m128i _mm_aesdeclast_si128(__m128i  , __m128i  );





extern __m128i _mm_aesenc_si128(__m128i  , __m128i  );





extern __m128i _mm_aesenclast_si128(__m128i  , __m128i  );





extern __m128i _mm_aesimc_si128(__m128i  );






extern __m128i _mm_aeskeygenassist_si128(__m128i  , const int  );







extern __m128i _mm_clmulepi64_si128(__m128i  , __m128i  ,
                                            const int  );



};  
#line 88 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\wmmintrin.h"

#line 90 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\wmmintrin.h"
#line 91 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\wmmintrin.h"
#line 92 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\wmmintrin.h"
#pragma external_header(pop)
#line 31 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\immintrin.h"


extern "C" {
#line 35 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\immintrin.h"




typedef union __declspec(intrin_type) __declspec(align(32)) __m256 {
    float m256_f32[8];
} __m256;

typedef struct __declspec(intrin_type) __declspec(align(32)) __m256d {
    double m256d_f64[4];
} __m256d;

typedef union  __declspec(intrin_type) __declspec(align(32)) __m256i {
    __int8              m256i_i8[32];
    __int16             m256i_i16[16];
    __int32             m256i_i32[8];
    __int64             m256i_i64[4];
    unsigned __int8     m256i_u8[32];
    unsigned __int16    m256i_u16[16];
    unsigned __int32    m256i_u32[8];
    unsigned __int64    m256i_u64[4];
} __m256i;



















































extern __m256d __cdecl _mm256_add_pd(__m256d, __m256d);









extern __m256 __cdecl _mm256_add_ps(__m256, __m256);












extern __m256d __cdecl _mm256_addsub_pd(__m256d, __m256d);












extern __m256 __cdecl _mm256_addsub_ps(__m256, __m256);








extern __m256d __cdecl _mm256_and_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_and_ps(__m256, __m256);








extern __m256d __cdecl _mm256_andnot_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_andnot_ps(__m256, __m256);













extern __m256d __cdecl _mm256_blend_pd(__m256d, __m256d, const int);













extern __m256 __cdecl _mm256_blend_ps(__m256, __m256, const int);









extern __m256d __cdecl _mm256_blendv_pd(__m256d, __m256d, __m256d);









extern __m256 __cdecl _mm256_blendv_ps(__m256, __m256, __m256);








extern __m256d __cdecl _mm256_div_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_div_ps(__m256, __m256);














extern __m256 __cdecl _mm256_dp_ps(__m256, __m256, const int);








extern __m256d __cdecl _mm256_hadd_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_hadd_ps(__m256, __m256);








extern __m256d __cdecl _mm256_hsub_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_hsub_ps(__m256, __m256);








extern __m256d __cdecl _mm256_max_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_max_ps(__m256, __m256);








extern __m256d __cdecl _mm256_min_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_min_ps(__m256, __m256);









extern __m256d __cdecl _mm256_mul_pd(__m256d, __m256d);









extern __m256 __cdecl _mm256_mul_ps(__m256, __m256);








extern __m256d __cdecl _mm256_or_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_or_ps(__m256, __m256);











extern __m256d __cdecl _mm256_shuffle_pd(__m256d, __m256d, const int);












extern __m256 __cdecl _mm256_shuffle_ps(__m256, __m256, const int);








extern __m256d __cdecl _mm256_sub_pd(__m256d, __m256d);









extern __m256 __cdecl _mm256_sub_ps(__m256, __m256);








extern __m256d __cdecl _mm256_xor_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_xor_ps(__m256, __m256);















extern __m128d __cdecl _mm_cmp_pd(__m128d, __m128d, const int);
extern __m256d __cdecl _mm256_cmp_pd(__m256d, __m256d, const int);















extern __m128 __cdecl _mm_cmp_ps(__m128, __m128, const int);
extern __m256 __cdecl _mm256_cmp_ps(__m256, __m256, const int);












extern __m128d __cdecl _mm_cmp_sd(__m128d, __m128d, const int);





extern int __cdecl _mm_comi_sd(__m128d, __m128d, const int);












extern __m128 __cdecl _mm_cmp_ss(__m128, __m128, const int);





extern int __cdecl _mm_comi_ss(__m128, __m128, const int);








extern __m256d __cdecl _mm256_cvtepi32_pd(__m128i);








extern __m256  __cdecl _mm256_cvtepi32_ps(__m256i);









extern __m128  __cdecl _mm256_cvtpd_ps(__m256d);








extern __m256i __cdecl _mm256_cvtps_epi32(__m256);









extern __m256d __cdecl _mm256_cvtps_pd(__m128);












extern __m128i __cdecl _mm256_cvttpd_epi32(__m256d);








extern __m128i __cdecl _mm256_cvtpd_epi32(__m256d);












extern __m256i __cdecl _mm256_cvttps_epi32(__m256);



























#line 616 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\immintrin.h"








extern __m128  __cdecl _mm256_extractf128_ps(__m256, const int);
extern __m128d __cdecl _mm256_extractf128_pd(__m256d, const int);
extern __m128i __cdecl _mm256_extractf128_si256(__m256i, const int);






extern void __cdecl _mm256_zeroall(void);







extern void __cdecl _mm256_zeroupper(void);









extern __m256  __cdecl _mm256_permutevar_ps(__m256, __m256i);
extern __m128  __cdecl _mm_permutevar_ps(__m128, __m128i);









extern __m256  __cdecl _mm256_permute_ps(__m256, int);
extern __m128  __cdecl _mm_permute_ps(__m128, int);









extern __m256d __cdecl _mm256_permutevar_pd(__m256d, __m256i);
extern __m128d __cdecl _mm_permutevar_pd(__m128d, __m128i);









extern __m256d __cdecl _mm256_permute_pd(__m256d, int);
extern __m128d __cdecl _mm_permute_pd(__m128d, int);








extern __m256  __cdecl _mm256_permute2f128_ps(__m256, __m256, int);
extern __m256d __cdecl _mm256_permute2f128_pd(__m256d, __m256d, int);
extern __m256i __cdecl _mm256_permute2f128_si256(__m256i, __m256i, int);








extern __m256  __cdecl _mm256_broadcast_ss(float const *);
extern __m128  __cdecl _mm_broadcast_ss(float const *);







extern __m256d __cdecl _mm256_broadcast_sd(double const *);







extern __m256  __cdecl _mm256_broadcast_ps(__m128 const *);
extern __m256d __cdecl _mm256_broadcast_pd(__m128d const *);









extern __m256  __cdecl _mm256_insertf128_ps(__m256, __m128, int);
extern __m256d __cdecl _mm256_insertf128_pd(__m256d, __m128d, int);
extern __m256i __cdecl _mm256_insertf128_si256(__m256i, __m128i, int);








extern __m256d __cdecl _mm256_load_pd(double const *);
extern void    __cdecl _mm256_store_pd(double *, __m256d);








extern __m256  __cdecl _mm256_load_ps(float const *);
extern void    __cdecl _mm256_store_ps(float *, __m256);








extern __m256d __cdecl _mm256_loadu_pd(double const *);
extern void    __cdecl _mm256_storeu_pd(double *, __m256d);








extern __m256  __cdecl _mm256_loadu_ps(float const *);
extern void    __cdecl _mm256_storeu_ps(float *, __m256);








extern __m256i __cdecl _mm256_load_si256(__m256i const *);
extern void    __cdecl _mm256_store_si256(__m256i *, __m256i);








extern __m256i __cdecl _mm256_loadu_si256(__m256i const *);
extern void    __cdecl _mm256_storeu_si256(__m256i *, __m256i);

































































extern __m256d __cdecl _mm256_maskload_pd(double const *, __m256i);
extern void    __cdecl _mm256_maskstore_pd(double *, __m256i, __m256d);
extern __m128d __cdecl _mm_maskload_pd(double const *, __m128i);
extern void    __cdecl _mm_maskstore_pd(double *, __m128i, __m128d);



















extern __m256  __cdecl _mm256_maskload_ps(float const *, __m256i);
extern void    __cdecl _mm256_maskstore_ps(float *, __m256i, __m256);
extern __m128  __cdecl _mm_maskload_ps(float const *, __m128i);
extern void    __cdecl _mm_maskstore_ps(float *, __m128i, __m128);







extern __m256  __cdecl _mm256_movehdup_ps(__m256);







extern __m256  __cdecl _mm256_moveldup_ps(__m256);







extern __m256d __cdecl _mm256_movedup_pd(__m256d);









extern __m256i __cdecl _mm256_lddqu_si256(__m256i const *);







extern void    __cdecl _mm256_stream_si256(__m256i *, __m256i);








extern void    __cdecl _mm256_stream_pd(double *, __m256d);








extern void    __cdecl _mm256_stream_ps(float *, __m256);









extern __m256  __cdecl _mm256_rcp_ps(__m256);










extern __m256  __cdecl _mm256_rsqrt_ps(__m256);








extern __m256d __cdecl _mm256_sqrt_pd(__m256d);








extern __m256  __cdecl _mm256_sqrt_ps(__m256);












extern __m256d __cdecl _mm256_round_pd(__m256d, int);














extern __m256  __cdecl _mm256_round_ps(__m256, int);









extern __m256d __cdecl _mm256_unpackhi_pd(__m256d, __m256d);







extern __m256  __cdecl _mm256_unpackhi_ps(__m256, __m256);







extern __m256d __cdecl _mm256_unpacklo_pd(__m256d, __m256d);







extern __m256  __cdecl _mm256_unpacklo_ps(__m256, __m256);









extern int     __cdecl _mm256_testz_si256(__m256i, __m256i);



extern int     __cdecl _mm256_testc_si256(__m256i, __m256i);



extern int     __cdecl _mm256_testnzc_si256(__m256i, __m256i);














extern int     __cdecl _mm256_testz_pd(__m256d, __m256d);
extern int     __cdecl _mm256_testc_pd(__m256d, __m256d);
extern int     __cdecl _mm256_testnzc_pd(__m256d, __m256d);
extern int     __cdecl _mm_testz_pd(__m128d, __m128d);
extern int     __cdecl _mm_testc_pd(__m128d, __m128d);
extern int     __cdecl _mm_testnzc_pd(__m128d, __m128d);












extern int     __cdecl _mm256_testz_ps(__m256, __m256);
extern int     __cdecl _mm256_testc_ps(__m256, __m256);
extern int     __cdecl _mm256_testnzc_ps(__m256, __m256);
extern int     __cdecl _mm_testz_ps(__m128, __m128);
extern int     __cdecl _mm_testc_ps(__m128, __m128);
extern int     __cdecl _mm_testnzc_ps(__m128, __m128);








extern int     __cdecl _mm256_movemask_pd(__m256d);








extern int     __cdecl _mm256_movemask_ps(__m256);




extern __m256d __cdecl _mm256_setzero_pd(void);
extern __m256  __cdecl _mm256_setzero_ps(void);
extern __m256i __cdecl _mm256_setzero_si256(void);




extern __m256d __cdecl _mm256_set_pd(double, double, double, double);
extern __m256  __cdecl _mm256_set_ps(float, float, float, float,
                                            float, float, float, float);
extern __m256i __cdecl _mm256_set_epi8(char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char);
extern __m256i __cdecl _mm256_set_epi16(short, short, short, short,
                                               short, short, short, short,
                                               short, short, short, short,
                                               short, short, short, short);
extern __m256i __cdecl _mm256_set_epi32(int, int, int, int,
                                               int, int, int, int);
extern __m256i __cdecl _mm256_set_epi64x(__int64, __int64,
                                                __int64, __int64);










extern __m256d __cdecl _mm256_setr_pd(double, double, double, double);
extern __m256  __cdecl _mm256_setr_ps(float, float, float, float,
                                             float, float, float, float);
extern __m256i __cdecl _mm256_setr_epi8(char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char);
extern __m256i __cdecl _mm256_setr_epi16(short, short, short, short,
                                                short, short, short, short,
                                                short, short, short, short,
                                                short, short, short, short);
extern __m256i __cdecl _mm256_setr_epi32(int, int, int, int,
                                                int, int, int, int);
extern __m256i __cdecl _mm256_setr_epi64x(__int64, __int64,
                                                 __int64, __int64);







extern __m256d __cdecl _mm256_set1_pd(double);
extern __m256  __cdecl _mm256_set1_ps(float);
extern __m256i __cdecl _mm256_set1_epi8(char);
extern __m256i __cdecl _mm256_set1_epi16(short);
extern __m256i __cdecl _mm256_set1_epi32(int);
extern __m256i __cdecl _mm256_set1_epi64x(long long);







extern __m256  __cdecl _mm256_castpd_ps(__m256d);
extern __m256d __cdecl _mm256_castps_pd(__m256);
extern __m256i __cdecl _mm256_castps_si256(__m256);
extern __m256i __cdecl _mm256_castpd_si256(__m256d);
extern __m256  __cdecl _mm256_castsi256_ps(__m256i);
extern __m256d __cdecl _mm256_castsi256_pd(__m256i);
extern __m128  __cdecl _mm256_castps256_ps128(__m256);
extern __m128d __cdecl _mm256_castpd256_pd128(__m256d);
extern __m128i __cdecl _mm256_castsi256_si128(__m256i);
extern __m256  __cdecl _mm256_castps128_ps256(__m128);
extern __m256d __cdecl _mm256_castpd128_pd256(__m128d);
extern __m256i __cdecl _mm256_castsi128_si256(__m128i);






extern __m128  __cdecl _mm_cvtph_ps(__m128i);
extern __m256  __cdecl _mm256_cvtph_ps(__m128i);
extern __m128i __cdecl _mm_cvtps_ph(__m128  , const int  );
extern __m128i __cdecl _mm256_cvtps_ph(__m256, int);



















 
extern unsigned __int64 __cdecl _xgetbv(unsigned int);

 
extern void __cdecl _xsetbv(unsigned int, unsigned __int64);






extern void __cdecl _xsave(void *, unsigned __int64);

extern void __cdecl _xsave64(void *, unsigned __int64);
#line 1264 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\immintrin.h"






extern void __cdecl _xsaveopt(void *, unsigned __int64);

extern void __cdecl _xsaveopt64(void *, unsigned __int64);
#line 1274 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\immintrin.h"





extern void __cdecl _xsavec(void *, unsigned __int64);

extern void __cdecl _xsavec64(void *, unsigned __int64);
#line 1283 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\immintrin.h"






extern void __cdecl _xrstor(void const *, unsigned __int64);

extern void __cdecl _xrstor64(void const *, unsigned __int64);
#line 1293 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\immintrin.h"






extern void __cdecl _xsaves(void *, unsigned __int64);

extern void __cdecl _xsaves64(void *, unsigned __int64);
#line 1303 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\immintrin.h"






extern void __cdecl _xrstors(void const *, unsigned __int64);

extern void __cdecl _xrstors64(void const *, unsigned __int64);
#line 1313 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\immintrin.h"





extern void __cdecl _fxsave(void *);

extern void __cdecl _fxsave64(void *);
#line 1322 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\immintrin.h"





extern void __cdecl _fxrstor(void const *);

extern void __cdecl _fxrstor64(void const *);
#line 1331 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\immintrin.h"







extern int __cdecl _rdrand16_step(unsigned short *);
extern int __cdecl _rdrand32_step(unsigned int *);

extern int __cdecl _rdrand64_step(unsigned __int64 *);
#line 1343 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\immintrin.h"





extern unsigned int     __cdecl _readfsbase_u32(void);
extern unsigned int     __cdecl _readgsbase_u32(void);
extern unsigned __int64 __cdecl _readfsbase_u64(void);
extern unsigned __int64 __cdecl _readgsbase_u64(void);




extern void __cdecl _writefsbase_u32(unsigned int);
extern void __cdecl _writegsbase_u32(unsigned int);
extern void __cdecl _writefsbase_u64(unsigned __int64);
extern void __cdecl _writegsbase_u64(unsigned __int64);
#line 1361 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\immintrin.h"




extern __m128  __cdecl _mm_fmadd_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmadd_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fmadd_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmadd_sd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fmsub_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmsub_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fmsub_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmsub_sd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fnmadd_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmadd_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fnmadd_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmadd_sd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fnmsub_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmsub_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fnmsub_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmsub_sd(__m128d, __m128d, __m128d);

extern __m256  __cdecl _mm256_fmadd_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmadd_pd(__m256d, __m256d, __m256d);
extern __m256  __cdecl _mm256_fmsub_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmsub_pd(__m256d, __m256d, __m256d);
extern __m256  __cdecl _mm256_fnmadd_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fnmadd_pd(__m256d, __m256d, __m256d);
extern __m256  __cdecl _mm256_fnmsub_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fnmsub_pd(__m256d, __m256d, __m256d);





extern __m128  __cdecl _mm_fmaddsub_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmaddsub_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fmsubadd_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmsubadd_pd(__m128d, __m128d, __m128d);

extern __m256  __cdecl _mm256_fmaddsub_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmaddsub_pd(__m256d, __m256d, __m256d);
extern __m256  __cdecl _mm256_fmsubadd_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmsubadd_pd(__m256d, __m256d, __m256d);





extern __m256i __cdecl _mm256_cmpeq_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpeq_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpeq_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpeq_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_cmpgt_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpgt_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpgt_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpgt_epi64(__m256i, __m256i);





extern __m256i __cdecl _mm256_max_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epu16(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epu32(__m256i, __m256i);

extern __m256i __cdecl _mm256_min_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epu16(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epu32(__m256i, __m256i);





extern __m256i __cdecl _mm256_and_si256(__m256i, __m256i);
extern __m256i __cdecl _mm256_andnot_si256(__m256i, __m256i);
extern __m256i __cdecl _mm256_or_si256(__m256i, __m256i);
extern __m256i __cdecl _mm256_xor_si256(__m256i, __m256i);





extern __m256i __cdecl _mm256_abs_epi8(__m256i);
extern __m256i __cdecl _mm256_abs_epi16(__m256i);
extern __m256i __cdecl _mm256_abs_epi32(__m256i);

extern __m256i __cdecl _mm256_add_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_add_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_add_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_add_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_adds_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_adds_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_adds_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_adds_epu16(__m256i, __m256i);

extern __m256i __cdecl _mm256_sub_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_sub_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_sub_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_sub_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_subs_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_subs_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_subs_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_subs_epu16(__m256i, __m256i);

extern __m256i __cdecl _mm256_avg_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_avg_epu16(__m256i, __m256i);

extern __m256i __cdecl _mm256_hadd_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_hadd_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_hadds_epi16(__m256i, __m256i);

extern __m256i __cdecl _mm256_hsub_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_hsub_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_hsubs_epi16(__m256i, __m256i);

extern __m256i __cdecl _mm256_madd_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_maddubs_epi16(__m256i, __m256i);

extern __m256i __cdecl _mm256_mulhi_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_mulhi_epu16(__m256i, __m256i);

extern __m256i __cdecl _mm256_mullo_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_mullo_epi32(__m256i, __m256i);

extern __m256i __cdecl _mm256_mul_epu32(__m256i, __m256i);
extern __m256i __cdecl _mm256_mul_epi32(__m256i, __m256i);

extern __m256i __cdecl _mm256_sign_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_sign_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_sign_epi32(__m256i, __m256i);

extern __m256i __cdecl _mm256_mulhrs_epi16(__m256i, __m256i);

extern __m256i __cdecl _mm256_sad_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_mpsadbw_epu8(__m256i, __m256i, const int);





extern __m256i __cdecl _mm256_slli_si256(__m256i, const int);

extern __m256i __cdecl _mm256_srli_si256(__m256i, const int);


extern __m256i __cdecl _mm256_sll_epi16(__m256i, __m128i);
extern __m256i __cdecl _mm256_sll_epi32(__m256i, __m128i);
extern __m256i __cdecl _mm256_sll_epi64(__m256i, __m128i);

extern __m256i __cdecl _mm256_slli_epi16(__m256i, int);
extern __m256i __cdecl _mm256_slli_epi32(__m256i, int);
extern __m256i __cdecl _mm256_slli_epi64(__m256i, int);

extern __m256i __cdecl _mm256_sllv_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_sllv_epi64(__m256i, __m256i);

extern __m128i __cdecl _mm_sllv_epi32(__m128i, __m128i);
extern __m128i __cdecl _mm_sllv_epi64(__m128i, __m128i);

extern __m256i __cdecl _mm256_sra_epi16(__m256i, __m128i);
extern __m256i __cdecl _mm256_sra_epi32(__m256i, __m128i);

extern __m256i __cdecl _mm256_srai_epi16(__m256i, int);
extern __m256i __cdecl _mm256_srai_epi32(__m256i, int);

extern __m256i __cdecl _mm256_srav_epi32(__m256i, __m256i);

extern __m128i __cdecl _mm_srav_epi32(__m128i, __m128i);

extern __m256i __cdecl _mm256_srl_epi16(__m256i, __m128i);
extern __m256i __cdecl _mm256_srl_epi32(__m256i, __m128i);
extern __m256i __cdecl _mm256_srl_epi64(__m256i, __m128i);

extern __m256i __cdecl _mm256_srli_epi16(__m256i, int);
extern __m256i __cdecl _mm256_srli_epi32(__m256i, int);
extern __m256i __cdecl _mm256_srli_epi64(__m256i, int);

extern __m256i __cdecl _mm256_srlv_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_srlv_epi64(__m256i, __m256i);

extern __m128i __cdecl _mm_srlv_epi32(__m128i, __m128i);
extern __m128i __cdecl _mm_srlv_epi64(__m128i, __m128i);





extern __m128i __cdecl _mm_blend_epi32(__m128i, __m128i, const int);

extern __m256i __cdecl _mm256_blend_epi32(__m256i,__m256i, const int);

extern __m256i __cdecl _mm256_alignr_epi8(__m256i, __m256i, const int);

extern __m256i __cdecl _mm256_blendv_epi8(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_blend_epi16(__m256i, __m256i, const int);

extern __m256i __cdecl _mm256_packs_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_packs_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_packus_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_packus_epi32(__m256i, __m256i);

extern __m256i __cdecl _mm256_unpackhi_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpackhi_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpackhi_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpackhi_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_unpacklo_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpacklo_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpacklo_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpacklo_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_shuffle_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_shuffle_epi32(__m256i, const int);

extern __m256i __cdecl _mm256_shufflehi_epi16(__m256i, const int);
extern __m256i __cdecl _mm256_shufflelo_epi16(__m256i, const int);

extern __m128i __cdecl _mm256_extracti128_si256(__m256i, const int);
extern __m256i __cdecl _mm256_inserti128_si256(__m256i, __m128i, const int);





extern __m128  __cdecl _mm_broadcastss_ps(__m128);
extern __m128d __cdecl _mm_broadcastsd_pd(__m128d);

extern __m128i __cdecl _mm_broadcastb_epi8(__m128i);
extern __m128i __cdecl _mm_broadcastw_epi16(__m128i);
extern __m128i __cdecl _mm_broadcastd_epi32(__m128i);
extern __m128i __cdecl _mm_broadcastq_epi64(__m128i);

extern __m256  __cdecl _mm256_broadcastss_ps(__m128);
extern __m256d __cdecl _mm256_broadcastsd_pd(__m128d);

extern __m256i __cdecl _mm256_broadcastb_epi8(__m128i);
extern __m256i __cdecl _mm256_broadcastw_epi16(__m128i);
extern __m256i __cdecl _mm256_broadcastd_epi32(__m128i);
extern __m256i __cdecl _mm256_broadcastq_epi64(__m128i);

extern __m256i __cdecl _mm256_broadcastsi128_si256(__m128i);






extern __m256i __cdecl _mm256_cvtepi8_epi16(__m128i);
extern __m256i __cdecl _mm256_cvtepi8_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepi8_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepi16_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepi16_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepi32_epi64(__m128i);

extern __m256i __cdecl _mm256_cvtepu8_epi16(__m128i);
extern __m256i __cdecl _mm256_cvtepu8_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepu8_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepu16_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepu16_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepu32_epi64(__m128i);






extern int __cdecl _mm256_movemask_epi8(__m256i);





extern __m128i __cdecl _mm_maskload_epi32(int const *  ,
                                          __m128i      );
extern __m128i __cdecl _mm_maskload_epi64(__int64 const *  ,
                                          __m128i          );

extern void __cdecl _mm_maskstore_epi32(int *    ,
                                        __m128i  ,
                                        __m128i  );
extern void __cdecl _mm_maskstore_epi64(__int64 *  ,
                                        __m128i    ,
                                        __m128i    );

extern __m256i __cdecl _mm256_maskload_epi32(int const *  ,
                                             __m256i      );
extern __m256i __cdecl _mm256_maskload_epi64(__int64 const *  ,
                                             __m256i          );

extern void __cdecl _mm256_maskstore_epi32(int *    ,
                                           __m256i  ,
                                           __m256i  );
extern void __cdecl _mm256_maskstore_epi64(__int64 *  ,
                                           __m256i    ,
                                           __m256i    );





extern __m256i __cdecl _mm256_permutevar8x32_epi32(__m256i, __m256i);
extern __m256  __cdecl _mm256_permutevar8x32_ps(__m256, __m256i);

extern __m256i __cdecl _mm256_permute4x64_epi64(__m256i, const int);
extern __m256d __cdecl _mm256_permute4x64_pd(__m256d, const int);

extern __m256i __cdecl _mm256_permute2x128_si256(__m256i, __m256i, const int);





extern __m256i  __cdecl _mm256_stream_load_si256(__m256i const *);






extern __m256d __cdecl _mm256_mask_i32gather_pd(__m256d         ,
                                                double const *  ,
                                                __m128i         ,
                                                __m256d         ,
                                                const int       );
extern __m256  __cdecl _mm256_mask_i32gather_ps(__m256          ,
                                                float const *   ,
                                                __m256i         ,
                                                __m256          ,
                                                const int       );
extern __m256d __cdecl _mm256_mask_i64gather_pd(__m256d         ,
                                                double const *  ,
                                                __m256i         ,
                                                __m256d         ,
                                                const int       );
extern __m128  __cdecl _mm256_mask_i64gather_ps(__m128          ,
                                                float const *   ,
                                                __m256i         ,
                                                __m128          ,
                                                const int       );

extern __m128d __cdecl _mm_mask_i32gather_pd(__m128d         ,
                                             double const *  ,
                                             __m128i         ,
                                             __m128d         ,
                                             const int       );
extern __m128  __cdecl _mm_mask_i32gather_ps(__m128          ,
                                             float const *   ,
                                             __m128i         ,
                                             __m128          ,
                                             const int       );
extern __m128d __cdecl _mm_mask_i64gather_pd(__m128d         ,
                                             double const *  ,
                                             __m128i         ,
                                             __m128d         ,
                                             const int       );
extern __m128  __cdecl _mm_mask_i64gather_ps(__m128          ,
                                             float const *   ,
                                             __m128i         ,
                                             __m128          ,
                                             const int       );


extern __m256i __cdecl _mm256_mask_i32gather_epi32(__m256i      ,
                                                   int const *  ,
                                                   __m256i      ,
                                                   __m256i      ,
                                                   const int    );
extern __m256i __cdecl _mm256_mask_i32gather_epi64(__m256i      ,
                                                   __int64 const *  ,
                                                   __m128i      ,
                                                   __m256i      ,
                                                   const int    );
extern __m128i __cdecl _mm256_mask_i64gather_epi32(__m128i      ,
                                                   int     const *  ,
                                                   __m256i      ,
                                                   __m128i      ,
                                                   const int    );
extern __m256i __cdecl _mm256_mask_i64gather_epi64(__m256i      ,
                                                   __int64 const *  ,
                                                   __m256i      ,
                                                   __m256i      ,
                                                   const int    );

extern __m128i __cdecl _mm_mask_i32gather_epi32(__m128i          ,
                                                int const *      ,
                                                __m128i          ,
                                                __m128i          ,
                                                const int        );
extern __m128i __cdecl _mm_mask_i32gather_epi64(__m128i          ,
                                                __int64 const *  ,
                                                __m128i          ,
                                                __m128i          ,
                                                const int        );
extern __m128i __cdecl _mm_mask_i64gather_epi32(__m128i          ,
                                                int     const *  ,
                                                __m128i          ,
                                                __m128i          ,
                                                const int        );
extern __m128i __cdecl _mm_mask_i64gather_epi64(__m128i          ,
                                                __int64 const *  ,
                                                __m128i          ,
                                                __m128i          ,
                                                const int        );





extern __m256d __cdecl _mm256_i32gather_pd(double const *  ,
                                           __m128i         ,
                                           const int       );
extern __m256  __cdecl _mm256_i32gather_ps(float  const *  ,
                                           __m256i         ,
                                           const int       );
extern __m256d __cdecl _mm256_i64gather_pd(double const *  ,
                                           __m256i         ,
                                           const int       );
extern __m128  __cdecl _mm256_i64gather_ps(float  const *  ,
                                           __m256i         ,
                                           const int       );

extern __m128d __cdecl _mm_i32gather_pd(double const *  ,
                                        __m128i         ,
                                        const int       );
extern __m128  __cdecl _mm_i32gather_ps(float  const *  ,
                                        __m128i         ,
                                        const int       );
extern __m128d __cdecl _mm_i64gather_pd(double const *  ,
                                        __m128i         ,
                                        const int       );
extern __m128  __cdecl _mm_i64gather_ps(float  const *  ,
                                        __m128i         ,
                                        const int       );

extern __m256i __cdecl _mm256_i32gather_epi32(int const *      ,
                                              __m256i          ,
                                              const int        );
extern __m256i __cdecl _mm256_i32gather_epi64(__int64 const *  ,
                                              __m128i          ,
                                              const int        );
extern __m128i __cdecl _mm256_i64gather_epi32(int const *      ,
                                              __m256i          ,
                                              const int        );
extern __m256i __cdecl _mm256_i64gather_epi64(__int64 const *  ,
                                              __m256i          ,
                                              const int        );

extern __m128i __cdecl _mm_i32gather_epi32(int const *      ,
                                           __m128i          ,
                                           const int        );
extern __m128i __cdecl _mm_i32gather_epi64(__int64 const *  ,
                                           __m128i          ,
                                           const int        );
extern __m128i __cdecl _mm_i64gather_epi32(int     const *  ,
                                           __m128i          ,
                                           const int        );
extern __m128i __cdecl _mm_i64gather_epi64(__int64 const *  ,
                                           __m128i          ,
                                           const int        );
















extern unsigned int     _bextr_u32(unsigned int  ,
                                   unsigned int  ,
                                   unsigned int  );
extern unsigned int     _bextr2_u32(unsigned int  ,
                                    unsigned int  );
extern unsigned int     _blsi_u32(unsigned int);
extern unsigned int     _blsmsk_u32(unsigned int);
extern unsigned int     _blsr_u32(unsigned int);
extern unsigned int     _bzhi_u32(unsigned int  ,
                                  unsigned int  );
extern unsigned int     _mulx_u32(unsigned int  ,
                                  unsigned int  ,
                                  unsigned int *  );
extern unsigned int     _pdep_u32(unsigned int  ,
                                  unsigned int  );
extern unsigned int     _pext_u32(unsigned int  ,
                                  unsigned int  );
extern unsigned int     _rorx_u32(unsigned int  ,
                                  const unsigned int  );
extern int              _sarx_i32(int  ,
                                  unsigned int  );
extern unsigned int     _shlx_u32(unsigned int  ,
                                  unsigned int  );
extern unsigned int     _shrx_u32(unsigned int  ,
                                          unsigned int  );


extern unsigned __int64 _bextr_u64(unsigned __int64  ,
                                   unsigned int  ,
                                   unsigned int  );
extern unsigned __int64 _bextr2_u64(unsigned __int64  ,
                                    unsigned __int64  );
extern unsigned __int64 _blsi_u64(unsigned __int64);
extern unsigned __int64 _blsmsk_u64(unsigned __int64);
extern unsigned __int64 _blsr_u64(unsigned __int64);
extern unsigned __int64 _bzhi_u64(unsigned __int64  ,
                                  unsigned int  );
extern unsigned __int64 _mulx_u64(unsigned __int64  ,
                                  unsigned __int64  ,
                                  unsigned __int64 *  );
extern unsigned __int64 _pdep_u64(unsigned __int64  ,
                                  unsigned __int64  );
extern unsigned __int64 _pext_u64(unsigned __int64  ,
                                  unsigned __int64  );
extern unsigned __int64 _rorx_u64(unsigned __int64  ,
                                  const unsigned int  );
extern __int64          _sarx_i64(__int64  ,
                                  unsigned int  );
extern unsigned __int64 _shlx_u64(unsigned __int64  ,
                                  unsigned int  );
extern unsigned __int64 _shrx_u64(unsigned __int64  ,
                                          unsigned int  );
#line 1898 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\immintrin.h"








extern unsigned int     _lzcnt_u32(unsigned int);

extern unsigned __int64 _lzcnt_u64(unsigned __int64);
#line 1910 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\immintrin.h"








extern unsigned __int16 _tzcnt_u16(unsigned __int16);
extern unsigned int     _tzcnt_u32(unsigned int);

extern unsigned __int64 _tzcnt_u64(unsigned __int64);
#line 1923 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\immintrin.h"






extern void __cdecl _invpcid(unsigned int  , void *  );


extern void _Store_HLERelease(long volatile *,long);
extern void _StorePointer_HLERelease(void * volatile *,void *);

extern long _InterlockedExchange_HLEAcquire(long volatile *,long);
extern long _InterlockedExchange_HLERelease(long volatile *,long);
extern void * _InterlockedExchangePointer_HLEAcquire(void *volatile *,void *);
extern void * _InterlockedExchangePointer_HLERelease(void *volatile *,void *);

extern long _InterlockedCompareExchange_HLEAcquire(long volatile *,long,long);
extern long _InterlockedCompareExchange_HLERelease(long volatile *,long,long);
extern __int64 _InterlockedCompareExchange64_HLEAcquire(__int64 volatile *,__int64,__int64);
extern __int64 _InterlockedCompareExchange64_HLERelease(__int64 volatile *,__int64,__int64);
extern void * _InterlockedCompareExchangePointer_HLEAcquire(void *volatile *,void *,void *);
extern void * _InterlockedCompareExchangePointer_HLERelease(void *volatile *,void *,void *);

extern long _InterlockedExchangeAdd_HLEAcquire(long volatile *,long);
extern long _InterlockedExchangeAdd_HLERelease(long volatile *,long);

extern long _InterlockedAnd_HLEAcquire(long volatile *,long);
extern long _InterlockedAnd_HLERelease(long volatile *,long);
extern long _InterlockedOr_HLEAcquire(long volatile *,long);
extern long _InterlockedOr_HLERelease(long volatile *,long);
extern long _InterlockedXor_HLEAcquire(long volatile *,long);
extern long _InterlockedXor_HLERelease(long volatile *,long);

extern unsigned char _interlockedbittestandset_HLEAcquire(long *,long);
extern unsigned char _interlockedbittestandset_HLERelease(long *,long);
extern unsigned char _interlockedbittestandreset_HLEAcquire(long *,long);
extern unsigned char _interlockedbittestandreset_HLERelease(long *,long);


extern void _Store64_HLERelease(__int64 volatile *,__int64);
extern __int64 _InterlockedExchange64_HLEAcquire(__int64 volatile *,__int64);
extern __int64 _InterlockedExchange64_HLERelease(__int64 volatile *,__int64);

extern __int64 _InterlockedExchangeAdd64_HLEAcquire(__int64 volatile *,__int64);
extern __int64 _InterlockedExchangeAdd64_HLERelease(__int64 volatile *,__int64);

extern __int64 _InterlockedAnd64_HLEAcquire(__int64 volatile *,__int64);
extern __int64 _InterlockedAnd64_HLERelease(__int64 volatile *,__int64);
extern __int64 _InterlockedOr64_HLEAcquire(__int64 volatile *,__int64);
extern __int64 _InterlockedOr64_HLERelease(__int64 volatile *,__int64);
extern __int64 _InterlockedXor64_HLEAcquire(__int64 volatile *,__int64);
extern __int64 _InterlockedXor64_HLERelease(__int64 volatile *,__int64);

extern unsigned char _interlockedbittestandset64_HLEAcquire(__int64 *,__int64);
extern unsigned char _interlockedbittestandset64_HLERelease(__int64 *,__int64);
extern unsigned char _interlockedbittestandreset64_HLEAcquire(__int64 *,__int64);
extern unsigned char _interlockedbittestandreset64_HLERelease(__int64 *,__int64);
#line 1982 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\immintrin.h"











extern unsigned int     __cdecl _xbegin(void);
extern void             __cdecl _xend(void);
extern void             __cdecl _xabort(const unsigned int);
extern unsigned char    __cdecl _xtest(void);








extern int __cdecl _rdseed16_step(unsigned short *);
extern int __cdecl _rdseed32_step(unsigned int *);

extern int __cdecl _rdseed64_step(unsigned __int64 *);
#line 2010 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\immintrin.h"










extern unsigned char __cdecl _addcarryx_u32(unsigned char  ,
                                                   unsigned int  ,
                                                   unsigned int  ,
                                                   unsigned int *  );



extern unsigned char __cdecl _addcarryx_u64(unsigned char  ,
                                                   unsigned __int64  ,
                                                   unsigned __int64  ,
                                                   unsigned __int64 *  );
#line 2032 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\immintrin.h"





extern unsigned short   __cdecl _load_be_u16(void const*);
extern unsigned int     __cdecl _load_be_u32(void const*);
extern unsigned __int64 __cdecl _load_be_u64(void const*);







extern void __cdecl _store_be_u16(void *, unsigned short);
extern void __cdecl _store_be_u32(void *, unsigned int);
extern void __cdecl _store_be_u64(void *, unsigned __int64);







extern __m128i __cdecl _mm_sha1msg1_epu32(__m128i, __m128i);
extern __m128i __cdecl _mm_sha1msg2_epu32(__m128i, __m128i);
extern __m128i __cdecl _mm_sha1nexte_epu32(__m128i, __m128i);
extern __m128i __cdecl _mm_sha1rnds4_epu32(__m128i, __m128i, const int);

extern __m128i __cdecl _mm_sha256msg1_epu32(__m128i, __m128i);
extern __m128i __cdecl _mm_sha256msg2_epu32(__m128i, __m128i);
extern __m128i __cdecl _mm_sha256rnds2_epu32(__m128i, __m128i, __m128i);




extern void * __cdecl _bnd_set_ptr_bounds(const void *, size_t);
extern void * __cdecl _bnd_narrow_ptr_bounds(const void *, const void *, size_t);
extern void * __cdecl _bnd_copy_ptr_bounds(const void *, const void *);
extern void * __cdecl _bnd_init_ptr_bounds(const void *);
extern void __cdecl _bnd_store_ptr_bounds(const void **, const void *);
extern void __cdecl _bnd_chk_ptr_lbounds(const void *);
extern void __cdecl _bnd_chk_ptr_ubounds(const void *);
extern void __cdecl _bnd_chk_ptr_bounds(const void *, size_t);
extern void * __cdecl _bnd_load_ptr_bounds(const void **, const void *);
extern const void * __cdecl _bnd_get_ptr_lbound(const void *);
extern const void * __cdecl _bnd_get_ptr_ubound(const void *);


extern __m256i __cdecl _mm256_insert_epi8 (__m256i  , int  , const int  );
extern __m256i __cdecl _mm256_insert_epi16(__m256i  , int  , const int  );
extern __m256i __cdecl _mm256_insert_epi32(__m256i  , int  , const int  );

extern __m256i __cdecl _mm256_insert_epi64(__m256i  , __int64  , const int  );
#line 2088 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\immintrin.h"


extern int __cdecl _mm256_extract_epi8 (__m256i  , const int  );
extern int __cdecl _mm256_extract_epi16(__m256i  , const int  );
extern int __cdecl _mm256_extract_epi32(__m256i  , const int  );

extern __int64 __cdecl _mm256_extract_epi64(__m256i  , const int  );
#line 2096 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\immintrin.h"


extern __m256d __cdecl _mm256_zextpd128_pd256(__m128d);
extern __m256  __cdecl _mm256_zextps128_ps256(__m128);
extern __m256i __cdecl _mm256_zextsi128_si256(__m128i);


extern unsigned int __cdecl _rdpid_u32(void);

extern void         __cdecl _ptwrite32(unsigned int);

extern void         __cdecl _ptwrite64(unsigned __int64);
#line 2109 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\immintrin.h"


extern __m128i __cdecl _mm_dpbusd_avx_epi32(__m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_dpbusd_avx_epi32(__m256i, __m256i, __m256i);
extern __m128i __cdecl _mm_dpbusds_avx_epi32(__m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_dpbusds_avx_epi32(__m256i, __m256i, __m256i);
extern __m128i __cdecl _mm_dpwssd_avx_epi32(__m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_dpwssd_avx_epi32(__m256i, __m256i, __m256i);
extern __m128i __cdecl _mm_dpwssds_avx_epi32(__m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_dpwssds_avx_epi32(__m256i, __m256i, __m256i);


extern unsigned int __cdecl _pconfig_u32(const int, size_t __data[]);
extern void __cdecl _wbnoinvd(void);


extern unsigned int __cdecl _encls_u32(const int, size_t __data[]);
extern unsigned int __cdecl _enclu_u32(const int, size_t __data[]);
extern unsigned int __cdecl _enclv_u32(const int, size_t __data[]);




extern unsigned __int64 __cdecl _udiv128(unsigned __int64  , unsigned __int64  , unsigned __int64  , unsigned __int64*  );
extern __int64          __cdecl _div128(__int64  , __int64  , __int64  , __int64*  );
#line 2135 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\immintrin.h"
extern unsigned         __cdecl _udiv64(unsigned __int64  , unsigned  , unsigned*  );
extern int              __cdecl _div64(__int64  , int  , int*  );


extern unsigned char _mm_aesdec128kl_u8(__m128i*  , __m128i  , const void*  );
extern unsigned char _mm_aesdec256kl_u8(__m128i*  , __m128i  , const void*  );
extern unsigned char _mm_aesdecwide128kl_u8(__m128i*  , const __m128i*  , const void*  );
extern unsigned char _mm_aesdecwide256kl_u8(__m128i*  , const __m128i*  , const void*  );
extern unsigned char _mm_aesenc128kl_u8(__m128i*  , __m128i  , const void*  );
extern unsigned char _mm_aesenc256kl_u8(__m128i*  , __m128i  , const void*  );
extern unsigned char _mm_aesencwide128kl_u8(__m128i*  , const __m128i*  , const void*  );
extern unsigned char _mm_aesencwide256kl_u8(__m128i*  , const __m128i*  , const void*  );
extern unsigned int  _mm_encodekey128_u32(unsigned int  , __m128i  , void*  );
extern unsigned int  _mm_encodekey256_u32(unsigned int  , __m128i  , __m128i  , void*  );
extern void          _mm_loadiwkey(unsigned int  , __m128i  , __m128i  , __m128i  );


extern unsigned int     __cdecl _rdpkru_u32(void);
extern void             __cdecl _wrpkru(unsigned int);


extern int              __cdecl _enqcmd(void *  , const void *  );
extern int              __cdecl _enqcmds(void *  , const void *  );




extern void             __cdecl _incsspd (unsigned int);
extern unsigned int     __cdecl _rdsspd (void);
extern void             __cdecl _saveprevssp (void);
extern void             __cdecl _rstorssp (void *);
extern void             __cdecl _wrssd (unsigned int, void *);
extern void             __cdecl _wrussd (unsigned int, void *);
extern void             __cdecl _setssbsy (void);
extern void             __cdecl _clrssbsy (void *);
extern void *           __cdecl _switchssp(void *);

extern void             __cdecl _incsspq (unsigned __int64);
extern unsigned __int64 __cdecl _rdsspq (void);
extern void             __cdecl _wrssq (unsigned __int64, void *);
extern void             __cdecl _wrussq(unsigned __int64, void *);
#line 2177 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\immintrin.h"






extern __m128i _mm_div_epi8(__m128i, __m128i);
extern __m128i _mm_div_epi16(__m128i, __m128i);
extern __m128i _mm_div_epi32(__m128i, __m128i);
extern __m128i _mm_div_epi64(__m128i, __m128i);
extern __m128i _mm_div_epu8(__m128i, __m128i);
extern __m128i _mm_div_epu16(__m128i, __m128i);
extern __m128i _mm_div_epu32(__m128i, __m128i);
extern __m128i _mm_div_epu64(__m128i, __m128i);
extern __m128i _mm_rem_epi8(__m128i, __m128i);
extern __m128i _mm_rem_epi16(__m128i, __m128i);
extern __m128i _mm_rem_epi32(__m128i, __m128i);
extern __m128i _mm_rem_epi64(__m128i, __m128i);
extern __m128i _mm_rem_epu8(__m128i, __m128i);
extern __m128i _mm_rem_epu16(__m128i, __m128i);
extern __m128i _mm_rem_epu32(__m128i, __m128i);
extern __m128i _mm_rem_epu64(__m128i, __m128i);
extern __m256i _mm256_div_epi8(__m256i, __m256i);
extern __m256i _mm256_div_epi16(__m256i, __m256i);
extern __m256i _mm256_div_epi32(__m256i, __m256i);
extern __m256i _mm256_div_epi64(__m256i, __m256i);
extern __m256i _mm256_div_epu8(__m256i, __m256i);
extern __m256i _mm256_div_epu16(__m256i, __m256i);
extern __m256i _mm256_div_epu32(__m256i, __m256i);
extern __m256i _mm256_div_epu64(__m256i, __m256i);
extern __m256i _mm256_rem_epi8(__m256i, __m256i);
extern __m256i _mm256_rem_epi16(__m256i, __m256i);
extern __m256i _mm256_rem_epi32(__m256i, __m256i);
extern __m256i _mm256_rem_epi64(__m256i, __m256i);
extern __m256i _mm256_rem_epu8(__m256i, __m256i);
extern __m256i _mm256_rem_epu16(__m256i, __m256i);
extern __m256i _mm256_rem_epu32(__m256i, __m256i);
extern __m256i _mm256_rem_epu64(__m256i, __m256i);










extern __m128i _mm_divrem_epi32(__m128i *  , __m128i, __m128i);
extern __m128i _mm_divrem_epu32(__m128i *  , __m128i, __m128i);
extern __m256i _mm256_divrem_epi32(__m256i *  , __m256i, __m256i);
extern __m256i _mm256_divrem_epu32(__m256i *  , __m256i, __m256i);







extern __m128  _mm_sin_ps(__m128);
extern __m128d _mm_sin_pd(__m128d);
extern __m256  _mm256_sin_ps(__m256);
extern __m256d _mm256_sin_pd(__m256d);
extern __m128  _mm_cos_ps(__m128);
extern __m128d _mm_cos_pd(__m128d);
extern __m256  _mm256_cos_ps(__m256);
extern __m256d _mm256_cos_pd(__m256d);
extern __m128  _mm_sincos_ps(__m128  *  , __m128);
extern __m128d _mm_sincos_pd(__m128d *  , __m128d);
extern __m256  _mm256_sincos_ps(__m256  *  , __m256);
extern __m256d _mm256_sincos_pd(__m256d *  , __m256d);
extern __m128  _mm_tan_ps(__m128);
extern __m128d _mm_tan_pd(__m128d);
extern __m256  _mm256_tan_ps(__m256);
extern __m256d _mm256_tan_pd(__m256d);
extern __m128  _mm_asin_ps(__m128);
extern __m128d _mm_asin_pd(__m128d);
extern __m256  _mm256_asin_ps(__m256);
extern __m256d _mm256_asin_pd(__m256d);
extern __m128  _mm_acos_ps(__m128);
extern __m128d _mm_acos_pd(__m128d);
extern __m256  _mm256_acos_ps(__m256);
extern __m256d _mm256_acos_pd(__m256d);
extern __m128  _mm_atan_ps(__m128);
extern __m128d _mm_atan_pd(__m128d);
extern __m256  _mm256_atan_ps(__m256);
extern __m256d _mm256_atan_pd(__m256d);
extern __m128  _mm_atan2_ps(__m128, __m128);
extern __m128d _mm_atan2_pd(__m128d, __m128d);
extern __m256  _mm256_atan2_ps(__m256, __m256);
extern __m256d _mm256_atan2_pd(__m256d, __m256d);
extern __m128  _mm_sind_ps(__m128);
extern __m128d _mm_sind_pd(__m128d);
extern __m256  _mm256_sind_ps(__m256);
extern __m256d _mm256_sind_pd(__m256d);
extern __m128  _mm_cosd_ps(__m128);
extern __m128d _mm_cosd_pd(__m128d);
extern __m256  _mm256_cosd_ps(__m256);
extern __m256d _mm256_cosd_pd(__m256d);
extern __m128  _mm_tand_ps(__m128);
extern __m128d _mm_tand_pd(__m128d);
extern __m256  _mm256_tand_ps(__m256);
extern __m256d _mm256_tand_pd(__m256d);
extern __m128  _mm_sinh_ps(__m128);
extern __m128d _mm_sinh_pd(__m128d);
extern __m256  _mm256_sinh_ps(__m256);
extern __m256d _mm256_sinh_pd(__m256d);
extern __m128  _mm_cosh_ps(__m128);
extern __m128d _mm_cosh_pd(__m128d);
extern __m256  _mm256_cosh_ps(__m256);
extern __m256d _mm256_cosh_pd(__m256d);
extern __m128  _mm_tanh_ps(__m128);
extern __m128d _mm_tanh_pd(__m128d);
extern __m256  _mm256_tanh_ps(__m256);
extern __m256d _mm256_tanh_pd(__m256d);
extern __m128  _mm_asinh_ps(__m128);
extern __m128d _mm_asinh_pd(__m128d);
extern __m256  _mm256_asinh_ps(__m256);
extern __m256d _mm256_asinh_pd(__m256d);
extern __m128  _mm_acosh_ps(__m128);
extern __m128d _mm_acosh_pd(__m128d);
extern __m256  _mm256_acosh_ps(__m256);
extern __m256d _mm256_acosh_pd(__m256d);
extern __m128  _mm_atanh_ps(__m128);
extern __m128d _mm_atanh_pd(__m128d);
extern __m256  _mm256_atanh_ps(__m256);
extern __m256d _mm256_atanh_pd(__m256d);
extern __m128  _mm_log_ps(__m128);
extern __m128d _mm_log_pd(__m128d);
extern __m256  _mm256_log_ps(__m256);
extern __m256d _mm256_log_pd(__m256d);
extern __m128  _mm_log1p_ps(__m128);
extern __m128d _mm_log1p_pd(__m128d);
extern __m256  _mm256_log1p_ps(__m256);
extern __m256d _mm256_log1p_pd(__m256d);
extern __m128  _mm_log10_ps(__m128);
extern __m128d _mm_log10_pd(__m128d);
extern __m256  _mm256_log10_ps(__m256);
extern __m256d _mm256_log10_pd(__m256d);
extern __m128  _mm_log2_ps(__m128);
extern __m128d _mm_log2_pd(__m128d);
extern __m256  _mm256_log2_ps(__m256);
extern __m256d _mm256_log2_pd(__m256d);
extern __m128  _mm_logb_ps(__m128);
extern __m128d _mm_logb_pd(__m128d);
extern __m256  _mm256_logb_ps(__m256);
extern __m256d _mm256_logb_pd(__m256d);
extern __m128  _mm_exp_ps(__m128);
extern __m128d _mm_exp_pd(__m128d);
extern __m256  _mm256_exp_ps(__m256);
extern __m256d _mm256_exp_pd(__m256d);
extern __m128  _mm_exp10_ps(__m128);
extern __m128d _mm_exp10_pd(__m128d);
extern __m256  _mm256_exp10_ps(__m256);
extern __m256d _mm256_exp10_pd(__m256d);
extern __m128  _mm_exp2_ps(__m128);
extern __m128d _mm_exp2_pd(__m128d);
extern __m256  _mm256_exp2_ps(__m256);
extern __m256d _mm256_exp2_pd(__m256d);
extern __m128  _mm_expm1_ps(__m128);
extern __m128d _mm_expm1_pd(__m128d);
extern __m256  _mm256_expm1_ps(__m256);
extern __m256d _mm256_expm1_pd(__m256d);
extern __m128  _mm_pow_ps(__m128, __m128);
extern __m128d _mm_pow_pd(__m128d, __m128d);
extern __m256  _mm256_pow_ps(__m256, __m256);
extern __m256d _mm256_pow_pd(__m256d, __m256d);
extern __m128  _mm_trunc_ps(__m128);
extern __m128d _mm_trunc_pd(__m128d);
extern __m256  _mm256_trunc_ps(__m256);
extern __m256d _mm256_trunc_pd(__m256d);
extern __m128  _mm_svml_floor_ps(__m128);
extern __m128d _mm_svml_floor_pd(__m128d);
extern __m256  _mm256_svml_floor_ps(__m256);
extern __m256d _mm256_svml_floor_pd(__m256d);
extern __m128  _mm_svml_ceil_ps(__m128);
extern __m128d _mm_svml_ceil_pd(__m128d);
extern __m256  _mm256_svml_ceil_ps(__m256);
extern __m256d _mm256_svml_ceil_pd(__m256d);
extern __m128  _mm_svml_round_ps(__m128);
extern __m128d _mm_svml_round_pd(__m128d);
extern __m256  _mm256_svml_round_ps(__m256);
extern __m256d _mm256_svml_round_pd(__m256d);
extern __m128  _mm_fmod_ps(__m128, __m128);
extern __m128d _mm_fmod_pd(__m128d, __m128d);
extern __m256  _mm256_fmod_ps(__m256, __m256);
extern __m256d _mm256_fmod_pd(__m256d, __m256d);
extern __m128  _mm_svml_sqrt_ps(__m128);
extern __m128d _mm_svml_sqrt_pd(__m128d);
extern __m256  _mm256_svml_sqrt_ps(__m256);
extern __m256d _mm256_svml_sqrt_pd(__m256d);
extern __m128  _mm_invsqrt_ps(__m128);
extern __m128d _mm_invsqrt_pd(__m128d);
extern __m256  _mm256_invsqrt_ps(__m256);
extern __m256d _mm256_invsqrt_pd(__m256d);
extern __m128  _mm_cbrt_ps(__m128);
extern __m128d _mm_cbrt_pd(__m128d);
extern __m256  _mm256_cbrt_ps(__m256);
extern __m256d _mm256_cbrt_pd(__m256d);
extern __m128  _mm_invcbrt_ps(__m128);
extern __m128d _mm_invcbrt_pd(__m128d);
extern __m256  _mm256_invcbrt_ps(__m256);
extern __m256d _mm256_invcbrt_pd(__m256d);
extern __m128  _mm_hypot_ps(__m128, __m128);
extern __m128d _mm_hypot_pd(__m128d, __m128d);
extern __m256  _mm256_hypot_ps(__m256, __m256);
extern __m256d _mm256_hypot_pd(__m256d, __m256d);
extern __m128  _mm_cdfnorm_ps(__m128);
extern __m128d _mm_cdfnorm_pd(__m128d);
extern __m256  _mm256_cdfnorm_ps(__m256);
extern __m256d _mm256_cdfnorm_pd(__m256d);
extern __m128  _mm_cdfnorminv_ps(__m128);
extern __m128d _mm_cdfnorminv_pd(__m128d);
extern __m256  _mm256_cdfnorminv_ps(__m256);
extern __m256d _mm256_cdfnorminv_pd(__m256d);
extern __m128  _mm_cexp_ps(__m128);
extern __m256  _mm256_cexp_ps(__m256);
extern __m128  _mm_clog_ps(__m128);
extern __m256  _mm256_clog_ps(__m256);
extern __m128  _mm_csqrt_ps(__m128);
extern __m256  _mm256_csqrt_ps(__m256);
extern __m128  _mm_erf_ps(__m128);
extern __m128d _mm_erf_pd(__m128d);
extern __m256  _mm256_erf_ps(__m256);
extern __m256d _mm256_erf_pd(__m256d);
extern __m128  _mm_erfc_ps(__m128);
extern __m128d _mm_erfc_pd(__m128d);
extern __m256  _mm256_erfc_ps(__m256);
extern __m256d _mm256_erfc_pd(__m256d);
extern __m128  _mm_erfcinv_ps(__m128);
extern __m128d _mm_erfcinv_pd(__m128d);
extern __m256  _mm256_erfcinv_ps(__m256);
extern __m256d _mm256_erfcinv_pd(__m256d);
extern __m128  _mm_erfinv_ps(__m128);
extern __m128d _mm_erfinv_pd(__m128d);
extern __m256  _mm256_erfinv_ps(__m256);
extern __m256d _mm256_erfinv_pd(__m256d);

 
extern void _mm_cldemote(void const *);


 
extern void _directstoreu_u32(void *, unsigned int);

extern void _directstoreu_u64(void *, unsigned __int64);
#line 2424 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\immintrin.h"
extern void _movdir64b(void *, void const *);

 
extern void __cdecl _serialize(void);
extern void __cdecl _xsusldtrk(void);
extern void __cdecl _xresldtrk(void);

 
extern void _umonitor(void *);
extern unsigned char _umwait(unsigned int, unsigned __int64);
extern unsigned char _tpause(unsigned int, unsigned __int64);

 

extern void _clui(void);
extern void _stui(void);
extern unsigned char _testui(void);
extern void _senduipi(unsigned __int64);
#line 2443 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\immintrin.h"

 
extern void _hreset(unsigned __int32);

 
extern __m128 _mm_svml_cvtepu32_ps (__m128i);
extern __m256 _mm256_svml_cvtepu32_ps (__m256i);
extern __m128d _mm_svml_cvtepu32_pd (__m128i);
extern __m256d _mm256_svml_cvtepu32_pd (__m128i);
extern __m128d _mm_svml_cvtepi64_pd (__m128i);
extern __m256d _mm256_svml_cvtepi64_pd (__m256i);
extern __m128d _mm_svml_cvtepu64_pd (__m128i);
extern __m256d _mm256_svml_cvtepu64_pd (__m256i);

 
extern unsigned __int32 _castf32_u32 (float);
extern unsigned __int64 _castf64_u64 (double);
extern float _castu32_f32 (unsigned __int32);
extern double _castu64_f64 (unsigned __int64);


};  
#line 2466 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\immintrin.h"

#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\zmmintrin.h"









































typedef unsigned char       __mmask8;
typedef unsigned short      __mmask16;
typedef unsigned int        __mmask32;
typedef unsigned __int64    __mmask64;

typedef union __declspec(intrin_type) __declspec(align(64)) __m512 {
    float m512_f32[16];
} __m512;

typedef struct __declspec(intrin_type) __declspec(align(64)) __m512d {
    double m512d_f64[8];
} __m512d;

typedef union  __declspec(intrin_type) __declspec(align(64)) __m512i {
    __int8              m512i_i8[64];
    __int16             m512i_i16[32];
    __int32             m512i_i32[16];
    __int64             m512i_i64[8];
    unsigned __int8     m512i_u8[64];
    unsigned __int16    m512i_u16[32];
    unsigned __int32    m512i_u32[16];
    unsigned __int64    m512i_u64[8];
} __m512i;



extern "C" {

#line 71 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\zmmintrin.h"

 
extern __m256  __cdecl _mm512_castps512_ps256(__m512);
extern __m512  __cdecl _mm512_castpd_ps(__m512d);
extern __m512  __cdecl _mm512_castps256_ps512(__m256);
extern __m512  __cdecl _mm512_castsi512_ps(__m512i);
extern __m512  __cdecl _mm512_castps128_ps512(__m128);

extern __m256d __cdecl _mm512_castpd512_pd256(__m512d);
extern __m512d __cdecl _mm512_castpd256_pd512(__m256d);
extern __m512d __cdecl _mm512_castps_pd(__m512);
extern __m512d __cdecl _mm512_castsi512_pd(__m512i);
extern __m512d __cdecl _mm512_castpd128_pd512(__m128d);

extern __m256i __cdecl _mm512_castsi512_si256(__m512i);
extern __m512i __cdecl _mm512_castpd_si512(__m512d);
extern __m512i __cdecl _mm512_castps_si512(__m512);
extern __m512i __cdecl _mm512_castsi256_si512(__m256i);

 





 
typedef enum {
    _MM_BROADCAST32_NONE,    

    _MM_BROADCAST_1X16,      
    _MM_BROADCAST_4X16       
} _MM_BROADCAST32_ENUM;

 
typedef enum {
    _MM_BROADCAST64_NONE,    

    _MM_BROADCAST_1X8,       
    _MM_BROADCAST_4X8        
} _MM_BROADCAST64_ENUM;






typedef enum {
    _MM_ROUND_MODE_NEAREST,              
    _MM_ROUND_MODE_DOWN,                 
    _MM_ROUND_MODE_UP,                   
    _MM_ROUND_MODE_TOWARD_ZERO,          
    _MM_ROUND_MODE_DEFAULT,              
    _MM_ROUND_MODE_NO_EXC = 8,           
} _MM_ROUND_MODE_ENUM;

 
typedef enum {
    _MM_EXPADJ_NONE,                
    _MM_EXPADJ_4,                   
    _MM_EXPADJ_5,                   
    _MM_EXPADJ_8,                   
    _MM_EXPADJ_16,                  
    _MM_EXPADJ_24,                  
    _MM_EXPADJ_31,                  
    _MM_EXPADJ_32                   
} _MM_EXP_ADJ_ENUM;

 
typedef enum {
    _MM_SCALE_1 = 1,
    _MM_SCALE_2 = 2,
    _MM_SCALE_4 = 4,
    _MM_SCALE_8 = 8
} _MM_INDEX_SCALE_ENUM;

 
typedef enum {
    _MM_PERM_AAAA = 0x00, _MM_PERM_AAAB = 0x01, _MM_PERM_AAAC = 0x02,
    _MM_PERM_AAAD = 0x03, _MM_PERM_AABA = 0x04, _MM_PERM_AABB = 0x05,
    _MM_PERM_AABC = 0x06, _MM_PERM_AABD = 0x07, _MM_PERM_AACA = 0x08,
    _MM_PERM_AACB = 0x09, _MM_PERM_AACC = 0x0A, _MM_PERM_AACD = 0x0B,
    _MM_PERM_AADA = 0x0C, _MM_PERM_AADB = 0x0D, _MM_PERM_AADC = 0x0E,
    _MM_PERM_AADD = 0x0F, _MM_PERM_ABAA = 0x10, _MM_PERM_ABAB = 0x11,
    _MM_PERM_ABAC = 0x12, _MM_PERM_ABAD = 0x13, _MM_PERM_ABBA = 0x14,
    _MM_PERM_ABBB = 0x15, _MM_PERM_ABBC = 0x16, _MM_PERM_ABBD = 0x17,
    _MM_PERM_ABCA = 0x18, _MM_PERM_ABCB = 0x19, _MM_PERM_ABCC = 0x1A,
    _MM_PERM_ABCD = 0x1B, _MM_PERM_ABDA = 0x1C, _MM_PERM_ABDB = 0x1D,
    _MM_PERM_ABDC = 0x1E, _MM_PERM_ABDD = 0x1F, _MM_PERM_ACAA = 0x20,
    _MM_PERM_ACAB = 0x21, _MM_PERM_ACAC = 0x22, _MM_PERM_ACAD = 0x23,
    _MM_PERM_ACBA = 0x24, _MM_PERM_ACBB = 0x25, _MM_PERM_ACBC = 0x26,
    _MM_PERM_ACBD = 0x27, _MM_PERM_ACCA = 0x28, _MM_PERM_ACCB = 0x29,
    _MM_PERM_ACCC = 0x2A, _MM_PERM_ACCD = 0x2B, _MM_PERM_ACDA = 0x2C,
    _MM_PERM_ACDB = 0x2D, _MM_PERM_ACDC = 0x2E, _MM_PERM_ACDD = 0x2F,
    _MM_PERM_ADAA = 0x30, _MM_PERM_ADAB = 0x31, _MM_PERM_ADAC = 0x32,
    _MM_PERM_ADAD = 0x33, _MM_PERM_ADBA = 0x34, _MM_PERM_ADBB = 0x35,
    _MM_PERM_ADBC = 0x36, _MM_PERM_ADBD = 0x37, _MM_PERM_ADCA = 0x38,
    _MM_PERM_ADCB = 0x39, _MM_PERM_ADCC = 0x3A, _MM_PERM_ADCD = 0x3B,
    _MM_PERM_ADDA = 0x3C, _MM_PERM_ADDB = 0x3D, _MM_PERM_ADDC = 0x3E,
    _MM_PERM_ADDD = 0x3F, _MM_PERM_BAAA = 0x40, _MM_PERM_BAAB = 0x41,
    _MM_PERM_BAAC = 0x42, _MM_PERM_BAAD = 0x43, _MM_PERM_BABA = 0x44,
    _MM_PERM_BABB = 0x45, _MM_PERM_BABC = 0x46, _MM_PERM_BABD = 0x47,
    _MM_PERM_BACA = 0x48, _MM_PERM_BACB = 0x49, _MM_PERM_BACC = 0x4A,
    _MM_PERM_BACD = 0x4B, _MM_PERM_BADA = 0x4C, _MM_PERM_BADB = 0x4D,
    _MM_PERM_BADC = 0x4E, _MM_PERM_BADD = 0x4F, _MM_PERM_BBAA = 0x50,
    _MM_PERM_BBAB = 0x51, _MM_PERM_BBAC = 0x52, _MM_PERM_BBAD = 0x53,
    _MM_PERM_BBBA = 0x54, _MM_PERM_BBBB = 0x55, _MM_PERM_BBBC = 0x56,
    _MM_PERM_BBBD = 0x57, _MM_PERM_BBCA = 0x58, _MM_PERM_BBCB = 0x59,
    _MM_PERM_BBCC = 0x5A, _MM_PERM_BBCD = 0x5B, _MM_PERM_BBDA = 0x5C,
    _MM_PERM_BBDB = 0x5D, _MM_PERM_BBDC = 0x5E, _MM_PERM_BBDD = 0x5F,
    _MM_PERM_BCAA = 0x60, _MM_PERM_BCAB = 0x61, _MM_PERM_BCAC = 0x62,
    _MM_PERM_BCAD = 0x63, _MM_PERM_BCBA = 0x64, _MM_PERM_BCBB = 0x65,
    _MM_PERM_BCBC = 0x66, _MM_PERM_BCBD = 0x67, _MM_PERM_BCCA = 0x68,
    _MM_PERM_BCCB = 0x69, _MM_PERM_BCCC = 0x6A, _MM_PERM_BCCD = 0x6B,
    _MM_PERM_BCDA = 0x6C, _MM_PERM_BCDB = 0x6D, _MM_PERM_BCDC = 0x6E,
    _MM_PERM_BCDD = 0x6F, _MM_PERM_BDAA = 0x70, _MM_PERM_BDAB = 0x71,
    _MM_PERM_BDAC = 0x72, _MM_PERM_BDAD = 0x73, _MM_PERM_BDBA = 0x74,
    _MM_PERM_BDBB = 0x75, _MM_PERM_BDBC = 0x76, _MM_PERM_BDBD = 0x77,
    _MM_PERM_BDCA = 0x78, _MM_PERM_BDCB = 0x79, _MM_PERM_BDCC = 0x7A,
    _MM_PERM_BDCD = 0x7B, _MM_PERM_BDDA = 0x7C, _MM_PERM_BDDB = 0x7D,
    _MM_PERM_BDDC = 0x7E, _MM_PERM_BDDD = 0x7F, _MM_PERM_CAAA = 0x80,
    _MM_PERM_CAAB = 0x81, _MM_PERM_CAAC = 0x82, _MM_PERM_CAAD = 0x83,
    _MM_PERM_CABA = 0x84, _MM_PERM_CABB = 0x85, _MM_PERM_CABC = 0x86,
    _MM_PERM_CABD = 0x87, _MM_PERM_CACA = 0x88, _MM_PERM_CACB = 0x89,
    _MM_PERM_CACC = 0x8A, _MM_PERM_CACD = 0x8B, _MM_PERM_CADA = 0x8C,
    _MM_PERM_CADB = 0x8D, _MM_PERM_CADC = 0x8E, _MM_PERM_CADD = 0x8F,
    _MM_PERM_CBAA = 0x90, _MM_PERM_CBAB = 0x91, _MM_PERM_CBAC = 0x92,
    _MM_PERM_CBAD = 0x93, _MM_PERM_CBBA = 0x94, _MM_PERM_CBBB = 0x95,
    _MM_PERM_CBBC = 0x96, _MM_PERM_CBBD = 0x97, _MM_PERM_CBCA = 0x98,
    _MM_PERM_CBCB = 0x99, _MM_PERM_CBCC = 0x9A, _MM_PERM_CBCD = 0x9B,
    _MM_PERM_CBDA = 0x9C, _MM_PERM_CBDB = 0x9D, _MM_PERM_CBDC = 0x9E,
    _MM_PERM_CBDD = 0x9F, _MM_PERM_CCAA = 0xA0, _MM_PERM_CCAB = 0xA1,
    _MM_PERM_CCAC = 0xA2, _MM_PERM_CCAD = 0xA3, _MM_PERM_CCBA = 0xA4,
    _MM_PERM_CCBB = 0xA5, _MM_PERM_CCBC = 0xA6, _MM_PERM_CCBD = 0xA7,
    _MM_PERM_CCCA = 0xA8, _MM_PERM_CCCB = 0xA9, _MM_PERM_CCCC = 0xAA,
    _MM_PERM_CCCD = 0xAB, _MM_PERM_CCDA = 0xAC, _MM_PERM_CCDB = 0xAD,
    _MM_PERM_CCDC = 0xAE, _MM_PERM_CCDD = 0xAF, _MM_PERM_CDAA = 0xB0,
    _MM_PERM_CDAB = 0xB1, _MM_PERM_CDAC = 0xB2, _MM_PERM_CDAD = 0xB3,
    _MM_PERM_CDBA = 0xB4, _MM_PERM_CDBB = 0xB5, _MM_PERM_CDBC = 0xB6,
    _MM_PERM_CDBD = 0xB7, _MM_PERM_CDCA = 0xB8, _MM_PERM_CDCB = 0xB9,
    _MM_PERM_CDCC = 0xBA, _MM_PERM_CDCD = 0xBB, _MM_PERM_CDDA = 0xBC,
    _MM_PERM_CDDB = 0xBD, _MM_PERM_CDDC = 0xBE, _MM_PERM_CDDD = 0xBF,
    _MM_PERM_DAAA = 0xC0, _MM_PERM_DAAB = 0xC1, _MM_PERM_DAAC = 0xC2,
    _MM_PERM_DAAD = 0xC3, _MM_PERM_DABA = 0xC4, _MM_PERM_DABB = 0xC5,
    _MM_PERM_DABC = 0xC6, _MM_PERM_DABD = 0xC7, _MM_PERM_DACA = 0xC8,
    _MM_PERM_DACB = 0xC9, _MM_PERM_DACC = 0xCA, _MM_PERM_DACD = 0xCB,
    _MM_PERM_DADA = 0xCC, _MM_PERM_DADB = 0xCD, _MM_PERM_DADC = 0xCE,
    _MM_PERM_DADD = 0xCF, _MM_PERM_DBAA = 0xD0, _MM_PERM_DBAB = 0xD1,
    _MM_PERM_DBAC = 0xD2, _MM_PERM_DBAD = 0xD3, _MM_PERM_DBBA = 0xD4,
    _MM_PERM_DBBB = 0xD5, _MM_PERM_DBBC = 0xD6, _MM_PERM_DBBD = 0xD7,
    _MM_PERM_DBCA = 0xD8, _MM_PERM_DBCB = 0xD9, _MM_PERM_DBCC = 0xDA,
    _MM_PERM_DBCD = 0xDB, _MM_PERM_DBDA = 0xDC, _MM_PERM_DBDB = 0xDD,
    _MM_PERM_DBDC = 0xDE, _MM_PERM_DBDD = 0xDF, _MM_PERM_DCAA = 0xE0,
    _MM_PERM_DCAB = 0xE1, _MM_PERM_DCAC = 0xE2, _MM_PERM_DCAD = 0xE3,
    _MM_PERM_DCBA = 0xE4, _MM_PERM_DCBB = 0xE5, _MM_PERM_DCBC = 0xE6,
    _MM_PERM_DCBD = 0xE7, _MM_PERM_DCCA = 0xE8, _MM_PERM_DCCB = 0xE9,
    _MM_PERM_DCCC = 0xEA, _MM_PERM_DCCD = 0xEB, _MM_PERM_DCDA = 0xEC,
    _MM_PERM_DCDB = 0xED, _MM_PERM_DCDC = 0xEE, _MM_PERM_DCDD = 0xEF,
    _MM_PERM_DDAA = 0xF0, _MM_PERM_DDAB = 0xF1, _MM_PERM_DDAC = 0xF2,
    _MM_PERM_DDAD = 0xF3, _MM_PERM_DDBA = 0xF4, _MM_PERM_DDBB = 0xF5,
    _MM_PERM_DDBC = 0xF6, _MM_PERM_DDBD = 0xF7, _MM_PERM_DDCA = 0xF8,
    _MM_PERM_DDCB = 0xF9, _MM_PERM_DDCC = 0xFA, _MM_PERM_DDCD = 0xFB,
    _MM_PERM_DDDA = 0xFC, _MM_PERM_DDDB = 0xFD, _MM_PERM_DDDC = 0xFE,
    _MM_PERM_DDDD = 0xFF
} _MM_PERM_ENUM;





typedef enum {
    _MM_FIXUP_NO_CHANGE,
    _MM_FIXUP_NEG_INF,
    _MM_FIXUP_NEG_ZERO,
    _MM_FIXUP_POS_ZERO,
    _MM_FIXUP_POS_INF,
    _MM_FIXUP_NAN,
    _MM_FIXUP_MAX_FLOAT,
    _MM_FIXUP_MIN_FLOAT
} _MM_FIXUPRESULT_ENUM;














 
typedef enum {
    _MM_MANT_NORM_1_2,       
    _MM_MANT_NORM_p5_2,      
    _MM_MANT_NORM_p5_1,      
    _MM_MANT_NORM_p75_1p5    
} _MM_MANTISSA_NORM_ENUM;

typedef enum {
    _MM_MANT_SIGN_src,       
    _MM_MANT_SIGN_zero,      
    _MM_MANT_SIGN_nan        
} _MM_MANTISSA_SIGN_ENUM;





 
typedef enum {
    _MM_CMPINT_EQ,       
    _MM_CMPINT_LT,       
    _MM_CMPINT_LE,       
    _MM_CMPINT_UNUSED,
    _MM_CMPINT_NE,       
    _MM_CMPINT_NLT,      

    _MM_CMPINT_NLE       

} _MM_CMPINT_ENUM;





extern __m512  __cdecl _mm512_setzero_ps(void);
extern __m512d __cdecl _mm512_setzero_pd(void);

extern __m512  __cdecl _mm512_set_ps(float  , float, float, float, float, float, float, float, float, float, float, float, float, float, float, float  );
extern __m512d __cdecl _mm512_set_pd(double  , double, double, double, double, double, double, double  );

extern __m512  __cdecl _mm512_setr_ps(float  , float, float, float, float, float, float, float, float, float, float, float, float, float, float, float  );
extern __m512d __cdecl _mm512_setr_pd(double  , double, double, double, double, double, double, double  );

extern __m512  __cdecl _mm512_set1_ps(float);
extern __m512d __cdecl _mm512_set1_pd(double);

extern __m512  __cdecl _mm512_load_ps(void const*);
extern __m512d __cdecl _mm512_load_pd(void const*);
extern __m512  __cdecl _mm512_maskz_load_ps(__mmask16, void const*);
extern __m512d __cdecl _mm512_maskz_load_pd(__mmask8, void const*);
extern __m512  __cdecl _mm512_mask_load_ps(__m512, __mmask16, void const*);
extern __m512d __cdecl _mm512_mask_load_pd(__m512d, __mmask8, void const*);
extern __m512  __cdecl _mm512_loadu_ps(void const*);
extern __m512d __cdecl _mm512_loadu_pd(void const*);
extern __m512  __cdecl _mm512_maskz_loadu_ps(__mmask16, void const*);
extern __m512d __cdecl _mm512_maskz_loadu_pd(__mmask8, void const*);
extern __m512  __cdecl _mm512_mask_loadu_ps(__m512, __mmask16, void const*);
extern __m512d __cdecl _mm512_mask_loadu_pd(__m512d, __mmask8, void const*);

extern void    __cdecl _mm512_store_ps(void*, __m512);
extern void    __cdecl _mm512_store_pd(void*, __m512d);
extern void    __cdecl _mm512_storeu_ps(void*, __m512);
extern void    __cdecl _mm512_storeu_pd(void*, __m512d);
extern void    __cdecl _mm512_mask_store_ps(void*, __mmask16, __m512);
extern void    __cdecl _mm512_mask_store_pd(void*, __mmask8, __m512d);
extern void    __cdecl _mm512_mask_storeu_ps(void*, __mmask16, __m512);
extern void    __cdecl _mm512_mask_storeu_pd(void*, __mmask8, __m512d);

extern __m512  __cdecl _mm512_add_ps(__m512, __m512);
extern __m512  __cdecl _mm512_maskz_add_ps(__mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_mask_add_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_add_round_ps(__m512, __m512, const int  );
extern __m512  __cdecl _mm512_maskz_add_round_ps(__mmask16, __m512, __m512, const int  );
extern __m512  __cdecl _mm512_mask_add_round_ps(__m512, __mmask16, __m512, __m512, const int  );
extern __m512d __cdecl _mm512_add_pd(__m512d, __m512d);
extern __m512d __cdecl _mm512_maskz_add_pd(__mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask_add_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_add_round_pd(__m512d, __m512d, const int  );
extern __m512d __cdecl _mm512_maskz_add_round_pd(__mmask8, __m512d, __m512d, const int  );
extern __m512d __cdecl _mm512_mask_add_round_pd(__m512d, __mmask8, __m512d, __m512d, const int  );

extern __m512  __cdecl _mm512_sub_ps(__m512, __m512);
extern __m512  __cdecl _mm512_maskz_sub_ps(__mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_mask_sub_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_sub_round_ps(__m512, __m512, const int  );
extern __m512  __cdecl _mm512_maskz_sub_round_ps(__mmask16, __m512, __m512, const int  );
extern __m512  __cdecl _mm512_mask_sub_round_ps(__m512, __mmask16, __m512, __m512, const int  );
extern __m512d __cdecl _mm512_sub_pd(__m512d, __m512d);
extern __m512d __cdecl _mm512_maskz_sub_pd(__mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask_sub_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_sub_round_pd(__m512d, __m512d, const int  );
extern __m512d __cdecl _mm512_maskz_sub_round_pd(__mmask8, __m512d, __m512d, const int  );
extern __m512d __cdecl _mm512_mask_sub_round_pd(__m512d, __mmask8, __m512d, __m512d, const int  );

extern __m512  __cdecl _mm512_mul_ps(__m512, __m512);
extern __m512  __cdecl _mm512_maskz_mul_ps(__mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_mask_mul_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_mul_round_ps( __m512, __m512, const int  );
extern __m512  __cdecl _mm512_maskz_mul_round_ps(__mmask16, __m512, __m512, const int  );
extern __m512  __cdecl _mm512_mask_mul_round_ps(__m512, __mmask16, __m512, __m512, const int  );
extern __m512d __cdecl _mm512_mul_pd(__m512d, __m512d);
extern __m512d __cdecl _mm512_maskz_mul_pd(__mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask_mul_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_mul_round_pd(__m512d, __m512d, const int  );
extern __m512d __cdecl _mm512_maskz_mul_round_pd(__mmask8, __m512d, __m512d, const int  );
extern __m512d __cdecl _mm512_mask_mul_round_pd(__m512d, __mmask8, __m512d, __m512d, const int  );

extern __m512  __cdecl _mm512_div_ps(__m512, __m512);
extern __m512  __cdecl _mm512_maskz_div_ps(__mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_mask_div_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_div_round_ps(__m512, __m512, const int  );
extern __m512  __cdecl _mm512_maskz_div_round_ps(__mmask16, __m512, __m512, const int  );
extern __m512  __cdecl _mm512_mask_div_round_ps(__m512, __mmask16, __m512, __m512, const int  );
extern __m512d __cdecl _mm512_div_pd(__m512d, __m512d);
extern __m512d __cdecl _mm512_maskz_div_pd(__mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask_div_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_div_round_pd(__m512d, __m512d, const int  );
extern __m512d __cdecl _mm512_maskz_div_round_pd(__mmask8, __m512d, __m512d, const int  );
extern __m512d __cdecl _mm512_mask_div_round_pd(__m512d, __mmask8, __m512d, __m512d, const int  );

extern __m512  __cdecl _mm512_fmadd_ps(__m512, __m512, __m512);
extern __m512  __cdecl _mm512_mask_fmadd_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_mask3_fmadd_ps(__m512, __m512, __m512, __mmask16);
extern __m512  __cdecl _mm512_maskz_fmadd_ps(__mmask16, __m512, __m512, __m512);
extern __m512  __cdecl _mm512_fmadd_round_ps(__m512, __m512, __m512, const int  );
extern __m512  __cdecl _mm512_mask_fmadd_round_ps(__m512, __mmask16, __m512, __m512, const int  );
extern __m512  __cdecl _mm512_mask3_fmadd_round_ps(__m512, __m512, __m512, __mmask16, const int  );
extern __m512  __cdecl _mm512_maskz_fmadd_round_ps(__mmask16, __m512, __m512, __m512, const int  );
extern __m512d __cdecl _mm512_fmadd_pd(__m512d, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask_fmadd_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask3_fmadd_pd(__m512d, __m512d, __m512d, __mmask8);
extern __m512d __cdecl _mm512_maskz_fmadd_pd(__mmask8, __m512d, __m512d, __m512d);
extern __m512d __cdecl _mm512_fmadd_round_pd(__m512d, __m512d, __m512d, const int  );
extern __m512d __cdecl _mm512_mask_fmadd_round_pd(__m512d, __mmask8, __m512d, __m512d, const int  );
extern __m512d __cdecl _mm512_mask3_fmadd_round_pd(__m512d, __m512d, __m512d, __mmask8, const int  );
extern __m512d __cdecl _mm512_maskz_fmadd_round_pd(__mmask8, __m512d, __m512d, __m512d, const int  );

extern __m512  __cdecl _mm512_fmsub_ps(__m512, __m512, __m512);
extern __m512  __cdecl _mm512_mask_fmsub_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_mask3_fmsub_ps(__m512, __m512, __m512, __mmask16);
extern __m512  __cdecl _mm512_maskz_fmsub_ps(__mmask16, __m512, __m512, __m512);
extern __m512  __cdecl _mm512_fmsub_round_ps(__m512, __m512, __m512, const int  );
extern __m512  __cdecl _mm512_mask_fmsub_round_ps(__m512, __mmask16, __m512, __m512, const int  );
extern __m512  __cdecl _mm512_mask3_fmsub_round_ps(__m512, __m512, __m512, __mmask16, const int  );
extern __m512  __cdecl _mm512_maskz_fmsub_round_ps(__mmask16, __m512, __m512, __m512, const int  );
extern __m512d __cdecl _mm512_fmsub_pd(__m512d, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask_fmsub_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask3_fmsub_pd(__m512d, __m512d, __m512d, __mmask8);
extern __m512d __cdecl _mm512_maskz_fmsub_pd(__mmask8, __m512d, __m512d, __m512d);
extern __m512d __cdecl _mm512_fmsub_round_pd(__m512d, __m512d, __m512d, const int  );
extern __m512d __cdecl _mm512_mask_fmsub_round_pd(__m512d, __mmask8, __m512d, __m512d, const int  );
extern __m512d __cdecl _mm512_mask3_fmsub_round_pd(__m512d, __m512d, __m512d, __mmask8, const int  );
extern __m512d __cdecl _mm512_maskz_fmsub_round_pd(__mmask8, __m512d, __m512d, __m512d, const int  );

extern __m512  __cdecl _mm512_fmaddsub_ps(__m512, __m512, __m512);
extern __m512  __cdecl _mm512_mask_fmaddsub_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_mask3_fmaddsub_ps(__m512, __m512, __m512, __mmask16);
extern __m512  __cdecl _mm512_maskz_fmaddsub_ps(__mmask16, __m512, __m512, __m512);
extern __m512  __cdecl _mm512_fmaddsub_round_ps(__m512, __m512, __m512, const int  );
extern __m512  __cdecl _mm512_mask_fmaddsub_round_ps(__m512, __mmask16, __m512, __m512, const int  );
extern __m512  __cdecl _mm512_mask3_fmaddsub_round_ps(__m512, __m512, __m512, __mmask16, const int  );
extern __m512  __cdecl _mm512_maskz_fmaddsub_round_ps(__mmask16, __m512, __m512, __m512, const int  );
extern __m512d __cdecl _mm512_fmaddsub_pd(__m512d, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask_fmaddsub_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask3_fmaddsub_pd(__m512d, __m512d, __m512d, __mmask8);
extern __m512d __cdecl _mm512_maskz_fmaddsub_pd(__mmask8, __m512d, __m512d, __m512d);
extern __m512d __cdecl _mm512_fmaddsub_round_pd(__m512d, __m512d, __m512d, const int  );
extern __m512d __cdecl _mm512_mask_fmaddsub_round_pd(__m512d, __mmask8, __m512d, __m512d, const int  );
extern __m512d __cdecl _mm512_mask3_fmaddsub_round_pd(__m512d, __m512d, __m512d, __mmask8, const int  );
extern __m512d __cdecl _mm512_maskz_fmaddsub_round_pd(__mmask8, __m512d, __m512d, __m512d, const int  );

extern __m512  __cdecl _mm512_fmsubadd_ps(__m512, __m512, __m512);
extern __m512  __cdecl _mm512_mask_fmsubadd_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_mask3_fmsubadd_ps(__m512, __m512, __m512, __mmask16);
extern __m512  __cdecl _mm512_maskz_fmsubadd_ps(__mmask16, __m512, __m512, __m512);
extern __m512  __cdecl _mm512_fmsubadd_round_ps(__m512, __m512, __m512, const int  );
extern __m512  __cdecl _mm512_mask_fmsubadd_round_ps(__m512, __mmask16, __m512, __m512, const int  );
extern __m512  __cdecl _mm512_mask3_fmsubadd_round_ps(__m512, __m512, __m512, __mmask16, const int  );
extern __m512  __cdecl _mm512_maskz_fmsubadd_round_ps(__mmask16, __m512, __m512, __m512, const int  );
extern __m512d __cdecl _mm512_fmsubadd_pd(__m512d, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask_fmsubadd_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask3_fmsubadd_pd(__m512d, __m512d, __m512d, __mmask8);
extern __m512d __cdecl _mm512_maskz_fmsubadd_pd(__mmask8, __m512d, __m512d, __m512d);
extern __m512d __cdecl _mm512_fmsubadd_round_pd(__m512d, __m512d, __m512d, const int  );
extern __m512d __cdecl _mm512_mask_fmsubadd_round_pd(__m512d, __mmask8, __m512d, __m512d, const int  );
extern __m512d __cdecl _mm512_mask3_fmsubadd_round_pd(__m512d, __m512d, __m512d, __mmask8, const int  );
extern __m512d __cdecl _mm512_maskz_fmsubadd_round_pd(__mmask8, __m512d, __m512d, __m512d, const int  );

extern __m512  __cdecl _mm512_fnmadd_ps(__m512, __m512, __m512);
extern __m512  __cdecl _mm512_mask_fnmadd_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_mask3_fnmadd_ps(__m512, __m512, __m512, __mmask16);
extern __m512  __cdecl _mm512_maskz_fnmadd_ps(__mmask16, __m512, __m512, __m512);
extern __m512  __cdecl _mm512_fnmadd_round_ps(__m512, __m512, __m512, const int  );
extern __m512  __cdecl _mm512_mask_fnmadd_round_ps(__m512, __mmask16, __m512, __m512, const int  );
extern __m512  __cdecl _mm512_mask3_fnmadd_round_ps(__m512, __m512, __m512, __mmask16, const int  );
extern __m512  __cdecl _mm512_maskz_fnmadd_round_ps(__mmask16, __m512, __m512, __m512, const int  );
extern __m512d __cdecl _mm512_fnmadd_pd(__m512d, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask_fnmadd_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask3_fnmadd_pd(__m512d, __m512d, __m512d, __mmask8);
extern __m512d __cdecl _mm512_maskz_fnmadd_pd(__mmask8, __m512d, __m512d, __m512d);
extern __m512d __cdecl _mm512_fnmadd_round_pd(__m512d, __m512d, __m512d, const int  );
extern __m512d __cdecl _mm512_mask_fnmadd_round_pd(__m512d, __mmask8, __m512d, __m512d, const int  );
extern __m512d __cdecl _mm512_mask3_fnmadd_round_pd(__m512d, __m512d, __m512d, __mmask8, const int  );
extern __m512d __cdecl _mm512_maskz_fnmadd_round_pd(__mmask8, __m512d, __m512d, __m512d, const int  );

extern __m512  __cdecl _mm512_fnmsub_ps(__m512, __m512, __m512);
extern __m512  __cdecl _mm512_mask_fnmsub_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_mask3_fnmsub_ps(__m512, __m512, __m512, __mmask16);
extern __m512  __cdecl _mm512_maskz_fnmsub_ps(__mmask16, __m512, __m512, __m512);
extern __m512  __cdecl _mm512_fnmsub_round_ps(__m512, __m512, __m512, const int  );
extern __m512  __cdecl _mm512_mask_fnmsub_round_ps(__m512, __mmask16, __m512, __m512, const int  );
extern __m512  __cdecl _mm512_mask3_fnmsub_round_ps(__m512, __m512, __m512, __mmask16, const int  );
extern __m512  __cdecl _mm512_maskz_fnmsub_round_ps(__mmask16, __m512, __m512, __m512, const int  );
extern __m512d __cdecl _mm512_fnmsub_pd(__m512d, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask_fnmsub_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask3_fnmsub_pd(__m512d, __m512d, __m512d, __mmask8);
extern __m512d __cdecl _mm512_maskz_fnmsub_pd(__mmask8, __m512d, __m512d, __m512d);
extern __m512d __cdecl _mm512_fnmsub_round_pd(__m512d, __m512d, __m512d, const int  );
extern __m512d __cdecl _mm512_mask_fnmsub_round_pd(__m512d, __mmask8, __m512d, __m512d, const int  );
extern __m512d __cdecl _mm512_mask3_fnmsub_round_pd(__m512d, __m512d, __m512d, __mmask8, const int  );
extern __m512d __cdecl _mm512_maskz_fnmsub_round_pd(__mmask8, __m512d, __m512d, __m512d, const int  );

extern __m512  __cdecl _mm512_sqrt_ps(__m512);
extern __m512d __cdecl _mm512_sqrt_pd(__m512d);
extern __m512  __cdecl _mm512_maskz_sqrt_ps(__mmask16, __m512);
extern __m512d __cdecl _mm512_maskz_sqrt_pd(__mmask8, __m512d);
extern __m512  __cdecl _mm512_mask_sqrt_ps(__m512, __mmask16, __m512);
extern __m512d __cdecl _mm512_mask_sqrt_pd(__m512d, __mmask8, __m512d);
extern __m512  __cdecl _mm512_sqrt_round_ps(__m512, const int  );
extern __m512d __cdecl _mm512_sqrt_round_pd(__m512d, const int  );
extern __m512  __cdecl _mm512_maskz_sqrt_round_ps(__mmask16, __m512, const int  );
extern __m512d __cdecl _mm512_maskz_sqrt_round_pd(__mmask8, __m512d, const int  );
extern __m512  __cdecl _mm512_mask_sqrt_round_ps(__m512, __mmask16, __m512, const int  );
extern __m512d __cdecl _mm512_mask_sqrt_round_pd(__m512d, __mmask8, __m512d, const int  );

extern __m512  __cdecl _mm512_abs_ps(__m512);
extern __m512  __cdecl _mm512_maskz_abs_ps(__mmask16, __m512);
extern __m512  __cdecl _mm512_mask_abs_ps(__m512, __mmask16, __m512);
extern __m512d __cdecl _mm512_abs_pd(__m512d);
extern __m512d __cdecl _mm512_maskz_abs_pd(__mmask8, __m512d);
extern __m512d __cdecl _mm512_mask_abs_pd(__m512d, __mmask8, __m512d);

extern __m512  __cdecl _mm512_max_ps(__m512, __m512);
extern __m512d __cdecl _mm512_max_pd(__m512d, __m512d);
extern __m512  __cdecl _mm512_maskz_max_ps(__mmask16, __m512, __m512);
extern __m512d __cdecl _mm512_maskz_max_pd(__mmask8, __m512d, __m512d);
extern __m512  __cdecl _mm512_mask_max_ps(__m512, __mmask16, __m512, __m512);
extern __m512d __cdecl _mm512_mask_max_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512  __cdecl _mm512_max_round_ps(__m512, __m512, const int  );
extern __m512d __cdecl _mm512_max_round_pd(__m512d, __m512d, const int  );
extern __m512  __cdecl _mm512_maskz_max_round_ps(__mmask16, __m512, __m512, const int  );
extern __m512d __cdecl _mm512_maskz_max_round_pd(__mmask8, __m512d, __m512d, const int  );
extern __m512  __cdecl _mm512_mask_max_round_ps(__m512, __mmask16, __m512, __m512, const int  );
extern __m512d __cdecl _mm512_mask_max_round_pd(__m512d, __mmask8, __m512d, __m512d, const int  );

extern __m512  __cdecl _mm512_min_ps(__m512, __m512);
extern __m512d __cdecl _mm512_min_pd(__m512d, __m512d);
extern __m512  __cdecl _mm512_maskz_min_ps(__mmask16, __m512, __m512);
extern __m512d __cdecl _mm512_maskz_min_pd(__mmask8, __m512d, __m512d);
extern __m512  __cdecl _mm512_mask_min_ps(__m512, __mmask16, __m512, __m512);
extern __m512d __cdecl _mm512_mask_min_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512  __cdecl _mm512_min_round_ps(__m512, __m512, const int  );
extern __m512d __cdecl _mm512_min_round_pd(__m512d, __m512d, const int  );
extern __m512  __cdecl _mm512_maskz_min_round_ps(__mmask16, __m512, __m512, const int  );
extern __m512d __cdecl _mm512_maskz_min_round_pd(__mmask8, __m512d, __m512d, const int  );
extern __m512  __cdecl _mm512_mask_min_round_ps(__m512, __mmask16, __m512, __m512, const int  );
extern __m512d __cdecl _mm512_mask_min_round_pd(__m512d, __mmask8, __m512d, __m512d, const int  );

extern __m512  __cdecl _mm512_rcp14_ps(__m512);
extern __m512d __cdecl _mm512_rcp14_pd(__m512d);
extern __m512  __cdecl _mm512_maskz_rcp14_ps(__mmask16, __m512);
extern __m512d __cdecl _mm512_maskz_rcp14_pd(__mmask8, __m512d);
extern __m512  __cdecl _mm512_mask_rcp14_ps(__m512, __mmask16, __m512);
extern __m512d __cdecl _mm512_mask_rcp14_pd(__m512d, __mmask8, __m512d);

extern __m512  __cdecl _mm512_rsqrt14_ps(__m512);
extern __m512d __cdecl _mm512_rsqrt14_pd(__m512d);
extern __m512  __cdecl _mm512_maskz_rsqrt14_ps(__mmask16, __m512);
extern __m512d __cdecl _mm512_maskz_rsqrt14_pd(__mmask8, __m512d);
extern __m512  __cdecl _mm512_mask_rsqrt14_ps(__m512, __mmask16, __m512);
extern __m512d __cdecl _mm512_mask_rsqrt14_pd(__m512d, __mmask8, __m512d);

extern __m512d __cdecl _mm512_cvtps_pd(__m256);
extern __m256  __cdecl _mm512_cvtpd_ps(__m512d);
extern __m512d __cdecl _mm512_maskz_cvtps_pd(__mmask8, __m256);
extern __m256  __cdecl _mm512_maskz_cvtpd_ps(__mmask8, __m512d);
extern __m512d __cdecl _mm512_mask_cvtps_pd(__m512d, __mmask8, __m256);
extern __m256  __cdecl _mm512_mask_cvtpd_ps(__m256, __mmask8, __m512d);
extern __m512d __cdecl _mm512_cvt_roundps_pd(__m256, const int  );
extern __m256  __cdecl _mm512_cvt_roundpd_ps(__m512d, const int  );
extern __m512d __cdecl _mm512_maskz_cvt_roundps_pd(__mmask8, __m256, const int  );
extern __m256  __cdecl _mm512_maskz_cvt_roundpd_ps(__mmask8, __m512d, const int  );
extern __m512d __cdecl _mm512_mask_cvt_roundps_pd(__m512d, __mmask8, __m256, const int  );
extern __m256  __cdecl _mm512_mask_cvt_roundpd_ps(__m256, __mmask8, __m512d, const int  );

extern __mmask16 __cdecl _mm512_cmp_ps_mask(__m512, __m512, const int);
extern __mmask16 __cdecl _mm512_mask_cmp_ps_mask(__mmask16, __m512, __m512, const int);
extern __mmask16 __cdecl _mm512_cmp_round_ps_mask(__m512, __m512, const int, const int  );
extern __mmask16 __cdecl _mm512_mask_cmp_round_ps_mask(__mmask16, __m512, __m512, const int, const int  );
extern __mmask8  __cdecl _mm512_cmp_pd_mask(__m512d, __m512d, const int);
extern __mmask8  __cdecl _mm512_mask_cmp_pd_mask(__mmask8, __m512d, __m512d, const int);
extern __mmask8  __cdecl _mm512_cmp_round_pd_mask(__m512d, __m512d, const int, const int  );
extern __mmask8  __cdecl _mm512_mask_cmp_round_pd_mask(__mmask8, __m512d, __m512d, const int, const int  );

extern __m512  __cdecl _mm512_broadcast_f32x2(__m128);
extern __m512  __cdecl _mm512_mask_broadcast_f32x2(__m512, __mmask16, __m128);
extern __m512  __cdecl _mm512_maskz_broadcast_f32x2(__mmask16, __m128);
extern __m512  __cdecl _mm512_broadcast_f32x4(__m128);
extern __m512  __cdecl _mm512_mask_broadcast_f32x4(__m512, __mmask16, __m128);
extern __m512  __cdecl _mm512_maskz_broadcast_f32x4(__mmask16, __m128);
extern __m512  __cdecl _mm512_broadcast_f32x8(__m256);
extern __m512  __cdecl _mm512_mask_broadcast_f32x8(__m512, __mmask16, __m256);
extern __m512  __cdecl _mm512_maskz_broadcast_f32x8(__mmask16, __m256);
extern __m512d __cdecl _mm512_broadcast_f64x2(__m128d);
extern __m512d __cdecl _mm512_mask_broadcast_f64x2(__m512d, __mmask8, __m128d);
extern __m512d __cdecl _mm512_maskz_broadcast_f64x2(__mmask8, __m128d);
extern __m512d __cdecl _mm512_broadcast_f64x4(__m256d);
extern __m512d __cdecl _mm512_mask_broadcast_f64x4(__m512d, __mmask8, __m256d);
extern __m512d __cdecl _mm512_maskz_broadcast_f64x4(__mmask8, __m256d);
extern __m512d __cdecl _mm512_broadcastsd_pd(__m128d);
extern __m512d __cdecl _mm512_mask_broadcastsd_pd(__m512d, __mmask8, __m128d);
extern __m512d __cdecl _mm512_maskz_broadcastsd_pd(__mmask8, __m128d);
extern __m512  __cdecl _mm512_broadcastss_ps(__m128);
extern __m512  __cdecl _mm512_mask_broadcastss_ps(__m512, __mmask16, __m128);
extern __m512  __cdecl _mm512_maskz_broadcastss_ps(__mmask16, __m128);

extern __m128  __cdecl _mm512_extractf32x4_ps(__m512, int);
extern __m128  __cdecl _mm512_mask_extractf32x4_ps(__m128, __mmask8, __m512, const int);
extern __m128  __cdecl _mm512_maskz_extractf32x4_ps(__mmask8, __m512, int);
extern __m256  __cdecl _mm512_extractf32x8_ps(__m512, int);
extern __m256  __cdecl _mm512_mask_extractf32x8_ps(__m256, __mmask8, __m512, const int);
extern __m256  __cdecl _mm512_maskz_extractf32x8_ps(__mmask8, __m512, int);
extern __m128d __cdecl _mm512_extractf64x2_pd(__m512d, int);
extern __m128d __cdecl _mm512_mask_extractf64x2_pd(__m128d, __mmask8, __m512d, const int);
extern __m128d __cdecl _mm512_maskz_extractf64x2_pd(__mmask8, __m512d, int);
extern __m256d __cdecl _mm512_extractf64x4_pd(__m512d, int);
extern __m256d __cdecl _mm512_mask_extractf64x4_pd(__m256d, __mmask8, __m512d, const int);
extern __m256d __cdecl _mm512_maskz_extractf64x4_pd(__mmask8, __m512d, int);

extern __m512  __cdecl _mm512_insertf32x4(__m512, __m128, int);
extern __m512  __cdecl _mm512_mask_insertf32x4(__m512, __mmask16, __m512, __m128, const int);
extern __m512  __cdecl _mm512_maskz_insertf32x4(__mmask16, __m512, __m128, int);
extern __m512  __cdecl _mm512_insertf32x8(__m512, __m256, int);
extern __m512  __cdecl _mm512_mask_insertf32x8(__m512, __mmask16, __m512, __m256, const int);
extern __m512  __cdecl _mm512_maskz_insertf32x8(__mmask16, __m512, __m256, int);
extern __m512d __cdecl _mm512_insertf64x2(__m512d, __m128d, int);
extern __m512d __cdecl _mm512_mask_insertf64x2(__m512d, __mmask8, __m512d, __m128d, const int);
extern __m512d __cdecl _mm512_maskz_insertf64x2(__mmask8, __m512d, __m128d, int);
extern __m512d __cdecl _mm512_insertf64x4(__m512d, __m256d, int);
extern __m512d __cdecl _mm512_mask_insertf64x4(__m512d, __mmask8, __m512d, __m256d, const int);
extern __m512d __cdecl _mm512_maskz_insertf64x4(__mmask8, __m512d, __m256d, int);

extern __m512  __cdecl _mm512_shuffle_f32x4(__m512, __m512, const int);
extern __m512  __cdecl _mm512_mask_shuffle_f32x4(__m512, __mmask16, __m512, __m512, const int);
extern __m512  __cdecl _mm512_maskz_shuffle_f32x4(__mmask16, __m512, __m512, const int);
extern __m512d __cdecl _mm512_shuffle_f64x2(__m512d, __m512d, const int);
extern __m512d __cdecl _mm512_mask_shuffle_f64x2(__m512d, __mmask8, __m512d, __m512d, const int);
extern __m512d __cdecl _mm512_maskz_shuffle_f64x2(__mmask8, __m512d, __m512d, const int);
extern __m512d __cdecl _mm512_shuffle_pd(__m512d, __m512d, const int);
extern __m512d __cdecl _mm512_mask_shuffle_pd(__m512d, __mmask8, __m512d, __m512d, const int);
extern __m512d __cdecl _mm512_maskz_shuffle_pd(__mmask8, __m512d, __m512d, const int);
extern __m512  __cdecl _mm512_shuffle_ps(__m512, __m512, const int);
extern __m512  __cdecl _mm512_mask_shuffle_ps(__m512, __mmask16, __m512, __m512, const int);
extern __m512  __cdecl _mm512_maskz_shuffle_ps(__mmask16, __m512, __m512, const int);

extern __mmask16 _mm512_cmpeq_ps_mask(__m512, __m512);
extern __mmask16 _mm512_cmple_ps_mask(__m512, __m512);
extern __mmask16 _mm512_cmplt_ps_mask(__m512, __m512);
extern __mmask16 _mm512_cmpneq_ps_mask(__m512, __m512);
extern __mmask16 _mm512_cmpnle_ps_mask(__m512, __m512);
extern __mmask16 _mm512_cmpnlt_ps_mask(__m512, __m512);
extern __mmask16 _mm512_cmpord_ps_mask(__m512, __m512);
extern __mmask16 _mm512_cmpunord_ps_mask(__m512, __m512);

extern __mmask16 _mm512_mask_cmpeq_ps_mask(__mmask16, __m512, __m512);
extern __mmask16 _mm512_mask_cmple_ps_mask(__mmask16, __m512, __m512);
extern __mmask16 _mm512_mask_cmplt_ps_mask(__mmask16, __m512, __m512);
extern __mmask16 _mm512_mask_cmpneq_ps_mask(__mmask16, __m512, __m512);
extern __mmask16 _mm512_mask_cmpnle_ps_mask(__mmask16, __m512, __m512);
extern __mmask16 _mm512_mask_cmpnlt_ps_mask(__mmask16, __m512, __m512);
extern __mmask16 _mm512_mask_cmpord_ps_mask(__mmask16, __m512, __m512);
extern __mmask16 _mm512_mask_cmpunord_ps_mask(__mmask16, __m512, __m512);

extern __mmask8 _mm512_cmpeq_pd_mask(__m512d, __m512d);
extern __mmask8 _mm512_cmple_pd_mask(__m512d, __m512d);
extern __mmask8 _mm512_cmplt_pd_mask(__m512d, __m512d);
extern __mmask8 _mm512_cmpneq_pd_mask(__m512d, __m512d);
extern __mmask8 _mm512_cmpnle_pd_mask(__m512d, __m512d);
extern __mmask8 _mm512_cmpnlt_pd_mask(__m512d, __m512d);
extern __mmask8 _mm512_cmpord_pd_mask(__m512d, __m512d);
extern __mmask8 _mm512_cmpunord_pd_mask(__m512d, __m512d);

extern __mmask8 _mm512_mask_cmpeq_pd_mask(__mmask8, __m512d, __m512d);
extern __mmask8 _mm512_mask_cmple_pd_mask(__mmask8, __m512d, __m512d);
extern __mmask8 _mm512_mask_cmplt_pd_mask(__mmask8, __m512d, __m512d);
extern __mmask8 _mm512_mask_cmpneq_pd_mask(__mmask8, __m512d, __m512d);
extern __mmask8 _mm512_mask_cmpnle_pd_mask(__mmask8, __m512d, __m512d);
extern __mmask8 _mm512_mask_cmpnlt_pd_mask(__mmask8, __m512d, __m512d);
extern __mmask8 _mm512_mask_cmpord_pd_mask(__mmask8, __m512d, __m512d);
extern __mmask8 _mm512_mask_cmpunord_pd_mask(__mmask8, __m512d, __m512d);




































extern __m512i __cdecl _mm512_setzero_si512(void);

extern __m512i __cdecl _mm512_set_epi8(char  , char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char  );
extern __m512i __cdecl _mm512_set_epi16(short  , short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short  );
extern __m512i __cdecl _mm512_set_epi32(int  , int, int, int, int, int, int, int, int, int, int, int, int, int, int, int  );
extern __m512i __cdecl _mm512_set_epi64(__int64  , __int64, __int64, __int64, __int64, __int64, __int64, __int64  );

extern __m512i __cdecl _mm512_setr_epi8(char  , char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char  );
extern __m512i __cdecl _mm512_setr_epi16(short  , short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short  );
extern __m512i __cdecl _mm512_setr_epi32(int  , int, int, int, int, int, int, int, int, int, int, int, int, int, int, int  );
extern __m512i __cdecl _mm512_setr_epi64(__int64  , __int64, __int64, __int64, __int64, __int64, __int64, __int64  );

extern __m512i __cdecl _mm512_set1_epi8(char);
extern __m512i __cdecl _mm512_mask_set1_epi8(__m512i, __mmask64, char);
extern __m512i __cdecl _mm512_maskz_set1_epi8(__mmask64, char);
extern __m512i __cdecl _mm512_set1_epi16(short);
extern __m512i __cdecl _mm512_mask_set1_epi16(__m512i, __mmask32, short);
extern __m512i __cdecl _mm512_maskz_set1_epi16(__mmask32, short);
extern __m512i __cdecl _mm512_set1_epi32(int);
extern __m512i __cdecl _mm512_mask_set1_epi32(__m512i, __mmask16, int);
extern __m512i __cdecl _mm512_maskz_set1_epi32(__mmask16, int);
extern __m512i __cdecl _mm512_set1_epi64(__int64);
extern __m512i __cdecl _mm512_mask_set1_epi64(__m512i, __mmask8, __int64);
extern __m512i __cdecl _mm512_maskz_set1_epi64(__mmask8, __int64);

extern __m512i __cdecl _mm512_add_epi8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_add_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_add_epi8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_add_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_add_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_add_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_add_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_add_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_add_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_add_epi64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_add_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_add_epi64(__mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_adds_epi8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_adds_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_adds_epi8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_adds_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_adds_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_adds_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_adds_epu8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_adds_epu8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_adds_epu8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_adds_epu16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_adds_epu16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_adds_epu16(__mmask32, __m512i, __m512i);

extern __m512i __cdecl _mm512_abs_epi8(__m512i);
extern __m512i __cdecl _mm512_mask_abs_epi8(__m512i, __mmask64, __m512i);
extern __m512i __cdecl _mm512_maskz_abs_epi8(__mmask64, __m512i);
extern __m512i __cdecl _mm512_abs_epi16(__m512i);
extern __m512i __cdecl _mm512_mask_abs_epi16(__m512i, __mmask32, __m512i);
extern __m512i __cdecl _mm512_maskz_abs_epi16(__mmask32, __m512i);
extern __m512i __cdecl _mm512_abs_epi32(__m512i);
extern __m512i __cdecl _mm512_mask_abs_epi32(__m512i, __mmask16, __m512i);
extern __m512i __cdecl _mm512_maskz_abs_epi32(__mmask16, __m512i);
extern __m512i __cdecl _mm512_abs_epi64(__m512i);
extern __m512i __cdecl _mm512_mask_abs_epi64(__m512i, __mmask8, __m512i);
extern __m512i __cdecl _mm512_maskz_abs_epi64(__mmask8, __m512i);

extern __m512i  __cdecl _mm512_broadcast_i32x2(__m128i);
extern __m512i  __cdecl _mm512_mask_broadcast_i32x2(__m512i, __mmask16, __m128i);
extern __m512i  __cdecl _mm512_maskz_broadcast_i32x2(__mmask16, __m128i);
extern __m512i  __cdecl _mm512_broadcast_i32x4(__m128i);
extern __m512i  __cdecl _mm512_mask_broadcast_i32x4(__m512i, __mmask16, __m128i);
extern __m512i  __cdecl _mm512_maskz_broadcast_i32x4(__mmask16, __m128i);
extern __m512i  __cdecl _mm512_broadcast_i32x8(__m256i);
extern __m512i  __cdecl _mm512_mask_broadcast_i32x8(__m512i, __mmask16, __m256i);
extern __m512i  __cdecl _mm512_maskz_broadcast_i32x8(__mmask16, __m256i);
extern __m512i  __cdecl _mm512_broadcast_i64x2(__m128i);
extern __m512i  __cdecl _mm512_mask_broadcast_i64x2(__m512i, __mmask8, __m128i);
extern __m512i  __cdecl _mm512_maskz_broadcast_i64x2(__mmask8, __m128i);
extern __m512i  __cdecl _mm512_broadcast_i64x4(__m256i);
extern __m512i  __cdecl _mm512_mask_broadcast_i64x4(__m512i, __mmask8, __m256i);
extern __m512i  __cdecl _mm512_maskz_broadcast_i64x4(__mmask8, __m256i);
extern __m512i __cdecl _mm512_broadcastb_epi8(__m128i);
extern __m512i __cdecl _mm512_mask_broadcastb_epi8(__m512i, __mmask64, __m128i);
extern __m512i __cdecl _mm512_maskz_broadcastb_epi8(__mmask64, __m128i);
extern __m512i __cdecl _mm512_broadcastw_epi16(__m128i);
extern __m512i __cdecl _mm512_mask_broadcastw_epi16(__m512i, __mmask32, __m128i);
extern __m512i __cdecl _mm512_maskz_broadcastw_epi16(__mmask32, __m128i);
extern __m512i __cdecl _mm512_broadcastd_epi32(__m128i);
extern __m512i __cdecl _mm512_mask_broadcastd_epi32(__m512i, __mmask16, __m128i);
extern __m512i __cdecl _mm512_maskz_broadcastd_epi32(__mmask16, __m128i);
extern __m512i __cdecl _mm512_broadcastq_epi64(__m128i);
extern __m512i __cdecl _mm512_mask_broadcastq_epi64(__m512i, __mmask8, __m128i);
extern __m512i __cdecl _mm512_maskz_broadcastq_epi64(__mmask8, __m128i);
extern __m512i __cdecl _mm512_broadcastmw_epi32(__mmask16);
extern __m512i __cdecl _mm512_broadcastmb_epi64(__mmask8);

extern __m512i __cdecl _mm512_sub_epi8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_sub_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_sub_epi8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_sub_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_sub_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_sub_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_sub_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_sub_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_sub_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_sub_epi64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_sub_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_sub_epi64(__mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_subs_epi8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_subs_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_subs_epi8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_subs_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_subs_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_subs_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_subs_epu8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_subs_epu8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_subs_epu8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_subs_epu16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_subs_epu16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_subs_epu16(__mmask32, __m512i, __m512i);

extern __m512i __cdecl _mm512_max_epi8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_max_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_max_epi8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_max_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_max_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_max_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_max_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_max_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_max_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_max_epi64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_max_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_max_epi64(__mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_max_epu8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_max_epu8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_max_epu8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_max_epu16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_max_epu16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_max_epu16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_max_epu32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_max_epu32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_max_epu32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_max_epu64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_max_epu64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_max_epu64(__mmask8, __m512i, __m512i);

extern __m512i __cdecl _mm512_min_epi8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_min_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_min_epi8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_min_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_min_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_min_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_min_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_min_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_min_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_min_epi64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_min_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_min_epi64(__mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_min_epu8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_min_epu8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_min_epu8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_min_epu16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_min_epu16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_min_epu16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_min_epu32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_min_epu32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_min_epu32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_min_epu64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_min_epu64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_min_epu64(__mmask8, __m512i, __m512i);

extern __m512i __cdecl _mm512_mul_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_mul_epi32(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_mul_epi32(__mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_mul_epu32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_mul_epu32(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_mul_epu32(__mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_mulhi_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_mulhi_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_mulhi_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_mulhi_epu16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_mulhi_epu16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_mulhi_epu16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_mullo_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_mullo_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_mullo_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_mullo_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_mullo_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_mullo_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_mullo_epi64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_mullo_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_mullo_epi64(__mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_mullox_epi64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_mullox_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_mulhrs_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_mulhrs_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_mulhrs_epi16(__mmask32, __m512i, __m512i);

extern __m512i __cdecl _mm512_load_epi32(void const*);
extern __m512i __cdecl _mm512_mask_load_epi32(__m512i, __mmask16, void const*);
extern __m512i __cdecl _mm512_maskz_load_epi32(__mmask16, void const*);
extern __m512i __cdecl _mm512_load_epi64(void const*);
extern __m512i __cdecl _mm512_mask_load_epi64(__m512i, __mmask8, void const*);
extern __m512i __cdecl _mm512_maskz_load_epi64(__mmask8, void const*);
extern __m512i __cdecl _mm512_loadu_epi8(void const*);
extern __m512i __cdecl _mm512_mask_loadu_epi8(__m512i, __mmask64, void const*);
extern __m512i __cdecl _mm512_maskz_loadu_epi8(__mmask64, void const*);
extern __m512i __cdecl _mm512_loadu_epi16(void const*);
extern __m512i __cdecl _mm512_mask_loadu_epi16(__m512i, __mmask32, void const*);
extern __m512i __cdecl _mm512_maskz_loadu_epi16(__mmask32, void const*);
extern __m512i __cdecl _mm512_loadu_epi32(void const*);
extern __m512i __cdecl _mm512_mask_loadu_epi32(__m512i, __mmask16, void const*);
extern __m512i __cdecl _mm512_maskz_loadu_epi32(__mmask16, void const*);
extern __m512i __cdecl _mm512_loadu_epi64(void const*);
extern __m512i __cdecl _mm512_mask_loadu_epi64(__m512i, __mmask8, void const*);
extern __m512i __cdecl _mm512_maskz_loadu_epi64(__mmask8, void const*);

extern void    __cdecl _mm512_store_epi32(void*, __m512i);
extern void    __cdecl _mm512_mask_store_epi32(void*, __mmask16, __m512i);
extern void    __cdecl _mm512_store_epi64(void*, __m512i);
extern void    __cdecl _mm512_mask_store_epi64(void*, __mmask8, __m512i);
extern void    __cdecl _mm512_storeu_epi8(void*, __m512i);
extern void    __cdecl _mm512_mask_storeu_epi8(void*, __mmask64, __m512i);
extern void    __cdecl _mm512_storeu_epi16(void*, __m512i);
extern void    __cdecl _mm512_mask_storeu_epi16(void*, __mmask32, __m512i);
extern void    __cdecl _mm512_storeu_epi32(void*, __m512i);
extern void    __cdecl _mm512_mask_storeu_epi32(void*, __mmask16, __m512i);
extern void    __cdecl _mm512_storeu_epi64(void*, __m512i);
extern void    __cdecl _mm512_mask_storeu_epi64(void*, __mmask8, __m512i);

extern __m128i __cdecl _mm512_extracti32x4_epi32(__m512i, int);
extern __m128i __cdecl _mm512_mask_extracti32x4_epi32(__m128i, __mmask8, __m512i, int);
extern __m128i __cdecl _mm512_maskz_extracti32x4_epi32(__mmask8, __m512i, int);
extern __m256i __cdecl _mm512_extracti32x8_epi32(__m512i, int);
extern __m256i __cdecl _mm512_mask_extracti32x8_epi32(__m256i, __mmask8, __m512i, int);
extern __m256i __cdecl _mm512_maskz_extracti32x8_epi32(__mmask8, __m512i, int);
extern __m128i __cdecl _mm512_extracti64x2_epi64(__m512i, int);
extern __m128i __cdecl _mm512_mask_extracti64x2_epi64(__m128i, __mmask8, __m512i, int);
extern __m128i __cdecl _mm512_maskz_extracti64x2_epi64(__mmask8, __m512i, int);
extern __m256i __cdecl _mm512_extracti64x4_epi64(__m512i, int);
extern __m256i __cdecl _mm512_mask_extracti64x4_epi64(__m256i, __mmask8, __m512i, int);
extern __m256i __cdecl _mm512_maskz_extracti64x4_epi64(__mmask8, __m512i, int);

extern __m512i __cdecl _mm512_inserti32x4(__m512i, __m128i, int);
extern __m512i __cdecl _mm512_mask_inserti32x4(__m512i, __mmask16, __m512i, __m128i, int);
extern __m512i __cdecl _mm512_maskz_inserti32x4(__mmask16, __m512i, __m128i, int);
extern __m512i __cdecl _mm512_inserti32x8(__m512i, __m256i, int);
extern __m512i __cdecl _mm512_mask_inserti32x8(__m512i, __mmask16, __m512i, __m256i, int);
extern __m512i __cdecl _mm512_maskz_inserti32x8(__mmask16, __m512i, __m256i, int);
extern __m512i __cdecl _mm512_inserti64x2(__m512i, __m128i, int);
extern __m512i __cdecl _mm512_mask_inserti64x2(__m512i, __mmask8, __m512i, __m128i, int);
extern __m512i __cdecl _mm512_maskz_inserti64x2(__mmask8, __m512i, __m128i, int);
extern __m512i __cdecl _mm512_inserti64x4(__m512i, __m256i, int);
extern __m512i __cdecl _mm512_mask_inserti64x4(__m512i, __mmask8, __m512i, __m256i, int);
extern __m512i __cdecl _mm512_maskz_inserti64x4(__mmask8, __m512i, __m256i, int);

extern __m512i __cdecl _mm512_shuffle_epi8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_shuffle_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_shuffle_epi8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_shuffle_epi32(__m512i, int);
extern __m512i __cdecl _mm512_mask_shuffle_epi32(__m512i, __mmask16, __m512i, int);
extern __m512i __cdecl _mm512_maskz_shuffle_epi32(__mmask16, __m512i, int);
extern __m512i __cdecl _mm512_shuffle_i32x4(__m512i, __m512i, const int);
extern __m512i __cdecl _mm512_mask_shuffle_i32x4(__m512i, __mmask16, __m512i, __m512i, const int);
extern __m512i __cdecl _mm512_maskz_shuffle_i32x4(__mmask16, __m512i, __m512i, const int);
extern __m512i __cdecl _mm512_shuffle_i64x2(__m512i, __m512i, const int);
extern __m512i __cdecl _mm512_mask_shuffle_i64x2(__m512i, __mmask8, __m512i, __m512i, const int);
extern __m512i __cdecl _mm512_maskz_shuffle_i64x2(__mmask8, __m512i, __m512i, const int);
extern __m512i __cdecl _mm512_shufflehi_epi16(__m512i, int);
extern __m512i __cdecl _mm512_mask_shufflehi_epi16(__m512i, __mmask32, __m512i, int);
extern __m512i __cdecl _mm512_maskz_shufflehi_epi16(__mmask32, __m512i, int);
extern __m512i __cdecl _mm512_shufflelo_epi16(__m512i, int);
extern __m512i __cdecl _mm512_mask_shufflelo_epi16(__m512i, __mmask32, __m512i, int);
extern __m512i __cdecl _mm512_maskz_shufflelo_epi16(__mmask32, __m512i, int);

extern __m512  __cdecl _mm512_mask_mov_ps(__m512, __mmask16, __m512);
extern __m512  __cdecl _mm512_maskz_mov_ps(__mmask16, __m512);
extern __m512d __cdecl _mm512_mask_mov_pd(__m512d, __mmask8, __m512d);
extern __m512d __cdecl _mm512_maskz_mov_pd(__mmask8, __m512d);
extern __m512i __cdecl _mm512_mask_mov_epi8(__m512i, __mmask64, __m512i);
extern __m512i __cdecl _mm512_maskz_mov_epi8(__mmask64, __m512i);
extern __m512i __cdecl _mm512_mask_mov_epi16(__m512i, __mmask32, __m512i);
extern __m512i __cdecl _mm512_maskz_mov_epi16(__mmask32, __m512i);
extern __m512i __cdecl _mm512_mask_mov_epi32(__m512i, __mmask16, __m512i);
extern __m512i __cdecl _mm512_maskz_mov_epi32(__mmask16, __m512i);
extern __m512i __cdecl _mm512_mask_mov_epi64(__m512i, __mmask8, __m512i);
extern __m512i __cdecl _mm512_maskz_mov_epi64(__mmask8, __m512i);
extern __m512d __cdecl _mm512_movedup_pd(__m512d);
extern __m512d __cdecl _mm512_mask_movedup_pd(__m512d, __mmask8, __m512d);
extern __m512d __cdecl _mm512_maskz_movedup_pd(__mmask8, __m512d);
extern __m512  __cdecl _mm512_movehdup_ps(__m512);
extern __m512  __cdecl _mm512_mask_movehdup_ps(__m512, __mmask16, __m512);
extern __m512  __cdecl _mm512_maskz_movehdup_ps(__mmask16, __m512);
extern __m512  __cdecl _mm512_moveldup_ps(__m512);
extern __m512  __cdecl _mm512_mask_moveldup_ps(__m512, __mmask16, __m512);
extern __m512  __cdecl _mm512_maskz_moveldup_ps(__mmask16, __m512);

extern __m512i __cdecl _mm512_movm_epi8(__mmask64);
extern __m512i __cdecl _mm512_movm_epi16(__mmask32);
extern __m512i __cdecl _mm512_movm_epi32(__mmask16);
extern __m512i __cdecl _mm512_movm_epi64(__mmask8);
extern __mmask64 __cdecl _mm512_movepi8_mask(__m512i);
extern __mmask32 __cdecl _mm512_movepi16_mask(__m512i);
extern __mmask16 __cdecl _mm512_movepi32_mask(__m512i);
extern __mmask8  __cdecl _mm512_movepi64_mask(__m512i);

extern __m512i __cdecl _mm512_alignr_epi8(__m512i, __m512i, const int);
extern __m512i __cdecl _mm512_mask_alignr_epi8(__m512i, __mmask64, __m512i, __m512i, const int);
extern __m512i __cdecl _mm512_maskz_alignr_epi8(__mmask64, __m512i, __m512i, const int);
extern __m512i __cdecl _mm512_alignr_epi32(__m512i, __m512i, const int);
extern __m512i __cdecl _mm512_mask_alignr_epi32(__m512i, __mmask16, __m512i, __m512i, const int  );
extern __m512i __cdecl _mm512_maskz_alignr_epi32(__mmask16, __m512i, __m512i, const int);
extern __m512i __cdecl _mm512_alignr_epi64(__m512i, __m512i, const int);
extern __m512i __cdecl _mm512_mask_alignr_epi64(__m512i, __mmask8, __m512i, __m512i, const int);
extern __m512i __cdecl _mm512_maskz_alignr_epi64(__mmask8, __m512i, __m512i, const int);

extern __m512d __cdecl _mm512_and_pd(__m512d, __m512d);
extern __m512d __cdecl _mm512_mask_and_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_maskz_and_pd(__mmask8, __m512d, __m512d);
extern __m512  __cdecl _mm512_and_ps(__m512, __m512);
extern __m512  __cdecl _mm512_mask_and_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_maskz_and_ps(__mmask16, __m512, __m512);
extern __m512i __cdecl _mm512_and_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_and_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_and_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_and_epi64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_and_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_and_epi64(__mmask8, __m512i, __m512i);

extern __m512d __cdecl _mm512_andnot_pd(__m512d, __m512d);
extern __m512d __cdecl _mm512_mask_andnot_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_maskz_andnot_pd(__mmask8, __m512d, __m512d);
extern __m512  __cdecl _mm512_andnot_ps(__m512, __m512);
extern __m512  __cdecl _mm512_mask_andnot_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_maskz_andnot_ps(__mmask16, __m512, __m512);
extern __m512i __cdecl _mm512_andnot_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_andnot_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_andnot_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_andnot_epi64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_andnot_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_andnot_epi64(__mmask8, __m512i, __m512i);

extern __m512d __cdecl _mm512_or_pd(__m512d, __m512d);
extern __m512d __cdecl _mm512_mask_or_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_maskz_or_pd(__mmask8, __m512d, __m512d);
extern __m512  __cdecl _mm512_or_ps(__m512, __m512);
extern __m512  __cdecl _mm512_mask_or_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_maskz_or_ps(__mmask16, __m512, __m512);
extern __m512i __cdecl _mm512_or_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_or_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_or_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_or_epi64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_or_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_or_epi64(__mmask8, __m512i, __m512i);

extern __m512d __cdecl _mm512_xor_pd(__m512d, __m512d);
extern __m512d __cdecl _mm512_mask_xor_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_maskz_xor_pd(__mmask8, __m512d, __m512d);
extern __m512  __cdecl _mm512_xor_ps(__m512, __m512);
extern __m512  __cdecl _mm512_mask_xor_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_maskz_xor_ps(__mmask16, __m512, __m512);
extern __m512i __cdecl _mm512_xor_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_xor_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_xor_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_xor_epi64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_xor_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_xor_epi64(__mmask8, __m512i, __m512i);

extern __m512  __cdecl _mm512_mask_blend_ps(__mmask16, __m512, __m512);
extern __m512d __cdecl _mm512_mask_blend_pd(__mmask8, __m512d, __m512d);
extern __m512i __cdecl _mm512_mask_blend_epi8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_blend_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_blend_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_blend_epi64(__mmask8, __m512i, __m512i);

extern __m512i __cdecl _mm512_sll_epi16(__m512i, __m128i);
extern __m512i __cdecl _mm512_sll_epi32(__m512i, __m128i);
extern __m512i __cdecl _mm512_sll_epi64(__m512i, __m128i);
extern __m512i __cdecl _mm512_slli_epi16(__m512i, unsigned int);
extern __m512i __cdecl _mm512_slli_epi32(__m512i, unsigned int);
extern __m512i __cdecl _mm512_slli_epi64(__m512i, unsigned int);
extern __m512i __cdecl _mm512_sllv_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_sllv_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_sllv_epi64(__m512i, __m512i);

extern __m512i __cdecl _mm512_mask_sll_epi16(__m512i, __mmask32, __m512i, __m128i);
extern __m512i __cdecl _mm512_maskz_sll_epi16(__mmask32, __m512i, __m128i);
extern __m512i __cdecl _mm512_mask_sll_epi32(__m512i, __mmask16, __m512i, __m128i);
extern __m512i __cdecl _mm512_maskz_sll_epi32(__mmask16, __m512i, __m128i);
extern __m512i __cdecl _mm512_mask_sll_epi64(__m512i, __mmask8, __m512i, __m128i);
extern __m512i __cdecl _mm512_maskz_sll_epi64(__mmask8, __m512i, __m128i);
extern __m512i __cdecl _mm512_mask_slli_epi16(__m512i, __mmask32, __m512i, unsigned int);
extern __m512i __cdecl _mm512_maskz_slli_epi16(__mmask32, __m512i, unsigned int);
extern __m512i __cdecl _mm512_mask_slli_epi32(__m512i, __mmask16, __m512i, unsigned int);
extern __m512i __cdecl _mm512_maskz_slli_epi32(__mmask16, __m512i, unsigned int);
extern __m512i __cdecl _mm512_mask_slli_epi64(__m512i, __mmask8, __m512i, unsigned int);
extern __m512i __cdecl _mm512_maskz_slli_epi64(__mmask8, __m512i, unsigned int);
extern __m512i __cdecl _mm512_mask_sllv_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_sllv_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_sllv_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_sllv_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_sllv_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_sllv_epi64(__mmask8, __m512i, __m512i);

extern __m512i __cdecl _mm512_srl_epi16(__m512i, __m128i);
extern __m512i __cdecl _mm512_srl_epi32(__m512i, __m128i);
extern __m512i __cdecl _mm512_srl_epi64(__m512i, __m128i);
extern __m512i __cdecl _mm512_srli_epi16(__m512i, int);
extern __m512i __cdecl _mm512_srli_epi32(__m512i, unsigned int);
extern __m512i __cdecl _mm512_srli_epi64(__m512i, unsigned int);
extern __m512i __cdecl _mm512_srlv_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_srlv_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_srlv_epi64(__m512i, __m512i);

extern __m512i __cdecl _mm512_mask_srl_epi16(__m512i, __mmask32, __m512i, __m128i);
extern __m512i __cdecl _mm512_maskz_srl_epi16(__mmask32, __m512i, __m128i);
extern __m512i __cdecl _mm512_mask_srl_epi32(__m512i, __mmask16, __m512i, __m128i);
extern __m512i __cdecl _mm512_maskz_srl_epi32(__mmask16, __m512i, __m128i);
extern __m512i __cdecl _mm512_mask_srl_epi64(__m512i, __mmask8, __m512i, __m128i);
extern __m512i __cdecl _mm512_maskz_srl_epi64(__mmask8, __m512i, __m128i);
extern __m512i __cdecl _mm512_mask_srli_epi16(__m512i, __mmask32, __m512i, unsigned int);
extern __m512i __cdecl _mm512_maskz_srli_epi16(__mmask32, __m512i, int);
extern __m512i __cdecl _mm512_mask_srli_epi32(__m512i, __mmask16, __m512i, unsigned int);
extern __m512i __cdecl _mm512_maskz_srli_epi32(__mmask16, __m512i, unsigned int);
extern __m512i __cdecl _mm512_mask_srli_epi64(__m512i, __mmask8, __m512i, unsigned int);
extern __m512i __cdecl _mm512_maskz_srli_epi64(__mmask8, __m512i, unsigned int);
extern __m512i __cdecl _mm512_mask_srlv_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_srlv_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_srlv_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_srlv_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_srlv_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_srlv_epi64(__mmask8, __m512i, __m512i);

extern __m512i __cdecl _mm512_sra_epi16(__m512i, __m128i);
extern __m512i __cdecl _mm512_sra_epi32(__m512i, __m128i);
extern __m512i __cdecl _mm512_sra_epi64(__m512i, __m128i);
extern __m512i __cdecl _mm512_srai_epi16(__m512i, unsigned int);
extern __m512i __cdecl _mm512_srai_epi32(__m512i, unsigned int);
extern __m512i __cdecl _mm512_srai_epi64(__m512i, unsigned int);
extern __m512i __cdecl _mm512_srav_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_srav_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_srav_epi64(__m512i, __m512i);

extern __m512i __cdecl _mm512_mask_sra_epi16(__m512i, __mmask32, __m512i, __m128i);
extern __m512i __cdecl _mm512_maskz_sra_epi16(__mmask32, __m512i, __m128i);
extern __m512i __cdecl _mm512_mask_sra_epi32(__m512i, __mmask16, __m512i, __m128i);
extern __m512i __cdecl _mm512_maskz_sra_epi32(__mmask16, __m512i, __m128i);
extern __m512i __cdecl _mm512_mask_sra_epi64(__m512i, __mmask8, __m512i, __m128i);
extern __m512i __cdecl _mm512_maskz_sra_epi64(__mmask8, __m512i, __m128i);
extern __m512i __cdecl _mm512_mask_srai_epi16(__m512i, __mmask32, __m512i, unsigned int);
extern __m512i __cdecl _mm512_maskz_srai_epi16(__mmask32, __m512i, unsigned int);
extern __m512i __cdecl _mm512_mask_srai_epi32(__m512i, __mmask16, __m512i, unsigned int);
extern __m512i __cdecl _mm512_maskz_srai_epi32(__mmask16, __m512i, unsigned int);
extern __m512i __cdecl _mm512_mask_srai_epi64(__m512i, __mmask8, __m512i, unsigned int);
extern __m512i __cdecl _mm512_maskz_srai_epi64(__mmask8, __m512i, unsigned int);
extern __m512i __cdecl _mm512_mask_srav_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_srav_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_srav_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_srav_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_srav_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_srav_epi64(__mmask8, __m512i, __m512i);

extern __m512i __cdecl _mm512_bslli_epi128(__m512i, int);
extern __m512i __cdecl _mm512_bsrli_epi128(__m512i, int);

extern __m512i __cdecl _mm512_rol_epi32(__m512i, const int);
extern __m512i __cdecl _mm512_mask_rol_epi32(__m512i, __mmask16, __m512i, const int);
extern __m512i __cdecl _mm512_maskz_rol_epi32(__mmask16, __m512i, const int);
extern __m512i __cdecl _mm512_rol_epi64(__m512i, const int);
extern __m512i __cdecl _mm512_mask_rol_epi64(__m512i, __mmask8, __m512i, const int);
extern __m512i __cdecl _mm512_maskz_rol_epi64(__mmask8, __m512i, const int);
extern __m512i __cdecl _mm512_rolv_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_rolv_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_rolv_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_rolv_epi64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_rolv_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_rolv_epi64(__mmask8, __m512i, __m512i);

extern __m512i __cdecl _mm512_ror_epi32(__m512i, int);
extern __m512i __cdecl _mm512_mask_ror_epi32(__m512i, __mmask16, __m512i, int);
extern __m512i __cdecl _mm512_maskz_ror_epi32(__mmask16, __m512i, int);
extern __m512i __cdecl _mm512_ror_epi64(__m512i, int);
extern __m512i __cdecl _mm512_mask_ror_epi64(__m512i, __mmask8, __m512i, int);
extern __m512i __cdecl _mm512_maskz_ror_epi64(__mmask8, __m512i, int);
extern __m512i __cdecl _mm512_rorv_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_rorv_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_rorv_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_rorv_epi64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_rorv_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_rorv_epi64(__mmask8, __m512i, __m512i);

extern __m512d __cdecl _mm512_unpackhi_pd(__m512d, __m512d);
extern __m512d __cdecl _mm512_mask_unpackhi_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_maskz_unpackhi_pd(__mmask8, __m512d, __m512d);
extern __m512  __cdecl _mm512_unpackhi_ps(__m512, __m512);
extern __m512  __cdecl _mm512_mask_unpackhi_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_maskz_unpackhi_ps(__mmask16, __m512, __m512);
extern __m512d __cdecl _mm512_unpacklo_pd(__m512d, __m512d);
extern __m512d __cdecl _mm512_mask_unpacklo_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_maskz_unpacklo_pd(__mmask8, __m512d, __m512d);
extern __m512  __cdecl _mm512_unpacklo_ps(__m512, __m512);
extern __m512  __cdecl _mm512_mask_unpacklo_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_maskz_unpacklo_ps(__mmask16, __m512, __m512);
extern __m512i __cdecl _mm512_unpackhi_epi8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_unpackhi_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_unpackhi_epi8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_unpackhi_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_unpackhi_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_unpackhi_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_unpackhi_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_unpackhi_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_unpackhi_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_unpackhi_epi64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_unpackhi_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_unpackhi_epi64(__mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_unpacklo_epi8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_unpacklo_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_unpacklo_epi8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_unpacklo_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_unpacklo_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_unpacklo_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_unpacklo_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_unpacklo_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_unpacklo_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_unpacklo_epi64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_unpacklo_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_unpacklo_epi64(__mmask8, __m512i, __m512i);

extern __m512  __cdecl _mm512_getexp_ps(__m512);
extern __m512  __cdecl _mm512_mask_getexp_ps(__m512, __mmask16, __m512);
extern __m512  __cdecl _mm512_maskz_getexp_ps(__mmask16, __m512);
extern __m512  __cdecl _mm512_getexp_round_ps(__m512, int);
extern __m512  __cdecl _mm512_mask_getexp_round_ps(__m512, __mmask16, __m512, int);
extern __m512  __cdecl _mm512_maskz_getexp_round_ps(__mmask16, __m512, int);
extern __m512d __cdecl _mm512_getexp_pd(__m512d);
extern __m512d __cdecl _mm512_mask_getexp_pd(__m512d, __mmask8, __m512d);
extern __m512d __cdecl _mm512_maskz_getexp_pd(__mmask8, __m512d);
extern __m512d __cdecl _mm512_getexp_round_pd(__m512d, int);
extern __m512d __cdecl _mm512_mask_getexp_round_pd(__m512d, __mmask8, __m512d, int);
extern __m512d __cdecl _mm512_maskz_getexp_round_pd(__mmask8, __m512d, int);

extern __m512  __cdecl _mm512_getmant_ps(__m512, int, int);
extern __m512  __cdecl _mm512_mask_getmant_ps(__m512, __mmask16, __m512, int, int);
extern __m512  __cdecl _mm512_maskz_getmant_ps(__mmask16, __m512, int, int);
extern __m512  __cdecl _mm512_getmant_round_ps(__m512, int, int, int);
extern __m512  __cdecl _mm512_mask_getmant_round_ps(__m512, __mmask16, __m512, int, int, int);
extern __m512  __cdecl _mm512_maskz_getmant_round_ps(__mmask16, __m512, int, int, int);
extern __m512d __cdecl _mm512_getmant_pd(__m512d, int, int);
extern __m512d __cdecl _mm512_mask_getmant_pd(__m512d, __mmask8, __m512d, int, int);
extern __m512d __cdecl _mm512_maskz_getmant_pd(__mmask8, __m512d, int, int);
extern __m512d __cdecl _mm512_getmant_round_pd(__m512d, int, int, int);
extern __m512d __cdecl _mm512_mask_getmant_round_pd(__m512d, __mmask8, __m512d, int, int, int);
extern __m512d __cdecl _mm512_maskz_getmant_round_pd(__mmask8, __m512d, int, int, int);

extern __m512d __cdecl _mm512_permute_pd(__m512d, const int);
extern __m512d __cdecl _mm512_mask_permute_pd(__m512d, __mmask8, __m512d, const int);
extern __m512d __cdecl _mm512_maskz_permute_pd(__mmask8, __m512d, const int);
extern __m512  __cdecl _mm512_permute_ps(__m512, const int);
extern __m512  __cdecl _mm512_mask_permute_ps(__m512, __mmask16, __m512, const int);
extern __m512  __cdecl _mm512_maskz_permute_ps(__mmask16, __m512, const int);
extern __m512d __cdecl _mm512_permutevar_pd(__m512d, __m512i);
extern __m512d __cdecl _mm512_mask_permutevar_pd(__m512d, __mmask8, __m512d, __m512i);
extern __m512d __cdecl _mm512_maskz_permutevar_pd(__mmask8, __m512d, __m512i);
extern __m512  __cdecl _mm512_permutevar_ps(__m512, __m512i);
extern __m512  __cdecl _mm512_mask_permutevar_ps(__m512, __mmask16, __m512, __m512i);
extern __m512  __cdecl _mm512_maskz_permutevar_ps(__mmask16, __m512, __m512i);
extern __m512i __cdecl _mm512_permutevar_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_permutevar_epi32(__m512i, __mmask16, __m512i, __m512i);

extern __m512d __cdecl _mm512_permutex_pd(__m512d, const int);
extern __m512d __cdecl _mm512_mask_permutex_pd(__m512d, __mmask8, __m512d, const int);
extern __m512d __cdecl _mm512_maskz_permutex_pd(__mmask8, __m512d, const int);
extern __m512i __cdecl _mm512_permutex_epi64(__m512i, const int);
extern __m512i __cdecl _mm512_mask_permutex_epi64(__m512i, __mmask8, __m512i, const int);
extern __m512i __cdecl _mm512_maskz_permutex_epi64(__mmask8, __m512i, const int);
extern __m512d __cdecl _mm512_permutexvar_pd(__m512i, __m512d);
extern __m512d __cdecl _mm512_mask_permutexvar_pd(__m512d, __mmask8, __m512i, __m512d);
extern __m512d __cdecl _mm512_maskz_permutexvar_pd(__mmask8, __m512i, __m512d);
extern __m512  __cdecl _mm512_permutexvar_ps(__m512i, __m512);
extern __m512  __cdecl _mm512_mask_permutexvar_ps(__m512, __mmask16, __m512i, __m512);
extern __m512  __cdecl _mm512_maskz_permutexvar_ps(__mmask16, __m512i, __m512);
extern __m512i __cdecl _mm512_permutexvar_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_permutexvar_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_permutexvar_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_permutexvar_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_permutexvar_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_permutexvar_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_permutexvar_epi64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_permutexvar_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_permutexvar_epi64(__mmask8, __m512i, __m512i);

extern __m512d __cdecl _mm512_permutex2var_pd(__m512d, __m512i  , __m512d);
extern __m512d __cdecl _mm512_mask_permutex2var_pd(__m512d, __mmask8, __m512i  , __m512d);
extern __m512d __cdecl _mm512_mask2_permutex2var_pd(__m512d, __m512i  , __mmask8, __m512d);
extern __m512d __cdecl _mm512_maskz_permutex2var_pd(__mmask8, __m512d, __m512i  , __m512d);
extern __m512  __cdecl _mm512_permutex2var_ps(__m512, __m512i  , __m512);
extern __m512  __cdecl _mm512_mask_permutex2var_ps(__m512, __mmask16, __m512i  , __m512);
extern __m512  __cdecl _mm512_mask2_permutex2var_ps(__m512, __m512i  , __mmask16, __m512);
extern __m512  __cdecl _mm512_maskz_permutex2var_ps(__mmask16, __m512, __m512i  , __m512);
extern __m512i __cdecl _mm512_permutex2var_epi16(__m512i, __m512i  , __m512i);
extern __m512i __cdecl _mm512_mask_permutex2var_epi16(__m512i, __mmask32, __m512i  , __m512i);
extern __m512i __cdecl _mm512_mask2_permutex2var_epi16(__m512i, __m512i  , __mmask32, __m512i);
extern __m512i __cdecl _mm512_maskz_permutex2var_epi16(__mmask32, __m512i, __m512i  , __m512i);
extern __m512i __cdecl _mm512_permutex2var_epi32(__m512i, __m512i  , __m512i);
extern __m512i __cdecl _mm512_mask_permutex2var_epi32(__m512i, __mmask16, __m512i  , __m512i);
extern __m512i __cdecl _mm512_mask2_permutex2var_epi32(__m512i, __m512i  , __mmask16, __m512i);
extern __m512i __cdecl _mm512_maskz_permutex2var_epi32(__mmask16, __m512i, __m512i  , __m512i);
extern __m512i __cdecl _mm512_permutex2var_epi64(__m512i, __m512i  , __m512i);
extern __m512i __cdecl _mm512_mask_permutex2var_epi64(__m512i, __mmask8, __m512i  , __m512i);
extern __m512i __cdecl _mm512_mask2_permutex2var_epi64(__m512i, __m512i  , __mmask8, __m512i);
extern __m512i __cdecl _mm512_maskz_permutex2var_epi64(__mmask8, __m512i, __m512i  , __m512i);

extern __m512d __cdecl _mm512_mask_compress_pd(__m512d, __mmask8, __m512d);
extern __m512d __cdecl _mm512_maskz_compress_pd(__mmask8, __m512d);
extern __m512  __cdecl _mm512_mask_compress_ps(__m512, __mmask16, __m512);
extern __m512  __cdecl _mm512_maskz_compress_ps(__mmask16, __m512);
extern __m512i __cdecl _mm512_mask_compress_epi8(__m512i, __mmask64, __m512i);
extern __m512i __cdecl _mm512_maskz_compress_epi8(__mmask64, __m512i);
extern __m512i __cdecl _mm512_mask_compress_epi16(__m512i, __mmask32, __m512i);
extern __m512i __cdecl _mm512_maskz_compress_epi16(__mmask32, __m512i);
extern __m512i __cdecl _mm512_mask_compress_epi32(__m512i, __mmask16, __m512i);
extern __m512i __cdecl _mm512_maskz_compress_epi32(__mmask16, __m512i);
extern __m512i __cdecl _mm512_mask_compress_epi64(__m512i, __mmask8, __m512i);
extern __m512i __cdecl _mm512_maskz_compress_epi64(__mmask8, __m512i);

extern void    __cdecl _mm512_mask_compressstoreu_pd(void*, __mmask8, __m512d);
extern void    __cdecl _mm512_mask_compressstoreu_ps(void*, __mmask16, __m512);
extern void    __cdecl _mm512_mask_compressstoreu_epi8(void*, __mmask64, __m512i);
extern void    __cdecl _mm512_mask_compressstoreu_epi16(void*, __mmask32, __m512i);
extern void    __cdecl _mm512_mask_compressstoreu_epi32(void*, __mmask16, __m512i);
extern void    __cdecl _mm512_mask_compressstoreu_epi64(void*, __mmask8, __m512i);

extern __m512d __cdecl _mm512_mask_expand_pd(__m512d, __mmask8, __m512d);
extern __m512d __cdecl _mm512_maskz_expand_pd(__mmask8, __m512d);
extern __m512  __cdecl _mm512_mask_expand_ps(__m512, __mmask16, __m512);
extern __m512  __cdecl _mm512_maskz_expand_ps(__mmask16, __m512);
extern __m512i __cdecl _mm512_mask_expand_epi8(__m512i, __mmask64, __m512i);
extern __m512i __cdecl _mm512_maskz_expand_epi8(__mmask64, __m512i);
extern __m512i __cdecl _mm512_mask_expand_epi16(__m512i, __mmask32, __m512i);
extern __m512i __cdecl _mm512_maskz_expand_epi16(__mmask32, __m512i);
extern __m512i __cdecl _mm512_mask_expand_epi32(__m512i, __mmask16, __m512i);
extern __m512i __cdecl _mm512_maskz_expand_epi32(__mmask16, __m512i);
extern __m512i __cdecl _mm512_mask_expand_epi64(__m512i, __mmask8, __m512i);
extern __m512i __cdecl _mm512_maskz_expand_epi64(__mmask8, __m512i);
extern __m512d __cdecl _mm512_mask_expandloadu_pd(__m512d, __mmask8, void const*);
extern __m512d __cdecl _mm512_maskz_expandloadu_pd(__mmask8, void const*);
extern __m512  __cdecl _mm512_mask_expandloadu_ps(__m512, __mmask16, void const*);
extern __m512  __cdecl _mm512_maskz_expandloadu_ps(__mmask16, void const*);
extern __m512i __cdecl _mm512_mask_expandloadu_epi8(__m512i, __mmask64, const void*);
extern __m512i __cdecl _mm512_maskz_expandloadu_epi8(__mmask64, const void*);
extern __m512i __cdecl _mm512_mask_expandloadu_epi16(__m512i, __mmask32, const void*);
extern __m512i __cdecl _mm512_maskz_expandloadu_epi16(__mmask32, const void*);
extern __m512i __cdecl _mm512_mask_expandloadu_epi32(__m512i, __mmask16, void const*);
extern __m512i __cdecl _mm512_maskz_expandloadu_epi32(__mmask16, void const*);
extern __m512i __cdecl _mm512_mask_expandloadu_epi64(__m512i, __mmask8, void const*);
extern __m512i __cdecl _mm512_maskz_expandloadu_epi64(__mmask8, void const*);

extern __m512i __cdecl _mm512_ternarylogic_epi32(__m512i, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_mask_ternarylogic_epi32(__m512i, __mmask16, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_maskz_ternarylogic_epi32(__mmask16, __m512i, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_ternarylogic_epi64(__m512i, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_mask_ternarylogic_epi64(__m512i, __mmask8, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_maskz_ternarylogic_epi64(__mmask8, __m512i, __m512i, __m512i, int);

extern __m512i __cdecl _mm512_conflict_epi32(__m512i);
extern __m512i __cdecl _mm512_mask_conflict_epi32(__m512i, __mmask16, __m512i);
extern __m512i __cdecl _mm512_maskz_conflict_epi32(__mmask16, __m512i);
extern __m512i __cdecl _mm512_conflict_epi64(__m512i);
extern __m512i __cdecl _mm512_mask_conflict_epi64(__m512i, __mmask8, __m512i);
extern __m512i __cdecl _mm512_maskz_conflict_epi64(__mmask8, __m512i);

extern __m512i __cdecl _mm512_lzcnt_epi32(__m512i);
extern __m512i __cdecl _mm512_mask_lzcnt_epi32(__m512i, __mmask16, __m512i);
extern __m512i __cdecl _mm512_maskz_lzcnt_epi32(__mmask16, __m512i);
extern __m512i __cdecl _mm512_lzcnt_epi64(__m512i);
extern __m512i __cdecl _mm512_mask_lzcnt_epi64(__m512i, __mmask8, __m512i);
extern __m512i __cdecl _mm512_maskz_lzcnt_epi64(__mmask8, __m512i);

extern __m512i __cdecl _mm512_avg_epu8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_avg_epu8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_avg_epu8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_avg_epu16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_avg_epu16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_avg_epu16(__mmask32, __m512i, __m512i);

extern __m512i __cdecl _mm512_sad_epu8(__m512i, __m512i);
extern __m512i __cdecl _mm512_dbsad_epu8(__m512i, __m512i, int);
extern __m512i __cdecl _mm512_mask_dbsad_epu8(__m512i, __mmask32, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_maskz_dbsad_epu8(__mmask32, __m512i, __m512i, int);

extern float   __cdecl _mm512_reduce_add_ps(__m512);
extern float   __cdecl _mm512_mask_reduce_add_ps(__mmask16, __m512);
extern double  __cdecl _mm512_reduce_add_pd(__m512d);
extern double  __cdecl _mm512_mask_reduce_add_pd(__mmask8, __m512d);
extern int     __cdecl _mm512_reduce_add_epi8(__m512i);
extern int     __cdecl _mm512_mask_reduce_add_epi8(__mmask64, __m512i);
extern int     __cdecl _mm512_reduce_add_epi16(__m512i);
extern int     __cdecl _mm512_mask_reduce_add_epi16(__mmask32, __m512i);
extern int     __cdecl _mm512_reduce_add_epi32(__m512i);
extern int     __cdecl _mm512_mask_reduce_add_epi32(__mmask16, __m512i);
extern __int64 __cdecl _mm512_reduce_add_epi64(__m512i);
extern __int64 __cdecl _mm512_mask_reduce_add_epi64(__mmask8, __m512i);
extern int     __cdecl _mm512_reduce_add_epu8(__m512i);
extern int     __cdecl _mm512_mask_reduce_add_epu8(__mmask64, __m512i);
extern int     __cdecl _mm512_reduce_add_epu16(__m512i);
extern int     __cdecl _mm512_mask_reduce_add_epu16(__mmask32, __m512i);

extern float   __cdecl _mm512_reduce_mul_ps(__m512);
extern float   __cdecl _mm512_mask_reduce_mul_ps(__mmask16, __m512);
extern double  __cdecl _mm512_reduce_mul_pd(__m512d);
extern double  __cdecl _mm512_mask_reduce_mul_pd(__mmask8, __m512d);
extern int     __cdecl _mm512_reduce_mul_epi32(__m512i);
extern int     __cdecl _mm512_mask_reduce_mul_epi32(__mmask16, __m512i);
extern __int64 __cdecl _mm512_reduce_mul_epi64(__m512i);
extern __int64 __cdecl _mm512_mask_reduce_mul_epi64(__mmask8, __m512i);

extern float   __cdecl _mm512_reduce_min_ps(__m512);
extern float   __cdecl _mm512_mask_reduce_min_ps(__mmask16, __m512);
extern double  __cdecl _mm512_reduce_min_pd(__m512d);
extern double  __cdecl _mm512_mask_reduce_min_pd(__mmask8, __m512d);
extern int     __cdecl _mm512_reduce_min_epi32(__m512i);
extern int     __cdecl _mm512_mask_reduce_min_epi32(__mmask16, __m512i);
extern __int64 __cdecl _mm512_reduce_min_epi64(__m512i);
extern __int64 __cdecl _mm512_mask_reduce_min_epi64(__mmask8, __m512i);
extern unsigned int     __cdecl _mm512_reduce_min_epu32(__m512i);
extern unsigned int     __cdecl _mm512_mask_reduce_min_epu32(__mmask16, __m512i);
extern unsigned __int64 __cdecl _mm512_reduce_min_epu64(__m512i);
extern unsigned __int64 __cdecl _mm512_mask_reduce_min_epu64(__mmask8, __m512i);

extern float   __cdecl _mm512_reduce_max_ps(__m512);
extern float   __cdecl _mm512_mask_reduce_max_ps(__mmask16, __m512);
extern double  __cdecl _mm512_reduce_max_pd(__m512d);
extern double  __cdecl _mm512_mask_reduce_max_pd(__mmask8, __m512d);
extern int     __cdecl _mm512_reduce_max_epi32(__m512i);
extern int     __cdecl _mm512_mask_reduce_max_epi32(__mmask16, __m512i);
extern __int64 __cdecl _mm512_reduce_max_epi64(__m512i);
extern __int64 __cdecl _mm512_mask_reduce_max_epi64(__mmask8, __m512i);
extern unsigned int     __cdecl _mm512_reduce_max_epu32(__m512i);
extern unsigned int     __cdecl _mm512_mask_reduce_max_epu32(__mmask16, __m512i);
extern unsigned __int64 __cdecl _mm512_reduce_max_epu64(__m512i);
extern unsigned __int64 __cdecl _mm512_mask_reduce_max_epu64(__mmask8, __m512i);

extern int     __cdecl _mm512_reduce_and_epi32(__m512i);
extern int     __cdecl _mm512_mask_reduce_and_epi32(__mmask16, __m512i);
extern __int64 __cdecl _mm512_reduce_and_epi64(__m512i);
extern __int64 __cdecl _mm512_mask_reduce_and_epi64(__mmask8, __m512i);

extern int     __cdecl _mm512_reduce_or_epi32(__m512i);
extern int     __cdecl _mm512_mask_reduce_or_epi32(__mmask16, __m512i);
extern __int64 __cdecl _mm512_reduce_or_epi64(__m512i);
extern __int64 __cdecl _mm512_mask_reduce_or_epi64(__mmask8, __m512i);

extern int     __cdecl _mm512_reduce_xor_epi32(__m512i);
extern int     __cdecl _mm512_mask_reduce_xor_epi32(__mmask16, __m512i);
extern __int64 __cdecl _mm512_reduce_xor_epi64(__m512i);
extern __int64 __cdecl _mm512_mask_reduce_xor_epi64(__mmask8, __m512i);

extern __m512d __cdecl _mm512_reduce_pd(__m512d, int);
extern __m512d __cdecl _mm512_mask_reduce_pd(__m512d, __mmask8, __m512d, int);
extern __m512d __cdecl _mm512_maskz_reduce_pd(__mmask8, __m512d, int);
extern __m512d __cdecl _mm512_reduce_round_pd(__m512d, int, int);
extern __m512d __cdecl _mm512_mask_reduce_round_pd(__m512d, __mmask8, __m512d, int, int);
extern __m512d __cdecl _mm512_maskz_reduce_round_pd(__mmask8, __m512d, int, int);
extern __m512  __cdecl _mm512_reduce_ps(__m512, int);
extern __m512  __cdecl _mm512_mask_reduce_ps(__m512, __mmask16, __m512, int);
extern __m512  __cdecl _mm512_maskz_reduce_ps(__mmask16, __m512, int);
extern __m512  __cdecl _mm512_reduce_round_ps(__m512, int, int);
extern __m512  __cdecl _mm512_mask_reduce_round_ps(__m512, __mmask16, __m512, int, int);
extern __m512  __cdecl _mm512_maskz_reduce_round_ps(__mmask16, __m512, int, int);

extern __m512d __cdecl _mm512_roundscale_pd(__m512d, int);
extern __m512d __cdecl _mm512_mask_roundscale_pd(__m512d, __mmask8, __m512d, int);
extern __m512d __cdecl _mm512_maskz_roundscale_pd(__mmask8, __m512d, int);
extern __m512d __cdecl _mm512_roundscale_round_pd(__m512d, int, int);
extern __m512d __cdecl _mm512_mask_roundscale_round_pd(__m512d, __mmask8, __m512d, int, int);
extern __m512d __cdecl _mm512_maskz_roundscale_round_pd(__mmask8, __m512d, int, int);
extern __m512  __cdecl _mm512_roundscale_ps(__m512, int);
extern __m512  __cdecl _mm512_mask_roundscale_ps(__m512, __mmask16, __m512, int);
extern __m512  __cdecl _mm512_maskz_roundscale_ps(__mmask16, __m512, int);
extern __m512  __cdecl _mm512_roundscale_round_ps(__m512, int, int);
extern __m512  __cdecl _mm512_mask_roundscale_round_ps(__m512, __mmask16, __m512, int, int);
extern __m512  __cdecl _mm512_maskz_roundscale_round_ps(__mmask16, __m512, int, int);

extern __m512d __cdecl _mm512_scalef_pd(__m512d, __m512d);
extern __m512d __cdecl _mm512_mask_scalef_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_maskz_scalef_pd(__mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_scalef_round_pd(__m512d, __m512d, int);
extern __m512d __cdecl _mm512_mask_scalef_round_pd(__m512d, __mmask8, __m512d, __m512d, int);
extern __m512d __cdecl _mm512_maskz_scalef_round_pd(__mmask8, __m512d, __m512d, int);
extern __m512  __cdecl _mm512_scalef_ps(__m512, __m512);
extern __m512  __cdecl _mm512_mask_scalef_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_maskz_scalef_ps(__mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_scalef_round_ps(__m512, __m512, int);
extern __m512  __cdecl _mm512_mask_scalef_round_ps(__m512, __mmask16, __m512, __m512, int);
extern __m512  __cdecl _mm512_maskz_scalef_round_ps(__mmask16, __m512, __m512, int);

extern __m512d __cdecl _mm512_fixupimm_pd(__m512d, __m512d, __m512i, const int);
extern __m512d __cdecl _mm512_mask_fixupimm_pd(__m512d, __mmask8, __m512d, __m512i, const int);
extern __m512d __cdecl _mm512_maskz_fixupimm_pd(__mmask8, __m512d, __m512d, __m512i, const int);
extern __m512d __cdecl _mm512_fixupimm_round_pd(__m512d, __m512d, __m512i, const int, const int);
extern __m512d __cdecl _mm512_mask_fixupimm_round_pd(__m512d, __mmask8, __m512d, __m512i, const int, const int);
extern __m512d __cdecl _mm512_maskz_fixupimm_round_pd(__mmask8, __m512d, __m512d, __m512i, const int, const int);
extern __m512  __cdecl _mm512_fixupimm_ps(__m512, __m512, __m512i, const int);
extern __m512  __cdecl _mm512_mask_fixupimm_ps(__m512, __mmask16, __m512, __m512i, const int);
extern __m512  __cdecl _mm512_maskz_fixupimm_ps(__mmask16, __m512, __m512, __m512i, const int);
extern __m512  __cdecl _mm512_fixupimm_round_ps(__m512, __m512, __m512i, const int, const int);
extern __m512  __cdecl _mm512_mask_fixupimm_round_ps(__m512, __mmask16, __m512, __m512i, const int, const int);
extern __m512  __cdecl _mm512_maskz_fixupimm_round_ps(__mmask16, __m512, __m512, __m512i, const int, const int);

extern void    __cdecl _mm512_stream_pd(void*, __m512d);
extern void    __cdecl _mm512_stream_ps(void*, __m512);
extern void    __cdecl _mm512_stream_si512(void*, __m512i);
extern __m512i __cdecl _mm512_stream_load_si512(void const*);

extern __m128d __cdecl _mm512_castpd512_pd128(__m512d);
extern __m128  __cdecl _mm512_castps512_ps128(__m512);
extern __m128i __cdecl _mm512_castsi512_si128(__m512i);
extern __m512i __cdecl _mm512_castsi128_si512(__m128i);

extern __mmask16 __cdecl _mm512_fpclass_ps_mask(__m512, int);
extern __mmask16 __cdecl _mm512_mask_fpclass_ps_mask(__mmask16, __m512, int);
extern __mmask8  __cdecl _mm512_fpclass_pd_mask(__m512d, int);
extern __mmask8  __cdecl _mm512_mask_fpclass_pd_mask(__mmask8, __m512d, int);

extern __m512d __cdecl _mm512_range_pd(__m512d, __m512d, int);
extern __m512d __cdecl _mm512_mask_range_pd(__m512d, __mmask8, __m512d, __m512d, int);
extern __m512d __cdecl _mm512_maskz_range_pd(__mmask8, __m512d, __m512d, int);
extern __m512d __cdecl _mm512_range_round_pd(__m512d, __m512d, int, int);
extern __m512d __cdecl _mm512_mask_range_round_pd(__m512d, __mmask8, __m512d, __m512d, int, int);
extern __m512d __cdecl _mm512_maskz_range_round_pd(__mmask8, __m512d, __m512d, int, int);
extern __m512  __cdecl _mm512_range_ps(__m512, __m512, int);
extern __m512  __cdecl _mm512_mask_range_ps(__m512, __mmask16, __m512, __m512, int);
extern __m512  __cdecl _mm512_maskz_range_ps(__mmask16, __m512, __m512, int);
extern __m512  __cdecl _mm512_range_round_ps(__m512, __m512, int, int);
extern __m512  __cdecl _mm512_mask_range_round_ps(__m512, __mmask16, __m512, __m512, int, int);
extern __m512  __cdecl _mm512_maskz_range_round_ps(__mmask16, __m512, __m512, int, int);

extern __m512i __cdecl _mm512_madd_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_madd_epi16(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_madd_epi16(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maddubs_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_maddubs_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_maddubs_epi16(__mmask32, __m512i, __m512i);

extern __m512i __cdecl _mm512_packs_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_packs_epi16(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_packs_epi16(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_packs_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_packs_epi32(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_packs_epi32(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_packus_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_packus_epi16(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_packus_epi16(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_packus_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_packus_epi32(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_packus_epi32(__mmask32, __m512i, __m512i);

extern __mmask64 __cdecl _mm512_cmp_epi8_mask(__m512i, __m512i, const int);
extern __mmask64 __cdecl _mm512_mask_cmp_epi8_mask(__mmask64, __m512i, __m512i, const int);
extern __mmask32 __cdecl _mm512_cmp_epi16_mask(__m512i, __m512i, const int);
extern __mmask32 __cdecl _mm512_mask_cmp_epi16_mask(__mmask32, __m512i, __m512i, const int);
extern __mmask16 __cdecl _mm512_cmp_epi32_mask(__m512i, __m512i, const int);
extern __mmask16 __cdecl _mm512_mask_cmp_epi32_mask(__mmask16, __m512i, __m512i, const int);
extern __mmask8  __cdecl _mm512_cmp_epi64_mask(__m512i, __m512i, const int);
extern __mmask8  __cdecl _mm512_mask_cmp_epi64_mask(__mmask8, __m512i, __m512i, const int);
extern __mmask64 __cdecl _mm512_cmp_epu8_mask(__m512i, __m512i, const int);
extern __mmask64 __cdecl _mm512_mask_cmp_epu8_mask(__mmask64, __m512i, __m512i, const int);
extern __mmask32 __cdecl _mm512_cmp_epu16_mask(__m512i, __m512i, const int);
extern __mmask32 __cdecl _mm512_mask_cmp_epu16_mask(__mmask32, __m512i, __m512i, const int);
extern __mmask16 __cdecl _mm512_cmp_epu32_mask(__m512i, __m512i, const int);
extern __mmask16 __cdecl _mm512_mask_cmp_epu32_mask(__mmask16, __m512i, __m512i, const int);
extern __mmask8  __cdecl _mm512_cmp_epu64_mask(__m512i, __m512i, const int);
extern __mmask8  __cdecl _mm512_mask_cmp_epu64_mask(__mmask8, __m512i, __m512i, const int);

extern __mmask64 __cdecl _mm512_test_epi8_mask(__m512i, __m512i);
extern __mmask64 __cdecl _mm512_mask_test_epi8_mask(__mmask64, __m512i, __m512i);
extern __mmask32 __cdecl _mm512_test_epi16_mask(__m512i, __m512i);
extern __mmask32 __cdecl _mm512_mask_test_epi16_mask(__mmask32, __m512i, __m512i);
extern __mmask64 __cdecl _mm512_testn_epi8_mask(__m512i, __m512i);
extern __mmask64 __cdecl _mm512_mask_testn_epi8_mask(__mmask64, __m512i, __m512i);
extern __mmask32 __cdecl _mm512_testn_epi16_mask(__m512i, __m512i);
extern __mmask32 __cdecl _mm512_mask_testn_epi16_mask(__mmask32, __m512i, __m512i);
extern __mmask16 __cdecl _mm512_test_epi32_mask(__m512i, __m512i);
extern __mmask16 __cdecl _mm512_mask_test_epi32_mask(__mmask16, __m512i, __m512i);
extern __mmask8  __cdecl _mm512_test_epi64_mask(__m512i, __m512i);
extern __mmask8  __cdecl _mm512_mask_test_epi64_mask(__mmask8, __m512i, __m512i);
extern __mmask16 __cdecl _mm512_testn_epi32_mask(__m512i, __m512i);
extern __mmask16 __cdecl _mm512_mask_testn_epi32_mask(__mmask16, __m512i, __m512i);
extern __mmask8  __cdecl _mm512_testn_epi64_mask(__m512i, __m512i);
extern __mmask8  __cdecl _mm512_mask_testn_epi64_mask(__mmask8, __m512i, __m512i);

extern __mmask16 __cdecl _mm512_kunpackb(__mmask16, __mmask16);
extern __mmask32 __cdecl _mm512_kunpackw(__mmask32, __mmask32);
extern __mmask64 __cdecl _mm512_kunpackd(__mmask64, __mmask64);

extern unsigned char __cdecl _mm512_testz_and_mask8(__mmask8, __mmask8);
extern unsigned char __cdecl _mm512_testz_and_mask16(__mmask16, __mmask16);
extern unsigned char __cdecl _mm512_testz_and_mask32(__mmask32, __mmask32);
extern unsigned char __cdecl _mm512_testz_and_mask64(__mmask64, __mmask64);
extern unsigned char __cdecl _mm512_testz_andn_mask8(__mmask8, __mmask8);
extern unsigned char __cdecl _mm512_testz_andn_mask16(__mmask16, __mmask16);
extern unsigned char __cdecl _mm512_testz_andn_mask32(__mmask32, __mmask32);
extern unsigned char __cdecl _mm512_testz_andn_mask64(__mmask64, __mmask64);
extern unsigned char __cdecl _mm512_testz_or_mask8(__mmask8, __mmask8);
extern unsigned char __cdecl _mm512_testz_or_mask16(__mmask16, __mmask16);
extern unsigned char __cdecl _mm512_testz_or_mask32(__mmask32, __mmask32);
extern unsigned char __cdecl _mm512_testz_or_mask64(__mmask64, __mmask64);
extern unsigned char __cdecl _mm512_testz_nor_mask8(__mmask8, __mmask8);
extern unsigned char __cdecl _mm512_testz_nor_mask16(__mmask16, __mmask16);
extern unsigned char __cdecl _mm512_testz_nor_mask32(__mmask32, __mmask32);
extern unsigned char __cdecl _mm512_testz_nor_mask64(__mmask64, __mmask64);

extern __m512  __cdecl _mm512_i32gather_ps(__m512i, void const*, int);
extern __m512  __cdecl _mm512_mask_i32gather_ps(__m512, __mmask16, __m512i, void const*, int);
extern void    __cdecl _mm512_i32scatter_ps(void*, __m512i, __m512, int);
extern void    __cdecl _mm512_mask_i32scatter_ps(void*, __mmask16, __m512i, __m512, int);
extern __m512d __cdecl _mm512_i64gather_pd(__m512i, void const*, int);
extern __m512d __cdecl _mm512_mask_i64gather_pd(__m512d, __mmask8, __m512i, void const*, int);
extern void    __cdecl _mm512_i64scatter_pd(void*, __m512i, __m512d, int);
extern void    __cdecl _mm512_mask_i64scatter_pd(void*, __mmask8, __m512i, __m512d, int);
extern __m512d __cdecl _mm512_i32gather_pd(__m256i, void const*, int);
extern __m512d __cdecl _mm512_mask_i32gather_pd(__m512d, __mmask8, __m256i, void const*, int);
extern void    __cdecl _mm512_i32scatter_pd(void*, __m256i, __m512d, int);
extern void    __cdecl _mm512_mask_i32scatter_pd(void*, __mmask8, __m256i, __m512d, int);
extern __m512i __cdecl _mm512_i32gather_epi32(__m512i, void const*, int);
extern __m512i __cdecl _mm512_mask_i32gather_epi32(__m512i, __mmask16, __m512i, void const*, int);
extern void    __cdecl _mm512_i32scatter_epi32(void*, __m512i, __m512i, int);
extern void    __cdecl _mm512_mask_i32scatter_epi32(void*, __mmask16, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_i32gather_epi64(__m256i, void const*, int);
extern __m512i __cdecl _mm512_mask_i32gather_epi64(__m512i, __mmask8, __m256i, void const*, int);
extern __m512i __cdecl _mm512_i64gather_epi64(__m512i, void const*, int);
extern __m512i __cdecl _mm512_mask_i64gather_epi64(__m512i, __mmask8, __m512i, void const*, int);
extern void    __cdecl _mm512_i32scatter_epi64(void*, __m256i, __m512i, int);
extern void    __cdecl _mm512_mask_i32scatter_epi64(void*, __mmask8, __m256i, __m512i, int);
extern void    __cdecl _mm512_i64scatter_epi64(void*, __m512i, __m512i, int);
extern void    __cdecl _mm512_mask_i64scatter_epi64(void*, __mmask8, __m512i, __m512i, int);
extern __m256  __cdecl _mm512_i64gather_ps(__m512i, void const*, int);
extern __m256  __cdecl _mm512_mask_i64gather_ps(__m256, __mmask8, __m512i, void const*, int);
extern void    __cdecl _mm512_i64scatter_ps(void*, __m512i, __m256, int);
extern void    __cdecl _mm512_mask_i64scatter_ps(void*, __mmask8, __m512i, __m256, int);
extern __m256i __cdecl _mm512_i64gather_epi32(__m512i, void const*, int);
extern __m256i __cdecl _mm512_mask_i64gather_epi32(__m256i, __mmask8, __m512i, void const*, int);
extern void    __cdecl _mm512_i64scatter_epi32(void*, __m512i, __m256i, int);
extern void    __cdecl _mm512_mask_i64scatter_epi32(void*, __mmask8, __m512i, __m256i, int);

extern __m512d __cdecl _mm512_cvtpslo_pd(__m512);
extern __m512d __cdecl _mm512_mask_cvtpslo_pd(__m512d, __mmask8, __m512);
extern __m512d __cdecl _mm512_cvtepi32lo_pd(__m512i);
extern __m512d __cdecl _mm512_mask_cvtepi32lo_pd(__m512d, __mmask8, __m512i);
extern __m512d __cdecl _mm512_cvtepu32lo_pd(__m512i);
extern __m512d __cdecl _mm512_mask_cvtepu32lo_pd(__m512d, __mmask8, __m512i);
extern __m512d __cdecl _mm512_cvtepi32_pd(__m256i);
extern __m512d __cdecl _mm512_mask_cvtepi32_pd(__m512d, __mmask8, __m256i);
extern __m512d __cdecl _mm512_maskz_cvtepi32_pd(__mmask8, __m256i);
extern __m512d __cdecl _mm512_cvtepu32_pd(__m256i);
extern __m512d __cdecl _mm512_mask_cvtepu32_pd(__m512d, __mmask8, __m256i);
extern __m512d __cdecl _mm512_maskz_cvtepu32_pd(__mmask8, __m256i);

extern __m512  __cdecl _mm512_cvtepi32_ps( __m512i);
extern __m512  __cdecl _mm512_mask_cvtepi32_ps(__m512, __mmask16, __m512i);
extern __m512  __cdecl _mm512_maskz_cvtepi32_ps(__mmask16, __m512i);
extern __m512  __cdecl _mm512_cvt_roundepi32_ps(__m512i, int);
extern __m512  __cdecl _mm512_mask_cvt_roundepi32_ps(__m512, __mmask16, __m512i, int);
extern __m512  __cdecl _mm512_maskz_cvt_roundepi32_ps(__mmask16, __m512i, int);
extern __m512  __cdecl _mm512_cvtepu32_ps( __m512i);
extern __m512  __cdecl _mm512_mask_cvtepu32_ps(__m512, __mmask16, __m512i);
extern __m512  __cdecl _mm512_maskz_cvtepu32_ps(__mmask16, __m512i);
extern __m512  __cdecl _mm512_cvt_roundepu32_ps(__m512i, int);
extern __m512  __cdecl _mm512_mask_cvt_roundepu32_ps(__m512, __mmask16, __m512i, int);
extern __m512  __cdecl _mm512_maskz_cvt_roundepu32_ps(__mmask16, __m512i, int);
extern __m512  __cdecl _mm512_cvtph_ps(__m256i);
extern __m512  __cdecl _mm512_mask_cvtph_ps(__m512, __mmask16, __m256i);
extern __m512  __cdecl _mm512_maskz_cvtph_ps(__mmask16, __m256i);
extern __m512  __cdecl _mm512_cvt_roundph_ps(__m256i, int);
extern __m512  __cdecl _mm512_mask_cvt_roundph_ps(__m512, __mmask16, __m256i, int);
extern __m512  __cdecl _mm512_maskz_cvt_roundph_ps(__mmask16, __m256i, int);
extern __m256i __cdecl _mm512_cvtps_ph(__m512, int);
extern __m256i __cdecl _mm512_mask_cvtps_ph(__m256i, __mmask16, __m512, int);
extern __m256i __cdecl _mm512_maskz_cvtps_ph(__mmask16, __m512, int);
extern __m256i __cdecl _mm512_cvt_roundps_ph(__m512, int);
extern __m256i __cdecl _mm512_mask_cvt_roundps_ph(__m256i, __mmask16, __m512, int);
extern __m256i __cdecl _mm512_maskz_cvt_roundps_ph(__mmask16, __m512, int);
extern __m256  __cdecl _mm512_cvtepi64_ps(__m512i);
extern __m256  __cdecl _mm512_mask_cvtepi64_ps(__m256, __mmask8, __m512i);
extern __m256  __cdecl _mm512_maskz_cvtepi64_ps(__mmask8, __m512i);
extern __m256  __cdecl _mm512_cvt_roundepi64_ps(__m512i, int);
extern __m256  __cdecl _mm512_mask_cvt_roundepi64_ps(__m256, __mmask8, __m512i, int);
extern __m256  __cdecl _mm512_maskz_cvt_roundepi64_ps(__mmask8, __m512i, int);
extern __m256  __cdecl _mm512_cvtepu64_ps(__m512i);
extern __m256  __cdecl _mm512_mask_cvtepu64_ps(__m256, __mmask8, __m512i);
extern __m256  __cdecl _mm512_maskz_cvtepu64_ps(__mmask8, __m512i);
extern __m256  __cdecl _mm512_cvt_roundepu64_ps(__m512i, int);
extern __m256  __cdecl _mm512_mask_cvt_roundepu64_ps(__m256, __mmask8, __m512i, int);
extern __m256  __cdecl _mm512_maskz_cvt_roundepu64_ps(__mmask8, __m512i, int);

extern __m512i __cdecl _mm512_cvtepi8_epi32(__m128i);
extern __m512i __cdecl _mm512_mask_cvtepi8_epi32(__m512i, __mmask16, __m128i);
extern __m512i __cdecl _mm512_maskz_cvtepi8_epi32(__mmask16, __m128i);
extern __m512i __cdecl _mm512_cvtepi8_epi64(__m128i);
extern __m512i __cdecl _mm512_mask_cvtepi8_epi64(__m512i, __mmask8, __m128i);
extern __m512i __cdecl _mm512_maskz_cvtepi8_epi64(__mmask8, __m128i);
extern __m512i __cdecl _mm512_cvtepi16_epi32(__m256i);
extern __m512i __cdecl _mm512_mask_cvtepi16_epi32(__m512i, __mmask16, __m256i);
extern __m512i __cdecl _mm512_maskz_cvtepi16_epi32(__mmask16, __m256i);
extern __m512i __cdecl _mm512_cvtepi16_epi64(__m128i);
extern __m512i __cdecl _mm512_mask_cvtepi16_epi64(__m512i, __mmask8, __m128i);
extern __m512i __cdecl _mm512_maskz_cvtepi16_epi64(__mmask8, __m128i);
extern __m128i __cdecl _mm512_cvtepi32_epi8(__m512i);
extern __m128i __cdecl _mm512_mask_cvtepi32_epi8(__m128i, __mmask16, __m512i);
extern __m128i __cdecl _mm512_maskz_cvtepi32_epi8(__mmask16, __m512i);
extern void    __cdecl _mm512_mask_cvtepi32_storeu_epi8(void*, __mmask16, __m512i);
extern __m128i __cdecl _mm512_cvtsepi32_epi8(__m512i);
extern __m128i __cdecl _mm512_mask_cvtsepi32_epi8(__m128i, __mmask16, __m512i);
extern __m128i __cdecl _mm512_maskz_cvtsepi32_epi8(__mmask16, __m512i);
extern void    __cdecl _mm512_mask_cvtsepi32_storeu_epi8(void*, __mmask16, __m512i);
extern __m128i __cdecl _mm512_cvtusepi32_epi8(__m512i);
extern __m128i __cdecl _mm512_mask_cvtusepi32_epi8(__m128i, __mmask16, __m512i);
extern __m128i __cdecl _mm512_maskz_cvtusepi32_epi8(__mmask16, __m512i);
extern void    __cdecl _mm512_mask_cvtusepi32_storeu_epi8(void*, __mmask16, __m512i);
extern __m256i __cdecl _mm512_cvtepi32_epi16(__m512i);
extern __m256i __cdecl _mm512_mask_cvtepi32_epi16(__m256i, __mmask16, __m512i);
extern __m256i __cdecl _mm512_maskz_cvtepi32_epi16(__mmask16, __m512i);
extern void    __cdecl _mm512_mask_cvtepi32_storeu_epi16(void*, __mmask16, __m512i);
extern __m256i __cdecl _mm512_cvtsepi32_epi16(__m512i);
extern __m256i __cdecl _mm512_mask_cvtsepi32_epi16(__m256i, __mmask16, __m512i);
extern __m256i __cdecl _mm512_maskz_cvtsepi32_epi16(__mmask16, __m512i);
extern void    __cdecl _mm512_mask_cvtsepi32_storeu_epi16(void*, __mmask16, __m512i);
extern __m256i __cdecl _mm512_cvtusepi32_epi16(__m512i);
extern __m256i __cdecl _mm512_mask_cvtusepi32_epi16(__m256i, __mmask16, __m512i);
extern __m256i __cdecl _mm512_maskz_cvtusepi32_epi16(__mmask16, __m512i);
extern void    __cdecl _mm512_mask_cvtusepi32_storeu_epi16(void*, __mmask16, __m512i);
extern __m512i __cdecl _mm512_cvtepi32_epi64(__m256i);
extern __m512i __cdecl _mm512_mask_cvtepi32_epi64(__m512i, __mmask8, __m256i);
extern __m512i __cdecl _mm512_maskz_cvtepi32_epi64(__mmask8, __m256i);
extern __m128i __cdecl _mm512_cvtepi64_epi8(__m512i);
extern __m128i __cdecl _mm512_mask_cvtepi64_epi8(__m128i, __mmask8, __m512i);
extern __m128i __cdecl _mm512_maskz_cvtepi64_epi8(__mmask8, __m512i);
extern void    __cdecl _mm512_mask_cvtepi64_storeu_epi8(void*, __mmask8, __m512i);
extern __m128i __cdecl _mm512_cvtsepi64_epi8(__m512i);
extern __m128i __cdecl _mm512_mask_cvtsepi64_epi8(__m128i, __mmask8, __m512i);
extern __m128i __cdecl _mm512_maskz_cvtsepi64_epi8(__mmask8, __m512i);
extern void    __cdecl _mm512_mask_cvtsepi64_storeu_epi8(void*, __mmask8, __m512i);
extern __m128i __cdecl _mm512_cvtusepi64_epi8(__m512i);
extern __m128i __cdecl _mm512_mask_cvtusepi64_epi8(__m128i, __mmask8, __m512i);
extern __m128i __cdecl _mm512_maskz_cvtusepi64_epi8(__mmask8, __m512i);
extern void    __cdecl _mm512_mask_cvtusepi64_storeu_epi8(void*, __mmask8, __m512i);
extern __m128i __cdecl _mm512_cvtepi64_epi16(__m512i);
extern __m128i __cdecl _mm512_mask_cvtepi64_epi16(__m128i, __mmask8, __m512i);
extern __m128i __cdecl _mm512_maskz_cvtepi64_epi16(__mmask8, __m512i);
extern void    __cdecl _mm512_mask_cvtepi64_storeu_epi16(void*, __mmask8, __m512i);
extern __m128i __cdecl _mm512_cvtsepi64_epi16(__m512i);
extern __m128i __cdecl _mm512_mask_cvtsepi64_epi16(__m128i, __mmask8, __m512i);
extern __m128i __cdecl _mm512_maskz_cvtsepi64_epi16(__mmask8, __m512i);
extern void    __cdecl _mm512_mask_cvtsepi64_storeu_epi16(void*, __mmask8, __m512i);
extern __m128i __cdecl _mm512_cvtusepi64_epi16(__m512i);
extern __m128i __cdecl _mm512_mask_cvtusepi64_epi16(__m128i, __mmask8, __m512i);
extern __m128i __cdecl _mm512_maskz_cvtusepi64_epi16(__mmask8, __m512i);
extern void    __cdecl _mm512_mask_cvtusepi64_storeu_epi16(void*, __mmask8, __m512i);
extern __m256i __cdecl _mm512_cvtepi64_epi32(__m512i);
extern __m256i __cdecl _mm512_mask_cvtepi64_epi32(__m256i, __mmask8, __m512i);
extern __m256i __cdecl _mm512_maskz_cvtepi64_epi32(__mmask8, __m512i);
extern void    __cdecl _mm512_mask_cvtepi64_storeu_epi32(void*, __mmask8, __m512i);
extern __m256i __cdecl _mm512_cvtsepi64_epi32(__m512i);
extern __m256i __cdecl _mm512_mask_cvtsepi64_epi32(__m256i, __mmask8, __m512i);
extern __m256i __cdecl _mm512_maskz_cvtsepi64_epi32(__mmask8, __m512i);
extern void    __cdecl _mm512_mask_cvtsepi64_storeu_epi32(void*, __mmask8, __m512i);
extern __m256i __cdecl _mm512_cvtusepi64_epi32(__m512i);
extern __m256i __cdecl _mm512_mask_cvtusepi64_epi32(__m256i, __mmask8, __m512i);
extern __m256i __cdecl _mm512_maskz_cvtusepi64_epi32(__mmask8, __m512i);
extern void    __cdecl _mm512_mask_cvtusepi64_storeu_epi32(void*, __mmask8, __m512i);
extern __m512i __cdecl _mm512_cvtepu8_epi32(__m128i);
extern __m512i __cdecl _mm512_mask_cvtepu8_epi32(__m512i, __mmask16, __m128i);
extern __m512i __cdecl _mm512_maskz_cvtepu8_epi32(__mmask16, __m128i);
extern __m512i __cdecl _mm512_cvtepu8_epi64(__m128i);
extern __m512i __cdecl _mm512_mask_cvtepu8_epi64(__m512i, __mmask8, __m128i);
extern __m512i __cdecl _mm512_maskz_cvtepu8_epi64(__mmask8, __m128i);
extern __m512i __cdecl _mm512_cvtepu16_epi32(__m256i);
extern __m512i __cdecl _mm512_mask_cvtepu16_epi32(__m512i, __mmask16, __m256i);
extern __m512i __cdecl _mm512_maskz_cvtepu16_epi32(__mmask16, __m256i);
extern __m512i __cdecl _mm512_cvtepu16_epi64(__m128i);
extern __m512i __cdecl _mm512_mask_cvtepu16_epi64(__m512i, __mmask8, __m128i);
extern __m512i __cdecl _mm512_maskz_cvtepu16_epi64(__mmask8, __m128i);
extern __m512i __cdecl _mm512_cvtepu32_epi64(__m256i);
extern __m512i __cdecl _mm512_mask_cvtepu32_epi64(__m512i, __mmask8, __m256i);
extern __m512i __cdecl _mm512_maskz_cvtepu32_epi64(__mmask8, __m256i);

extern __m512i __cdecl _mm512_cvtps_epi32(__m512);
extern __m512i __cdecl _mm512_mask_cvtps_epi32(__m512i, __mmask16, __m512);
extern __m512i __cdecl _mm512_maskz_cvtps_epi32(__mmask16, __m512);
extern __m512i __cdecl _mm512_cvt_roundps_epi32(__m512, int);
extern __m512i __cdecl _mm512_mask_cvt_roundps_epi32(__m512i, __mmask16, __m512, int);
extern __m512i __cdecl _mm512_maskz_cvt_roundps_epi32(__mmask16, __m512, int);
extern __m512i __cdecl _mm512_cvttps_epi32(__m512);
extern __m512i __cdecl _mm512_mask_cvttps_epi32(__m512i, __mmask16, __m512);
extern __m512i __cdecl _mm512_maskz_cvttps_epi32(__mmask16, __m512);
extern __m512i __cdecl _mm512_cvtt_roundps_epi32(__m512, int);
extern __m512i __cdecl _mm512_mask_cvtt_roundps_epi32(__m512i, __mmask16, __m512, int);
extern __m512i __cdecl _mm512_maskz_cvtt_roundps_epi32(__mmask16, __m512, int);
extern __m512i __cdecl _mm512_cvtps_epu32(__m512);
extern __m512i __cdecl _mm512_mask_cvtps_epu32(__m512i, __mmask16, __m512);
extern __m512i __cdecl _mm512_maskz_cvtps_epu32(__mmask16, __m512);
extern __m512i __cdecl _mm512_cvt_roundps_epu32(__m512, int);
extern __m512i __cdecl _mm512_mask_cvt_roundps_epu32(__m512i, __mmask16, __m512, int);
extern __m512i __cdecl _mm512_maskz_cvt_roundps_epu32(__mmask16, __m512, int);
extern __m512i __cdecl _mm512_cvttps_epu32(__m512);
extern __m512i __cdecl _mm512_mask_cvttps_epu32(__m512i, __mmask16, __m512);
extern __m512i __cdecl _mm512_maskz_cvttps_epu32(__mmask16, __m512);
extern __m512i __cdecl _mm512_cvtt_roundps_epu32(__m512, int);
extern __m512i __cdecl _mm512_mask_cvtt_roundps_epu32(__m512i, __mmask16, __m512, int);
extern __m512i __cdecl _mm512_maskz_cvtt_roundps_epu32(__mmask16, __m512, int);
extern __m256i __cdecl _mm512_cvtpd_epi32(__m512d);
extern __m256i __cdecl _mm512_mask_cvtpd_epi32(__m256i, __mmask8, __m512d);
extern __m256i __cdecl _mm512_maskz_cvtpd_epi32(__mmask8, __m512d);
extern __m256i __cdecl _mm512_cvt_roundpd_epi32(__m512d, int);
extern __m256i __cdecl _mm512_mask_cvt_roundpd_epi32(__m256i, __mmask8, __m512d, int);
extern __m256i __cdecl _mm512_maskz_cvt_roundpd_epi32(__mmask8, __m512d, int);
extern __m256i __cdecl _mm512_cvttpd_epi32(__m512d);
extern __m256i __cdecl _mm512_mask_cvttpd_epi32(__m256i, __mmask8, __m512d);
extern __m256i __cdecl _mm512_maskz_cvttpd_epi32(__mmask8, __m512d);
extern __m256i __cdecl _mm512_cvtt_roundpd_epi32(__m512d, int);
extern __m256i __cdecl _mm512_mask_cvtt_roundpd_epi32(__m256i, __mmask8, __m512d, int);
extern __m256i __cdecl _mm512_maskz_cvtt_roundpd_epi32(__mmask8, __m512d, int);
extern __m256i __cdecl _mm512_cvtpd_epu32(__m512d);
extern __m256i __cdecl _mm512_mask_cvtpd_epu32(__m256i, __mmask8, __m512d);
extern __m256i __cdecl _mm512_maskz_cvtpd_epu32(__mmask8, __m512d);
extern __m256i __cdecl _mm512_cvt_roundpd_epu32(__m512d, int);
extern __m256i __cdecl _mm512_mask_cvt_roundpd_epu32(__m256i, __mmask8, __m512d, int);
extern __m256i __cdecl _mm512_maskz_cvt_roundpd_epu32(__mmask8, __m512d, int);
extern __m256i __cdecl _mm512_cvttpd_epu32(__m512d);
extern __m256i __cdecl _mm512_mask_cvttpd_epu32(__m256i, __mmask8, __m512d);
extern __m256i __cdecl _mm512_maskz_cvttpd_epu32(__mmask8, __m512d);
extern __m256i __cdecl _mm512_cvtt_roundpd_epu32(__m512d, int);
extern __m256i __cdecl _mm512_mask_cvtt_roundpd_epu32(__m256i, __mmask8, __m512d, int);
extern __m256i __cdecl _mm512_maskz_cvtt_roundpd_epu32(__mmask8, __m512d, int);

extern __m512i __cdecl _mm512_cvtepi8_epi16(__m256i);
extern __m512i __cdecl _mm512_mask_cvtepi8_epi16(__m512i, __mmask32, __m256i);
extern __m512i __cdecl _mm512_maskz_cvtepi8_epi16(__mmask32, __m256i);
extern __m512i __cdecl _mm512_cvtepu8_epi16(__m256i);
extern __m512i __cdecl _mm512_mask_cvtepu8_epi16(__m512i, __mmask32, __m256i);
extern __m512i __cdecl _mm512_maskz_cvtepu8_epi16(__mmask32, __m256i);
extern __m256i __cdecl _mm512_cvtepi16_epi8(__m512i);
extern __m256i __cdecl _mm512_mask_cvtepi16_epi8(__m256i, __mmask32, __m512i);
extern __m256i __cdecl _mm512_maskz_cvtepi16_epi8(__mmask32, __m512i);
extern void    __cdecl _mm512_mask_cvtepi16_storeu_epi8(void*, __mmask32, __m512i);
extern __m256i __cdecl _mm512_cvtsepi16_epi8(__m512i);
extern __m256i __cdecl _mm512_mask_cvtsepi16_epi8(__m256i, __mmask32, __m512i);
extern __m256i __cdecl _mm512_maskz_cvtsepi16_epi8(__mmask32, __m512i);
extern void    __cdecl _mm512_mask_cvtsepi16_storeu_epi8(void*, __mmask32, __m512i);
extern __m256i __cdecl _mm512_cvtusepi16_epi8(__m512i);
extern __m256i __cdecl _mm512_mask_cvtusepi16_epi8(__m256i, __mmask32, __m512i);
extern __m256i __cdecl _mm512_maskz_cvtusepi16_epi8(__mmask32, __m512i);
extern void    __cdecl _mm512_mask_cvtusepi16_storeu_epi8(void*, __mmask32, __m512i);

extern __m512d __cdecl _mm512_cvtepi64_pd(__m512i);
extern __m512d __cdecl _mm512_mask_cvtepi64_pd(__m512d, __mmask8, __m512i);
extern __m512d __cdecl _mm512_maskz_cvtepi64_pd(__mmask8, __m512i);
extern __m512d __cdecl _mm512_cvt_roundepi64_pd(__m512i, int);
extern __m512d __cdecl _mm512_mask_cvt_roundepi64_pd(__m512d, __mmask8, __m512i, int);
extern __m512d __cdecl _mm512_maskz_cvt_roundepi64_pd(__mmask8, __m512i, int);
extern __m512d __cdecl _mm512_cvtepu64_pd(__m512i);
extern __m512d __cdecl _mm512_mask_cvtepu64_pd(__m512d, __mmask8, __m512i);
extern __m512d __cdecl _mm512_maskz_cvtepu64_pd(__mmask8, __m512i);
extern __m512d __cdecl _mm512_cvt_roundepu64_pd(__m512i, int);
extern __m512d __cdecl _mm512_mask_cvt_roundepu64_pd(__m512d, __mmask8, __m512i, int);
extern __m512d __cdecl _mm512_maskz_cvt_roundepu64_pd(__mmask8, __m512i, int);
extern __m512i __cdecl _mm512_cvtpd_epi64(__m512d);
extern __m512i __cdecl _mm512_mask_cvtpd_epi64(__m512i, __mmask8, __m512d);
extern __m512i __cdecl _mm512_maskz_cvtpd_epi64(__mmask8, __m512d);
extern __m512i __cdecl _mm512_cvt_roundpd_epi64(__m512d, int);
extern __m512i __cdecl _mm512_mask_cvt_roundpd_epi64(__m512i, __mmask8, __m512d, int);
extern __m512i __cdecl _mm512_maskz_cvt_roundpd_epi64(__mmask8, __m512d, int);
extern __m512i __cdecl _mm512_cvtpd_epu64(__m512d);
extern __m512i __cdecl _mm512_mask_cvtpd_epu64(__m512i, __mmask8, __m512d);
extern __m512i __cdecl _mm512_maskz_cvtpd_epu64(__mmask8, __m512d);
extern __m512i __cdecl _mm512_cvt_roundpd_epu64(__m512d, int);
extern __m512i __cdecl _mm512_mask_cvt_roundpd_epu64(__m512i, __mmask8, __m512d, int);
extern __m512i __cdecl _mm512_maskz_cvt_roundpd_epu64(__mmask8, __m512d, int);
extern __m512i __cdecl _mm512_cvttpd_epi64(__m512d);
extern __m512i __cdecl _mm512_mask_cvttpd_epi64(__m512i, __mmask8, __m512d);
extern __m512i __cdecl _mm512_maskz_cvttpd_epi64(__mmask8, __m512d);
extern __m512i __cdecl _mm512_cvtt_roundpd_epi64(__m512d, int);
extern __m512i __cdecl _mm512_mask_cvtt_roundpd_epi64(__m512i, __mmask8, __m512d, int);
extern __m512i __cdecl _mm512_maskz_cvtt_roundpd_epi64(__mmask8, __m512d, int);
extern __m512i __cdecl _mm512_cvttpd_epu64(__m512d);
extern __m512i __cdecl _mm512_mask_cvttpd_epu64(__m512i, __mmask8, __m512d);
extern __m512i __cdecl _mm512_maskz_cvttpd_epu64(__mmask8, __m512d);
extern __m512i __cdecl _mm512_cvtt_roundpd_epu64(__m512d, int);
extern __m512i __cdecl _mm512_mask_cvtt_roundpd_epu64(__m512i, __mmask8, __m512d, int);
extern __m512i __cdecl _mm512_maskz_cvtt_roundpd_epu64(__mmask8, __m512d, int);
extern __m512i __cdecl _mm512_cvtps_epi64(__m256);
extern __m512i __cdecl _mm512_mask_cvtps_epi64(__m512i, __mmask8, __m256);
extern __m512i __cdecl _mm512_maskz_cvtps_epi64(__mmask8, __m256);
extern __m512i __cdecl _mm512_cvt_roundps_epi64(__m256, int);
extern __m512i __cdecl _mm512_mask_cvt_roundps_epi64(__m512i, __mmask8, __m256, int);
extern __m512i __cdecl _mm512_maskz_cvt_roundps_epi64(__mmask8, __m256, int);
extern __m512i __cdecl _mm512_cvtps_epu64(__m256);
extern __m512i __cdecl _mm512_mask_cvtps_epu64(__m512i, __mmask8, __m256);
extern __m512i __cdecl _mm512_maskz_cvtps_epu64(__mmask8, __m256);
extern __m512i __cdecl _mm512_cvt_roundps_epu64(__m256, int);
extern __m512i __cdecl _mm512_mask_cvt_roundps_epu64(__m512i, __mmask8, __m256, int);
extern __m512i __cdecl _mm512_maskz_cvt_roundps_epu64(__mmask8, __m256, int);
extern __m512i __cdecl _mm512_cvttps_epi64(__m256);
extern __m512i __cdecl _mm512_mask_cvttps_epi64(__m512i, __mmask8, __m256);
extern __m512i __cdecl _mm512_maskz_cvttps_epi64(__mmask8, __m256);
extern __m512i __cdecl _mm512_cvtt_roundps_epi64(__m256, int);
extern __m512i __cdecl _mm512_mask_cvtt_roundps_epi64(__m512i, __mmask8, __m256, int);
extern __m512i __cdecl _mm512_maskz_cvtt_roundps_epi64(__mmask8, __m256, int);
extern __m512i __cdecl _mm512_cvttps_epu64(__m256);
extern __m512i __cdecl _mm512_mask_cvttps_epu64(__m512i, __mmask8, __m256);
extern __m512i __cdecl _mm512_maskz_cvttps_epu64(__mmask8, __m256);
extern __m512i __cdecl _mm512_cvtt_roundps_epu64(__m256, int);
extern __m512i __cdecl _mm512_mask_cvtt_roundps_epu64(__m512i, __mmask8, __m256, int);
extern __m512i __cdecl _mm512_maskz_cvtt_roundps_epu64(__mmask8, __m256, int);

extern __mmask64  __cdecl _mm512_cmpeq_epi8_mask(__m512i, __m512i);
extern __mmask64  __cdecl _mm512_cmpge_epi8_mask(__m512i, __m512i);
extern __mmask64  __cdecl _mm512_cmpgt_epi8_mask(__m512i, __m512i);
extern __mmask64  __cdecl _mm512_cmple_epi8_mask(__m512i, __m512i);
extern __mmask64  __cdecl _mm512_cmplt_epi8_mask(__m512i, __m512i);
extern __mmask64  __cdecl _mm512_cmpneq_epi8_mask(__m512i, __m512i);
extern __mmask64  __cdecl _mm512_cmpeq_epu8_mask(__m512i, __m512i);
extern __mmask64  __cdecl _mm512_cmpge_epu8_mask(__m512i, __m512i);
extern __mmask64  __cdecl _mm512_cmpgt_epu8_mask(__m512i, __m512i);
extern __mmask64  __cdecl _mm512_cmple_epu8_mask(__m512i, __m512i);
extern __mmask64  __cdecl _mm512_cmplt_epu8_mask(__m512i, __m512i);
extern __mmask64  __cdecl _mm512_cmpneq_epu8_mask(__m512i, __m512i);

extern __mmask64  __cdecl _mm512_mask_cmpeq_epi8_mask(__mmask64, __m512i, __m512i);
extern __mmask64  __cdecl _mm512_mask_cmpge_epi8_mask(__mmask64, __m512i, __m512i);
extern __mmask64  __cdecl _mm512_mask_cmpgt_epi8_mask(__mmask64, __m512i, __m512i);
extern __mmask64  __cdecl _mm512_mask_cmple_epi8_mask(__mmask64, __m512i, __m512i);
extern __mmask64  __cdecl _mm512_mask_cmplt_epi8_mask(__mmask64, __m512i, __m512i);
extern __mmask64  __cdecl _mm512_mask_cmpneq_epi8_mask(__mmask64, __m512i, __m512i);
extern __mmask64  __cdecl _mm512_mask_cmpeq_epu8_mask(__mmask64, __m512i, __m512i);
extern __mmask64  __cdecl _mm512_mask_cmpge_epu8_mask(__mmask64, __m512i, __m512i);
extern __mmask64  __cdecl _mm512_mask_cmpgt_epu8_mask(__mmask64, __m512i, __m512i);
extern __mmask64  __cdecl _mm512_mask_cmple_epu8_mask(__mmask64, __m512i, __m512i);
extern __mmask64  __cdecl _mm512_mask_cmplt_epu8_mask(__mmask64, __m512i, __m512i);
extern __mmask64  __cdecl _mm512_mask_cmpneq_epu8_mask(__mmask64, __m512i, __m512i);

extern __mmask32  __cdecl _mm512_cmpeq_epi16_mask(__m512i, __m512i);
extern __mmask32  __cdecl _mm512_cmpge_epi16_mask(__m512i, __m512i);
extern __mmask32  __cdecl _mm512_cmpgt_epi16_mask(__m512i, __m512i);
extern __mmask32  __cdecl _mm512_cmple_epi16_mask(__m512i, __m512i);
extern __mmask32  __cdecl _mm512_cmplt_epi16_mask(__m512i, __m512i);
extern __mmask32  __cdecl _mm512_cmpneq_epi16_mask(__m512i, __m512i);
extern __mmask32  __cdecl _mm512_cmpeq_epu16_mask(__m512i, __m512i);
extern __mmask32  __cdecl _mm512_cmpge_epu16_mask(__m512i, __m512i);
extern __mmask32  __cdecl _mm512_cmpgt_epu16_mask(__m512i, __m512i);
extern __mmask32  __cdecl _mm512_cmple_epu16_mask(__m512i, __m512i);
extern __mmask32  __cdecl _mm512_cmplt_epu16_mask(__m512i, __m512i);
extern __mmask32  __cdecl _mm512_cmpneq_epu16_mask(__m512i, __m512i);

extern __mmask32  __cdecl _mm512_mask_cmpeq_epi16_mask(__mmask32, __m512i, __m512i);
extern __mmask32  __cdecl _mm512_mask_cmpge_epi16_mask(__mmask32, __m512i, __m512i);
extern __mmask32  __cdecl _mm512_mask_cmpgt_epi16_mask(__mmask32, __m512i, __m512i);
extern __mmask32  __cdecl _mm512_mask_cmple_epi16_mask(__mmask32, __m512i, __m512i);
extern __mmask32  __cdecl _mm512_mask_cmplt_epi16_mask(__mmask32, __m512i, __m512i);
extern __mmask32  __cdecl _mm512_mask_cmpneq_epi16_mask(__mmask32, __m512i, __m512i);
extern __mmask32  __cdecl _mm512_mask_cmpeq_epu16_mask(__mmask32, __m512i, __m512i);
extern __mmask32  __cdecl _mm512_mask_cmpge_epu16_mask(__mmask32, __m512i, __m512i);
extern __mmask32  __cdecl _mm512_mask_cmpgt_epu16_mask(__mmask32, __m512i, __m512i);
extern __mmask32  __cdecl _mm512_mask_cmple_epu16_mask(__mmask32, __m512i, __m512i);
extern __mmask32  __cdecl _mm512_mask_cmplt_epu16_mask(__mmask32, __m512i, __m512i);
extern __mmask32  __cdecl _mm512_mask_cmpneq_epu16_mask(__mmask32, __m512i, __m512i);

extern __mmask16  __cdecl _mm512_cmpeq_epi32_mask(__m512i, __m512i);
extern __mmask16  __cdecl _mm512_cmpge_epi32_mask(__m512i, __m512i);
extern __mmask16  __cdecl _mm512_cmpgt_epi32_mask(__m512i, __m512i);
extern __mmask16  __cdecl _mm512_cmple_epi32_mask(__m512i, __m512i);
extern __mmask16  __cdecl _mm512_cmplt_epi32_mask(__m512i, __m512i);
extern __mmask16  __cdecl _mm512_cmpneq_epi32_mask(__m512i, __m512i);
extern __mmask16  __cdecl _mm512_cmpeq_epu32_mask(__m512i, __m512i);
extern __mmask16  __cdecl _mm512_cmpge_epu32_mask(__m512i, __m512i);
extern __mmask16  __cdecl _mm512_cmpgt_epu32_mask(__m512i, __m512i);
extern __mmask16  __cdecl _mm512_cmple_epu32_mask(__m512i, __m512i);
extern __mmask16  __cdecl _mm512_cmplt_epu32_mask(__m512i, __m512i);
extern __mmask16  __cdecl _mm512_cmpneq_epu32_mask(__m512i, __m512i);

extern __mmask16  __cdecl _mm512_mask_cmpeq_epi32_mask(__mmask16, __m512i, __m512i);
extern __mmask16  __cdecl _mm512_mask_cmpge_epi32_mask(__mmask16, __m512i, __m512i);
extern __mmask16  __cdecl _mm512_mask_cmpgt_epi32_mask(__mmask16, __m512i, __m512i);
extern __mmask16  __cdecl _mm512_mask_cmple_epi32_mask(__mmask16, __m512i, __m512i);
extern __mmask16  __cdecl _mm512_mask_cmplt_epi32_mask(__mmask16, __m512i, __m512i);
extern __mmask16  __cdecl _mm512_mask_cmpneq_epi32_mask(__mmask16, __m512i, __m512i);
extern __mmask16  __cdecl _mm512_mask_cmpeq_epu32_mask(__mmask16, __m512i, __m512i);
extern __mmask16  __cdecl _mm512_mask_cmpge_epu32_mask(__mmask16, __m512i, __m512i);
extern __mmask16  __cdecl _mm512_mask_cmpgt_epu32_mask(__mmask16, __m512i, __m512i);
extern __mmask16  __cdecl _mm512_mask_cmple_epu32_mask(__mmask16, __m512i, __m512i);
extern __mmask16  __cdecl _mm512_mask_cmplt_epu32_mask(__mmask16, __m512i, __m512i);
extern __mmask16  __cdecl _mm512_mask_cmpneq_epu32_mask(__mmask16, __m512i, __m512i);

extern __mmask8  __cdecl _mm512_cmpeq_epi64_mask(__m512i, __m512i);
extern __mmask8  __cdecl _mm512_cmpge_epi64_mask(__m512i, __m512i);
extern __mmask8  __cdecl _mm512_cmpgt_epi64_mask(__m512i, __m512i);
extern __mmask8  __cdecl _mm512_cmple_epi64_mask(__m512i, __m512i);
extern __mmask8  __cdecl _mm512_cmplt_epi64_mask(__m512i, __m512i);
extern __mmask8  __cdecl _mm512_cmpneq_epi64_mask(__m512i, __m512i);
extern __mmask8  __cdecl _mm512_cmpeq_epu64_mask(__m512i, __m512i);
extern __mmask8  __cdecl _mm512_cmpge_epu64_mask(__m512i, __m512i);
extern __mmask8  __cdecl _mm512_cmpgt_epu64_mask(__m512i, __m512i);
extern __mmask8  __cdecl _mm512_cmple_epu64_mask(__m512i, __m512i);
extern __mmask8  __cdecl _mm512_cmplt_epu64_mask(__m512i, __m512i);
extern __mmask8  __cdecl _mm512_cmpneq_epu64_mask(__m512i, __m512i);

extern __mmask8  __cdecl _mm512_mask_cmpeq_epi64_mask(__mmask8, __m512i, __m512i);
extern __mmask8  __cdecl _mm512_mask_cmpge_epi64_mask(__mmask8, __m512i, __m512i);
extern __mmask8  __cdecl _mm512_mask_cmpgt_epi64_mask(__mmask8, __m512i, __m512i);
extern __mmask8  __cdecl _mm512_mask_cmple_epi64_mask(__mmask8, __m512i, __m512i);
extern __mmask8  __cdecl _mm512_mask_cmplt_epi64_mask(__mmask8, __m512i, __m512i);
extern __mmask8  __cdecl _mm512_mask_cmpneq_epi64_mask(__mmask8, __m512i, __m512i);
extern __mmask8  __cdecl _mm512_mask_cmpeq_epu64_mask(__mmask8, __m512i, __m512i);
extern __mmask8  __cdecl _mm512_mask_cmpge_epu64_mask(__mmask8, __m512i, __m512i);
extern __mmask8  __cdecl _mm512_mask_cmpgt_epu64_mask(__mmask8, __m512i, __m512i);
extern __mmask8  __cdecl _mm512_mask_cmple_epu64_mask(__mmask8, __m512i, __m512i);
extern __mmask8  __cdecl _mm512_mask_cmplt_epu64_mask(__mmask8, __m512i, __m512i);
extern __mmask8  __cdecl _mm512_mask_cmpneq_epu64_mask(__mmask8, __m512i, __m512i);





























































extern __m128i   __cdecl _mm_mask_abs_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_abs_epi16(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_abs_epi16(__m256i, __mmask16, __m256i);
extern __m256i   __cdecl _mm256_maskz_abs_epi16(__mmask16, __m256i);
extern __m128i   __cdecl _mm_mask_abs_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_abs_epi32(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_abs_epi32(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_abs_epi32(__mmask8, __m256i);
extern __m128i   __cdecl _mm_abs_epi64(__m128i);
extern __m128i   __cdecl _mm_mask_abs_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_abs_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_abs_epi64(__m256i);
extern __m256i   __cdecl _mm256_mask_abs_epi64(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_abs_epi64(__mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_abs_epi8(__m128i, __mmask16, __m128i);
extern __m128i   __cdecl _mm_maskz_abs_epi8(__mmask16, __m128i);
extern __m256i   __cdecl _mm256_mask_abs_epi8(__m256i, __mmask32, __m256i);
extern __m256i   __cdecl _mm256_maskz_abs_epi8(__mmask32, __m256i);
extern __m128i   __cdecl _mm_mask_add_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_add_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_add_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_add_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_add_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_add_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_add_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_add_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_add_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_add_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_add_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_add_epi64(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_add_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_add_epi8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_add_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_add_epi8(__mmask32, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_add_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_add_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_add_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_add_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_add_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_add_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_add_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_add_ps(__mmask8, __m256, __m256);
extern __m128i   __cdecl _mm_mask_adds_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_adds_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_adds_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_adds_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_adds_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_adds_epi8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_adds_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_adds_epi8(__mmask32, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_adds_epu16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_adds_epu16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_adds_epu16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_adds_epu16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_adds_epu8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_adds_epu8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_adds_epu8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_adds_epu8(__mmask32, __m256i, __m256i);
extern __m128i   __cdecl _mm_alignr_epi32(__m128i, __m128i, const int);
extern __m128i   __cdecl _mm_mask_alignr_epi32(__m128i, __mmask8, __m128i, __m128i, const int);
extern __m128i   __cdecl _mm_maskz_alignr_epi32(__mmask8, __m128i, __m128i, const int);
extern __m256i   __cdecl _mm256_alignr_epi32(__m256i, __m256i, const int);
extern __m256i   __cdecl _mm256_mask_alignr_epi32(__m256i, __mmask8, __m256i, __m256i, const int);
extern __m256i   __cdecl _mm256_maskz_alignr_epi32(__mmask8, __m256i, __m256i, const int);
extern __m128i   __cdecl _mm_alignr_epi64(__m128i, __m128i, const int);
extern __m128i   __cdecl _mm_mask_alignr_epi64(__m128i, __mmask8, __m128i, __m128i, const int);
extern __m128i   __cdecl _mm_maskz_alignr_epi64(__mmask8, __m128i, __m128i, const int);
extern __m256i   __cdecl _mm256_alignr_epi64(__m256i, __m256i, const int);
extern __m256i   __cdecl _mm256_mask_alignr_epi64(__m256i, __mmask8, __m256i, __m256i, const int);
extern __m256i   __cdecl _mm256_maskz_alignr_epi64(__mmask8, __m256i, __m256i, const int);
extern __m128i   __cdecl _mm_mask_alignr_epi8(__m128i, __mmask16, __m128i, __m128i, const int);
extern __m128i   __cdecl _mm_maskz_alignr_epi8(__mmask16, __m128i, __m128i, const int);
extern __m256i   __cdecl _mm256_mask_alignr_epi8(__m256i, __mmask32, __m256i, __m256i, const int);
extern __m256i   __cdecl _mm256_maskz_alignr_epi8(__mmask32, __m256i, __m256i, const int);
extern __m128i   __cdecl _mm_and_epi32(__m128i, __m128i);
extern __m128i   __cdecl _mm_mask_and_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_and_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_and_epi32(__m256i, __m256i);
extern __m256i   __cdecl _mm256_mask_and_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_and_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_and_epi64(__m128i, __m128i);
extern __m128i   __cdecl _mm_mask_and_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_and_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_and_epi64(__m256i, __m256i);
extern __m256i   __cdecl _mm256_mask_and_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_and_epi64(__mmask8, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_and_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_and_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_and_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_and_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_and_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_and_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_and_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_and_ps(__mmask8, __m256, __m256);
extern __m128i   __cdecl _mm_andnot_epi32(__m128i, __m128i);
extern __m128i   __cdecl _mm_mask_andnot_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_andnot_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_andnot_epi32(__m256i, __m256i);
extern __m256i   __cdecl _mm256_mask_andnot_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_andnot_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_andnot_epi64(__m128i, __m128i);
extern __m128i   __cdecl _mm_mask_andnot_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_andnot_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_andnot_epi64(__m256i, __m256i);
extern __m256i   __cdecl _mm256_mask_andnot_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_andnot_epi64(__mmask8, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_andnot_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_andnot_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_andnot_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_andnot_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_andnot_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_andnot_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_andnot_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_andnot_ps(__mmask8, __m256, __m256);
extern __m128i   __cdecl _mm_mask_avg_epu16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_avg_epu16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_avg_epu16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_avg_epu16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_avg_epu8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_avg_epu8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_avg_epu8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_avg_epu8(__mmask32, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_blend_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_blend_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_blend_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_blend_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_blend_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_blend_epi64(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_blend_epi8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_blend_epi8(__mmask32, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_blend_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_blend_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_blend_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_blend_ps(__mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_broadcast_f32x2(__m128);
extern __m256    __cdecl _mm256_mask_broadcast_f32x2(__m256, __mmask8, __m128);
extern __m256    __cdecl _mm256_maskz_broadcast_f32x2(__mmask8, __m128);
extern __m256    __cdecl _mm256_broadcast_f32x4(__m128);
extern __m256    __cdecl _mm256_mask_broadcast_f32x4(__m256, __mmask8, __m128);
extern __m256    __cdecl _mm256_maskz_broadcast_f32x4(__mmask8, __m128);
extern __m256d   __cdecl _mm256_broadcast_f64x2(__m128d);
extern __m256d   __cdecl _mm256_mask_broadcast_f64x2(__m256d, __mmask8, __m128d);
extern __m256d   __cdecl _mm256_maskz_broadcast_f64x2(__mmask8, __m128d);
extern __m128i   __cdecl _mm_broadcast_i32x2(__m128i);
extern __m128i   __cdecl _mm_mask_broadcast_i32x2(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_broadcast_i32x2(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_broadcast_i32x2(__m128i);
extern __m256i   __cdecl _mm256_mask_broadcast_i32x2(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_broadcast_i32x2(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_broadcast_i32x4(__m128i);
extern __m256i   __cdecl _mm256_mask_broadcast_i32x4(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_broadcast_i32x4(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_broadcast_i64x2(__m128i);
extern __m256i   __cdecl _mm256_mask_broadcast_i64x2(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_broadcast_i64x2(__mmask8, __m128i);
extern __m128i   __cdecl _mm_mask_broadcastb_epi8(__m128i, __mmask16, __m128i);
extern __m128i   __cdecl _mm_maskz_broadcastb_epi8(__mmask16, __m128i);
extern __m256i   __cdecl _mm256_mask_broadcastb_epi8(__m256i, __mmask32, __m128i);
extern __m256i   __cdecl _mm256_maskz_broadcastb_epi8(__mmask32, __m128i);
extern __m128i   __cdecl _mm_mask_broadcastd_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_broadcastd_epi32(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_broadcastd_epi32(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_broadcastd_epi32(__mmask8, __m128i);
extern __m128i   __cdecl _mm_broadcastmb_epi64(__mmask8);
extern __m256i   __cdecl _mm256_broadcastmb_epi64(__mmask8);
extern __m128i   __cdecl _mm_broadcastmw_epi32(__mmask16);
extern __m256i   __cdecl _mm256_broadcastmw_epi32(__mmask16);
extern __m128i   __cdecl _mm_mask_broadcastq_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_broadcastq_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_broadcastq_epi64(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_broadcastq_epi64(__mmask8, __m128i);
extern __m256d   __cdecl _mm256_mask_broadcastsd_pd(__m256d, __mmask8, __m128d);
extern __m256d   __cdecl _mm256_maskz_broadcastsd_pd(__mmask8, __m128d);
extern __m128    __cdecl _mm_mask_broadcastss_ps(__m128, __mmask8, __m128);
extern __m128    __cdecl _mm_maskz_broadcastss_ps(__mmask8, __m128);
extern __m256    __cdecl _mm256_mask_broadcastss_ps(__m256, __mmask8, __m128);
extern __m256    __cdecl _mm256_maskz_broadcastss_ps(__mmask8, __m128);
extern __m128i   __cdecl _mm_mask_broadcastw_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_broadcastw_epi16(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_broadcastw_epi16(__m256i, __mmask16, __m128i);
extern __m256i   __cdecl _mm256_maskz_broadcastw_epi16(__mmask16, __m128i);
extern __mmask8  __cdecl _mm_cmp_epi16_mask(__m128i, __m128i, const int);
extern __mmask8  __cdecl _mm_mask_cmp_epi16_mask(__mmask8, __m128i, __m128i, const int);
extern __mmask16 __cdecl _mm256_cmp_epi16_mask(__m256i, __m256i, const int);
extern __mmask16 __cdecl _mm256_mask_cmp_epi16_mask(__mmask16, __m256i, __m256i, const int);
extern __mmask8  __cdecl _mm_cmp_epi32_mask(__m128i, __m128i, int);
extern __mmask8  __cdecl _mm_mask_cmp_epi32_mask(__mmask8, __m128i, __m128i, int);
extern __mmask8  __cdecl _mm256_cmp_epi32_mask(__m256i, __m256i, int);
extern __mmask8  __cdecl _mm256_mask_cmp_epi32_mask(__mmask8, __m256i, __m256i, int);
extern __mmask8  __cdecl _mm_cmp_epi64_mask(__m128i, __m128i, int);
extern __mmask8  __cdecl _mm_mask_cmp_epi64_mask(__mmask8, __m128i, __m128i, int);
extern __mmask8  __cdecl _mm256_cmp_epi64_mask(__m256i, __m256i, int);
extern __mmask8  __cdecl _mm256_mask_cmp_epi64_mask(__mmask8, __m256i, __m256i, int);
extern __mmask16 __cdecl _mm_cmp_epi8_mask(__m128i, __m128i, const int);
extern __mmask16 __cdecl _mm_mask_cmp_epi8_mask(__mmask16, __m128i, __m128i, const int);
extern __mmask32 __cdecl _mm256_cmp_epi8_mask(__m256i, __m256i, const int);
extern __mmask32 __cdecl _mm256_mask_cmp_epi8_mask(__mmask32, __m256i, __m256i, const int);
extern __mmask8  __cdecl _mm_cmp_epu16_mask(__m128i, __m128i, const int);
extern __mmask8  __cdecl _mm_mask_cmp_epu16_mask(__mmask8, __m128i, __m128i, const int);
extern __mmask16 __cdecl _mm256_cmp_epu16_mask(__m256i, __m256i, const int);
extern __mmask16 __cdecl _mm256_mask_cmp_epu16_mask(__mmask16, __m256i, __m256i, const int);
extern __mmask8  __cdecl _mm_cmp_epu32_mask(__m128i, __m128i, int);
extern __mmask8  __cdecl _mm_mask_cmp_epu32_mask(__mmask8, __m128i, __m128i, int);
extern __mmask8  __cdecl _mm256_cmp_epu32_mask(__m256i, __m256i, int);
extern __mmask8  __cdecl _mm256_mask_cmp_epu32_mask(__mmask8, __m256i, __m256i, int);
extern __mmask8  __cdecl _mm_cmp_epu64_mask(__m128i, __m128i, int);
extern __mmask8  __cdecl _mm_mask_cmp_epu64_mask(__mmask8, __m128i, __m128i, int);
extern __mmask8  __cdecl _mm256_cmp_epu64_mask(__m256i, __m256i, int);
extern __mmask8  __cdecl _mm256_mask_cmp_epu64_mask(__mmask8, __m256i, __m256i, int);
extern __mmask16 __cdecl _mm_cmp_epu8_mask(__m128i, __m128i, const int);
extern __mmask16 __cdecl _mm_mask_cmp_epu8_mask(__mmask16, __m128i, __m128i, const int);
extern __mmask32 __cdecl _mm256_cmp_epu8_mask(__m256i, __m256i, const int);
extern __mmask32 __cdecl _mm256_mask_cmp_epu8_mask(__mmask32, __m256i, __m256i, const int);
extern __mmask8  __cdecl _mm_cmp_pd_mask(__m128d, __m128d, const int);
extern __mmask8  __cdecl _mm_mask_cmp_pd_mask(__mmask8, __m128d, __m128d, const int);
extern __mmask8  __cdecl _mm256_cmp_pd_mask(__m256d, __m256d, const int);
extern __mmask8  __cdecl _mm256_mask_cmp_pd_mask(__mmask8, __m256d, __m256d, const int);
extern __mmask8  __cdecl _mm_cmp_ps_mask(__m128, __m128, const int);
extern __mmask8  __cdecl _mm_mask_cmp_ps_mask(__mmask8, __m128, __m128, const int);
extern __mmask8  __cdecl _mm256_cmp_ps_mask(__m256, __m256, const int);
extern __mmask8  __cdecl _mm256_mask_cmp_ps_mask(__mmask8, __m256, __m256, const int);
extern __m128i   __cdecl _mm_mask_compress_epi8(__m128i, __mmask16, __m128i);
extern __m128i   __cdecl _mm_maskz_compress_epi8(__mmask16, __m128i);
extern __m256i   __cdecl _mm256_mask_compress_epi8(__m256i, __mmask32, __m256i);
extern __m256i   __cdecl _mm256_maskz_compress_epi8(__mmask32, __m256i);
extern __m128i   __cdecl _mm_mask_compress_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_compress_epi16(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_compress_epi16(__m256i, __mmask16, __m256i);
extern __m256i   __cdecl _mm256_maskz_compress_epi16(__mmask16, __m256i);
extern __m128i   __cdecl _mm_mask_compress_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_compress_epi32(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_compress_epi32(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_compress_epi32(__mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_compress_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_compress_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_compress_epi64(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_compress_epi64(__mmask8, __m256i);
extern __m128d   __cdecl _mm_mask_compress_pd(__m128d, __mmask8, __m128d);
extern __m128d   __cdecl _mm_maskz_compress_pd(__mmask8, __m128d);
extern __m256d   __cdecl _mm256_mask_compress_pd(__m256d, __mmask8, __m256d);
extern __m256d   __cdecl _mm256_maskz_compress_pd(__mmask8, __m256d);
extern __m128    __cdecl _mm_mask_compress_ps(__m128, __mmask8, __m128);
extern __m128    __cdecl _mm_maskz_compress_ps(__mmask8, __m128);
extern __m256    __cdecl _mm256_mask_compress_ps(__m256, __mmask8, __m256);
extern __m256    __cdecl _mm256_maskz_compress_ps(__mmask8, __m256);
extern void      __cdecl _mm_mask_compressstoreu_epi8(void*, __mmask16, __m128i);
extern void      __cdecl _mm256_mask_compressstoreu_epi8(void*, __mmask32, __m256i);
extern void      __cdecl _mm_mask_compressstoreu_epi16(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_compressstoreu_epi16(void*, __mmask16, __m256i);
extern void      __cdecl _mm_mask_compressstoreu_epi32(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_compressstoreu_epi32(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_compressstoreu_epi64(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_compressstoreu_epi64(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_compressstoreu_pd(void*, __mmask8, __m128d);
extern void      __cdecl _mm256_mask_compressstoreu_pd(void*, __mmask8, __m256d);
extern void      __cdecl _mm_mask_compressstoreu_ps(void*, __mmask8, __m128);
extern void      __cdecl _mm256_mask_compressstoreu_ps(void*, __mmask8, __m256);
extern __m128i   __cdecl _mm_conflict_epi32(__m128i);
extern __m128i   __cdecl _mm_mask_conflict_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_conflict_epi32(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_conflict_epi32(__m256i);
extern __m256i   __cdecl _mm256_mask_conflict_epi32(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_conflict_epi32(__mmask8, __m256i);
extern __m128i   __cdecl _mm_conflict_epi64(__m128i);
extern __m128i   __cdecl _mm_mask_conflict_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_conflict_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_conflict_epi64(__m256i);
extern __m256i   __cdecl _mm256_mask_conflict_epi64(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_conflict_epi64(__mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_cvtps_ph(__m128i, __mmask8, __m128, int);
extern __m128i   __cdecl _mm_maskz_cvtps_ph(__mmask8, __m128, int);
extern __m128i   __cdecl _mm_mask_cvt_roundps_ph(__m128i, __mmask8, __m128, int);
extern __m128i   __cdecl _mm_maskz_cvt_roundps_ph(__mmask8, __m128, int);
extern __m128i   __cdecl _mm256_mask_cvtps_ph(__m128i, __mmask8, __m256, int);
extern __m128i   __cdecl _mm256_maskz_cvtps_ph(__mmask8, __m256, int);
extern __m128i   __cdecl _mm256_mask_cvt_roundps_ph(__m128i, __mmask8, __m256, int);
extern __m128i   __cdecl _mm256_maskz_cvt_roundps_ph(__mmask8, __m256, int);
extern __m128i   __cdecl _mm_mask_cvtepi16_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi16_epi32(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepi16_epi32(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepi16_epi32(__mmask8, __m128i);
extern __m128i   __cdecl _mm_mask_cvtepi16_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi16_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepi16_epi64(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepi16_epi64(__mmask8, __m128i);
extern __m128i   __cdecl _mm_cvtepi16_epi8(__m128i);
extern __m128i   __cdecl _mm_mask_cvtepi16_epi8(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi16_epi8(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtepi16_epi8(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtepi16_epi8(__m128i, __mmask16, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtepi16_epi8(__mmask16, __m256i);
extern void      __cdecl _mm_mask_cvtepi16_storeu_epi8(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtepi16_storeu_epi8(void*, __mmask16, __m256i);
extern __m128i   __cdecl _mm_cvtepi32_epi16(__m128i);
extern __m128i   __cdecl _mm_mask_cvtepi32_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi32_epi16(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtepi32_epi16(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtepi32_epi16(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtepi32_epi16(__mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_cvtepi32_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi32_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepi32_epi64(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepi32_epi64(__mmask8, __m128i);
extern __m128i   __cdecl _mm_cvtepi32_epi8(__m128i);
extern __m128i   __cdecl _mm_mask_cvtepi32_epi8(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi32_epi8(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtepi32_epi8(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtepi32_epi8(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtepi32_epi8(__mmask8, __m256i);
extern __m128d   __cdecl _mm_mask_cvtepi32_pd(__m128d, __mmask8, __m128i);
extern __m128d   __cdecl _mm_maskz_cvtepi32_pd(__mmask8, __m128i);
extern __m256d   __cdecl _mm256_mask_cvtepi32_pd(__m256d, __mmask8, __m128i);
extern __m256d   __cdecl _mm256_maskz_cvtepi32_pd(__mmask8, __m128i);
extern __m128    __cdecl _mm_mask_cvtepi32_ps(__m128, __mmask8, __m128i);
extern __m128    __cdecl _mm_maskz_cvtepi32_ps(__mmask8, __m128i);
extern __m256    __cdecl _mm256_mask_cvtepi32_ps(__m256, __mmask8, __m256i);
extern __m256    __cdecl _mm256_maskz_cvtepi32_ps(__mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtepi32_storeu_epi16(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtepi32_storeu_epi16(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtepi32_storeu_epi8(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtepi32_storeu_epi8(void*, __mmask8, __m256i);
extern __m128i   __cdecl _mm_cvtepi64_epi16(__m128i);
extern __m128i   __cdecl _mm_mask_cvtepi64_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi64_epi16(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtepi64_epi16(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtepi64_epi16(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtepi64_epi16(__mmask8, __m256i);
extern __m128i   __cdecl _mm_cvtepi64_epi32(__m128i);
extern __m128i   __cdecl _mm_mask_cvtepi64_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi64_epi32(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtepi64_epi32(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtepi64_epi32(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtepi64_epi32(__mmask8, __m256i);
extern __m128i   __cdecl _mm_cvtepi64_epi8(__m128i);
extern __m128i   __cdecl _mm_mask_cvtepi64_epi8(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi64_epi8(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtepi64_epi8(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtepi64_epi8(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtepi64_epi8(__mmask8, __m256i);
extern __m128d   __cdecl _mm_cvtepi64_pd(__m128i);
extern __m128d   __cdecl _mm_mask_cvtepi64_pd(__m128d, __mmask8, __m128i);
extern __m128d   __cdecl _mm_maskz_cvtepi64_pd(__mmask8, __m128i);
extern __m256d   __cdecl _mm256_cvtepi64_pd(__m256i);
extern __m256d   __cdecl _mm256_mask_cvtepi64_pd(__m256d, __mmask8, __m256i);
extern __m256d   __cdecl _mm256_maskz_cvtepi64_pd(__mmask8, __m256i);
extern __m128    __cdecl _mm_cvtepi64_ps(__m128i);
extern __m128    __cdecl _mm_mask_cvtepi64_ps(__m128, __mmask8, __m128i);
extern __m128    __cdecl _mm_maskz_cvtepi64_ps(__mmask8, __m128i);
extern __m128    __cdecl _mm256_cvtepi64_ps(__m256i);
extern __m128    __cdecl _mm256_mask_cvtepi64_ps(__m128, __mmask8, __m256i);
extern __m128    __cdecl _mm256_maskz_cvtepi64_ps(__mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtepi64_storeu_epi16(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtepi64_storeu_epi16(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtepi64_storeu_epi32(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtepi64_storeu_epi32(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtepi64_storeu_epi8(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtepi64_storeu_epi8(void*, __mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_cvtepi8_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi8_epi16(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepi8_epi16(__m256i, __mmask16, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepi8_epi16(__mmask16, __m128i);
extern __m128i   __cdecl _mm_mask_cvtepi8_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi8_epi32(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepi8_epi32(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepi8_epi32(__mmask8, __m128i);
extern __m128i   __cdecl _mm_mask_cvtepi8_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi8_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepi8_epi64(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepi8_epi64(__mmask8, __m128i);
extern __m128i   __cdecl _mm_mask_cvtepu16_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepu16_epi32(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepu16_epi32(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepu16_epi32(__mmask8, __m128i);
extern __m128i   __cdecl _mm_mask_cvtepu16_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepu16_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepu16_epi64(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepu16_epi64(__mmask8, __m128i);
extern __m128i   __cdecl _mm_mask_cvtepu32_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepu32_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepu32_epi64(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepu32_epi64(__mmask8, __m128i);
extern __m128    __cdecl _mm_cvtepu32_ps(__m128i);
extern __m128    __cdecl _mm_mask_cvtepu32_ps(__m128, __mmask8, __m128i);
extern __m128    __cdecl _mm_maskz_cvtepu32_ps(__mmask8, __m128i);
extern __m256    __cdecl _mm256_cvtepu32_ps(__m256i);
extern __m256    __cdecl _mm256_mask_cvtepu32_ps(__m256, __mmask8, __m256i);
extern __m256    __cdecl _mm256_maskz_cvtepu32_ps(__mmask8, __m256i);
extern __m128d   __cdecl _mm_cvtepu32_pd(__m128i);
extern __m128d   __cdecl _mm_mask_cvtepu32_pd(__m128d, __mmask8, __m128i);
extern __m128d   __cdecl _mm_maskz_cvtepu32_pd(__mmask8, __m128i);
extern __m256d   __cdecl _mm256_cvtepu32_pd(__m128i);
extern __m256d   __cdecl _mm256_mask_cvtepu32_pd(__m256d, __mmask8, __m128i);
extern __m256d   __cdecl _mm256_maskz_cvtepu32_pd(__mmask8, __m128i);
extern __m128d   __cdecl _mm_cvtepu64_pd(__m128i);
extern __m128d   __cdecl _mm_mask_cvtepu64_pd(__m128d, __mmask8, __m128i);
extern __m128d   __cdecl _mm_maskz_cvtepu64_pd(__mmask8, __m128i);
extern __m256d   __cdecl _mm256_cvtepu64_pd(__m256i);
extern __m256d   __cdecl _mm256_mask_cvtepu64_pd(__m256d, __mmask8, __m256i);
extern __m256d   __cdecl _mm256_maskz_cvtepu64_pd(__mmask8, __m256i);
extern __m128    __cdecl _mm_cvtepu64_ps(__m128i);
extern __m128    __cdecl _mm_mask_cvtepu64_ps(__m128, __mmask8, __m128i);
extern __m128    __cdecl _mm_maskz_cvtepu64_ps(__mmask8, __m128i);
extern __m128    __cdecl _mm256_cvtepu64_ps(__m256i);
extern __m128    __cdecl _mm256_mask_cvtepu64_ps(__m128, __mmask8, __m256i);
extern __m128    __cdecl _mm256_maskz_cvtepu64_ps(__mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_cvtepu8_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepu8_epi16(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepu8_epi16(__m256i, __mmask16, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepu8_epi16(__mmask16, __m128i);
extern __m128i   __cdecl _mm_mask_cvtepu8_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepu8_epi32(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepu8_epi32(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepu8_epi32(__mmask8, __m128i);
extern __m128i   __cdecl _mm_mask_cvtepu8_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepu8_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepu8_epi64(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepu8_epi64(__mmask8, __m128i);
extern __m128i   __cdecl _mm_mask_cvtpd_epi32(__m128i, __mmask8, __m128d);
extern __m128i   __cdecl _mm_maskz_cvtpd_epi32(__mmask8, __m128d);
extern __m128i   __cdecl _mm256_mask_cvtpd_epi32(__m128i, __mmask8, __m256d);
extern __m128i   __cdecl _mm256_maskz_cvtpd_epi32(__mmask8, __m256d);
extern __m128i   __cdecl _mm_cvtpd_epi64(__m128d);
extern __m128i   __cdecl _mm_mask_cvtpd_epi64(__m128i, __mmask8, __m128d);
extern __m128i   __cdecl _mm_maskz_cvtpd_epi64(__mmask8, __m128d);
extern __m256i   __cdecl _mm256_cvtpd_epi64(__m256d);
extern __m256i   __cdecl _mm256_mask_cvtpd_epi64(__m256i, __mmask8, __m256d);
extern __m256i   __cdecl _mm256_maskz_cvtpd_epi64(__mmask8, __m256d);
extern __m128i   __cdecl _mm_cvtpd_epu32(__m128d);
extern __m128i   __cdecl _mm_mask_cvtpd_epu32(__m128i, __mmask8, __m128d);
extern __m128i   __cdecl _mm_maskz_cvtpd_epu32(__mmask8, __m128d);
extern __m128i   __cdecl _mm256_cvtpd_epu32(__m256d);
extern __m128i   __cdecl _mm256_mask_cvtpd_epu32(__m128i, __mmask8, __m256d);
extern __m128i   __cdecl _mm256_maskz_cvtpd_epu32(__mmask8, __m256d);
extern __m128i   __cdecl _mm_cvtpd_epu64(__m128d);
extern __m128i   __cdecl _mm_mask_cvtpd_epu64(__m128i, __mmask8, __m128d);
extern __m128i   __cdecl _mm_maskz_cvtpd_epu64(__mmask8, __m128d);
extern __m256i   __cdecl _mm256_cvtpd_epu64(__m256d);
extern __m256i   __cdecl _mm256_mask_cvtpd_epu64(__m256i, __mmask8, __m256d);
extern __m256i   __cdecl _mm256_maskz_cvtpd_epu64(__mmask8, __m256d);
extern __m128    __cdecl _mm_mask_cvtpd_ps(__m128, __mmask8, __m128d);
extern __m128    __cdecl _mm_maskz_cvtpd_ps(__mmask8, __m128d);
extern __m128    __cdecl _mm256_mask_cvtpd_ps(__m128, __mmask8, __m256d);
extern __m128    __cdecl _mm256_maskz_cvtpd_ps(__mmask8, __m256d);
extern __m128    __cdecl _mm_mask_cvtph_ps(__m128, __mmask8, __m128i);
extern __m128    __cdecl _mm_maskz_cvtph_ps(__mmask8, __m128i);
extern __m256    __cdecl _mm256_mask_cvtph_ps(__m256, __mmask8, __m128i);
extern __m256    __cdecl _mm256_maskz_cvtph_ps(__mmask8, __m128i);
extern __m128i   __cdecl _mm_mask_cvtps_epi32(__m128i, __mmask8, __m128);
extern __m128i   __cdecl _mm_maskz_cvtps_epi32(__mmask8, __m128);
extern __m256i   __cdecl _mm256_mask_cvtps_epi32(__m256i, __mmask8, __m256);
extern __m256i   __cdecl _mm256_maskz_cvtps_epi32(__mmask8, __m256);
extern __m128i   __cdecl _mm_cvtps_epi64(__m128);
extern __m128i   __cdecl _mm_mask_cvtps_epi64(__m128i, __mmask8, __m128);
extern __m128i   __cdecl _mm_maskz_cvtps_epi64(__mmask8, __m128);
extern __m256i   __cdecl _mm256_cvtps_epi64(__m128);
extern __m256i   __cdecl _mm256_mask_cvtps_epi64(__m256i, __mmask8, __m128);
extern __m256i   __cdecl _mm256_maskz_cvtps_epi64(__mmask8, __m128);
extern __m128i   __cdecl _mm_cvtps_epu32(__m128);
extern __m128i   __cdecl _mm_mask_cvtps_epu32(__m128i, __mmask8, __m128);
extern __m128i   __cdecl _mm_maskz_cvtps_epu32(__mmask8, __m128);
extern __m256i   __cdecl _mm256_cvtps_epu32(__m256);
extern __m256i   __cdecl _mm256_mask_cvtps_epu32(__m256i, __mmask8, __m256);
extern __m256i   __cdecl _mm256_maskz_cvtps_epu32(__mmask8, __m256);
extern __m128i   __cdecl _mm_cvtps_epu64(__m128);
extern __m128i   __cdecl _mm_mask_cvtps_epu64(__m128i, __mmask8, __m128);
extern __m128i   __cdecl _mm_maskz_cvtps_epu64(__mmask8, __m128);
extern __m256i   __cdecl _mm256_cvtps_epu64(__m128);
extern __m256i   __cdecl _mm256_mask_cvtps_epu64(__m256i, __mmask8, __m128);
extern __m256i   __cdecl _mm256_maskz_cvtps_epu64(__mmask8, __m128);
extern __m128d   __cdecl _mm_mask_cvtps_pd(__m128d, __mmask8, __m128);
extern __m128d   __cdecl _mm_maskz_cvtps_pd(__mmask8, __m128);
extern __m256d   __cdecl _mm256_mask_cvtps_pd(__m256d, __mmask8, __m128);
extern __m256d   __cdecl _mm256_maskz_cvtps_pd(__mmask8, __m128);
extern __m128i   __cdecl _mm_cvtsepi16_epi8(__m128i);
extern __m128i   __cdecl _mm_mask_cvtsepi16_epi8(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtsepi16_epi8(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtsepi16_epi8(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtsepi16_epi8(__m128i, __mmask16, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtsepi16_epi8(__mmask16, __m256i);
extern void      __cdecl _mm_mask_cvtsepi16_storeu_epi8(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtsepi16_storeu_epi8(void*, __mmask16, __m256i);
extern __m128i   __cdecl _mm_cvtsepi32_epi16(__m128i);
extern __m128i   __cdecl _mm_mask_cvtsepi32_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtsepi32_epi16(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtsepi32_epi16(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtsepi32_epi16(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtsepi32_epi16(__mmask8, __m256i);
extern __m128i   __cdecl _mm_cvtsepi32_epi8(__m128i);
extern __m128i   __cdecl _mm_mask_cvtsepi32_epi8(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtsepi32_epi8(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtsepi32_epi8(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtsepi32_epi8(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtsepi32_epi8(__mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtsepi32_storeu_epi16(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtsepi32_storeu_epi16(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtsepi32_storeu_epi8(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtsepi32_storeu_epi8(void*, __mmask8, __m256i);
extern __m128i   __cdecl _mm_cvtsepi64_epi16(__m128i);
extern __m128i   __cdecl _mm_mask_cvtsepi64_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtsepi64_epi16(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtsepi64_epi16(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtsepi64_epi16(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtsepi64_epi16(__mmask8, __m256i);
extern __m128i   __cdecl _mm_cvtsepi64_epi32(__m128i);
extern __m128i   __cdecl _mm_mask_cvtsepi64_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtsepi64_epi32(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtsepi64_epi32(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtsepi64_epi32(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtsepi64_epi32(__mmask8, __m256i);
extern __m128i   __cdecl _mm_cvtsepi64_epi8(__m128i);
extern __m128i   __cdecl _mm_mask_cvtsepi64_epi8(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtsepi64_epi8(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtsepi64_epi8(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtsepi64_epi8(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtsepi64_epi8(__mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtsepi64_storeu_epi16(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtsepi64_storeu_epi16(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtsepi64_storeu_epi32(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtsepi64_storeu_epi32(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtsepi64_storeu_epi8(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtsepi64_storeu_epi8(void*, __mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_cvttpd_epi32(__m128i, __mmask8, __m128d);
extern __m128i   __cdecl _mm_maskz_cvttpd_epi32(__mmask8, __m128d);
extern __m128i   __cdecl _mm256_mask_cvttpd_epi32(__m128i, __mmask8, __m256d);
extern __m128i   __cdecl _mm256_maskz_cvttpd_epi32(__mmask8, __m256d);
extern __m128i   __cdecl _mm_cvttpd_epi64(__m128d);
extern __m128i   __cdecl _mm_mask_cvttpd_epi64(__m128i, __mmask8, __m128d);
extern __m128i   __cdecl _mm_maskz_cvttpd_epi64(__mmask8, __m128d);
extern __m256i   __cdecl _mm256_cvttpd_epi64(__m256d);
extern __m256i   __cdecl _mm256_mask_cvttpd_epi64(__m256i, __mmask8, __m256d);
extern __m256i   __cdecl _mm256_maskz_cvttpd_epi64(__mmask8, __m256d);
extern __m128i   __cdecl _mm_cvttpd_epu32(__m128d);
extern __m128i   __cdecl _mm_mask_cvttpd_epu32(__m128i, __mmask8, __m128d);
extern __m128i   __cdecl _mm_maskz_cvttpd_epu32(__mmask8, __m128d);
extern __m128i   __cdecl _mm256_cvttpd_epu32(__m256d);
extern __m128i   __cdecl _mm256_mask_cvttpd_epu32(__m128i, __mmask8, __m256d);
extern __m128i   __cdecl _mm256_maskz_cvttpd_epu32(__mmask8, __m256d);
extern __m128i   __cdecl _mm_cvttpd_epu64(__m128d);
extern __m128i   __cdecl _mm_mask_cvttpd_epu64(__m128i, __mmask8, __m128d);
extern __m128i   __cdecl _mm_maskz_cvttpd_epu64(__mmask8, __m128d);
extern __m256i   __cdecl _mm256_cvttpd_epu64(__m256d);
extern __m256i   __cdecl _mm256_mask_cvttpd_epu64(__m256i, __mmask8, __m256d);
extern __m256i   __cdecl _mm256_maskz_cvttpd_epu64(__mmask8, __m256d);
extern __m128i   __cdecl _mm_mask_cvttps_epi32(__m128i, __mmask8, __m128);
extern __m128i   __cdecl _mm_maskz_cvttps_epi32(__mmask8, __m128);
extern __m256i   __cdecl _mm256_mask_cvttps_epi32(__m256i, __mmask8, __m256);
extern __m256i   __cdecl _mm256_maskz_cvttps_epi32(__mmask8, __m256);
extern __m128i   __cdecl _mm_cvttps_epi64(__m128);
extern __m128i   __cdecl _mm_mask_cvttps_epi64(__m128i, __mmask8, __m128);
extern __m128i   __cdecl _mm_maskz_cvttps_epi64(__mmask8, __m128);
extern __m256i   __cdecl _mm256_cvttps_epi64(__m128);
extern __m256i   __cdecl _mm256_mask_cvttps_epi64(__m256i, __mmask8, __m128);
extern __m256i   __cdecl _mm256_maskz_cvttps_epi64(__mmask8, __m128);
extern __m128i   __cdecl _mm_cvttps_epu32(__m128);
extern __m128i   __cdecl _mm_mask_cvttps_epu32(__m128i, __mmask8, __m128);
extern __m128i   __cdecl _mm_maskz_cvttps_epu32(__mmask8, __m128);
extern __m256i   __cdecl _mm256_cvttps_epu32(__m256);
extern __m256i   __cdecl _mm256_mask_cvttps_epu32(__m256i, __mmask8, __m256);
extern __m256i   __cdecl _mm256_maskz_cvttps_epu32(__mmask8, __m256);
extern __m128i   __cdecl _mm_cvttps_epu64(__m128);
extern __m128i   __cdecl _mm_mask_cvttps_epu64(__m128i, __mmask8, __m128);
extern __m128i   __cdecl _mm_maskz_cvttps_epu64(__mmask8, __m128);
extern __m256i   __cdecl _mm256_cvttps_epu64(__m128);
extern __m256i   __cdecl _mm256_mask_cvttps_epu64(__m256i, __mmask8, __m128);
extern __m256i   __cdecl _mm256_maskz_cvttps_epu64(__mmask8, __m128);
extern __m128i   __cdecl _mm_cvtusepi16_epi8(__m128i);
extern __m128i   __cdecl _mm_mask_cvtusepi16_epi8(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtusepi16_epi8(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtusepi16_epi8(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtusepi16_epi8(__m128i, __mmask16, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtusepi16_epi8(__mmask16, __m256i);
extern void      __cdecl _mm_mask_cvtusepi16_storeu_epi8(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtusepi16_storeu_epi8(void*, __mmask16, __m256i);
extern __m128i   __cdecl _mm_cvtusepi32_epi16(__m128i);
extern __m128i   __cdecl _mm_mask_cvtusepi32_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtusepi32_epi16(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtusepi32_epi16(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtusepi32_epi16(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtusepi32_epi16(__mmask8, __m256i);
extern __m128i   __cdecl _mm_cvtusepi32_epi8(__m128i);
extern __m128i   __cdecl _mm_mask_cvtusepi32_epi8(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtusepi32_epi8(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtusepi32_epi8(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtusepi32_epi8(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtusepi32_epi8(__mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtusepi32_storeu_epi16(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtusepi32_storeu_epi16(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtusepi32_storeu_epi8(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtusepi32_storeu_epi8(void*, __mmask8, __m256i);
extern __m128i   __cdecl _mm_cvtusepi64_epi16(__m128i);
extern __m128i   __cdecl _mm_mask_cvtusepi64_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtusepi64_epi16(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtusepi64_epi16(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtusepi64_epi16(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtusepi64_epi16(__mmask8, __m256i);
extern __m128i   __cdecl _mm_cvtusepi64_epi32(__m128i);
extern __m128i   __cdecl _mm_mask_cvtusepi64_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtusepi64_epi32(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtusepi64_epi32(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtusepi64_epi32(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtusepi64_epi32(__mmask8, __m256i);
extern __m128i   __cdecl _mm_cvtusepi64_epi8(__m128i);
extern __m128i   __cdecl _mm_mask_cvtusepi64_epi8(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtusepi64_epi8(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtusepi64_epi8(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtusepi64_epi8(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtusepi64_epi8(__mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtusepi64_storeu_epi16(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtusepi64_storeu_epi16(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtusepi64_storeu_epi32(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtusepi64_storeu_epi32(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtusepi64_storeu_epi8(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtusepi64_storeu_epi8(void*, __mmask8, __m256i);
extern __m128i   __cdecl _mm_dbsad_epu8(__m128i, __m128i, int);
extern __m128i   __cdecl _mm_mask_dbsad_epu8(__m128i, __mmask8, __m128i, __m128i, int);
extern __m128i   __cdecl _mm_maskz_dbsad_epu8(__mmask8, __m128i, __m128i, int);
extern __m256i   __cdecl _mm256_dbsad_epu8(__m256i, __m256i, int);
extern __m256i   __cdecl _mm256_mask_dbsad_epu8(__m256i, __mmask16, __m256i, __m256i, int);
extern __m256i   __cdecl _mm256_maskz_dbsad_epu8(__mmask16, __m256i, __m256i, int);
extern __m128d   __cdecl _mm_mask_div_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_div_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_div_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_div_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_div_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_div_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_div_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_div_ps(__mmask8, __m256, __m256);
extern __m128i   __cdecl _mm_mask_expand_epi8(__m128i, __mmask16, __m128i);
extern __m128i   __cdecl _mm_maskz_expand_epi8(__mmask16, __m128i);
extern __m256i   __cdecl _mm256_mask_expand_epi8(__m256i, __mmask32, __m256i);
extern __m256i   __cdecl _mm256_maskz_expand_epi8(__mmask32, __m256i);
extern __m128i   __cdecl _mm_mask_expand_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_expand_epi16(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_expand_epi16(__m256i, __mmask16, __m256i);
extern __m256i   __cdecl _mm256_maskz_expand_epi16(__mmask16, __m256i);
extern __m128i   __cdecl _mm_mask_expand_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_expand_epi32(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_expand_epi32(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_expand_epi32(__mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_expand_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_expand_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_expand_epi64(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_expand_epi64(__mmask8, __m256i);
extern __m128d   __cdecl _mm_mask_expand_pd(__m128d, __mmask8, __m128d);
extern __m128d   __cdecl _mm_maskz_expand_pd(__mmask8, __m128d);
extern __m256d   __cdecl _mm256_mask_expand_pd(__m256d, __mmask8, __m256d);
extern __m256d   __cdecl _mm256_maskz_expand_pd(__mmask8, __m256d);
extern __m128    __cdecl _mm_mask_expand_ps(__m128, __mmask8, __m128);
extern __m128    __cdecl _mm_maskz_expand_ps(__mmask8, __m128);
extern __m256    __cdecl _mm256_mask_expand_ps(__m256, __mmask8, __m256);
extern __m256    __cdecl _mm256_maskz_expand_ps(__mmask8, __m256);
extern __m128i   __cdecl _mm_mask_expandloadu_epi8(__m128i, __mmask16, const void*);
extern __m128i   __cdecl _mm_maskz_expandloadu_epi8(__mmask16, const void*);
extern __m256i   __cdecl _mm256_mask_expandloadu_epi8(__m256i, __mmask32, const void*);
extern __m256i   __cdecl _mm256_maskz_expandloadu_epi8(__mmask32, const void*);
extern __m128i   __cdecl _mm_mask_expandloadu_epi16(__m128i, __mmask8, const void*);
extern __m128i   __cdecl _mm_maskz_expandloadu_epi16(__mmask8, const void*);
extern __m256i   __cdecl _mm256_mask_expandloadu_epi16(__m256i, __mmask16, const void*);
extern __m256i   __cdecl _mm256_maskz_expandloadu_epi16(__mmask16, const void*);
extern __m128i   __cdecl _mm_mask_expandloadu_epi32(__m128i, __mmask8, void const*);
extern __m128i   __cdecl _mm_maskz_expandloadu_epi32(__mmask8, void const*);
extern __m256i   __cdecl _mm256_mask_expandloadu_epi32(__m256i, __mmask8, void const*);
extern __m256i   __cdecl _mm256_maskz_expandloadu_epi32(__mmask8, void const*);
extern __m128i   __cdecl _mm_mask_expandloadu_epi64(__m128i, __mmask8, void const*);
extern __m128i   __cdecl _mm_maskz_expandloadu_epi64(__mmask8, void const*);
extern __m256i   __cdecl _mm256_mask_expandloadu_epi64(__m256i, __mmask8, void const*);
extern __m256i   __cdecl _mm256_maskz_expandloadu_epi64(__mmask8, void const*);
extern __m128d   __cdecl _mm_mask_expandloadu_pd(__m128d, __mmask8, void const*);
extern __m128d   __cdecl _mm_maskz_expandloadu_pd(__mmask8, void const*);
extern __m256d   __cdecl _mm256_mask_expandloadu_pd(__m256d, __mmask8, void const*);
extern __m256d   __cdecl _mm256_maskz_expandloadu_pd(__mmask8, void const*);
extern __m128    __cdecl _mm_mask_expandloadu_ps(__m128, __mmask8, void const*);
extern __m128    __cdecl _mm_maskz_expandloadu_ps(__mmask8, void const*);
extern __m256    __cdecl _mm256_mask_expandloadu_ps(__m256, __mmask8, void const*);
extern __m256    __cdecl _mm256_maskz_expandloadu_ps(__mmask8, void const*);
extern __m128    __cdecl _mm256_extractf32x4_ps(__m256, int);
extern __m128    __cdecl _mm256_mask_extractf32x4_ps(__m128, __mmask8, __m256, int);
extern __m128    __cdecl _mm256_maskz_extractf32x4_ps(__mmask8, __m256, int);
extern __m128d   __cdecl _mm256_extractf64x2_pd(__m256d, int);
extern __m128d   __cdecl _mm256_mask_extractf64x2_pd(__m128d, __mmask8, __m256d, int);
extern __m128d   __cdecl _mm256_maskz_extractf64x2_pd(__mmask8, __m256d, int);
extern __m128i   __cdecl _mm256_extracti32x4_epi32(__m256i, int);
extern __m128i   __cdecl _mm256_mask_extracti32x4_epi32(__m128i, __mmask8, __m256i, int);
extern __m128i   __cdecl _mm256_maskz_extracti32x4_epi32(__mmask8, __m256i, int);
extern __m128i   __cdecl _mm256_extracti64x2_epi64(__m256i, int);
extern __m128i   __cdecl _mm256_mask_extracti64x2_epi64(__m128i, __mmask8, __m256i, int);
extern __m128i   __cdecl _mm256_maskz_extracti64x2_epi64(__mmask8, __m256i, int);
extern __m128d   __cdecl _mm_fixupimm_pd(__m128d, __m128d, __m128i, const int);
extern __m128d   __cdecl _mm_mask_fixupimm_pd(__m128d, __mmask8, __m128d, __m128i, const int);
extern __m128d   __cdecl _mm_maskz_fixupimm_pd(__mmask8, __m128d, __m128d, __m128i, const int);
extern __m256d   __cdecl _mm256_fixupimm_pd(__m256d, __m256d, __m256i, const int);
extern __m256d   __cdecl _mm256_mask_fixupimm_pd(__m256d, __mmask8, __m256d, __m256i, const int);
extern __m256d   __cdecl _mm256_maskz_fixupimm_pd(__mmask8, __m256d, __m256d, __m256i, const int);
extern __m128    __cdecl _mm_fixupimm_ps(__m128, __m128, __m128i, const int);
extern __m128    __cdecl _mm_mask_fixupimm_ps(__m128, __mmask8, __m128, __m128i, const int);
extern __m128    __cdecl _mm_maskz_fixupimm_ps(__mmask8, __m128, __m128, __m128i, const int);
extern __m256    __cdecl _mm256_fixupimm_ps(__m256, __m256, __m256i, const int);
extern __m256    __cdecl _mm256_mask_fixupimm_ps(__m256, __mmask8, __m256, __m256i, const int);
extern __m256    __cdecl _mm256_maskz_fixupimm_ps(__mmask8, __m256, __m256, __m256i, const int);
extern __m128d   __cdecl _mm_mask_fmadd_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_mask3_fmadd_pd(__m128d, __m128d, __m128d, __mmask8);
extern __m128d   __cdecl _mm_maskz_fmadd_pd(__mmask8, __m128d, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_fmadd_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_mask3_fmadd_pd(__m256d, __m256d, __m256d, __mmask8);
extern __m256d   __cdecl _mm256_maskz_fmadd_pd(__mmask8, __m256d, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_fmadd_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_mask3_fmadd_ps(__m128, __m128, __m128, __mmask8);
extern __m128    __cdecl _mm_maskz_fmadd_ps(__mmask8, __m128, __m128, __m128);
extern __m256    __cdecl _mm256_mask_fmadd_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_mask3_fmadd_ps(__m256, __m256, __m256, __mmask8);
extern __m256    __cdecl _mm256_maskz_fmadd_ps(__mmask8, __m256, __m256, __m256);
extern __m128d   __cdecl _mm_mask_fmaddsub_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_mask3_fmaddsub_pd(__m128d, __m128d, __m128d, __mmask8);
extern __m128d   __cdecl _mm_maskz_fmaddsub_pd(__mmask8, __m128d, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_fmaddsub_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_mask3_fmaddsub_pd(__m256d, __m256d, __m256d, __mmask8);
extern __m256d   __cdecl _mm256_maskz_fmaddsub_pd(__mmask8, __m256d, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_fmaddsub_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_mask3_fmaddsub_ps(__m128, __m128, __m128, __mmask8);
extern __m128    __cdecl _mm_maskz_fmaddsub_ps(__mmask8, __m128, __m128, __m128);
extern __m256    __cdecl _mm256_mask_fmaddsub_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_mask3_fmaddsub_ps(__m256, __m256, __m256, __mmask8);
extern __m256    __cdecl _mm256_maskz_fmaddsub_ps(__mmask8, __m256, __m256, __m256);
extern __m128d   __cdecl _mm_mask_fmsub_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_mask3_fmsub_pd(__m128d, __m128d, __m128d, __mmask8);
extern __m128d   __cdecl _mm_maskz_fmsub_pd(__mmask8, __m128d, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_fmsub_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_mask3_fmsub_pd(__m256d, __m256d, __m256d, __mmask8);
extern __m256d   __cdecl _mm256_maskz_fmsub_pd(__mmask8, __m256d, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_fmsub_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_mask3_fmsub_ps(__m128, __m128, __m128, __mmask8);
extern __m128    __cdecl _mm_maskz_fmsub_ps(__mmask8, __m128, __m128, __m128);
extern __m256    __cdecl _mm256_mask_fmsub_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_mask3_fmsub_ps(__m256, __m256, __m256, __mmask8);
extern __m256    __cdecl _mm256_maskz_fmsub_ps(__mmask8, __m256, __m256, __m256);
extern __m128d   __cdecl _mm_mask_fmsubadd_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_mask3_fmsubadd_pd(__m128d, __m128d, __m128d, __mmask8);
extern __m128d   __cdecl _mm_maskz_fmsubadd_pd(__mmask8, __m128d, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_fmsubadd_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_mask3_fmsubadd_pd(__m256d, __m256d, __m256d, __mmask8);
extern __m256d   __cdecl _mm256_maskz_fmsubadd_pd(__mmask8, __m256d, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_fmsubadd_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_mask3_fmsubadd_ps(__m128, __m128, __m128, __mmask8);
extern __m128    __cdecl _mm_maskz_fmsubadd_ps(__mmask8, __m128, __m128, __m128);
extern __m256    __cdecl _mm256_mask_fmsubadd_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_mask3_fmsubadd_ps(__m256, __m256, __m256, __mmask8);
extern __m256    __cdecl _mm256_maskz_fmsubadd_ps(__mmask8, __m256, __m256, __m256);
extern __m128d   __cdecl _mm_mask_fnmadd_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_mask3_fnmadd_pd(__m128d, __m128d, __m128d, __mmask8);
extern __m128d   __cdecl _mm_maskz_fnmadd_pd(__mmask8, __m128d, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_fnmadd_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_mask3_fnmadd_pd(__m256d, __m256d, __m256d, __mmask8);
extern __m256d   __cdecl _mm256_maskz_fnmadd_pd(__mmask8, __m256d, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_fnmadd_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_mask3_fnmadd_ps(__m128, __m128, __m128, __mmask8);
extern __m128    __cdecl _mm_maskz_fnmadd_ps(__mmask8, __m128, __m128, __m128);
extern __m256    __cdecl _mm256_mask_fnmadd_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_mask3_fnmadd_ps(__m256, __m256, __m256, __mmask8);
extern __m256    __cdecl _mm256_maskz_fnmadd_ps(__mmask8, __m256, __m256, __m256);
extern __m128d   __cdecl _mm_mask_fnmsub_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_mask3_fnmsub_pd(__m128d, __m128d, __m128d, __mmask8);
extern __m128d   __cdecl _mm_maskz_fnmsub_pd(__mmask8, __m128d, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_fnmsub_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_mask3_fnmsub_pd(__m256d, __m256d, __m256d, __mmask8);
extern __m256d   __cdecl _mm256_maskz_fnmsub_pd(__mmask8, __m256d, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_fnmsub_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_mask3_fnmsub_ps(__m128, __m128, __m128, __mmask8);
extern __m128    __cdecl _mm_maskz_fnmsub_ps(__mmask8, __m128, __m128, __m128);
extern __m256    __cdecl _mm256_mask_fnmsub_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_mask3_fnmsub_ps(__m256, __m256, __m256, __mmask8);
extern __m256    __cdecl _mm256_maskz_fnmsub_ps(__mmask8, __m256, __m256, __m256);
extern __mmask8  __cdecl _mm_fpclass_pd_mask(__m128d, int);
extern __mmask8  __cdecl _mm_mask_fpclass_pd_mask(__mmask8, __m128d, int);
extern __mmask8  __cdecl _mm256_fpclass_pd_mask(__m256d, int);
extern __mmask8  __cdecl _mm256_mask_fpclass_pd_mask(__mmask8, __m256d, int);
extern __mmask8  __cdecl _mm_fpclass_ps_mask(__m128, int);
extern __mmask8  __cdecl _mm_mask_fpclass_ps_mask(__mmask8, __m128, int);
extern __mmask8  __cdecl _mm256_fpclass_ps_mask(__m256, int);
extern __mmask8  __cdecl _mm256_mask_fpclass_ps_mask(__mmask8, __m256, int);
extern __m128d   __cdecl _mm_getexp_pd(__m128d);
extern __m128d   __cdecl _mm_mask_getexp_pd(__m128d, __mmask8, __m128d);
extern __m128d   __cdecl _mm_maskz_getexp_pd(__mmask8, __m128d);
extern __m256d   __cdecl _mm256_getexp_pd(__m256d);
extern __m256d   __cdecl _mm256_mask_getexp_pd(__m256d, __mmask8, __m256d);
extern __m256d   __cdecl _mm256_maskz_getexp_pd(__mmask8, __m256d);
extern __m128    __cdecl _mm_getexp_ps(__m128);
extern __m128    __cdecl _mm_mask_getexp_ps(__m128, __mmask8, __m128);
extern __m128    __cdecl _mm_maskz_getexp_ps(__mmask8, __m128);
extern __m256    __cdecl _mm256_getexp_ps(__m256);
extern __m256    __cdecl _mm256_mask_getexp_ps(__m256, __mmask8, __m256);
extern __m256    __cdecl _mm256_maskz_getexp_ps(__mmask8, __m256);
extern __m128d   __cdecl _mm_getmant_pd(__m128d, int, int);
extern __m128d   __cdecl _mm_mask_getmant_pd(__m128d, __mmask8, __m128d, int, int);
extern __m128d   __cdecl _mm_maskz_getmant_pd(__mmask8, __m128d, int, int);
extern __m256d   __cdecl _mm256_getmant_pd(__m256d, int, int);
extern __m256d   __cdecl _mm256_mask_getmant_pd(__m256d, __mmask8, __m256d, int, int);
extern __m256d   __cdecl _mm256_maskz_getmant_pd(__mmask8, __m256d, int, int);
extern __m128    __cdecl _mm_getmant_ps(__m128, int, int);
extern __m128    __cdecl _mm_mask_getmant_ps(__m128, __mmask8, __m128, int, int);
extern __m128    __cdecl _mm_maskz_getmant_ps(__mmask8, __m128, int, int);
extern __m256    __cdecl _mm256_getmant_ps(__m256, int, int);
extern __m256    __cdecl _mm256_mask_getmant_ps(__m256, __mmask8, __m256, int, int);
extern __m256    __cdecl _mm256_maskz_getmant_ps(__mmask8, __m256, int, int);
extern __m128i   __cdecl _mm_mmask_i32gather_epi32(__m128i, __mmask8, __m128i, void const*, const int);
extern __m256i   __cdecl _mm256_mmask_i32gather_epi32(__m256i, __mmask8, __m256i, void const*, const int);
extern __m128i   __cdecl _mm_mmask_i32gather_epi64(__m128i, __mmask8, __m128i, void const*, const int);
extern __m256i   __cdecl _mm256_mmask_i32gather_epi64(__m256i, __mmask8, __m128i, void const*, const int);
extern __m128d   __cdecl _mm_mmask_i32gather_pd(__m128d, __mmask8, __m128i, void const*, const int);
extern __m256d   __cdecl _mm256_mmask_i32gather_pd(__m256d, __mmask8, __m128i, void const*, const int);
extern __m128    __cdecl _mm_mmask_i32gather_ps(__m128, __mmask8, __m128i, void const*, const int);
extern __m256    __cdecl _mm256_mmask_i32gather_ps(__m256, __mmask8, __m256i, void const*, const int);
extern void      __cdecl _mm_i32scatter_epi32(void*, __m128i, __m128i, const int);
extern void      __cdecl _mm_mask_i32scatter_epi32(void*, __mmask8, __m128i, __m128i, const int);
extern void      __cdecl _mm256_i32scatter_epi32(void*, __m256i, __m256i, const int);
extern void      __cdecl _mm256_mask_i32scatter_epi32(void*, __mmask8, __m256i, __m256i, const int);
extern void      __cdecl _mm_i32scatter_epi64(void*, __m128i, __m128i, const int);
extern void      __cdecl _mm_mask_i32scatter_epi64(void*, __mmask8, __m128i, __m128i, const int);
extern void      __cdecl _mm256_i32scatter_epi64(void*, __m128i, __m256i, const int);
extern void      __cdecl _mm256_mask_i32scatter_epi64(void*, __mmask8, __m128i, __m256i, const int);
extern void      __cdecl _mm_i32scatter_pd(void*, __m128i, __m128d, const int);
extern void      __cdecl _mm_mask_i32scatter_pd(void*, __mmask8, __m128i, __m128d, const int);
extern void      __cdecl _mm256_i32scatter_pd(void*, __m128i, __m256d, const int);
extern void      __cdecl _mm256_mask_i32scatter_pd(void*, __mmask8, __m128i, __m256d, const int);
extern void      __cdecl _mm_i32scatter_ps(void*, __m128i, __m128, const int);
extern void      __cdecl _mm_mask_i32scatter_ps(void*, __mmask8, __m128i, __m128, const int);
extern void      __cdecl _mm256_i32scatter_ps(void*, __m256i, __m256, const int);
extern void      __cdecl _mm256_mask_i32scatter_ps(void*, __mmask8, __m256i, __m256, const int);
extern __m128i   __cdecl _mm_mmask_i64gather_epi32(__m128i, __mmask8, __m128i, void const*, const int);
extern __m128i   __cdecl _mm256_mmask_i64gather_epi32(__m128i, __mmask8, __m256i, void const*, const int);
extern __m128i   __cdecl _mm_mmask_i64gather_epi64(__m128i, __mmask8, __m128i, void const*, const int);
extern __m256i   __cdecl _mm256_mmask_i64gather_epi64(__m256i, __mmask8, __m256i, void const*, const int);
extern __m128d   __cdecl _mm_mmask_i64gather_pd(__m128d, __mmask8, __m128i, void const*, const int);
extern __m256d   __cdecl _mm256_mmask_i64gather_pd(__m256d, __mmask8, __m256i, void const*, const int);
extern __m128    __cdecl _mm_mmask_i64gather_ps(__m128, __mmask8, __m128i, void const*, const int);
extern __m128    __cdecl _mm256_mmask_i64gather_ps(__m128, __mmask8, __m256i, void const*, const int);
extern void      __cdecl _mm_i64scatter_epi32(void*, __m128i, __m128i, const int);
extern void      __cdecl _mm_mask_i64scatter_epi32(void*, __mmask8, __m128i, __m128i, const int);
extern void      __cdecl _mm256_i64scatter_epi32(void*, __m256i, __m128i, const int);
extern void      __cdecl _mm256_mask_i64scatter_epi32(void*, __mmask8, __m256i, __m128i, const int);
extern void      __cdecl _mm_i64scatter_epi64(void*, __m128i, __m128i, const int);
extern void      __cdecl _mm_mask_i64scatter_epi64(void*, __mmask8, __m128i, __m128i, const int);
extern void      __cdecl _mm256_i64scatter_epi64(void*, __m256i, __m256i, const int);
extern void      __cdecl _mm256_mask_i64scatter_epi64(void*, __mmask8, __m256i, __m256i, const int);
extern void      __cdecl _mm_i64scatter_pd(void*, __m128i, __m128d, const int);
extern void      __cdecl _mm_mask_i64scatter_pd(void*, __mmask8, __m128i, __m128d, const int);
extern void      __cdecl _mm256_i64scatter_pd(void*, __m256i, __m256d, const int);
extern void      __cdecl _mm256_mask_i64scatter_pd(void*, __mmask8, __m256i, __m256d, const int);
extern void      __cdecl _mm_i64scatter_ps(void*, __m128i, __m128, const int);
extern void      __cdecl _mm_mask_i64scatter_ps(void*, __mmask8, __m128i, __m128, const int);
extern void      __cdecl _mm256_i64scatter_ps(void*, __m256i, __m128, const int);
extern void      __cdecl _mm256_mask_i64scatter_ps(void*, __mmask8, __m256i, __m128, const int);
extern __m256    __cdecl _mm256_insertf32x4(__m256, __m128, int);
extern __m256    __cdecl _mm256_mask_insertf32x4(__m256, __mmask8, __m256, __m128, int);
extern __m256    __cdecl _mm256_maskz_insertf32x4(__mmask8, __m256, __m128, int);
extern __m256d   __cdecl _mm256_insertf64x2(__m256d, __m128d, int);
extern __m256d   __cdecl _mm256_mask_insertf64x2(__m256d, __mmask8, __m256d, __m128d, int);
extern __m256d   __cdecl _mm256_maskz_insertf64x2(__mmask8, __m256d, __m128d, int);
extern __m256i   __cdecl _mm256_inserti32x4(__m256i, __m128i, int);
extern __m256i   __cdecl _mm256_mask_inserti32x4(__m256i, __mmask8, __m256i, __m128i, int);
extern __m256i   __cdecl _mm256_maskz_inserti32x4(__mmask8, __m256i, __m128i, int);
extern __m256i   __cdecl _mm256_inserti64x2(__m256i, __m128i, int);
extern __m256i   __cdecl _mm256_mask_inserti64x2(__m256i, __mmask8, __m256i, __m128i, int);
extern __m256i   __cdecl _mm256_maskz_inserti64x2(__mmask8, __m256i, __m128i, int);
extern __m128i   __cdecl _mm_mask_load_epi32(__m128i, __mmask8, void const*);
extern __m128i   __cdecl _mm_maskz_load_epi32(__mmask8, void const*);
extern __m256i   __cdecl _mm256_mask_load_epi32(__m256i, __mmask8, void const*);
extern __m256i   __cdecl _mm256_maskz_load_epi32(__mmask8, void const*);
extern __m128i   __cdecl _mm_mask_load_epi64(__m128i, __mmask8, void const*);
extern __m128i   __cdecl _mm_maskz_load_epi64(__mmask8, void const*);
extern __m256i   __cdecl _mm256_mask_load_epi64(__m256i, __mmask8, void const*);
extern __m256i   __cdecl _mm256_maskz_load_epi64(__mmask8, void const*);
extern __m128d   __cdecl _mm_mask_load_pd(__m128d, __mmask8, void const*);
extern __m128d   __cdecl _mm_maskz_load_pd(__mmask8, void const*);
extern __m256d   __cdecl _mm256_mask_load_pd(__m256d, __mmask8, void const*);
extern __m256d   __cdecl _mm256_maskz_load_pd(__mmask8, void const*);
extern __m128    __cdecl _mm_mask_load_ps(__m128, __mmask8, void const*);
extern __m128    __cdecl _mm_maskz_load_ps(__mmask8, void const*);
extern __m256    __cdecl _mm256_mask_load_ps(__m256, __mmask8, void const*);
extern __m256    __cdecl _mm256_maskz_load_ps(__mmask8, void const*);
extern __m128i   __cdecl _mm_loadu_epi16(void const*);
extern __m128i   __cdecl _mm_mask_loadu_epi16(__m128i, __mmask8, void const*);
extern __m128i   __cdecl _mm_maskz_loadu_epi16(__mmask8, void const*);
extern __m256i   __cdecl _mm256_loadu_epi16(void const*);
extern __m256i   __cdecl _mm256_mask_loadu_epi16(__m256i, __mmask16, void const*);
extern __m256i   __cdecl _mm256_maskz_loadu_epi16(__mmask16, void const*);
extern __m128i   __cdecl _mm_loadu_epi32(void const*);
extern __m128i   __cdecl _mm_mask_loadu_epi32(__m128i, __mmask8, void const*);
extern __m128i   __cdecl _mm_maskz_loadu_epi32(__mmask8, void const*);
extern __m256i   __cdecl _mm256_loadu_epi32(void const*);
extern __m256i   __cdecl _mm256_mask_loadu_epi32(__m256i, __mmask8, void const*);
extern __m256i   __cdecl _mm256_maskz_loadu_epi32(__mmask8, void const*);
extern __m128i   __cdecl _mm_loadu_epi64(void const*);
extern __m128i   __cdecl _mm_mask_loadu_epi64(__m128i, __mmask8, void const*);
extern __m128i   __cdecl _mm_maskz_loadu_epi64(__mmask8, void const*);
extern __m256i   __cdecl _mm256_loadu_epi64(void const*);
extern __m256i   __cdecl _mm256_mask_loadu_epi64(__m256i, __mmask8, void const*);
extern __m256i   __cdecl _mm256_maskz_loadu_epi64(__mmask8, void const*);
extern __m128i   __cdecl _mm_loadu_epi8(void const*);
extern __m128i   __cdecl _mm_mask_loadu_epi8(__m128i, __mmask16, void const*);
extern __m128i   __cdecl _mm_maskz_loadu_epi8(__mmask16, void const*);
extern __m256i   __cdecl _mm256_loadu_epi8(void const*);
extern __m256i   __cdecl _mm256_mask_loadu_epi8(__m256i, __mmask32, void const*);
extern __m256i   __cdecl _mm256_maskz_loadu_epi8(__mmask32, void const*);
extern __m128d   __cdecl _mm_mask_loadu_pd(__m128d, __mmask8, void const*);
extern __m128d   __cdecl _mm_maskz_loadu_pd(__mmask8, void const*);
extern __m256d   __cdecl _mm256_mask_loadu_pd(__m256d, __mmask8, void const*);
extern __m256d   __cdecl _mm256_maskz_loadu_pd(__mmask8, void const*);
extern __m128    __cdecl _mm_mask_loadu_ps(__m128, __mmask8, void const*);
extern __m128    __cdecl _mm_maskz_loadu_ps(__mmask8, void const*);
extern __m256    __cdecl _mm256_mask_loadu_ps(__m256, __mmask8, void const*);
extern __m256    __cdecl _mm256_maskz_loadu_ps(__mmask8, void const*);
extern __m128i   __cdecl _mm_lzcnt_epi32(__m128i);
extern __m128i   __cdecl _mm_mask_lzcnt_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_lzcnt_epi32(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_lzcnt_epi32(__m256i);
extern __m256i   __cdecl _mm256_mask_lzcnt_epi32(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_lzcnt_epi32(__mmask8, __m256i);
extern __m128i   __cdecl _mm_lzcnt_epi64(__m128i);
extern __m128i   __cdecl _mm_mask_lzcnt_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_lzcnt_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_lzcnt_epi64(__m256i);
extern __m256i   __cdecl _mm256_mask_lzcnt_epi64(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_lzcnt_epi64(__mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_madd_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_madd_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_madd_epi16(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_madd_epi16(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_maddubs_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_maddubs_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_maddubs_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_maddubs_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_max_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_max_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_max_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_max_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_max_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_max_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_max_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_max_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_max_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_max_epi64(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_max_epi64(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_max_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_max_epi64(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_max_epi64(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_max_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_max_epi8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_max_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_max_epi8(__mmask32, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_max_epu16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_max_epu16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_max_epu16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_max_epu16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_max_epu32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_max_epu32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_max_epu32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_max_epu32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_max_epu64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_max_epu64(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_max_epu64(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_max_epu64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_max_epu64(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_max_epu64(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_max_epu8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_max_epu8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_max_epu8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_max_epu8(__mmask32, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_max_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_max_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_max_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_max_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_max_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_max_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_max_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_max_ps(__mmask8, __m256, __m256);
extern __m128i   __cdecl _mm_mask_min_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_min_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_min_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_min_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_min_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_min_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_min_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_min_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_min_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_min_epi64(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_min_epi64(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_min_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_min_epi64(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_min_epi64(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_min_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_min_epi8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_min_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_min_epi8(__mmask32, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_min_epu16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_min_epu16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_min_epu16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_min_epu16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_min_epu32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_min_epu32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_min_epu32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_min_epu32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_min_epu64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_min_epu64(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_min_epu64(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_min_epu64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_min_epu64(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_min_epu64(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_min_epu8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_min_epu8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_min_epu8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_min_epu8(__mmask32, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_min_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_min_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_min_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_min_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_min_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_min_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_min_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_min_ps(__mmask8, __m256, __m256);
extern __m128i   __cdecl _mm_mask_mov_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_mov_epi16(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_mov_epi16(__m256i, __mmask16, __m256i);
extern __m256i   __cdecl _mm256_maskz_mov_epi16(__mmask16, __m256i);
extern __m128i   __cdecl _mm_mask_mov_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_mov_epi32(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_mov_epi32(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_mov_epi32(__mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_mov_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_mov_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_mov_epi64(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_mov_epi64(__mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_mov_epi8(__m128i, __mmask16, __m128i);
extern __m128i   __cdecl _mm_maskz_mov_epi8(__mmask16, __m128i);
extern __m256i   __cdecl _mm256_mask_mov_epi8(__m256i, __mmask32, __m256i);
extern __m256i   __cdecl _mm256_maskz_mov_epi8(__mmask32, __m256i);
extern __m128d   __cdecl _mm_mask_mov_pd(__m128d, __mmask8, __m128d);
extern __m128d   __cdecl _mm_maskz_mov_pd(__mmask8, __m128d);
extern __m256d   __cdecl _mm256_mask_mov_pd(__m256d, __mmask8, __m256d);
extern __m256d   __cdecl _mm256_maskz_mov_pd(__mmask8, __m256d);
extern __m128    __cdecl _mm_mask_mov_ps(__m128, __mmask8, __m128);
extern __m128    __cdecl _mm_maskz_mov_ps(__mmask8, __m128);
extern __m256    __cdecl _mm256_mask_mov_ps(__m256, __mmask8, __m256);
extern __m256    __cdecl _mm256_maskz_mov_ps(__mmask8, __m256);
extern __m128d   __cdecl _mm_mask_movedup_pd(__m128d, __mmask8, __m128d);
extern __m128d   __cdecl _mm_maskz_movedup_pd(__mmask8, __m128d);
extern __m256d   __cdecl _mm256_mask_movedup_pd(__m256d, __mmask8, __m256d);
extern __m256d   __cdecl _mm256_maskz_movedup_pd(__mmask8, __m256d);
extern __m128    __cdecl _mm_mask_movehdup_ps(__m128, __mmask8, __m128);
extern __m128    __cdecl _mm_maskz_movehdup_ps(__mmask8, __m128);
extern __m256    __cdecl _mm256_mask_movehdup_ps(__m256, __mmask8, __m256);
extern __m256    __cdecl _mm256_maskz_movehdup_ps(__mmask8, __m256);
extern __m128    __cdecl _mm_mask_moveldup_ps(__m128, __mmask8, __m128);
extern __m128    __cdecl _mm_maskz_moveldup_ps(__mmask8, __m128);
extern __m256    __cdecl _mm256_mask_moveldup_ps(__m256, __mmask8, __m256);
extern __m256    __cdecl _mm256_maskz_moveldup_ps(__mmask8, __m256);
extern __mmask8  __cdecl _mm_movepi16_mask(__m128i);
extern __mmask16 __cdecl _mm256_movepi16_mask(__m256i);
extern __mmask8  __cdecl _mm_movepi32_mask(__m128i);
extern __mmask8  __cdecl _mm256_movepi32_mask(__m256i);
extern __mmask8  __cdecl _mm_movepi64_mask(__m128i);
extern __mmask8  __cdecl _mm256_movepi64_mask(__m256i);
extern __mmask16 __cdecl _mm_movepi8_mask(__m128i);
extern __mmask32 __cdecl _mm256_movepi8_mask(__m256i);
extern __m128i   __cdecl _mm_movm_epi16(__mmask8);
extern __m256i   __cdecl _mm256_movm_epi16(__mmask16);
extern __m128i   __cdecl _mm_movm_epi32(__mmask8);
extern __m256i   __cdecl _mm256_movm_epi32(__mmask8);
extern __m128i   __cdecl _mm_movm_epi64(__mmask8);
extern __m256i   __cdecl _mm256_movm_epi64(__mmask8);
extern __m128i   __cdecl _mm_movm_epi8(__mmask16);
extern __m256i   __cdecl _mm256_movm_epi8(__mmask32);
extern __m128i   __cdecl _mm_mask_mul_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_mul_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_mul_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_mul_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_mul_epu32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_mul_epu32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_mul_epu32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_mul_epu32(__mmask8, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_mul_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_mul_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_mul_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_mul_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_mul_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_mul_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_mul_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_mul_ps(__mmask8, __m256, __m256);
extern __m128i   __cdecl _mm_mask_mulhi_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_mulhi_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_mulhi_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_mulhi_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_mulhi_epu16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_mulhi_epu16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_mulhi_epu16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_mulhi_epu16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_mulhrs_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_mulhrs_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_mulhrs_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_mulhrs_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_mullo_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_mullo_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_mullo_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_mullo_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_mullo_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_mullo_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_mullo_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_mullo_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_mullo_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_mullo_epi64(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_mullo_epi64(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_mullo_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_mullo_epi64(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_mullo_epi64(__m256i, __m256i);
extern __m128i   __cdecl _mm_or_epi32(__m128i, __m128i);
extern __m128i   __cdecl _mm_mask_or_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_or_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_or_epi32(__m256i, __m256i);
extern __m256i   __cdecl _mm256_mask_or_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_or_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_or_epi64(__m128i, __m128i);
extern __m128i   __cdecl _mm_mask_or_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_or_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_or_epi64(__m256i, __m256i);
extern __m256i   __cdecl _mm256_mask_or_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_or_epi64(__mmask8, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_or_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_or_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_or_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_or_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_or_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_or_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_or_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_or_ps(__mmask8, __m256, __m256);
extern __m128i   __cdecl _mm_mask_packs_epi16(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_packs_epi16(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_packs_epi16(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_packs_epi16(__mmask32, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_packs_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_packs_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_packs_epi32(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_packs_epi32(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_packus_epi16(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_packus_epi16(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_packus_epi16(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_packus_epi16(__mmask32, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_packus_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_packus_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_packus_epi32(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_packus_epi32(__mmask16, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_permute_pd(__m128d, __mmask8, __m128d, const int);
extern __m128d   __cdecl _mm_maskz_permute_pd(__mmask8, __m128d, const int);
extern __m256d   __cdecl _mm256_mask_permute_pd(__m256d, __mmask8, __m256d, const int);
extern __m256d   __cdecl _mm256_maskz_permute_pd(__mmask8, __m256d, const int);
extern __m128    __cdecl _mm_mask_permute_ps(__m128, __mmask8, __m128, const int);
extern __m128    __cdecl _mm_maskz_permute_ps(__mmask8, __m128, const int);
extern __m256    __cdecl _mm256_mask_permute_ps(__m256, __mmask8, __m256, const int);
extern __m256    __cdecl _mm256_maskz_permute_ps(__mmask8, __m256, const int);
extern __m128d   __cdecl _mm_mask_permutevar_pd(__m128d, __mmask8, __m128d, __m128i);
extern __m128d   __cdecl _mm_maskz_permutevar_pd(__mmask8, __m128d, __m128i);
extern __m256d   __cdecl _mm256_mask_permutevar_pd(__m256d, __mmask8, __m256d, __m256i);
extern __m256d   __cdecl _mm256_maskz_permutevar_pd(__mmask8, __m256d, __m256i);
extern __m128    __cdecl _mm_mask_permutevar_ps(__m128, __mmask8, __m128, __m128i);
extern __m128    __cdecl _mm_maskz_permutevar_ps(__mmask8, __m128, __m128i);
extern __m256    __cdecl _mm256_mask_permutevar_ps(__m256, __mmask8, __m256, __m256i);
extern __m256    __cdecl _mm256_maskz_permutevar_ps(__mmask8, __m256, __m256i);
extern __m256i   __cdecl _mm256_mask_permutex_epi64(__m256i, __mmask8, __m256i, const int);
extern __m256i   __cdecl _mm256_maskz_permutex_epi64(__mmask8, __m256i, const int);
extern __m256i   __cdecl _mm256_permutex_epi64(__m256i, const int);
extern __m256d   __cdecl _mm256_mask_permutex_pd(__m256d, __mmask8, __m256d, const int);
extern __m256d   __cdecl _mm256_maskz_permutex_pd(__mmask8, __m256d, const int);
extern __m256d   __cdecl _mm256_permutex_pd(__m256d, const int);
extern __m128i   __cdecl _mm_mask_permutex2var_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_mask2_permutex2var_epi16(__m128i, __m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_permutex2var_epi16(__mmask8, __m128i, __m128i, __m128i);
extern __m128i   __cdecl _mm_permutex2var_epi16(__m128i, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_permutex2var_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_mask2_permutex2var_epi16(__m256i, __m256i, __mmask16, __m256i);
extern __m256i   __cdecl _mm256_maskz_permutex2var_epi16(__mmask16, __m256i, __m256i, __m256i);
extern __m256i   __cdecl _mm256_permutex2var_epi16(__m256i, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_permutex2var_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_mask2_permutex2var_epi32(__m128i, __m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_permutex2var_epi32(__mmask8, __m128i, __m128i, __m128i);
extern __m128i   __cdecl _mm_permutex2var_epi32(__m128i, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_permutex2var_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_mask2_permutex2var_epi32(__m256i, __m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_permutex2var_epi32(__mmask8, __m256i, __m256i, __m256i);
extern __m256i   __cdecl _mm256_permutex2var_epi32(__m256i, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_permutex2var_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_mask2_permutex2var_epi64(__m128i, __m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_permutex2var_epi64(__mmask8, __m128i, __m128i, __m128i);
extern __m128i   __cdecl _mm_permutex2var_epi64(__m128i, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_permutex2var_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_mask2_permutex2var_epi64(__m256i, __m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_permutex2var_epi64(__mmask8, __m256i, __m256i, __m256i);
extern __m256i   __cdecl _mm256_permutex2var_epi64(__m256i, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_permutex2var_pd(__m128d, __mmask8, __m128i, __m128d);
extern __m128d   __cdecl _mm_mask2_permutex2var_pd(__m128d, __m128i, __mmask8, __m128d);
extern __m128d   __cdecl _mm_maskz_permutex2var_pd(__mmask8, __m128d, __m128i, __m128d);
extern __m128d   __cdecl _mm_permutex2var_pd(__m128d, __m128i, __m128d);
extern __m256d   __cdecl _mm256_mask_permutex2var_pd(__m256d, __mmask8, __m256i, __m256d);
extern __m256d   __cdecl _mm256_mask2_permutex2var_pd(__m256d, __m256i, __mmask8, __m256d);
extern __m256d   __cdecl _mm256_maskz_permutex2var_pd(__mmask8, __m256d, __m256i, __m256d);
extern __m256d   __cdecl _mm256_permutex2var_pd(__m256d, __m256i, __m256d);
extern __m128    __cdecl _mm_mask_permutex2var_ps(__m128, __mmask8, __m128i, __m128);
extern __m128    __cdecl _mm_mask2_permutex2var_ps(__m128, __m128i, __mmask8, __m128);
extern __m128    __cdecl _mm_maskz_permutex2var_ps(__mmask8, __m128, __m128i, __m128);
extern __m128    __cdecl _mm_permutex2var_ps(__m128, __m128i, __m128);
extern __m256    __cdecl _mm256_mask_permutex2var_ps(__m256, __mmask8, __m256i, __m256);
extern __m256    __cdecl _mm256_mask2_permutex2var_ps(__m256, __m256i, __mmask8, __m256);
extern __m256    __cdecl _mm256_maskz_permutex2var_ps(__mmask8, __m256, __m256i, __m256);
extern __m256    __cdecl _mm256_permutex2var_ps(__m256, __m256i, __m256);
extern __m128i   __cdecl _mm_mask_permutexvar_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_permutexvar_epi16(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_permutexvar_epi16(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_permutexvar_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_permutexvar_epi16(__mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_permutexvar_epi16(__m256i, __m256i);
extern __m256i   __cdecl _mm256_mask_permutexvar_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_permutexvar_epi32(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_permutexvar_epi32(__m256i, __m256i);
extern __m256i   __cdecl _mm256_mask_permutexvar_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_permutexvar_epi64(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_permutexvar_epi64(__m256i, __m256i);
extern __m256d   __cdecl _mm256_mask_permutexvar_pd(__m256d, __mmask8, __m256i, __m256d);
extern __m256d   __cdecl _mm256_maskz_permutexvar_pd(__mmask8, __m256i, __m256d);
extern __m256d   __cdecl _mm256_permutexvar_pd(__m256i, __m256d);
extern __m256    __cdecl _mm256_mask_permutexvar_ps(__m256, __mmask8, __m256i, __m256);
extern __m256    __cdecl _mm256_maskz_permutexvar_ps(__mmask8, __m256i, __m256);
extern __m256    __cdecl _mm256_permutexvar_ps(__m256i, __m256);
extern __m128d   __cdecl _mm_mask_range_pd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_maskz_range_pd(__mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_range_pd(__m128d, __m128d, int);
extern __m256d   __cdecl _mm256_mask_range_pd(__m256d, __mmask8, __m256d, __m256d, int);
extern __m256d   __cdecl _mm256_maskz_range_pd(__mmask8, __m256d, __m256d, int);
extern __m256d   __cdecl _mm256_range_pd(__m256d, __m256d, int);
extern __m128    __cdecl _mm_mask_range_ps(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_maskz_range_ps(__mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_range_ps(__m128, __m128, int);
extern __m256    __cdecl _mm256_mask_range_ps(__m256, __mmask8, __m256, __m256, int);
extern __m256    __cdecl _mm256_maskz_range_ps(__mmask8, __m256, __m256, int);
extern __m256    __cdecl _mm256_range_ps(__m256, __m256, int);
extern __m128d   __cdecl _mm_mask_rcp14_pd(__m128d, __mmask8, __m128d);
extern __m128d   __cdecl _mm_maskz_rcp14_pd(__mmask8, __m128d);
extern __m128d   __cdecl _mm_rcp14_pd(__m128d);
extern __m256d   __cdecl _mm256_mask_rcp14_pd(__m256d, __mmask8, __m256d);
extern __m256d   __cdecl _mm256_maskz_rcp14_pd(__mmask8, __m256d);
extern __m256d   __cdecl _mm256_rcp14_pd(__m256d);
extern __m128    __cdecl _mm_mask_rcp14_ps(__m128, __mmask8, __m128);
extern __m128    __cdecl _mm_maskz_rcp14_ps(__mmask8, __m128);
extern __m128    __cdecl _mm_rcp14_ps(__m128);
extern __m256    __cdecl _mm256_mask_rcp14_ps(__m256, __mmask8, __m256);
extern __m256    __cdecl _mm256_maskz_rcp14_ps(__mmask8, __m256);
extern __m256    __cdecl _mm256_rcp14_ps(__m256);
extern __m128d   __cdecl _mm_mask_reduce_pd(__m128d, __mmask8, __m128d, int);
extern __m128d   __cdecl _mm_maskz_reduce_pd(__mmask8, __m128d, int);
extern __m128d   __cdecl _mm_reduce_pd(__m128d, int);
extern __m256d   __cdecl _mm256_mask_reduce_pd(__m256d, __mmask8, __m256d, int);
extern __m256d   __cdecl _mm256_maskz_reduce_pd(__mmask8, __m256d, int);
extern __m256d   __cdecl _mm256_reduce_pd(__m256d, int);
extern __m128    __cdecl _mm_mask_reduce_ps(__m128, __mmask8, __m128, int);
extern __m128    __cdecl _mm_maskz_reduce_ps(__mmask8, __m128, int);
extern __m128    __cdecl _mm_reduce_ps(__m128, int);
extern __m256    __cdecl _mm256_mask_reduce_ps(__m256, __mmask8, __m256, int);
extern __m256    __cdecl _mm256_maskz_reduce_ps(__mmask8, __m256, int);
extern __m256    __cdecl _mm256_reduce_ps(__m256, int);
extern __m128i   __cdecl _mm_mask_rol_epi32(__m128i, __mmask8, __m128i, const int);
extern __m128i   __cdecl _mm_maskz_rol_epi32(__mmask8, __m128i, const int);
extern __m128i   __cdecl _mm_rol_epi32(__m128i, int);
extern __m256i   __cdecl _mm256_mask_rol_epi32(__m256i, __mmask8, __m256i, const int);
extern __m256i   __cdecl _mm256_maskz_rol_epi32(__mmask8, __m256i, const int);
extern __m256i   __cdecl _mm256_rol_epi32(__m256i, const int);
extern __m128i   __cdecl _mm_mask_rol_epi64(__m128i, __mmask8, __m128i, const int);
extern __m128i   __cdecl _mm_maskz_rol_epi64(__mmask8, __m128i, const int);
extern __m128i   __cdecl _mm_rol_epi64(__m128i, const int);
extern __m256i   __cdecl _mm256_mask_rol_epi64(__m256i, __mmask8, __m256i, const int);
extern __m256i   __cdecl _mm256_maskz_rol_epi64(__mmask8, __m256i, const int);
extern __m256i   __cdecl _mm256_rol_epi64(__m256i, const int);
extern __m128i   __cdecl _mm_mask_rolv_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_rolv_epi32(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_rolv_epi32(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_rolv_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_rolv_epi32(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_rolv_epi32(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_rolv_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_rolv_epi64(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_rolv_epi64(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_rolv_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_rolv_epi64(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_rolv_epi64(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_ror_epi32(__m128i, __mmask8, __m128i, const int);
extern __m128i   __cdecl _mm_maskz_ror_epi32(__mmask8, __m128i, const int);
extern __m128i   __cdecl _mm_ror_epi32(__m128i, const int);
extern __m256i   __cdecl _mm256_mask_ror_epi32(__m256i, __mmask8, __m256i, const int);
extern __m256i   __cdecl _mm256_maskz_ror_epi32(__mmask8, __m256i, const int);
extern __m256i   __cdecl _mm256_ror_epi32(__m256i, const int);
extern __m128i   __cdecl _mm_mask_ror_epi64(__m128i, __mmask8, __m128i, const int);
extern __m128i   __cdecl _mm_maskz_ror_epi64(__mmask8, __m128i, const int);
extern __m128i   __cdecl _mm_ror_epi64(__m128i, const int);
extern __m256i   __cdecl _mm256_mask_ror_epi64(__m256i, __mmask8, __m256i, const int);
extern __m256i   __cdecl _mm256_maskz_ror_epi64(__mmask8, __m256i, const int);
extern __m256i   __cdecl _mm256_ror_epi64(__m256i, const int);
extern __m128i   __cdecl _mm_mask_rorv_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_rorv_epi32(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_rorv_epi32(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_rorv_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_rorv_epi32(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_rorv_epi32(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_rorv_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_rorv_epi64(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_rorv_epi64(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_rorv_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_rorv_epi64(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_rorv_epi64(__m256i, __m256i);
extern __m128d   __cdecl _mm_mask_roundscale_pd(__m128d, __mmask8, __m128d, int);
extern __m128d   __cdecl _mm_maskz_roundscale_pd(__mmask8, __m128d, int);
extern __m128d   __cdecl _mm_roundscale_pd(__m128d, int);
extern __m256d   __cdecl _mm256_mask_roundscale_pd(__m256d, __mmask8, __m256d, int);
extern __m256d   __cdecl _mm256_maskz_roundscale_pd(__mmask8, __m256d, int);
extern __m256d   __cdecl _mm256_roundscale_pd(__m256d, int);
extern __m128    __cdecl _mm_mask_roundscale_ps(__m128, __mmask8, __m128, int);
extern __m128    __cdecl _mm_maskz_roundscale_ps(__mmask8, __m128, int);
extern __m128    __cdecl _mm_roundscale_ps(__m128, int);
extern __m256    __cdecl _mm256_mask_roundscale_ps(__m256, __mmask8, __m256, int);
extern __m256    __cdecl _mm256_maskz_roundscale_ps(__mmask8, __m256, int);
extern __m256    __cdecl _mm256_roundscale_ps(__m256, int);
extern __m128d   __cdecl _mm_mask_rsqrt14_pd(__m128d, __mmask8, __m128d);
extern __m128d   __cdecl _mm_maskz_rsqrt14_pd(__mmask8, __m128d);
extern __m256d   __cdecl _mm256_mask_rsqrt14_pd(__m256d, __mmask8, __m256d);
extern __m256d   __cdecl _mm256_maskz_rsqrt14_pd(__mmask8, __m256d);
extern __m128    __cdecl _mm_mask_rsqrt14_ps(__m128, __mmask8, __m128);
extern __m128    __cdecl _mm_maskz_rsqrt14_ps(__mmask8, __m128);
extern __m256    __cdecl _mm256_mask_rsqrt14_ps(__m256, __mmask8, __m256);
extern __m256    __cdecl _mm256_maskz_rsqrt14_ps(__mmask8, __m256);
extern __m128d   __cdecl _mm_mask_scalef_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_scalef_pd(__mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_scalef_pd(__m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_scalef_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_scalef_pd(__mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_scalef_pd(__m256d, __m256d);
extern __m128    __cdecl _mm_mask_scalef_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_scalef_ps(__mmask8, __m128, __m128);
extern __m128    __cdecl _mm_scalef_ps(__m128, __m128);
extern __m256    __cdecl _mm256_mask_scalef_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_scalef_ps(__mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_scalef_ps(__m256, __m256);
extern __m128i   __cdecl _mm_mask_set1_epi16(__m128i, __mmask8, short);
extern __m128i   __cdecl _mm_maskz_set1_epi16(__mmask8, short);
extern __m256i   __cdecl _mm256_mask_set1_epi16(__m256i, __mmask16, short);
extern __m256i   __cdecl _mm256_maskz_set1_epi16(__mmask16, short);
extern __m128i   __cdecl _mm_mask_set1_epi32(__m128i, __mmask8, int);
extern __m128i   __cdecl _mm_maskz_set1_epi32(__mmask8, int);
extern __m256i   __cdecl _mm256_mask_set1_epi32(__m256i, __mmask8, int);
extern __m256i   __cdecl _mm256_maskz_set1_epi32(__mmask8, int);
extern __m128i   __cdecl _mm_mask_set1_epi64(__m128i, __mmask8, __int64);
extern __m128i   __cdecl _mm_maskz_set1_epi64(__mmask8, __int64);
extern __m256i   __cdecl _mm256_mask_set1_epi64(__m256i, __mmask8, __int64);
extern __m256i   __cdecl _mm256_maskz_set1_epi64(__mmask8, __int64);
extern __m128i   __cdecl _mm_mask_set1_epi8(__m128i, __mmask16, char);
extern __m128i   __cdecl _mm_maskz_set1_epi8(__mmask16, char);
extern __m256i   __cdecl _mm256_mask_set1_epi8(__m256i, __mmask32, char);
extern __m256i   __cdecl _mm256_maskz_set1_epi8(__mmask32, char);
extern __m128i   __cdecl _mm_mask_shuffle_epi32(__m128i, __mmask8, __m128i, int);
extern __m128i   __cdecl _mm_maskz_shuffle_epi32(__mmask8, __m128i, int);
extern __m256i   __cdecl _mm256_mask_shuffle_epi32(__m256i, __mmask8, __m256i, int);
extern __m256i   __cdecl _mm256_maskz_shuffle_epi32(__mmask8, __m256i, int);
extern __m128i   __cdecl _mm_mask_shuffle_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_shuffle_epi8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_shuffle_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_shuffle_epi8(__mmask32, __m256i, __m256i);
extern __m256    __cdecl _mm256_mask_shuffle_f32x4(__m256, __mmask8, __m256, __m256, const int);
extern __m256    __cdecl _mm256_maskz_shuffle_f32x4(__mmask8, __m256, __m256, const int);
extern __m256    __cdecl _mm256_shuffle_f32x4(__m256, __m256, const int);
extern __m256d   __cdecl _mm256_mask_shuffle_f64x2(__m256d, __mmask8, __m256d, __m256d, const int);
extern __m256d   __cdecl _mm256_maskz_shuffle_f64x2(__mmask8, __m256d, __m256d, const int);
extern __m256d   __cdecl _mm256_shuffle_f64x2(__m256d, __m256d, const int);
extern __m256i   __cdecl _mm256_mask_shuffle_i32x4(__m256i, __mmask8, __m256i, __m256i, const int);
extern __m256i   __cdecl _mm256_maskz_shuffle_i32x4(__mmask8, __m256i, __m256i, const int);
extern __m256i   __cdecl _mm256_shuffle_i32x4(__m256i, __m256i, const int);
extern __m256i   __cdecl _mm256_mask_shuffle_i64x2(__m256i, __mmask8, __m256i, __m256i, const int);
extern __m256i   __cdecl _mm256_maskz_shuffle_i64x2(__mmask8, __m256i, __m256i, const int);
extern __m256i   __cdecl _mm256_shuffle_i64x2(__m256i, __m256i, const int);
extern __m128d   __cdecl _mm_mask_shuffle_pd(__m128d, __mmask8, __m128d, __m128d, const int);
extern __m128d   __cdecl _mm_maskz_shuffle_pd(__mmask8, __m128d, __m128d, const int);
extern __m256d   __cdecl _mm256_mask_shuffle_pd(__m256d, __mmask8, __m256d, __m256d, const int);
extern __m256d   __cdecl _mm256_maskz_shuffle_pd(__mmask8, __m256d, __m256d, const int);
extern __m128    __cdecl _mm_mask_shuffle_ps(__m128, __mmask8, __m128, __m128, const int);
extern __m128    __cdecl _mm_maskz_shuffle_ps(__mmask8, __m128, __m128, const int);
extern __m256    __cdecl _mm256_mask_shuffle_ps(__m256, __mmask8, __m256, __m256, const int);
extern __m256    __cdecl _mm256_maskz_shuffle_ps(__mmask8, __m256, __m256, const int);
extern __m128i   __cdecl _mm_mask_shufflehi_epi16(__m128i, __mmask8, __m128i, int);
extern __m128i   __cdecl _mm_maskz_shufflehi_epi16(__mmask8, __m128i, int);
extern __m256i   __cdecl _mm256_mask_shufflehi_epi16(__m256i, __mmask16, __m256i, int);
extern __m256i   __cdecl _mm256_maskz_shufflehi_epi16(__mmask16, __m256i, int);
extern __m128i   __cdecl _mm_mask_shufflelo_epi16(__m128i, __mmask8, __m128i, int);
extern __m128i   __cdecl _mm_maskz_shufflelo_epi16(__mmask8, __m128i, int);
extern __m256i   __cdecl _mm256_mask_shufflelo_epi16(__m256i, __mmask16, __m256i, int);
extern __m256i   __cdecl _mm256_maskz_shufflelo_epi16(__mmask16, __m256i, int);
extern __m128i   __cdecl _mm_mask_sll_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sll_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sll_epi16(__m256i, __mmask16, __m256i, __m128i);
extern __m256i   __cdecl _mm256_maskz_sll_epi16(__mmask16, __m256i, __m128i);
extern __m128i   __cdecl _mm_mask_sll_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sll_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sll_epi32(__m256i, __mmask8, __m256i, __m128i);
extern __m256i   __cdecl _mm256_maskz_sll_epi32(__mmask8, __m256i, __m128i);
extern __m128i   __cdecl _mm_mask_sll_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sll_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sll_epi64(__m256i, __mmask8, __m256i, __m128i);
extern __m256i   __cdecl _mm256_maskz_sll_epi64(__mmask8, __m256i, __m128i);
extern __m128i   __cdecl _mm_mask_slli_epi16(__m128i, __mmask8, __m128i, unsigned int);
extern __m128i   __cdecl _mm_maskz_slli_epi16(__mmask8, __m128i, unsigned int);
extern __m256i   __cdecl _mm256_mask_slli_epi16(__m256i, __mmask16, __m256i, unsigned int);
extern __m256i   __cdecl _mm256_maskz_slli_epi16(__mmask16, __m256i, unsigned int);
extern __m128i   __cdecl _mm_mask_slli_epi32(__m128i, __mmask8, __m128i, unsigned int);
extern __m128i   __cdecl _mm_maskz_slli_epi32(__mmask8, __m128i, unsigned int);
extern __m256i   __cdecl _mm256_mask_slli_epi32(__m256i, __mmask8, __m256i, unsigned int);
extern __m256i   __cdecl _mm256_maskz_slli_epi32(__mmask8, __m256i, unsigned int);
extern __m128i   __cdecl _mm_mask_slli_epi64(__m128i, __mmask8, __m128i, unsigned int);
extern __m128i   __cdecl _mm_maskz_slli_epi64(__mmask8, __m128i, unsigned int);
extern __m256i   __cdecl _mm256_mask_slli_epi64(__m256i, __mmask8, __m256i, unsigned int);
extern __m256i   __cdecl _mm256_maskz_slli_epi64(__mmask8, __m256i, unsigned int);
extern __m128i   __cdecl _mm_mask_sllv_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sllv_epi16(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_sllv_epi16(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sllv_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_sllv_epi16(__mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_sllv_epi16(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_sllv_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sllv_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sllv_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_sllv_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_sllv_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sllv_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sllv_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_sllv_epi64(__mmask8, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_sqrt_pd(__m128d, __mmask8, __m128d);
extern __m128d   __cdecl _mm_maskz_sqrt_pd(__mmask8, __m128d);
extern __m256d   __cdecl _mm256_mask_sqrt_pd(__m256d, __mmask8, __m256d);
extern __m256d   __cdecl _mm256_maskz_sqrt_pd(__mmask8, __m256d);
extern __m128    __cdecl _mm_mask_sqrt_ps(__m128, __mmask8, __m128);
extern __m128    __cdecl _mm_maskz_sqrt_ps(__mmask8, __m128);
extern __m256    __cdecl _mm256_mask_sqrt_ps(__m256, __mmask8, __m256);
extern __m256    __cdecl _mm256_maskz_sqrt_ps(__mmask8, __m256);
extern __m128i   __cdecl _mm_mask_sra_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sra_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sra_epi16(__m256i, __mmask16, __m256i, __m128i);
extern __m256i   __cdecl _mm256_maskz_sra_epi16(__mmask16, __m256i, __m128i);
extern __m128i   __cdecl _mm_mask_sra_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sra_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sra_epi32(__m256i, __mmask8, __m256i, __m128i);
extern __m256i   __cdecl _mm256_maskz_sra_epi32(__mmask8, __m256i, __m128i);
extern __m128i   __cdecl _mm_mask_sra_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sra_epi64(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_sra_epi64(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sra_epi64(__m256i, __mmask8, __m256i, __m128i);
extern __m256i   __cdecl _mm256_maskz_sra_epi64(__mmask8, __m256i, __m128i);
extern __m256i   __cdecl _mm256_sra_epi64(__m256i, __m128i);
extern __m128i   __cdecl _mm_mask_srai_epi16(__m128i, __mmask8, __m128i, unsigned int);
extern __m128i   __cdecl _mm_maskz_srai_epi16(__mmask8, __m128i, unsigned int);
extern __m256i   __cdecl _mm256_mask_srai_epi16(__m256i, __mmask16, __m256i, unsigned int);
extern __m256i   __cdecl _mm256_maskz_srai_epi16(__mmask16, __m256i, unsigned int);
extern __m128i   __cdecl _mm_mask_srai_epi32(__m128i, __mmask8, __m128i, unsigned int);
extern __m128i   __cdecl _mm_maskz_srai_epi32(__mmask8, __m128i, unsigned int);
extern __m256i   __cdecl _mm256_mask_srai_epi32(__m256i, __mmask8, __m256i, unsigned int);
extern __m256i   __cdecl _mm256_maskz_srai_epi32(__mmask8, __m256i, unsigned int);
extern __m128i   __cdecl _mm_mask_srai_epi64(__m128i, __mmask8, __m128i, unsigned int);
extern __m128i   __cdecl _mm_maskz_srai_epi64(__mmask8, __m128i, unsigned int);
extern __m128i   __cdecl _mm_srai_epi64(__m128i, unsigned int);
extern __m256i   __cdecl _mm256_mask_srai_epi64(__m256i, __mmask8, __m256i, unsigned int);
extern __m256i   __cdecl _mm256_maskz_srai_epi64(__mmask8, __m256i, unsigned int);
extern __m256i   __cdecl _mm256_srai_epi64(__m256i, unsigned int);
extern __m128i   __cdecl _mm_mask_srav_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_srav_epi16(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_srav_epi16(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_srav_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_srav_epi16(__mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_srav_epi16(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_srav_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_srav_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_srav_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_srav_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_srav_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_srav_epi64(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_srav_epi64(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_srav_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_srav_epi64(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_srav_epi64(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_srl_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_srl_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_srl_epi16(__m256i, __mmask16, __m256i, __m128i);
extern __m256i   __cdecl _mm256_maskz_srl_epi16(__mmask16, __m256i, __m128i);
extern __m128i   __cdecl _mm_mask_srl_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_srl_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_srl_epi32(__m256i, __mmask8, __m256i, __m128i);
extern __m256i   __cdecl _mm256_maskz_srl_epi32(__mmask8, __m256i, __m128i);
extern __m128i   __cdecl _mm_mask_srl_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_srl_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_srl_epi64(__m256i, __mmask8, __m256i, __m128i);
extern __m256i   __cdecl _mm256_maskz_srl_epi64(__mmask8, __m256i, __m128i);
extern __m128i   __cdecl _mm_mask_srli_epi16(__m128i, __mmask8, __m128i, int);
extern __m128i   __cdecl _mm_maskz_srli_epi16(__mmask8, __m128i, int);
extern __m256i   __cdecl _mm256_mask_srli_epi16(__m256i, __mmask16, __m256i, int);
extern __m256i   __cdecl _mm256_maskz_srli_epi16(__mmask16, __m256i, int);
extern __m128i   __cdecl _mm_mask_srli_epi32(__m128i, __mmask8, __m128i, unsigned int);
extern __m128i   __cdecl _mm_maskz_srli_epi32(__mmask8, __m128i, unsigned int);
extern __m256i   __cdecl _mm256_mask_srli_epi32(__m256i, __mmask8, __m256i, unsigned int);
extern __m256i   __cdecl _mm256_maskz_srli_epi32(__mmask8, __m256i, unsigned int);
extern __m128i   __cdecl _mm_mask_srli_epi64(__m128i, __mmask8, __m128i, unsigned int);
extern __m128i   __cdecl _mm_maskz_srli_epi64(__mmask8, __m128i, unsigned int);
extern __m256i   __cdecl _mm256_mask_srli_epi64(__m256i, __mmask8, __m256i, unsigned int);
extern __m256i   __cdecl _mm256_maskz_srli_epi64(__mmask8, __m256i, unsigned int);
extern __m128i   __cdecl _mm_mask_srlv_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_srlv_epi16(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_srlv_epi16(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_srlv_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_srlv_epi16(__mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_srlv_epi16(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_srlv_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_srlv_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_srlv_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_srlv_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_srlv_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_srlv_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_srlv_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_srlv_epi64(__mmask8, __m256i, __m256i);
extern void      __cdecl _mm_mask_store_epi32(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_store_epi32(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_store_epi64(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_store_epi64(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_store_pd(void*, __mmask8, __m128d);
extern void      __cdecl _mm256_mask_store_pd(void*, __mmask8, __m256d);
extern void      __cdecl _mm_mask_store_ps(void*, __mmask8, __m128);
extern void      __cdecl _mm256_mask_store_ps(void*, __mmask8, __m256);
extern void      __cdecl _mm_storeu_epi16(void*, __m128i);
extern void      __cdecl _mm256_storeu_epi16(void*, __m256i);
extern void      __cdecl _mm_mask_storeu_epi16(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_storeu_epi16(void*, __mmask16, __m256i);
extern void      __cdecl _mm_storeu_epi32(void*, __m128i);
extern void      __cdecl _mm256_storeu_epi32(void*, __m256i);
extern void      __cdecl _mm_mask_storeu_epi32(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_storeu_epi32(void*, __mmask8, __m256i);
extern void      __cdecl _mm_storeu_epi64(void*, __m128i);
extern void      __cdecl _mm256_storeu_epi64(void*, __m256i);
extern void      __cdecl _mm_mask_storeu_epi64(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_storeu_epi64(void*, __mmask8, __m256i);
extern void      __cdecl _mm_storeu_epi8(void*, __m128i);
extern void      __cdecl _mm256_storeu_epi8(void*, __m256i);
extern void      __cdecl _mm_mask_storeu_epi8(void*, __mmask16, __m128i);
extern void      __cdecl _mm256_mask_storeu_epi8(void*, __mmask32, __m256i);
extern void      __cdecl _mm_mask_storeu_pd(void*, __mmask8, __m128d);
extern void      __cdecl _mm256_mask_storeu_pd(void*, __mmask8, __m256d);
extern void      __cdecl _mm_mask_storeu_ps(void*, __mmask8, __m128);
extern void      __cdecl _mm256_mask_storeu_ps(void*, __mmask8, __m256);
extern __m128i   __cdecl _mm_mask_sub_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sub_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sub_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_sub_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_sub_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sub_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sub_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_sub_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_sub_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sub_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sub_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_sub_epi64(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_sub_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sub_epi8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sub_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_sub_epi8(__mmask32, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_sub_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_sub_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_sub_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_sub_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_sub_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_sub_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_sub_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_sub_ps(__mmask8, __m256, __m256);
extern __m128i   __cdecl _mm_mask_subs_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_subs_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_subs_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_subs_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_subs_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_subs_epi8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_subs_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_subs_epi8(__mmask32, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_subs_epu16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_subs_epu16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_subs_epu16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_subs_epu16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_subs_epu8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_subs_epu8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_subs_epu8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_subs_epu8(__mmask32, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_ternarylogic_epi32(__m128i, __mmask8, __m128i, __m128i, int);
extern __m128i   __cdecl _mm_maskz_ternarylogic_epi32(__mmask8, __m128i, __m128i, __m128i, int);
extern __m128i   __cdecl _mm_ternarylogic_epi32(__m128i, __m128i, __m128i, int);
extern __m256i   __cdecl _mm256_mask_ternarylogic_epi32(__m256i, __mmask8, __m256i, __m256i, int);
extern __m256i   __cdecl _mm256_maskz_ternarylogic_epi32(__mmask8, __m256i, __m256i, __m256i, int);
extern __m256i   __cdecl _mm256_ternarylogic_epi32(__m256i, __m256i, __m256i, int);
extern __m128i   __cdecl _mm_mask_ternarylogic_epi64(__m128i, __mmask8, __m128i, __m128i, int);
extern __m128i   __cdecl _mm_maskz_ternarylogic_epi64(__mmask8, __m128i, __m128i, __m128i, int);
extern __m128i   __cdecl _mm_ternarylogic_epi64(__m128i, __m128i, __m128i, int);
extern __m256i   __cdecl _mm256_mask_ternarylogic_epi64(__m256i, __mmask8, __m256i, __m256i, int);
extern __m256i   __cdecl _mm256_maskz_ternarylogic_epi64(__mmask8, __m256i, __m256i, __m256i, int);
extern __m256i   __cdecl _mm256_ternarylogic_epi64(__m256i, __m256i, __m256i, int);
extern __mmask8  __cdecl _mm_mask_test_epi16_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_test_epi16_mask(__m128i, __m128i);
extern __mmask16 __cdecl _mm256_mask_test_epi16_mask(__mmask16, __m256i, __m256i);
extern __mmask16 __cdecl _mm256_test_epi16_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm_mask_test_epi32_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_test_epi32_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm256_mask_test_epi32_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_test_epi32_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm_mask_test_epi64_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_test_epi64_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm256_mask_test_epi64_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_test_epi64_mask(__m256i, __m256i);
extern __mmask16 __cdecl _mm_mask_test_epi8_mask(__mmask16, __m128i, __m128i);
extern __mmask16 __cdecl _mm_test_epi8_mask(__m128i, __m128i);
extern __mmask32 __cdecl _mm256_mask_test_epi8_mask(__mmask32, __m256i, __m256i);
extern __mmask32 __cdecl _mm256_test_epi8_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm_mask_testn_epi16_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_testn_epi16_mask(__m128i, __m128i);
extern __mmask16 __cdecl _mm256_mask_testn_epi16_mask(__mmask16, __m256i, __m256i);
extern __mmask16 __cdecl _mm256_testn_epi16_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm_mask_testn_epi32_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_testn_epi32_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm256_mask_testn_epi32_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_testn_epi32_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm_mask_testn_epi64_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_testn_epi64_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm256_mask_testn_epi64_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_testn_epi64_mask(__m256i, __m256i);
extern __mmask16 __cdecl _mm_mask_testn_epi8_mask(__mmask16, __m128i, __m128i);
extern __mmask16 __cdecl _mm_testn_epi8_mask(__m128i, __m128i);
extern __mmask32 __cdecl _mm256_mask_testn_epi8_mask(__mmask32, __m256i, __m256i);
extern __mmask32 __cdecl _mm256_testn_epi8_mask(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_unpackhi_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_unpackhi_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_unpackhi_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_unpackhi_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_unpackhi_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_unpackhi_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_unpackhi_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_unpackhi_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_unpackhi_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_unpackhi_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_unpackhi_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_unpackhi_epi64(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_unpackhi_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_unpackhi_epi8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_unpackhi_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_unpackhi_epi8(__mmask32, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_unpackhi_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_unpackhi_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_unpackhi_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_unpackhi_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_unpackhi_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_unpackhi_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_unpackhi_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_unpackhi_ps(__mmask8, __m256, __m256);
extern __m128i   __cdecl _mm_mask_unpacklo_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_unpacklo_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_unpacklo_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_unpacklo_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_unpacklo_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_unpacklo_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_unpacklo_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_unpacklo_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_unpacklo_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_unpacklo_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_unpacklo_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_unpacklo_epi64(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_unpacklo_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_unpacklo_epi8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_unpacklo_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_unpacklo_epi8(__mmask32, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_unpacklo_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_unpacklo_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_unpacklo_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_unpacklo_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_unpacklo_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_unpacklo_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_unpacklo_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_unpacklo_ps(__mmask8, __m256, __m256);
extern __m128i   __cdecl _mm_xor_epi32(__m128i, __m128i);
extern __m128i   __cdecl _mm_mask_xor_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_xor_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_xor_epi32(__m256i, __m256i);
extern __m256i   __cdecl _mm256_mask_xor_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_xor_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_xor_epi64(__m128i, __m128i);
extern __m128i   __cdecl _mm_mask_xor_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_xor_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_xor_epi64(__m256i, __m256i);
extern __m256i   __cdecl _mm256_mask_xor_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_xor_epi64(__mmask8, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_xor_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_xor_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_xor_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_xor_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_xor_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_xor_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_xor_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_xor_ps(__mmask8, __m256, __m256);

extern __mmask16  __cdecl _mm_cmpeq_epi8_mask(__m128i, __m128i);
extern __mmask16  __cdecl _mm_cmpge_epi8_mask(__m128i, __m128i);
extern __mmask16  __cdecl _mm_cmpgt_epi8_mask(__m128i, __m128i);
extern __mmask16  __cdecl _mm_cmple_epi8_mask(__m128i, __m128i);
extern __mmask16  __cdecl _mm_cmplt_epi8_mask(__m128i, __m128i);
extern __mmask16  __cdecl _mm_cmpneq_epi8_mask(__m128i, __m128i);
extern __mmask16  __cdecl _mm_cmpeq_epu8_mask(__m128i, __m128i);
extern __mmask16  __cdecl _mm_cmpge_epu8_mask(__m128i, __m128i);
extern __mmask16  __cdecl _mm_cmpgt_epu8_mask(__m128i, __m128i);
extern __mmask16  __cdecl _mm_cmple_epu8_mask(__m128i, __m128i);
extern __mmask16  __cdecl _mm_cmplt_epu8_mask(__m128i, __m128i);
extern __mmask16  __cdecl _mm_cmpneq_epu8_mask(__m128i, __m128i);

extern __mmask16  __cdecl _mm_mask_cmpeq_epi8_mask(__mmask16, __m128i, __m128i);
extern __mmask16  __cdecl _mm_mask_cmpge_epi8_mask(__mmask16, __m128i, __m128i);
extern __mmask16  __cdecl _mm_mask_cmpgt_epi8_mask(__mmask16, __m128i, __m128i);
extern __mmask16  __cdecl _mm_mask_cmple_epi8_mask(__mmask16, __m128i, __m128i);
extern __mmask16  __cdecl _mm_mask_cmplt_epi8_mask(__mmask16, __m128i, __m128i);
extern __mmask16  __cdecl _mm_mask_cmpneq_epi8_mask(__mmask16, __m128i, __m128i);
extern __mmask16  __cdecl _mm_mask_cmpeq_epu8_mask(__mmask16, __m128i, __m128i);
extern __mmask16  __cdecl _mm_mask_cmpge_epu8_mask(__mmask16, __m128i, __m128i);
extern __mmask16  __cdecl _mm_mask_cmpgt_epu8_mask(__mmask16, __m128i, __m128i);
extern __mmask16  __cdecl _mm_mask_cmple_epu8_mask(__mmask16, __m128i, __m128i);
extern __mmask16  __cdecl _mm_mask_cmplt_epu8_mask(__mmask16, __m128i, __m128i);
extern __mmask16  __cdecl _mm_mask_cmpneq_epu8_mask(__mmask16, __m128i, __m128i);

extern __mmask8  __cdecl _mm_cmpeq_epi16_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpge_epi16_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpgt_epi16_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmple_epi16_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmplt_epi16_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpneq_epi16_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpeq_epu16_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpge_epu16_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpgt_epu16_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmple_epu16_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmplt_epu16_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpneq_epu16_mask(__m128i, __m128i);

extern __mmask8  __cdecl _mm_mask_cmpeq_epi16_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpge_epi16_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpgt_epi16_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmple_epi16_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmplt_epi16_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpneq_epi16_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpeq_epu16_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpge_epu16_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpgt_epu16_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmple_epu16_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmplt_epu16_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpneq_epu16_mask(__mmask8, __m128i, __m128i);

extern __mmask8  __cdecl _mm_cmpeq_epi32_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpge_epi32_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpgt_epi32_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmple_epi32_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmplt_epi32_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpneq_epi32_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpeq_epu32_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpge_epu32_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpgt_epu32_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmple_epu32_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmplt_epu32_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpneq_epu32_mask(__m128i, __m128i);

extern __mmask8  __cdecl _mm_mask_cmpeq_epi32_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpge_epi32_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpgt_epi32_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmple_epi32_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmplt_epi32_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpneq_epi32_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpeq_epu32_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpge_epu32_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpgt_epu32_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmple_epu32_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmplt_epu32_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpneq_epu32_mask(__mmask8, __m128i, __m128i);

extern __mmask8  __cdecl _mm_cmpeq_epi64_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpge_epi64_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpgt_epi64_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmple_epi64_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmplt_epi64_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpneq_epi64_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpeq_epu64_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpge_epu64_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpgt_epu64_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmple_epu64_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmplt_epu64_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpneq_epu64_mask(__m128i, __m128i);

extern __mmask8  __cdecl _mm_mask_cmpeq_epi64_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpge_epi64_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpgt_epi64_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmple_epi64_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmplt_epi64_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpneq_epi64_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpeq_epu64_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpge_epu64_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpgt_epu64_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmple_epu64_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmplt_epu64_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpneq_epu64_mask(__mmask8, __m128i, __m128i);

extern __mmask32  __cdecl _mm256_cmpeq_epi8_mask(__m256i, __m256i);
extern __mmask32  __cdecl _mm256_cmpge_epi8_mask(__m256i, __m256i);
extern __mmask32  __cdecl _mm256_cmpgt_epi8_mask(__m256i, __m256i);
extern __mmask32  __cdecl _mm256_cmple_epi8_mask(__m256i, __m256i);
extern __mmask32  __cdecl _mm256_cmplt_epi8_mask(__m256i, __m256i);
extern __mmask32  __cdecl _mm256_cmpneq_epi8_mask(__m256i, __m256i);
extern __mmask32  __cdecl _mm256_cmpeq_epu8_mask(__m256i, __m256i);
extern __mmask32  __cdecl _mm256_cmpge_epu8_mask(__m256i, __m256i);
extern __mmask32  __cdecl _mm256_cmpgt_epu8_mask(__m256i, __m256i);
extern __mmask32  __cdecl _mm256_cmple_epu8_mask(__m256i, __m256i);
extern __mmask32  __cdecl _mm256_cmplt_epu8_mask(__m256i, __m256i);
extern __mmask32  __cdecl _mm256_cmpneq_epu8_mask(__m256i, __m256i);

extern __mmask32  __cdecl _mm256_mask_cmpeq_epi8_mask(__mmask32, __m256i, __m256i);
extern __mmask32  __cdecl _mm256_mask_cmpge_epi8_mask(__mmask32, __m256i, __m256i);
extern __mmask32  __cdecl _mm256_mask_cmpgt_epi8_mask(__mmask32, __m256i, __m256i);
extern __mmask32  __cdecl _mm256_mask_cmple_epi8_mask(__mmask32, __m256i, __m256i);
extern __mmask32  __cdecl _mm256_mask_cmplt_epi8_mask(__mmask32, __m256i, __m256i);
extern __mmask32  __cdecl _mm256_mask_cmpneq_epi8_mask(__mmask32, __m256i, __m256i);
extern __mmask32  __cdecl _mm256_mask_cmpeq_epu8_mask(__mmask32, __m256i, __m256i);
extern __mmask32  __cdecl _mm256_mask_cmpge_epu8_mask(__mmask32, __m256i, __m256i);
extern __mmask32  __cdecl _mm256_mask_cmpgt_epu8_mask(__mmask32, __m256i, __m256i);
extern __mmask32  __cdecl _mm256_mask_cmple_epu8_mask(__mmask32, __m256i, __m256i);
extern __mmask32  __cdecl _mm256_mask_cmplt_epu8_mask(__mmask32, __m256i, __m256i);
extern __mmask32  __cdecl _mm256_mask_cmpneq_epu8_mask(__mmask32, __m256i, __m256i);

extern __mmask16  __cdecl _mm256_cmpeq_epi16_mask(__m256i, __m256i);
extern __mmask16  __cdecl _mm256_cmpge_epi16_mask(__m256i, __m256i);
extern __mmask16  __cdecl _mm256_cmpgt_epi16_mask(__m256i, __m256i);
extern __mmask16  __cdecl _mm256_cmple_epi16_mask(__m256i, __m256i);
extern __mmask16  __cdecl _mm256_cmplt_epi16_mask(__m256i, __m256i);
extern __mmask16  __cdecl _mm256_cmpneq_epi16_mask(__m256i, __m256i);
extern __mmask16  __cdecl _mm256_cmpeq_epu16_mask(__m256i, __m256i);
extern __mmask16  __cdecl _mm256_cmpge_epu16_mask(__m256i, __m256i);
extern __mmask16  __cdecl _mm256_cmpgt_epu16_mask(__m256i, __m256i);
extern __mmask16  __cdecl _mm256_cmple_epu16_mask(__m256i, __m256i);
extern __mmask16  __cdecl _mm256_cmplt_epu16_mask(__m256i, __m256i);
extern __mmask16  __cdecl _mm256_cmpneq_epu16_mask(__m256i, __m256i);

extern __mmask16  __cdecl _mm256_mask_cmpeq_epi16_mask(__mmask16, __m256i, __m256i);
extern __mmask16  __cdecl _mm256_mask_cmpge_epi16_mask(__mmask16, __m256i, __m256i);
extern __mmask16  __cdecl _mm256_mask_cmpgt_epi16_mask(__mmask16, __m256i, __m256i);
extern __mmask16  __cdecl _mm256_mask_cmple_epi16_mask(__mmask16, __m256i, __m256i);
extern __mmask16  __cdecl _mm256_mask_cmplt_epi16_mask(__mmask16, __m256i, __m256i);
extern __mmask16  __cdecl _mm256_mask_cmpneq_epi16_mask(__mmask16, __m256i, __m256i);
extern __mmask16  __cdecl _mm256_mask_cmpeq_epu16_mask(__mmask16, __m256i, __m256i);
extern __mmask16  __cdecl _mm256_mask_cmpge_epu16_mask(__mmask16, __m256i, __m256i);
extern __mmask16  __cdecl _mm256_mask_cmpgt_epu16_mask(__mmask16, __m256i, __m256i);
extern __mmask16  __cdecl _mm256_mask_cmple_epu16_mask(__mmask16, __m256i, __m256i);
extern __mmask16  __cdecl _mm256_mask_cmplt_epu16_mask(__mmask16, __m256i, __m256i);
extern __mmask16  __cdecl _mm256_mask_cmpneq_epu16_mask(__mmask16, __m256i, __m256i);

extern __mmask8  __cdecl _mm256_cmpeq_epi32_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmpge_epi32_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmpgt_epi32_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmple_epi32_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmplt_epi32_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmpneq_epi32_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmpeq_epu32_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmpge_epu32_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmpgt_epu32_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmple_epu32_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmplt_epu32_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmpneq_epu32_mask(__m256i, __m256i);

extern __mmask8  __cdecl _mm256_mask_cmpeq_epi32_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmpge_epi32_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmpgt_epi32_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmple_epi32_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmplt_epi32_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmpneq_epi32_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmpeq_epu32_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmpge_epu32_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmpgt_epu32_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmple_epu32_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmplt_epu32_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmpneq_epu32_mask(__mmask8, __m256i, __m256i);

extern __mmask8  __cdecl _mm256_cmpeq_epi64_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmpge_epi64_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmpgt_epi64_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmple_epi64_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmplt_epi64_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmpneq_epi64_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmpeq_epu64_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmpge_epu64_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmpgt_epu64_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmple_epu64_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmplt_epu64_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmpneq_epu64_mask(__m256i, __m256i);

extern __mmask8  __cdecl _mm256_mask_cmpeq_epi64_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmpge_epi64_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmpgt_epi64_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmple_epi64_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmplt_epi64_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmpneq_epi64_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmpeq_epu64_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmpge_epu64_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmpgt_epu64_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmple_epu64_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmplt_epu64_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmpneq_epu64_mask(__mmask8, __m256i, __m256i);


extern __m128d   __cdecl _mm_add_round_sd(__m128d, __m128d, int);
extern __m128d   __cdecl _mm_mask_add_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_maskz_add_round_sd(__mmask8, __m128d, __m128d, int);
extern __m128    __cdecl _mm_add_round_ss(__m128, __m128, int);
extern __m128    __cdecl _mm_mask_add_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_maskz_add_round_ss(__mmask8, __m128, __m128, int);
extern __m128d   __cdecl _mm_mask_add_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_add_sd(__mmask8, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_add_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_add_ss(__mmask8, __m128, __m128);
extern __mmask8  __cdecl _mm_cmp_round_sd_mask(__m128d, __m128d, const int, const int);
extern __mmask8  __cdecl _mm_mask_cmp_round_sd_mask(__mmask8, __m128d, __m128d, const int, const int);
extern __mmask8  __cdecl _mm_cmp_round_ss_mask(__m128, __m128, const int, const int);
extern __mmask8  __cdecl _mm_mask_cmp_round_ss_mask(__mmask8, __m128, __m128, const int, const int);
extern __mmask8  __cdecl _mm_cmp_sd_mask(__m128d, __m128d, const int);
extern __mmask8  __cdecl _mm_mask_cmp_sd_mask(__mmask8, __m128d, __m128d, const int);
extern __mmask8  __cdecl _mm_cmp_ss_mask(__m128, __m128, const int);
extern __mmask8  __cdecl _mm_mask_cmp_ss_mask(__mmask8, __m128, __m128, const int);
extern int       __cdecl _mm_comi_round_sd(__m128d, __m128d, const int, const int);
extern int       __cdecl _mm_comi_round_ss(__m128, __m128, const int, const int);
extern __m128    __cdecl _mm_cvt_roundi32_ss(__m128, int, int);
extern int       __cdecl _mm_cvt_roundsd_i32(__m128d, int);
extern int       __cdecl _mm_cvt_roundsd_si32(__m128d, int);
extern __m128    __cdecl _mm_cvt_roundsd_ss(__m128, __m128d, int);
extern __m128    __cdecl _mm_mask_cvt_roundsd_ss(__m128, __mmask8, __m128, __m128d, int);
extern __m128    __cdecl _mm_maskz_cvt_roundsd_ss(__mmask8, __m128, __m128d, int);
extern unsigned int __cdecl _mm_cvt_roundsd_u32(__m128d, int);
extern __m128    __cdecl _mm_cvt_roundsi32_ss(__m128, int, int);
extern int       __cdecl _mm_cvt_roundss_i32(__m128, int);
extern __m128d   __cdecl _mm_cvt_roundss_sd(__m128d, __m128, int);
extern __m128d   __cdecl _mm_mask_cvt_roundss_sd(__m128d, __mmask8, __m128d, __m128, int);
extern __m128d   __cdecl _mm_maskz_cvt_roundss_sd(__mmask8, __m128d, __m128, int);
extern int       __cdecl _mm_cvt_roundss_si32(__m128, int);
extern unsigned int __cdecl _mm_cvt_roundss_u32(__m128, int);
extern __m128    __cdecl _mm_cvt_roundu32_ss(__m128, unsigned int, int);
extern __m128d   __cdecl _mm_cvti32_sd(__m128d, int);
extern __m128    __cdecl _mm_cvti32_ss(__m128, int);
extern int       __cdecl _mm_cvtsd_i32(__m128d);
extern __m128    __cdecl _mm_mask_cvtsd_ss(__m128, __mmask8, __m128, __m128d);
extern __m128    __cdecl _mm_maskz_cvtsd_ss(__mmask8, __m128, __m128d);
extern unsigned int __cdecl _mm_cvtsd_u32(__m128d);
extern int       __cdecl _mm_cvtss_i32(__m128);
extern __m128d   __cdecl _mm_mask_cvtss_sd(__m128d, __mmask8, __m128d, __m128);
extern __m128d   __cdecl _mm_maskz_cvtss_sd(__mmask8, __m128d, __m128);
extern unsigned int __cdecl _mm_cvtss_u32(__m128);
extern int       __cdecl _mm_cvtt_roundsd_i32(__m128d, int);
extern int       __cdecl _mm_cvtt_roundsd_si32(__m128d, int);
extern unsigned int __cdecl _mm_cvtt_roundsd_u32(__m128d, int);
extern int       __cdecl _mm_cvtt_roundss_i32(__m128, int);
extern int       __cdecl _mm_cvtt_roundss_si32(__m128, int);
extern unsigned int __cdecl _mm_cvtt_roundss_u32(__m128, int);
extern int       __cdecl _mm_cvttsd_i32(__m128d);
extern unsigned int __cdecl _mm_cvttsd_u32(__m128d);
extern int       __cdecl _mm_cvttss_i32(__m128);
extern unsigned int __cdecl _mm_cvttss_u32(__m128);
extern __m128d   __cdecl _mm_cvtu32_sd(__m128d, unsigned int);
extern __m128    __cdecl _mm_cvtu32_ss(__m128, unsigned int);
extern __m128d   __cdecl _mm_div_round_sd(__m128d, __m128d, int);
extern __m128d   __cdecl _mm_mask_div_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_maskz_div_round_sd(__mmask8, __m128d, __m128d, int);
extern __m128    __cdecl _mm_div_round_ss(__m128, __m128, int);
extern __m128    __cdecl _mm_mask_div_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_maskz_div_round_ss(__mmask8, __m128, __m128, int);
extern __m128d   __cdecl _mm_mask_div_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_div_sd(__mmask8, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_div_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_div_ss(__mmask8, __m128, __m128);
extern __m128d   __cdecl _mm_fixupimm_round_sd(__m128d, __m128d, __m128i, const int, int);
extern __m128d   __cdecl _mm_mask_fixupimm_round_sd(__m128d, __mmask8, __m128d, __m128i, const int, const int);
extern __m128d   __cdecl _mm_maskz_fixupimm_round_sd(__mmask8, __m128d, __m128d, __m128i, const int, const int);
extern __m128    __cdecl _mm_fixupimm_round_ss(__m128, __m128, __m128i, const int, const int);
extern __m128    __cdecl _mm_mask_fixupimm_round_ss(__m128, __mmask8, __m128, __m128i, const int, const int);
extern __m128    __cdecl _mm_maskz_fixupimm_round_ss(__mmask8, __m128, __m128, __m128i, const int, const int);
extern __m128d   __cdecl _mm_fixupimm_sd(__m128d, __m128d, __m128i, const int);
extern __m128d   __cdecl _mm_mask_fixupimm_sd(__m128d, __mmask8, __m128d, __m128i, const int);
extern __m128d   __cdecl _mm_maskz_fixupimm_sd(__mmask8, __m128d, __m128d, __m128i, const int);
extern __m128    __cdecl _mm_fixupimm_ss(__m128, __m128, __m128i, const int);
extern __m128    __cdecl _mm_mask_fixupimm_ss(__m128, __mmask8, __m128, __m128i, const int);
extern __m128    __cdecl _mm_maskz_fixupimm_ss(__mmask8, __m128, __m128, __m128i, const int);
extern __m128d   __cdecl _mm_fmadd_round_sd(__m128d, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_mask_fmadd_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_mask3_fmadd_round_sd(__m128d, __m128d, __m128d, __mmask8, int);
extern __m128d   __cdecl _mm_maskz_fmadd_round_sd(__mmask8, __m128d, __m128d, __m128d, int);
extern __m128    __cdecl _mm_fmadd_round_ss(__m128, __m128, __m128, int);
extern __m128    __cdecl _mm_mask_fmadd_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_mask3_fmadd_round_ss(__m128, __m128, __m128, __mmask8, int);
extern __m128    __cdecl _mm_maskz_fmadd_round_ss(__mmask8, __m128, __m128, __m128, int);
extern __m128d   __cdecl _mm_mask_fmadd_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_mask3_fmadd_sd(__m128d, __m128d, __m128d, __mmask8);
extern __m128d   __cdecl _mm_maskz_fmadd_sd(__mmask8, __m128d, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_fmadd_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_mask3_fmadd_ss(__m128, __m128, __m128, __mmask8);
extern __m128    __cdecl _mm_maskz_fmadd_ss(__mmask8, __m128, __m128, __m128);
extern __m128d   __cdecl _mm_fmsub_round_sd(__m128d, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_mask_fmsub_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_mask3_fmsub_round_sd(__m128d, __m128d, __m128d, __mmask8, int);
extern __m128d   __cdecl _mm_maskz_fmsub_round_sd(__mmask8, __m128d, __m128d, __m128d, int);
extern __m128    __cdecl _mm_fmsub_round_ss(__m128, __m128, __m128, int);
extern __m128    __cdecl _mm_mask_fmsub_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_mask3_fmsub_round_ss(__m128, __m128, __m128, __mmask8, int);
extern __m128    __cdecl _mm_maskz_fmsub_round_ss(__mmask8, __m128, __m128, __m128, int);
extern __m128d   __cdecl _mm_mask_fmsub_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_mask3_fmsub_sd(__m128d, __m128d, __m128d, __mmask8);
extern __m128d   __cdecl _mm_maskz_fmsub_sd(__mmask8, __m128d, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_fmsub_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_mask3_fmsub_ss(__m128, __m128, __m128, __mmask8);
extern __m128    __cdecl _mm_maskz_fmsub_ss(__mmask8, __m128, __m128, __m128);
extern __m128d   __cdecl _mm_fnmadd_round_sd(__m128d, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_mask_fnmadd_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_mask3_fnmadd_round_sd(__m128d, __m128d, __m128d, __mmask8, int);
extern __m128d   __cdecl _mm_maskz_fnmadd_round_sd(__mmask8, __m128d, __m128d, __m128d, int);
extern __m128    __cdecl _mm_fnmadd_round_ss(__m128, __m128, __m128, int);
extern __m128    __cdecl _mm_mask_fnmadd_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_mask3_fnmadd_round_ss(__m128, __m128, __m128, __mmask8, int);
extern __m128    __cdecl _mm_maskz_fnmadd_round_ss(__mmask8, __m128, __m128, __m128, int);
extern __m128d   __cdecl _mm_mask_fnmadd_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_mask3_fnmadd_sd(__m128d, __m128d, __m128d, __mmask8);
extern __m128d   __cdecl _mm_maskz_fnmadd_sd(__mmask8, __m128d, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_fnmadd_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_mask3_fnmadd_ss(__m128, __m128, __m128, __mmask8);
extern __m128    __cdecl _mm_maskz_fnmadd_ss(__mmask8, __m128, __m128, __m128);
extern __m128d   __cdecl _mm_fnmsub_round_sd(__m128d, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_mask_fnmsub_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_mask3_fnmsub_round_sd(__m128d, __m128d, __m128d, __mmask8, int);
extern __m128d   __cdecl _mm_maskz_fnmsub_round_sd(__mmask8, __m128d, __m128d, __m128d, int);
extern __m128    __cdecl _mm_fnmsub_round_ss(__m128, __m128, __m128, int);
extern __m128    __cdecl _mm_mask_fnmsub_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_mask3_fnmsub_round_ss(__m128, __m128, __m128, __mmask8, int);
extern __m128    __cdecl _mm_maskz_fnmsub_round_ss(__mmask8, __m128, __m128, __m128, int);
extern __m128d   __cdecl _mm_mask_fnmsub_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_mask3_fnmsub_sd(__m128d, __m128d, __m128d, __mmask8);
extern __m128d   __cdecl _mm_maskz_fnmsub_sd(__mmask8, __m128d, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_fnmsub_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_mask3_fnmsub_ss(__m128, __m128, __m128, __mmask8);
extern __m128    __cdecl _mm_maskz_fnmsub_ss(__mmask8, __m128, __m128, __m128);
extern __mmask8  __cdecl _mm_fpclass_sd_mask(__m128d, int);
extern __mmask8  __cdecl _mm_mask_fpclass_sd_mask(__mmask8, __m128d, int);
extern __mmask8  __cdecl _mm_fpclass_ss_mask(__m128, int);
extern __mmask8  __cdecl _mm_mask_fpclass_ss_mask(__mmask8, __m128, int);
extern __m128d   __cdecl _mm_getexp_round_sd(__m128d, __m128d, const int);
extern __m128d   __cdecl _mm_mask_getexp_round_sd(__m128d, __mmask8, __m128d, __m128d, const int);
extern __m128d   __cdecl _mm_maskz_getexp_round_sd(__mmask8, __m128d, __m128d, const int);
extern __m128    __cdecl _mm_getexp_round_ss(__m128, __m128, const int);
extern __m128    __cdecl _mm_mask_getexp_round_ss(__m128, __mmask8, __m128, __m128, const int);
extern __m128    __cdecl _mm_maskz_getexp_round_ss(__mmask8, __m128, __m128, const int);
extern __m128d   __cdecl _mm_getexp_sd(__m128d, __m128d);
extern __m128d   __cdecl _mm_mask_getexp_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_getexp_sd(__mmask8, __m128d, __m128d);
extern __m128    __cdecl _mm_getexp_ss(__m128, __m128);
extern __m128    __cdecl _mm_mask_getexp_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_getexp_ss(__mmask8, __m128, __m128);
extern __m128d   __cdecl _mm_getmant_round_sd(__m128d, __m128d, int, int, int);
extern __m128d   __cdecl _mm_mask_getmant_round_sd(__m128d, __mmask8, __m128d, __m128d, int, int, int);
extern __m128d   __cdecl _mm_maskz_getmant_round_sd(__mmask8, __m128d, __m128d, int, int, int);
extern __m128    __cdecl _mm_getmant_round_ss(__m128, __m128, int, int, int);
extern __m128    __cdecl _mm_mask_getmant_round_ss(__m128, __mmask8, __m128, __m128, int, int, int);
extern __m128    __cdecl _mm_maskz_getmant_round_ss(__mmask8, __m128, __m128, int, int, int);
extern __m128d   __cdecl _mm_getmant_sd(__m128d, __m128d, int, int);
extern __m128d   __cdecl _mm_mask_getmant_sd(__m128d, __mmask8, __m128d, __m128d, int, int);
extern __m128d   __cdecl _mm_maskz_getmant_sd(__mmask8, __m128d, __m128d, int, int);
extern __m128    __cdecl _mm_getmant_ss(__m128, __m128, int, int);
extern __m128    __cdecl _mm_mask_getmant_ss(__m128, __mmask8, __m128, __m128, int, int);
extern __m128    __cdecl _mm_maskz_getmant_ss(__mmask8, __m128, __m128, int, int);
extern __m128d   __cdecl _mm_mask_load_sd(__m128d, __mmask8, const double*);
extern __m128d   __cdecl _mm_maskz_load_sd(__mmask8, const double*);
extern __m128    __cdecl _mm_mask_load_ss(__m128, __mmask8, const float*);
extern __m128    __cdecl _mm_maskz_load_ss(__mmask8, const float*);
extern __m128d   __cdecl _mm_mask_max_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_maskz_max_round_sd(__mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_max_round_sd(__m128d, __m128d, int);
extern __m128    __cdecl _mm_mask_max_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_maskz_max_round_ss(__mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_max_round_ss(__m128, __m128, int);
extern __m128d   __cdecl _mm_mask_max_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_max_sd(__mmask8, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_max_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_max_ss(__mmask8, __m128, __m128);
extern __m128d   __cdecl _mm_mask_min_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_maskz_min_round_sd(__mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_min_round_sd(__m128d, __m128d, int);
extern __m128    __cdecl _mm_mask_min_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_maskz_min_round_ss(__mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_min_round_ss(__m128, __m128, int);
extern __m128d   __cdecl _mm_mask_min_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_min_sd(__mmask8, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_min_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_min_ss(__mmask8, __m128, __m128);
extern __m128d   __cdecl _mm_mask_move_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_move_sd(__mmask8, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_move_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_move_ss(__mmask8, __m128, __m128);
extern __m128d   __cdecl _mm_mask_mul_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_maskz_mul_round_sd(__mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_mul_round_sd(__m128d, __m128d, int);
extern __m128    __cdecl _mm_mask_mul_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_maskz_mul_round_ss(__mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_mul_round_ss(__m128, __m128, int);
extern __m128d   __cdecl _mm_mask_mul_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_mul_sd(__mmask8, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_mul_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_mul_ss(__mmask8, __m128, __m128);
extern __m128d   __cdecl _mm_range_sd(__m128d, __m128d, const int);
extern __m128d   __cdecl _mm_mask_range_sd(__m128d, __mmask8, __m128d, __m128d, const int);
extern __m128d   __cdecl _mm_maskz_range_sd(__mmask8, __m128d, __m128d, const int);
extern __m128d   __cdecl _mm_range_round_sd(__m128d, __m128d, const int, int);
extern __m128d   __cdecl _mm_mask_range_round_sd(__m128d, __mmask8, __m128d, __m128d, const int, int);
extern __m128d   __cdecl _mm_maskz_range_round_sd(__mmask8, __m128d, __m128d, const int, int);
extern __m128    __cdecl _mm_range_ss(__m128, __m128, const int);
extern __m128    __cdecl _mm_mask_range_ss(__m128, __mmask8, __m128, __m128, const int);
extern __m128    __cdecl _mm_maskz_range_ss(__mmask8, __m128, __m128, const int);
extern __m128    __cdecl _mm_range_round_ss(__m128, __m128, const int, int);
extern __m128    __cdecl _mm_mask_range_round_ss(__m128, __mmask8, __m128, __m128, const int, int);
extern __m128    __cdecl _mm_maskz_range_round_ss(__mmask8, __m128, __m128, const int, int);
extern __m128d   __cdecl _mm_mask_rcp14_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_rcp14_sd(__mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_rcp14_sd(__m128d, __m128d);
extern __m128    __cdecl _mm_mask_rcp14_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_rcp14_ss(__mmask8, __m128, __m128);
extern __m128    __cdecl _mm_rcp14_ss(__m128, __m128);
extern __m128d   __cdecl _mm_mask_rcp28_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_maskz_rcp28_round_sd(__mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_rcp28_round_sd(__m128d, __m128d, int);
extern __m128    __cdecl _mm_mask_rcp28_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_maskz_rcp28_round_ss(__mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_rcp28_round_ss(__m128, __m128, int);
extern __m128d   __cdecl _mm_mask_rcp28_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_rcp28_sd(__mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_rcp28_sd(__m128d, __m128d);
extern __m128    __cdecl _mm_mask_rcp28_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_rcp28_ss(__mmask8, __m128, __m128);
extern __m128    __cdecl _mm_rcp28_ss(__m128, __m128);
extern __m128d   __cdecl _mm_mask_reduce_round_sd(__m128d, __mmask8, __m128d, __m128d, const int, int);
extern __m128d   __cdecl _mm_maskz_reduce_round_sd(__mmask8, __m128d, __m128d, const int, int);
extern __m128d   __cdecl _mm_reduce_round_sd(__m128d, __m128d, const int, int);
extern __m128    __cdecl _mm_mask_reduce_round_ss(__m128, __mmask8, __m128, __m128, const int, int);
extern __m128    __cdecl _mm_maskz_reduce_round_ss(__mmask8, __m128, __m128, const int, int);
extern __m128    __cdecl _mm_reduce_round_ss(__m128, __m128, const int, int);
extern __m128d   __cdecl _mm_mask_reduce_sd(__m128d, __mmask8, __m128d, __m128d, const int);
extern __m128d   __cdecl _mm_maskz_reduce_sd(__mmask8, __m128d, __m128d, const int);
extern __m128d   __cdecl _mm_reduce_sd(__m128d, __m128d, const int);
extern __m128    __cdecl _mm_mask_reduce_ss(__m128, __mmask8, __m128, __m128, const int);
extern __m128    __cdecl _mm_maskz_reduce_ss(__mmask8, __m128, __m128, const int);
extern __m128    __cdecl _mm_reduce_ss(__m128, __m128, const int);
extern __m128d   __cdecl _mm_mask_roundscale_round_sd(__m128d, __mmask8, __m128d, __m128d, const int, const int);
extern __m128d   __cdecl _mm_maskz_roundscale_round_sd(__mmask8, __m128d, __m128d, const int, const int);
extern __m128d   __cdecl _mm_roundscale_round_sd(__m128d, __m128d, const int, const int);
extern __m128    __cdecl _mm_mask_roundscale_round_ss(__m128, __mmask8, __m128, __m128, const int, const int);
extern __m128    __cdecl _mm_maskz_roundscale_round_ss(__mmask8, __m128, __m128, const int, const int);
extern __m128    __cdecl _mm_roundscale_round_ss(__m128, __m128, const int, const int);
extern __m128d   __cdecl _mm_mask_roundscale_sd(__m128d, __mmask8, __m128d, __m128d, const int);
extern __m128d   __cdecl _mm_maskz_roundscale_sd(__mmask8, __m128d, __m128d, const int);
extern __m128d   __cdecl _mm_roundscale_sd(__m128d, __m128d, const int);
extern __m128    __cdecl _mm_mask_roundscale_ss(__m128, __mmask8, __m128, __m128, const int);
extern __m128    __cdecl _mm_maskz_roundscale_ss(__mmask8, __m128, __m128, const int);
extern __m128    __cdecl _mm_roundscale_ss(__m128, __m128, const int);
extern __m128d   __cdecl _mm_mask_rsqrt14_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_rsqrt14_sd(__mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_rsqrt14_sd(__m128d, __m128d);
extern __m128    __cdecl _mm_mask_rsqrt14_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_rsqrt14_ss(__mmask8, __m128, __m128);
extern __m128    __cdecl _mm_rsqrt14_ss(__m128, __m128);
extern __m128d   __cdecl _mm_mask_rsqrt28_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_maskz_rsqrt28_round_sd(__mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_rsqrt28_round_sd(__m128d, __m128d, int);
extern __m128    __cdecl _mm_mask_rsqrt28_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_maskz_rsqrt28_round_ss(__mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_rsqrt28_round_ss(__m128, __m128, int);
extern __m128d   __cdecl _mm_mask_rsqrt28_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_rsqrt28_sd(__mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_rsqrt28_sd(__m128d, __m128d);
extern __m128    __cdecl _mm_mask_rsqrt28_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_rsqrt28_ss(__mmask8, __m128, __m128);
extern __m128    __cdecl _mm_rsqrt28_ss(__m128, __m128);
extern __m128d   __cdecl _mm_mask_scalef_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_maskz_scalef_round_sd(__mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_scalef_round_sd(__m128d, __m128d, int);
extern __m128    __cdecl _mm_mask_scalef_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_maskz_scalef_round_ss(__mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_scalef_round_ss(__m128, __m128, int);
extern __m128d   __cdecl _mm_mask_scalef_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_scalef_sd(__mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_scalef_sd(__m128d, __m128d);
extern __m128    __cdecl _mm_mask_scalef_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_scalef_ss(__mmask8, __m128, __m128);
extern __m128    __cdecl _mm_scalef_ss(__m128, __m128);
extern __m128d   __cdecl _mm_mask_sqrt_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_maskz_sqrt_round_sd(__mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_sqrt_round_sd(__m128d, __m128d, int);
extern __m128    __cdecl _mm_mask_sqrt_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_maskz_sqrt_round_ss(__mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_sqrt_round_ss(__m128, __m128, int);
extern __m128d   __cdecl _mm_mask_sqrt_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_sqrt_sd(__mmask8, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_sqrt_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_sqrt_ss(__mmask8, __m128, __m128);
extern void      __cdecl _mm_mask_store_sd(double*, __mmask8, __m128d);
extern void      __cdecl _mm_mask_store_ss(float*, __mmask8, __m128);
extern __m128d   __cdecl _mm_mask_sub_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_maskz_sub_round_sd(__mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_sub_round_sd(__m128d, __m128d, int);
extern __m128    __cdecl _mm_mask_sub_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_maskz_sub_round_ss(__mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_sub_round_ss(__m128, __m128, int);
extern __m128d   __cdecl _mm_mask_sub_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_sub_sd(__mmask8, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_sub_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_sub_ss(__mmask8, __m128, __m128);



extern unsigned __int64 __cdecl _mm_cvtsd_u64(__m128d);
extern unsigned __int64 __cdecl _mm_cvtss_u64(__m128);
extern unsigned __int64 __cdecl _mm_cvttsd_u64(__m128d);
extern unsigned __int64 __cdecl _mm_cvttss_u64(__m128);
extern unsigned __int64 __cdecl _mm_cvt_roundsd_u64(__m128d, int);
extern unsigned __int64 __cdecl _mm_cvt_roundss_u64(__m128, int);
extern unsigned __int64 __cdecl _mm_cvtt_roundsd_u64(__m128d, int);
extern unsigned __int64 __cdecl _mm_cvtt_roundss_u64(__m128, int);

extern __m128d   __cdecl _mm_cvti64_sd(__m128d, __int64);
extern __m128    __cdecl _mm_cvti64_ss(__m128, __int64);
extern __int64   __cdecl _mm_cvtsd_i64(__m128d);
extern __int64   __cdecl _mm_cvtss_i64(__m128);
extern __int64   __cdecl _mm_cvttsd_i64(__m128d);
extern __int64   __cdecl _mm_cvttss_i64(__m128);
extern __int64   __cdecl _mm_cvtt_roundsd_i64(__m128d, int);
extern __int64   __cdecl _mm_cvtt_roundsd_si64(__m128d, int);
extern __int64   __cdecl _mm_cvtt_roundss_i64(__m128, int);
extern __int64   __cdecl _mm_cvtt_roundss_si64(__m128, int);
extern __m128d   __cdecl _mm_cvtu64_sd(__m128d, unsigned __int64);
extern __m128    __cdecl _mm_cvtu64_ss(__m128, unsigned __int64);
extern __m128d   __cdecl _mm_cvt_roundi64_sd(__m128d, __int64, int);
extern __m128    __cdecl _mm_cvt_roundi64_ss(__m128, __int64, int);
extern __int64   __cdecl _mm_cvt_roundsd_i64(__m128d, int);
extern __int64   __cdecl _mm_cvt_roundsd_si64(__m128d, int);
extern __m128d   __cdecl _mm_cvt_roundsi64_sd(__m128d, __int64, int);
extern __m128    __cdecl _mm_cvt_roundsi64_ss(__m128, __int64, int);
extern __int64   __cdecl _mm_cvt_roundss_i64(__m128, int);
extern __int64   __cdecl _mm_cvt_roundss_si64(__m128, int);
extern __m128d   __cdecl _mm_cvt_roundu64_sd(__m128d, unsigned __int64, int);
extern __m128    __cdecl _mm_cvt_roundu64_ss(__m128, unsigned __int64, int);

#line 4344 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\zmmintrin.h"


extern __m512d   __cdecl _mm512_zextpd128_pd512(__m128d);
extern __m512d   __cdecl _mm512_zextpd256_pd512(__m256d);
extern __m512    __cdecl _mm512_zextps128_ps512(__m128);
extern __m512    __cdecl _mm512_zextps256_ps512(__m256);
extern __m512i   __cdecl _mm512_zextsi128_si512(__m128i);
extern __m512i   __cdecl _mm512_zextsi256_si512(__m256i);



























#line 4380 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\zmmintrin.h"


extern __m128i __cdecl _mm_madd52hi_epu64(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_madd52hi_epu64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_madd52hi_epu64(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_madd52hi_epu64(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_madd52hi_epu64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_madd52hi_epu64(__mmask8, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_madd52hi_epu64(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_madd52hi_epu64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_madd52hi_epu64(__mmask8, __m512i, __m512i, __m512i);

extern __m128i __cdecl _mm_madd52lo_epu64(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_madd52lo_epu64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_madd52lo_epu64(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_madd52lo_epu64(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_madd52lo_epu64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_madd52lo_epu64(__mmask8, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_madd52lo_epu64(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_madd52lo_epu64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_madd52lo_epu64(__mmask8, __m512i, __m512i, __m512i);


extern __m128i __cdecl _mm_permutexvar_epi8(__m128i, __m128i);
extern __m128i __cdecl _mm_mask_permutexvar_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_permutexvar_epi8(__mmask16, __m128i, __m128i);
extern __m256i __cdecl _mm256_permutexvar_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_mask_permutexvar_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_permutexvar_epi8(__mmask32, __m256i, __m256i);
extern __m512i __cdecl _mm512_permutexvar_epi8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_permutexvar_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_permutexvar_epi8(__mmask64, __m512i, __m512i);

extern __m128i __cdecl _mm_permutex2var_epi8(__m128i, __m128i  , __m128i);
extern __m128i __cdecl _mm_mask_permutex2var_epi8(__m128i, __mmask16, __m128i  , __m128i);
extern __m128i __cdecl _mm_mask2_permutex2var_epi8(__m128i, __m128i  , __mmask16, __m128i);
extern __m128i __cdecl _mm_maskz_permutex2var_epi8(__mmask16, __m128i, __m128i  , __m128i);
extern __m256i __cdecl _mm256_permutex2var_epi8(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_permutex2var_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask2_permutex2var_epi8(__m256i, __m256i, __mmask32, __m256i);
extern __m256i __cdecl _mm256_maskz_permutex2var_epi8(__mmask32, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_permutex2var_epi8(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_permutex2var_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask2_permutex2var_epi8(__m512i, __m512i, __mmask64, __m512i);
extern __m512i __cdecl _mm512_maskz_permutex2var_epi8(__mmask64, __m512i, __m512i, __m512i);

extern __m128i __cdecl _mm_multishift_epi64_epi8(__m128i, __m128i);
extern __m128i __cdecl _mm_mask_multishift_epi64_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_multishift_epi64_epi8(__mmask16, __m128i, __m128i);
extern __m256i __cdecl _mm256_multishift_epi64_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_mask_multishift_epi64_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_multishift_epi64_epi8(__mmask32, __m256i, __m256i);
extern __m512i __cdecl _mm512_multishift_epi64_epi8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_multishift_epi64_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_multishift_epi64_epi8(__mmask64, __m512i, __m512i);


extern __m128i __cdecl _mm_dpbusd_epi32(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_dpbusd_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_dpbusd_epi32(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_dpbusd_epi32(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_dpbusd_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_dpbusd_epi32(__mmask8, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_dpbusd_epi32(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_dpbusd_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_dpbusd_epi32(__mmask16, __m512i, __m512i, __m512i);

extern __m128i __cdecl _mm_dpbusds_epi32(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_dpbusds_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_dpbusds_epi32(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_dpbusds_epi32(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_dpbusds_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_dpbusds_epi32(__mmask8, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_dpbusds_epi32(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_dpbusds_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_dpbusds_epi32(__mmask16, __m512i, __m512i, __m512i);

extern __m128i __cdecl _mm_dpwssd_epi32(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_dpwssd_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_dpwssd_epi32(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_dpwssd_epi32(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_dpwssd_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_dpwssd_epi32(__mmask8, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_dpwssd_epi32(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_dpwssd_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_dpwssd_epi32(__mmask16, __m512i, __m512i, __m512i);

extern __m128i __cdecl _mm_dpwssds_epi32(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_dpwssds_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_dpwssds_epi32(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_dpwssds_epi32(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_dpwssds_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_dpwssds_epi32(__mmask8, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_dpwssds_epi32(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_dpwssds_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_dpwssds_epi32(__mmask16, __m512i, __m512i, __m512i);


extern __m256i __cdecl _mm256_aesenc_epi128(__m256i, __m256i);
extern __m512i __cdecl _mm512_aesenc_epi128(__m512i, __m512i);
extern __m256i __cdecl _mm256_aesenclast_epi128(__m256i, __m256i);
extern __m512i __cdecl _mm512_aesenclast_epi128(__m512i, __m512i);
extern __m256i __cdecl _mm256_aesdec_epi128(__m256i, __m256i);
extern __m512i __cdecl _mm512_aesdec_epi128(__m512i, __m512i);
extern __m256i __cdecl _mm256_aesdeclast_epi128(__m256i, __m256i);
extern __m512i __cdecl _mm512_aesdeclast_epi128(__m512i, __m512i);


extern __m256i __cdecl _mm256_clmulepi64_epi128(__m256i, __m256i, const int);
extern __m512i __cdecl _mm512_clmulepi64_epi128(__m512i, __m512i, const int);


extern __m128i __cdecl _mm_popcnt_epi32(__m128i);
extern __m128i __cdecl _mm_mask_popcnt_epi32(__m128i, __mmask8, __m128i);
extern __m128i __cdecl _mm_maskz_popcnt_epi32(__mmask8, __m128i);
extern __m256i __cdecl _mm256_popcnt_epi32(__m256i);
extern __m256i __cdecl _mm256_mask_popcnt_epi32(__m256i, __mmask8, __m256i);
extern __m256i __cdecl _mm256_maskz_popcnt_epi32(__mmask8, __m256i);
extern __m512i __cdecl _mm512_popcnt_epi32(__m512i);
extern __m512i __cdecl _mm512_mask_popcnt_epi32(__m512i, __mmask16, __m512i);
extern __m512i __cdecl _mm512_maskz_popcnt_epi32(__mmask16, __m512i);

extern __m128i __cdecl _mm_popcnt_epi64(__m128i);
extern __m128i __cdecl _mm_mask_popcnt_epi64(__m128i, __mmask8, __m128i);
extern __m128i __cdecl _mm_maskz_popcnt_epi64(__mmask8, __m128i);
extern __m256i __cdecl _mm256_popcnt_epi64(__m256i);
extern __m256i __cdecl _mm256_mask_popcnt_epi64(__m256i, __mmask8, __m256i);
extern __m256i __cdecl _mm256_maskz_popcnt_epi64(__mmask8, __m256i);
extern __m512i __cdecl _mm512_popcnt_epi64(__m512i);
extern __m512i __cdecl _mm512_mask_popcnt_epi64(__m512i, __mmask8, __m512i);
extern __m512i __cdecl _mm512_maskz_popcnt_epi64(__mmask8, __m512i);


extern __m128i __cdecl _mm_popcnt_epi8(__m128i);
extern __m128i __cdecl _mm_mask_popcnt_epi8(__m128i, __mmask16, __m128i);
extern __m128i __cdecl _mm_maskz_popcnt_epi8(__mmask16, __m128i);
extern __m256i __cdecl _mm256_popcnt_epi8(__m256i);
extern __m256i __cdecl _mm256_mask_popcnt_epi8(__m256i, __mmask32, __m256i);
extern __m256i __cdecl _mm256_maskz_popcnt_epi8(__mmask32, __m256i);
extern __m512i __cdecl _mm512_popcnt_epi8(__m512i);
extern __m512i __cdecl _mm512_mask_popcnt_epi8(__m512i, __mmask64, __m512i);
extern __m512i __cdecl _mm512_maskz_popcnt_epi8(__mmask64, __m512i);

extern __m128i __cdecl _mm_popcnt_epi16(__m128i);
extern __m128i __cdecl _mm_mask_popcnt_epi16(__m128i, __mmask8, __m128i);
extern __m128i __cdecl _mm_maskz_popcnt_epi16(__mmask8, __m128i);
extern __m256i __cdecl _mm256_popcnt_epi16(__m256i);
extern __m256i __cdecl _mm256_mask_popcnt_epi16(__m256i, __mmask16, __m256i);
extern __m256i __cdecl _mm256_maskz_popcnt_epi16(__mmask16, __m256i);
extern __m512i __cdecl _mm512_popcnt_epi16(__m512i);
extern __m512i __cdecl _mm512_mask_popcnt_epi16(__m512i, __mmask32, __m512i);
extern __m512i __cdecl _mm512_maskz_popcnt_epi16(__mmask32, __m512i);

extern __mmask16 __cdecl _mm_bitshuffle_epi64_mask(__m128i, __m128i);
extern __mmask16 __cdecl _mm_mask_bitshuffle_epi64_mask(__mmask16, __m128i, __m128i);
extern __mmask32 __cdecl _mm256_bitshuffle_epi64_mask(__m256i, __m256i);
extern __mmask32 __cdecl _mm256_mask_bitshuffle_epi64_mask(__mmask32, __m256i, __m256i);
extern __mmask64 __cdecl _mm512_bitshuffle_epi64_mask(__m512i, __m512i);
extern __mmask64 __cdecl _mm512_mask_bitshuffle_epi64_mask(__mmask64, __m512i, __m512i);


extern __m128i __cdecl _mm_gf2p8affineinv_epi64_epi8(__m128i, __m128i, int);
extern __m128i __cdecl _mm_mask_gf2p8affineinv_epi64_epi8(__m128i, __mmask16, __m128i, __m128i, int);
extern __m128i __cdecl _mm_maskz_gf2p8affineinv_epi64_epi8(__mmask16, __m128i, __m128i, int);
extern __m256i __cdecl _mm256_gf2p8affineinv_epi64_epi8(__m256i, __m256i, int);
extern __m256i __cdecl _mm256_mask_gf2p8affineinv_epi64_epi8(__m256i, __mmask32, __m256i, __m256i, int);
extern __m256i __cdecl _mm256_maskz_gf2p8affineinv_epi64_epi8(__mmask32, __m256i, __m256i, int);
extern __m512i __cdecl _mm512_gf2p8affineinv_epi64_epi8(__m512i, __m512i, int);
extern __m512i __cdecl _mm512_mask_gf2p8affineinv_epi64_epi8(__m512i, __mmask64, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_maskz_gf2p8affineinv_epi64_epi8(__mmask64, __m512i, __m512i, int);
extern __m128i __cdecl _mm_gf2p8affine_epi64_epi8(__m128i, __m128i, int);
extern __m128i __cdecl _mm_mask_gf2p8affine_epi64_epi8(__m128i, __mmask16, __m128i, __m128i, int);
extern __m128i __cdecl _mm_maskz_gf2p8affine_epi64_epi8(__mmask16, __m128i, __m128i, int);
extern __m256i __cdecl _mm256_gf2p8affine_epi64_epi8(__m256i, __m256i, int);
extern __m256i __cdecl _mm256_mask_gf2p8affine_epi64_epi8(__m256i, __mmask32, __m256i, __m256i, int);
extern __m256i __cdecl _mm256_maskz_gf2p8affine_epi64_epi8(__mmask32, __m256i, __m256i, int);
extern __m512i __cdecl _mm512_gf2p8affine_epi64_epi8(__m512i, __m512i, int);
extern __m512i __cdecl _mm512_mask_gf2p8affine_epi64_epi8(__m512i, __mmask64, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_maskz_gf2p8affine_epi64_epi8(__mmask64, __m512i, __m512i, int);
extern __m128i __cdecl _mm_gf2p8mul_epi8(__m128i, __m128i);
extern __m128i __cdecl _mm_mask_gf2p8mul_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_gf2p8mul_epi8(__mmask16, __m128i, __m128i);
extern __m256i __cdecl _mm256_gf2p8mul_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_mask_gf2p8mul_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_gf2p8mul_epi8(__mmask32, __m256i, __m256i);
extern __m512i __cdecl _mm512_gf2p8mul_epi8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_gf2p8mul_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_gf2p8mul_epi8(__mmask64, __m512i, __m512i);


extern __m128i __cdecl _mm_shldi_epi16(__m128i, __m128i, int);
extern __m128i __cdecl _mm_mask_shldi_epi16(__m128i, __mmask8, __m128i, __m128i, int);
extern __m128i __cdecl _mm_maskz_shldi_epi16(__mmask8, __m128i, __m128i, int);
extern __m256i __cdecl _mm256_shldi_epi16(__m256i, __m256i, int);
extern __m256i __cdecl _mm256_mask_shldi_epi16(__m256i, __mmask16, __m256i, __m256i, int);
extern __m256i __cdecl _mm256_maskz_shldi_epi16(__mmask16, __m256i, __m256i, int);
extern __m512i __cdecl _mm512_shldi_epi16(__m512i, __m512i, int);
extern __m512i __cdecl _mm512_mask_shldi_epi16(__m512i, __mmask32, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_maskz_shldi_epi16(__mmask32, __m512i, __m512i, int);
extern __m128i __cdecl _mm_shldi_epi32(__m128i, __m128i, int);
extern __m128i __cdecl _mm_mask_shldi_epi32(__m128i, __mmask8, __m128i, __m128i, int);
extern __m128i __cdecl _mm_maskz_shldi_epi32(__mmask8, __m128i, __m128i, int);
extern __m256i __cdecl _mm256_shldi_epi32(__m256i, __m256i, int);
extern __m256i __cdecl _mm256_mask_shldi_epi32(__m256i, __mmask8, __m256i, __m256i, int);
extern __m256i __cdecl _mm256_maskz_shldi_epi32(__mmask8, __m256i, __m256i, int);
extern __m512i __cdecl _mm512_shldi_epi32(__m512i, __m512i, int);
extern __m512i __cdecl _mm512_mask_shldi_epi32(__m512i, __mmask16, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_maskz_shldi_epi32(__mmask16, __m512i, __m512i, int);
extern __m128i __cdecl _mm_shldi_epi64(__m128i, __m128i, int);
extern __m128i __cdecl _mm_mask_shldi_epi64(__m128i, __mmask8, __m128i, __m128i, int);
extern __m128i __cdecl _mm_maskz_shldi_epi64(__mmask8, __m128i, __m128i, int);
extern __m256i __cdecl _mm256_shldi_epi64(__m256i, __m256i, int);
extern __m256i __cdecl _mm256_mask_shldi_epi64(__m256i, __mmask8, __m256i, __m256i, int);
extern __m256i __cdecl _mm256_maskz_shldi_epi64(__mmask8, __m256i, __m256i, int);
extern __m512i __cdecl _mm512_shldi_epi64(__m512i, __m512i, int);
extern __m512i __cdecl _mm512_mask_shldi_epi64(__m512i, __mmask8, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_maskz_shldi_epi64(__mmask8, __m512i, __m512i, int);
extern __m128i __cdecl _mm_shldv_epi16(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_shldv_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_shldv_epi16(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_shldv_epi16(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_shldv_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_shldv_epi16(__mmask16, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_shldv_epi16(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_shldv_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_shldv_epi16(__mmask32, __m512i, __m512i, __m512i);
extern __m128i __cdecl _mm_shldv_epi32(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_shldv_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_shldv_epi32(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_shldv_epi32(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_shldv_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_shldv_epi32(__mmask8, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_shldv_epi32(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_shldv_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_shldv_epi32(__mmask16, __m512i, __m512i, __m512i);
extern __m128i __cdecl _mm_shldv_epi64(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_shldv_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_shldv_epi64(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_shldv_epi64(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_shldv_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_shldv_epi64(__mmask8, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_shldv_epi64(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_shldv_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_shldv_epi64(__mmask8, __m512i, __m512i, __m512i);


extern __m128i __cdecl _mm_shrdi_epi16(__m128i, __m128i, int);
extern __m128i __cdecl _mm_mask_shrdi_epi16(__m128i, __mmask8, __m128i, __m128i, int);
extern __m128i __cdecl _mm_maskz_shrdi_epi16(__mmask8, __m128i, __m128i, int);
extern __m256i __cdecl _mm256_shrdi_epi16(__m256i, __m256i, int);
extern __m256i __cdecl _mm256_mask_shrdi_epi16(__m256i, __mmask16, __m256i, __m256i, int);
extern __m256i __cdecl _mm256_maskz_shrdi_epi16(__mmask16, __m256i, __m256i, int);
extern __m512i __cdecl _mm512_shrdi_epi16(__m512i, __m512i, int);
extern __m512i __cdecl _mm512_mask_shrdi_epi16(__m512i, __mmask32, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_maskz_shrdi_epi16(__mmask32, __m512i, __m512i, int);
extern __m128i __cdecl _mm_shrdi_epi32(__m128i, __m128i, int);
extern __m128i __cdecl _mm_mask_shrdi_epi32(__m128i, __mmask8, __m128i, __m128i, int);
extern __m128i __cdecl _mm_maskz_shrdi_epi32(__mmask8, __m128i, __m128i, int);
extern __m256i __cdecl _mm256_shrdi_epi32(__m256i, __m256i, int);
extern __m256i __cdecl _mm256_mask_shrdi_epi32(__m256i, __mmask8, __m256i, __m256i, int);
extern __m256i __cdecl _mm256_maskz_shrdi_epi32(__mmask8, __m256i, __m256i, int);
extern __m512i __cdecl _mm512_shrdi_epi32(__m512i, __m512i, int);
extern __m512i __cdecl _mm512_mask_shrdi_epi32(__m512i, __mmask16, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_maskz_shrdi_epi32(__mmask16, __m512i, __m512i, int);
extern __m128i __cdecl _mm_shrdi_epi64(__m128i, __m128i, int);
extern __m128i __cdecl _mm_mask_shrdi_epi64(__m128i, __mmask8, __m128i, __m128i, int);
extern __m128i __cdecl _mm_maskz_shrdi_epi64(__mmask8, __m128i, __m128i, int);
extern __m256i __cdecl _mm256_shrdi_epi64(__m256i, __m256i, int);
extern __m256i __cdecl _mm256_mask_shrdi_epi64(__m256i, __mmask8, __m256i, __m256i, int);
extern __m256i __cdecl _mm256_maskz_shrdi_epi64(__mmask8, __m256i, __m256i, int);
extern __m512i __cdecl _mm512_shrdi_epi64(__m512i, __m512i, int);
extern __m512i __cdecl _mm512_mask_shrdi_epi64(__m512i, __mmask8, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_maskz_shrdi_epi64(__mmask8, __m512i, __m512i, int);
extern __m128i __cdecl _mm_shrdv_epi16(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_shrdv_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_shrdv_epi16(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_shrdv_epi16(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_shrdv_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_shrdv_epi16(__mmask16, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_shrdv_epi16(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_shrdv_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_shrdv_epi16(__mmask32, __m512i, __m512i, __m512i);
extern __m128i __cdecl _mm_shrdv_epi32(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_shrdv_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_shrdv_epi32(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_shrdv_epi32(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_shrdv_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_shrdv_epi32(__mmask8, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_shrdv_epi32(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_shrdv_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_shrdv_epi32(__mmask16, __m512i, __m512i, __m512i);
extern __m128i __cdecl _mm_shrdv_epi64(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_shrdv_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_shrdv_epi64(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_shrdv_epi64(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_shrdv_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_shrdv_epi64(__mmask8, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_shrdv_epi64(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_shrdv_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_shrdv_epi64(__mmask8, __m512i, __m512i, __m512i);






extern __m512i _mm512_div_epi8(__m512i, __m512i);
extern __m512i _mm512_div_epi16(__m512i, __m512i);
extern __m512i _mm512_div_epi32(__m512i, __m512i);
extern __m512i _mm512_div_epi64(__m512i, __m512i);
extern __m512i _mm512_div_epu8(__m512i, __m512i);
extern __m512i _mm512_div_epu16(__m512i, __m512i);
extern __m512i _mm512_div_epu32(__m512i, __m512i);
extern __m512i _mm512_div_epu64(__m512i, __m512i);
extern __m512i _mm512_mask_div_epi32(__m512i  , __mmask16, __m512i, __m512i);
extern __m512i _mm512_mask_div_epu32(__m512i  , __mmask16, __m512i, __m512i);
extern __m512i _mm512_rem_epi8(__m512i, __m512i);
extern __m512i _mm512_rem_epi16(__m512i, __m512i);
extern __m512i _mm512_rem_epi32(__m512i, __m512i);
extern __m512i _mm512_rem_epi64(__m512i, __m512i);
extern __m512i _mm512_rem_epu8(__m512i, __m512i);
extern __m512i _mm512_rem_epu16(__m512i, __m512i);
extern __m512i _mm512_rem_epu32(__m512i, __m512i);
extern __m512i _mm512_rem_epu64(__m512i, __m512i);
extern __m512i _mm512_mask_rem_epi32(__m512i  , __mmask16, __m512i, __m512i);
extern __m512i _mm512_mask_rem_epu32(__m512i  , __mmask16, __m512i, __m512i);


extern __m512  _mm512_sin_ps(__m512);
extern __m512  _mm512_mask_sin_ps(__m512   , __mmask16, __m512);
extern __m512d _mm512_sin_pd(__m512d);
extern __m512d _mm512_mask_sin_pd(__m512d  , __mmask8, __m512d);
extern __m512  _mm512_cos_ps(__m512);
extern __m512  _mm512_mask_cos_ps(__m512   , __mmask16, __m512);
extern __m512d _mm512_cos_pd(__m512d);
extern __m512d _mm512_mask_cos_pd(__m512d  , __mmask8, __m512d);
extern __m512  _mm512_sincos_ps(__m512  *  , __m512);
extern __m512  _mm512_mask_sincos_ps(__m512  *  , __m512   , __m512   , __mmask16, __m512);
extern __m512d _mm512_sincos_pd(__m512d *  , __m512d);
extern __m512d _mm512_mask_sincos_pd(__m512d *  , __m512d  , __m512d  , __mmask8, __m512d);
extern __m512  _mm512_tan_ps(__m512);
extern __m512  _mm512_mask_tan_ps(__m512   , __mmask16, __m512);
extern __m512d _mm512_tan_pd(__m512d);
extern __m512d _mm512_mask_tan_pd(__m512d  , __mmask8, __m512d);
extern __m512  _mm512_asin_ps(__m512);
extern __m512  _mm512_mask_asin_ps(__m512   , __mmask16, __m512);
extern __m512d _mm512_asin_pd(__m512d);
extern __m512d _mm512_mask_asin_pd(__m512d  , __mmask8, __m512d);
extern __m512  _mm512_acos_ps(__m512);
extern __m512  _mm512_mask_acos_ps(__m512   , __mmask16, __m512);
extern __m512d _mm512_acos_pd(__m512d);
extern __m512d _mm512_mask_acos_pd(__m512d  , __mmask8, __m512d);
extern __m512  _mm512_atan_ps(__m512);
extern __m512  _mm512_mask_atan_ps(__m512   , __mmask16, __m512);
extern __m512d _mm512_atan_pd(__m512d);
extern __m512d _mm512_mask_atan_pd(__m512d  , __mmask8, __m512d);
extern __m512  _mm512_atan2_ps(__m512, __m512);
extern __m512  _mm512_mask_atan2_ps(__m512   , __mmask16, __m512, __m512);
extern __m512d _mm512_atan2_pd(__m512d, __m512d);
extern __m512d _mm512_mask_atan2_pd(__m512d  , __mmask8, __m512d, __m512d);
extern __m512  _mm512_sind_ps(__m512);
extern __m512  _mm512_mask_sind_ps(__m512   , __mmask16, __m512);
extern __m512d _mm512_sind_pd(__m512d);
extern __m512d _mm512_mask_sind_pd(__m512d  , __mmask8, __m512d);
extern __m512  _mm512_cosd_ps(__m512);
extern __m512  _mm512_mask_cosd_ps(__m512   , __mmask16, __m512);
extern __m512d _mm512_cosd_pd(__m512d);
extern __m512d _mm512_mask_cosd_pd(__m512d  , __mmask8, __m512d);
extern __m512  _mm512_tand_ps(__m512);
extern __m512  _mm512_mask_tand_ps(__m512   , __mmask16, __m512);
extern __m512d _mm512_tand_pd(__m512d);
extern __m512d _mm512_mask_tand_pd(__m512d  , __mmask8, __m512d);
extern __m512  _mm512_sinh_ps(__m512);
extern __m512  _mm512_mask_sinh_ps(__m512   , __mmask16, __m512);
extern __m512d _mm512_sinh_pd(__m512d);
extern __m512d _mm512_mask_sinh_pd(__m512d  , __mmask8, __m512d);
extern __m512  _mm512_cosh_ps(__m512);
extern __m512  _mm512_mask_cosh_ps(__m512   , __mmask16, __m512);
extern __m512d _mm512_cosh_pd(__m512d);
extern __m512d _mm512_mask_cosh_pd(__m512d  , __mmask8, __m512d);
extern __m512  _mm512_tanh_ps(__m512);
extern __m512  _mm512_mask_tanh_ps(__m512   , __mmask16, __m512);
extern __m512d _mm512_tanh_pd(__m512d);
extern __m512d _mm512_mask_tanh_pd(__m512d  , __mmask8, __m512d);
extern __m512  _mm512_asinh_ps(__m512);
extern __m512  _mm512_mask_asinh_ps(__m512   , __mmask16, __m512);
extern __m512d _mm512_asinh_pd(__m512d);
extern __m512d _mm512_mask_asinh_pd(__m512d  , __mmask8, __m512d);
extern __m512  _mm512_acosh_ps(__m512);
extern __m512  _mm512_mask_acosh_ps(__m512   , __mmask16, __m512);
extern __m512d _mm512_acosh_pd(__m512d);
extern __m512d _mm512_mask_acosh_pd(__m512d  , __mmask8, __m512d);
extern __m512  _mm512_atanh_ps(__m512);
extern __m512  _mm512_mask_atanh_ps(__m512   , __mmask16, __m512);
extern __m512d _mm512_atanh_pd(__m512d);
extern __m512d _mm512_mask_atanh_pd(__m512d  , __mmask8, __m512d);
extern __m512  _mm512_log_ps(__m512);
extern __m512  _mm512_mask_log_ps(__m512   , __mmask16, __m512);
extern __m512d _mm512_log_pd(__m512d);
extern __m512d _mm512_mask_log_pd(__m512d  , __mmask8, __m512d);
extern __m512  _mm512_log1p_ps(__m512);
extern __m512  _mm512_mask_log1p_ps(__m512   , __mmask16, __m512);
extern __m512d _mm512_log1p_pd(__m512d);
extern __m512d _mm512_mask_log1p_pd(__m512d  , __mmask8, __m512d);
extern __m512  _mm512_log10_ps(__m512);
extern __m512  _mm512_mask_log10_ps(__m512   , __mmask16, __m512);
extern __m512d _mm512_log10_pd(__m512d);
extern __m512d _mm512_mask_log10_pd(__m512d  , __mmask8, __m512d);
extern __m512  _mm512_log2_ps(__m512);
extern __m512  _mm512_mask_log2_ps(__m512   , __mmask16, __m512);
extern __m512d _mm512_log2_pd(__m512d);
extern __m512d _mm512_mask_log2_pd(__m512d  , __mmask8, __m512d);
extern __m512  _mm512_logb_ps(__m512);
extern __m512  _mm512_mask_logb_ps(__m512   , __mmask16, __m512);
extern __m512d _mm512_logb_pd(__m512d);
extern __m512d _mm512_mask_logb_pd(__m512d  , __mmask8, __m512d);
extern __m512  _mm512_exp_ps(__m512);
extern __m512  _mm512_mask_exp_ps(__m512   , __mmask16, __m512);
extern __m512d _mm512_exp_pd(__m512d);
extern __m512d _mm512_mask_exp_pd(__m512d  , __mmask8, __m512d);
extern __m512  _mm512_exp10_ps(__m512);
extern __m512  _mm512_mask_exp10_ps(__m512   , __mmask16, __m512);
extern __m512d _mm512_exp10_pd(__m512d);
extern __m512d _mm512_mask_exp10_pd(__m512d  , __mmask8, __m512d);
extern __m512  _mm512_exp2_ps(__m512);
extern __m512  _mm512_mask_exp2_ps(__m512   , __mmask16, __m512);
extern __m512d _mm512_exp2_pd(__m512d);
extern __m512d _mm512_mask_exp2_pd(__m512d  , __mmask8, __m512d);
extern __m512  _mm512_expm1_ps(__m512);
extern __m512  _mm512_mask_expm1_ps(__m512   , __mmask16, __m512);
extern __m512d _mm512_expm1_pd(__m512d);
extern __m512d _mm512_mask_expm1_pd(__m512d  , __mmask8, __m512d);
extern __m512  _mm512_pow_ps(__m512, __m512);
extern __m512  _mm512_mask_pow_ps(__m512   , __mmask16, __m512, __m512);
extern __m512d _mm512_pow_pd(__m512d, __m512d);
extern __m512d _mm512_mask_pow_pd(__m512d  , __mmask8, __m512d, __m512d);
extern __m512  _mm512_trunc_ps(__m512);
extern __m512  _mm512_mask_trunc_ps(__m512   , __mmask16, __m512);
extern __m512d _mm512_trunc_pd(__m512d);
extern __m512d _mm512_mask_trunc_pd(__m512d  , __mmask8, __m512d);
extern __m512  _mm512_floor_ps(__m512);
extern __m512  _mm512_mask_floor_ps(__m512   , __mmask16, __m512);
extern __m512d _mm512_floor_pd(__m512d);
extern __m512d _mm512_mask_floor_pd(__m512d  , __mmask8, __m512d);
extern __m512  _mm512_ceil_ps(__m512);
extern __m512  _mm512_mask_ceil_ps(__m512   , __mmask16, __m512);
extern __m512d _mm512_ceil_pd(__m512d);
extern __m512d _mm512_mask_ceil_pd(__m512d  , __mmask8, __m512d);
extern __m512 _mm512_svml_round_ps(__m512);
extern __m512 _mm512_mask_svml_round_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_svml_round_pd(__m512d);
extern __m512d _mm512_mask_svml_round_pd(__m512d  , __mmask8, __m512d);
extern __m512  _mm512_fmod_ps(__m512, __m512);
extern __m512  _mm512_mask_fmod_ps(__m512   , __mmask16, __m512, __m512);
extern __m512d _mm512_fmod_pd(__m512d, __m512d);
extern __m512d _mm512_mask_fmod_pd(__m512d  , __mmask8, __m512d, __m512d);
extern __m512  _mm512_rint_ps(__m512);
extern __m512  _mm512_mask_rint_ps(__m512   , __mmask16, __m512);
extern __m512d _mm512_rint_pd(__m512d);
extern __m512d _mm512_mask_rint_pd(__m512d  , __mmask8, __m512d);






extern __m512  _mm512_invsqrt_ps(__m512);
extern __m512  _mm512_mask_invsqrt_ps(__m512   , __mmask16, __m512);
extern __m512d _mm512_invsqrt_pd(__m512d);
extern __m512d _mm512_mask_invsqrt_pd(__m512d  , __mmask8, __m512d);
extern __m512  _mm512_cbrt_ps(__m512);
extern __m512  _mm512_mask_cbrt_ps(__m512   , __mmask16, __m512);
extern __m512d _mm512_cbrt_pd(__m512d);
extern __m512d _mm512_mask_cbrt_pd(__m512d  , __mmask8, __m512d);
extern __m512  _mm512_invcbrt_ps(__m512);
extern __m512  _mm512_mask_invcbrt_ps(__m512   , __mmask16, __m512);
extern __m512d _mm512_invcbrt_pd(__m512d);
extern __m512d _mm512_mask_invcbrt_pd(__m512d  , __mmask8, __m512d);
extern __m512  _mm512_hypot_ps(__m512, __m512);
extern __m512  _mm512_mask_hypot_ps(__m512   , __mmask16, __m512, __m512);
extern __m512d _mm512_hypot_pd(__m512d, __m512d);
extern __m512d _mm512_mask_hypot_pd(__m512d  , __mmask8, __m512d, __m512d);
extern __m512  _mm512_cdfnorm_ps(__m512);
extern __m512  _mm512_mask_cdfnorm_ps(__m512   , __mmask16, __m512);
extern __m512d _mm512_cdfnorm_pd(__m512d);
extern __m512d _mm512_mask_cdfnorm_pd(__m512d  , __mmask8, __m512d);
extern __m512  _mm512_cdfnorminv_ps(__m512);
extern __m512  _mm512_mask_cdfnorminv_ps(__m512   , __mmask16, __m512);
extern __m512d _mm512_cdfnorminv_pd(__m512d);
extern __m512d _mm512_mask_cdfnorminv_pd(__m512d  , __mmask8, __m512d);
extern __m512  _mm512_erf_ps(__m512);
extern __m512  _mm512_mask_erf_ps(__m512   , __mmask16, __m512);
extern __m512d _mm512_erf_pd(__m512d);
extern __m512d _mm512_mask_erf_pd(__m512d  , __mmask8, __m512d);
extern __m512  _mm512_erfc_ps(__m512);
extern __m512  _mm512_mask_erfc_ps(__m512   , __mmask16, __m512);
extern __m512d _mm512_erfc_pd(__m512d);
extern __m512d _mm512_mask_erfc_pd(__m512d  , __mmask8, __m512d);
extern __m512  _mm512_erfcinv_ps(__m512);
extern __m512  _mm512_mask_erfcinv_ps(__m512   , __mmask16, __m512);
extern __m512d _mm512_erfcinv_pd(__m512d);
extern __m512d _mm512_mask_erfcinv_pd(__m512d  , __mmask8, __m512d);
extern __m512  _mm512_erfinv_ps(__m512);
extern __m512  _mm512_mask_erfinv_ps(__m512   , __mmask16, __m512);
extern __m512d _mm512_erfinv_pd(__m512d);
extern __m512d _mm512_mask_erfinv_pd(__m512d  , __mmask8, __m512d);
extern __m512  _mm512_nearbyint_ps(__m512);
extern __m512  _mm512_mask_nearbyint_ps(__m512   , __mmask16, __m512);
extern __m512d _mm512_nearbyint_pd(__m512d);
extern __m512d _mm512_mask_nearbyint_pd(__m512d  , __mmask8, __m512d);


typedef __m128i __m128bh;
typedef __m256i __m256bh;
typedef __m512i __m512bh;
typedef unsigned short __bfloat16;

extern __m128bh _mm_cvtneps_pbh(__m128);
extern __m128bh _mm_mask_cvtneps_pbh(__m128bh, __mmask8, __m128);
extern __m128bh _mm_maskz_cvtneps_pbh(__mmask8, __m128);
extern __m128bh _mm_cvtne2ps_pbh(__m128, __m128);
extern __m128bh _mm_mask_cvtne2ps_pbh(__m128bh, __mmask8, __m128, __m128);
extern __m128bh _mm_maskz_cvtne2ps_pbh(__mmask8, __m128, __m128);
extern __m128   _mm_dpbf16_ps(__m128, __m128bh, __m128bh);
extern __m128   _mm_mask_dpbf16_ps(__m128, __mmask8, __m128bh, __m128bh);
extern __m128   _mm_maskz_dpbf16_ps(__mmask8, __m128, __m128bh, __m128bh);
extern __m128bh _mm256_cvtneps_pbh(__m256);
extern __m128bh _mm256_mask_cvtneps_pbh(__m128bh, __mmask8, __m256);
extern __m128bh _mm256_maskz_cvtneps_pbh(__mmask8, __m256);
extern __m256bh _mm256_cvtne2ps_pbh(__m256, __m256);
extern __m256bh _mm256_mask_cvtne2ps_pbh(__m256bh, __mmask16, __m256, __m256);
extern __m256bh _mm256_maskz_cvtne2ps_pbh(__mmask16, __m256, __m256);
extern __m256   _mm256_dpbf16_ps(__m256, __m256bh, __m256bh);
extern __m256   _mm256_mask_dpbf16_ps(__m256, __mmask8, __m256bh, __m256bh);
extern __m256   _mm256_maskz_dpbf16_ps(__mmask8, __m256, __m256bh, __m256bh);
extern __m256bh _mm512_cvtneps_pbh(__m512);
extern __m256bh _mm512_mask_cvtneps_pbh(__m256bh, __mmask16, __m512);
extern __m256bh _mm512_maskz_cvtneps_pbh(__mmask16, __m512);
extern __m512bh _mm512_cvtne2ps_pbh(__m512, __m512);
extern __m512bh _mm512_mask_cvtne2ps_pbh(__m512bh, __mmask32, __m512, __m512);
extern __m512bh _mm512_maskz_cvtne2ps_pbh(__mmask32, __m512, __m512);
extern __m512   _mm512_dpbf16_ps(__m512, __m512bh, __m512bh);
extern __m512   _mm512_mask_dpbf16_ps(__m512, __mmask16, __m512bh, __m512bh);
extern __m512   _mm512_maskz_dpbf16_ps(__mmask16, __m512, __m512bh, __m512bh);
extern __bfloat16 _mm_cvtness_sbh(float);
extern float      _mm_cvtsbh_ss(__bfloat16);
extern __m128     _mm_cvtpbh_ps(__m128bh);
extern __m128     _mm_mask_cvtpbh_ps(__m128, __mmask8, __m128bh);
extern __m128     _mm_maskz_cvtpbh_ps(__mmask8, __m128bh);
extern __m256     _mm256_cvtpbh_ps(__m128bh);
extern __m256     _mm256_mask_cvtpbh_ps(__m256, __mmask8, __m128bh);
extern __m256     _mm256_maskz_cvtpbh_ps(__mmask8, __m128bh);
extern __m512     _mm512_cvtpbh_ps(__m256bh);
extern __m512     _mm512_mask_cvtpbh_ps(__m512, __mmask16, __m256bh);
extern __m512     _mm512_maskz_cvtpbh_ps(__mmask16, __m256bh);




















extern __mmask8  __cdecl _kadd_mask8(__mmask8, __mmask8);
extern __mmask16 __cdecl _kadd_mask16(__mmask16, __mmask16);
extern __mmask32 __cdecl _kadd_mask32(__mmask32, __mmask32);
extern __mmask64 __cdecl _kadd_mask64(__mmask64, __mmask64);
extern __mmask8  __cdecl _kand_mask8(__mmask8, __mmask8);
extern __mmask16 __cdecl _kand_mask16(__mmask16, __mmask16);
extern __mmask32 __cdecl _kand_mask32(__mmask32, __mmask32);
extern __mmask64 __cdecl _kand_mask64(__mmask64, __mmask64);
extern __mmask8  __cdecl _kandn_mask8(__mmask8, __mmask8);
extern __mmask16 __cdecl _kandn_mask16(__mmask16, __mmask16);
extern __mmask32 __cdecl _kandn_mask32(__mmask32, __mmask32);
extern __mmask64 __cdecl _kandn_mask64(__mmask64, __mmask64);
extern __mmask8  __cdecl _knot_mask8(__mmask8);
extern __mmask16 __cdecl _knot_mask16(__mmask16);
extern __mmask32 __cdecl _knot_mask32(__mmask32);
extern __mmask64 __cdecl _knot_mask64(__mmask64);
extern __mmask8  __cdecl _kor_mask8(__mmask8, __mmask8);
extern __mmask16 __cdecl _kor_mask16(__mmask16, __mmask16);
extern __mmask32 __cdecl _kor_mask32(__mmask32, __mmask32);
extern __mmask64 __cdecl _kor_mask64(__mmask64, __mmask64);
extern __mmask8  __cdecl _kxnor_mask8(__mmask8, __mmask8);
extern __mmask16 __cdecl _kxnor_mask16(__mmask16, __mmask16);
extern __mmask32 __cdecl _kxnor_mask32(__mmask32, __mmask32);
extern __mmask64 __cdecl _kxnor_mask64(__mmask64, __mmask64);
extern __mmask8  __cdecl _kxor_mask8(__mmask8, __mmask8);
extern __mmask16 __cdecl _kxor_mask16(__mmask16, __mmask16);
extern __mmask32 __cdecl _kxor_mask32(__mmask32, __mmask32);
extern __mmask64 __cdecl _kxor_mask64(__mmask64, __mmask64);
extern __mmask8  __cdecl _kshiftli_mask8(__mmask8, unsigned int);
extern __mmask16 __cdecl _kshiftli_mask16(__mmask16, unsigned int);
extern __mmask32 __cdecl _kshiftli_mask32(__mmask32, unsigned int);
extern __mmask64 __cdecl _kshiftli_mask64(__mmask64, unsigned int);
extern __mmask8  __cdecl _kshiftri_mask8(__mmask8, unsigned int);
extern __mmask16 __cdecl _kshiftri_mask16(__mmask16, unsigned int);
extern __mmask32 __cdecl _kshiftri_mask32(__mmask32, unsigned int);
extern __mmask64 __cdecl _kshiftri_mask64(__mmask64, unsigned int);
extern __mmask8  __cdecl _load_mask8(__mmask8 *);
extern __mmask16 __cdecl _load_mask16(__mmask16 *);
extern __mmask32 __cdecl _load_mask32(__mmask32 *);
extern __mmask64 __cdecl _load_mask64(__mmask64 *);
extern void      __cdecl _store_mask8(__mmask8 *, __mmask8);
extern void      __cdecl _store_mask16(__mmask16 *, __mmask16);
extern void      __cdecl _store_mask32(__mmask32 *, __mmask32);
extern void      __cdecl _store_mask64(__mmask64 *, __mmask64);
extern unsigned int     __cdecl _cvtmask8_u32(__mmask8);
extern unsigned int     __cdecl _cvtmask16_u32(__mmask16);
extern unsigned int     __cdecl _cvtmask32_u32(__mmask32);
extern unsigned __int64 __cdecl _cvtmask64_u64(__mmask64);
extern __mmask8         __cdecl _cvtu32_mask8(unsigned int);
extern __mmask16        __cdecl _cvtu32_mask16(unsigned int);
extern __mmask32        __cdecl _cvtu32_mask32(unsigned int);
extern __mmask64        __cdecl _cvtu64_mask64(unsigned __int64);
extern __mmask16        __cdecl _mm512_kmov(__mmask16);
extern unsigned char __cdecl _kortest_mask8_u8(__mmask8, __mmask8, unsigned char *);
extern unsigned char __cdecl _kortest_mask16_u8(__mmask16, __mmask16, unsigned char *);
extern unsigned char __cdecl _kortest_mask32_u8(__mmask32, __mmask32, unsigned char *);
extern unsigned char __cdecl _kortest_mask64_u8(__mmask64, __mmask64, unsigned char *);
extern unsigned char __cdecl _ktest_mask8_u8(__mmask8, __mmask8, unsigned char *);
extern unsigned char __cdecl _ktest_mask16_u8(__mmask16, __mmask16, unsigned char *);
extern unsigned char __cdecl _ktest_mask32_u8(__mmask32, __mmask32, unsigned char *);
extern unsigned char __cdecl _ktest_mask64_u8(__mmask64, __mmask64, unsigned char *);





































extern __m512  __cdecl _mm512_mask_exp2a23_round_ps(__m512, __mmask16, __m512, int);
extern __m512  __cdecl _mm512_maskz_exp2a23_round_ps(__mmask16, __m512, int);
extern __m512d __cdecl _mm512_mask_exp2a23_round_pd(__m512d, __mmask8, __m512d, int);
extern __m512d __cdecl _mm512_maskz_exp2a23_round_pd(__mmask8, __m512d, int);


















extern __m512  __cdecl _mm512_mask_rcp28_round_ps(__m512, __mmask16, __m512, const int);
extern __m512  __cdecl _mm512_maskz_rcp28_round_ps(__mmask16, __m512, const int);
extern __m512d __cdecl _mm512_mask_rcp28_round_pd(__m512d, __mmask8, __m512d, const int);
extern __m512d __cdecl _mm512_maskz_rcp28_round_pd(__mmask8, __m512d, const int);


















extern __m512  __cdecl _mm512_mask_rsqrt28_round_ps(__m512, __mmask16, __m512, const int);
extern __m512  __cdecl _mm512_maskz_rsqrt28_round_ps(__mmask16, __m512, const int);
extern __m512d __cdecl _mm512_mask_rsqrt28_round_pd(__m512d, __mmask8, __m512d, const int);
extern __m512d __cdecl _mm512_maskz_rsqrt28_round_pd(__mmask8, __m512d, const int);


















extern void __cdecl _mm512_prefetch_i32gather_pd(__m256i vindex, void const* base_addr, int scale, const int hint);
extern void __cdecl _mm512_prefetch_i32gather_ps(__m512i index, void const* mv, int scale, const int hint);
extern void __cdecl _mm512_prefetch_i32scatter_pd(void* base_addr, __m256i vindex, int scale, const int hint);
extern void __cdecl _mm512_prefetch_i32scatter_ps(void* mv, __m512i index, int scale, const int hint);
extern void __cdecl _mm512_prefetch_i64gather_pd(__m512i vindex, void const* base_addr, int scale, const int hint);
extern void __cdecl _mm512_prefetch_i64gather_ps(__m512i vindex, void const* base_addr, int scale, const int hint);
extern void __cdecl _mm512_prefetch_i64scatter_pd(void* base_addr, __m512i vindex, int scale, const int hint);
extern void __cdecl _mm512_prefetch_i64scatter_ps(void* base_addr, __m512i vindex, int scale, const int hint);
extern void __cdecl _mm512_mask_prefetch_i32gather_pd(__m256i vindex, __mmask8 mask, void const* base_addr, int scale, const int hint);
extern void __cdecl _mm512_mask_prefetch_i32gather_ps(__m512i vindex, __mmask16 mask, void const* base_addr, int scale, const int hint);
extern void __cdecl _mm512_mask_prefetch_i32scatter_pd(void* base_addr, __mmask8 mask, __m256i vinde, int scale, const int hint);
extern void __cdecl _mm512_mask_prefetch_i32scatter_ps(void* mv, __mmask16 k, __m512i index, int scale, const int hint);
extern void __cdecl _mm512_mask_prefetch_i64gather_pd(__m512i vindex, __mmask8 mask, void const* base_addr, int scale, const int hint);
extern void __cdecl _mm512_mask_prefetch_i64gather_ps(__m512i vindex, __mmask8 mask, void const* base_addr, int scale, const int hint);
extern void __cdecl _mm512_mask_prefetch_i64scatter_pd(void* base_addr, __mmask8 mask, __m512i vindex, int scale, const int hint);
extern void __cdecl _mm512_mask_prefetch_i64scatter_ps(void* base_addr, __mmask8 mask, __m512i vindex, int scale, const int hint);


extern void __cdecl _mm_2intersect_epi32(__m128i, __m128i, __mmask8 *, __mmask8 *);
extern void __cdecl _mm256_2intersect_epi32(__m256i, __m256i, __mmask8 *, __mmask8 *);
extern void __cdecl _mm512_2intersect_epi32(__m512i, __m512i, __mmask16 *, __mmask16 *);
extern void __cdecl _mm_2intersect_epi64(__m128i, __m128i, __mmask8 *, __mmask8 *);
extern void __cdecl _mm256_2intersect_epi64(__m256i, __m256i, __mmask8 *, __mmask8 *);
extern void __cdecl _mm512_2intersect_epi64(__m512i, __m512i, __mmask8 *, __mmask8 *);




typedef int __tile;

extern void __cdecl _tile_loadconfig(const void *);
extern void __cdecl _tile_storeconfig(void *);
extern void __cdecl _tile_release(void);

extern void __cdecl _tile_loadd(__tile dst, const void *base, int stride);
extern void __cdecl _tile_stream_loadd(__tile dst, const void *base, int stride);
extern void __cdecl _tile_stored(__tile src, void *base, int stride);
extern void __cdecl _tile_zero(__tile dst);

extern void __cdecl _tile_dpbf16ps(__tile dst, __tile src1, __tile src2);
extern void __cdecl _tile_dpfp16ps(__tile dst, __tile src1, __tile src2);
extern void __cdecl _tile_dpbssd(__tile dst, __tile src1, __tile src2);
extern void __cdecl _tile_dpbsud(__tile dst, __tile src1, __tile src2);
extern void __cdecl _tile_dpbusd(__tile dst, __tile src1, __tile src2);
extern void __cdecl _tile_dpbuud(__tile dst, __tile src1, __tile src2);

#line 5166 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\zmmintrin.h"

 
typedef __m128i __m128h;
typedef __m256i __m256h;
typedef __m512i __m512h;


extern __m128h __cdecl _mm_add_ph(__m128h, __m128h);
extern __m128h __cdecl _mm_mask_add_ph(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_maskz_add_ph(__mmask8, __m128h, __m128h);
extern __m256h __cdecl _mm256_add_ph(__m256h, __m256h);
extern __m256h __cdecl _mm256_mask_add_ph(__m256h, __mmask16, __m256h, __m256h);
extern __m256h __cdecl _mm256_maskz_add_ph(__mmask16, __m256h, __m256h);
extern __m512h __cdecl _mm512_add_ph(__m512h, __m512h);
extern __m512h __cdecl _mm512_mask_add_ph(__m512h, __mmask32, __m512h, __m512h);
extern __m512h __cdecl _mm512_maskz_add_ph(__mmask32, __m512h, __m512h);
extern __m512h __cdecl _mm512_add_round_ph(__m512h, __m512h, int);
extern __m512h __cdecl _mm512_mask_add_round_ph(__m512h, __mmask32, __m512h, __m512h, int);
extern __m512h __cdecl _mm512_maskz_add_round_ph(__mmask32, __m512h, __m512h, int);


extern __m128h __cdecl _mm_add_sh(__m128h, __m128h);
extern __m128h __cdecl _mm_mask_add_sh(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_maskz_add_sh(__mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_add_round_sh(__m128h, __m128h, int);
extern __m128h __cdecl _mm_mask_add_round_sh(__m128h, __mmask8, __m128h, __m128h, int);
extern __m128h __cdecl _mm_maskz_add_round_sh(__mmask8, __m128h, __m128h, int);
 
 





extern __mmask8 __cdecl _mm_cmp_ph_mask(__m128h, __m128h, const int);
extern __mmask8 __cdecl _mm_mask_cmp_ph_mask(__mmask8, __m128h, __m128h, const int);
extern __mmask16 __cdecl _mm256_cmp_ph_mask(__m256h, __m256h, const int);
extern __mmask16 __cdecl _mm256_mask_cmp_ph_mask(__mmask16, __m256h, __m256h, const int);
extern __mmask32 __cdecl _mm512_cmp_ph_mask(__m512h, __m512h, const int);
extern __mmask32 __cdecl _mm512_mask_cmp_ph_mask(__mmask32, __m512h, __m512h, const int);
extern __mmask32 __cdecl _mm512_cmp_round_ph_mask(__m512h, __m512h, const int, const int);
extern __mmask32 __cdecl _mm512_mask_cmp_round_ph_mask(__mmask32, __m512h, __m512h, const int, const int);


extern __mmask8 __cdecl _mm_cmp_sh_mask(__m128h, __m128h, const int);
extern __mmask8 __cdecl _mm_mask_cmp_sh_mask(__mmask8, __m128h, __m128h, const int);
extern __mmask8 __cdecl _mm_cmp_round_sh_mask(__m128h, __m128h, const int, const int);
extern __mmask8 __cdecl _mm_mask_cmp_round_sh_mask(__mmask8, __m128h, __m128h, const int, const int);


extern int __cdecl _mm_comi_sh(__m128h, __m128h, const int);
extern int __cdecl _mm_comi_round_sh(__m128h, __m128h, const int, const int);


extern __m128h __cdecl _mm_cvtepi32_ph(__m128i);
extern __m128h __cdecl _mm_mask_cvtepi32_ph(__m128h, __mmask8, __m128i);
extern __m128h __cdecl _mm_maskz_cvtepi32_ph(__mmask8, __m128i);
extern __m128h __cdecl _mm256_cvtepi32_ph(__m256i);
extern __m128h __cdecl _mm256_mask_cvtepi32_ph(__m128h, __mmask8, __m256i);
extern __m128h __cdecl _mm256_maskz_cvtepi32_ph(__mmask8, __m256i);
extern __m256h __cdecl _mm512_cvtepi32_ph (__m512i);
extern __m256h __cdecl _mm512_mask_cvtepi32_ph (__m256h, __mmask16, __m512i);
extern __m256h __cdecl _mm512_maskz_cvtepi32_ph (__mmask16, __m512i);
extern __m256h __cdecl _mm512_cvt_roundepi32_ph(__m512i, int);
extern __m256h __cdecl _mm512_mask_cvt_roundepi32_ph(__m256h, __mmask16, __m512i, int);
extern __m256h __cdecl _mm512_maskz_cvt_roundepi32_ph(__mmask16, __m512i, int);


extern __m128h __cdecl _mm_cvtpd_ph(__m128d);
extern __m128h __cdecl _mm_mask_cvtpd_ph(__m128h, __mmask8, __m128d);
extern __m128h __cdecl _mm_maskz_cvtpd_ph(__mmask8, __m128d);
extern __m128h __cdecl _mm256_cvtpd_ph(__m256d);
extern __m128h __cdecl _mm256_mask_cvtpd_ph(__m128h, __mmask8, __m256d);
extern __m128h __cdecl _mm256_maskz_cvtpd_ph(__mmask8, __m256d);
extern __m128h __cdecl _mm512_cvtpd_ph (__m512d);
extern __m128h __cdecl _mm512_mask_cvtpd_ph (__m128h, __mmask8, __m512d);
extern __m128h __cdecl _mm512_maskz_cvtpd_ph (__mmask8, __m512d);
extern __m128h __cdecl _mm512_cvt_roundpd_ph(__m512d, int);
extern __m128h __cdecl _mm512_mask_cvt_roundpd_ph(__m128h, __mmask8, __m512d, int);
extern __m128h __cdecl _mm512_maskz_cvt_roundpd_ph(__mmask8, __m512d, int);


extern __m128i __cdecl _mm_cvtph_epi32(__m128h);
extern __m128i __cdecl _mm_mask_cvtph_epi32(__m128i, __mmask8, __m128h);
extern __m128i __cdecl _mm_maskz_cvtph_epi32(__mmask8, __m128h);
extern __m256i __cdecl _mm256_cvtph_epi32(__m128h);
extern __m256i __cdecl _mm256_mask_cvtph_epi32(__m256i, __mmask8, __m128h);
extern __m256i __cdecl _mm256_maskz_cvtph_epi32(__mmask8, __m128h);
extern __m512i __cdecl _mm512_cvtph_epi32 (__m256h);
extern __m512i __cdecl _mm512_mask_cvtph_epi32 (__m512i, __mmask16, __m256h);
extern __m512i __cdecl _mm512_maskz_cvtph_epi32 (__mmask16, __m256h);
extern __m512i __cdecl _mm512_cvt_roundph_epi32(__m256h, int);
extern __m512i __cdecl _mm512_mask_cvt_roundph_epi32(__m512i, __mmask16, __m256h, int);
extern __m512i __cdecl _mm512_maskz_cvt_roundph_epi32(__mmask16, __m256h, int);


extern __m128d __cdecl _mm_cvtph_pd(__m128h);
extern __m128d __cdecl _mm_mask_cvtph_pd(__m128d, __mmask8, __m128h);
extern __m128d __cdecl _mm_maskz_cvtph_pd(__mmask8, __m128h);
extern __m256d __cdecl _mm256_cvtph_pd(__m128h);
extern __m256d __cdecl _mm256_mask_cvtph_pd(__m256d, __mmask8, __m128h);
extern __m256d __cdecl _mm256_maskz_cvtph_pd(__mmask8, __m128h);
extern __m512d __cdecl _mm512_cvtph_pd (__m128h);
extern __m512d __cdecl _mm512_mask_cvtph_pd (__m512d, __mmask8, __m128h);
extern __m512d __cdecl _mm512_maskz_cvtph_pd (__mmask8, __m128h);
extern __m512d __cdecl _mm512_cvt_roundph_pd(__m128h, int);
extern __m512d __cdecl _mm512_mask_cvt_roundph_pd(__m512d, __mmask8, __m128h, int);
extern __m512d __cdecl _mm512_maskz_cvt_roundph_pd(__mmask8, __m128h, int);


extern __m128 __cdecl _mm_cvtxph_ps(__m128h);
extern __m128 __cdecl _mm_mask_cvtxph_ps(__m128, __mmask8, __m128h);
extern __m128 __cdecl _mm_maskz_cvtxph_ps(__mmask8, __m128h);
extern __m256 __cdecl _mm256_cvtxph_ps(__m128h);
extern __m256 __cdecl _mm256_mask_cvtxph_ps(__m256, __mmask8, __m128h);
extern __m256 __cdecl _mm256_maskz_cvtxph_ps(__mmask8, __m128h);
extern __m512 __cdecl _mm512_cvtxph_ps(__m256h);
extern __m512 __cdecl _mm512_mask_cvtxph_ps(__m512, __mmask16, __m256h);
extern __m512 __cdecl _mm512_maskz_cvtxph_ps(__mmask16, __m256h);
extern __m512 __cdecl _mm512_cvtx_roundph_ps(__m256h, int);
extern __m512 __cdecl _mm512_mask_cvtx_roundph_ps(__m512, __mmask16, __m256h, int);
extern __m512 __cdecl _mm512_maskz_cvtx_roundph_ps(__mmask16, __m256h, int);


extern __m128i __cdecl _mm_cvtph_epi64(__m128h);
extern __m128i __cdecl _mm_mask_cvtph_epi64(__m128i, __mmask8, __m128h);
extern __m128i __cdecl _mm_maskz_cvtph_epi64(__mmask8, __m128h);
extern __m256i __cdecl _mm256_cvtph_epi64(__m128h);
extern __m256i __cdecl _mm256_mask_cvtph_epi64(__m256i, __mmask8, __m128h);
extern __m256i __cdecl _mm256_maskz_cvtph_epi64(__mmask8, __m128h);
extern __m512i __cdecl _mm512_cvtph_epi64 (__m128h);
extern __m512i __cdecl _mm512_mask_cvtph_epi64 (__m512i, __mmask8, __m128h);
extern __m512i __cdecl _mm512_maskz_cvtph_epi64 (__mmask8, __m128h);
extern __m512i __cdecl _mm512_cvt_roundph_epi64(__m128h, int);
extern __m512i __cdecl _mm512_mask_cvt_roundph_epi64(__m512i, __mmask8, __m128h, int);
extern __m512i __cdecl _mm512_maskz_cvt_roundph_epi64(__mmask8, __m128h, int);


extern __m128i __cdecl _mm_cvtph_epu32(__m128h);
extern __m128i __cdecl _mm_mask_cvtph_epu32(__m128i, __mmask8, __m128h);
extern __m128i __cdecl _mm_maskz_cvtph_epu32(__mmask8, __m128h);
extern __m256i __cdecl _mm256_cvtph_epu32(__m128h);
extern __m256i __cdecl _mm256_mask_cvtph_epu32(__m256i, __mmask8, __m128h);
extern __m256i __cdecl _mm256_maskz_cvtph_epu32(__mmask8, __m128h);
extern __m512i __cdecl _mm512_cvtph_epu32 (__m256h);
extern __m512i __cdecl _mm512_mask_cvtph_epu32 (__m512i, __mmask16, __m256h);
extern __m512i __cdecl _mm512_maskz_cvtph_epu32 (__mmask16, __m256h);
extern __m512i __cdecl _mm512_cvt_roundph_epu32(__m256h, int);
extern __m512i __cdecl _mm512_mask_cvt_roundph_epu32(__m512i, __mmask16, __m256h, int);
extern __m512i __cdecl _mm512_maskz_cvt_roundph_epu32(__mmask16, __m256h, int);


extern __m128i __cdecl _mm_cvtph_epu64(__m128h);
extern __m128i __cdecl _mm_mask_cvtph_epu64(__m128i, __mmask8, __m128h);
extern __m128i __cdecl _mm_maskz_cvtph_epu64(__mmask8, __m128h);
extern __m256i __cdecl _mm256_cvtph_epu64(__m128h);
extern __m256i __cdecl _mm256_mask_cvtph_epu64(__m256i, __mmask8, __m128h);
extern __m256i __cdecl _mm256_maskz_cvtph_epu64(__mmask8, __m128h);
extern __m512i __cdecl _mm512_cvtph_epu64 (__m128h);
extern __m512i __cdecl _mm512_mask_cvtph_epu64 (__m512i, __mmask8, __m128h);
extern __m512i __cdecl _mm512_maskz_cvtph_epu64 (__mmask8, __m128h);
extern __m512i __cdecl _mm512_cvt_roundph_epu64(__m128h, int);
extern __m512i __cdecl _mm512_mask_cvt_roundph_epu64(__m512i, __mmask8, __m128h, int);
extern __m512i __cdecl _mm512_maskz_cvt_roundph_epu64(__mmask8, __m128h, int);


extern __m128i __cdecl _mm_cvtph_epu16(__m128h);
extern __m128i __cdecl _mm_mask_cvtph_epu16(__m128i, __mmask8, __m128h);
extern __m128i __cdecl _mm_maskz_cvtph_epu16(__mmask8, __m128h);
extern __m256i __cdecl _mm256_cvtph_epu16(__m256h);
extern __m256i __cdecl _mm256_mask_cvtph_epu16(__m256i, __mmask16, __m256h);
extern __m256i __cdecl _mm256_maskz_cvtph_epu16(__mmask16, __m256h);
extern __m512i __cdecl _mm512_cvtph_epu16 (__m512h);
extern __m512i __cdecl _mm512_mask_cvtph_epu16 (__m512i, __mmask32, __m512h);
extern __m512i __cdecl _mm512_maskz_cvtph_epu16 (__mmask32, __m512h);
extern __m512i __cdecl _mm512_cvt_roundph_epu16(__m512h, int);
extern __m512i __cdecl _mm512_mask_cvt_roundph_epu16(__m512i, __mmask32, __m512h, int);
extern __m512i __cdecl _mm512_maskz_cvt_roundph_epu16(__mmask32, __m512h, int);


extern __m128i __cdecl _mm_cvtph_epi16(__m128h);
extern __m128i __cdecl _mm_mask_cvtph_epi16(__m128i, __mmask8, __m128h);
extern __m128i __cdecl _mm_maskz_cvtph_epi16(__mmask8, __m128h);
extern __m256i __cdecl _mm256_cvtph_epi16(__m256h);
extern __m256i __cdecl _mm256_mask_cvtph_epi16(__m256i, __mmask16, __m256h);
extern __m256i __cdecl _mm256_maskz_cvtph_epi16(__mmask16, __m256h);
extern __m512i __cdecl _mm512_cvtph_epi16 (__m512h);
extern __m512i __cdecl _mm512_mask_cvtph_epi16 (__m512i, __mmask32, __m512h);
extern __m512i __cdecl _mm512_maskz_cvtph_epi16 (__mmask32, __m512h);
extern __m512i __cdecl _mm512_cvt_roundph_epi16(__m512h, int);
extern __m512i __cdecl _mm512_mask_cvt_roundph_epi16(__m512i, __mmask32, __m512h, int);
extern __m512i __cdecl _mm512_maskz_cvt_roundph_epi16(__mmask32, __m512h, int);


extern __m128h __cdecl _mm_cvtxps_ph(__m128);
extern __m128h __cdecl _mm_mask_cvtxps_ph(__m128h, __mmask8, __m128);
extern __m128h __cdecl _mm_maskz_cvtxps_ph(__mmask8, __m128);
extern __m128h __cdecl _mm256_cvtxps_ph(__m256);
extern __m128h __cdecl _mm256_mask_cvtxps_ph(__m128h, __mmask8, __m256);
extern __m128h __cdecl _mm256_maskz_cvtxps_ph(__mmask8, __m256);
extern __m256h __cdecl _mm512_cvtxps_ph(__m512);
extern __m256h __cdecl _mm512_mask_cvtxps_ph(__m256h, __mmask16, __m512);
extern __m256h __cdecl _mm512_maskz_cvtxps_ph(__mmask16, __m512);
extern __m256h __cdecl _mm512_cvtx_roundps_ph(__m512, int);
extern __m256h __cdecl _mm512_mask_cvtx_roundps_ph(__m256h, __mmask16, __m512, int);
extern __m256h __cdecl _mm512_maskz_cvtx_roundps_ph(__mmask16, __m512, int);


extern __m128h __cdecl _mm_cvtepi64_ph(__m128i);
extern __m128h __cdecl _mm_mask_cvtepi64_ph(__m128h, __mmask8, __m128i);
extern __m128h __cdecl _mm_maskz_cvtepi64_ph(__mmask8, __m128i);
extern __m128h __cdecl _mm256_cvtepi64_ph(__m256i);
extern __m128h __cdecl _mm256_mask_cvtepi64_ph(__m128h, __mmask8, __m256i);
extern __m128h __cdecl _mm256_maskz_cvtepi64_ph(__mmask8, __m256i);
extern __m128h __cdecl _mm512_cvtepi64_ph (__m512i);
extern __m128h __cdecl _mm512_mask_cvtepi64_ph (__m128h, __mmask8, __m512i);
extern __m128h __cdecl _mm512_maskz_cvtepi64_ph (__mmask8, __m512i);
extern __m128h __cdecl _mm512_cvt_roundepi64_ph(__m512i, int);
extern __m128h __cdecl _mm512_mask_cvt_roundepi64_ph(__m128h, __mmask8, __m512i, int);
extern __m128h __cdecl _mm512_maskz_cvt_roundepi64_ph(__mmask8, __m512i, int);


extern __m128h __cdecl _mm_cvtsd_sh(__m128h, __m128d);
extern __m128h __cdecl _mm_mask_cvtsd_sh(__m128h, __mmask8, __m128h, __m128d);
extern __m128h __cdecl _mm_maskz_cvtsd_sh(__mmask8, __m128h, __m128d);
extern __m128h __cdecl _mm_cvt_roundsd_sh(__m128h, __m128d, const int);
extern __m128h __cdecl _mm_mask_cvt_roundsd_sh(__m128h, __mmask8, __m128h, __m128d, const int);
extern __m128h __cdecl _mm_maskz_cvt_roundsd_sh(__mmask8, __m128h, __m128d, const int);


extern __m128d __cdecl _mm_cvtsh_sd(__m128d, __m128h);
extern __m128d __cdecl _mm_mask_cvtsh_sd(__m128d, __mmask8, __m128d, __m128h);
extern __m128d __cdecl _mm_maskz_cvtsh_sd(__mmask8, __m128d, __m128h);
extern __m128d __cdecl _mm_cvt_roundsh_sd(__m128d, __m128h, const int);
extern __m128d __cdecl _mm_mask_cvt_roundsh_sd(__m128d, __mmask8, __m128d, __m128h, const int);
extern __m128d __cdecl _mm_maskz_cvt_roundsh_sd(__mmask8, __m128d, __m128h, const int);


extern int __cdecl _mm_cvtsh_i32(__m128h);
extern __int64 __cdecl _mm_cvtsh_i64(__m128h);
extern int __cdecl _mm_cvt_roundsh_i32(__m128h, int);
extern __int64 __cdecl _mm_cvt_roundsh_i64(__m128h, int);


extern __m128 __cdecl _mm_cvtsh_ss(__m128, __m128h);
extern __m128 __cdecl _mm_mask_cvtsh_ss(__m128, __mmask8, __m128, __m128h);
extern __m128 __cdecl _mm_maskz_cvtsh_ss(__mmask8, __m128, __m128h);
extern __m128 __cdecl _mm_cvt_roundsh_ss(__m128, __m128h, const int);
extern __m128 __cdecl _mm_mask_cvt_roundsh_ss(__m128, __mmask8, __m128, __m128h, const int);
extern __m128 __cdecl _mm_maskz_cvt_roundsh_ss(__mmask8, __m128, __m128h, const int);


extern unsigned int __cdecl _mm_cvtsh_u32(__m128h);
extern unsigned __int64 __cdecl _mm_cvtsh_u64(__m128h);
extern unsigned int __cdecl _mm_cvt_roundsh_u32(__m128h, int);
extern unsigned __int64 __cdecl _mm_cvt_roundsh_u64(__m128h, int);


extern __m128h __cdecl _mm_cvti32_sh(__m128h, int);
extern __m128h __cdecl _mm_cvti64_sh(__m128h, __int64);
extern __m128h __cdecl _mm_cvt_roundi32_sh(__m128h, int, int);
extern __m128h __cdecl _mm_cvt_roundi64_sh(__m128h, __int64, int);


extern __m128h __cdecl _mm_cvtss_sh(__m128h, __m128, const int);
extern __m128h __cdecl _mm_mask_cvtss_sh(__m128h, __mmask8, __m128h, __m128, const int);
extern __m128h __cdecl _mm_maskz_cvtss_sh(__mmask8, __m128h, __m128, const int);
extern __m128h __cdecl _mm_cvt_roundss_sh(__m128h, __m128, const int);
extern __m128h __cdecl _mm_mask_cvt_roundss_sh(__m128h, __mmask8, __m128h, __m128, const int);
extern __m128h __cdecl _mm_maskz_cvt_roundss_sh(__mmask8, __m128h, __m128, const int);


extern __m128i __cdecl _mm_cvttph_epi32(__m128h);
extern __m128i __cdecl _mm_mask_cvttph_epi32(__m128i, __mmask8, __m128h);
extern __m128i __cdecl _mm_maskz_cvttph_epi32(__mmask8, __m128h);
extern __m256i __cdecl _mm256_cvttph_epi32(__m128h);
extern __m256i __cdecl _mm256_mask_cvttph_epi32(__m256i, __mmask8, __m128h);
extern __m256i __cdecl _mm256_maskz_cvttph_epi32(__mmask8, __m128h);
extern __m512i __cdecl _mm512_cvttph_epi32 (__m256h);
extern __m512i __cdecl _mm512_mask_cvttph_epi32 (__m512i, __mmask16, __m256h);
extern __m512i __cdecl _mm512_maskz_cvttph_epi32 (__mmask16, __m256h);
extern __m512i __cdecl _mm512_cvtt_roundph_epi32(__m256h, int);
extern __m512i __cdecl _mm512_mask_cvtt_roundph_epi32(__m512i, __mmask16, __m256h, int);
extern __m512i __cdecl _mm512_maskz_cvtt_roundph_epi32(__mmask16, __m256h, int);


extern __m128i __cdecl _mm_cvttph_epi64(__m128h);
extern __m128i __cdecl _mm_mask_cvttph_epi64(__m128i, __mmask8, __m128h);
extern __m128i __cdecl _mm_maskz_cvttph_epi64(__mmask8, __m128h);
extern __m256i __cdecl _mm256_cvttph_epi64(__m128h);
extern __m256i __cdecl _mm256_mask_cvttph_epi64(__m256i, __mmask8, __m128h);
extern __m256i __cdecl _mm256_maskz_cvttph_epi64(__mmask8, __m128h);
extern __m512i __cdecl _mm512_cvttph_epi64 (__m128h);
extern __m512i __cdecl _mm512_mask_cvttph_epi64 (__m512i, __mmask8, __m128h);
extern __m512i __cdecl _mm512_maskz_cvttph_epi64 (__mmask8, __m128h);
extern __m512i __cdecl _mm512_cvtt_roundph_epi64(__m128h, int);
extern __m512i __cdecl _mm512_mask_cvtt_roundph_epi64(__m512i, __mmask8, __m128h, int);
extern __m512i __cdecl _mm512_maskz_cvtt_roundph_epi64(__mmask8, __m128h, int);


extern __m128i __cdecl _mm_cvttph_epu32(__m128h);
extern __m128i __cdecl _mm_mask_cvttph_epu32(__m128i, __mmask8, __m128h);
extern __m128i __cdecl _mm_maskz_cvttph_epu32(__mmask8, __m128h);
extern __m256i __cdecl _mm256_cvttph_epu32(__m128h);
extern __m256i __cdecl _mm256_mask_cvttph_epu32(__m256i, __mmask8, __m128h);
extern __m256i __cdecl _mm256_maskz_cvttph_epu32(__mmask8, __m128h);
extern __m512i __cdecl _mm512_cvttph_epu32 (__m256h);
extern __m512i __cdecl _mm512_mask_cvttph_epu32 (__m512i, __mmask16, __m256h);
extern __m512i __cdecl _mm512_maskz_cvttph_epu32 (__mmask16, __m256h);
extern __m512i __cdecl _mm512_cvtt_roundph_epu32(__m256h, int);
extern __m512i __cdecl _mm512_mask_cvtt_roundph_epu32(__m512i, __mmask16, __m256h, int);
extern __m512i __cdecl _mm512_maskz_cvtt_roundph_epu32(__mmask16, __m256h, int);


extern __m128i __cdecl _mm_cvttph_epu64(__m128h);
extern __m128i __cdecl _mm_mask_cvttph_epu64(__m128i, __mmask8, __m128h);
extern __m128i __cdecl _mm_maskz_cvttph_epu64(__mmask8, __m128h);
extern __m256i __cdecl _mm256_cvttph_epu64(__m128h);
extern __m256i __cdecl _mm256_mask_cvttph_epu64(__m256i, __mmask8, __m128h);
extern __m256i __cdecl _mm256_maskz_cvttph_epu64(__mmask8, __m128h);
extern __m512i __cdecl _mm512_cvttph_epu64 (__m128h);
extern __m512i __cdecl _mm512_mask_cvttph_epu64 (__m512i, __mmask8, __m128h);
extern __m512i __cdecl _mm512_maskz_cvttph_epu64 (__mmask8, __m128h);
extern __m512i __cdecl _mm512_cvtt_roundph_epu64(__m128h, int);
extern __m512i __cdecl _mm512_mask_cvtt_roundph_epu64(__m512i, __mmask8, __m128h, int);
extern __m512i __cdecl _mm512_maskz_cvtt_roundph_epu64(__mmask8, __m128h, int);


extern __m128i __cdecl _mm_cvttph_epu16(__m128h);
extern __m128i __cdecl _mm_mask_cvttph_epu16(__m128i, __mmask8, __m128h);
extern __m128i __cdecl _mm_maskz_cvttph_epu16(__mmask8, __m128h);
extern __m256i __cdecl _mm256_cvttph_epu16(__m256h);
extern __m256i __cdecl _mm256_mask_cvttph_epu16(__m256i, __mmask16, __m256h);
extern __m256i __cdecl _mm256_maskz_cvttph_epu16(__mmask16, __m256h);
extern __m512i __cdecl _mm512_cvttph_epu16 (__m512h);
extern __m512i __cdecl _mm512_mask_cvttph_epu16 (__m512i, __mmask32, __m512h);
extern __m512i __cdecl _mm512_maskz_cvttph_epu16 (__mmask32, __m512h);
extern __m512i __cdecl _mm512_cvtt_roundph_epu16(__m512h, int);
extern __m512i __cdecl _mm512_mask_cvtt_roundph_epu16(__m512i, __mmask32, __m512h, int);
extern __m512i __cdecl _mm512_maskz_cvtt_roundph_epu16(__mmask32, __m512h, int);


extern __m128i __cdecl _mm_cvttph_epi16(__m128h);
extern __m128i __cdecl _mm_mask_cvttph_epi16(__m128i, __mmask8, __m128h);
extern __m128i __cdecl _mm_maskz_cvttph_epi16(__mmask8, __m128h);
extern __m256i __cdecl _mm256_cvttph_epi16(__m256h);
extern __m256i __cdecl _mm256_mask_cvttph_epi16(__m256i, __mmask16, __m256h);
extern __m256i __cdecl _mm256_maskz_cvttph_epi16(__mmask16, __m256h);
extern __m512i __cdecl _mm512_cvttph_epi16 (__m512h);
extern __m512i __cdecl _mm512_mask_cvttph_epi16 (__m512i, __mmask32, __m512h);
extern __m512i __cdecl _mm512_maskz_cvttph_epi16 (__mmask32, __m512h);
extern __m512i __cdecl _mm512_cvtt_roundph_epi16(__m512h, int);
extern __m512i __cdecl _mm512_mask_cvtt_roundph_epi16(__m512i, __mmask32, __m512h, int);
extern __m512i __cdecl _mm512_maskz_cvtt_roundph_epi16(__mmask32, __m512h, int);


extern int __cdecl _mm_cvttsh_i32(__m128h);
extern __int64 __cdecl _mm_cvttsh_i64(__m128h);
extern int __cdecl _mm_cvtt_roundsh_i32(__m128h, int);
extern __int64 __cdecl _mm_cvtt_roundsh_i64(__m128h, int);


extern unsigned int __cdecl _mm_cvttsh_u32(__m128h);
extern unsigned __int64 __cdecl _mm_cvttsh_u64(__m128h);
extern unsigned int __cdecl _mm_cvtt_roundsh_u32(__m128h, int);
extern unsigned __int64 __cdecl _mm_cvtt_roundsh_u64(__m128h, int);


extern __m128h __cdecl _mm_cvtepu32_ph(__m128i);
extern __m128h __cdecl _mm_mask_cvtepu32_ph(__m128h, __mmask8, __m128i);
extern __m128h __cdecl _mm_maskz_cvtepu32_ph(__mmask8, __m128i);
extern __m128h __cdecl _mm256_cvtepu32_ph(__m256i);
extern __m128h __cdecl _mm256_mask_cvtepu32_ph(__m128h, __mmask8, __m256i);
extern __m128h __cdecl _mm256_maskz_cvtepu32_ph(__mmask8, __m256i);
extern __m256h __cdecl _mm512_cvtepu32_ph (__m512i);
extern __m256h __cdecl _mm512_mask_cvtepu32_ph (__m256h, __mmask16, __m512i);
extern __m256h __cdecl _mm512_maskz_cvtepu32_ph (__mmask16, __m512i);
extern __m256h __cdecl _mm512_cvt_roundepu32_ph(__m512i, int);
extern __m256h __cdecl _mm512_mask_cvt_roundepu32_ph(__m256h, __mmask16, __m512i, int);
extern __m256h __cdecl _mm512_maskz_cvt_roundepu32_ph(__mmask16, __m512i, int);


extern __m128h __cdecl _mm_cvtepu64_ph(__m128i);
extern __m128h __cdecl _mm_mask_cvtepu64_ph(__m128h, __mmask8, __m128i);
extern __m128h __cdecl _mm_maskz_cvtepu64_ph(__mmask8, __m128i);
extern __m128h __cdecl _mm256_cvtepu64_ph(__m256i);
extern __m128h __cdecl _mm256_mask_cvtepu64_ph(__m128h, __mmask8, __m256i);
extern __m128h __cdecl _mm256_maskz_cvtepu64_ph(__mmask8, __m256i);
extern __m128h __cdecl _mm512_cvtepu64_ph (__m512i);
extern __m128h __cdecl _mm512_mask_cvtepu64_ph (__m128h, __mmask8, __m512i);
extern __m128h __cdecl _mm512_maskz_cvtepu64_ph (__mmask8, __m512i);
extern __m128h __cdecl _mm512_cvt_roundepu64_ph(__m512i, int);
extern __m128h __cdecl _mm512_mask_cvt_roundepu64_ph(__m128h, __mmask8, __m512i, int);
extern __m128h __cdecl _mm512_maskz_cvt_roundepu64_ph(__mmask8, __m512i, int);


extern __m128h __cdecl _mm_cvtu32_sh(__m128h, unsigned int);
extern __m128h __cdecl _mm_cvtu64_sh(__m128h, unsigned __int64);
extern __m128h __cdecl _mm_cvt_roundu32_sh(__m128h, unsigned int, int);
extern __m128h __cdecl _mm_cvt_roundu64_sh(__m128h, unsigned __int64, int);


extern __m128h __cdecl _mm_cvtepu16_ph(__m128i);
extern __m128h __cdecl _mm_mask_cvtepu16_ph(__m128h, __mmask8, __m128i);
extern __m128h __cdecl _mm_maskz_cvtepu16_ph(__mmask8, __m128i);
extern __m256h __cdecl _mm256_cvtepu16_ph(__m256i);
extern __m256h __cdecl _mm256_mask_cvtepu16_ph(__m256h, __mmask16, __m256i);
extern __m256h __cdecl _mm256_maskz_cvtepu16_ph(__mmask16, __m256i);
extern __m512h __cdecl _mm512_cvtepu16_ph (__m512i);
extern __m512h __cdecl _mm512_mask_cvtepu16_ph (__m512h, __mmask32, __m512i);
extern __m512h __cdecl _mm512_maskz_cvtepu16_ph (__mmask32, __m512i);
extern __m512h __cdecl _mm512_cvt_roundepu16_ph(__m512i, int);
extern __m512h __cdecl _mm512_mask_cvt_roundepu16_ph(__m512h, __mmask32, __m512i, int);
extern __m512h __cdecl _mm512_maskz_cvt_roundepu16_ph(__mmask32, __m512i, int);


extern __m128h __cdecl _mm_cvtepi16_ph(__m128i);
extern __m128h __cdecl _mm_mask_cvtepi16_ph(__m128h, __mmask8, __m128i);
extern __m128h __cdecl _mm_maskz_cvtepi16_ph(__mmask8, __m128i);
extern __m256h __cdecl _mm256_cvtepi16_ph(__m256i);
extern __m256h __cdecl _mm256_mask_cvtepi16_ph(__m256h, __mmask16, __m256i);
extern __m256h __cdecl _mm256_maskz_cvtepi16_ph(__mmask16, __m256i);
extern __m512h __cdecl _mm512_cvtepi16_ph (__m512i);
extern __m512h __cdecl _mm512_mask_cvtepi16_ph (__m512h, __mmask32, __m512i);
extern __m512h __cdecl _mm512_maskz_cvtepi16_ph (__mmask32, __m512i);
extern __m512h __cdecl _mm512_cvt_roundepi16_ph(__m512i, int);
extern __m512h __cdecl _mm512_mask_cvt_roundepi16_ph(__m512h, __mmask32, __m512i, int);
extern __m512h __cdecl _mm512_maskz_cvt_roundepi16_ph(__mmask32, __m512i, int);


extern __m128h __cdecl _mm_div_ph(__m128h, __m128h);
extern __m128h __cdecl _mm_mask_div_ph(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_maskz_div_ph(__mmask8, __m128h, __m128h);
extern __m256h __cdecl _mm256_div_ph(__m256h, __m256h);
extern __m256h __cdecl _mm256_mask_div_ph(__m256h, __mmask16, __m256h, __m256h);
extern __m256h __cdecl _mm256_maskz_div_ph(__mmask16, __m256h, __m256h);
extern __m512h __cdecl _mm512_div_ph(__m512h, __m512h);
extern __m512h __cdecl _mm512_mask_div_ph(__m512h, __mmask32, __m512h, __m512h);
extern __m512h __cdecl _mm512_maskz_div_ph(__mmask32, __m512h, __m512h);
extern __m512h __cdecl _mm512_div_round_ph(__m512h, __m512h, int);
extern __m512h __cdecl _mm512_mask_div_round_ph(__m512h, __mmask32, __m512h, __m512h, int);
extern __m512h __cdecl _mm512_maskz_div_round_ph(__mmask32, __m512h, __m512h, int);


extern __m128h __cdecl _mm_div_sh(__m128h, __m128h);
extern __m128h __cdecl _mm_mask_div_sh(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_maskz_div_sh(__mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_div_round_sh(__m128h, __m128h, int);
extern __m128h __cdecl _mm_mask_div_round_sh(__m128h, __mmask8, __m128h, __m128h, int);
extern __m128h __cdecl _mm_maskz_div_round_sh(__mmask8, __m128h, __m128h, int);


extern __m128h __cdecl _mm_fmaddsub_ph(__m128h, __m128h, __m128h);
extern __m128h __cdecl _mm_mask_fmaddsub_ph(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_mask3_fmaddsub_ph(__m128h, __m128h, __m128h, __mmask8);
extern __m128h __cdecl _mm_maskz_fmaddsub_ph(__mmask8, __m128h, __m128h, __m128h);
extern __m256h __cdecl _mm256_fmaddsub_ph(__m256h, __m256h, __m256h);
extern __m256h __cdecl _mm256_mask_fmaddsub_ph(__m256h, __mmask16, __m256h, __m256h);
extern __m256h __cdecl _mm256_mask3_fmaddsub_ph(__m256h, __m256h, __m256h, __mmask16);
extern __m256h __cdecl _mm256_maskz_fmaddsub_ph(__mmask16, __m256h, __m256h, __m256h);
extern __m512h __cdecl _mm512_fmaddsub_ph(__m512h, __m512h, __m512h);
extern __m512h __cdecl _mm512_mask_fmaddsub_ph(__m512h, __mmask32, __m512h, __m512h);
extern __m512h __cdecl _mm512_mask3_fmaddsub_ph(__m512h, __m512h, __m512h, __mmask32);
extern __m512h __cdecl _mm512_maskz_fmaddsub_ph(__mmask32, __m512h, __m512h, __m512h);
extern __m512h __cdecl _mm512_fmaddsub_round_ph(__m512h, __m512h, __m512h, const int);
extern __m512h __cdecl _mm512_mask_fmaddsub_round_ph(__m512h, __mmask32, __m512h, __m512h, const int);
extern __m512h __cdecl _mm512_mask3_fmaddsub_round_ph(__m512h, __m512h, __m512h, __mmask32, const int);
extern __m512h __cdecl _mm512_maskz_fmaddsub_round_ph(__mmask32, __m512h, __m512h, __m512h, const int);


extern __m128h __cdecl _mm_fmsubadd_ph(__m128h, __m128h, __m128h);
extern __m128h __cdecl _mm_mask_fmsubadd_ph(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_mask3_fmsubadd_ph(__m128h, __m128h, __m128h, __mmask8);
extern __m128h __cdecl _mm_maskz_fmsubadd_ph(__mmask8, __m128h, __m128h, __m128h);
extern __m256h __cdecl _mm256_fmsubadd_ph(__m256h, __m256h, __m256h);
extern __m256h __cdecl _mm256_mask_fmsubadd_ph(__m256h, __mmask16, __m256h, __m256h);
extern __m256h __cdecl _mm256_mask3_fmsubadd_ph(__m256h, __m256h, __m256h, __mmask16);
extern __m256h __cdecl _mm256_maskz_fmsubadd_ph(__mmask16, __m256h, __m256h, __m256h);
extern __m512h __cdecl _mm512_fmsubadd_ph(__m512h, __m512h, __m512h);
extern __m512h __cdecl _mm512_mask_fmsubadd_ph(__m512h, __mmask32, __m512h, __m512h);
extern __m512h __cdecl _mm512_mask3_fmsubadd_ph(__m512h, __m512h, __m512h, __mmask32);
extern __m512h __cdecl _mm512_maskz_fmsubadd_ph(__mmask32, __m512h, __m512h, __m512h);
extern __m512h __cdecl _mm512_fmsubadd_round_ph(__m512h, __m512h, __m512h, const int);
extern __m512h __cdecl _mm512_mask_fmsubadd_round_ph(__m512h, __mmask32, __m512h, __m512h, const int);
extern __m512h __cdecl _mm512_mask3_fmsubadd_round_ph(__m512h, __m512h, __m512h, __mmask32, const int);
extern __m512h __cdecl _mm512_maskz_fmsubadd_round_ph(__mmask32, __m512h, __m512h, __m512h, const int);


extern __mmask8 __cdecl _mm_fpclass_ph_mask(__m128h, int);
extern __mmask8 __cdecl _mm_mask_fpclass_ph_mask(__mmask8, __m128h, int);
extern __mmask16 __cdecl _mm256_fpclass_ph_mask(__m256h, int);
extern __mmask16 __cdecl _mm256_mask_fpclass_ph_mask(__mmask16, __m256h, int);
extern __mmask32 __cdecl _mm512_fpclass_ph_mask(__m512h, int);
extern __mmask32 __cdecl _mm512_mask_fpclass_ph_mask(__mmask32, __m512h, int);


extern __mmask8 __cdecl _mm_fpclass_sh_mask(__m128h, int);
extern __mmask8 __cdecl _mm_mask_fpclass_sh_mask(__mmask8, __m128h, int);


extern __m128h __cdecl _mm_fmadd_pch(__m128h, __m128h, __m128h);
extern __m128h __cdecl _mm_mask_fmadd_pch(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_mask3_fmadd_pch(__m128h, __m128h, __m128h, __mmask8);
extern __m128h __cdecl _mm_maskz_fmadd_pch(__mmask8, __m128h, __m128h, __m128h);
extern __m256h __cdecl _mm256_fmadd_pch(__m256h, __m256h, __m256h);
extern __m256h __cdecl _mm256_mask_fmadd_pch(__m256h, __mmask8, __m256h, __m256h);
extern __m256h __cdecl _mm256_mask3_fmadd_pch(__m256h, __m256h, __m256h, __mmask8);
extern __m256h __cdecl _mm256_maskz_fmadd_pch(__mmask8, __m256h, __m256h, __m256h);
extern __m512h __cdecl _mm512_fmadd_pch(__m512h, __m512h, __m512h);
extern __m512h __cdecl _mm512_mask_fmadd_pch(__m512h, __mmask16, __m512h, __m512h);
extern __m512h __cdecl _mm512_mask3_fmadd_pch(__m512h, __m512h, __m512h, __mmask16);
extern __m512h __cdecl _mm512_maskz_fmadd_pch(__mmask16, __m512h, __m512h, __m512h);
extern __m512h __cdecl _mm512_fmadd_round_pch(__m512h, __m512h, __m512h, const int);
extern __m512h __cdecl _mm512_mask_fmadd_round_pch(__m512h, __mmask16, __m512h, __m512h, const int);
extern __m512h __cdecl _mm512_mask3_fmadd_round_pch(__m512h, __m512h, __m512h, __mmask16, const int);
extern __m512h __cdecl _mm512_maskz_fmadd_round_pch(__mmask16, __m512h, __m512h, __m512h, const int);
extern __m128h __cdecl _mm_fcmadd_pch(__m128h, __m128h, __m128h);
extern __m128h __cdecl _mm_mask_fcmadd_pch(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_mask3_fcmadd_pch(__m128h, __m128h, __m128h, __mmask8);
extern __m128h __cdecl _mm_maskz_fcmadd_pch(__mmask8, __m128h, __m128h, __m128h);
extern __m256h __cdecl _mm256_fcmadd_pch(__m256h, __m256h, __m256h);
extern __m256h __cdecl _mm256_mask_fcmadd_pch(__m256h, __mmask8, __m256h, __m256h);
extern __m256h __cdecl _mm256_mask3_fcmadd_pch(__m256h, __m256h, __m256h, __mmask8);
extern __m256h __cdecl _mm256_maskz_fcmadd_pch(__mmask8, __m256h, __m256h, __m256h);
extern __m512h __cdecl _mm512_fcmadd_pch(__m512h, __m512h, __m512h);
extern __m512h __cdecl _mm512_mask_fcmadd_pch(__m512h, __mmask16, __m512h, __m512h);
extern __m512h __cdecl _mm512_mask3_fcmadd_pch(__m512h, __m512h, __m512h, __mmask16);
extern __m512h __cdecl _mm512_maskz_fcmadd_pch(__mmask16, __m512h, __m512h, __m512h);
extern __m512h __cdecl _mm512_fcmadd_round_pch(__m512h, __m512h, __m512h, const int);
extern __m512h __cdecl _mm512_mask_fcmadd_round_pch(__m512h, __mmask16, __m512h, __m512h, const int);
extern __m512h __cdecl _mm512_mask3_fcmadd_round_pch(__m512h, __m512h, __m512h, __mmask16, const int);
extern __m512h __cdecl _mm512_maskz_fcmadd_round_pch(__mmask16, __m512h, __m512h, __m512h, const int);


extern __m128h __cdecl _mm_fcmadd_sch(__m128h, __m128h, __m128h);
extern __m128h __cdecl _mm_mask_fcmadd_sch(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_mask3_fcmadd_sch(__m128h, __m128h, __m128h, __mmask8);
extern __m128h __cdecl _mm_maskz_fcmadd_sch(__mmask8, __m128h, __m128h, __m128h);
extern __m128h __cdecl _mm_fcmadd_round_sch(__m128h, __m128h, __m128h, const int);
extern __m128h __cdecl _mm_mask_fcmadd_round_sch(__m128h, __mmask8, __m128h, __m128h, const int);
extern __m128h __cdecl _mm_mask3_fcmadd_round_sch(__m128h, __m128h, __m128h, __mmask8, const int);
extern __m128h __cdecl _mm_maskz_fcmadd_round_sch(__mmask8, __m128h, __m128h, __m128h, const int);
extern __m128h __cdecl _mm_fmadd_sch(__m128h, __m128h, __m128h);
extern __m128h __cdecl _mm_mask_fmadd_sch(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_mask3_fmadd_sch(__m128h, __m128h, __m128h, __mmask8);
extern __m128h __cdecl _mm_maskz_fmadd_sch(__mmask8, __m128h, __m128h, __m128h);
extern __m128h __cdecl _mm_fmadd_round_sch(__m128h, __m128h, __m128h, const int);
extern __m128h __cdecl _mm_mask_fmadd_round_sch(__m128h, __mmask8, __m128h, __m128h, const int);
extern __m128h __cdecl _mm_mask3_fmadd_round_sch(__m128h, __m128h, __m128h, __mmask8, const int);
extern __m128h __cdecl _mm_maskz_fmadd_round_sch(__mmask8, __m128h, __m128h, __m128h, const int);


extern __m128h __cdecl _mm_fcmul_pch(__m128h, __m128h);
extern __m128h __cdecl _mm_mask_fcmul_pch(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_maskz_fcmul_pch(__mmask8, __m128h, __m128h);
extern __m256h __cdecl _mm256_fcmul_pch(__m256h, __m256h);
extern __m256h __cdecl _mm256_mask_fcmul_pch(__m256h, __mmask8, __m256h, __m256h);
extern __m256h __cdecl _mm256_maskz_fcmul_pch(__mmask8, __m256h, __m256h);
extern __m512h __cdecl _mm512_fcmul_pch(__m512h, __m512h);
extern __m512h __cdecl _mm512_mask_fcmul_pch(__m512h, __mmask16, __m512h, __m512h);
extern __m512h __cdecl _mm512_maskz_fcmul_pch(__mmask16, __m512h, __m512h);
extern __m512h __cdecl _mm512_fcmul_round_pch(__m512h, __m512h, const int);
extern __m512h __cdecl _mm512_mask_fcmul_round_pch(__m512h, __mmask16, __m512h, __m512h, const int);
extern __m512h __cdecl _mm512_maskz_fcmul_round_pch(__mmask16, __m512h, __m512h, const int);
extern __m128h __cdecl _mm_fmul_pch(__m128h, __m128h);
extern __m128h __cdecl _mm_mask_fmul_pch(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_maskz_fmul_pch(__mmask8, __m128h, __m128h);
extern __m256h __cdecl _mm256_fmul_pch(__m256h, __m256h);
extern __m256h __cdecl _mm256_mask_fmul_pch(__m256h, __mmask8, __m256h, __m256h);
extern __m256h __cdecl _mm256_maskz_fmul_pch(__mmask8, __m256h, __m256h);
extern __m512h __cdecl _mm512_fmul_pch(__m512h, __m512h);
extern __m512h __cdecl _mm512_mask_fmul_pch(__m512h, __mmask16, __m512h, __m512h);
extern __m512h __cdecl _mm512_maskz_fmul_pch(__mmask16, __m512h, __m512h);
extern __m512h __cdecl _mm512_fmul_round_pch(__m512h, __m512h, const int);
extern __m512h __cdecl _mm512_mask_fmul_round_pch(__m512h, __mmask16, __m512h, __m512h, const int);
extern __m512h __cdecl _mm512_maskz_fmul_round_pch(__mmask16, __m512h, __m512h, const int);


extern __m128h __cdecl _mm_fcmul_sch(__m128h, __m128h);
extern __m128h __cdecl _mm_mask_fcmul_sch(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_maskz_fcmul_sch(__mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_fcmul_round_sch(__m128h, __m128h, const int);
extern __m128h __cdecl _mm_mask_fcmul_round_sch(__m128h, __mmask8, __m128h, __m128h, const int);
extern __m128h __cdecl _mm_maskz_fcmul_round_sch(__mmask8, __m128h, __m128h, const int);
extern __m128h __cdecl _mm_fmul_sch(__m128h, __m128h);
extern __m128h __cdecl _mm_mask_fmul_sch(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_maskz_fmul_sch(__mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_fmul_round_sch(__m128h, __m128h, const int);
extern __m128h __cdecl _mm_mask_fmul_round_sch(__m128h, __mmask8, __m128h, __m128h, const int);
extern __m128h __cdecl _mm_maskz_fmul_round_sch(__mmask8, __m128h, __m128h, const int);


extern __m128h __cdecl _mm_fnmadd_ph(__m128h, __m128h, __m128h);
extern __m128h __cdecl _mm_mask_fnmadd_ph(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_mask3_fnmadd_ph(__m128h, __m128h, __m128h, __mmask8);
extern __m128h __cdecl _mm_maskz_fnmadd_ph(__mmask8, __m128h, __m128h, __m128h);
extern __m256h __cdecl _mm256_fnmadd_ph(__m256h, __m256h, __m256h);
extern __m256h __cdecl _mm256_mask_fnmadd_ph(__m256h, __mmask16, __m256h, __m256h);
extern __m256h __cdecl _mm256_mask3_fnmadd_ph(__m256h, __m256h, __m256h, __mmask16);
extern __m256h __cdecl _mm256_maskz_fnmadd_ph(__mmask16, __m256h, __m256h, __m256h);
extern __m512h __cdecl _mm512_fnmadd_ph(__m512h, __m512h, __m512h);
extern __m512h __cdecl _mm512_mask_fnmadd_ph(__m512h, __mmask32, __m512h, __m512h);
extern __m512h __cdecl _mm512_mask3_fnmadd_ph(__m512h, __m512h, __m512h, __mmask32);
extern __m512h __cdecl _mm512_maskz_fnmadd_ph(__mmask32, __m512h, __m512h, __m512h);
extern __m512h __cdecl _mm512_fnmadd_round_ph(__m512h, __m512h, __m512h, const int);
extern __m512h __cdecl _mm512_mask_fnmadd_round_ph(__m512h, __mmask32, __m512h, __m512h, const int);
extern __m512h __cdecl _mm512_mask3_fnmadd_round_ph(__m512h, __m512h, __m512h, __mmask32, const int);
extern __m512h __cdecl _mm512_maskz_fnmadd_round_ph(__mmask32, __m512h, __m512h, __m512h, const int);
extern __m128h __cdecl _mm_fmadd_ph(__m128h, __m128h, __m128h);
extern __m128h __cdecl _mm_mask_fmadd_ph(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_mask3_fmadd_ph(__m128h, __m128h, __m128h, __mmask8);
extern __m128h __cdecl _mm_maskz_fmadd_ph(__mmask8, __m128h, __m128h, __m128h);
extern __m256h __cdecl _mm256_fmadd_ph(__m256h, __m256h, __m256h);
extern __m256h __cdecl _mm256_mask_fmadd_ph(__m256h, __mmask16, __m256h, __m256h);
extern __m256h __cdecl _mm256_mask3_fmadd_ph(__m256h, __m256h, __m256h, __mmask16);
extern __m256h __cdecl _mm256_maskz_fmadd_ph(__mmask16, __m256h, __m256h, __m256h);
extern __m512h __cdecl _mm512_fmadd_ph(__m512h, __m512h, __m512h);
extern __m512h __cdecl _mm512_mask_fmadd_ph(__m512h, __mmask32, __m512h, __m512h);
extern __m512h __cdecl _mm512_mask3_fmadd_ph(__m512h, __m512h, __m512h, __mmask32);
extern __m512h __cdecl _mm512_maskz_fmadd_ph(__mmask32, __m512h, __m512h, __m512h);
extern __m512h __cdecl _mm512_fmadd_round_ph(__m512h, __m512h, __m512h, const int);
extern __m512h __cdecl _mm512_mask_fmadd_round_ph(__m512h, __mmask32, __m512h, __m512h, const int);
extern __m512h __cdecl _mm512_mask3_fmadd_round_ph(__m512h, __m512h, __m512h, __mmask32, const int);
extern __m512h __cdecl _mm512_maskz_fmadd_round_ph(__mmask32, __m512h, __m512h, __m512h, const int);


extern __m128h __cdecl _mm_fnmadd_sh(__m128h, __m128h, __m128h);
extern __m128h __cdecl _mm_mask_fnmadd_sh(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_mask3_fnmadd_sh(__m128h, __m128h, __m128h, __mmask8);
extern __m128h __cdecl _mm_maskz_fnmadd_sh(__mmask8, __m128h, __m128h, __m128h);
extern __m128h __cdecl _mm_fnmadd_round_sh(__m128h, __m128h, __m128h, const int);
extern __m128h __cdecl _mm_mask_fnmadd_round_sh(__m128h, __mmask8, __m128h, __m128h, const int);
extern __m128h __cdecl _mm_mask3_fnmadd_round_sh(__m128h, __m128h, __m128h, __mmask8, const int);
extern __m128h __cdecl _mm_maskz_fnmadd_round_sh(__mmask8, __m128h, __m128h, __m128h, const int);
extern __m128h __cdecl _mm_fmadd_sh(__m128h, __m128h, __m128h);
extern __m128h __cdecl _mm_mask_fmadd_sh(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_mask3_fmadd_sh(__m128h, __m128h, __m128h, __mmask8);
extern __m128h __cdecl _mm_maskz_fmadd_sh(__mmask8, __m128h, __m128h, __m128h);
extern __m128h __cdecl _mm_fmadd_round_sh(__m128h, __m128h, __m128h, const int);
extern __m128h __cdecl _mm_mask_fmadd_round_sh(__m128h, __mmask8, __m128h, __m128h, const int);
extern __m128h __cdecl _mm_mask3_fmadd_round_sh(__m128h, __m128h, __m128h, __mmask8, const int);
extern __m128h __cdecl _mm_maskz_fmadd_round_sh(__mmask8, __m128h, __m128h, __m128h, const int);


extern __m128h __cdecl _mm_fnmsub_ph(__m128h, __m128h, __m128h);
extern __m128h __cdecl _mm_mask_fnmsub_ph(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_mask3_fnmsub_ph(__m128h, __m128h, __m128h, __mmask8);
extern __m128h __cdecl _mm_maskz_fnmsub_ph(__mmask8, __m128h, __m128h, __m128h);
extern __m256h __cdecl _mm256_fnmsub_ph(__m256h, __m256h, __m256h);
extern __m256h __cdecl _mm256_mask_fnmsub_ph(__m256h, __mmask16, __m256h, __m256h);
extern __m256h __cdecl _mm256_mask3_fnmsub_ph(__m256h, __m256h, __m256h, __mmask16);
extern __m256h __cdecl _mm256_maskz_fnmsub_ph(__mmask16, __m256h, __m256h, __m256h);
extern __m512h __cdecl _mm512_fnmsub_ph(__m512h, __m512h, __m512h);
extern __m512h __cdecl _mm512_mask_fnmsub_ph(__m512h, __mmask32, __m512h, __m512h);
extern __m512h __cdecl _mm512_mask3_fnmsub_ph(__m512h, __m512h, __m512h, __mmask32);
extern __m512h __cdecl _mm512_maskz_fnmsub_ph(__mmask32, __m512h, __m512h, __m512h);
extern __m512h __cdecl _mm512_fnmsub_round_ph(__m512h, __m512h, __m512h, const int);
extern __m512h __cdecl _mm512_mask_fnmsub_round_ph(__m512h, __mmask32, __m512h, __m512h, const int);
extern __m512h __cdecl _mm512_mask3_fnmsub_round_ph(__m512h, __m512h, __m512h, __mmask32, const int);
extern __m512h __cdecl _mm512_maskz_fnmsub_round_ph(__mmask32, __m512h, __m512h, __m512h, const int);
extern __m128h __cdecl _mm_fmsub_ph(__m128h, __m128h, __m128h);
extern __m128h __cdecl _mm_mask_fmsub_ph(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_mask3_fmsub_ph(__m128h, __m128h, __m128h, __mmask8);
extern __m128h __cdecl _mm_maskz_fmsub_ph(__mmask8, __m128h, __m128h, __m128h);
extern __m256h __cdecl _mm256_fmsub_ph(__m256h, __m256h, __m256h);
extern __m256h __cdecl _mm256_mask_fmsub_ph(__m256h, __mmask16, __m256h, __m256h);
extern __m256h __cdecl _mm256_mask3_fmsub_ph(__m256h, __m256h, __m256h, __mmask16);
extern __m256h __cdecl _mm256_maskz_fmsub_ph(__mmask16, __m256h, __m256h, __m256h);
extern __m512h __cdecl _mm512_fmsub_ph(__m512h, __m512h, __m512h);
extern __m512h __cdecl _mm512_mask_fmsub_ph(__m512h, __mmask32, __m512h, __m512h);
extern __m512h __cdecl _mm512_mask3_fmsub_ph(__m512h, __m512h, __m512h, __mmask32);
extern __m512h __cdecl _mm512_maskz_fmsub_ph(__mmask32, __m512h, __m512h, __m512h);
extern __m512h __cdecl _mm512_fmsub_round_ph(__m512h, __m512h, __m512h, const int);
extern __m512h __cdecl _mm512_mask_fmsub_round_ph(__m512h, __mmask32, __m512h, __m512h, const int);
extern __m512h __cdecl _mm512_mask3_fmsub_round_ph(__m512h, __m512h, __m512h, __mmask32, const int);
extern __m512h __cdecl _mm512_maskz_fmsub_round_ph(__mmask32, __m512h, __m512h, __m512h, const int);


extern __m128h __cdecl _mm_fnmsub_sh(__m128h, __m128h, __m128h);
extern __m128h __cdecl _mm_mask_fnmsub_sh(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_mask3_fnmsub_sh(__m128h, __m128h, __m128h, __mmask8);
extern __m128h __cdecl _mm_maskz_fnmsub_sh(__mmask8, __m128h, __m128h, __m128h);
extern __m128h __cdecl _mm_fnmsub_round_sh(__m128h, __m128h, __m128h, const int);
extern __m128h __cdecl _mm_mask_fnmsub_round_sh(__m128h, __mmask8, __m128h, __m128h, const int);
extern __m128h __cdecl _mm_mask3_fnmsub_round_sh(__m128h, __m128h, __m128h, __mmask8, const int);
extern __m128h __cdecl _mm_maskz_fnmsub_round_sh(__mmask8, __m128h, __m128h, __m128h, const int);
extern __m128h __cdecl _mm_fmsub_sh(__m128h, __m128h, __m128h);
extern __m128h __cdecl _mm_mask_fmsub_sh(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_mask3_fmsub_sh(__m128h, __m128h, __m128h, __mmask8);
extern __m128h __cdecl _mm_maskz_fmsub_sh(__mmask8, __m128h, __m128h, __m128h);
extern __m128h __cdecl _mm_fmsub_round_sh(__m128h, __m128h, __m128h, const int);
extern __m128h __cdecl _mm_mask_fmsub_round_sh(__m128h, __mmask8, __m128h, __m128h, const int);
extern __m128h __cdecl _mm_mask3_fmsub_round_sh(__m128h, __m128h, __m128h, __mmask8, const int);
extern __m128h __cdecl _mm_maskz_fmsub_round_sh(__mmask8, __m128h, __m128h, __m128h, const int);


extern __m128h __cdecl _mm_getexp_ph(__m128h);
extern __m128h __cdecl _mm_mask_getexp_ph(__m128h, __mmask8, __m128h);
extern __m128h __cdecl _mm_maskz_getexp_ph(__mmask8, __m128h);
extern __m256h __cdecl _mm256_getexp_ph(__m256h);
extern __m256h __cdecl _mm256_mask_getexp_ph(__m256h, __mmask16, __m256h);
extern __m256h __cdecl _mm256_maskz_getexp_ph(__mmask16, __m256h);
extern __m512h __cdecl _mm512_getexp_ph(__m512h);
extern __m512h __cdecl _mm512_mask_getexp_ph(__m512h, __mmask32, __m512h);
extern __m512h __cdecl _mm512_maskz_getexp_ph(__mmask32, __m512h);
extern __m512h __cdecl _mm512_getexp_round_ph(__m512h, const int);
extern __m512h __cdecl _mm512_mask_getexp_round_ph(__m512h, __mmask32, __m512h, const int);
extern __m512h __cdecl _mm512_maskz_getexp_round_ph(__mmask32, __m512h, const int);


extern __m128h __cdecl _mm_getexp_sh(__m128h, __m128h);
extern __m128h __cdecl _mm_mask_getexp_sh(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_maskz_getexp_sh(__mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_getexp_round_sh(__m128h, __m128h, const int);
extern __m128h __cdecl _mm_mask_getexp_round_sh(__m128h, __mmask8, __m128h, __m128h, const int);
extern __m128h __cdecl _mm_maskz_getexp_round_sh(__mmask8, __m128h, __m128h, const int);


extern __m128h __cdecl _mm_getmant_ph(__m128h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM);
extern __m128h __cdecl _mm_mask_getmant_ph(__m128h, __mmask8, __m128h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM);
extern __m128h __cdecl _mm_maskz_getmant_ph(__mmask8, __m128h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM);
extern __m256h __cdecl _mm256_getmant_ph(__m256h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM);
extern __m256h __cdecl _mm256_mask_getmant_ph(__m256h, __mmask16, __m256h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM);
extern __m256h __cdecl _mm256_maskz_getmant_ph(__mmask16, __m256h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM);
extern __m512h __cdecl _mm512_getmant_ph(__m512h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM);
extern __m512h __cdecl _mm512_mask_getmant_ph(__m512h, __mmask32, __m512h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM);
extern __m512h __cdecl _mm512_maskz_getmant_ph(__mmask32, __m512h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM);
extern __m512h __cdecl _mm512_getmant_round_ph(__m512h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM, const int);
extern __m512h __cdecl _mm512_mask_getmant_round_ph(__m512h, __mmask32, __m512h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM, const int);
extern __m512h __cdecl _mm512_maskz_getmant_round_ph(__mmask32, __m512h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM, const int);


extern __m128h __cdecl _mm_getmant_sh(__m128h, __m128h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM);
extern __m128h __cdecl _mm_mask_getmant_sh(__m128h, __mmask8, __m128h, __m128h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM);
extern __m128h __cdecl _mm_maskz_getmant_sh(__mmask8, __m128h, __m128h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM);
extern __m128h __cdecl _mm_getmant_round_sh(__m128h, __m128h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM, const int);
extern __m128h __cdecl _mm_mask_getmant_round_sh(__m128h, __mmask8, __m128h, __m128h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM, const int);
extern __m128h __cdecl _mm_maskz_getmant_round_sh(__mmask8, __m128h, __m128h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM, const int);


extern __m128h __cdecl _mm_max_ph(__m128h, __m128h);
extern __m128h __cdecl _mm_mask_max_ph(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_maskz_max_ph(__mmask8, __m128h, __m128h);
extern __m256h __cdecl _mm256_max_ph(__m256h, __m256h);
extern __m256h __cdecl _mm256_mask_max_ph(__m256h, __mmask16, __m256h, __m256h);
extern __m256h __cdecl _mm256_maskz_max_ph(__mmask16, __m256h, __m256h);
extern __m512h __cdecl _mm512_max_ph(__m512h, __m512h);
extern __m512h __cdecl _mm512_mask_max_ph(__m512h, __mmask32, __m512h, __m512h);
extern __m512h __cdecl _mm512_maskz_max_ph(__mmask32, __m512h, __m512h);
extern __m512h __cdecl _mm512_max_round_ph(__m512h, __m512h, int);
extern __m512h __cdecl _mm512_mask_max_round_ph(__m512h, __mmask32, __m512h, __m512h, int);
extern __m512h __cdecl _mm512_maskz_max_round_ph(__mmask32, __m512h, __m512h, int);


extern __m128h __cdecl _mm_max_sh(__m128h, __m128h);
extern __m128h __cdecl _mm_mask_max_sh(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_maskz_max_sh(__mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_max_round_sh(__m128h, __m128h, int);
extern __m128h __cdecl _mm_mask_max_round_sh(__m128h, __mmask8, __m128h, __m128h, int);
extern __m128h __cdecl _mm_maskz_max_round_sh(__mmask8, __m128h, __m128h, int);


extern __m128h __cdecl _mm_min_ph(__m128h, __m128h);
extern __m128h __cdecl _mm_mask_min_ph(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_maskz_min_ph(__mmask8, __m128h, __m128h);
extern __m256h __cdecl _mm256_min_ph(__m256h, __m256h);
extern __m256h __cdecl _mm256_mask_min_ph(__m256h, __mmask16, __m256h, __m256h);
extern __m256h __cdecl _mm256_maskz_min_ph(__mmask16, __m256h, __m256h);
extern __m512h __cdecl _mm512_min_ph(__m512h, __m512h);
extern __m512h __cdecl _mm512_mask_min_ph(__m512h, __mmask32, __m512h, __m512h);
extern __m512h __cdecl _mm512_maskz_min_ph(__mmask32, __m512h, __m512h);
extern __m512h __cdecl _mm512_min_round_ph(__m512h, __m512h, int);
extern __m512h __cdecl _mm512_mask_min_round_ph(__m512h, __mmask32, __m512h, __m512h, int);
extern __m512h __cdecl _mm512_maskz_min_round_ph(__mmask32, __m512h, __m512h, int);


extern __m128h __cdecl _mm_min_sh(__m128h, __m128h);
extern __m128h __cdecl _mm_mask_min_sh(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_maskz_min_sh(__mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_min_round_sh(__m128h, __m128h, int);
extern __m128h __cdecl _mm_mask_min_round_sh(__m128h, __mmask8, __m128h, __m128h, int);
extern __m128h __cdecl _mm_maskz_min_round_sh(__mmask8, __m128h, __m128h, int);


extern __m128h __cdecl _mm_load_sh(void const*);
extern __m128h __cdecl _mm_mask_load_sh(__m128h, __mmask8, void const*);
extern __m128h __cdecl _mm_maskz_load_sh(__mmask8, void const*);
extern void __cdecl _mm_store_sh(void*, __m128h);
extern void __cdecl _mm_mask_store_sh(void*, __mmask8, __m128h);
extern __m128h __cdecl _mm_move_sh(__m128h, __m128h);
extern __m128h __cdecl _mm_mask_move_sh(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_maskz_move_sh(__mmask8, __m128h, __m128h);


extern __m128i __cdecl _mm_cvtsi16_si128(short);
extern short __cdecl _mm_cvtsi128_si16(__m128i);


extern __m128h __cdecl _mm_mul_ph(__m128h, __m128h);
extern __m128h __cdecl _mm_mask_mul_ph(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_maskz_mul_ph(__mmask8, __m128h, __m128h);
extern __m256h __cdecl _mm256_mul_ph(__m256h, __m256h);
extern __m256h __cdecl _mm256_mask_mul_ph(__m256h, __mmask16, __m256h, __m256h);
extern __m256h __cdecl _mm256_maskz_mul_ph(__mmask16, __m256h, __m256h);
extern __m512h __cdecl _mm512_mul_ph(__m512h, __m512h);
extern __m512h __cdecl _mm512_mask_mul_ph(__m512h, __mmask32, __m512h, __m512h);
extern __m512h __cdecl _mm512_maskz_mul_ph(__mmask32, __m512h, __m512h);
extern __m512h __cdecl _mm512_mul_round_ph(__m512h, __m512h, int);
extern __m512h __cdecl _mm512_mask_mul_round_ph(__m512h, __mmask32, __m512h, __m512h, int);
extern __m512h __cdecl _mm512_maskz_mul_round_ph(__mmask32, __m512h, __m512h, int);


extern __m128h __cdecl _mm_mul_sh(__m128h, __m128h);
extern __m128h __cdecl _mm_mask_mul_sh(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_maskz_mul_sh(__mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_mul_round_sh(__m128h, __m128h, int);
extern __m128h __cdecl _mm_mask_mul_round_sh(__m128h, __mmask8, __m128h, __m128h, int);
extern __m128h __cdecl _mm_maskz_mul_round_sh(__mmask8, __m128h, __m128h, int);


extern __m128h __cdecl _mm_rcp_ph(__m128h);
extern __m128h __cdecl _mm_mask_rcp_ph(__m128h, __mmask8, __m128h);
extern __m128h __cdecl _mm_maskz_rcp_ph(__mmask8, __m128h);
extern __m256h __cdecl _mm256_rcp_ph(__m256h);
extern __m256h __cdecl _mm256_mask_rcp_ph(__m256h, __mmask16, __m256h);
extern __m256h __cdecl _mm256_maskz_rcp_ph(__mmask16, __m256h);
extern __m512h __cdecl _mm512_rcp_ph(__m512h);
extern __m512h __cdecl _mm512_mask_rcp_ph(__m512h, __mmask32, __m512h);
extern __m512h __cdecl _mm512_maskz_rcp_ph(__mmask32, __m512h);


extern __m128h __cdecl _mm_rcp_sh(__m128h, __m128h);
extern __m128h __cdecl _mm_mask_rcp_sh(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_maskz_rcp_sh(__mmask8, __m128h, __m128h);


extern __m128h __cdecl _mm_reduce_ph(__m128h, int);
extern __m128h __cdecl _mm_mask_reduce_ph(__m128h, __mmask8, __m128h, int);
extern __m128h __cdecl _mm_maskz_reduce_ph(__mmask8, __m128h, int);
extern __m256h __cdecl _mm256_reduce_ph(__m256h, int);
extern __m256h __cdecl _mm256_mask_reduce_ph(__m256h, __mmask16, __m256h, int);
extern __m256h __cdecl _mm256_maskz_reduce_ph(__mmask16, __m256h, int);
extern __m512h __cdecl _mm512_reduce_ph(__m512h, int);
extern __m512h __cdecl _mm512_mask_reduce_ph(__m512h, __mmask32, __m512h, int);
extern __m512h __cdecl _mm512_maskz_reduce_ph(__mmask32, __m512h, int);
extern __m512h __cdecl _mm512_reduce_round_ph(__m512h, int, const int);
extern __m512h __cdecl _mm512_mask_reduce_round_ph(__m512h, __mmask32, __m512h, int, const int);
extern __m512h __cdecl _mm512_maskz_reduce_round_ph(__mmask32, __m512h, int, const int);


extern __m128h __cdecl _mm_reduce_sh(__m128h, __m128h, int);
extern __m128h __cdecl _mm_mask_reduce_sh(__m128h, __mmask8, __m128h, __m128h, int);
extern __m128h __cdecl _mm_maskz_reduce_sh(__mmask8, __m128h, __m128h, int);
extern __m128h __cdecl _mm_reduce_round_sh(__m128h, __m128h, int, const int);
extern __m128h __cdecl _mm_mask_reduce_round_sh(__m128h, __mmask8, __m128h, __m128h, int, const int);
extern __m128h __cdecl _mm_maskz_reduce_round_sh(__mmask8, __m128h, __m128h, int, const int);


extern __m128h __cdecl _mm_roundscale_ph(__m128h, int);
extern __m128h __cdecl _mm_mask_roundscale_ph(__m128h, __mmask8, __m128h, int);
extern __m128h __cdecl _mm_maskz_roundscale_ph(__mmask8, __m128h, int);
extern __m256h __cdecl _mm256_roundscale_ph(__m256h, int);
extern __m256h __cdecl _mm256_mask_roundscale_ph(__m256h, __mmask16, __m256h, int);
extern __m256h __cdecl _mm256_maskz_roundscale_ph(__mmask16, __m256h, int);
extern __m512h __cdecl _mm512_roundscale_ph(__m512h, int);
extern __m512h __cdecl _mm512_mask_roundscale_ph(__m512h, __mmask32, __m512h, int);
extern __m512h __cdecl _mm512_maskz_roundscale_ph(__mmask32, __m512h, int);
extern __m512h __cdecl _mm512_roundscale_round_ph(__m512h, int, const int);
extern __m512h __cdecl _mm512_mask_roundscale_round_ph(__m512h, __mmask32, __m512h, int, const int);
extern __m512h __cdecl _mm512_maskz_roundscale_round_ph(__mmask32, __m512h, int, const int);


extern __m128h __cdecl _mm_roundscale_sh(__m128h, __m128h, int);
extern __m128h __cdecl _mm_mask_roundscale_sh(__m128h, __mmask8, __m128h, __m128h, int);
extern __m128h __cdecl _mm_maskz_roundscale_sh(__mmask8, __m128h, __m128h, int);
extern __m128h __cdecl _mm_roundscale_round_sh(__m128h, __m128h, int, const int);
extern __m128h __cdecl _mm_mask_roundscale_round_sh(__m128h, __mmask8, __m128h, __m128h, int, const int);
extern __m128h __cdecl _mm_maskz_roundscale_round_sh(__mmask8, __m128h, __m128h, int, const int);


extern __m128h __cdecl _mm_rsqrt_ph(__m128h);
extern __m128h __cdecl _mm_mask_rsqrt_ph(__m128h, __mmask8, __m128h);
extern __m128h __cdecl _mm_maskz_rsqrt_ph(__mmask8, __m128h);
extern __m256h __cdecl _mm256_rsqrt_ph(__m256h);
extern __m256h __cdecl _mm256_mask_rsqrt_ph(__m256h, __mmask16, __m256h);
extern __m256h __cdecl _mm256_maskz_rsqrt_ph(__mmask16, __m256h);
extern __m512h __cdecl _mm512_rsqrt_ph(__m512h);
extern __m512h __cdecl _mm512_mask_rsqrt_ph(__m512h, __mmask32, __m512h);
extern __m512h __cdecl _mm512_maskz_rsqrt_ph(__mmask32, __m512h);


extern __m128h __cdecl _mm_rsqrt_sh(__m128h, __m128h);
extern __m128h __cdecl _mm_mask_rsqrt_sh(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_maskz_rsqrt_sh(__mmask8, __m128h, __m128h);


extern __m128h __cdecl _mm_scalef_ph(__m128h, __m128h);
extern __m128h __cdecl _mm_mask_scalef_ph(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_maskz_scalef_ph(__mmask8, __m128h, __m128h);
extern __m256h __cdecl _mm256_scalef_ph(__m256h, __m256h);
extern __m256h __cdecl _mm256_mask_scalef_ph(__m256h, __mmask16, __m256h, __m256h);
extern __m256h __cdecl _mm256_maskz_scalef_ph(__mmask16, __m256h, __m256h);
extern __m512h __cdecl _mm512_scalef_ph(__m512h, __m512h);
extern __m512h __cdecl _mm512_mask_scalef_ph(__m512h, __mmask32, __m512h, __m512h);
extern __m512h __cdecl _mm512_maskz_scalef_ph(__mmask32, __m512h, __m512h);
extern __m512h __cdecl _mm512_scalef_round_ph(__m512h, __m512h, const int);
extern __m512h __cdecl _mm512_mask_scalef_round_ph(__m512h, __mmask32, __m512h, __m512h, const int);
extern __m512h __cdecl _mm512_maskz_scalef_round_ph(__mmask32, __m512h, __m512h, const int);


extern __m128h __cdecl _mm_scalef_sh(__m128h, __m128h);
extern __m128h __cdecl _mm_mask_scalef_sh(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_maskz_scalef_sh(__mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_scalef_round_sh(__m128h, __m128h, const int);
extern __m128h __cdecl _mm_mask_scalef_round_sh(__m128h, __mmask8, __m128h, __m128h, const int);
extern __m128h __cdecl _mm_maskz_scalef_round_sh(__mmask8, __m128h, __m128h, const int);


extern __m128h __cdecl _mm_sqrt_ph(__m128h);
extern __m128h __cdecl _mm_mask_sqrt_ph(__m128h, __mmask8, __m128h);
extern __m128h __cdecl _mm_maskz_sqrt_ph(__mmask8, __m128h);
extern __m256h __cdecl _mm256_sqrt_ph(__m256h);
extern __m256h __cdecl _mm256_mask_sqrt_ph(__m256h, __mmask16, __m256h);
extern __m256h __cdecl _mm256_maskz_sqrt_ph(__mmask16, __m256h);
extern __m512h __cdecl _mm512_sqrt_ph(__m512h);
extern __m512h __cdecl _mm512_mask_sqrt_ph(__m512h, __mmask32, __m512h);
extern __m512h __cdecl _mm512_maskz_sqrt_ph(__mmask32, __m512h);
extern __m512h __cdecl _mm512_sqrt_round_ph(__m512h, const int);
extern __m512h __cdecl _mm512_mask_sqrt_round_ph(__m512h, __mmask32, __m512h, const int);
extern __m512h __cdecl _mm512_maskz_sqrt_round_ph(__mmask32, __m512h, const int);


extern __m128h __cdecl _mm_sqrt_sh(__m128h, __m128h);
extern __m128h __cdecl _mm_mask_sqrt_sh(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_maskz_sqrt_sh(__mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_sqrt_round_sh(__m128h, __m128h, const int);
extern __m128h __cdecl _mm_mask_sqrt_round_sh(__m128h, __mmask8, __m128h, __m128h, const int);
extern __m128h __cdecl _mm_maskz_sqrt_round_sh(__mmask8, __m128h, __m128h, const int);


extern __m128h __cdecl _mm_sub_ph(__m128h, __m128h);
extern __m128h __cdecl _mm_mask_sub_ph(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_maskz_sub_ph(__mmask8, __m128h, __m128h);
extern __m256h __cdecl _mm256_sub_ph(__m256h, __m256h);
extern __m256h __cdecl _mm256_mask_sub_ph(__m256h, __mmask16, __m256h, __m256h);
extern __m256h __cdecl _mm256_maskz_sub_ph(__mmask16, __m256h, __m256h);
extern __m512h __cdecl _mm512_sub_ph(__m512h, __m512h);
extern __m512h __cdecl _mm512_mask_sub_ph(__m512h, __mmask32, __m512h, __m512h);
extern __m512h __cdecl _mm512_maskz_sub_ph(__mmask32, __m512h, __m512h);
extern __m512h __cdecl _mm512_sub_round_ph(__m512h, __m512h, int);
extern __m512h __cdecl _mm512_mask_sub_round_ph(__m512h, __mmask32, __m512h, __m512h, int);
extern __m512h __cdecl _mm512_maskz_sub_round_ph(__mmask32, __m512h, __m512h, int);


extern __m128h __cdecl _mm_sub_sh(__m128h, __m128h);
extern __m128h __cdecl _mm_mask_sub_sh(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_maskz_sub_sh(__mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_sub_round_sh(__m128h, __m128h, int);
extern __m128h __cdecl _mm_mask_sub_round_sh(__m128h, __mmask8, __m128h, __m128h, int);
extern __m128h __cdecl _mm_maskz_sub_round_sh(__mmask8, __m128h, __m128h, int);

extern __m128h __cdecl _mm_mask_blend_ph (__mmask8, __m128h, __m128h);
extern __m256h __cdecl _mm256_mask_blend_ph (__mmask16, __m256h, __m256h);
extern __m512h __cdecl _mm512_mask_blend_ph (__mmask32, __m512h, __m512h);























































































































































}
#line 6283 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\zmmintrin.h"


#line 6286 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\zmmintrin.h"
#pragma external_header(pop)
#line 2468 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\immintrin.h"

#line 2470 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\immintrin.h"
#line 2471 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\immintrin.h"
#line 2472 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\immintrin.h"
#pragma external_header(pop)
#line 36 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin.h"
        #pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ammintrin.h"































#pragma once



#line 37 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ammintrin.h"



#line 41 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ammintrin.h"







#line 49 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ammintrin.h"


extern "C" {  
#line 53 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ammintrin.h"


























































































 

 
__m128 _mm_macc_ps(__m128, __m128, __m128);
__m128d _mm_macc_pd(__m128d, __m128d, __m128d);
__m128 _mm_macc_ss(__m128, __m128, __m128);
__m128d _mm_macc_sd(__m128d, __m128d, __m128d);
__m128 _mm_maddsub_ps(__m128, __m128, __m128);
__m128d _mm_maddsub_pd(__m128d, __m128d, __m128d);
__m128 _mm_msubadd_ps(__m128, __m128, __m128);
__m128d _mm_msubadd_pd(__m128d, __m128d, __m128d);
__m128 _mm_msub_ps(__m128, __m128, __m128);
__m128d _mm_msub_pd(__m128d, __m128d, __m128d);
__m128 _mm_msub_ss(__m128, __m128, __m128);
__m128d _mm_msub_sd(__m128d, __m128d, __m128d);
__m128 _mm_nmacc_ps(__m128, __m128, __m128);
__m128d _mm_nmacc_pd(__m128d, __m128d, __m128d);
__m128 _mm_nmacc_ss(__m128, __m128, __m128);
__m128d _mm_nmacc_sd(__m128d, __m128d, __m128d);
__m128 _mm_nmsub_ps(__m128, __m128, __m128);
__m128d _mm_nmsub_pd(__m128d, __m128d, __m128d);
__m128 _mm_nmsub_ss(__m128, __m128, __m128);
__m128d _mm_nmsub_sd(__m128d, __m128d, __m128d);

 
__m128i _mm_maccs_epi16(__m128i, __m128i, __m128i);
__m128i _mm_macc_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maccsd_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maccd_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maccs_epi32(__m128i, __m128i, __m128i);
__m128i _mm_macc_epi32(__m128i, __m128i, __m128i);
__m128i _mm_maccslo_epi32(__m128i, __m128i, __m128i);
__m128i _mm_macclo_epi32(__m128i, __m128i, __m128i);
__m128i _mm_maccshi_epi32(__m128i, __m128i, __m128i);
__m128i _mm_macchi_epi32(__m128i, __m128i, __m128i);
__m128i _mm_maddsd_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maddd_epi16(__m128i, __m128i, __m128i);

 
__m128i _mm_haddw_epi8(__m128i);
__m128i _mm_haddd_epi8(__m128i);
__m128i _mm_haddq_epi8(__m128i);
__m128i _mm_haddd_epi16(__m128i);
__m128i _mm_haddq_epi16(__m128i);
__m128i _mm_haddq_epi32(__m128i);
__m128i _mm_haddw_epu8(__m128i);
__m128i _mm_haddd_epu8(__m128i);
__m128i _mm_haddq_epu8(__m128i);
__m128i _mm_haddd_epu16(__m128i);
__m128i _mm_haddq_epu16(__m128i);
__m128i _mm_haddq_epu32(__m128i);
__m128i _mm_hsubw_epi8(__m128i);
__m128i _mm_hsubd_epi16(__m128i);
__m128i _mm_hsubq_epi32(__m128i);

 
__m128i _mm_cmov_si128(__m128i, __m128i, __m128i);
__m128i _mm_perm_epi8(__m128i, __m128i, __m128i);

 
__m128i _mm_rot_epi8(__m128i, __m128i);
__m128i _mm_rot_epi16(__m128i, __m128i);
__m128i _mm_rot_epi32(__m128i, __m128i);
__m128i _mm_rot_epi64(__m128i, __m128i);
__m128i _mm_roti_epi8(__m128i, int);
__m128i _mm_roti_epi16(__m128i, int);
__m128i _mm_roti_epi32(__m128i, int);
__m128i _mm_roti_epi64(__m128i, int);
__m128i _mm_shl_epi8(__m128i, __m128i);
__m128i _mm_shl_epi16(__m128i, __m128i);
__m128i _mm_shl_epi32(__m128i, __m128i);
__m128i _mm_shl_epi64(__m128i, __m128i);
__m128i _mm_sha_epi8(__m128i, __m128i);
__m128i _mm_sha_epi16(__m128i, __m128i);
__m128i _mm_sha_epi32(__m128i, __m128i);
__m128i _mm_sha_epi64(__m128i, __m128i);

 

__m128i _mm_com_epu8(__m128i, __m128i, int);
__m128i _mm_com_epu16(__m128i, __m128i, int);
__m128i _mm_com_epu32(__m128i, __m128i, int);
__m128i _mm_com_epu64(__m128i, __m128i, int);
__m128i _mm_com_epi8(__m128i, __m128i, int);
__m128i _mm_com_epi16(__m128i, __m128i, int);
__m128i _mm_com_epi32(__m128i, __m128i, int);
__m128i _mm_com_epi64(__m128i, __m128i, int);

 

__m128 _mm_frcz_ps(__m128);
__m128d _mm_frcz_pd(__m128d);
__m128 _mm_frcz_ss(__m128, __m128);
__m128d _mm_frcz_sd(__m128d, __m128d);

 

 



 
__m128 _mm_permute2_ps(__m128, __m128, __m128i, int);
__m128d _mm_permute2_pd(__m128d, __m128d, __m128i, int);


 
__m256 _mm256_macc_ps(__m256, __m256, __m256);
__m256d _mm256_macc_pd(__m256d, __m256d, __m256d);
__m256 _mm256_maddsub_ps(__m256, __m256, __m256);
__m256d _mm256_maddsub_pd(__m256d, __m256d, __m256d);
__m256 _mm256_msubadd_ps(__m256, __m256, __m256);
__m256d _mm256_msubadd_pd(__m256d, __m256d, __m256d);
__m256 _mm256_msub_ps(__m256, __m256, __m256);
__m256d _mm256_msub_pd(__m256d, __m256d, __m256d);
__m256 _mm256_nmacc_ps(__m256, __m256, __m256);
__m256d _mm256_nmacc_pd(__m256d, __m256d, __m256d);
__m256 _mm256_nmsub_ps(__m256, __m256, __m256);
__m256d _mm256_nmsub_pd(__m256d, __m256d, __m256d);
__m256i _mm256_cmov_si256(__m256i, __m256i, __m256i);
__m256 _mm256_frcz_ps(__m256);
__m256d _mm256_frcz_pd(__m256d);
__m256 _mm256_permute2_ps(__m256, __m256, __m256i, int);
__m256d _mm256_permute2_pd(__m256d, __m256d, __m256i, int);

 
void __llwpcb(void *);
void *__slwpcb(void);
void __lwpval32(unsigned int, unsigned int, unsigned int);
unsigned char __lwpins32(unsigned int, unsigned int, unsigned int);

void __lwpval64(unsigned __int64, unsigned int, unsigned int);
unsigned char __lwpins64(unsigned __int64, unsigned int, unsigned int);
#line 277 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ammintrin.h"

 
unsigned int _bextr_u32(unsigned int, unsigned int, unsigned int);
unsigned int _andn_u32(unsigned int, unsigned int);
unsigned int _tzcnt_u32(unsigned int);
unsigned int _lzcnt_u32(unsigned int);
unsigned int _blsr_u32(unsigned int);
unsigned int _blsmsk_u32(unsigned int);
unsigned int _blsi_u32(unsigned int);

unsigned __int64 _bextr_u64(unsigned __int64, unsigned int, unsigned int);
unsigned __int64 _andn_u64(unsigned __int64, unsigned __int64);
unsigned __int64 _tzcnt_u64(unsigned __int64);
unsigned __int64 _lzcnt_u64(unsigned __int64);
unsigned __int64 _blsr_u64(unsigned __int64);
unsigned __int64 _blsmsk_u64(unsigned __int64);
unsigned __int64 _blsi_u64(unsigned __int64);
#line 295 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ammintrin.h"

 
unsigned int _bextri_u32(unsigned int, unsigned int);
unsigned int _blcfill_u32(unsigned int);
unsigned int _blsfill_u32(unsigned int);
unsigned int _blcs_u32(unsigned int);
unsigned int _tzmsk_u32(unsigned int);
unsigned int _blcic_u32(unsigned int);
unsigned int _blsic_u32(unsigned int);
unsigned int _t1mskc_u32(unsigned int);
unsigned int _blcmsk_u32(unsigned int);
unsigned int _blci_u32(unsigned int);

unsigned __int64 _bextri_u64(unsigned __int64, unsigned int);
unsigned __int64 _blcfill_u64(unsigned __int64);
unsigned __int64 _blsfill_u64(unsigned __int64);
unsigned __int64 _blcs_u64(unsigned __int64);
unsigned __int64 _tzmsk_u64(unsigned __int64);
unsigned __int64 _blcic_u64(unsigned __int64);
unsigned __int64 _blsic_u64(unsigned __int64);
unsigned __int64 _t1mskc_u64(unsigned __int64);
unsigned __int64 _blcmsk_u64(unsigned __int64);
unsigned __int64 _blci_u64(unsigned __int64);
#line 319 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ammintrin.h"

void _mm_monitorx(void const *, unsigned int, unsigned int);
void _mm_mwaitx(unsigned int, unsigned int, unsigned int);

void _mm_clzero(void const *);



typedef struct rmp_seg {
    unsigned __int64 rmp_gpa;
    __int8           rmp_entry;
    __int8           rmp_pageSize;
    __int8           rmp_pageMark;
    __int8           rmp_reserved;
    __int32          rmp_ASID;
} rmp_seg;

unsigned int __rmpupdate(unsigned __int64, rmp_seg *, int);
unsigned int __pvalidate(unsigned __int64, int, int, int *);
unsigned int __psmash(unsigned __int64);
unsigned int __rmpadjust(unsigned __int64, int, int);
unsigned int __rmpquery(unsigned __int64, int, int);
#line 342 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ammintrin.h"



void __svm_invlpgb(void*, int);
void __svm_tlbsync(void);



};  
#line 352 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ammintrin.h"

#line 354 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ammintrin.h"
#line 355 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ammintrin.h"
#line 356 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ammintrin.h"
#pragma external_header(pop)
#line 37 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin.h"
    #line 38 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin.h"

    

#line 42 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin.h"

    


#line 47 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin.h"

    


#line 52 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin.h"
#line 53 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin.h"


extern "C" {
#line 57 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin.h"


void * _AddressOfReturnAddress(void);










int _cvt_dtoi_fast (double);
int _cvt_dtoi_sat (double);
int _cvt_dtoi_sent (double);
long long _cvt_dtoll_fast (double);
long long _cvt_dtoll_sat (double);
long long _cvt_dtoll_sent (double);
unsigned _cvt_dtoui_fast (double);
unsigned _cvt_dtoui_sat (double);
unsigned _cvt_dtoui_sent (double);
unsigned long long _cvt_dtoull_fast (double);
unsigned long long _cvt_dtoull_sat (double);
unsigned long long _cvt_dtoull_sent (double);
int _cvt_ftoi_fast (float);
int _cvt_ftoi_sat (float);
int _cvt_ftoi_sent (float);
long long _cvt_ftoll_fast (float);
long long _cvt_ftoll_sat (float);
long long _cvt_ftoll_sent (float);
unsigned _cvt_ftoui_fast (float);
unsigned _cvt_ftoui_sat (float);
unsigned _cvt_ftoui_sent (float);
unsigned long long _cvt_ftoull_fast (float);
unsigned long long _cvt_ftoull_sat (float);
unsigned long long _cvt_ftoull_sent (float);




long _interlockedadd(long volatile * _Addend, long _Value);

__int64 _interlockedadd64(__int64 volatile * _Addend, __int64 _Value);







short _InterlockedAnd16_np(short volatile * _Value, short _Mask);
__int64 _InterlockedAnd64_np(__int64 volatile * _Value, __int64 _Mask);
char _InterlockedAnd8_np(char volatile * _Value, char _Mask);
long _InterlockedAnd_np(long volatile * _Value, long _Mask);
unsigned char _interlockedbittestandset(long volatile *, long);



unsigned char _InterlockedCompareExchange128_np(__int64 volatile * _Destination, __int64 _ExchangeHigh, __int64 _ExchangeLow, __int64 * _ComparandResult);
short _InterlockedCompareExchange16_np(short volatile * _Destination, short _Exchange, short _Comparand);
__int64 _InterlockedCompareExchange64_np(__int64 volatile * _Destination, __int64 _Exchange, __int64 _Comparand);
void * _InterlockedCompareExchangePointer(void * volatile * _Destination, void * _Exchange, void * _Comparand);


void * _InterlockedCompareExchangePointer_np(void * volatile * _Destination, void * _Exchange, void * _Comparand);

long _InterlockedCompareExchange_np(long volatile * _Destination, long _Exchange, long _Comparand);









void * _InterlockedExchangePointer(void * volatile * _Target, void * _Value);











short _InterlockedOr16_np(short volatile * _Value, short _Mask);
__int64 _InterlockedOr64_np(__int64 volatile * _Value, __int64 _Mask);
char _InterlockedOr8_np(char volatile * _Value, char _Mask);
long _InterlockedOr_np(long volatile * _Value, long _Mask);
short _InterlockedXor16_np(short volatile * _Value, short _Mask);
__int64 _InterlockedXor64_np(__int64 volatile * _Value, __int64 _Mask);
char _InterlockedXor8_np(char volatile * _Value, char _Mask);
long _InterlockedXor_np(long volatile * _Value, long _Mask);








void _ReadBarrier(void);






void * _ReturnAddress(void);

void _WriteBarrier(void);









void __addgsbyte(unsigned long, unsigned char);
void __addgsdword(unsigned long, unsigned long);
void __addgsqword(unsigned long, unsigned __int64);
void __addgsword(unsigned long, unsigned short);




void __clts(void);
void __code_seg(const char *);
void __cpuid(int[4], int);
void __cpuidex(int[4], int, int);
void __cdecl __debugbreak(void);

__int64 __emul(int, int);
unsigned __int64 __emulu(unsigned int, unsigned int);
__declspec(noreturn) void __fastfail(unsigned int);
void __faststorefence(void);
unsigned int __getcallerseflags(void);
void __halt(void);


unsigned char __inbyte(unsigned short);
void __inbytestring(unsigned short, unsigned char *, unsigned long);



void __incgsbyte(unsigned long);
void __incgsdword(unsigned long);
void __incgsqword(unsigned long);
void __incgsword(unsigned long);




unsigned long __indword(unsigned short);
void __indwordstring(unsigned short, unsigned long *, unsigned long);
void __int2c(void);
void __invlpg(void *);
unsigned short __inword(unsigned short);
void __inwordstring(unsigned short, unsigned short *, unsigned long);
void __lidt(void *);
unsigned __int64 __ll_lshift(unsigned __int64, int);
__int64 __ll_rshift(__int64, int);
void __movsb(unsigned char *, unsigned char const *, size_t);
void __movsd(unsigned long *, unsigned long const *, size_t);
void __movsq(unsigned long long *, unsigned long long const *, size_t);
void __movsw(unsigned short *, unsigned short const *, size_t);
__int64 __mulh(__int64, __int64);
void __nop(void);
void __nvreg_restore_fence(void);
void __nvreg_save_fence(void);
void __outbyte(unsigned short, unsigned char);
void __outbytestring(unsigned short, unsigned char *, unsigned long);
void __outdword(unsigned short, unsigned long);
void __outdwordstring(unsigned short, unsigned long *, unsigned long);
void __outword(unsigned short, unsigned short);
void __outwordstring(unsigned short, unsigned short *, unsigned long);




unsigned __int64 __rdtsc(void);
unsigned __int64 __rdtscp(unsigned int *);
unsigned __int64 __readcr0(void);

unsigned __int64 __readcr2(void);

unsigned __int64 __readcr3(void);

unsigned __int64 __readcr4(void);

unsigned __int64 __readcr8(void);

unsigned __int64 __readdr(unsigned int);

unsigned __int64 __readeflags(void);





unsigned char __readgsbyte(unsigned long);
unsigned long __readgsdword(unsigned long);
unsigned __int64 __readgsqword(unsigned long);
unsigned short __readgsword(unsigned long);
unsigned __int64 __readmsr(unsigned long);
unsigned __int64 __readpmc(unsigned long);




unsigned long __segmentlimit(unsigned long);

void __sidt(void *);

void __stosb(unsigned char *, unsigned char, size_t);
void __stosd(unsigned long *, unsigned long, size_t);
void __stosq(unsigned __int64 *, unsigned __int64, size_t);
void __stosw(unsigned short *, unsigned short, size_t);
void __svm_clgi(void);
void __svm_invlpga(void *, int);
void __svm_skinit(int);
void __svm_stgi(void);
void __svm_vmload(size_t);
void __svm_vmrun(size_t);
void __svm_vmsave(size_t);





void __ud2(void);
unsigned __int64 __ull_rshift(unsigned __int64, int);
unsigned __int64 __umulh(unsigned __int64, unsigned __int64);
void __vmx_off(void);
unsigned char __vmx_on(unsigned __int64 *);
unsigned char __vmx_vmclear(unsigned __int64 *);
unsigned char __vmx_vmlaunch(void);
unsigned char __vmx_vmptrld(unsigned __int64 *);
void __vmx_vmptrst(unsigned __int64 *);
unsigned char __vmx_vmread(size_t, size_t *);
unsigned char __vmx_vmresume(void);
unsigned char __vmx_vmwrite(size_t, size_t);
void __wbinvd(void);


void __writecr0(unsigned __int64);

void __writecr2(unsigned __int64);

void __writecr3(unsigned __int64);

void __writecr4(unsigned __int64);

void __writecr8(unsigned __int64);

void __writedr(unsigned int, unsigned __int64);

void __writeeflags(unsigned __int64);





void __writegsbyte(unsigned long, unsigned char);
void __writegsdword(unsigned long, unsigned long);
void __writegsqword(unsigned long, unsigned __int64);
void __writegsword(unsigned long, unsigned short);
void __writemsr(unsigned long, unsigned __int64);




unsigned char _bittest64(__int64 const *, __int64);
unsigned char _bittestandcomplement(long *, long);
unsigned char _bittestandcomplement64(__int64 *, __int64);
unsigned char _bittestandreset(long *, long);
unsigned char _bittestandreset64(__int64 *, __int64);
unsigned char _bittestandset(long *, long);
unsigned char _bittestandset64(__int64 *, __int64);
[[nodiscard]] unsigned __int64 __cdecl _byteswap_uint64( unsigned __int64);
[[nodiscard]] unsigned long __cdecl _byteswap_ulong( unsigned long);
[[nodiscard]] unsigned short __cdecl _byteswap_ushort( unsigned short);
void __cdecl _disable(void);
void __cdecl _enable(void);
unsigned char _interlockedbittestandreset(long volatile *, long);
unsigned char _interlockedbittestandreset64(__int64 volatile *, __int64);






unsigned char _interlockedbittestandset64(__int64 volatile *, __int64);













[[nodiscard]] unsigned long __cdecl _lrotl( unsigned long, int);
[[nodiscard]] unsigned long __cdecl _lrotr( unsigned long, int);




























































void _m_prefetch(void *);
void _m_prefetchw(volatile const void *);



































__m128i _mm_abs_epi16(__m128i);
__m128i _mm_abs_epi32(__m128i);
__m128i _mm_abs_epi8(__m128i);



__m128i _mm_add_epi16(__m128i, __m128i);
__m128i _mm_add_epi32(__m128i, __m128i);
__m128i _mm_add_epi64(__m128i, __m128i);
__m128i _mm_add_epi8(__m128i, __m128i);
__m128d _mm_add_pd(__m128d, __m128d);
__m128 _mm_add_ps(__m128, __m128);
__m128d _mm_add_sd(__m128d, __m128d);

__m128 _mm_add_ss(__m128, __m128);
__m128i _mm_adds_epi16(__m128i, __m128i);
__m128i _mm_adds_epi8(__m128i, __m128i);
__m128i _mm_adds_epu16(__m128i, __m128i);
__m128i _mm_adds_epu8(__m128i, __m128i);
__m128d _mm_addsub_pd(__m128d, __m128d);
__m128 _mm_addsub_ps(__m128, __m128);
__m128i _mm_alignr_epi8(__m128i, __m128i, int);

__m128d _mm_and_pd(__m128d, __m128d);
__m128 _mm_and_ps(__m128, __m128);
__m128i _mm_and_si128(__m128i, __m128i);
__m128d _mm_andnot_pd(__m128d, __m128d);
__m128 _mm_andnot_ps(__m128, __m128);
__m128i _mm_andnot_si128(__m128i, __m128i);
__m128i _mm_avg_epu16(__m128i, __m128i);
__m128i _mm_avg_epu8(__m128i, __m128i);
__m128i _mm_blend_epi16(__m128i, __m128i, int);
__m128d _mm_blend_pd(__m128d, __m128d, int);
__m128 _mm_blend_ps(__m128, __m128, int);
__m128i _mm_blendv_epi8(__m128i, __m128i, __m128i);
__m128d _mm_blendv_pd(__m128d, __m128d, __m128d);
__m128 _mm_blendv_ps(__m128, __m128, __m128);
void _mm_clflush(void const *);
void _mm_clflushopt(void const *);
void _mm_clwb(void const *);
void _mm_clzero(void const *);
__m128i _mm_cmpeq_epi16(__m128i, __m128i);
__m128i _mm_cmpeq_epi32(__m128i, __m128i);
__m128i _mm_cmpeq_epi64(__m128i, __m128i);
__m128i _mm_cmpeq_epi8(__m128i, __m128i);
__m128d _mm_cmpeq_pd(__m128d, __m128d);
__m128 _mm_cmpeq_ps(__m128, __m128);
__m128d _mm_cmpeq_sd(__m128d, __m128d);
__m128 _mm_cmpeq_ss(__m128, __m128);
int _mm_cmpestra(__m128i, int, __m128i, int, int);
int _mm_cmpestrc(__m128i, int, __m128i, int, int);
int _mm_cmpestri(__m128i, int, __m128i, int, int);
__m128i _mm_cmpestrm(__m128i, int, __m128i, int, int);
int _mm_cmpestro(__m128i, int, __m128i, int, int);
int _mm_cmpestrs(__m128i, int, __m128i, int, int);
int _mm_cmpestrz(__m128i, int, __m128i, int, int);
__m128d _mm_cmpge_pd(__m128d, __m128d);
__m128 _mm_cmpge_ps(__m128, __m128);
__m128d _mm_cmpge_sd(__m128d, __m128d);
__m128 _mm_cmpge_ss(__m128, __m128);
__m128i _mm_cmpgt_epi16(__m128i, __m128i);
__m128i _mm_cmpgt_epi32(__m128i, __m128i);
__m128i _mm_cmpgt_epi64(__m128i, __m128i);
__m128i _mm_cmpgt_epi8(__m128i, __m128i);
__m128d _mm_cmpgt_pd(__m128d, __m128d);
__m128 _mm_cmpgt_ps(__m128, __m128);
__m128d _mm_cmpgt_sd(__m128d, __m128d);
__m128 _mm_cmpgt_ss(__m128, __m128);
int _mm_cmpistra(__m128i, __m128i, int);
int _mm_cmpistrc(__m128i, __m128i, int);
int _mm_cmpistri(__m128i, __m128i, int);
__m128i _mm_cmpistrm(__m128i, __m128i, int);
int _mm_cmpistro(__m128i, __m128i, int);
int _mm_cmpistrs(__m128i, __m128i, int);
int _mm_cmpistrz(__m128i, __m128i, int);
__m128d _mm_cmple_pd(__m128d, __m128d);
__m128 _mm_cmple_ps(__m128, __m128);
__m128d _mm_cmple_sd(__m128d, __m128d);
__m128 _mm_cmple_ss(__m128, __m128);
__m128i _mm_cmplt_epi16(__m128i, __m128i);
__m128i _mm_cmplt_epi32(__m128i, __m128i);
__m128i _mm_cmplt_epi8(__m128i, __m128i);
__m128d _mm_cmplt_pd(__m128d, __m128d);
__m128 _mm_cmplt_ps(__m128, __m128);
__m128d _mm_cmplt_sd(__m128d, __m128d);
__m128 _mm_cmplt_ss(__m128, __m128);
__m128d _mm_cmpneq_pd(__m128d, __m128d);
__m128 _mm_cmpneq_ps(__m128, __m128);
__m128d _mm_cmpneq_sd(__m128d, __m128d);
__m128 _mm_cmpneq_ss(__m128, __m128);
__m128d _mm_cmpnge_pd(__m128d, __m128d);
__m128 _mm_cmpnge_ps(__m128, __m128);
__m128d _mm_cmpnge_sd(__m128d, __m128d);
__m128 _mm_cmpnge_ss(__m128, __m128);
__m128d _mm_cmpngt_pd(__m128d, __m128d);
__m128 _mm_cmpngt_ps(__m128, __m128);
__m128d _mm_cmpngt_sd(__m128d, __m128d);
__m128 _mm_cmpngt_ss(__m128, __m128);
__m128d _mm_cmpnle_pd(__m128d, __m128d);
__m128 _mm_cmpnle_ps(__m128, __m128);
__m128d _mm_cmpnle_sd(__m128d, __m128d);
__m128 _mm_cmpnle_ss(__m128, __m128);
__m128d _mm_cmpnlt_pd(__m128d, __m128d);
__m128 _mm_cmpnlt_ps(__m128, __m128);
__m128d _mm_cmpnlt_sd(__m128d, __m128d);
__m128 _mm_cmpnlt_ss(__m128, __m128);
__m128d _mm_cmpord_pd(__m128d, __m128d);
__m128 _mm_cmpord_ps(__m128, __m128);
__m128d _mm_cmpord_sd(__m128d, __m128d);
__m128 _mm_cmpord_ss(__m128, __m128);
__m128d _mm_cmpunord_pd(__m128d, __m128d);
__m128 _mm_cmpunord_ps(__m128, __m128);
__m128d _mm_cmpunord_sd(__m128d, __m128d);
__m128 _mm_cmpunord_ss(__m128, __m128);
int _mm_comieq_sd(__m128d, __m128d);
int _mm_comieq_ss(__m128, __m128);
int _mm_comige_sd(__m128d, __m128d);
int _mm_comige_ss(__m128, __m128);
int _mm_comigt_sd(__m128d, __m128d);
int _mm_comigt_ss(__m128, __m128);
int _mm_comile_sd(__m128d, __m128d);
int _mm_comile_ss(__m128, __m128);
int _mm_comilt_sd(__m128d, __m128d);
int _mm_comilt_ss(__m128, __m128);
int _mm_comineq_sd(__m128d, __m128d);
int _mm_comineq_ss(__m128, __m128);
unsigned int _mm_crc32_u16(unsigned int, unsigned short);
unsigned int _mm_crc32_u32(unsigned int, unsigned int);
unsigned __int64 _mm_crc32_u64(unsigned __int64, unsigned __int64);
unsigned int _mm_crc32_u8(unsigned int, unsigned char);


__m128 _mm_cvt_si2ss(__m128, int);
int _mm_cvt_ss2si(__m128);
__m128i _mm_cvtepi16_epi32(__m128i);
__m128i _mm_cvtepi16_epi64(__m128i);
__m128i _mm_cvtepi32_epi64(__m128i);
__m128d _mm_cvtepi32_pd(__m128i);
__m128 _mm_cvtepi32_ps(__m128i);
__m128i _mm_cvtepi8_epi16(__m128i);
__m128i _mm_cvtepi8_epi32(__m128i);
__m128i _mm_cvtepi8_epi64(__m128i);
__m128i _mm_cvtepu16_epi32(__m128i);
__m128i _mm_cvtepu16_epi64(__m128i);
__m128i _mm_cvtepu32_epi64(__m128i);
__m128i _mm_cvtepu8_epi16(__m128i);
__m128i _mm_cvtepu8_epi32(__m128i);
__m128i _mm_cvtepu8_epi64(__m128i);
__m128i _mm_cvtpd_epi32(__m128d);

__m128 _mm_cvtpd_ps(__m128d);

__m128i _mm_cvtps_epi32(__m128);
__m128d _mm_cvtps_pd(__m128);
int _mm_cvtsd_si32(__m128d);
__int64 _mm_cvtsd_si64(__m128d);
__int64 _mm_cvtsd_si64x(__m128d);
__m128 _mm_cvtsd_ss(__m128, __m128d);
int _mm_cvtsi128_si32(__m128i);
__int64 _mm_cvtsi128_si64(__m128i);
__int64 _mm_cvtsi128_si64x(__m128i);
__m128d _mm_cvtsi32_sd(__m128d, int);
__m128i _mm_cvtsi32_si128(int);
__m128d _mm_cvtsi64_sd(__m128d, __int64);
__m128i _mm_cvtsi64_si128(__int64);
__m128 _mm_cvtsi64_ss(__m128, __int64);
__m128d _mm_cvtsi64x_sd(__m128d, __int64);
__m128i _mm_cvtsi64x_si128(__int64);
__m128 _mm_cvtsi64x_ss(__m128, __int64);
__m128d _mm_cvtss_sd(__m128d, __m128);
__int64 _mm_cvtss_si64(__m128);
__int64 _mm_cvtss_si64x(__m128);

int _mm_cvtt_ss2si(__m128);
__m128i _mm_cvttpd_epi32(__m128d);

__m128i _mm_cvttps_epi32(__m128);
int _mm_cvttsd_si32(__m128d);
__int64 _mm_cvttsd_si64(__m128d);
__int64 _mm_cvttsd_si64x(__m128d);
__int64 _mm_cvttss_si64(__m128);
__int64 _mm_cvttss_si64x(__m128);
__m128d _mm_div_pd(__m128d, __m128d);
__m128 _mm_div_ps(__m128, __m128);
__m128d _mm_div_sd(__m128d, __m128d);
__m128 _mm_div_ss(__m128, __m128);
__m128d _mm_dp_pd(__m128d, __m128d, int);
__m128 _mm_dp_ps(__m128, __m128, int);
int _mm_extract_epi16(__m128i, int);
int _mm_extract_epi32(__m128i, int);
__int64 _mm_extract_epi64(__m128i, int);
int _mm_extract_epi8(__m128i, int);
int _mm_extract_ps(__m128, int);
__m128i _mm_extract_si64(__m128i, __m128i);
__m128i _mm_extracti_si64(__m128i, int, int);
unsigned int _mm_getcsr(void);
__m128i _mm_hadd_epi16(__m128i, __m128i);
__m128i _mm_hadd_epi32(__m128i, __m128i);
__m128d _mm_hadd_pd(__m128d, __m128d);


__m128 _mm_hadd_ps(__m128, __m128);
__m128i _mm_hadds_epi16(__m128i, __m128i);

__m128i _mm_hsub_epi16(__m128i, __m128i);
__m128i _mm_hsub_epi32(__m128i, __m128i);
__m128d _mm_hsub_pd(__m128d, __m128d);


__m128 _mm_hsub_ps(__m128, __m128);
__m128i _mm_hsubs_epi16(__m128i, __m128i);

__m128i _mm_insert_epi16(__m128i, int, int);
__m128i _mm_insert_epi32(__m128i, int, int);
__m128i _mm_insert_epi64(__m128i, __int64, int);
__m128i _mm_insert_epi8(__m128i, int, int);
__m128 _mm_insert_ps(__m128, __m128, int);
__m128i _mm_insert_si64(__m128i, __m128i);
__m128i _mm_inserti_si64(__m128i, __m128i, int, int);
__m128i _mm_lddqu_si128(__m128i const *);
void _mm_lfence(void);
__m128d _mm_load1_pd(double const *);
__m128d _mm_load_pd(double const *);
__m128 _mm_load_ps(float const *);
__m128 _mm_load_ps1(float const *);
__m128d _mm_load_sd(double const *);
__m128i _mm_load_si128(__m128i const *);
__m128 _mm_load_ss(float const *);
__m128d _mm_loaddup_pd(double const *);
__m128d _mm_loadh_pd(__m128d, double const *);
__m128 _mm_loadh_pi(__m128, __m64 const *);
__m128i _mm_loadl_epi64(__m128i const *);
__m128d _mm_loadl_pd(__m128d, double const *);
__m128 _mm_loadl_pi(__m128, __m64 const *);
__m128d _mm_loadr_pd(double const *);
__m128 _mm_loadr_ps(float const *);
__m128d _mm_loadu_pd(double const *);
__m128 _mm_loadu_ps(float const *);
__m128i _mm_loadu_si128(__m128i const *);
__m128i _mm_madd_epi16(__m128i, __m128i);
__m128i _mm_maddubs_epi16(__m128i, __m128i);

void _mm_maskmoveu_si128(__m128i, __m128i, char *);
__m128i _mm_max_epi16(__m128i, __m128i);
__m128i _mm_max_epi32(__m128i, __m128i);
__m128i _mm_max_epi8(__m128i, __m128i);
__m128i _mm_max_epu16(__m128i, __m128i);
__m128i _mm_max_epu32(__m128i, __m128i);
__m128i _mm_max_epu8(__m128i, __m128i);
__m128d _mm_max_pd(__m128d, __m128d);
__m128 _mm_max_ps(__m128, __m128);
__m128d _mm_max_sd(__m128d, __m128d);
__m128 _mm_max_ss(__m128, __m128);
void _mm_mfence(void);
__m128i _mm_min_epi16(__m128i, __m128i);
__m128i _mm_min_epi32(__m128i, __m128i);
__m128i _mm_min_epi8(__m128i, __m128i);
__m128i _mm_min_epu16(__m128i, __m128i);
__m128i _mm_min_epu32(__m128i, __m128i);
__m128i _mm_min_epu8(__m128i, __m128i);
__m128d _mm_min_pd(__m128d, __m128d);
__m128 _mm_min_ps(__m128, __m128);
__m128d _mm_min_sd(__m128d, __m128d);
__m128 _mm_min_ss(__m128, __m128);
__m128i _mm_minpos_epu16(__m128i);
void _mm_monitor(void const *, unsigned int, unsigned int);
__m128i _mm_move_epi64(__m128i);
__m128d _mm_move_sd(__m128d, __m128d);
__m128 _mm_move_ss(__m128, __m128);
__m128d _mm_movedup_pd(__m128d);
__m128 _mm_movehdup_ps(__m128);
__m128 _mm_movehl_ps(__m128, __m128);
__m128 _mm_moveldup_ps(__m128);
__m128 _mm_movelh_ps(__m128, __m128);
int _mm_movemask_epi8(__m128i);
int _mm_movemask_pd(__m128d);
int _mm_movemask_ps(__m128);


__m128i _mm_mpsadbw_epu8(__m128i, __m128i, int);
__m128i _mm_mul_epi32(__m128i, __m128i);
__m128i _mm_mul_epu32(__m128i, __m128i);
__m128d _mm_mul_pd(__m128d, __m128d);
__m128 _mm_mul_ps(__m128, __m128);
__m128d _mm_mul_sd(__m128d, __m128d);
__m128 _mm_mul_ss(__m128, __m128);

__m128i _mm_mulhi_epi16(__m128i, __m128i);
__m128i _mm_mulhi_epu16(__m128i, __m128i);
__m128i _mm_mulhrs_epi16(__m128i, __m128i);

__m128i _mm_mullo_epi16(__m128i, __m128i);
__m128i _mm_mullo_epi32(__m128i, __m128i);
void _mm_mwait(unsigned int, unsigned int);
__m128d _mm_or_pd(__m128d, __m128d);
__m128 _mm_or_ps(__m128, __m128);
__m128i _mm_or_si128(__m128i, __m128i);
__m128i _mm_packs_epi16(__m128i, __m128i);
__m128i _mm_packs_epi32(__m128i, __m128i);
__m128i _mm_packus_epi16(__m128i, __m128i);
__m128i _mm_packus_epi32(__m128i, __m128i);
int _mm_popcnt_u32(unsigned int);
__int64 _mm_popcnt_u64(unsigned __int64);
void _mm_prefetch(char const *, int);
__m128 _mm_rcp_ps(__m128);
__m128 _mm_rcp_ss(__m128);
__m128d _mm_round_pd(__m128d, int);
__m128 _mm_round_ps(__m128, int);
__m128d _mm_round_sd(__m128d, __m128d, int);
__m128 _mm_round_ss(__m128, __m128, int);
__m128 _mm_rsqrt_ps(__m128);
__m128 _mm_rsqrt_ss(__m128);
__m128i _mm_sad_epu8(__m128i, __m128i);
__m128i _mm_set1_epi16(short);
__m128i _mm_set1_epi32(int);

__m128i _mm_set1_epi64x(__int64);
__m128i _mm_set1_epi8(char);
__m128d _mm_set1_pd(double);



__m128i _mm_set_epi16(short, short, short, short, short, short, short, short);
__m128i _mm_set_epi32(int, int, int, int);

__m128i _mm_set_epi64x(__int64, __int64);
__m128i _mm_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char);
__m128d _mm_set_pd(double, double);



__m128 _mm_set_ps(float, float, float, float);
__m128 _mm_set_ps1(float);
__m128d _mm_set_sd(double);
__m128 _mm_set_ss(float);
void _mm_setcsr(unsigned int);
__m128i _mm_setl_epi64(__m128i);
__m128i _mm_setr_epi16(short, short, short, short, short, short, short, short);
__m128i _mm_setr_epi32(int, int, int, int);

__m128i _mm_setr_epi64x(__int64, __int64);
__m128i _mm_setr_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char);
__m128d _mm_setr_pd(double, double);



__m128 _mm_setr_ps(float, float, float, float);
__m128d _mm_setzero_pd(void);
__m128 _mm_setzero_ps(void);
__m128i _mm_setzero_si128(void);

void _mm_sfence(void);
__m128i _mm_shuffle_epi32(__m128i, int);
__m128i _mm_shuffle_epi8(__m128i, __m128i);
__m128d _mm_shuffle_pd(__m128d, __m128d, int);

__m128 _mm_shuffle_ps(__m128, __m128, unsigned int);
__m128i _mm_shufflehi_epi16(__m128i, int);
__m128i _mm_shufflelo_epi16(__m128i, int);
__m128i _mm_sign_epi16(__m128i, __m128i);
__m128i _mm_sign_epi32(__m128i, __m128i);
__m128i _mm_sign_epi8(__m128i, __m128i);



__m128i _mm_sll_epi16(__m128i, __m128i);
__m128i _mm_sll_epi32(__m128i, __m128i);
__m128i _mm_sll_epi64(__m128i, __m128i);
__m128i _mm_slli_epi16(__m128i, int);
__m128i _mm_slli_epi32(__m128i, int);
__m128i _mm_slli_epi64(__m128i, int);
__m128i _mm_slli_si128(__m128i, int);
__m128d _mm_sqrt_pd(__m128d);
__m128 _mm_sqrt_ps(__m128);
__m128d _mm_sqrt_sd(__m128d, __m128d);
__m128 _mm_sqrt_ss(__m128);
__m128i _mm_sra_epi16(__m128i, __m128i);
__m128i _mm_sra_epi32(__m128i, __m128i);
__m128i _mm_srai_epi16(__m128i, int);
__m128i _mm_srai_epi32(__m128i, int);
__m128i _mm_srl_epi16(__m128i, __m128i);
__m128i _mm_srl_epi32(__m128i, __m128i);
__m128i _mm_srl_epi64(__m128i, __m128i);
__m128i _mm_srli_epi16(__m128i, int);
__m128i _mm_srli_epi32(__m128i, int);
__m128i _mm_srli_epi64(__m128i, int);
__m128i _mm_srli_si128(__m128i, int);
void _mm_store1_pd(double *, __m128d);
void _mm_store_pd(double *, __m128d);
void _mm_store_ps(float *, __m128);
void _mm_store_ps1(float *, __m128);
void _mm_store_sd(double *, __m128d);
void _mm_store_si128(__m128i *, __m128i);
void _mm_store_ss(float *, __m128);
void _mm_storeh_pd(double *, __m128d);
void _mm_storeh_pi(__m64 *, __m128);
void _mm_storel_epi64(__m128i *, __m128i);
void _mm_storel_pd(double *, __m128d);
void _mm_storel_pi(__m64 *, __m128);
void _mm_storer_pd(double *, __m128d);
void _mm_storer_ps(float *, __m128);
void _mm_storeu_pd(double *, __m128d);
void _mm_storeu_ps(float *, __m128);
void _mm_storeu_si128(__m128i *, __m128i);


#line 875 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin.h"
__m128i _mm_stream_load_si128(const __m128i *);
#line 877 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin.h"
void _mm_stream_pd(double *, __m128d);

void _mm_stream_ps(float *, __m128);
void _mm_stream_sd(double *, __m128d);
void _mm_stream_si128(__m128i *, __m128i);
void _mm_stream_si32(int *, int);
void _mm_stream_si64x(__int64 *, __int64);
void _mm_stream_ss(float *, __m128);
__m128i _mm_sub_epi16(__m128i, __m128i);
__m128i _mm_sub_epi32(__m128i, __m128i);
__m128i _mm_sub_epi64(__m128i, __m128i);
__m128i _mm_sub_epi8(__m128i, __m128i);
__m128d _mm_sub_pd(__m128d, __m128d);
__m128 _mm_sub_ps(__m128, __m128);
__m128d _mm_sub_sd(__m128d, __m128d);

__m128 _mm_sub_ss(__m128, __m128);
__m128i _mm_subs_epi16(__m128i, __m128i);
__m128i _mm_subs_epi8(__m128i, __m128i);
__m128i _mm_subs_epu16(__m128i, __m128i);
__m128i _mm_subs_epu8(__m128i, __m128i);
int _mm_testc_si128(__m128i, __m128i);
int _mm_testnzc_si128(__m128i, __m128i);
int _mm_testz_si128(__m128i, __m128i);
int _mm_ucomieq_sd(__m128d, __m128d);
int _mm_ucomieq_ss(__m128, __m128);
int _mm_ucomige_sd(__m128d, __m128d);
int _mm_ucomige_ss(__m128, __m128);
int _mm_ucomigt_sd(__m128d, __m128d);
int _mm_ucomigt_ss(__m128, __m128);
int _mm_ucomile_sd(__m128d, __m128d);
int _mm_ucomile_ss(__m128, __m128);
int _mm_ucomilt_sd(__m128d, __m128d);
int _mm_ucomilt_ss(__m128, __m128);
int _mm_ucomineq_sd(__m128d, __m128d);
int _mm_ucomineq_ss(__m128, __m128);
__m128i _mm_unpackhi_epi16(__m128i, __m128i);
__m128i _mm_unpackhi_epi32(__m128i, __m128i);
__m128i _mm_unpackhi_epi64(__m128i, __m128i);
__m128i _mm_unpackhi_epi8(__m128i, __m128i);
__m128d _mm_unpackhi_pd(__m128d, __m128d);
__m128 _mm_unpackhi_ps(__m128, __m128);
__m128i _mm_unpacklo_epi16(__m128i, __m128i);
__m128i _mm_unpacklo_epi32(__m128i, __m128i);
__m128i _mm_unpacklo_epi64(__m128i, __m128i);
__m128i _mm_unpacklo_epi8(__m128i, __m128i);
__m128d _mm_unpacklo_pd(__m128d, __m128d);
__m128 _mm_unpacklo_ps(__m128, __m128);
__m128d _mm_xor_pd(__m128d, __m128d);
__m128 _mm_xor_ps(__m128, __m128);
__m128i _mm_xor_si128(__m128i, __m128i);
__int64 _mul128(__int64 _Multiplier, __int64 _Multiplicand, __int64 * _HighProduct);
int __cdecl _setjmp(jmp_buf);
int __cdecl _setjmpex(jmp_buf);
void _rsm(void);
void _lgdt(void *);
void _sgdt(void *);
void _clac(void);
void _stac(void);
unsigned char __cdecl _addcarry_u8(unsigned char, unsigned char, unsigned char, unsigned char *);
unsigned char __cdecl _subborrow_u8(unsigned char, unsigned char, unsigned char, unsigned char *);
unsigned char __cdecl _addcarry_u16(unsigned char, unsigned short, unsigned short, unsigned short *);
unsigned char __cdecl _subborrow_u16(unsigned char, unsigned short, unsigned short, unsigned short *);
unsigned char __cdecl _addcarry_u32(unsigned char, unsigned int, unsigned int, unsigned int *);
unsigned char __cdecl _subborrow_u32(unsigned char, unsigned int, unsigned int, unsigned int *);
void _mm_monitorx(void const *, unsigned int, unsigned int);
void _mm_mwaitx(unsigned int, unsigned int, unsigned int);
unsigned int __rmpupdate(unsigned __int64, rmp_seg *, int);
unsigned int __psmash(unsigned __int64);
unsigned int __rmpadjust(unsigned __int64, int, int);
unsigned int __pvalidate(unsigned __int64, int, int, int*);
void __svm_invlpgb(void*, int);
void __svm_tlbsync(void);
void * _AddressOfNextInstruction(void);



    





#line 961 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin.h"

#line 963 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin.h"


}
#line 967 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin.h"
#pragma warning(pop) 
#line 969 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin.h"

#line 971 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\intrin.h"
#pragma external_header(pop)
#line 6 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\func_integer.inl"
#pragma intrinsic(_BitScanReverse)
#line 8 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\func_integer.inl"











#line 20 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\func_integer.inl"

namespace glm{
namespace detail
{
	template<typename T>
	inline T mask(T Bits)
	{
		return Bits >= static_cast<T>(sizeof(T) * 8) ? ~static_cast<T>(0) : (static_cast<T>(1) << Bits) - static_cast<T>(1);
	}

	template<length_t L, typename T, qualifier Q, bool Aligned, bool EXEC>
	struct compute_bitfieldReverseStep
	{
		inline static vec<L, T, Q> call(vec<L, T, Q> const& v, T, T)
		{
			return v;
		}
	};

	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_bitfieldReverseStep<L, T, Q, Aligned, true>
	{
		inline static vec<L, T, Q> call(vec<L, T, Q> const& v, T Mask, T Shift)
		{
			return (v & Mask) << Shift | (v & (~Mask)) >> Shift;
		}
	};

	template<length_t L, typename T, qualifier Q, bool Aligned, bool EXEC>
	struct compute_bitfieldBitCountStep
	{
		inline static vec<L, T, Q> call(vec<L, T, Q> const& v, T, T)
		{
			return v;
		}
	};

	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_bitfieldBitCountStep<L, T, Q, Aligned, true>
	{
		inline static vec<L, T, Q> call(vec<L, T, Q> const& v, T Mask, T Shift)
		{
			return (v & Mask) + ((v >> Shift) & Mask);
		}
	};

	template<typename genIUType, size_t Bits>
	struct compute_findLSB
	{
		inline static int call(genIUType Value)
		{
			if(Value == 0)
				return -1;

			return glm::bitCount(~Value & (Value - static_cast<genIUType>(1)));
		}
	};

























#line 103 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\func_integer.inl"

	template<length_t L, typename T, qualifier Q, bool EXEC = true>
	struct compute_findMSB_step_vec
	{
		inline static vec<L, T, Q> call(vec<L, T, Q> const& x, T Shift)
		{
			return x | (x >> Shift);
		}
	};

	template<length_t L, typename T, qualifier Q>
	struct compute_findMSB_step_vec<L, T, Q, false>
	{
		inline static vec<L, T, Q> call(vec<L, T, Q> const& x, T)
		{
			return x;
		}
	};

	template<length_t L, typename T, qualifier Q, int>
	struct compute_findMSB_vec
	{
		inline static vec<L, int, Q> call(vec<L, T, Q> const& v)
		{
			vec<L, T, Q> x(v);
			x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >=  8>::call(x, static_cast<T>( 1));
			x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >=  8>::call(x, static_cast<T>( 2));
			x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >=  8>::call(x, static_cast<T>( 4));
			x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >= 16>::call(x, static_cast<T>( 8));
			x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >= 32>::call(x, static_cast<T>(16));
			x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >= 64>::call(x, static_cast<T>(32));
			return vec<L, int, Q>(sizeof(T) * 8 - 1) - glm::bitCount(~x);
		}
	};





































#line 175 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\func_integer.inl"
}

	
	inline uint uaddCarry(uint const& x, uint const& y, uint & Carry)
	{
		detail::uint64 const Value64(static_cast<detail::uint64>(x) + static_cast<detail::uint64>(y));
		detail::uint64 const Max32((static_cast<detail::uint64>(1) << static_cast<detail::uint64>(32)) - static_cast<detail::uint64>(1));
		Carry = Value64 > Max32 ? 1u : 0u;
		return static_cast<uint>(Value64 % (Max32 + static_cast<detail::uint64>(1)));
	}

	template<length_t L, qualifier Q>
	inline vec<L, uint, Q> uaddCarry(vec<L, uint, Q> const& x, vec<L, uint, Q> const& y, vec<L, uint, Q>& Carry)
	{
		vec<L, detail::uint64, Q> Value64(vec<L, detail::uint64, Q>(x) + vec<L, detail::uint64, Q>(y));
		vec<L, detail::uint64, Q> Max32((static_cast<detail::uint64>(1) << static_cast<detail::uint64>(32)) - static_cast<detail::uint64>(1));
		Carry = mix(vec<L, uint, Q>(0), vec<L, uint, Q>(1), greaterThan(Value64, Max32));
		return vec<L, uint, Q>(Value64 % (Max32 + static_cast<detail::uint64>(1)));
	}

	
	inline uint usubBorrow(uint const& x, uint const& y, uint & Borrow)
	{
		Borrow = x >= y ? static_cast<uint>(0) : static_cast<uint>(1);
		if(y >= x)
			return y - x;
		else
			return static_cast<uint>((static_cast<detail::int64>(1) << static_cast<detail::int64>(32)) + (static_cast<detail::int64>(y) - static_cast<detail::int64>(x)));
	}

	template<length_t L, qualifier Q>
	inline vec<L, uint, Q> usubBorrow(vec<L, uint, Q> const& x, vec<L, uint, Q> const& y, vec<L, uint, Q>& Borrow)
	{
		Borrow = mix(vec<L, uint, Q>(1), vec<L, uint, Q>(0), greaterThanEqual(x, y));
		vec<L, uint, Q> const YgeX(y - x);
		vec<L, uint, Q> const XgeY(vec<L, uint, Q>((static_cast<detail::int64>(1) << static_cast<detail::int64>(32)) + (vec<L, detail::int64, Q>(y) - vec<L, detail::int64, Q>(x))));
		return mix(XgeY, YgeX, greaterThanEqual(y, x));
	}

	
	inline void umulExtended(uint const& x, uint const& y, uint & msb, uint & lsb)
	{
		detail::uint64 Value64 = static_cast<detail::uint64>(x) * static_cast<detail::uint64>(y);
		msb = static_cast<uint>(Value64 >> static_cast<detail::uint64>(32));
		lsb = static_cast<uint>(Value64);
	}

	template<length_t L, qualifier Q>
	inline void umulExtended(vec<L, uint, Q> const& x, vec<L, uint, Q> const& y, vec<L, uint, Q>& msb, vec<L, uint, Q>& lsb)
	{
		vec<L, detail::uint64, Q> Value64(vec<L, detail::uint64, Q>(x) * vec<L, detail::uint64, Q>(y));
		msb = vec<L, uint, Q>(Value64 >> static_cast<detail::uint64>(32));
		lsb = vec<L, uint, Q>(Value64);
	}

	
	inline void imulExtended(int x, int y, int& msb, int& lsb)
	{
		detail::int64 Value64 = static_cast<detail::int64>(x) * static_cast<detail::int64>(y);
		msb = static_cast<int>(Value64 >> static_cast<detail::int64>(32));
		lsb = static_cast<int>(Value64);
	}

	template<length_t L, qualifier Q>
	inline void imulExtended(vec<L, int, Q> const& x, vec<L, int, Q> const& y, vec<L, int, Q>& msb, vec<L, int, Q>& lsb)
	{
		vec<L, detail::int64, Q> Value64(vec<L, detail::int64, Q>(x) * vec<L, detail::int64, Q>(y));
		lsb = vec<L, int, Q>(Value64 & static_cast<detail::int64>(0xFFFFFFFF));
		msb = vec<L, int, Q>((Value64 >> static_cast<detail::int64>(32)) & static_cast<detail::int64>(0xFFFFFFFF));
	}

	
	template<typename genIUType>
	inline genIUType bitfieldExtract(genIUType Value, int Offset, int Bits)
	{
		return bitfieldExtract(vec<1, genIUType>(Value), Offset, Bits).x;
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> bitfieldExtract(vec<L, T, Q> const& Value, int Offset, int Bits)
	{
		static_assert(std::numeric_limits<T>::is_integer, "'bitfieldExtract' only accept integer inputs") ;

		return (Value >> static_cast<T>(Offset)) & static_cast<T>(detail::mask(Bits));
	}

	
	template<typename genIUType>
	inline genIUType bitfieldInsert(genIUType const& Base, genIUType const& Insert, int Offset, int Bits)
	{
		static_assert(std::numeric_limits<genIUType>::is_integer, "'bitfieldInsert' only accept integer values") ;

		return bitfieldInsert(vec<1, genIUType>(Base), vec<1, genIUType>(Insert), Offset, Bits).x;
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> bitfieldInsert(vec<L, T, Q> const& Base, vec<L, T, Q> const& Insert, int Offset, int Bits)
	{
		static_assert(std::numeric_limits<T>::is_integer, "'bitfieldInsert' only accept integer values") ;

		T const Mask = detail::mask(static_cast<T>(Bits)) << Offset;
		return (Base & ~Mask) | ((Insert << static_cast<T>(Offset)) & Mask);
	}


#pragma warning(push)
#pragma warning(disable : 4309)
#line 283 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\func_integer.inl"

	
	template<typename genIUType>
	inline genIUType bitfieldReverse(genIUType x)
	{
		static_assert(std::numeric_limits<genIUType>::is_integer, "'bitfieldReverse' only accept integer values") ;

		return bitfieldReverse(glm::vec<1, genIUType, glm::defaultp>(x)).x;
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> bitfieldReverse(vec<L, T, Q> const& v)
	{
		static_assert(std::numeric_limits<T>::is_integer, "'bitfieldReverse' only accept integer values") ;

		vec<L, T, Q> x(v);
		x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>=  2>::call(x, static_cast<T>(0x5555555555555555ull), static_cast<T>( 1));
		x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>=  4>::call(x, static_cast<T>(0x3333333333333333ull), static_cast<T>( 2));
		x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>=  8>::call(x, static_cast<T>(0x0F0F0F0F0F0F0F0Full), static_cast<T>( 4));
		x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 16>::call(x, static_cast<T>(0x00FF00FF00FF00FFull), static_cast<T>( 8));
		x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 32>::call(x, static_cast<T>(0x0000FFFF0000FFFFull), static_cast<T>(16));
		x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 64>::call(x, static_cast<T>(0x00000000FFFFFFFFull), static_cast<T>(32));
		return x;
	}


#pragma warning(pop)
#line 311 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\func_integer.inl"

	
	template<typename genIUType>
	inline int bitCount(genIUType x)
	{
		static_assert(std::numeric_limits<genIUType>::is_integer, "'bitCount' only accept integer values") ;

		return bitCount(glm::vec<1, genIUType, glm::defaultp>(x)).x;
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, int, Q> bitCount(vec<L, T, Q> const& v)
	{
		static_assert(std::numeric_limits<T>::is_integer, "'bitCount' only accept integer values") ;


#pragma warning(push)
#pragma warning(disable : 4310) 
#line 330 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\func_integer.inl"

		vec<L, typename detail::make_unsigned<T>::type, Q> x(v);
		x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>=  2>::call(x, typename detail::make_unsigned<T>::type(0x5555555555555555ull), typename detail::make_unsigned<T>::type( 1));
		x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>=  4>::call(x, typename detail::make_unsigned<T>::type(0x3333333333333333ull), typename detail::make_unsigned<T>::type( 2));
		x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>=  8>::call(x, typename detail::make_unsigned<T>::type(0x0F0F0F0F0F0F0F0Full), typename detail::make_unsigned<T>::type( 4));
		x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 16>::call(x, typename detail::make_unsigned<T>::type(0x00FF00FF00FF00FFull), typename detail::make_unsigned<T>::type( 8));
		x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 32>::call(x, typename detail::make_unsigned<T>::type(0x0000FFFF0000FFFFull), typename detail::make_unsigned<T>::type(16));
		x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 64>::call(x, typename detail::make_unsigned<T>::type(0x00000000FFFFFFFFull), typename detail::make_unsigned<T>::type(32));
		return vec<L, int, Q>(x);


#pragma warning(pop)
#line 343 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\func_integer.inl"
	}

	
	template<typename genIUType>
	inline int findLSB(genIUType Value)
	{
		static_assert(std::numeric_limits<genIUType>::is_integer, "'findLSB' only accept integer values") ;

		return detail::compute_findLSB<genIUType, sizeof(genIUType) * 8>::call(Value);
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, int, Q> findLSB(vec<L, T, Q> const& x)
	{
		static_assert(std::numeric_limits<T>::is_integer, "'findLSB' only accept integer values") ;

		return detail::functor1<vec, L, int, T, Q>::call(findLSB, x);
	}

	
	template<typename genIUType>
	inline int findMSB(genIUType v)
	{
		static_assert(std::numeric_limits<genIUType>::is_integer, "'findMSB' only accept integer values") ;

		return findMSB(vec<1, genIUType>(v)).x;
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, int, Q> findMSB(vec<L, T, Q> const& v)
	{
		static_assert(std::numeric_limits<T>::is_integer, "'findMSB' only accept integer values") ;

		return detail::compute_findMSB_vec<L, T, Q, static_cast<int>(sizeof(T) * 8)>::call(v);
	}
}








#line 388 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\func_integer.inl"



#line 392 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\func_integer.inl"

#line 213 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\integer.hpp"
#line 138 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\glm.hpp"
#line 4 "D:\\dev\\DaisyEngine\\DaisyEngine\\src\\SampleCamera.h"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\src\\Camera.h"
#pragma once

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"




#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 970 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
























































































































































































































#line 1187 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 1189 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
#line 6 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"

#pragma once






#line 15 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.hpp"



















#pragma once


#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_constants.hpp"










#pragma once


#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 970 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
























































































































































































































#line 1187 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 1189 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
#line 15 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_constants.hpp"



#line 19 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_constants.hpp"

namespace glm
{
	
	

	
	template<typename genType>
	[[nodiscard]] constexpr genType epsilon();

	
	template<typename genType>
	[[nodiscard]] constexpr genType pi();

	
	template<typename genType>
	[[nodiscard]] constexpr genType cos_one_over_two();

	
} 

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_constants.inl"


namespace glm
{
	template<typename genType>
	inline constexpr genType epsilon()
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'epsilon' only accepts floating-point inputs") ;
		return std::numeric_limits<genType>::epsilon();
	}

	template<typename genType>
	inline constexpr genType pi()
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'pi' only accepts floating-point inputs") ;
		return static_cast<genType>(3.14159265358979323846264338327950288);
	}

	template<typename genType>
	inline constexpr genType cos_one_over_two()
	{
		return genType(0.877582561890372716130286068203503191);
	}
} 
#line 41 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_constants.hpp"
#line 24 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.hpp"





#line 30 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.hpp"

namespace glm
{
	
	

	
	
	
	
	
	
	template<typename T>
	[[nodiscard]] mat<4, 4, T, defaultp> ortho(
		T left, T right, T bottom, T top);

	
	
	
	
	
	
	template<typename T>
	[[nodiscard]] mat<4, 4, T, defaultp> orthoLH_ZO(
		T left, T right, T bottom, T top, T zNear, T zFar);

	
	
	
	
	
	
	template<typename T>
	[[nodiscard]] mat<4, 4, T, defaultp> orthoLH_NO(
		T left, T right, T bottom, T top, T zNear, T zFar);

	
	
	
	
	
	
	template<typename T>
	[[nodiscard]] mat<4, 4, T, defaultp> orthoRH_ZO(
		T left, T right, T bottom, T top, T zNear, T zFar);

	
	
	
	
	
	
	template<typename T>
	[[nodiscard]] mat<4, 4, T, defaultp> orthoRH_NO(
		T left, T right, T bottom, T top, T zNear, T zFar);

	
	
	
	
	
	
	template<typename T>
	[[nodiscard]] mat<4, 4, T, defaultp> orthoZO(
		T left, T right, T bottom, T top, T zNear, T zFar);

	
	
	
	
	
	
	template<typename T>
	[[nodiscard]] mat<4, 4, T, defaultp> orthoNO(
		T left, T right, T bottom, T top, T zNear, T zFar);

	
	
	
	
	
	
	
	template<typename T>
	[[nodiscard]] mat<4, 4, T, defaultp> orthoLH(
		T left, T right, T bottom, T top, T zNear, T zFar);

	
	
	
	
	
	
	
	template<typename T>
	[[nodiscard]] mat<4, 4, T, defaultp> orthoRH(
		T left, T right, T bottom, T top, T zNear, T zFar);

	
	
	
	
	
	
	
	template<typename T>
	[[nodiscard]] mat<4, 4, T, defaultp> ortho(
		T left, T right, T bottom, T top, T zNear, T zFar);

	
	
	
	
	template<typename T>
	[[nodiscard]] mat<4, 4, T, defaultp> frustumLH_ZO(
		T left, T right, T bottom, T top, T near, T far);

	
	
	
	
	template<typename T>
	[[nodiscard]] mat<4, 4, T, defaultp> frustumLH_NO(
		T left, T right, T bottom, T top, T near, T far);

	
	
	
	
	template<typename T>
	[[nodiscard]] mat<4, 4, T, defaultp> frustumRH_ZO(
		T left, T right, T bottom, T top, T near, T far);

	
	
	
	
	template<typename T>
	[[nodiscard]] mat<4, 4, T, defaultp> frustumRH_NO(
		T left, T right, T bottom, T top, T near, T far);

	
	
	
	
	template<typename T>
	[[nodiscard]] mat<4, 4, T, defaultp> frustumZO(
		T left, T right, T bottom, T top, T near, T far);

	
	
	
	
	template<typename T>
	[[nodiscard]] mat<4, 4, T, defaultp> frustumNO(
		T left, T right, T bottom, T top, T near, T far);

	
	
	
	
	
	template<typename T>
	[[nodiscard]] mat<4, 4, T, defaultp> frustumLH(
		T left, T right, T bottom, T top, T near, T far);

	
	
	
	
	
	template<typename T>
	[[nodiscard]] mat<4, 4, T, defaultp> frustumRH(
		T left, T right, T bottom, T top, T near, T far);

	
	
	
	
	
	template<typename T>
	[[nodiscard]] mat<4, 4, T, defaultp> frustum(
		T left, T right, T bottom, T top, T near, T far);


	
	
	
	
	
	
	
	
	
	template<typename T>
	[[nodiscard]] mat<4, 4, T, defaultp> perspectiveRH_ZO(
		T fovy, T aspect, T near, T far);

	
	
	
	
	
	
	
	
	
	template<typename T>
	[[nodiscard]] mat<4, 4, T, defaultp> perspectiveRH_NO(
		T fovy, T aspect, T near, T far);

	
	
	
	
	
	
	
	
	
	template<typename T>
	[[nodiscard]] mat<4, 4, T, defaultp> perspectiveLH_ZO(
		T fovy, T aspect, T near, T far);

	
	
	
	
	
	
	
	
	
	template<typename T>
	[[nodiscard]] mat<4, 4, T, defaultp> perspectiveLH_NO(
		T fovy, T aspect, T near, T far);

	
	
	
	
	
	
	
	
	
	template<typename T>
	[[nodiscard]] mat<4, 4, T, defaultp> perspectiveZO(
		T fovy, T aspect, T near, T far);

	
	
	
	
	
	
	
	
	
	template<typename T>
	[[nodiscard]] mat<4, 4, T, defaultp> perspectiveNO(
		T fovy, T aspect, T near, T far);

	
	
	
	
	
	
	
	
	
	
	template<typename T>
	[[nodiscard]] mat<4, 4, T, defaultp> perspectiveRH(
		T fovy, T aspect, T near, T far);

	
	
	
	
	
	
	
	
	
	
	template<typename T>
	[[nodiscard]] mat<4, 4, T, defaultp> perspectiveLH(
		T fovy, T aspect, T near, T far);

	
	
	
	
	
	
	
	
	
	
	template<typename T>
	[[nodiscard]] mat<4, 4, T, defaultp> perspective(
		T fovy, T aspect, T near, T far);

	
	
	
	
	
	
	
	
	
	
	template<typename T>
	[[nodiscard]] mat<4, 4, T, defaultp> perspectiveFovRH_ZO(
		T fov, T width, T height, T near, T far);

	
	
	
	
	
	
	
	
	
	
	template<typename T>
	[[nodiscard]] mat<4, 4, T, defaultp> perspectiveFovRH_NO(
		T fov, T width, T height, T near, T far);

	
	
	
	
	
	
	
	
	
	
	template<typename T>
	[[nodiscard]] mat<4, 4, T, defaultp> perspectiveFovLH_ZO(
		T fov, T width, T height, T near, T far);

	
	
	
	
	
	
	
	
	
	
	template<typename T>
	[[nodiscard]] mat<4, 4, T, defaultp> perspectiveFovLH_NO(
		T fov, T width, T height, T near, T far);

	
	
	
	
	
	
	
	
	
	
	template<typename T>
	[[nodiscard]] mat<4, 4, T, defaultp> perspectiveFovZO(
		T fov, T width, T height, T near, T far);

	
	
	
	
	
	
	
	
	
	
	template<typename T>
	[[nodiscard]] mat<4, 4, T, defaultp> perspectiveFovNO(
		T fov, T width, T height, T near, T far);

	
	
	
	
	
	
	
	
	
	
	
	template<typename T>
	[[nodiscard]] mat<4, 4, T, defaultp> perspectiveFovRH(
		T fov, T width, T height, T near, T far);

	
	
	
	
	
	
	
	
	
	
	
	template<typename T>
	[[nodiscard]] mat<4, 4, T, defaultp> perspectiveFovLH(
		T fov, T width, T height, T near, T far);

	
	
	
	
	
	
	
	
	
	
	template<typename T>
	[[nodiscard]] mat<4, 4, T, defaultp> perspectiveFov(
		T fov, T width, T height, T near, T far);

	
	
	
	
	
	
	
	template<typename T>
	[[nodiscard]] mat<4, 4, T, defaultp> infinitePerspectiveLH(
		T fovy, T aspect, T near);

	
	
	
	
	
	
	
	template<typename T>
	[[nodiscard]] mat<4, 4, T, defaultp> infinitePerspectiveRH(
		T fovy, T aspect, T near);

	
	
	
	
	
	
	
	template<typename T>
	[[nodiscard]] mat<4, 4, T, defaultp> infinitePerspective(
		T fovy, T aspect, T near);

	
	
	
	
	
	
	
	template<typename T>
	[[nodiscard]] mat<4, 4, T, defaultp> tweakedInfinitePerspective(
		T fovy, T aspect, T near);

	
	
	
	
	
	
	
	
	template<typename T>
	[[nodiscard]] mat<4, 4, T, defaultp> tweakedInfinitePerspective(
		T fovy, T aspect, T near, T ep);

	
}

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"
namespace glm
{
	template<typename T>
	inline mat<4, 4, T, defaultp> ortho(T left, T right, T bottom, T top)
	{
		mat<4, 4, T, defaultp> Result(static_cast<T>(1));
		Result[0][0] = static_cast<T>(2) / (right - left);
		Result[1][1] = static_cast<T>(2) / (top - bottom);
		Result[2][2] = - static_cast<T>(1);
		Result[3][0] = - (right + left) / (right - left);
		Result[3][1] = - (top + bottom) / (top - bottom);
		return Result;
	}

	template<typename T>
	inline mat<4, 4, T, defaultp> orthoLH_ZO(T left, T right, T bottom, T top, T zNear, T zFar)
	{
		mat<4, 4, T, defaultp> Result(1);
		Result[0][0] = static_cast<T>(2) / (right - left);
		Result[1][1] = static_cast<T>(2) / (top - bottom);
		Result[2][2] = static_cast<T>(1) / (zFar - zNear);
		Result[3][0] = - (right + left) / (right - left);
		Result[3][1] = - (top + bottom) / (top - bottom);
		Result[3][2] = - zNear / (zFar - zNear);
		return Result;
	}

	template<typename T>
	inline mat<4, 4, T, defaultp> orthoLH_NO(T left, T right, T bottom, T top, T zNear, T zFar)
	{
		mat<4, 4, T, defaultp> Result(1);
		Result[0][0] = static_cast<T>(2) / (right - left);
		Result[1][1] = static_cast<T>(2) / (top - bottom);
		Result[2][2] = static_cast<T>(2) / (zFar - zNear);
		Result[3][0] = - (right + left) / (right - left);
		Result[3][1] = - (top + bottom) / (top - bottom);
		Result[3][2] = - (zFar + zNear) / (zFar - zNear);
		return Result;
	}

	template<typename T>
	inline mat<4, 4, T, defaultp> orthoRH_ZO(T left, T right, T bottom, T top, T zNear, T zFar)
	{
		mat<4, 4, T, defaultp> Result(1);
		Result[0][0] = static_cast<T>(2) / (right - left);
		Result[1][1] = static_cast<T>(2) / (top - bottom);
		Result[2][2] = - static_cast<T>(1) / (zFar - zNear);
		Result[3][0] = - (right + left) / (right - left);
		Result[3][1] = - (top + bottom) / (top - bottom);
		Result[3][2] = - zNear / (zFar - zNear);
		return Result;
	}

	template<typename T>
	inline mat<4, 4, T, defaultp> orthoRH_NO(T left, T right, T bottom, T top, T zNear, T zFar)
	{
		mat<4, 4, T, defaultp> Result(1);
		Result[0][0] = static_cast<T>(2) / (right - left);
		Result[1][1] = static_cast<T>(2) / (top - bottom);
		Result[2][2] = - static_cast<T>(2) / (zFar - zNear);
		Result[3][0] = - (right + left) / (right - left);
		Result[3][1] = - (top + bottom) / (top - bottom);
		Result[3][2] = - (zFar + zNear) / (zFar - zNear);
		return Result;
	}

	template<typename T>
	inline mat<4, 4, T, defaultp> orthoZO(T left, T right, T bottom, T top, T zNear, T zFar)
	{


#line 73 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"
			return orthoRH_ZO(left, right, bottom, top, zNear, zFar);
#line 75 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"
	}

	template<typename T>
	inline mat<4, 4, T, defaultp> orthoNO(T left, T right, T bottom, T top, T zNear, T zFar)
	{


#line 83 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"
			return orthoRH_NO(left, right, bottom, top, zNear, zFar);
#line 85 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"
	}

	template<typename T>
	inline mat<4, 4, T, defaultp> orthoLH(T left, T right, T bottom, T top, T zNear, T zFar)
	{


#line 93 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"
			return orthoLH_NO(left, right, bottom, top, zNear, zFar);
#line 95 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"

	}

	template<typename T>
	inline mat<4, 4, T, defaultp> orthoRH(T left, T right, T bottom, T top, T zNear, T zFar)
	{


#line 104 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"
			return orthoRH_NO(left, right, bottom, top, zNear, zFar);
#line 106 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"
	}

	template<typename T>
	inline mat<4, 4, T, defaultp> ortho(T left, T right, T bottom, T top, T zNear, T zFar)
	{


#line 114 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"

#line 116 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"

#line 118 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"
			return orthoRH_NO(left, right, bottom, top, zNear, zFar);
#line 120 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"
	}

	template<typename T>
	inline mat<4, 4, T, defaultp> frustumLH_ZO(T left, T right, T bottom, T top, T nearVal, T farVal)
	{
		mat<4, 4, T, defaultp> Result(0);
		Result[0][0] = (static_cast<T>(2) * nearVal) / (right - left);
		Result[1][1] = (static_cast<T>(2) * nearVal) / (top - bottom);
		Result[2][0] = -(right + left) / (right - left);
		Result[2][1] = -(top + bottom) / (top - bottom);
		Result[2][2] = farVal / (farVal - nearVal);
		Result[2][3] = static_cast<T>(1);
		Result[3][2] = -(farVal * nearVal) / (farVal - nearVal);
		return Result;
	}

	template<typename T>
	inline mat<4, 4, T, defaultp> frustumLH_NO(T left, T right, T bottom, T top, T nearVal, T farVal)
	{
		mat<4, 4, T, defaultp> Result(0);
		Result[0][0] = (static_cast<T>(2) * nearVal) / (right - left);
		Result[1][1] = (static_cast<T>(2) * nearVal) / (top - bottom);
		Result[2][0] = -(right + left) / (right - left);
		Result[2][1] = -(top + bottom) / (top - bottom);
		Result[2][2] = (farVal + nearVal) / (farVal - nearVal);
		Result[2][3] = static_cast<T>(1);
		Result[3][2] = - (static_cast<T>(2) * farVal * nearVal) / (farVal - nearVal);
		return Result;
	}

	template<typename T>
	inline mat<4, 4, T, defaultp> frustumRH_ZO(T left, T right, T bottom, T top, T nearVal, T farVal)
	{
		mat<4, 4, T, defaultp> Result(0);
		Result[0][0] = (static_cast<T>(2) * nearVal) / (right - left);
		Result[1][1] = (static_cast<T>(2) * nearVal) / (top - bottom);
		Result[2][0] = (right + left) / (right - left);
		Result[2][1] = (top + bottom) / (top - bottom);
		Result[2][2] = farVal / (nearVal - farVal);
		Result[2][3] = static_cast<T>(-1);
		Result[3][2] = -(farVal * nearVal) / (farVal - nearVal);
		return Result;
	}

	template<typename T>
	inline mat<4, 4, T, defaultp> frustumRH_NO(T left, T right, T bottom, T top, T nearVal, T farVal)
	{
		mat<4, 4, T, defaultp> Result(0);
		Result[0][0] = (static_cast<T>(2) * nearVal) / (right - left);
		Result[1][1] = (static_cast<T>(2) * nearVal) / (top - bottom);
		Result[2][0] = (right + left) / (right - left);
		Result[2][1] = (top + bottom) / (top - bottom);
		Result[2][2] = - (farVal + nearVal) / (farVal - nearVal);
		Result[2][3] = static_cast<T>(-1);
		Result[3][2] = - (static_cast<T>(2) * farVal * nearVal) / (farVal - nearVal);
		return Result;
	}

	template<typename T>
	inline mat<4, 4, T, defaultp> frustumZO(T left, T right, T bottom, T top, T nearVal, T farVal)
	{


#line 184 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"
			return frustumRH_ZO(left, right, bottom, top, nearVal, farVal);
#line 186 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"
	}

	template<typename T>
	inline mat<4, 4, T, defaultp> frustumNO(T left, T right, T bottom, T top, T nearVal, T farVal)
	{


#line 194 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"
			return frustumRH_NO(left, right, bottom, top, nearVal, farVal);
#line 196 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"
	}

	template<typename T>
	inline mat<4, 4, T, defaultp> frustumLH(T left, T right, T bottom, T top, T nearVal, T farVal)
	{


#line 204 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"
			return frustumLH_NO(left, right, bottom, top, nearVal, farVal);
#line 206 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"
	}

	template<typename T>
	inline mat<4, 4, T, defaultp> frustumRH(T left, T right, T bottom, T top, T nearVal, T farVal)
	{


#line 214 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"
			return frustumRH_NO(left, right, bottom, top, nearVal, farVal);
#line 216 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"
	}

	template<typename T>
	inline mat<4, 4, T, defaultp> frustum(T left, T right, T bottom, T top, T nearVal, T farVal)
	{


#line 224 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"

#line 226 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"

#line 228 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"
			return frustumRH_NO(left, right, bottom, top, nearVal, farVal);
#line 230 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"
	}

	template<typename T>
	inline mat<4, 4, T, defaultp> perspectiveRH_ZO(T fovy, T aspect, T zNear, T zFar)
	{
		(void)( (!!(abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0))) || (_wassert(L"abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0)", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl", (unsigned)(235)), 0) ) ;

		T const tanHalfFovy = tan(fovy / static_cast<T>(2));

		mat<4, 4, T, defaultp> Result(static_cast<T>(0));
		Result[0][0] = static_cast<T>(1) / (aspect * tanHalfFovy);
		Result[1][1] = static_cast<T>(1) / (tanHalfFovy);
		Result[2][2] = zFar / (zNear - zFar);
		Result[2][3] = - static_cast<T>(1);
		Result[3][2] = -(zFar * zNear) / (zFar - zNear);
		return Result;
	}

	template<typename T>
	inline mat<4, 4, T, defaultp> perspectiveRH_NO(T fovy, T aspect, T zNear, T zFar)
	{
		(void)( (!!(abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0))) || (_wassert(L"abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0)", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl", (unsigned)(251)), 0) ) ;

		T const tanHalfFovy = tan(fovy / static_cast<T>(2));

		mat<4, 4, T, defaultp> Result(static_cast<T>(0));
		Result[0][0] = static_cast<T>(1) / (aspect * tanHalfFovy);
		Result[1][1] = static_cast<T>(1) / (tanHalfFovy);
		Result[2][2] = - (zFar + zNear) / (zFar - zNear);
		Result[2][3] = - static_cast<T>(1);
		Result[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);
		return Result;
	}

	template<typename T>
	inline mat<4, 4, T, defaultp> perspectiveLH_ZO(T fovy, T aspect, T zNear, T zFar)
	{
		(void)( (!!(abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0))) || (_wassert(L"abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0)", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl", (unsigned)(267)), 0) ) ;

		T const tanHalfFovy = tan(fovy / static_cast<T>(2));

		mat<4, 4, T, defaultp> Result(static_cast<T>(0));
		Result[0][0] = static_cast<T>(1) / (aspect * tanHalfFovy);
		Result[1][1] = static_cast<T>(1) / (tanHalfFovy);
		Result[2][2] = zFar / (zFar - zNear);
		Result[2][3] = static_cast<T>(1);
		Result[3][2] = -(zFar * zNear) / (zFar - zNear);
		return Result;
	}

	template<typename T>
	inline mat<4, 4, T, defaultp> perspectiveLH_NO(T fovy, T aspect, T zNear, T zFar)
	{
		(void)( (!!(abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0))) || (_wassert(L"abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0)", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl", (unsigned)(283)), 0) ) ;

		T const tanHalfFovy = tan(fovy / static_cast<T>(2));

		mat<4, 4, T, defaultp> Result(static_cast<T>(0));
		Result[0][0] = static_cast<T>(1) / (aspect * tanHalfFovy);
		Result[1][1] = static_cast<T>(1) / (tanHalfFovy);
		Result[2][2] = (zFar + zNear) / (zFar - zNear);
		Result[2][3] = static_cast<T>(1);
		Result[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);
		return Result;
	}

	template<typename T>
	inline mat<4, 4, T, defaultp> perspectiveZO(T fovy, T aspect, T zNear, T zFar)
	{


#line 302 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"
			return perspectiveRH_ZO(fovy, aspect, zNear, zFar);
#line 304 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"
	}

	template<typename T>
	inline mat<4, 4, T, defaultp> perspectiveNO(T fovy, T aspect, T zNear, T zFar)
	{


#line 312 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"
			return perspectiveRH_NO(fovy, aspect, zNear, zFar);
#line 314 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"
	}

	template<typename T>
	inline mat<4, 4, T, defaultp> perspectiveLH(T fovy, T aspect, T zNear, T zFar)
	{


#line 322 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"
			return perspectiveLH_NO(fovy, aspect, zNear, zFar);
#line 324 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"

	}

	template<typename T>
	inline mat<4, 4, T, defaultp> perspectiveRH(T fovy, T aspect, T zNear, T zFar)
	{


#line 333 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"
			return perspectiveRH_NO(fovy, aspect, zNear, zFar);
#line 335 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"
	}

	template<typename T>
	inline mat<4, 4, T, defaultp> perspective(T fovy, T aspect, T zNear, T zFar)
	{


#line 343 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"

#line 345 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"

#line 347 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"
			return perspectiveRH_NO(fovy, aspect, zNear, zFar);
#line 349 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"
	}

	template<typename T>
	inline mat<4, 4, T, defaultp> perspectiveFovRH_ZO(T fov, T width, T height, T zNear, T zFar)
	{
		(void)( (!!(width > static_cast<T>(0))) || (_wassert(L"width > static_cast<T>(0)", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl", (unsigned)(354)), 0) ) ;
		(void)( (!!(height > static_cast<T>(0))) || (_wassert(L"height > static_cast<T>(0)", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl", (unsigned)(355)), 0) ) ;
		(void)( (!!(fov > static_cast<T>(0))) || (_wassert(L"fov > static_cast<T>(0)", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl", (unsigned)(356)), 0) ) ;

		T const rad = fov;
		T const h = glm::cos(static_cast<T>(0.5) * rad) / glm::sin(static_cast<T>(0.5) * rad);
		T const w = h * height / width; 

		mat<4, 4, T, defaultp> Result(static_cast<T>(0));
		Result[0][0] = w;
		Result[1][1] = h;
		Result[2][2] = zFar / (zNear - zFar);
		Result[2][3] = - static_cast<T>(1);
		Result[3][2] = -(zFar * zNear) / (zFar - zNear);
		return Result;
	}

	template<typename T>
	inline mat<4, 4, T, defaultp> perspectiveFovRH_NO(T fov, T width, T height, T zNear, T zFar)
	{
		(void)( (!!(width > static_cast<T>(0))) || (_wassert(L"width > static_cast<T>(0)", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl", (unsigned)(374)), 0) ) ;
		(void)( (!!(height > static_cast<T>(0))) || (_wassert(L"height > static_cast<T>(0)", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl", (unsigned)(375)), 0) ) ;
		(void)( (!!(fov > static_cast<T>(0))) || (_wassert(L"fov > static_cast<T>(0)", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl", (unsigned)(376)), 0) ) ;

		T const rad = fov;
		T const h = glm::cos(static_cast<T>(0.5) * rad) / glm::sin(static_cast<T>(0.5) * rad);
		T const w = h * height / width; 

		mat<4, 4, T, defaultp> Result(static_cast<T>(0));
		Result[0][0] = w;
		Result[1][1] = h;
		Result[2][2] = - (zFar + zNear) / (zFar - zNear);
		Result[2][3] = - static_cast<T>(1);
		Result[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);
		return Result;
	}

	template<typename T>
	inline mat<4, 4, T, defaultp> perspectiveFovLH_ZO(T fov, T width, T height, T zNear, T zFar)
	{
		(void)( (!!(width > static_cast<T>(0))) || (_wassert(L"width > static_cast<T>(0)", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl", (unsigned)(394)), 0) ) ;
		(void)( (!!(height > static_cast<T>(0))) || (_wassert(L"height > static_cast<T>(0)", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl", (unsigned)(395)), 0) ) ;
		(void)( (!!(fov > static_cast<T>(0))) || (_wassert(L"fov > static_cast<T>(0)", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl", (unsigned)(396)), 0) ) ;

		T const rad = fov;
		T const h = glm::cos(static_cast<T>(0.5) * rad) / glm::sin(static_cast<T>(0.5) * rad);
		T const w = h * height / width; 

		mat<4, 4, T, defaultp> Result(static_cast<T>(0));
		Result[0][0] = w;
		Result[1][1] = h;
		Result[2][2] = zFar / (zFar - zNear);
		Result[2][3] = static_cast<T>(1);
		Result[3][2] = -(zFar * zNear) / (zFar - zNear);
		return Result;
	}

	template<typename T>
	inline mat<4, 4, T, defaultp> perspectiveFovLH_NO(T fov, T width, T height, T zNear, T zFar)
	{
		(void)( (!!(width > static_cast<T>(0))) || (_wassert(L"width > static_cast<T>(0)", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl", (unsigned)(414)), 0) ) ;
		(void)( (!!(height > static_cast<T>(0))) || (_wassert(L"height > static_cast<T>(0)", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl", (unsigned)(415)), 0) ) ;
		(void)( (!!(fov > static_cast<T>(0))) || (_wassert(L"fov > static_cast<T>(0)", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl", (unsigned)(416)), 0) ) ;

		T const rad = fov;
		T const h = glm::cos(static_cast<T>(0.5) * rad) / glm::sin(static_cast<T>(0.5) * rad);
		T const w = h * height / width; 

		mat<4, 4, T, defaultp> Result(static_cast<T>(0));
		Result[0][0] = w;
		Result[1][1] = h;
		Result[2][2] = (zFar + zNear) / (zFar - zNear);
		Result[2][3] = static_cast<T>(1);
		Result[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);
		return Result;
	}

	template<typename T>
	inline mat<4, 4, T, defaultp> perspectiveFovZO(T fov, T width, T height, T zNear, T zFar)
	{


#line 437 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"
			return perspectiveFovRH_ZO(fov, width, height, zNear, zFar);
#line 439 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"
	}

	template<typename T>
	inline mat<4, 4, T, defaultp> perspectiveFovNO(T fov, T width, T height, T zNear, T zFar)
	{


#line 447 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"
			return perspectiveFovRH_NO(fov, width, height, zNear, zFar);
#line 449 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"
	}

	template<typename T>
	inline mat<4, 4, T, defaultp> perspectiveFovLH(T fov, T width, T height, T zNear, T zFar)
	{


#line 457 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"
			return perspectiveFovLH_NO(fov, width, height, zNear, zFar);
#line 459 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"
	}

	template<typename T>
	inline mat<4, 4, T, defaultp> perspectiveFovRH(T fov, T width, T height, T zNear, T zFar)
	{


#line 467 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"
			return perspectiveFovRH_NO(fov, width, height, zNear, zFar);
#line 469 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"
	}

	template<typename T>
	inline mat<4, 4, T, defaultp> perspectiveFov(T fov, T width, T height, T zNear, T zFar)
	{


#line 477 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"

#line 479 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"

#line 481 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"
			return perspectiveFovRH_NO(fov, width, height, zNear, zFar);
#line 483 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"
	}

	template<typename T>
	inline mat<4, 4, T, defaultp> infinitePerspectiveRH_NO(T fovy, T aspect, T zNear)
	{
		T const range = tan(fovy / static_cast<T>(2)) * zNear;
		T const left = -range * aspect;
		T const right = range * aspect;
		T const bottom = -range;
		T const top = range;

		mat<4, 4, T, defaultp> Result(static_cast<T>(0));
		Result[0][0] = (static_cast<T>(2) * zNear) / (right - left);
		Result[1][1] = (static_cast<T>(2) * zNear) / (top - bottom);
		Result[2][2] = - static_cast<T>(1);
		Result[2][3] = - static_cast<T>(1);
		Result[3][2] = - static_cast<T>(2) * zNear;
		return Result;
	}
	
	template<typename T>
	inline mat<4, 4, T, defaultp> infinitePerspectiveRH_ZO(T fovy, T aspect, T zNear)
	{
		T const range = tan(fovy / static_cast<T>(2)) * zNear;
		T const left = -range * aspect;
		T const right = range * aspect;
		T const bottom = -range;
		T const top = range;

		mat<4, 4, T, defaultp> Result(static_cast<T>(0));
		Result[0][0] = (static_cast<T>(2) * zNear) / (right - left);
		Result[1][1] = (static_cast<T>(2) * zNear) / (top - bottom);
		Result[2][2] = - static_cast<T>(1);
		Result[2][3] = - static_cast<T>(1);
		Result[3][2] = - zNear;
		return Result;
	}

	template<typename T>
	inline mat<4, 4, T, defaultp> infinitePerspectiveLH_NO(T fovy, T aspect, T zNear)
	{
		T const range = tan(fovy / static_cast<T>(2)) * zNear;
		T const left = -range * aspect;
		T const right = range * aspect;
		T const bottom = -range;
		T const top = range;

		mat<4, 4, T, defaultp> Result(T(0));
		Result[0][0] = (static_cast<T>(2) * zNear) / (right - left);
		Result[1][1] = (static_cast<T>(2) * zNear) / (top - bottom);
		Result[2][2] = static_cast<T>(1);
		Result[2][3] = static_cast<T>(1);
		Result[3][2] = - static_cast<T>(2) * zNear;
		return Result;
	}

	template<typename T>
	inline mat<4, 4, T, defaultp> infinitePerspectiveLH_ZO(T fovy, T aspect, T zNear)
	{
		T const range = tan(fovy / static_cast<T>(2)) * zNear;
		T const left = -range * aspect;
		T const right = range * aspect;
		T const bottom = -range;
		T const top = range;

		mat<4, 4, T, defaultp> Result(T(0));
		Result[0][0] = (static_cast<T>(2) * zNear) / (right - left);
		Result[1][1] = (static_cast<T>(2) * zNear) / (top - bottom);
		Result[2][2] = static_cast<T>(1);
		Result[2][3] = static_cast<T>(1);
		Result[3][2] = - zNear;
		return Result;
	}

	template<typename T>
	inline mat<4, 4, T, defaultp> infinitePerspective(T fovy, T aspect, T zNear)
	{


#line 563 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"

#line 565 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"

#line 567 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"
			return infinitePerspectiveRH_NO(fovy, aspect, zNear);
#line 569 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.inl"
	}

	
	template<typename T>
	inline mat<4, 4, T, defaultp> tweakedInfinitePerspective(T fovy, T aspect, T zNear, T ep)
	{
		T const range = tan(fovy / static_cast<T>(2)) * zNear;
		T const left = -range * aspect;
		T const right = range * aspect;
		T const bottom = -range;
		T const top = range;

		mat<4, 4, T, defaultp> Result(static_cast<T>(0));
		Result[0][0] = (static_cast<T>(2) * zNear) / (right - left);
		Result[1][1] = (static_cast<T>(2) * zNear) / (top - bottom);
		Result[2][2] = ep - static_cast<T>(1);
		Result[2][3] = static_cast<T>(-1);
		Result[3][2] = (ep - static_cast<T>(2)) * zNear;
		return Result;
	}

	template<typename T>
	inline mat<4, 4, T, defaultp> tweakedInfinitePerspective(T fovy, T aspect, T zNear)
	{
		return tweakedInfinitePerspective(fovy, aspect, zNear, epsilon<T>());
	}
}
#line 523 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_clip_space.hpp"
#line 17 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_common.hpp"












#pragma once


#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\_fixes.hpp"



























#line 17 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_common.hpp"



#line 21 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_common.hpp"

namespace glm
{
	
	

	template<length_t C, length_t R, typename T, typename U, qualifier Q>
	[[nodiscard]] mat<C, R, T, Q> mix(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y, mat<C, R, U, Q> const& a);

	template<length_t C, length_t R, typename T, typename U, qualifier Q>
	[[nodiscard]] mat<C, R, T, Q> mix(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y, U a);

	template <length_t C, length_t R, typename T, qualifier Q>
	[[nodiscard]] constexpr mat<C, R, T, Q> abs(mat<C, R, T, Q> const& x);

	
}

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_common.inl"


#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\_matrix_vectorize.hpp"
#pragma once

namespace glm {

	namespace detail {

		template<template<length_t C, length_t R, typename T, qualifier Q> class mat, length_t C, length_t R, typename Ret, typename T, qualifier Q>
		struct matrix_functor_1 {
		};

		template<template<length_t C, length_t R, typename T, qualifier Q> class mat, typename Ret, typename T, qualifier Q>
		struct matrix_functor_1<mat, 2, 2, Ret, T, Q> {
			inline constexpr static mat<2, 2, T, Q> call(Ret (*Func)(T x), mat<2, 2, T, Q> const &x) {
				return mat<2, 2, Ret, Q>(
					Func(x[0][0]), Func(x[0][1]),
					Func(x[1][0]), Func(x[1][1])
				);
			}
		};

		template<template<length_t C, length_t R, typename T, qualifier Q> class mat, typename Ret, typename T, qualifier Q>
		struct matrix_functor_1<mat, 2, 3, Ret, T, Q> {

			inline constexpr static mat<2, 3, T, Q> call(Ret (*Func)(T x), mat<2, 3, T, Q> const &x) {
				return mat<2, 3, Ret, Q>(
					Func(x[0][0]), Func(x[0][1]), Func(x[0][2]),
					Func(x[1][0]), Func(x[1][1]), Func(x[1][2])
				);
			}

		};

		template<template<length_t C, length_t R, typename T, qualifier Q> class mat, typename Ret, typename T, qualifier Q>
		struct matrix_functor_1<mat, 2, 4, Ret, T, Q> {

			inline constexpr static mat<2, 4, T, Q> call(Ret (*Func)(T x), mat<2, 4, T, Q> const &x) {
				return mat<2, 4, Ret, Q>(
					Func(x[0][0]), Func(x[0][1]), Func(x[0][2]), Func(x[0][3]),
					Func(x[1][0]), Func(x[1][1]), Func(x[1][2]), Func(x[1][3])
				);
			}

		};

		template<template<length_t C, length_t R, typename T, qualifier Q> class mat, typename Ret, typename T, qualifier Q>
		struct matrix_functor_1<mat, 3, 2, Ret, T, Q> {

			inline constexpr static mat<3, 2, T, Q> call(Ret (*Func)(T x), mat<3, 2, T, Q> const &x) {
				return mat<3, 2, Ret, Q>(
					Func(x[0][0]), Func(x[0][1]),
					Func(x[1][0]), Func(x[1][1]),
					Func(x[2][0]), Func(x[2][1])
				);
			}

		};

		template<template<length_t C, length_t R, typename T, qualifier Q> class mat, typename Ret, typename T, qualifier Q>
		struct matrix_functor_1<mat, 3, 3, Ret, T, Q> {

			inline constexpr static mat<3, 3, T, Q> call(Ret (*Func)(T x), mat<3, 3, T, Q> const &x) {
				return mat<3, 3, Ret, Q>(
					Func(x[0][0]), Func(x[0][1]), Func(x[0][2]),
					Func(x[1][0]), Func(x[1][1]), Func(x[1][2]),
					Func(x[2][0]), Func(x[2][1]), Func(x[2][2])
				);
			}

		};

		template<template<length_t C, length_t R, typename T, qualifier Q> class mat, typename Ret, typename T, qualifier Q>
		struct matrix_functor_1<mat, 3, 4, Ret, T, Q> {

			inline constexpr static mat<3, 4, T, Q> call(Ret (*Func)(T x), mat<3, 4, T, Q> const &x) {
				return mat<3, 4, Ret, Q>(
					Func(x[0][0]), Func(x[0][1]), Func(x[0][2]), Func(x[0][3]),
					Func(x[1][0]), Func(x[1][1]), Func(x[1][2]), Func(x[1][3]),
					Func(x[2][0]), Func(x[2][1]), Func(x[2][2]), Func(x[2][3])
				);
			}

		};

		template<template<length_t C, length_t R, typename T, qualifier Q> class mat, typename Ret, typename T, qualifier Q>
		struct matrix_functor_1<mat, 4, 2, Ret, T, Q> {

			inline constexpr static mat<4, 2, T, Q> call(Ret (*Func)(T x), mat<4, 2, T, Q> const &x) {
				return mat<4, 2, Ret, Q>(
					Func(x[0][0]), Func(x[0][1]),
					Func(x[1][0]), Func(x[1][1]),
					Func(x[2][0]), Func(x[2][1]),
					Func(x[3][0]), Func(x[3][1])
				);
			}

		};

		template<template<length_t C, length_t R, typename T, qualifier Q> class mat, typename Ret, typename T, qualifier Q>
		struct matrix_functor_1<mat, 4, 3, Ret, T, Q> {

			inline constexpr static mat<4, 3, T, Q> call(Ret (*Func)(T x), mat<4, 3, T, Q> const &x) {
				return mat<4, 3, Ret, Q>(
					Func(x[0][0]), Func(x[0][1]), Func(x[0][2]),
					Func(x[1][0]), Func(x[1][1]), Func(x[1][2]),
					Func(x[2][0]), Func(x[2][1]), Func(x[2][2]),
					Func(x[3][0]), Func(x[3][1]), Func(x[3][2])
				);
			}

		};

		template<template<length_t C, length_t R, typename T, qualifier Q> class mat, typename Ret, typename T, qualifier Q>
		struct matrix_functor_1<mat, 4, 4, Ret, T, Q> {

			inline constexpr static mat<4, 4, T, Q> call(Ret (*Func)(T x), mat<4, 4, T, Q> const &x) {
				return mat<4, 4, Ret, Q>(
					Func(x[0][0]), Func(x[0][1]), Func(x[0][2]), Func(x[0][3]),
					Func(x[1][0]), Func(x[1][1]), Func(x[1][2]), Func(x[1][3]),
					Func(x[2][0]), Func(x[2][1]), Func(x[2][2]), Func(x[2][3]),
					Func(x[3][0]), Func(x[3][1]), Func(x[3][2]), Func(x[3][3])
				);
			}

		};

	}

}
#line 4 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_common.inl"

namespace glm
{
	template<length_t C, length_t R, typename T, typename U, qualifier Q>
	inline mat<C, R, T, Q> mix(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y, U a)
	{
		return mat<C, R, U, Q>(x) * (static_cast<U>(1) - a) + mat<C, R, U, Q>(y) * a;
	}

	template<length_t C, length_t R, typename T, typename U, qualifier Q>
	inline mat<C, R, T, Q> mix(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y, mat<C, R, U, Q> const& a)
	{
		return matrixCompMult(mat<C, R, U, Q>(x), static_cast<U>(1) - a) + matrixCompMult(mat<C, R, U, Q>(y), a);
	}

	template<length_t C, length_t R, typename T, qualifier Q, bool Aligned>
	struct compute_abs_matrix
	{
		inline constexpr static mat<C, R, T, Q> call(mat<C, R, T, Q> const& x)
		{
			return detail::matrix_functor_1<mat, C, R, T, T, Q>::call(abs, x);
		}
	};

	template<length_t C, length_t R, typename T, qualifier Q>
	[[nodiscard]] constexpr mat<C, R, T, Q> abs(mat<C, R, T, Q> const& x)
	{
		return compute_abs_matrix<C, R, T, Q, detail::is_aligned<Q>::value>::call(x);
	}

}
#line 40 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_common.hpp"
#line 18 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"







































#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_int2x2.hpp"












#pragma once






#line 21 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_int2x2.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<2, 2, int, defaultp>	imat2x2;

	
	
	
	typedef mat<2, 2, int, defaultp>	imat2;

	
}
#line 58 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_int2x2_sized.hpp"












#pragma once







#line 22 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_int2x2_sized.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<2, 2, int8, defaultp>				i8mat2x2;

	
	
	
	typedef mat<2, 2, int16, defaultp>				i16mat2x2;

	
	
	
	typedef mat<2, 2, int32, defaultp>				i32mat2x2;

	
	
	
	typedef mat<2, 2, int64, defaultp>				i64mat2x2;


	
	
	
	typedef mat<2, 2, int8, defaultp>				i8mat2;

	
	
	
	typedef mat<2, 2, int16, defaultp>				i16mat2;

	
	
	
	typedef mat<2, 2, int32, defaultp>				i32mat2;

	
	
	
	typedef mat<2, 2, int64, defaultp>				i64mat2;

	
}
#line 59 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_int2x3.hpp"












#pragma once






#line 21 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_int2x3.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<2, 3, int, defaultp>	imat2x3;

	
}
#line 60 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_int2x3_sized.hpp"












#pragma once







#line 22 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_int2x3_sized.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<2, 3, int8, defaultp>				i8mat2x3;

	
	
	
	typedef mat<2, 3, int16, defaultp>				i16mat2x3;

	
	
	
	typedef mat<2, 3, int32, defaultp>				i32mat2x3;

	
	
	
	typedef mat<2, 3, int64, defaultp>				i64mat2x3;

	
}
#line 61 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_int2x4.hpp"












#pragma once






#line 21 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_int2x4.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<2, 4, int, defaultp>	imat2x4;

	
}
#line 62 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_int2x4_sized.hpp"












#pragma once







#line 22 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_int2x4_sized.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<2, 4, int8, defaultp>				i8mat2x4;

	
	
	
	typedef mat<2, 4, int16, defaultp>				i16mat2x4;

	
	
	
	typedef mat<2, 4, int32, defaultp>				i32mat2x4;

	
	
	
	typedef mat<2, 4, int64, defaultp>				i64mat2x4;

	
}
#line 63 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_int3x2.hpp"












#pragma once






#line 21 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_int3x2.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<3, 2, int, defaultp>	imat3x2;

	
}
#line 64 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_int3x2_sized.hpp"












#pragma once







#line 22 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_int3x2_sized.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<3, 2, int8, defaultp>				i8mat3x2;

	
	
	
	typedef mat<3, 2, int16, defaultp>				i16mat3x2;

	
	
	
	typedef mat<3, 2, int32, defaultp>				i32mat3x2;

	
	
	
	typedef mat<3, 2, int64, defaultp>				i64mat3x2;

	
}
#line 65 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_int3x3.hpp"












#pragma once






#line 21 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_int3x3.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<3, 3, int, defaultp>	imat3x3;

	
	
	
	typedef mat<3, 3, int, defaultp>	imat3;

	
}
#line 66 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_int3x3_sized.hpp"












#pragma once







#line 22 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_int3x3_sized.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<3, 3, int8, defaultp>				i8mat3x3;

	
	
	
	typedef mat<3, 3, int16, defaultp>				i16mat3x3;

	
	
	
	typedef mat<3, 3, int32, defaultp>				i32mat3x3;

	
	
	
	typedef mat<3, 3, int64, defaultp>				i64mat3x3;


	
	
	
	typedef mat<3, 3, int8, defaultp>				i8mat3;

	
	
	
	typedef mat<3, 3, int16, defaultp>				i16mat3;

	
	
	
	typedef mat<3, 3, int32, defaultp>				i32mat3;

	
	
	
	typedef mat<3, 3, int64, defaultp>				i64mat3;

	
}
#line 67 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_int3x4.hpp"












#pragma once






#line 21 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_int3x4.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<3, 4, int, defaultp>	imat3x4;

	
}
#line 68 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_int3x4_sized.hpp"












#pragma once







#line 22 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_int3x4_sized.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<3, 4, int8, defaultp>				i8mat3x4;

	
	
	
	typedef mat<3, 4, int16, defaultp>				i16mat3x4;

	
	
	
	typedef mat<3, 4, int32, defaultp>				i32mat3x4;

	
	
	
	typedef mat<3, 4, int64, defaultp>				i64mat3x4;

	
}
#line 69 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_int4x2.hpp"












#pragma once






#line 21 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_int4x2.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<4, 2, int, defaultp>	imat4x2;

	
}
#line 70 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_int4x2_sized.hpp"












#pragma once







#line 22 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_int4x2_sized.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<4, 2, int8, defaultp>				i8mat4x2;

	
	
	
	typedef mat<4, 2, int16, defaultp>				i16mat4x2;

	
	
	
	typedef mat<4, 2, int32, defaultp>				i32mat4x2;

	
	
	
	typedef mat<4, 2, int64, defaultp>				i64mat4x2;

	
}
#line 71 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_int4x3.hpp"












#pragma once






#line 21 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_int4x3.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<4, 3, int, defaultp>	imat4x3;

	
}
#line 72 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_int4x3_sized.hpp"












#pragma once







#line 22 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_int4x3_sized.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<4, 3, int8, defaultp>				i8mat4x3;

	
	
	
	typedef mat<4, 3, int16, defaultp>				i16mat4x3;

	
	
	
	typedef mat<4, 3, int32, defaultp>				i32mat4x3;

	
	
	
	typedef mat<4, 3, int64, defaultp>				i64mat4x3;

	
}
#line 73 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_int4x4.hpp"












#pragma once






#line 21 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_int4x4.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<4, 4, int, defaultp>	imat4x4;

	
	
	
	typedef mat<4, 4, int, defaultp>	imat4;

	
}
#line 74 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_int4x4_sized.hpp"












#pragma once







#line 22 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_int4x4_sized.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<4, 4, int8, defaultp>				i8mat4x4;

	
	
	
	typedef mat<4, 4, int16, defaultp>				i16mat4x4;

	
	
	
	typedef mat<4, 4, int32, defaultp>				i32mat4x4;

	
	
	
	typedef mat<4, 4, int64, defaultp>				i64mat4x4;


	
	
	
	typedef mat<4, 4, int8, defaultp>				i8mat4;

	
	
	
	typedef mat<4, 4, int16, defaultp>				i16mat4;

	
	
	
	typedef mat<4, 4, int32, defaultp>				i32mat4;

	
	
	
	typedef mat<4, 4, int64, defaultp>				i64mat4;

	
}
#line 75 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_uint2x2.hpp"












#pragma once






#line 21 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_uint2x2.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<2, 2, uint, defaultp>	umat2x2;

	
	
	
	typedef mat<2, 2, uint, defaultp>	umat2;

	
}
#line 77 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_uint2x2_sized.hpp"












#pragma once







#line 22 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_uint2x2_sized.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<2, 2, uint8, defaultp>				u8mat2x2;

	
	
	
	typedef mat<2, 2, uint16, defaultp>				u16mat2x2;

	
	
	
	typedef mat<2, 2, uint32, defaultp>				u32mat2x2;

	
	
	
	typedef mat<2, 2, uint64, defaultp>				u64mat2x2;


	
	
	
	typedef mat<2, 2, uint8, defaultp>				u8mat2;

	
	
	
	typedef mat<2, 2, uint16, defaultp>				u16mat2;

	
	
	
	typedef mat<2, 2, uint32, defaultp>				u32mat2;

	
	
	
	typedef mat<2, 2, uint64, defaultp>				u64mat2;

	
}
#line 78 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_uint2x3.hpp"












#pragma once






#line 21 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_uint2x3.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<2, 3, uint, defaultp>	umat2x3;

	
}
#line 79 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_uint2x3_sized.hpp"












#pragma once







#line 22 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_uint2x3_sized.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<2, 3, uint8, defaultp>				u8mat2x3;

	
	
	
	typedef mat<2, 3, uint16, defaultp>				u16mat2x3;

	
	
	
	typedef mat<2, 3, uint32, defaultp>				u32mat2x3;

	
	
	
	typedef mat<2, 3, uint64, defaultp>				u64mat2x3;

	
}
#line 80 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_uint2x4.hpp"












#pragma once






#line 21 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_uint2x4.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<2, 4, uint, defaultp>	umat2x4;

	
}
#line 81 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_uint2x4_sized.hpp"












#pragma once







#line 22 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_uint2x4_sized.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<2, 4, uint8, defaultp>				u8mat2x4;

	
	
	
	typedef mat<2, 4, uint16, defaultp>				u16mat2x4;

	
	
	
	typedef mat<2, 4, uint32, defaultp>				u32mat2x4;

	
	
	
	typedef mat<2, 4, uint64, defaultp>				u64mat2x4;

	
}
#line 82 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_uint3x2.hpp"












#pragma once






#line 21 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_uint3x2.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<3, 2, uint, defaultp>	umat3x2;

	
}
#line 83 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_uint3x2_sized.hpp"












#pragma once







#line 22 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_uint3x2_sized.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<3, 2, uint8, defaultp>				u8mat3x2;

	
	
	
	typedef mat<3, 2, uint16, defaultp>				u16mat3x2;

	
	
	
	typedef mat<3, 2, uint32, defaultp>				u32mat3x2;

	
	
	
	typedef mat<3, 2, uint64, defaultp>				u64mat3x2;

	
}
#line 84 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_uint3x3.hpp"












#pragma once






#line 21 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_uint3x3.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<3, 3, uint, defaultp>	umat3x3;

	
	
	
	typedef mat<3, 3, uint, defaultp>	umat3;

	
}
#line 85 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_uint3x3_sized.hpp"












#pragma once







#line 22 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_uint3x3_sized.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<3, 3, uint8, defaultp>				u8mat3x3;

	
	
	
	typedef mat<3, 3, uint16, defaultp>				u16mat3x3;

	
	
	
	typedef mat<3, 3, uint32, defaultp>				u32mat3x3;

	
	
	
	typedef mat<3, 3, uint64, defaultp>				u64mat3x3;


	
	
	
	typedef mat<3, 3, uint8, defaultp>				u8mat3;

	
	
	
	typedef mat<3, 3, uint16, defaultp>				u16mat3;

	
	
	
	typedef mat<3, 3, uint32, defaultp>				u32mat3;

	
	
	
	typedef mat<3, 3, uint64, defaultp>				u64mat3;

	
}
#line 86 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_uint3x4.hpp"












#pragma once






#line 21 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_uint3x4.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<3, 4, uint, defaultp>	umat3x4;

	
}
#line 87 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_uint3x4_sized.hpp"












#pragma once







#line 22 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_uint3x4_sized.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<3, 4, uint8, defaultp>				u8mat3x4;

	
	
	
	typedef mat<3, 4, uint16, defaultp>				u16mat3x4;

	
	
	
	typedef mat<3, 4, uint32, defaultp>				u32mat3x4;

	
	
	
	typedef mat<3, 4, uint64, defaultp>				u64mat3x4;

	
}
#line 88 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_uint4x2.hpp"












#pragma once






#line 21 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_uint4x2.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<4, 2, uint, defaultp>	umat4x2;

	
}
#line 89 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_uint4x2_sized.hpp"












#pragma once







#line 22 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_uint4x2_sized.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<4, 2, uint8, defaultp>				u8mat4x2;

	
	
	
	typedef mat<4, 2, uint16, defaultp>				u16mat4x2;

	
	
	
	typedef mat<4, 2, uint32, defaultp>				u32mat4x2;

	
	
	
	typedef mat<4, 2, uint64, defaultp>				u64mat4x2;

	
}
#line 90 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_uint4x3.hpp"












#pragma once






#line 21 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_uint4x3.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<4, 3, uint, defaultp>	umat4x3;

	
}
#line 91 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_uint4x3_sized.hpp"












#pragma once







#line 22 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_uint4x3_sized.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<4, 3, uint8, defaultp>				u8mat4x3;

	
	
	
	typedef mat<4, 3, uint16, defaultp>				u16mat4x3;

	
	
	
	typedef mat<4, 3, uint32, defaultp>				u32mat4x3;

	
	
	
	typedef mat<4, 3, uint64, defaultp>				u64mat4x3;

	
}
#line 92 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_uint4x4.hpp"












#pragma once






#line 21 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_uint4x4.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<4, 4, uint, defaultp>	umat4x4;

	
	
	
	typedef mat<4, 4, uint, defaultp>	umat4;

	
}
#line 93 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_uint4x4_sized.hpp"












#pragma once







#line 22 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_uint4x4_sized.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<4, 4, uint8, defaultp>				u8mat4x4;

	
	
	
	typedef mat<4, 4, uint16, defaultp>				u16mat4x4;

	
	
	
	typedef mat<4, 4, uint32, defaultp>				u32mat4x4;

	
	
	
	typedef mat<4, 4, uint64, defaultp>				u64mat4x4;


	
	
	
	typedef mat<4, 4, uint8, defaultp>				u8mat4;

	
	
	
	typedef mat<4, 4, uint16, defaultp>				u16mat4;

	
	
	
	typedef mat<4, 4, uint32, defaultp>				u32mat4;

	
	
	
	typedef mat<4, 4, uint64, defaultp>				u64mat4;

	
}
#line 94 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_projection.hpp"



















#pragma once


#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\constants.hpp"












#pragma once






#line 21 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\constants.hpp"

namespace glm
{
	
	

	
	
	template<typename genType>
	[[nodiscard]] constexpr genType zero();

	
	
	template<typename genType>
	[[nodiscard]] constexpr genType one();

	
	
	template<typename genType>
	[[nodiscard]] constexpr genType two_pi();

	
	
	template<typename genType>
	[[nodiscard]] constexpr genType tau();

	
	
	template<typename genType>
	[[nodiscard]] constexpr genType root_pi();

	
	
	template<typename genType>
	[[nodiscard]] constexpr genType half_pi();

	
	
	template<typename genType>
	[[nodiscard]] constexpr genType three_over_two_pi();

	
	
	template<typename genType>
	[[nodiscard]] constexpr genType quarter_pi();

	
	
	template<typename genType>
	[[nodiscard]] constexpr genType one_over_pi();

	
	
	template<typename genType>
	[[nodiscard]] constexpr genType one_over_two_pi();

	
	
	template<typename genType>
	[[nodiscard]] constexpr genType two_over_pi();

	
	
	template<typename genType>
	[[nodiscard]] constexpr genType four_over_pi();

	
	
	template<typename genType>
	[[nodiscard]] constexpr genType two_over_root_pi();

	
	
	template<typename genType>
	[[nodiscard]] constexpr genType one_over_root_two();

	
	
	template<typename genType>
	[[nodiscard]] constexpr genType root_half_pi();

	
	
	template<typename genType>
	[[nodiscard]] constexpr genType root_two_pi();

	
	
	template<typename genType>
	[[nodiscard]] constexpr genType root_ln_four();

	
	
	template<typename genType>
	[[nodiscard]] constexpr genType e();

	
	
	template<typename genType>
	[[nodiscard]] constexpr genType euler();

	
	
	template<typename genType>
	[[nodiscard]] constexpr genType root_two();

	
	
	template<typename genType>
	[[nodiscard]] constexpr genType root_three();

	
	
	template<typename genType>
	[[nodiscard]] constexpr genType root_five();

	
	
	template<typename genType>
	[[nodiscard]] constexpr genType ln_two();

	
	
	template<typename genType>
	[[nodiscard]] constexpr genType ln_ten();

	
	
	template<typename genType>
	[[nodiscard]] constexpr genType ln_ln_two();

	
	
	template<typename genType>
	[[nodiscard]] constexpr genType third();

	
	
	template<typename genType>
	[[nodiscard]] constexpr genType two_thirds();

	
	
	template<typename genType>
	[[nodiscard]] constexpr genType golden_ratio();

	
} 

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\constants.inl"


namespace glm
{
	template<typename genType>
	inline constexpr genType zero()
	{
		return genType(0);
	}

	template<typename genType>
	inline constexpr genType one()
	{
		return genType(1);
	}

	template<typename genType>
	inline constexpr genType two_pi()
	{
		return genType(6.28318530717958647692528676655900576);
	}

	template<typename genType>
	inline constexpr genType tau()
	{
		return two_pi<genType>();
	}

	template<typename genType>
	inline constexpr genType root_pi()
	{
		return genType(1.772453850905516027);
	}

	template<typename genType>
	inline constexpr genType half_pi()
	{
		return genType(1.57079632679489661923132169163975144);
	}

	template<typename genType>
	inline constexpr genType three_over_two_pi()
	{
		return genType(4.71238898038468985769396507491925432);
	}

	template<typename genType>
	inline constexpr genType quarter_pi()
	{
		return genType(0.785398163397448309615660845819875721);
	}

	template<typename genType>
	inline constexpr genType one_over_pi()
	{
		return genType(0.318309886183790671537767526745028724);
	}

	template<typename genType>
	inline constexpr genType one_over_two_pi()
	{
		return genType(0.159154943091895335768883763372514362);
	}

	template<typename genType>
	inline constexpr genType two_over_pi()
	{
		return genType(0.636619772367581343075535053490057448);
	}

	template<typename genType>
	inline constexpr genType four_over_pi()
	{
		return genType(1.273239544735162686151070106980114898);
	}

	template<typename genType>
	inline constexpr genType two_over_root_pi()
	{
		return genType(1.12837916709551257389615890312154517);
	}

	template<typename genType>
	inline constexpr genType one_over_root_two()
	{
		return genType(0.707106781186547524400844362104849039);
	}

	template<typename genType>
	inline constexpr genType root_half_pi()
	{
		return genType(1.253314137315500251);
	}

	template<typename genType>
	inline constexpr genType root_two_pi()
	{
		return genType(2.506628274631000502);
	}

	template<typename genType>
	inline constexpr genType root_ln_four()
	{
		return genType(1.17741002251547469);
	}

	template<typename genType>
	inline constexpr genType e()
	{
		return genType(2.71828182845904523536);
	}

	template<typename genType>
	inline constexpr genType euler()
	{
		return genType(0.577215664901532860606);
	}

	template<typename genType>
	inline constexpr genType root_two()
	{
		return genType(1.41421356237309504880168872420969808);
	}

	template<typename genType>
	inline constexpr genType root_three()
	{
		return genType(1.73205080756887729352744634150587236);
	}

	template<typename genType>
	inline constexpr genType root_five()
	{
		return genType(2.23606797749978969640917366873127623);
	}

	template<typename genType>
	inline constexpr genType ln_two()
	{
		return genType(0.693147180559945309417232121458176568);
	}

	template<typename genType>
	inline constexpr genType ln_ten()
	{
		return genType(2.30258509299404568401799145468436421);
	}

	template<typename genType>
	inline constexpr genType ln_ln_two()
	{
		return genType(-0.3665129205816643);
	}

	template<typename genType>
	inline constexpr genType third()
	{
		return genType(0.3333333333333333333333333333333333333333);
	}

	template<typename genType>
	inline constexpr genType two_thirds()
	{
		return genType(0.666666666666666666666666666666666666667);
	}

	template<typename genType>
	inline constexpr genType golden_ratio()
	{
		return genType(1.61803398874989484820458683436563811);
	}

} 
#line 171 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\constants.hpp"
#line 24 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_projection.hpp"






#line 31 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_projection.hpp"

namespace glm
{
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	template<typename T, typename U, qualifier Q>
	[[nodiscard]] vec<3, T, Q> projectZO(
		vec<3, T, Q> const& obj, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport);

	
	
	
	
	
	
	
	
	
	
	
	
	template<typename T, typename U, qualifier Q>
	[[nodiscard]] vec<3, T, Q> projectNO(
		vec<3, T, Q> const& obj, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport);

	
	
	
	
	
	
	
	
	
	
	
	
	template<typename T, typename U, qualifier Q>
	[[nodiscard]] vec<3, T, Q> project(
		vec<3, T, Q> const& obj, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport);

	
	
	
	
	
	
	
	
	
	
	
	
	template<typename T, typename U, qualifier Q>
	[[nodiscard]] vec<3, T, Q> unProjectZO(
		vec<3, T, Q> const& win, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport);

	
	
	
	
	
	
	
	
	
	
	
	
	template<typename T, typename U, qualifier Q>
	[[nodiscard]] vec<3, T, Q> unProjectNO(
		vec<3, T, Q> const& win, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport);

	
	
	
	
	
	
	
	
	
	
	
	
	template<typename T, typename U, qualifier Q>
	[[nodiscard]] vec<3, T, Q> unProject(
		vec<3, T, Q> const& win, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport);

	
	
	
	
	
	
	
	
	
	template<typename T, qualifier Q, typename U>
	[[nodiscard]] mat<4, 4, T, Q> pickMatrix(
		vec<2, T, Q> const& center, vec<2, T, Q> const& delta, vec<4, U, Q> const& viewport);

	
}

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_projection.inl"
namespace glm
{
	template<typename T, typename U, qualifier Q>
	inline vec<3, T, Q> projectZO(vec<3, T, Q> const& obj, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport)
	{
		vec<4, T, Q> tmp = vec<4, T, Q>(obj, static_cast<T>(1));
		tmp = model * tmp;
		tmp = proj * tmp;

		tmp /= tmp.w;
		tmp.x = tmp.x * static_cast<T>(0.5) + static_cast<T>(0.5);
		tmp.y = tmp.y * static_cast<T>(0.5) + static_cast<T>(0.5);

		tmp[0] = tmp[0] * T(viewport[2]) + T(viewport[0]);
		tmp[1] = tmp[1] * T(viewport[3]) + T(viewport[1]);

		return vec<3, T, Q>(tmp);
	}

	template<typename T, typename U, qualifier Q>
	inline vec<3, T, Q> projectNO(vec<3, T, Q> const& obj, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport)
	{
		vec<4, T, Q> tmp = vec<4, T, Q>(obj, static_cast<T>(1));
		tmp = model * tmp;
		tmp = proj * tmp;

		tmp /= tmp.w;
		tmp = tmp * static_cast<T>(0.5) + static_cast<T>(0.5);
		tmp[0] = tmp[0] * T(viewport[2]) + T(viewport[0]);
		tmp[1] = tmp[1] * T(viewport[3]) + T(viewport[1]);

		return vec<3, T, Q>(tmp);
	}

	template<typename T, typename U, qualifier Q>
	inline vec<3, T, Q> project(vec<3, T, Q> const& obj, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport)
	{


#line 41 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_projection.inl"
			return projectNO(obj, model, proj, viewport);
#line 43 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_projection.inl"
	}

	template<typename T, typename U, qualifier Q>
	inline vec<3, T, Q> unProjectZO(vec<3, T, Q> const& win, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport)
	{
		mat<4, 4, T, Q> Inverse = inverse(proj * model);

		vec<4, T, Q> tmp = vec<4, T, Q>(win, T(1));
		tmp.x = (tmp.x - T(viewport[0])) / T(viewport[2]);
		tmp.y = (tmp.y - T(viewport[1])) / T(viewport[3]);
		tmp.x = tmp.x * static_cast<T>(2) - static_cast<T>(1);
		tmp.y = tmp.y * static_cast<T>(2) - static_cast<T>(1);

		vec<4, T, Q> obj = Inverse * tmp;
		obj /= obj.w;

		return vec<3, T, Q>(obj);
	}

	template<typename T, typename U, qualifier Q>
	inline vec<3, T, Q> unProjectNO(vec<3, T, Q> const& win, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport)
	{
		mat<4, 4, T, Q> Inverse = inverse(proj * model);

		vec<4, T, Q> tmp = vec<4, T, Q>(win, T(1));
		tmp.x = (tmp.x - T(viewport[0])) / T(viewport[2]);
		tmp.y = (tmp.y - T(viewport[1])) / T(viewport[3]);
		tmp = tmp * static_cast<T>(2) - static_cast<T>(1);

		vec<4, T, Q> obj = Inverse * tmp;
		obj /= obj.w;

		return vec<3, T, Q>(obj);
	}

	template<typename T, typename U, qualifier Q>
	inline vec<3, T, Q> unProject(vec<3, T, Q> const& win, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport)
	{


#line 84 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_projection.inl"
			return unProjectNO(win, model, proj, viewport);
#line 86 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_projection.inl"
	}

	template<typename T, qualifier Q, typename U>
	inline mat<4, 4, T, Q> pickMatrix(vec<2, T, Q> const& center, vec<2, T, Q> const& delta, vec<4, U, Q> const& viewport)
	{
		(void)( (!!(delta.x > static_cast<T>(0) && delta.y > static_cast<T>(0))) || (_wassert(L"delta.x > static_cast<T>(0) && delta.y > static_cast<T>(0)", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_projection.inl", (unsigned)(91)), 0) ) ;
		mat<4, 4, T, Q> Result(static_cast<T>(1));

		if(!(delta.x > static_cast<T>(0) && delta.y > static_cast<T>(0)))
			return Result; 

		vec<3, T, Q> Temp(
			(static_cast<T>(viewport[2]) - static_cast<T>(2) * (center.x - static_cast<T>(viewport[0]))) / delta.x,
			(static_cast<T>(viewport[3]) - static_cast<T>(2) * (center.y - static_cast<T>(viewport[1]))) / delta.y,
			static_cast<T>(0));

		
		Result = translate(Result, Temp);
		return scale(Result, vec<3, T, Q>(static_cast<T>(viewport[2]) / delta.x, static_cast<T>(viewport[3]) / delta.y, static_cast<T>(1)));
	}
}
#line 150 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_projection.hpp"
#line 96 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_relational.hpp"














#pragma once






#line 23 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_relational.hpp"

namespace glm
{
	
	

	
	
	
	
	
	
	
	template<length_t C, length_t R, typename T, qualifier Q>
	[[nodiscard]] constexpr vec<C, bool, Q> equal(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y);

	
	
	
	
	
	
	
	template<length_t C, length_t R, typename T, qualifier Q>
	[[nodiscard]] constexpr vec<C, bool, Q> notEqual(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y);

	
	
	
	
	
	
	
	template<length_t C, length_t R, typename T, qualifier Q>
	[[nodiscard]] constexpr vec<C, bool, Q> equal(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y, T epsilon);

	
	
	
	
	
	
	
	template<length_t C, length_t R, typename T, qualifier Q>
	[[nodiscard]] constexpr vec<C, bool, Q> equal(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y, vec<C, T, Q> const& epsilon);

	
	
	
	
	
	
	
	template<length_t C, length_t R, typename T, qualifier Q>
	[[nodiscard]] constexpr vec<C, bool, Q> notEqual(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y, T epsilon);

	
	
	
	
	
	
	
	template<length_t C, length_t R, typename T, qualifier Q>
	[[nodiscard]] constexpr vec<C, bool, Q> notEqual(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y, vec<C, T, Q> const& epsilon);

	
	
	
	
	
	
	
	template<length_t C, length_t R, typename T, qualifier Q>
	[[nodiscard]] constexpr vec<C, bool, Q> equal(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y, int ULPs);

	
	
	
	
	
	
	
	template<length_t C, length_t R, typename T, qualifier Q>
	[[nodiscard]] constexpr vec<C, bool, Q> equal(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y, vec<C, int, Q> const& ULPs);

	
	
	
	
	
	
	
	template<length_t C, length_t R, typename T, qualifier Q>
	[[nodiscard]] constexpr vec<C, bool, Q> notEqual(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y, int ULPs);

	
	
	
	
	
	
	
	template<length_t C, length_t R, typename T, qualifier Q>
	[[nodiscard]] constexpr vec<C, bool, Q> notEqual(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y, vec<C, int, Q> const& ULPs);

	
}

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_relational.inl"




#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_relational.hpp"

















#pragma once






#line 26 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_relational.hpp"

namespace glm
{
	
	

	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y, T epsilon);

	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, T, Q> const& epsilon);

	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, T epsilon);

	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, T, Q> const& epsilon);

	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y, int ULPs);

	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, int, Q> const& ULPs);

	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, int ULPs);

	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, int, Q> const& ULPs);

	
}

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_relational.inl"



#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_float.hpp"
#pragma once

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 970 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
























































































































































































































#line 1187 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 1189 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
#line 4 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_float.hpp"




#line 9 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_float.hpp"

namespace glm{
namespace detail
{
	template <typename T>
	union float_t
	{};

	
	template <>
	union float_t<float>
	{
		typedef int int_type;
		typedef float float_type;

		constexpr float_t(float_type Num = 0.0f) : f(Num) {}

		constexpr float_t& operator=(float_t const& x)
		{
			f = x.f;
			return *this;
		}

		
		constexpr bool negative() const { return i < 0; }
		constexpr int_type mantissa() const { return i & ((1 << 23) - 1); }
		constexpr int_type exponent() const { return (i >> 23) & ((1 << 8) - 1); }

		int_type i;
		float_type f;
	};

	template <>
	union float_t<double>
	{
		typedef detail::int64 int_type;
		typedef double float_type;

		constexpr float_t(float_type Num = static_cast<float_type>(0)) : f(Num) {}

		constexpr float_t& operator=(float_t const& x)
		{
			f = x.f;
			return *this;
		}

		
		constexpr bool negative() const { return i < 0; }
		constexpr int_type mantissa() const { return i & ((int_type(1) << 52) - 1); }
		constexpr int_type exponent() const { return (i >> 52) & ((int_type(1) << 11) - 1); }

		int_type i;
		float_type f;
	};
}
}



#line 69 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_float.hpp"
#line 5 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_relational.inl"

namespace glm
{
	template<length_t L, typename T, qualifier Q>
	inline constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y, T Epsilon)
	{
		return equal(x, y, vec<L, T, Q>(Epsilon));
	}

	template<length_t L, typename T, qualifier Q>
	inline constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, T, Q> const& Epsilon)
	{
		return lessThanEqual(abs(x - y), Epsilon);
	}

	template<length_t L, typename T, qualifier Q>
	inline constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, T Epsilon)
	{
		return notEqual(x, y, vec<L, T, Q>(Epsilon));
	}

	template<length_t L, typename T, qualifier Q>
	inline constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, T, Q> const& Epsilon)
	{
		return greaterThan(abs(x - y), Epsilon);
	}


	template<length_t L, typename T, qualifier Q>
	inline constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y, int MaxULPs)
	{
		return equal(x, y, vec<L, int, Q>(MaxULPs));
	}

	template<length_t L, typename T, qualifier Q>
	inline constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, int, Q> const& MaxULPs)
	{
		vec<L, bool, Q> Result(false);
		for(length_t i = 0; i < L; ++i)
		{
			detail::float_t<T> const a(x[i]);
			detail::float_t<T> const b(y[i]);

			
			if(a.negative() != b.negative())
			{
				
				Result[i] = a.mantissa() == b.mantissa() && a.exponent() == b.exponent();
			}
			else
			{
				
				typename detail::float_t<T>::int_type const DiffULPs = abs(a.i - b.i);
				Result[i] = DiffULPs <= MaxULPs[i];
			}
		}
		return Result;
	}

	template<length_t L, typename T, qualifier Q>
	inline constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, int MaxULPs)
	{
		return notEqual(x, y, vec<L, int, Q>(MaxULPs));
	}

	template<length_t L, typename T, qualifier Q>
	inline constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, int, Q> const& MaxULPs)
	{
		return not_(equal(x, y, MaxULPs));
	}
}
#line 108 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_relational.hpp"
#line 6 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_relational.inl"


namespace glm
{
	template<length_t C, length_t R, typename T, qualifier Q>
	inline constexpr vec<C, bool, Q> equal(mat<C, R, T, Q> const& a, mat<C, R, T, Q> const& b)
	{
		vec<C, bool, Q> Result(true);
		for(length_t i = 0; i < C; ++i)
			Result[i] = all(equal(a[i], b[i]));
		return Result;
	}

	template<length_t C, length_t R, typename T, qualifier Q>
	inline constexpr vec<C, bool, Q> equal(mat<C, R, T, Q> const& a, mat<C, R, T, Q> const& b, T Epsilon)
	{
		return equal(a, b, vec<C, T, Q>(Epsilon));
	}

	template<length_t C, length_t R, typename T, qualifier Q>
	inline constexpr vec<C, bool, Q> equal(mat<C, R, T, Q> const& a, mat<C, R, T, Q> const& b, vec<C, T, Q> const& Epsilon)
	{
		vec<C, bool, Q> Result(true);
		for(length_t i = 0; i < C; ++i)
			Result[i] = all(equal(a[i], b[i], Epsilon[i]));
		return Result;
	}

	template<length_t C, length_t R, typename T, qualifier Q>
	inline constexpr vec<C, bool, Q> notEqual(mat<C, R, T, Q> const& a, mat<C, R, T, Q> const& b)
	{
		vec<C, bool, Q> Result(true);
		for(length_t i = 0; i < C; ++i)
			Result[i] = any(notEqual(a[i], b[i]));
		return Result;
	}

	template<length_t C, length_t R, typename T, qualifier Q>
	inline constexpr vec<C, bool, Q> notEqual(mat<C, R, T, Q> const& a, mat<C, R, T, Q> const& b, T Epsilon)
	{
		return notEqual(a, b, vec<C, T, Q>(Epsilon));
	}

	template<length_t C, length_t R, typename T, qualifier Q>
	inline constexpr vec<C, bool, Q> notEqual(mat<C, R, T, Q> const& a, mat<C, R, T, Q> const& b, vec<C, T, Q> const& Epsilon)
	{
		vec<C, bool, Q> Result(true);
		for(length_t i = 0; i < C; ++i)
			Result[i] = any(notEqual(a[i], b[i], Epsilon[i]));
		return Result;
	}

	template<length_t C, length_t R, typename T, qualifier Q>
	inline constexpr vec<C, bool, Q> equal(mat<C, R, T, Q> const& a, mat<C, R, T, Q> const& b, int MaxULPs)
	{
		return equal(a, b, vec<C, int, Q>(MaxULPs));
	}

	template<length_t C, length_t R, typename T, qualifier Q>
	inline constexpr vec<C, bool, Q> equal(mat<C, R, T, Q> const& a, mat<C, R, T, Q> const& b, vec<C, int, Q> const& MaxULPs)
	{
		vec<C, bool, Q> Result(true);
		for(length_t i = 0; i < C; ++i)
			Result[i] = all(equal(a[i], b[i], MaxULPs[i]));
		return Result;
	}

	template<length_t C, length_t R, typename T, qualifier Q>
	inline constexpr vec<C, bool, Q> notEqual(mat<C, R, T, Q> const& a, mat<C, R, T, Q> const& b, int MaxULPs)
	{
		return notEqual(a, b, vec<C, int, Q>(MaxULPs));
	}

	template<length_t C, length_t R, typename T, qualifier Q>
	inline constexpr vec<C, bool, Q> notEqual(mat<C, R, T, Q> const& a, mat<C, R, T, Q> const& b, vec<C, int, Q> const& MaxULPs)
	{
		vec<C, bool, Q> Result(true);
		for(length_t i = 0; i < C; ++i)
			Result[i] = any(notEqual(a[i], b[i], MaxULPs[i]));
		return Result;
	}

}
#line 133 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_relational.hpp"
#line 97 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_transform.hpp"



















#pragma once









#line 31 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_transform.hpp"

namespace glm
{
	
	

	
	template<typename genType>
	[[nodiscard]] constexpr genType identity();

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	template<typename T, qualifier Q>
	[[nodiscard]] constexpr mat<4, 4, T, Q> translate(
		mat<4, 4, T, Q> const& m, vec<3, T, Q> const& v);

	
	
	
	
	
	
	
	
	
	
	
	
	template<typename T, qualifier Q>
	[[nodiscard]] mat<4, 4, T, Q> rotate(
		mat<4, 4, T, Q> const& m, T angle, vec<3, T, Q> const& axis);

	
	
	
	
	
	
	
	
	
	
	
	template<typename T, qualifier Q>
	[[nodiscard]] mat<4, 4, T, Q> scale(
		mat<4, 4, T, Q> const& m, vec<3, T, Q> const& v);

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    template <typename T, qualifier Q>
    inline mat<4, 4, T, Q> shear(
        mat<4, 4, T, Q> const &m, vec<3, T, Q> const& p, vec<2, T, Q> const &l_x, vec<2, T, Q> const &l_y, vec<2, T, Q> const &l_z);

    
	
	
	
	
	
	
	
	
	
	template<typename T, qualifier Q>
	[[nodiscard]] mat<4, 4, T, Q> lookAtRH(
		vec<3, T, Q> const& eye, vec<3, T, Q> const& center, vec<3, T, Q> const& up);

	
	
	
	
	
	
	
	
	
	
	template<typename T, qualifier Q>
	[[nodiscard]] mat<4, 4, T, Q> lookAtLH(
		vec<3, T, Q> const& eye, vec<3, T, Q> const& center, vec<3, T, Q> const& up);

	
	
	
	
	
	
	
	
	
	
	
	template<typename T, qualifier Q>
	[[nodiscard]] mat<4, 4, T, Q> lookAt(
		vec<3, T, Q> const& eye, vec<3, T, Q> const& center, vec<3, T, Q> const& up);

	
}

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_transform.inl"
namespace glm
{
	template<typename genType>
	inline constexpr genType identity()
	{
		return detail::init_gentype<genType, detail::genTypeTrait<genType>::GENTYPE>::identity();
	}

	template<typename T, qualifier Q>
	inline constexpr mat<4, 4, T, Q> translate(mat<4, 4, T, Q> const& m, vec<3, T, Q> const& v)
	{
		mat<4, 4, T, Q> Result(m);
		Result[3] = m[0] * v[0] + m[1] * v[1] + m[2] * v[2] + m[3];
		return Result;
	}

	template<typename T, qualifier Q>
	inline mat<4, 4, T, Q> rotate(mat<4, 4, T, Q> const& m, T angle, vec<3, T, Q> const& v)
	{
		T const a = angle;
		T const c = cos(a);
		T const s = sin(a);

		vec<3, T, Q> axis(normalize(v));
		vec<3, T, Q> temp((T(1) - c) * axis);

		mat<4, 4, T, Q> Rotate;
		Rotate[0][0] = c + temp[0] * axis[0];
		Rotate[0][1] = temp[0] * axis[1] + s * axis[2];
		Rotate[0][2] = temp[0] * axis[2] - s * axis[1];

		Rotate[1][0] = temp[1] * axis[0] - s * axis[2];
		Rotate[1][1] = c + temp[1] * axis[1];
		Rotate[1][2] = temp[1] * axis[2] + s * axis[0];

		Rotate[2][0] = temp[2] * axis[0] + s * axis[1];
		Rotate[2][1] = temp[2] * axis[1] - s * axis[0];
		Rotate[2][2] = c + temp[2] * axis[2];

		mat<4, 4, T, Q> Result;
		Result[0] = m[0] * Rotate[0][0] + m[1] * Rotate[0][1] + m[2] * Rotate[0][2];
		Result[1] = m[0] * Rotate[1][0] + m[1] * Rotate[1][1] + m[2] * Rotate[1][2];
		Result[2] = m[0] * Rotate[2][0] + m[1] * Rotate[2][1] + m[2] * Rotate[2][2];
		Result[3] = m[3];
		return Result;
	}

	template<typename T, qualifier Q>
	inline mat<4, 4, T, Q> rotate_slow(mat<4, 4, T, Q> const& m, T angle, vec<3, T, Q> const& v)
	{
		T const a = angle;
		T const c = cos(a);
		T const s = sin(a);
		mat<4, 4, T, Q> Result;

		vec<3, T, Q> axis = normalize(v);

		Result[0][0] = c + (static_cast<T>(1) - c)      * axis.x     * axis.x;
		Result[0][1] = (static_cast<T>(1) - c) * axis.x * axis.y + s * axis.z;
		Result[0][2] = (static_cast<T>(1) - c) * axis.x * axis.z - s * axis.y;
		Result[0][3] = static_cast<T>(0);

		Result[1][0] = (static_cast<T>(1) - c) * axis.y * axis.x - s * axis.z;
		Result[1][1] = c + (static_cast<T>(1) - c) * axis.y * axis.y;
		Result[1][2] = (static_cast<T>(1) - c) * axis.y * axis.z + s * axis.x;
		Result[1][3] = static_cast<T>(0);

		Result[2][0] = (static_cast<T>(1) - c) * axis.z * axis.x + s * axis.y;
		Result[2][1] = (static_cast<T>(1) - c) * axis.z * axis.y - s * axis.x;
		Result[2][2] = c + (static_cast<T>(1) - c) * axis.z * axis.z;
		Result[2][3] = static_cast<T>(0);

		Result[3] = vec<4, T, Q>(0, 0, 0, 1);
		return m * Result;
	}

	template<typename T, qualifier Q>
	inline mat<4, 4, T, Q> scale(mat<4, 4, T, Q> const& m, vec<3, T, Q> const& v)
	{
		mat<4, 4, T, Q> Result;
		Result[0] = m[0] * v[0];
		Result[1] = m[1] * v[1];
		Result[2] = m[2] * v[2];
		Result[3] = m[3];
		return Result;
	}

	template<typename T, qualifier Q>
	inline mat<4, 4, T, Q> scale_slow(mat<4, 4, T, Q> const& m, vec<3, T, Q> const& v)
	{
		mat<4, 4, T, Q> Result(T(1));
		Result[0][0] = v.x;
		Result[1][1] = v.y;
		Result[2][2] = v.z;
		return m * Result;
	}

    template <typename T, qualifier Q>
    inline mat<4, 4, T, Q> shear(mat<4, 4, T, Q> const &m, vec<3, T, Q> const& p, vec<2, T, Q> const &l_x, vec<2, T, Q> const &l_y, vec<2, T, Q> const &l_z)
    {
        T const lambda_xy = l_x[0];
        T const lambda_xz = l_x[1];
        T const lambda_yx = l_y[0];
        T const lambda_yz = l_y[1];
        T const lambda_zx = l_z[0];
        T const lambda_zy = l_z[1];

        vec<3, T, Q> point_lambda = vec<3, T, Q>(
            (lambda_xy + lambda_xz), (lambda_yx + lambda_yz), (lambda_zx + lambda_zy)
        );

        mat<4, 4, T, Q> Shear = mat<4, 4, T, Q>(
            1                      , lambda_yx              , lambda_zx              , 0,
            lambda_xy              , 1                      , lambda_zy              , 0,
            lambda_xz              , lambda_yz              , 1                      , 0,
            -point_lambda[0] * p[0], -point_lambda[1] * p[1], -point_lambda[2] * p[2], 1
        );

        mat<4, 4, T, Q> Result;
		Result[0] = m[0] * Shear[0][0] + m[1] * Shear[0][1] + m[2] * Shear[0][2] + m[3] * Shear[0][3];
		Result[1] = m[0] * Shear[1][0] + m[1] * Shear[1][1] + m[2] * Shear[1][2] + m[3] * Shear[1][3];
		Result[2] = m[0] * Shear[2][0] + m[1] * Shear[2][1] + m[2] * Shear[2][2] + m[3] * Shear[2][3];
		Result[3] = m[0] * Shear[3][0] + m[1] * Shear[3][1] + m[2] * Shear[3][2] + m[3] * Shear[3][3];
        return Result;
    }

    template <typename T, qualifier Q>
    inline mat<4, 4, T, Q> shear_slow(mat<4, 4, T, Q> const &m, vec<3, T, Q> const& p, vec<2, T, Q> const &l_x, vec<2, T, Q> const &l_y, vec<2, T, Q> const &l_z)
    {
        T const lambda_xy = static_cast<T>(l_x[0]);
        T const lambda_xz = static_cast<T>(l_x[1]);
        T const lambda_yx = static_cast<T>(l_y[0]);
        T const lambda_yz = static_cast<T>(l_y[1]);
        T const lambda_zx = static_cast<T>(l_z[0]);
        T const lambda_zy = static_cast<T>(l_z[1]);

        vec<3, T, Q> point_lambda = vec<3, T, Q>(
            static_cast<T>(lambda_xy + lambda_xz),
            static_cast<T>(lambda_yx + lambda_yz),
            static_cast<T>(lambda_zx + lambda_zy)
        );

        mat<4, 4, T, Q> Shear = mat<4, 4, T, Q>(
            1                      , lambda_yx              , lambda_zx              , 0,
            lambda_xy              , 1                      , lambda_zy              , 0,
            lambda_xz              , lambda_yz              , 1                      , 0,
            -point_lambda[0] * p[0], -point_lambda[1] * p[1], -point_lambda[2] * p[2], 1
        );
        return m * Shear;
    }

	template<typename T, qualifier Q>
	inline mat<4, 4, T, Q> lookAtRH(vec<3, T, Q> const& eye, vec<3, T, Q> const& center, vec<3, T, Q> const& up)
	{
		vec<3, T, Q> const f(normalize(center - eye));
		vec<3, T, Q> const s(normalize(cross(f, up)));
		vec<3, T, Q> const u(cross(s, f));

		mat<4, 4, T, Q> Result(1);
		Result[0][0] = s.x;
		Result[1][0] = s.y;
		Result[2][0] = s.z;
		Result[0][1] = u.x;
		Result[1][1] = u.y;
		Result[2][1] = u.z;
		Result[0][2] =-f.x;
		Result[1][2] =-f.y;
		Result[2][2] =-f.z;
		Result[3][0] =-dot(s, eye);
		Result[3][1] =-dot(u, eye);
		Result[3][2] = dot(f, eye);
		return Result;
	}

	template<typename T, qualifier Q>
	inline mat<4, 4, T, Q> lookAtLH(vec<3, T, Q> const& eye, vec<3, T, Q> const& center, vec<3, T, Q> const& up)
	{
		vec<3, T, Q> const f(normalize(center - eye));
		vec<3, T, Q> const s(normalize(cross(up, f)));
		vec<3, T, Q> const u(cross(f, s));

		mat<4, 4, T, Q> Result(1);
		Result[0][0] = s.x;
		Result[1][0] = s.y;
		Result[2][0] = s.z;
		Result[0][1] = u.x;
		Result[1][1] = u.y;
		Result[2][1] = u.z;
		Result[0][2] = f.x;
		Result[1][2] = f.y;
		Result[2][2] = f.z;
		Result[3][0] = -dot(s, eye);
		Result[3][1] = -dot(u, eye);
		Result[3][2] = -dot(f, eye);
		return Result;
	}

	template<typename T, qualifier Q>
	inline mat<4, 4, T, Q> lookAt(vec<3, T, Q> const& eye, vec<3, T, Q> const& center, vec<3, T, Q> const& up)
	{


#line 204 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_transform.inl"
            return lookAtRH(eye, center, up);
#line 206 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_transform.inl"
	}
}
#line 172 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\matrix_transform.hpp"
#line 98 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\quaternion_common.hpp"




















#pragma once



#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\quaternion_geometric.hpp"














#pragma once








#line 25 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\quaternion_geometric.hpp"

namespace glm
{
	
	

	
	
	
	
	
	
	template<typename T, qualifier Q>
	[[nodiscard]] T length(qua<T, Q> const& q);

	
	
	
	
	
	
	template<typename T, qualifier Q>
	[[nodiscard]] qua<T, Q> normalize(qua<T, Q> const& q);

	
	
	
	
	
	
	template<typename T, qualifier Q>
	[[nodiscard]] constexpr T dot(qua<T, Q> const& x, qua<T, Q> const& y);

	
	
	
	
	
	
	template<typename T, qualifier Q>
	inline constexpr qua<T, Q> cross(qua<T, Q> const& q1, qua<T, Q> const& q2);

	
} 

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\quaternion_geometric.inl"
namespace glm
{
	template<typename T, qualifier Q>
	inline constexpr T dot(qua<T, Q> const& x, qua<T, Q> const& y)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'dot' accepts only floating-point inputs") ;
		return detail::compute_dot<qua<T, Q>, T, detail::is_aligned<Q>::value>::call(x, y);
	}

	template<typename T, qualifier Q>
	inline T length(qua<T, Q> const& q)
	{
		return glm::sqrt(dot(q, q));
	}

	template<typename T, qualifier Q>
	inline qua<T, Q> normalize(qua<T, Q> const& q)
	{
		T len = length(q);
		if(len <= static_cast<T>(0)) 
			return qua<T, Q>::wxyz(static_cast<T>(1), static_cast<T>(0), static_cast<T>(0), static_cast<T>(0));
		T oneOverLen = static_cast<T>(1) / len;
		return qua<T, Q>::wxyz(q.w * oneOverLen, q.x * oneOverLen, q.y * oneOverLen, q.z * oneOverLen);
	}

	template<typename T, qualifier Q>
	inline constexpr qua<T, Q> cross(qua<T, Q> const& q1, qua<T, Q> const& q2)
	{
		return qua<T, Q>::wxyz(
			q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z,
			q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,
			q1.w * q2.y + q1.y * q2.w + q1.z * q2.x - q1.x * q2.z,
			q1.w * q2.z + q1.z * q2.w + q1.x * q2.y - q1.y * q2.x);
	}
}

#line 71 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\quaternion_geometric.hpp"
#line 26 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\quaternion_common.hpp"







#line 34 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\quaternion_common.hpp"

namespace glm
{
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	template<typename T, qualifier Q>
	[[nodiscard]] qua<T, Q> mix(qua<T, Q> const& x, qua<T, Q> const& y, T a);

	
	
	
	
	
	
	
	
	
	template<typename T, qualifier Q>
	[[nodiscard]] constexpr qua<T, Q> lerp(qua<T, Q> const& x, qua<T, Q> const& y, T a);

	
	
	
	
	
	
	
	
	
	template<typename T, qualifier Q>
	[[nodiscard]] qua<T, Q> slerp(qua<T, Q> const& x, qua<T, Q> const& y, T a);

    
    
    
    
    
    
    
    
    
    
    
    
    template<typename T, typename S, qualifier Q>
    [[nodiscard]] qua<T, Q> slerp(qua<T, Q> const& x, qua<T, Q> const& y, T a, S k);

	
	
	
	
	template<typename T, qualifier Q>
	[[nodiscard]] constexpr qua<T, Q> conjugate(qua<T, Q> const& q);

	
	
	
	
	template<typename T, qualifier Q>
	[[nodiscard]] constexpr qua<T, Q> inverse(qua<T, Q> const& q);

	
	
	
	
	
	
	
	
	
	
	template<typename T, qualifier Q>
	[[nodiscard]] vec<4, bool, Q> isnan(qua<T, Q> const& x);

	
	
	
	
	
	
	
	
	template<typename T, qualifier Q>
	[[nodiscard]] vec<4, bool, Q> isinf(qua<T, Q> const& x);

	
} 

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\quaternion_common.inl"
namespace glm
{
	template<typename T, qualifier Q>
	inline qua<T, Q> mix(qua<T, Q> const& x, qua<T, Q> const& y, T a)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'mix' only accept floating-point inputs") ;

		T const cosTheta = dot(x, y);

		
		if(cosTheta > static_cast<T>(1) - epsilon<T>())
		{
			
			return qua<T, Q>::wxyz(
				mix(x.w, y.w, a),
				mix(x.x, y.x, a),
				mix(x.y, y.y, a),
				mix(x.z, y.z, a));
		}
		else
		{
			
			T angle = acos(cosTheta);
			return (sin((static_cast<T>(1) - a) * angle) * x + sin(a * angle) * y) / sin(angle);
		}
	}

	template<typename T, qualifier Q>
	inline constexpr qua<T, Q> lerp(qua<T, Q> const& x, qua<T, Q> const& y, T a)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'lerp' only accept floating-point inputs") ;

		
		(void)( (!!(a >= static_cast<T>(0))) || (_wassert(L"a >= static_cast<T>(0)", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\quaternion_common.inl", (unsigned)(34)), 0) ) ;
		(void)( (!!(a <= static_cast<T>(1))) || (_wassert(L"a <= static_cast<T>(1)", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\quaternion_common.inl", (unsigned)(35)), 0) ) ;

		return x * (static_cast<T>(1) - a) + (y * a);
	}

	template<typename T, qualifier Q>
	inline qua<T, Q> slerp(qua<T, Q> const& x, qua<T, Q> const& y, T a)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'slerp' only accept floating-point inputs") ;

		qua<T, Q> z = y;

		T cosTheta = dot(x, y);

		
		
		if(cosTheta < static_cast<T>(0))
		{
			z = -y;
			cosTheta = -cosTheta;
		}

		
		if(cosTheta > static_cast<T>(1) - epsilon<T>())
		{
			
			return qua<T, Q>::wxyz(
				mix(x.w, z.w, a),
				mix(x.x, z.x, a),
				mix(x.y, z.y, a),
				mix(x.z, z.z, a));
		}
		else
		{
			
			T angle = acos(cosTheta);
			return (sin((static_cast<T>(1) - a) * angle) * x + sin(a * angle) * z) / sin(angle);
		}
	}

    template<typename T, typename S, qualifier Q>
    inline qua<T, Q> slerp(qua<T, Q> const& x, qua<T, Q> const& y, T a, S k)
    {
        static_assert(std::numeric_limits<T>::is_iec559 || 0, "'slerp' only accept floating-point inputs") ;
        static_assert(std::numeric_limits<S>::is_integer, "'slerp' only accept integer for spin count") ;

        qua<T, Q> z = y;

        T cosTheta = dot(x, y);

        
        
        if (cosTheta < static_cast<T>(0))
        {
            z = -y;
            cosTheta = -cosTheta;
        }

        
        if (cosTheta > static_cast<T>(1) - epsilon<T>())
        {
            
            return qua<T, Q>::wxyz(
                mix(x.w, z.w, a),
                mix(x.x, z.x, a),
                mix(x.y, z.y, a),
                mix(x.z, z.z, a));
        }
        else
        {
            
            T angle = acos(cosTheta);
            T phi = angle + static_cast<T>(k) * glm::pi<T>();
            return (sin(angle - a * phi)* x + sin(a * phi) * z) / sin(angle);
        }
    }

	template<typename T, qualifier Q>
	inline constexpr qua<T, Q> conjugate(qua<T, Q> const& q)
	{
		return qua<T, Q>::wxyz(q.w, -q.x, -q.y, -q.z);
	}

	template<typename T, qualifier Q>
	inline constexpr qua<T, Q> inverse(qua<T, Q> const& q)
	{
		return conjugate(q) / dot(q, q);
	}

	template<typename T, qualifier Q>
	inline vec<4, bool, Q> isnan(qua<T, Q> const& q)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'isnan' only accept floating-point inputs") ;

		return vec<4, bool, Q>(isnan(q.x), isnan(q.y), isnan(q.z), isnan(q.w));
	}

	template<typename T, qualifier Q>
	inline vec<4, bool, Q> isinf(qua<T, Q> const& q)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'isinf' only accept floating-point inputs") ;

		return vec<4, bool, Q>(isinf(q.x), isinf(q.y), isinf(q.z), isinf(q.w));
	}
}



#line 144 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\quaternion_common.inl"

#line 136 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\quaternion_common.hpp"
#line 100 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\quaternion_double.hpp"



















#pragma once


#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_quat.hpp"



#pragma once







#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\quaternion_relational.hpp"
















#pragma once






#line 25 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\quaternion_relational.hpp"

namespace glm
{
	
	

	
	
	
	
	template<typename T, qualifier Q>
	[[nodiscard]] vec<4, bool, Q> equal(qua<T, Q> const& x, qua<T, Q> const& y);

	
	
	
	
	template<typename T, qualifier Q>
	[[nodiscard]] vec<4, bool, Q> equal(qua<T, Q> const& x, qua<T, Q> const& y, T epsilon);

	
	
	
	
	template<typename T, qualifier Q>
	[[nodiscard]] vec<4, bool, Q> notEqual(qua<T, Q> const& x, qua<T, Q> const& y);

	
	
	
	
	template<typename T, qualifier Q>
	[[nodiscard]] vec<4, bool, Q> notEqual(qua<T, Q> const& x, qua<T, Q> const& y, T epsilon);

	
} 

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\quaternion_relational.inl"
namespace glm
{
	template<typename T, qualifier Q>
	inline vec<4, bool, Q> equal(qua<T, Q> const& x, qua<T, Q> const& y)
	{
		vec<4, bool, Q> Result;
		for(length_t i = 0; i < x.length(); ++i)
			Result[i] = x[i] == y[i];
		return Result;
	}

	template<typename T, qualifier Q>
	inline vec<4, bool, Q> equal(qua<T, Q> const& x, qua<T, Q> const& y, T epsilon)
	{
		vec<4, T, Q> v(x.x - y.x, x.y - y.y, x.z - y.z, x.w - y.w);
		return lessThan(abs(v), vec<4, T, Q>(epsilon));
	}

	template<typename T, qualifier Q>
	inline vec<4, bool, Q> notEqual(qua<T, Q> const& x, qua<T, Q> const& y)
	{
		vec<4, bool, Q> Result;
		for(length_t i = 0; i < x.length(); ++i)
			Result[i] = x[i] != y[i];
		return Result;
	}

	template<typename T, qualifier Q>
	inline vec<4, bool, Q> notEqual(qua<T, Q> const& x, qua<T, Q> const& y, T epsilon)
	{
		vec<4, T, Q> v(x.x - y.x, x.y - y.y, x.z - y.z, x.w - y.w);
		return greaterThanEqual(abs(v), vec<4, T, Q>(epsilon));
	}
}

#line 63 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\quaternion_relational.hpp"
#line 13 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_quat.hpp"

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\matrix_transform.hpp"




















#pragma once












#line 35 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\matrix_transform.hpp"

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\matrix_transform.inl"



#line 37 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\matrix_transform.hpp"
#line 15 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_quat.hpp"

namespace glm
{




#line 23 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_quat.hpp"



#line 27 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_quat.hpp"
#pragma warning(push)
#pragma warning(disable: 4201)  
#line 30 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_quat.hpp"
#line 31 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_quat.hpp"

	template<typename T, qualifier Q>
	struct qua
	{
		

		typedef qua<T, Q> type;
		typedef T value_type;

		


			union
			{



					struct { T x, y, z, w; };
#line 50 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_quat.hpp"

				typename detail::storage<4, T, detail::is_aligned<Q>::value>::type data;
			};






#line 60 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_quat.hpp"

		

		typedef length_t length_type;

		
		[[nodiscard]] static constexpr length_type length(){return 4;}

		[[nodiscard]] constexpr T & operator[](length_type i);
		[[nodiscard]] constexpr T const& operator[](length_type i) const;

		

		 constexpr qua() = default ;
		 constexpr qua(qua<T, Q> const& q) = default ;
		template<qualifier P>
		constexpr qua(qua<T, P> const& q);

		

		constexpr qua(T s, vec<3, T, Q> const& v);




		constexpr qua(T w, T x, T y, T z);
#line 87 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_quat.hpp"

		[[nodiscard]] static constexpr qua<T, Q> wxyz(T w, T x, T y, T z);

		

		template<typename U, qualifier P>
		constexpr  qua(qua<U, P> const& q);

		

			[[nodiscard]] explicit operator mat<3, 3, T, Q>() const;
			[[nodiscard]] explicit operator mat<4, 4, T, Q>() const;
#line 100 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_quat.hpp"

		
		
		
		
		
		
		 qua(vec<3, T, Q> const& u, vec<3, T, Q> const& v);

		
		constexpr  qua(vec<3, T, Q> const& eulerAngles);
		constexpr  qua(mat<3, 3, T, Q> const& q);
		constexpr  qua(mat<4, 4, T, Q> const& q);

		

		 constexpr qua<T, Q>& operator=(qua<T, Q> const& q) = default ;

		template<typename U>
		 constexpr qua<T, Q>& operator=(qua<U, Q> const& q);
		template<typename U>
		 constexpr qua<T, Q>& operator+=(qua<U, Q> const& q);
		template<typename U>
		 constexpr qua<T, Q>& operator-=(qua<U, Q> const& q);
		template<typename U>
		 constexpr qua<T, Q>& operator*=(qua<U, Q> const& q);
		template<typename U>
		 constexpr qua<T, Q>& operator*=(U s);
		template<typename U>
		 constexpr qua<T, Q>& operator/=(U s);
	};




#line 136 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_quat.hpp"

#line 138 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_quat.hpp"
#pragma warning(pop)
#line 140 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_quat.hpp"
#line 141 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_quat.hpp"

	

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr qua<T, Q> operator+(qua<T, Q> const& q);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr qua<T, Q> operator-(qua<T, Q> const& q);

	

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr qua<T, Q> operator+(qua<T, Q> const& q, qua<T, Q> const& p);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr qua<T, Q> operator-(qua<T, Q> const& q, qua<T, Q> const& p);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr qua<T, Q> operator*(qua<T, Q> const& q, qua<T, Q> const& p);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator*(qua<T, Q> const& q, vec<3, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<3, T, Q> operator*(vec<3, T, Q> const& v, qua<T, Q> const& q);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator*(qua<T, Q> const& q, vec<4, T, Q> const& v);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, T, Q> operator*(vec<4, T, Q> const& v, qua<T, Q> const& q);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr qua<T, Q> operator*(qua<T, Q> const& q, T const& s);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr qua<T, Q> operator*(T const& s, qua<T, Q> const& q);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr qua<T, Q> operator/(qua<T, Q> const& q, T const& s);

	

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr bool operator==(qua<T, Q> const& q1, qua<T, Q> const& q2);

	template<typename T, qualifier Q>
	[[nodiscard]] constexpr bool operator!=(qua<T, Q> const& q1, qua<T, Q> const& q2);
} 


#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_quat.inl"






namespace glm{
namespace detail
{
	template <typename T>
	struct genTypeTrait<qua<T> >
	{
		static const genTypeEnum GENTYPE = GENTYPE_QUAT;
	};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_dot<qua<T, Q>, T, Aligned>
	{
		inline constexpr static T call(qua<T, Q> const& a, qua<T, Q> const& b)
		{
			vec<4, T, Q> tmp(a.w * b.w, a.x * b.x, a.y * b.y, a.z * b.z);
			return (tmp.x + tmp.y) + (tmp.z + tmp.w);
		}
	};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_quat_add
	{
		inline constexpr static qua<T, Q> call(qua<T, Q> const& q, qua<T, Q> const& p)
		{
			return qua<T, Q>::wxyz(q.w + p.w, q.x + p.x, q.y + p.y, q.z + p.z);
		}
	};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_quat_sub
	{
		inline constexpr static qua<T, Q> call(qua<T, Q> const& q, qua<T, Q> const& p)
		{
			return qua<T, Q>::wxyz(q.w - p.w, q.x - p.x, q.y - p.y, q.z - p.z);
		}
	};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_quat_mul_scalar
	{
		inline constexpr static qua<T, Q> call(qua<T, Q> const& q, T s)
		{
			return qua<T, Q>::wxyz(q.w * s, q.x * s, q.y * s, q.z * s);
		}
	};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_quat_div_scalar
	{
		inline constexpr static qua<T, Q> call(qua<T, Q> const& q, T s)
		{
			return qua<T, Q>::wxyz(q.w / s, q.x / s, q.y / s, q.z / s);
		}
	};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_quat_mul_vec4
	{
		inline constexpr static vec<4, T, Q> call(qua<T, Q> const& q, vec<4, T, Q> const& v)
		{
			return vec<4, T, Q>(q * vec<3, T, Q>(v), v.w);
		}
	};
}

	

	template<typename T, qualifier Q>
	inline constexpr T & qua<T, Q>::operator[](typename qua<T, Q>::length_type i)
	{
		((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_quat.inl", (unsigned)(77)), 0) )) ;



			return (&x)[i];
#line 83 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_quat.inl"
	}

	template<typename T, qualifier Q>
	inline constexpr T const& qua<T, Q>::operator[](typename qua<T, Q>::length_type i) const
	{
		((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_quat.inl", (unsigned)(88)), 0) )) ;



			return (&x)[i];
#line 94 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_quat.inl"
	}

	












#line 110 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_quat.inl"










#line 121 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_quat.inl"

	template<typename T, qualifier Q>
	template<qualifier P>
	inline constexpr qua<T, Q>::qua(qua<T, P> const& q)



			: x(q.x), y(q.y), z(q.z), w(q.w)
#line 130 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_quat.inl"
	{}

	

	template<typename T, qualifier Q>
	inline constexpr qua<T, Q>::qua(T s, vec<3, T, Q> const& v)



			: x(v.x), y(v.y), z(v.z), w(s)
#line 141 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_quat.inl"
	{}

	template <typename T, qualifier Q>



	inline constexpr qua<T, Q>::qua(T _w, T _x, T _y, T _z)
#line 149 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_quat.inl"



			: x(_x), y(_y), z(_z), w(_w)
#line 154 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_quat.inl"
	{}

	template <typename T, qualifier Q>
	constexpr qua<T, Q> qua<T, Q>::wxyz(T w, T x, T y, T z) {



		return qua<T, Q>(w, x, y, z);
#line 163 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_quat.inl"
	}
	
	

	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	inline constexpr qua<T, Q>::qua(qua<U, P> const& q)



			: x(static_cast<T>(q.x)), y(static_cast<T>(q.y)), z(static_cast<T>(q.z)), w(static_cast<T>(q.w))
#line 175 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_quat.inl"
	{}

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	template<typename T, qualifier Q>
	inline qua<T, Q>::qua(vec<3, T, Q> const& u, vec<3, T, Q> const& v)
	{
		T norm_u_norm_v = sqrt(dot(u, u) * dot(v, v));
		T real_part = norm_u_norm_v + dot(u, v);
		vec<3, T, Q> t;

		if(real_part < static_cast<T>(1.e-6f) * norm_u_norm_v)
		{
			
			
			
			real_part = static_cast<T>(0);
			t = abs(u.x) > abs(u.z) ? vec<3, T, Q>(-u.y, u.x, static_cast<T>(0)) : vec<3, T, Q>(static_cast<T>(0), -u.z, u.y);
		}
		else
		{
			
			t = cross(u, v);
		}

		*this = normalize(qua<T, Q>::wxyz(real_part, t.x, t.y, t.z));
	}

	template<typename T, qualifier Q>
	inline constexpr qua<T, Q>::qua(vec<3, T, Q> const& eulerAngle)
	{
		vec<3, T, Q> c = glm::cos(eulerAngle * T(0.5));
		vec<3, T, Q> s = glm::sin(eulerAngle * T(0.5));

		this->w = c.x * c.y * c.z + s.x * s.y * s.z;
		this->x = s.x * c.y * c.z - c.x * s.y * s.z;
		this->y = c.x * s.y * c.z + s.x * c.y * s.z;
		this->z = c.x * c.y * s.z - s.x * s.y * c.z;
	}

	template<typename T, qualifier Q>
	inline constexpr qua<T, Q>::qua(mat<3, 3, T, Q> const& m)
	{
		*this = quat_cast(m);
	}

	template<typename T, qualifier Q>
	inline constexpr qua<T, Q>::qua(mat<4, 4, T, Q> const& m)
	{
		*this = quat_cast(m);
	}


	template<typename T, qualifier Q>
	inline qua<T, Q>::operator mat<3, 3, T, Q>() const
	{
		return mat3_cast(*this);
	}

	template<typename T, qualifier Q>
	inline qua<T, Q>::operator mat<4, 4, T, Q>() const
	{
		return mat4_cast(*this);
	}
#line 256 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_quat.inl"

	











#line 270 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_quat.inl"

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr qua<T, Q> & qua<T, Q>::operator=(qua<U, Q> const& q)
	{
		this->w = static_cast<T>(q.w);
		this->x = static_cast<T>(q.x);
		this->y = static_cast<T>(q.y);
		this->z = static_cast<T>(q.z);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr qua<T, Q> & qua<T, Q>::operator+=(qua<U, Q> const& q)
	{
		return (*this = detail::compute_quat_add<T, Q, detail::is_aligned<Q>::value>::call(*this, qua<T, Q>(q)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr qua<T, Q> & qua<T, Q>::operator-=(qua<U, Q> const& q)
	{
		return (*this = detail::compute_quat_sub<T, Q, detail::is_aligned<Q>::value>::call(*this, qua<T, Q>(q)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr qua<T, Q> & qua<T, Q>::operator*=(qua<U, Q> const& r)
	{
		qua<T, Q> const p(*this);
		qua<T, Q> const q(r);

		this->w = p.w * q.w - p.x * q.x - p.y * q.y - p.z * q.z;
		this->x = p.w * q.x + p.x * q.w + p.y * q.z - p.z * q.y;
		this->y = p.w * q.y + p.y * q.w + p.z * q.x - p.x * q.z;
		this->z = p.w * q.z + p.z * q.w + p.x * q.y - p.y * q.x;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr qua<T, Q> & qua<T, Q>::operator*=(U s)
	{
		return (*this = detail::compute_quat_mul_scalar<T, Q, detail::is_aligned<Q>::value>::call(*this, static_cast<U>(s)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	inline constexpr qua<T, Q> & qua<T, Q>::operator/=(U s)
	{
		return (*this = detail::compute_quat_div_scalar<T, Q, detail::is_aligned<Q>::value>::call(*this, static_cast<U>(s)));
	}

	

	template<typename T, qualifier Q>
	inline constexpr qua<T, Q> operator+(qua<T, Q> const& q)
	{
		return q;
	}

	template<typename T, qualifier Q>
	inline constexpr qua<T, Q> operator-(qua<T, Q> const& q)
	{
		return qua<T, Q>::wxyz(-q.w, -q.x, -q.y, -q.z);
	}

	

	template<typename T, qualifier Q>
	inline constexpr qua<T, Q> operator+(qua<T, Q> const& q, qua<T, Q> const& p)
	{
		return qua<T, Q>(q) += p;
	}

	template<typename T, qualifier Q>
	inline constexpr qua<T, Q> operator-(qua<T, Q> const& q, qua<T, Q> const& p)
	{
		return qua<T, Q>(q) -= p;
	}

	template<typename T, qualifier Q>
	inline constexpr qua<T, Q> operator*(qua<T, Q> const& q, qua<T, Q> const& p)
	{
		return qua<T, Q>(q) *= p;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator*(qua<T, Q> const& q, vec<3, T, Q> const& v)
	{
		vec<3, T, Q> const QuatVector(q.x, q.y, q.z);
		vec<3, T, Q> const uv(glm::cross(QuatVector, v));
		vec<3, T, Q> const uuv(glm::cross(QuatVector, uv));

		return v + ((uv * q.w) + uuv) * static_cast<T>(2);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<3, T, Q> operator*(vec<3, T, Q> const& v, qua<T, Q> const& q)
	{
		return glm::inverse(q) * v;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator*(qua<T, Q> const& q, vec<4, T, Q> const& v)
	{
		return detail::compute_quat_mul_vec4<T, Q, detail::is_aligned<Q>::value>::call(q, v);
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, T, Q> operator*(vec<4, T, Q> const& v, qua<T, Q> const& q)
	{
		return glm::inverse(q) * v;
	}

	template<typename T, qualifier Q>
	inline constexpr qua<T, Q> operator*(qua<T, Q> const& q, T const& s)
	{
		return qua<T, Q>::wxyz(
			q.w * s, q.x * s, q.y * s, q.z * s);
	}

	template<typename T, qualifier Q>
	inline constexpr qua<T, Q> operator*(T const& s, qua<T, Q> const& q)
	{
		return q * s;
	}

	template<typename T, qualifier Q>
	inline constexpr qua<T, Q> operator/(qua<T, Q> const& q, T const& s)
	{
		return qua<T, Q>::wxyz(
			q.w / s, q.x / s, q.y / s, q.z / s);
	}

	

	template<typename T, qualifier Q>
	inline constexpr bool operator==(qua<T, Q> const& q1, qua<T, Q> const& q2)
	{
		return q1.x == q2.x && q1.y == q2.y && q1.z == q2.z && q1.w == q2.w;
	}

	template<typename T, qualifier Q>
	inline constexpr bool operator!=(qua<T, Q> const& q1, qua<T, Q> const& q2)
	{
		return q1.x != q2.x || q1.y != q2.y || q1.z != q2.z || q1.w != q2.w;
	}
}



#line 424 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_quat.inl"

#line 193 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_quat.hpp"
#line 194 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\type_quat.hpp"
#line 24 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\quaternion_double.hpp"



#line 28 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\quaternion_double.hpp"

namespace glm
{
	
	

	
	typedef qua<double, defaultp>		dquat;

	
} 

#line 101 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\quaternion_double_precision.hpp"










#pragma once






#line 19 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\quaternion_double_precision.hpp"

namespace glm
{
	
	

	
	
	
	typedef qua<double, lowp>		lowp_dquat;

	
	
	
	typedef qua<double, mediump>	mediump_dquat;

	
	
	
	typedef qua<double, highp>		highp_dquat;

	
} 

#line 102 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\quaternion_float.hpp"



















#pragma once






#line 28 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\quaternion_float.hpp"

namespace glm
{
	
	

	
	typedef qua<float, defaultp>		quat;

	
} 

#line 103 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\quaternion_float_precision.hpp"










#pragma once






#line 19 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\quaternion_float_precision.hpp"

namespace glm
{
	
	

	
	typedef qua<float, lowp>		lowp_quat;

	
	typedef qua<float, mediump>		mediump_quat;

	
	typedef qua<float, highp>		highp_quat;

	
} 

#line 104 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\quaternion_exponential.hpp"














#pragma once









#line 26 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\quaternion_exponential.hpp"

namespace glm
{
	
	

	
	
	
	
	template<typename T, qualifier Q>
	[[nodiscard]] qua<T, Q> exp(qua<T, Q> const& q);

	
	
	
	
	template<typename T, qualifier Q>
	[[nodiscard]] qua<T, Q> log(qua<T, Q> const& q);

	
	
	
	
	template<typename T, qualifier Q>
	[[nodiscard]] qua<T, Q> pow(qua<T, Q> const& q, T y);

	
	
	
	
	template<typename T, qualifier Q>
	[[nodiscard]] qua<T, Q> sqrt(qua<T, Q> const& q);

	
} 

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\quaternion_exponential.inl"


namespace glm
{
	template<typename T, qualifier Q>
	inline qua<T, Q> exp(qua<T, Q> const& q)
	{
		vec<3, T, Q> u(q.x, q.y, q.z);
		T const Angle = glm::length(u);
		if (Angle < epsilon<T>())
			return qua<T, Q>();

		vec<3, T, Q> const v(u / Angle);
		return qua<T, Q>(cos(Angle), sin(Angle) * v);
	}

	template<typename T, qualifier Q>
	inline qua<T, Q> log(qua<T, Q> const& q)
	{
		vec<3, T, Q> u(q.x, q.y, q.z);
		T Vec3Len = length(u);

		if (Vec3Len < epsilon<T>())
		{
			if(q.w > static_cast<T>(0))
				return qua<T, Q>::wxyz(log(q.w), static_cast<T>(0), static_cast<T>(0), static_cast<T>(0));
			else if(q.w < static_cast<T>(0))
				return qua<T, Q>::wxyz(log(-q.w), pi<T>(), static_cast<T>(0), static_cast<T>(0));
			else
				return qua<T, Q>::wxyz(std::numeric_limits<T>::infinity(), std::numeric_limits<T>::infinity(), std::numeric_limits<T>::infinity(), std::numeric_limits<T>::infinity());
		}
		else
		{
			T t = atan(Vec3Len, T(q.w)) / Vec3Len;
			T QuatLen2 = Vec3Len * Vec3Len + q.w * q.w;
			return qua<T, Q>::wxyz(static_cast<T>(0.5) * log(QuatLen2), t * q.x, t * q.y, t * q.z);
		}
	}

	template<typename T, qualifier Q>
	inline qua<T, Q> pow(qua<T, Q> const& x, T y)
	{
		
		
		if(y > -epsilon<T>() && y < epsilon<T>())
			return qua<T, Q>::wxyz(1,0,0,0);

		
		T magnitude = sqrt(x.x * x.x + x.y * x.y + x.z * x.z + x.w *x.w);

		T Angle;
		if(abs(x.w / magnitude) > cos_one_over_two<T>())
		{
			
			

			
			T VectorMagnitude = x.x * x.x + x.y * x.y + x.z * x.z;
			
			
			
			
			if (VectorMagnitude < std::numeric_limits<T>::min()) {
				
				return qua<T, Q>::wxyz(pow(x.w, y), 0, 0, 0);
			}

			Angle = asin(sqrt(VectorMagnitude) / magnitude);
		}
		else
		{
			
			Angle = acos(x.w / magnitude);
		}

		T NewAngle = Angle * y;
		T Div = sin(NewAngle) / sin(Angle);
		T Mag = pow(magnitude, y - static_cast<T>(1));
		return qua<T, Q>::wxyz(cos(NewAngle) * magnitude * Mag, x.x * Div * Mag, x.y * Div * Mag, x.z * Div * Mag);
	}

	template<typename T, qualifier Q>
	inline qua<T, Q> sqrt(qua<T, Q> const& x)
	{
		return pow(x, static_cast<T>(0.5));
	}
}


#line 64 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\quaternion_exponential.hpp"
#line 105 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"


#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\quaternion_transform.hpp"

















#pragma once








#line 28 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\quaternion_transform.hpp"

namespace glm
{
	
	

	
	
	
	
	
	
	
	
	template<typename T, qualifier Q>
	[[nodiscard]] qua<T, Q> rotate(qua<T, Q> const& q, T const& angle, vec<3, T, Q> const& axis);
	
} 

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\quaternion_transform.inl"
namespace glm
{
	template<typename T, qualifier Q>
	inline qua<T, Q> rotate(qua<T, Q> const& q, T const& angle, vec<3, T, Q> const& v)
	{
		vec<3, T, Q> Tmp = v;

		
		T len = glm::length(Tmp);
		if(abs(len - static_cast<T>(1)) > static_cast<T>(0.001))
		{
			T oneOverLen = static_cast<T>(1) / len;
			Tmp.x *= oneOverLen;
			Tmp.y *= oneOverLen;
			Tmp.z *= oneOverLen;
		}

		T const AngleRad(angle);
		T const Sin = sin(AngleRad * static_cast<T>(0.5));

		return q * qua<T, Q>::wxyz(cos(AngleRad * static_cast<T>(0.5)), Tmp.x * Sin, Tmp.y * Sin, Tmp.z * Sin);
	}
}

#line 48 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\quaternion_transform.hpp"
#line 108 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\quaternion_trigonometric.hpp"

















#pragma once










#line 30 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\quaternion_trigonometric.hpp"

namespace glm
{
	
	

	
	
	
	
	
	
	template<typename T, qualifier Q>
	[[nodiscard]] T angle(qua<T, Q> const& x);

	
	
	
	
	template<typename T, qualifier Q>
	[[nodiscard]] vec<3, T, Q> axis(qua<T, Q> const& x);

	
	
	
	
	
	
	
	template<typename T, qualifier Q>
	[[nodiscard]] qua<T, Q> angleAxis(T const& angle, vec<3, T, Q> const& axis);

	
} 

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\quaternion_trigonometric.inl"


namespace glm
{
	template<typename T, qualifier Q>
	inline T angle(qua<T, Q> const& x)
	{
		if (abs(x.w) > cos_one_over_two<T>())
		{
			T const a = asin(sqrt(x.x * x.x + x.y * x.y + x.z * x.z)) * static_cast<T>(2);
			if(x.w < static_cast<T>(0))
				return pi<T>() * static_cast<T>(2) - a;
			return a;
		}

		return acos(x.w) * static_cast<T>(2);
	}

	template<typename T, qualifier Q>
	inline vec<3, T, Q> axis(qua<T, Q> const& x)
	{
		T const tmp1 = static_cast<T>(1) - x.w * x.w;
		if(tmp1 <= static_cast<T>(0))
			return vec<3, T, Q>(0, 0, 1);
		T const tmp2 = static_cast<T>(1) / sqrt(tmp1);
		return vec<3, T, Q>(x.x * tmp2, x.y * tmp2, x.z * tmp2);
	}

	template<typename T, qualifier Q>
	inline qua<T, Q> angleAxis(T const& angle, vec<3, T, Q> const& v)
	{
		T const a(angle);
		T const s = glm::sin(a * static_cast<T>(0.5));

		return qua<T, Q>(glm::cos(a * static_cast<T>(0.5)), v * s);
	}
}
#line 66 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\quaternion_trigonometric.hpp"
#line 109 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_common.hpp"













#pragma once






#line 22 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_common.hpp"

namespace glm
{
	
	

	
	
	
	
	
	template<typename T>
	[[nodiscard]] T min(T a, T b, T c);

	
	
	
	
	
	template<typename T>
	[[nodiscard]] T min(T a, T b, T c, T d);

	
	
	
	
	
	template<typename T>
	[[nodiscard]] T max(T a, T b, T c);

	
	
	
	
	
	template<typename T>
	[[nodiscard]] T max(T a, T b, T c, T d);

	
	
	
	
	
	
	template<typename T>
	[[nodiscard]] T fmin(T a, T b);

	
	
	
	
	
	
	template<typename T>
	[[nodiscard]] T fmin(T a, T b, T c);

	
	
	
	
	
	
	template<typename T>
	[[nodiscard]] T fmin(T a, T b, T c, T d);

	
	
	
	
	
	
	template<typename T>
	[[nodiscard]] T fmax(T a, T b);

	
	
	
	
	
	
	template<typename T>
	[[nodiscard]] T fmax(T a, T b, T C);

	
	
	
	
	
	
	template<typename T>
	[[nodiscard]] T fmax(T a, T b, T C, T D);

	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType fclamp(genType x, genType minVal, genType maxVal);

	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType clamp(genType const& Texcoord);

	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType repeat(genType const& Texcoord);

	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType mirrorClamp(genType const& Texcoord);

	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType mirrorRepeat(genType const& Texcoord);

	
	
	
	
	
	
	
	
	
	template<typename genType>
	[[nodiscard]] int iround(genType const& x);

	
	
	
	
	
	
	
	
	
	template<typename genType>
	[[nodiscard]] uint uround(genType const& x);

	
}

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_common.inl"
namespace glm
{
	template<typename T>
	inline T min(T a, T b, T c)
	{
		return glm::min(glm::min(a, b), c);
	}

	template<typename T>
	inline T min(T a, T b, T c, T d)
	{
		return glm::min(glm::min(a, b), glm::min(c, d));
	}

	template<typename T>
	inline T max(T a, T b, T c)
	{
		return glm::max(glm::max(a, b), c);
	}

	template<typename T>
	inline T max(T a, T b, T c, T d)
	{
		return glm::max(glm::max(a, b), glm::max(c, d));
	}


		using std::fmin;










#line 40 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_common.inl"

	template<typename T>
	inline T fmin(T a, T b, T c)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'fmin' only accept floating-point input") ;

		if (isnan(a))
			return fmin(b, c);
		if (isnan(b))
			return fmin(a, c);
		if (isnan(c))
			return min(a, b);
		return min(a, b, c);
	}

	template<typename T>
	inline T fmin(T a, T b, T c, T d)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'fmin' only accept floating-point input") ;

		if (isnan(a))
			return fmin(b, c, d);
		if (isnan(b))
			return min(a, fmin(c, d));
		if (isnan(c))
			return fmin(min(a, b), d);
		if (isnan(d))
			return min(a, b, c);
		return min(a, b, c, d);
	}



		using std::fmax;










#line 85 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_common.inl"

	template<typename T>
	inline T fmax(T a, T b, T c)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'fmax' only accept floating-point input") ;

		if (isnan(a))
			return fmax(b, c);
		if (isnan(b))
			return fmax(a, c);
		if (isnan(c))
			return max(a, b);
		return max(a, b, c);
	}

	template<typename T>
	inline T fmax(T a, T b, T c, T d)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'fmax' only accept floating-point input") ;

		if (isnan(a))
			return fmax(b, c, d);
		if (isnan(b))
			return max(a, fmax(c, d));
		if (isnan(c))
			return fmax(max(a, b), d);
		if (isnan(d))
			return max(a, b, c);
		return max(a, b, c, d);
	}

	
	template<typename genType>
	inline genType fclamp(genType x, genType minVal, genType maxVal)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'fclamp' only accept floating-point or integer inputs") ;
		return fmin(fmax(x, minVal), maxVal);
	}

	template<typename genType>
	inline genType clamp(genType const& Texcoord)
	{
		return glm::clamp(Texcoord, static_cast<genType>(0), static_cast<genType>(1));
	}

	template<typename genType>
	inline genType repeat(genType const& Texcoord)
	{
		return glm::fract(Texcoord);
	}

	template<typename genType>
	inline genType mirrorClamp(genType const& Texcoord)
	{
		return glm::fract(glm::abs(Texcoord));
	}

	template<typename genType>
	inline genType mirrorRepeat(genType const& Texcoord)
	{
		genType const Abs = glm::abs(Texcoord);
		genType const Clamp = glm::mod(glm::floor(Abs), static_cast<genType>(2));
		genType const Floor = glm::floor(Abs);
		genType const Rest = Abs - Floor;
		genType const Mirror = Clamp + Rest;
		return mix(Rest, static_cast<genType>(1) - Rest, Mirror >= static_cast<genType>(1));
	}

	template<typename genType>
	inline int iround(genType const& x)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'iround' only accept floating-point inputs") ;
		(void)( (!!(static_cast<genType>(0.0) <= x)) || (_wassert(L"static_cast<genType>(0.0) <= x", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_common.inl", (unsigned)(157)), 0) ) ;

		return static_cast<int>(x + static_cast<genType>(0.5));
	}

	template<typename genType>
	inline uint uround(genType const& x)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'uround' only accept floating-point inputs") ;
		(void)( (!!(static_cast<genType>(0.0) <= x)) || (_wassert(L"static_cast<genType>(0.0) <= x", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_common.inl", (unsigned)(166)), 0) ) ;

		return static_cast<uint>(x + static_cast<genType>(0.5));
	}
}
#line 182 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_common.hpp"
#line 111 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_integer.hpp"










#pragma once


#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 970 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
























































































































































































































#line 1187 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 1189 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
#line 15 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_integer.hpp"









#line 25 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_integer.hpp"

namespace glm
{
	
	

	
	
	
	template<typename genIUType>
	[[nodiscard]] bool isPowerOfTwo(genIUType v);

	
	
	
	
	template<typename genIUType>
	[[nodiscard]] genIUType nextPowerOfTwo(genIUType v);

	
	
	
	
	template<typename genIUType>
	[[nodiscard]] genIUType prevPowerOfTwo(genIUType v);

	
	
	
	template<typename genIUType>
	[[nodiscard]] bool isMultiple(genIUType v, genIUType Multiple);

	
	
	
	
	
	
	
	
	template<typename genIUType>
	[[nodiscard]] genIUType nextMultiple(genIUType v, genIUType Multiple);

	
	
	
	
	
	
	
	
	template<typename genIUType>
	[[nodiscard]] genIUType prevMultiple(genIUType v, genIUType Multiple);

	
	
	
	
	
	
	
	template<typename genIUType>
	[[nodiscard]] int findNSB(genIUType x, int significantBitCount);

	
} 

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_integer.inl"


namespace glm{
namespace detail
{
	template<length_t L, typename T, qualifier Q, bool compute = false>
	struct compute_ceilShift
	{
		inline static vec<L, T, Q> call(vec<L, T, Q> const& v, T)
		{
			return v;
		}
	};

	template<length_t L, typename T, qualifier Q>
	struct compute_ceilShift<L, T, Q, true>
	{
		inline static vec<L, T, Q> call(vec<L, T, Q> const& v, T Shift)
		{
			return v | (v >> Shift);
		}
	};

	template<length_t L, typename T, qualifier Q, bool isSigned = true>
	struct compute_ceilPowerOfTwo
	{
		inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
		{
			static_assert(!std::numeric_limits<T>::is_iec559 || 0, "'ceilPowerOfTwo' only accept integer scalar or vector inputs") ;

			vec<L, T, Q> const Sign(sign(x));

			vec<L, T, Q> v(abs(x));

			v = v - static_cast<T>(1);
			v = v | (v >> static_cast<T>(1));
			v = v | (v >> static_cast<T>(2));
			v = v | (v >> static_cast<T>(4));
			v = compute_ceilShift<L, T, Q, sizeof(T) >= 2>::call(v, 8);
			v = compute_ceilShift<L, T, Q, sizeof(T) >= 4>::call(v, 16);
			v = compute_ceilShift<L, T, Q, sizeof(T) >= 8>::call(v, 32);
			return (v + static_cast<T>(1)) * Sign;
		}
	};

	template<length_t L, typename T, qualifier Q>
	struct compute_ceilPowerOfTwo<L, T, Q, false>
	{
		inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
		{
			static_assert(!std::numeric_limits<T>::is_iec559 || 0, "'ceilPowerOfTwo' only accept integer scalar or vector inputs") ;

			vec<L, T, Q> v(x);

			v = v - static_cast<T>(1);
			v = v | (v >> static_cast<T>(1));
			v = v | (v >> static_cast<T>(2));
			v = v | (v >> static_cast<T>(4));
			v = compute_ceilShift<L, T, Q, sizeof(T) >= 2>::call(v, 8);
			v = compute_ceilShift<L, T, Q, sizeof(T) >= 4>::call(v, 16);
			v = compute_ceilShift<L, T, Q, sizeof(T) >= 8>::call(v, 32);
			return v + static_cast<T>(1);
		}
	};

	template<bool is_float, bool is_signed>
	struct compute_ceilMultiple{};

	template<>
	struct compute_ceilMultiple<true, true>
	{
		template<typename genType>
		inline static genType call(genType Source, genType Multiple)
		{
			if(Source > genType(0))
				return Source + (Multiple - std::fmod(Source, Multiple));
			else
				return Source + std::fmod(-Source, Multiple);
		}
	};

	template<>
	struct compute_ceilMultiple<false, false>
	{
		template<typename genType>
		inline static genType call(genType Source, genType Multiple)
		{
			genType Tmp = Source - genType(1);
			return Tmp + (Multiple - (Tmp % Multiple));
		}
	};

	template<>
	struct compute_ceilMultiple<false, true>
	{
		template<typename genType>
		inline static genType call(genType Source, genType Multiple)
		{
			(void)( (!!(Multiple > genType(0))) || (_wassert(L"Multiple > genType(0)", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_integer.inl", (unsigned)(99)), 0) ) ;
			if(Source > genType(0))
			{
				genType Tmp = Source - genType(1);
				return Tmp + (Multiple - (Tmp % Multiple));
			}
			else
				return Source + (-Source % Multiple);
		}
	};

	template<bool is_float, bool is_signed>
	struct compute_floorMultiple{};

	template<>
	struct compute_floorMultiple<true, true>
	{
		template<typename genType>
		inline static genType call(genType Source, genType Multiple)
		{
			if(Source >= genType(0))
				return Source - std::fmod(Source, Multiple);
			else
				return Source - std::fmod(Source, Multiple) - Multiple;
		}
	};

	template<>
	struct compute_floorMultiple<false, false>
	{
		template<typename genType>
		inline static genType call(genType Source, genType Multiple)
		{
			if(Source >= genType(0))
				return Source - Source % Multiple;
			else
			{
				genType Tmp = Source + genType(1);
				return Tmp - Tmp % Multiple - Multiple;
			}
		}
	};

	template<>
	struct compute_floorMultiple<false, true>
	{
		template<typename genType>
		inline static genType call(genType Source, genType Multiple)
		{
			if(Source >= genType(0))
				return Source - Source % Multiple;
			else
			{
				genType Tmp = Source + genType(1);
				return Tmp - Tmp % Multiple - Multiple;
			}
		}
	};
}

	template<typename genIUType>
	inline bool isPowerOfTwo(genIUType Value)
	{
		static_assert(std::numeric_limits<genIUType>::is_integer, "'isPowerOfTwo' only accept integer inputs") ;

		genIUType const Result = glm::abs(Value);
		return !(Result & (Result - 1));
	}

	template<typename genIUType>
	inline genIUType nextPowerOfTwo(genIUType value)
	{
		static_assert(std::numeric_limits<genIUType>::is_integer, "'nextPowerOfTwo' only accept integer inputs") ;

		return detail::compute_ceilPowerOfTwo<1, genIUType, defaultp, std::numeric_limits<genIUType>::is_signed>::call(vec<1, genIUType, defaultp>(value)).x;
	}

	template<typename genIUType>
	inline genIUType prevPowerOfTwo(genIUType value)
	{
		static_assert(std::numeric_limits<genIUType>::is_integer, "'prevPowerOfTwo' only accept integer inputs") ;

		return isPowerOfTwo(value) ? value : static_cast<genIUType>(static_cast<genIUType>(1) << static_cast<genIUType>(findMSB(value)));
	}

	template<typename genIUType>
	inline bool isMultiple(genIUType Value, genIUType Multiple)
	{
		static_assert(std::numeric_limits<genIUType>::is_integer, "'isMultiple' only accept integer inputs") ;

		return isMultiple(vec<1, genIUType>(Value), vec<1, genIUType>(Multiple)).x;
	}

	template<typename genIUType>
	inline genIUType nextMultiple(genIUType Source, genIUType Multiple)
	{
		static_assert(std::numeric_limits<genIUType>::is_integer, "'nextMultiple' only accept integer inputs") ;

		return detail::compute_ceilMultiple<std::numeric_limits<genIUType>::is_iec559, std::numeric_limits<genIUType>::is_signed>::call(Source, Multiple);
	}

	template<typename genIUType>
	inline genIUType prevMultiple(genIUType Source, genIUType Multiple)
	{
		static_assert(std::numeric_limits<genIUType>::is_integer, "'prevMultiple' only accept integer inputs") ;

		return detail::compute_floorMultiple<std::numeric_limits<genIUType>::is_iec559, std::numeric_limits<genIUType>::is_signed>::call(Source, Multiple);
	}

	template<typename genIUType>
	inline int findNSB(genIUType x, int significantBitCount)
	{
		static_assert(std::numeric_limits<genIUType>::is_integer, "'findNSB' only accept integer inputs") ;

		if(bitCount(x) < significantBitCount)
			return -1;

		genIUType const One = static_cast<genIUType>(1);
		int bitPos = 0;

		genIUType key = x;
		int nBitCount = significantBitCount;
		int Step = sizeof(x) * 8 / 2;
		while (key > One)
		{
			genIUType Mask = static_cast<genIUType>((One << Step) - One);
			genIUType currentKey = key & Mask;
			int currentBitCount = bitCount(currentKey);
			if (nBitCount > currentBitCount)
			{
				nBitCount -= currentBitCount;
				bitPos += Step;
				key >>= static_cast<genIUType>(Step);
			}
			else
			{
				key = key & Mask;
			}

			Step >>= 1;
		}

		return static_cast<int>(bitPos);
	}
}
#line 93 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_integer.hpp"
#line 113 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_packing.hpp"













#pragma once






#line 22 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_packing.hpp"

namespace glm
{
	
	


	
}

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_packing.inl"
#line 33 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_packing.hpp"
#line 114 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_reciprocal.hpp"












#pragma once


#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 970 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
























































































































































































































#line 1187 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 1189 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
#line 17 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_reciprocal.hpp"



#line 21 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_reciprocal.hpp"

namespace glm
{
	
	

	
	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType sec(genType angle);

	
	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType csc(genType angle);

	
	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType cot(genType angle);

	
	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType asec(genType x);

	
	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType acsc(genType x);

	
	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType acot(genType x);

	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType sech(genType angle);

	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType csch(genType angle);

	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType coth(genType angle);

	
	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType asech(genType x);

	
	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType acsch(genType x);

	
	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType acoth(genType x);

	
}

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_reciprocal.inl"





namespace glm
{
	
	template<typename genType>
	inline genType sec(genType angle)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'sec' only accept floating-point values") ;
		return genType(1) / glm::cos(angle);
	}

	
	template<typename genType>
	inline genType csc(genType angle)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'csc' only accept floating-point values") ;
		return genType(1) / glm::sin(angle);
	}

	
	template<typename genType>
	inline genType cot(genType angle)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'cot' only accept floating-point values") ;

		genType const pi_over_2 = genType(3.1415926535897932384626433832795 / 2.0);
		return glm::tan(pi_over_2 - angle);
	}

	
	template<typename genType>
	inline genType asec(genType x)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'asec' only accept floating-point values") ;
		return acos(genType(1) / x);
	}

	
	template<typename genType>
	inline genType acsc(genType x)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'acsc' only accept floating-point values") ;
		return asin(genType(1) / x);
	}

	
	template<typename genType>
	inline genType acot(genType x)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'acot' only accept floating-point values") ;

		genType const pi_over_2 = genType(3.1415926535897932384626433832795 / 2.0);
		return pi_over_2 - atan(x);
	}

	
	template<typename genType>
	inline genType sech(genType angle)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'sech' only accept floating-point values") ;
		return genType(1) / glm::cosh(angle);
	}

	
	template<typename genType>
	inline genType csch(genType angle)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'csch' only accept floating-point values") ;
		return genType(1) / glm::sinh(angle);
	}

	
	template<typename genType>
	inline genType coth(genType angle)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'coth' only accept floating-point values") ;
		return glm::cosh(angle) / glm::sinh(angle);
	}

	
	template<typename genType>
	inline genType asech(genType x)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'asech' only accept floating-point values") ;
		return acosh(genType(1) / x);
	}

	
	template<typename genType>
	inline genType acsch(genType x)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'acsch' only accept floating-point values") ;
		return asinh(genType(1) / x);
	}

	
	template<typename genType>
	inline genType acoth(genType x)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'acoth' only accept floating-point values") ;
		return atanh(genType(1) / x);
	}
}
#line 136 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_reciprocal.hpp"
#line 115 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_relational.hpp"














#pragma once






#line 23 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_relational.hpp"

namespace glm
{
	
	

	
	
	
	
	template<typename genType>
	[[nodiscard]] constexpr bool equal(genType const& x, genType const& y, genType const& epsilon);

	
	
	
	
	template<typename genType>
	[[nodiscard]] constexpr bool notEqual(genType const& x, genType const& y, genType const& epsilon);

	
	
	
	
	
	
	
	
	template<typename genType>
	[[nodiscard]] constexpr bool equal(genType const& x, genType const& y, int ULPs);

	
	
	
	
	
	
	
	
	template<typename genType>
	[[nodiscard]] constexpr bool notEqual(genType const& x, genType const& y, int ULPs);

	
}

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_relational.inl"





namespace glm
{
	template<typename genType>
	inline constexpr bool equal(genType const& x, genType const& y, genType const& epsilon)
	{
		return abs(x - y) <= epsilon;
	}

	template<typename genType>
	inline constexpr bool notEqual(genType const& x, genType const& y, genType const& epsilon)
	{
		return abs(x - y) > epsilon;
	}

	template<typename genType>
	inline constexpr bool equal(genType const& x, genType const& y, int MaxULPs)
	{
		detail::float_t<genType> const a(x);
		detail::float_t<genType> const b(y);

		
		if(a.negative() != b.negative())
			return false;

		
		typename detail::float_t<genType>::int_type const DiffULPs = abs(a.i - b.i);
		return DiffULPs <= MaxULPs;
	}

	template<typename genType>
	inline constexpr bool notEqual(genType const& x, genType const& y, int ULPs)
	{
		return !equal(x, y, ULPs);
	}
}
#line 69 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_relational.hpp"
#line 116 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_ulp.hpp"















#pragma once








#line 26 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_ulp.hpp"

namespace glm
{
	
	

	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType nextFloat(genType x);

	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType prevFloat(genType x);

	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType nextFloat(genType x, int ULPs);

	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType prevFloat(genType x, int ULPs);

	
	
	
	[[nodiscard]] int floatDistance(float x, float y);

	
	
	
	[[nodiscard]] int64 floatDistance(double x, double y);

	
}

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_ulp.inl"













#pragma warning(push)
#pragma warning(disable : 4127)
#pragma warning(disable : 4365) 




#line 22 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_ulp.inl"

typedef union
{
	float value;
	 
	unsigned int word;
} ieee_float_shape_type;

typedef union
{
	double value;
	struct
	{
		int lsw;
		int msw;
	} parts;
} ieee_double_shape_type;































namespace glm{
namespace detail
{
	inline float nextafterf(float x, float y)
	{
		volatile float t;
		int hx, hy, ix, iy;

		do { ieee_float_shape_type gf_u; gf_u.value = (x); (hx) = static_cast<int>(gf_u.word); } while (0) ;
		do { ieee_float_shape_type gf_u; gf_u.value = (y); (hy) = static_cast<int>(gf_u.word); } while (0) ;
		ix = hx & 0x7fffffff;		
		iy = hy & 0x7fffffff;		

		if((ix > 0x7f800000) ||	
			(iy > 0x7f800000))	
			return x + y;
		if(abs(y - x) <= epsilon<float>())
			return y;		
		if(ix == 0)
		{				
			do { ieee_float_shape_type sf_u; sf_u.word = static_cast<unsigned int>((hy & 0x80000000) | 1); (x) = sf_u.value; } while (0) ;
			t = x * x;
			if(abs(t - x) <= epsilon<float>())
				return t;
			else
				return x;	
		}
		if(hx >= 0)
		{						
			if(hx > hy)			
				hx -= 1;
			else				
				hx += 1;
		}
		else
		{						
			if(hy >= 0 || hx > hy)	
				hx -= 1;
			else				
				hx += 1;
		}
		hy = hx & 0x7f800000;
		if(hy >= 0x7f800000)
			return x + x;  		
		if(hy < 0x00800000)		
		{
			t = x * x;
			if(abs(t - x) > epsilon<float>())
			{					
				do { ieee_float_shape_type sf_u; sf_u.word = static_cast<unsigned int>(hx); (y) = sf_u.value; } while (0) ;
				return y;
			}
		}
		do { ieee_float_shape_type sf_u; sf_u.word = static_cast<unsigned int>(hx); (x) = sf_u.value; } while (0) ;
		return x;
	}

	inline double nextafter(double x, double y)
	{
		volatile double t;
		int hx, hy, ix, iy;
		unsigned int lx, ly;

		do { ieee_double_shape_type ew_u; ew_u.value = (x); (hx) = ew_u.parts.msw; (lx) = ew_u.parts.lsw; } while (0) ;
		do { ieee_double_shape_type ew_u; ew_u.value = (y); (hy) = ew_u.parts.msw; (ly) = ew_u.parts.lsw; } while (0) ;
		ix = hx & 0x7fffffff;								
		iy = hy & 0x7fffffff;								

		if(((ix >= 0x7ff00000) && ((ix - 0x7ff00000) | lx) != 0) ||	
			((iy >= 0x7ff00000) && ((iy - 0x7ff00000) | ly) != 0))	
			return x + y;
		if(abs(y - x) <= epsilon<double>())
			return y;									
		if((ix | lx) == 0)
		{													
			do { ieee_double_shape_type iw_u; iw_u.parts.msw = (hy & 0x80000000); iw_u.parts.lsw = (1); (x) = iw_u.value; } while (0) ;		
			t = x * x;
			if(abs(t - x) <= epsilon<double>())
				return t;
			else
				return x;   
		}
		if(hx >= 0) {                             
			if(hx > hy || ((hx == hy) && (lx > ly))) {    
				if(lx == 0) hx -= 1;
				lx -= 1;
			}
			else {                            
				lx += 1;
				if(lx == 0) hx += 1;
			}
		}
		else {                                
			if(hy >= 0 || hx > hy || ((hx == hy) && (lx > ly))){
				if(lx == 0) hx -= 1;
				lx -= 1;
			}
			else {                            
				lx += 1;
				if(lx == 0) hx += 1;
			}
		}
		hy = hx & 0x7ff00000;
		if(hy >= 0x7ff00000)
			return x + x;			
		if(hy < 0x00100000)
		{						
			t = x * x;
			if(abs(t - x) > epsilon<double>())
			{					
				do { ieee_double_shape_type iw_u; iw_u.parts.msw = (hx); iw_u.parts.lsw = (lx); (y) = iw_u.value; } while (0) ;
				return y;
			}
		}
		do { ieee_double_shape_type iw_u; iw_u.parts.msw = (hx); iw_u.parts.lsw = (lx); (x) = iw_u.value; } while (0) ;
		return x;
	}
}
}


#pragma warning(pop)


#line 195 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_ulp.inl"

namespace glm
{
	template<>
	inline float nextFloat(float x)
	{

			return std::nextafter(x, std::numeric_limits<float>::max());






#line 210 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_ulp.inl"
	}

	template<>
	inline double nextFloat(double x)
	{

			return std::nextafter(x, std::numeric_limits<double>::max());






#line 224 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_ulp.inl"
	}

	template<typename T>
	inline T nextFloat(T x, int ULPs)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'next_float' only accept floating-point input") ;
		(void)( (!!(ULPs >= 0)) || (_wassert(L"ULPs >= 0", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_ulp.inl", (unsigned)(230)), 0) ) ;

		T temp = x;
		for(int i = 0; i < ULPs; ++i)
			temp = nextFloat(temp);
		return temp;
	}

	inline float prevFloat(float x)
	{

			return std::nextafter(x, std::numeric_limits<float>::min());






#line 249 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_ulp.inl"
	}

	inline double prevFloat(double x)
	{

			return std::nextafter(x, std::numeric_limits<double>::min());






#line 262 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_ulp.inl"
	}

	template<typename T>
	inline T prevFloat(T x, int ULPs)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'prev_float' only accept floating-point input") ;
		(void)( (!!(ULPs >= 0)) || (_wassert(L"ULPs >= 0", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_ulp.inl", (unsigned)(268)), 0) ) ;

		T temp = x;
		for(int i = 0; i < ULPs; ++i)
			temp = prevFloat(temp);
		return temp;
	}

	inline int floatDistance(float x, float y)
	{
		detail::float_t<float> const a(x);
		detail::float_t<float> const b(y);

		return abs(a.i - b.i);
	}

	inline int64 floatDistance(double x, double y)
	{
		detail::float_t<double> const a(x);
		detail::float_t<double> const b(y);

		return abs(a.i - b.i);
	}
}
#line 78 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\scalar_ulp.hpp"
#line 117 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"




#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_common.hpp"













#pragma once







#line 23 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_common.hpp"

namespace glm
{
	
	

	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] constexpr vec<L, T, Q> min(vec<L, T, Q> const& a, vec<L, T, Q> const& b, vec<L, T, Q> const& c);

	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] constexpr vec<L, T, Q> min(vec<L, T, Q> const& a, vec<L, T, Q> const& b, vec<L, T, Q> const& c, vec<L, T, Q> const& d);

	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] constexpr vec<L, T, Q> max(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, T, Q> const& z);

	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] constexpr vec<L, T, Q> max( vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, T, Q> const& z, vec<L, T, Q> const& w);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> fmin(vec<L, T, Q> const& x, T y);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> fmin(vec<L, T, Q> const& x, vec<L, T, Q> const& y);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> fmin(vec<L, T, Q> const& a, vec<L, T, Q> const& b, vec<L, T, Q> const& c);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> fmin(vec<L, T, Q> const& a, vec<L, T, Q> const& b, vec<L, T, Q> const& c, vec<L, T, Q> const& d);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> fmax(vec<L, T, Q> const& a, T b);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> fmax(vec<L, T, Q> const& a, vec<L, T, Q> const& b);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> fmax(vec<L, T, Q> const& a, vec<L, T, Q> const& b, vec<L, T, Q> const& c);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> fmax(vec<L, T, Q> const& a, vec<L, T, Q> const& b, vec<L, T, Q> const& c, vec<L, T, Q> const& d);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> fclamp(vec<L, T, Q> const& x, T minVal, T maxVal);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> fclamp(vec<L, T, Q> const& x, vec<L, T, Q> const& minVal, vec<L, T, Q> const& maxVal);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> clamp(vec<L, T, Q> const& Texcoord);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> repeat(vec<L, T, Q> const& Texcoord);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> mirrorClamp(vec<L, T, Q> const& Texcoord);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> mirrorRepeat(vec<L, T, Q> const& Texcoord);

	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, int, Q> iround(vec<L, T, Q> const& x);

	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, uint, Q> uround(vec<L, T, Q> const& x);

	
}

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_common.inl"


namespace glm
{
	template<length_t L, typename T, qualifier Q>
	inline constexpr vec<L, T, Q> min(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, T, Q> const& z)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || std::numeric_limits<T>::is_integer, "'min' only accept floating-point or integer inputs") ;
		return glm::min(glm::min(x, y), z);
	}

	template<length_t L, typename T, qualifier Q>
	inline constexpr vec<L, T, Q> min(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, T, Q> const& z, vec<L, T, Q> const& w)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || std::numeric_limits<T>::is_integer, "'min' only accept floating-point or integer inputs") ;
		return glm::min(glm::min(x, y), glm::min(z, w));
	}

	template<length_t L, typename T, qualifier Q>
	inline constexpr vec<L, T, Q> max(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, T, Q> const& z)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || std::numeric_limits<T>::is_integer, "'max' only accept floating-point or integer inputs") ;
		return glm::max(glm::max(x, y), z);
	}

	template<length_t L, typename T, qualifier Q>
	inline constexpr vec<L, T, Q> max(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, T, Q> const& z, vec<L, T, Q> const& w)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || std::numeric_limits<T>::is_integer, "'max' only accept floating-point or integer inputs") ;
		return glm::max(glm::max(x, y), glm::max(z, w));
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> fmin(vec<L, T, Q> const& a, T b)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'fmin' only accept floating-point inputs") ;
		return detail::functor2<vec, L, T, Q>::call(fmin, a, vec<L, T, Q>(b));
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> fmin(vec<L, T, Q> const& a, vec<L, T, Q> const& b)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'fmin' only accept floating-point inputs") ;
		return detail::functor2<vec, L, T, Q>::call(fmin, a, b);
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> fmin(vec<L, T, Q> const& a, vec<L, T, Q> const& b, vec<L, T, Q> const& c)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'fmin' only accept floating-point inputs") ;
		return fmin(fmin(a, b), c);
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> fmin(vec<L, T, Q> const& a, vec<L, T, Q> const& b, vec<L, T, Q> const& c, vec<L, T, Q> const& d)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'fmin' only accept floating-point inputs") ;
		return fmin(fmin(a, b), fmin(c, d));
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> fmax(vec<L, T, Q> const& a, T b)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'fmax' only accept floating-point inputs") ;
		return detail::functor2<vec, L, T, Q>::call(fmax, a, vec<L, T, Q>(b));
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> fmax(vec<L, T, Q> const& a, vec<L, T, Q> const& b)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'fmax' only accept floating-point inputs") ;
		return detail::functor2<vec, L, T, Q>::call(fmax, a, b);
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> fmax(vec<L, T, Q> const& a, vec<L, T, Q> const& b, vec<L, T, Q> const& c)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'fmax' only accept floating-point inputs") ;
		return fmax(fmax(a, b), c);
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> fmax(vec<L, T, Q> const& a, vec<L, T, Q> const& b, vec<L, T, Q> const& c, vec<L, T, Q> const& d)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'fmax' only accept floating-point inputs") ;
		return fmax(fmax(a, b), fmax(c, d));
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> fclamp(vec<L, T, Q> const& x, T minVal, T maxVal)
	{
		return fmin(fmax(x, vec<L, T, Q>(minVal)), vec<L, T, Q>(maxVal));
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> fclamp(vec<L, T, Q> const& x, vec<L, T, Q> const& minVal, vec<L, T, Q> const& maxVal)
	{
		return fmin(fmax(x, minVal), maxVal);
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> clamp(vec<L, T, Q> const& Texcoord)
	{
		return glm::clamp(Texcoord, vec<L, T, Q>(0), vec<L, T, Q>(1));
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> repeat(vec<L, T, Q> const& Texcoord)
	{
		return glm::fract(Texcoord);
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> mirrorClamp(vec<L, T, Q> const& Texcoord)
	{
		return glm::fract(glm::abs(Texcoord));
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> mirrorRepeat(vec<L, T, Q> const& Texcoord)
	{
		vec<L, T, Q> const Abs = glm::abs(Texcoord);
		vec<L, T, Q> const Clamp = glm::mod(glm::floor(Abs), vec<L, T, Q>(2));
		vec<L, T, Q> const Floor = glm::floor(Abs);
		vec<L, T, Q> const Rest = Abs - Floor;
		vec<L, T, Q> const Mirror = Clamp + Rest;
		return mix(Rest, vec<L, T, Q>(1) - Rest, glm::greaterThanEqual(Mirror, vec<L, T, Q>(1)));
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, int, Q> iround(vec<L, T, Q> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'iround' only accept floating-point inputs") ;
		(void)( (!!(all(lessThanEqual(vec<L, T, Q>(0), x)))) || (_wassert(L"all(lessThanEqual(vec<L, T, Q>(0), x))", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_common.inl", (unsigned)(134)), 0) ) ;

		return vec<L, int, Q>(x + static_cast<T>(0.5));
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, uint, Q> uround(vec<L, T, Q> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'uround' only accept floating-point inputs") ;
		(void)( (!!(all(lessThanEqual(vec<L, T, Q>(0), x)))) || (_wassert(L"all(lessThanEqual(vec<L, T, Q>(0), x))", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_common.inl", (unsigned)(143)), 0) ) ;

		return vec<L, uint, Q>(x + static_cast<T>(0.5));
	}
}
#line 229 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_common.hpp"
#line 122 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_integer.hpp"











#pragma once


#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 970 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
























































































































































































































#line 1187 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 1189 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
#line 16 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_integer.hpp"








#line 25 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_integer.hpp"

namespace glm
{
	
	

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, bool, Q> isPowerOfTwo(vec<L, T, Q> const& v);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> nextPowerOfTwo(vec<L, T, Q> const& v);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> prevPowerOfTwo(vec<L, T, Q> const& v);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, bool, Q> isMultiple(vec<L, T, Q> const& v, T Multiple);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, bool, Q> isMultiple(vec<L, T, Q> const& v, vec<L, T, Q> const& Multiple);

	
	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> nextMultiple(vec<L, T, Q> const& v, T Multiple);

	
	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> nextMultiple(vec<L, T, Q> const& v, vec<L, T, Q> const& Multiple);

	
	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> prevMultiple(vec<L, T, Q> const& v, T Multiple);

	
	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> prevMultiple(vec<L, T, Q> const& v, vec<L, T, Q> const& Multiple);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, int, Q> findNSB(vec<L, T, Q> const& Source, vec<L, int, Q> SignificantBitCount);

	
} 

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_integer.inl"


namespace glm
{
	template<length_t L, typename T, qualifier Q>
	inline vec<L, bool, Q> isPowerOfTwo(vec<L, T, Q> const& Value)
	{
		static_assert(std::numeric_limits<T>::is_integer, "'isPowerOfTwo' only accept integer inputs") ;

		vec<L, T, Q> const Result(abs(Value));
		return equal(Result & (Result - vec<L, T, Q>(1)), vec<L, T, Q>(0));
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> nextPowerOfTwo(vec<L, T, Q> const& v)
	{
		static_assert(std::numeric_limits<T>::is_integer, "'nextPowerOfTwo' only accept integer inputs") ;

		return detail::compute_ceilPowerOfTwo<L, T, Q, std::numeric_limits<T>::is_signed>::call(v);
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> prevPowerOfTwo(vec<L, T, Q> const& v)
	{
		static_assert(std::numeric_limits<T>::is_integer, "'prevPowerOfTwo' only accept integer inputs") ;

		return detail::functor1<vec, L, T, T, Q>::call(prevPowerOfTwo, v);
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, bool, Q> isMultiple(vec<L, T, Q> const& Value, T Multiple)
	{
		static_assert(std::numeric_limits<T>::is_integer, "'isMultiple' only accept integer inputs") ;

		return equal(Value % Multiple, vec<L, T, Q>(0));
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, bool, Q> isMultiple(vec<L, T, Q> const& Value, vec<L, T, Q> const& Multiple)
	{
		static_assert(std::numeric_limits<T>::is_integer, "'isMultiple' only accept integer inputs") ;

		return equal(Value % Multiple, vec<L, T, Q>(0));
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> nextMultiple(vec<L, T, Q> const& Source, T Multiple)
	{
		static_assert(std::numeric_limits<T>::is_integer, "'nextMultiple' only accept integer inputs") ;

		return detail::functor2<vec, L, T, Q>::call(nextMultiple, Source, vec<L, T, Q>(Multiple));
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> nextMultiple(vec<L, T, Q> const& Source, vec<L, T, Q> const& Multiple)
	{
		static_assert(std::numeric_limits<T>::is_integer, "'nextMultiple' only accept integer inputs") ;

		return detail::functor2<vec, L, T, Q>::call(nextMultiple, Source, Multiple);
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> prevMultiple(vec<L, T, Q> const& Source, T Multiple)
	{
		static_assert(std::numeric_limits<T>::is_integer, "'prevMultiple' only accept integer inputs") ;

		return detail::functor2<vec, L, T, Q>::call(prevMultiple, Source, vec<L, T, Q>(Multiple));
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> prevMultiple(vec<L, T, Q> const& Source, vec<L, T, Q> const& Multiple)
	{
		static_assert(std::numeric_limits<T>::is_integer, "'prevMultiple' only accept integer inputs") ;

		return detail::functor2<vec, L, T, Q>::call(prevMultiple, Source, Multiple);
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, int, Q> findNSB(vec<L, T, Q> const& Source, vec<L, int, Q> SignificantBitCount)
	{
		static_assert(std::numeric_limits<T>::is_integer, "'findNSB' only accept integer inputs") ;

		return detail::functor2_vec_int<L, T, Q>::call(findNSB, Source, SignificantBitCount);
	}
}
#line 150 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_integer.hpp"
#line 123 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_packing.hpp"













#pragma once






#line 22 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_packing.hpp"

namespace glm
{
	
	


	
}

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_packing.inl"
#line 33 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_packing.hpp"
#line 124 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_reciprocal.hpp"












#pragma once


#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 970 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
























































































































































































































#line 1187 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 1189 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
#line 17 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_reciprocal.hpp"



#line 21 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_reciprocal.hpp"

namespace glm
{
	
	

	
	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType sec(genType angle);

	
	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType csc(genType angle);

	
	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType cot(genType angle);

	
	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType asec(genType x);

	
	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType acsc(genType x);

	
	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType acot(genType x);

	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType sech(genType angle);

	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType csch(genType angle);

	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType coth(genType angle);

	
	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType asech(genType x);

	
	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType acsch(genType x);

	
	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType acoth(genType x);

	
}

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_reciprocal.inl"





namespace glm
{
	
	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> sec(vec<L, T, Q> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'sec' only accept floating-point inputs") ;
		return static_cast<T>(1) / detail::functor1<vec, L, T, T, Q>::call(cos, x);
	}

	
	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> csc(vec<L, T, Q> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'csc' only accept floating-point inputs") ;
		return static_cast<T>(1) / detail::functor1<vec, L, T, T, Q>::call(sin, x);
	}

	
	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> cot(vec<L, T, Q> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'cot' only accept floating-point inputs") ;
		T const pi_over_2 = static_cast<T>(3.1415926535897932384626433832795 / 2.0);
		return detail::functor1<vec, L, T, T, Q>::call(tan, pi_over_2 - x);
	}

	
	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> asec(vec<L, T, Q> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'asec' only accept floating-point inputs") ;
		return detail::functor1<vec, L, T, T, Q>::call(acos, static_cast<T>(1) / x);
	}

	
	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> acsc(vec<L, T, Q> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'acsc' only accept floating-point inputs") ;
		return detail::functor1<vec, L, T, T, Q>::call(asin, static_cast<T>(1) / x);
	}

	
	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> acot(vec<L, T, Q> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'acot' only accept floating-point inputs") ;
		T const pi_over_2 = static_cast<T>(3.1415926535897932384626433832795 / 2.0);
		return pi_over_2 - detail::functor1<vec, L, T, T, Q>::call(atan, x);
	}

	
	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> sech(vec<L, T, Q> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'sech' only accept floating-point inputs") ;
		return static_cast<T>(1) / detail::functor1<vec, L, T, T, Q>::call(cosh, x);
	}

	
	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> csch(vec<L, T, Q> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'csch' only accept floating-point inputs") ;
		return static_cast<T>(1) / detail::functor1<vec, L, T, T, Q>::call(sinh, x);
	}

	
	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> coth(vec<L, T, Q> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'coth' only accept floating-point inputs") ;
		return glm::cosh(x) / glm::sinh(x);
	}

	
	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> asech(vec<L, T, Q> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'asech' only accept floating-point inputs") ;
		return detail::functor1<vec, L, T, T, Q>::call(acosh, static_cast<T>(1) / x);
	}

	
	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> acsch(vec<L, T, Q> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'acsch' only accept floating-point inputs") ;
		return detail::functor1<vec, L, T, T, Q>::call(asinh, static_cast<T>(1) / x);
	}

	
	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> acoth(vec<L, T, Q> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'acoth' only accept floating-point inputs") ;
		return detail::functor1<vec, L, T, T, Q>::call(atanh, static_cast<T>(1) / x);
	}
}
#line 136 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_reciprocal.hpp"
#line 125 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_ulp.hpp"
















#pragma once






#line 25 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_ulp.hpp"

namespace glm
{
	
	

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> nextFloat(vec<L, T, Q> const& x);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> nextFloat(vec<L, T, Q> const& x, int ULPs);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> nextFloat(vec<L, T, Q> const& x, vec<L, int, Q> const& ULPs);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> prevFloat(vec<L, T, Q> const& x);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> prevFloat(vec<L, T, Q> const& x, int ULPs);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> prevFloat(vec<L, T, Q> const& x, vec<L, int, Q> const& ULPs);

	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, int, Q> floatDistance(vec<L, float, Q> const& x, vec<L, float, Q> const& y);

	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, int64, Q> floatDistance(vec<L, double, Q> const& x, vec<L, double, Q> const& y);

	
}

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_ulp.inl"
namespace glm
{
	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> nextFloat(vec<L, T, Q> const& x)
	{
		vec<L, T, Q> Result(0);
		for(length_t i = 0, n = Result.length(); i < n; ++i)
			Result[i] = nextFloat(x[i]);
		return Result;
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> nextFloat(vec<L, T, Q> const& x, int ULPs)
	{
		vec<L, T, Q> Result(0);
		for(length_t i = 0, n = Result.length(); i < n; ++i)
			Result[i] = nextFloat(x[i], ULPs);
		return Result;
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> nextFloat(vec<L, T, Q> const& x, vec<L, int, Q> const& ULPs)
	{
		vec<L, T, Q> Result(0);
		for(length_t i = 0, n = Result.length(); i < n; ++i)
			Result[i] = nextFloat(x[i], ULPs[i]);
		return Result;
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> prevFloat(vec<L, T, Q> const& x)
	{
		vec<L, T, Q> Result(0);
		for(length_t i = 0, n = Result.length(); i < n; ++i)
			Result[i] = prevFloat(x[i]);
		return Result;
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> prevFloat(vec<L, T, Q> const& x, int ULPs)
	{
		vec<L, T, Q> Result(0);
		for(length_t i = 0, n = Result.length(); i < n; ++i)
			Result[i] = prevFloat(x[i], ULPs);
		return Result;
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> prevFloat(vec<L, T, Q> const& x, vec<L, int, Q> const& ULPs)
	{
		vec<L, T, Q> Result(0);
		for(length_t i = 0, n = Result.length(); i < n; ++i)
			Result[i] = prevFloat(x[i], ULPs[i]);
		return Result;
	}

	template<length_t L, qualifier Q>
	inline vec<L, int, Q> floatDistance(vec<L, float, Q> const& x, vec<L, float, Q> const& y)
	{
		vec<L, int, Q> Result(0);
		for(length_t i = 0, n = Result.length(); i < n; ++i)
			Result[i] = floatDistance(x[i], y[i]);
		return Result;
	}

	template<length_t L, qualifier Q>
	inline vec<L, int64, Q> floatDistance(vec<L, double, Q> const& x, vec<L, double, Q> const& y)
	{
		vec<L, int64, Q> Result(0);
		for(length_t i = 0, n = Result.length(); i < n; ++i)
			Result[i] = floatDistance(x[i], y[i]);
		return Result;
	}
}
#line 113 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_ulp.hpp"
#line 127 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_bool1.hpp"












#pragma once





#line 20 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_bool1.hpp"

namespace glm
{
	
	

	
	typedef vec<1, bool, defaultp>		bvec1;

	
}
#line 129 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_bool1_precision.hpp"










#pragma once





#line 18 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_bool1_precision.hpp"

namespace glm
{
	
	

	
	typedef vec<1, bool, highp>			highp_bvec1;

	
	typedef vec<1, bool, mediump>		mediump_bvec1;

	
	typedef vec<1, bool, lowp>			lowp_bvec1;

	
}
#line 130 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"







#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_double1.hpp"













#pragma once





#line 21 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_double1.hpp"

namespace glm
{
	
	

	
	typedef vec<1, double, defaultp>		dvec1;

	
}
#line 138 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_double1_precision.hpp"












#pragma once





#line 20 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_double1_precision.hpp"

namespace glm
{
	
	

	
	typedef vec<1, double, highp>		highp_dvec1;

	
	typedef vec<1, double, mediump>		mediump_dvec1;

	
	typedef vec<1, double, lowp>		lowp_dvec1;

	
}
#line 139 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"







#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_float1.hpp"













#pragma once





#line 21 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_float1.hpp"

namespace glm
{
	
	

	
	typedef vec<1, float, defaultp>		vec1;

	
}
#line 147 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_float1_precision.hpp"












#pragma once





#line 20 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_float1_precision.hpp"

namespace glm
{
	
	

	
	typedef vec<1, float, highp>		highp_vec1;

	
	typedef vec<1, float, mediump>		mediump_vec1;

	
	typedef vec<1, float, lowp>			lowp_vec1;

	
}
#line 148 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"







#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_int1.hpp"













#pragma once





#line 21 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_int1.hpp"

namespace glm
{
	
	

	
	typedef vec<1, int, defaultp>			ivec1;

	
}

#line 156 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_int1_sized.hpp"













#pragma once






#line 22 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_int1_sized.hpp"

namespace glm
{
	
	

	
	
	
	typedef vec<1, int8, defaultp>	i8vec1;

	
	
	
	typedef vec<1, int16, defaultp>	i16vec1;

	
	
	
	typedef vec<1, int32, defaultp>	i32vec1;

	
	
	
	typedef vec<1, int64, defaultp>	i64vec1;

	
}
#line 157 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"







#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_uint1.hpp"













#pragma once





#line 21 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_uint1.hpp"

namespace glm
{
	
	

	
	typedef vec<1, unsigned int, defaultp>			uvec1;

	
}

#line 165 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_uint1_sized.hpp"













#pragma once






#line 22 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext\\vector_uint1_sized.hpp"

namespace glm
{
	
	

	
	
	
	typedef vec<1, uint8, defaultp>		u8vec1;

	
	
	
	typedef vec<1, uint16, defaultp>	u16vec1;

	
	
	
	typedef vec<1, uint32, defaultp>	u32vec1;

	
	
	
	typedef vec<1, uint64, defaultp>	u64vec1;

	
}
#line 166 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"







#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\bitfield.hpp"













#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 970 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
























































































































































































































#line 1187 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 1189 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
#line 15 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\bitfield.hpp"

#pragma once






#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\type_precision.hpp"













#pragma once


#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\quaternion.hpp"













#pragma once





















#line 37 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\quaternion.hpp"

namespace glm
{
	
	

	
	
	
	
	
	
	template<typename T, qualifier Q>
	[[nodiscard]] vec<3, T, Q> eulerAngles(qua<T, Q> const& x);

	
	
	
	
	
	template<typename T, qualifier Q>
	[[nodiscard]] T roll(qua<T, Q> const& x);

	
	
	
	
	
	template<typename T, qualifier Q>
	[[nodiscard]] T pitch(qua<T, Q> const& x);

	
	
	
	
	
	template<typename T, qualifier Q>
	[[nodiscard]] T yaw(qua<T, Q> const& x);

	
	
	
	
	
	template<typename T, qualifier Q>
	[[nodiscard]] mat<3, 3, T, Q> mat3_cast(qua<T, Q> const& x);

	
	
	
	
	
	template<typename T, qualifier Q>
	[[nodiscard]] mat<4, 4, T, Q> mat4_cast(qua<T, Q> const& x);

	
	
	
	
	
	template<typename T, qualifier Q>
	[[nodiscard]] qua<T, Q> quat_cast(mat<3, 3, T, Q> const& x);

	
	
	
	
	
	template<typename T, qualifier Q>
	[[nodiscard]] qua<T, Q> quat_cast(mat<4, 4, T, Q> const& x);

	
	
	
	
	
	
	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, bool, Q> lessThan(qua<T, Q> const& x, qua<T, Q> const& y);

	
	
	
	
	
	
	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, bool, Q> lessThanEqual(qua<T, Q> const& x, qua<T, Q> const& y);

	
	
	
	
	
	
	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, bool, Q> greaterThan(qua<T, Q> const& x, qua<T, Q> const& y);

	
	
	
	
	
	
	template<typename T, qualifier Q>
	[[nodiscard]] constexpr vec<4, bool, Q> greaterThanEqual(qua<T, Q> const& x, qua<T, Q> const& y);

	
	
	
	
	template<typename T, qualifier Q>
	[[nodiscard]] qua<T, Q> quatLookAt(
		vec<3, T, Q> const& direction,
		vec<3, T, Q> const& up);

	
	
	
	
	template<typename T, qualifier Q>
	[[nodiscard]] qua<T, Q> quatLookAtRH(
		vec<3, T, Q> const& direction,
		vec<3, T, Q> const& up);

	
	
	
	
	template<typename T, qualifier Q>
	[[nodiscard]] qua<T, Q> quatLookAtLH(
		vec<3, T, Q> const& direction,
		vec<3, T, Q> const& up);
	
} 

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\quaternion.inl"



#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\epsilon.hpp"













#pragma once


#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 970 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
























































































































































































































#line 1187 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 1189 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
#line 18 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\epsilon.hpp"




#line 23 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\epsilon.hpp"

namespace glm
{
	
	

	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, bool, Q> epsilonEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, T const& epsilon);

	
	
	
	
	template<typename genType>
	[[nodiscard]] bool epsilonEqual(genType const& x, genType const& y, genType const& epsilon);

	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, bool, Q> epsilonNotEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, T const& epsilon);

	
	
	
	
	template<typename genType>
	[[nodiscard]] bool epsilonNotEqual(genType const& x, genType const& y, genType const& epsilon);

	
}

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\epsilon.inl"






namespace glm
{
	template<>
	inline bool epsilonEqual
	(
		float const& x,
		float const& y,
		float const& epsilon
	)
	{
		return abs(x - y) < epsilon;
	}

	template<>
	inline bool epsilonEqual
	(
		double const& x,
		double const& y,
		double const& epsilon
	)
	{
		return abs(x - y) < epsilon;
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, bool, Q> epsilonEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, T const& epsilon)
	{
		return lessThan(abs(x - y), vec<L, T, Q>(epsilon));
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, bool, Q> epsilonEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, T, Q> const& epsilon)
	{
		return lessThan(abs(x - y), vec<L, T, Q>(epsilon));
	}

	template<>
	inline bool epsilonNotEqual(float const& x, float const& y, float const& epsilon)
	{
		return abs(x - y) >= epsilon;
	}

	template<>
	inline bool epsilonNotEqual(double const& x, double const& y, double const& epsilon)
	{
		return abs(x - y) >= epsilon;
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, bool, Q> epsilonNotEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, T const& epsilon)
	{
		return greaterThanEqual(abs(x - y), vec<L, T, Q>(epsilon));
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, bool, Q> epsilonNotEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, T, Q> const& epsilon)
	{
		return greaterThanEqual(abs(x - y), vec<L, T, Q>(epsilon));
	}

	template<typename T, qualifier Q>
	inline vec<4, bool, Q> epsilonEqual(qua<T, Q> const& x, qua<T, Q> const& y, T const& epsilon)
	{
		vec<4, T, Q> v(x.x - y.x, x.y - y.y, x.z - y.z, x.w - y.w);
		return lessThan(abs(v), vec<4, T, Q>(epsilon));
	}

	template<typename T, qualifier Q>
	inline vec<4, bool, Q> epsilonNotEqual(qua<T, Q> const& x, qua<T, Q> const& y, T const& epsilon)
	{
		vec<4, T, Q> v(x.x - y.x, x.y - y.y, x.z - y.z, x.w - y.w);
		return greaterThanEqual(abs(v), vec<4, T, Q>(epsilon));
	}
}
#line 61 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\epsilon.hpp"
#line 5 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\quaternion.inl"


namespace glm
{
	template<typename T, qualifier Q>
	inline vec<3, T, Q> eulerAngles(qua<T, Q> const& x)
	{
		return vec<3, T, Q>(pitch(x), yaw(x), roll(x));
	}

	template<typename T, qualifier Q>
	inline T roll(qua<T, Q> const& q)
	{
		T const y = static_cast<T>(2) * (q.x * q.y + q.w * q.z);
		T const x = q.w * q.w + q.x * q.x - q.y * q.y - q.z * q.z;

		if(all(equal(vec<2, T, Q>(x, y), vec<2, T, Q>(0), epsilon<T>()))) 
			return static_cast<T>(0);

		return static_cast<T>(atan(y, x));
	}

	template<typename T, qualifier Q>
	inline T pitch(qua<T, Q> const& q)
	{
		
		T const y = static_cast<T>(2) * (q.y * q.z + q.w * q.x);
		T const x = q.w * q.w - q.x * q.x - q.y * q.y + q.z * q.z;

		if(all(equal(vec<2, T, Q>(x, y), vec<2, T, Q>(0), epsilon<T>()))) 
			return static_cast<T>(static_cast<T>(2) * atan(q.x, q.w));

		return static_cast<T>(atan(y, x));
	}

	template<typename T, qualifier Q>
	inline T yaw(qua<T, Q> const& q)
	{
		return asin(clamp(static_cast<T>(-2) * (q.x * q.z - q.w * q.y), static_cast<T>(-1), static_cast<T>(1)));
	}

	template<typename T, qualifier Q>
	inline mat<3, 3, T, Q> mat3_cast(qua<T, Q> const& q)
	{
		mat<3, 3, T, Q> Result(T(1));
		T qxx(q.x * q.x);
		T qyy(q.y * q.y);
		T qzz(q.z * q.z);
		T qxz(q.x * q.z);
		T qxy(q.x * q.y);
		T qyz(q.y * q.z);
		T qwx(q.w * q.x);
		T qwy(q.w * q.y);
		T qwz(q.w * q.z);

		Result[0][0] = T(1) - T(2) * (qyy +  qzz);
		Result[0][1] = T(2) * (qxy + qwz);
		Result[0][2] = T(2) * (qxz - qwy);

		Result[1][0] = T(2) * (qxy - qwz);
		Result[1][1] = T(1) - T(2) * (qxx +  qzz);
		Result[1][2] = T(2) * (qyz + qwx);

		Result[2][0] = T(2) * (qxz + qwy);
		Result[2][1] = T(2) * (qyz - qwx);
		Result[2][2] = T(1) - T(2) * (qxx +  qyy);
		return Result;
	}

	template<typename T, qualifier Q>
	inline mat<4, 4, T, Q> mat4_cast(qua<T, Q> const& q)
	{
		return mat<4, 4, T, Q>(mat3_cast(q));
	}

	template<typename T, qualifier Q>
	inline qua<T, Q> quat_cast(mat<3, 3, T, Q> const& m)
	{
		T fourXSquaredMinus1 = m[0][0] - m[1][1] - m[2][2];
		T fourYSquaredMinus1 = m[1][1] - m[0][0] - m[2][2];
		T fourZSquaredMinus1 = m[2][2] - m[0][0] - m[1][1];
		T fourWSquaredMinus1 = m[0][0] + m[1][1] + m[2][2];

		int biggestIndex = 0;
		T fourBiggestSquaredMinus1 = fourWSquaredMinus1;
		if(fourXSquaredMinus1 > fourBiggestSquaredMinus1)
		{
			fourBiggestSquaredMinus1 = fourXSquaredMinus1;
			biggestIndex = 1;
		}
		if(fourYSquaredMinus1 > fourBiggestSquaredMinus1)
		{
			fourBiggestSquaredMinus1 = fourYSquaredMinus1;
			biggestIndex = 2;
		}
		if(fourZSquaredMinus1 > fourBiggestSquaredMinus1)
		{
			fourBiggestSquaredMinus1 = fourZSquaredMinus1;
			biggestIndex = 3;
		}

		T biggestVal = sqrt(fourBiggestSquaredMinus1 + static_cast<T>(1)) * static_cast<T>(0.5);
		T mult = static_cast<T>(0.25) / biggestVal;

		switch(biggestIndex)
		{
		case 0:
			return qua<T, Q>::wxyz(biggestVal, (m[1][2] - m[2][1]) * mult, (m[2][0] - m[0][2]) * mult, (m[0][1] - m[1][0]) * mult);
		case 1:
			return qua<T, Q>::wxyz((m[1][2] - m[2][1]) * mult, biggestVal, (m[0][1] + m[1][0]) * mult, (m[2][0] + m[0][2]) * mult);
		case 2:
			return qua<T, Q>::wxyz((m[2][0] - m[0][2]) * mult, (m[0][1] + m[1][0]) * mult, biggestVal, (m[1][2] + m[2][1]) * mult);
		case 3:
			return qua<T, Q>::wxyz((m[0][1] - m[1][0]) * mult, (m[2][0] + m[0][2]) * mult, (m[1][2] + m[2][1]) * mult, biggestVal);
		default: 
			(void)( (!!(false)) || (_wassert(L"false", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\quaternion.inl", (unsigned)(120)), 0) ) ;
			return qua<T, Q>::wxyz(1, 0, 0, 0);
		}
	}

	template<typename T, qualifier Q>
	inline qua<T, Q> quat_cast(mat<4, 4, T, Q> const& m4)
	{
		return quat_cast(mat<3, 3, T, Q>(m4));
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, bool, Q> lessThan(qua<T, Q> const& x, qua<T, Q> const& y)
	{
		vec<4, bool, Q> Result(false, false, false, false);
		for(length_t i = 0; i < x.length(); ++i)
			Result[i] = x[i] < y[i];
		return Result;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, bool, Q> lessThanEqual(qua<T, Q> const& x, qua<T, Q> const& y)
	{
		vec<4, bool, Q> Result(false, false, false, false);
		for(length_t i = 0; i < x.length(); ++i)
			Result[i] = x[i] <= y[i];
		return Result;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, bool, Q> greaterThan(qua<T, Q> const& x, qua<T, Q> const& y)
	{
		vec<4, bool, Q> Result(false, false, false, false);
		for(length_t i = 0; i < x.length(); ++i)
			Result[i] = x[i] > y[i];
		return Result;
	}

	template<typename T, qualifier Q>
	inline constexpr vec<4, bool, Q> greaterThanEqual(qua<T, Q> const& x, qua<T, Q> const& y)
	{
		vec<4, bool, Q> Result(false, false, false, false);
		for(length_t i = 0; i < x.length(); ++i)
			Result[i] = x[i] >= y[i];
		return Result;
	}


	template<typename T, qualifier Q>
	inline qua<T, Q> quatLookAt(vec<3, T, Q> const& direction, vec<3, T, Q> const& up)
	{


#line 174 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\quaternion.inl"
			return quatLookAtRH(direction, up);
#line 176 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\quaternion.inl"
	}

	template<typename T, qualifier Q>
	inline qua<T, Q> quatLookAtRH(vec<3, T, Q> const& direction, vec<3, T, Q> const& up)
	{
		mat<3, 3, T, Q> Result;

		Result[2] = -direction;
		vec<3, T, Q> const& Right = cross(up, Result[2]);
		Result[0] = Right * inversesqrt(max(static_cast<T>(0.00001), dot(Right, Right)));
		Result[1] = cross(Result[2], Result[0]);

		return quat_cast(Result);
	}

	template<typename T, qualifier Q>
	inline qua<T, Q> quatLookAtLH(vec<3, T, Q> const& direction, vec<3, T, Q> const& up)
	{
		mat<3, 3, T, Q> Result;

		Result[2] = direction;
		vec<3, T, Q> const& Right = cross(up, Result[2]);
		Result[0] = Right * inversesqrt(max(static_cast<T>(0.00001), dot(Right, Right)));
		Result[1] = cross(Result[2], Result[0]);

		return quat_cast(Result);
	}
}



#line 208 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\quaternion.inl"

#line 174 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\quaternion.hpp"
#line 18 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\type_precision.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\vec1.hpp"












#pragma once















#line 30 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\vec1.hpp"

#line 19 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\type_precision.hpp"

























#line 45 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\type_precision.hpp"

namespace glm
{
	
	

	
	

	
	
	typedef detail::int8 lowp_int8;

	
	
	typedef detail::int16 lowp_int16;

	
	
	typedef detail::int32 lowp_int32;

	
	
	typedef detail::int64 lowp_int64;

	
	
	typedef detail::int8 lowp_int8_t;

	
	
	typedef detail::int16 lowp_int16_t;

	
	
	typedef detail::int32 lowp_int32_t;

	
	
	typedef detail::int64 lowp_int64_t;

	
	
	typedef detail::int8 lowp_i8;

	
	
	typedef detail::int16 lowp_i16;

	
	
	typedef detail::int32 lowp_i32;

	
	
	typedef detail::int64 lowp_i64;

	
	
	typedef detail::int8 mediump_int8;

	
	
	typedef detail::int16 mediump_int16;

	
	
	typedef detail::int32 mediump_int32;

	
	
	typedef detail::int64 mediump_int64;

	
	
	typedef detail::int8 mediump_int8_t;

	
	
	typedef detail::int16 mediump_int16_t;

	
	
	typedef detail::int32 mediump_int32_t;

	
	
	typedef detail::int64 mediump_int64_t;

	
	
	typedef detail::int8 mediump_i8;

	
	
	typedef detail::int16 mediump_i16;

	
	
	typedef detail::int32 mediump_i32;

	
	
	typedef detail::int64 mediump_i64;

	
	
	typedef detail::int8 highp_int8;

	
	
	typedef detail::int16 highp_int16;

	
	
	typedef detail::int32 highp_int32;

	
	
	typedef detail::int64 highp_int64;

	
	
	typedef detail::int8 highp_int8_t;

	
	
	typedef detail::int16 highp_int16_t;

	
	
	typedef detail::int32 highp_int32_t;

	
	
	typedef detail::int64 highp_int64_t;

	
	
	typedef detail::int8 highp_i8;

	
	
	typedef detail::int16 highp_i16;

	
	
	typedef detail::int32 highp_i32;

	
	
	typedef detail::int64 highp_i64;



	using std::int8_t;
	using std::int16_t;
	using std::int32_t;
	using std::int64_t;
















#line 221 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\type_precision.hpp"

	
	
	typedef detail::int8 i8;

	
	
	typedef detail::int16 i16;

	
	
	typedef detail::int32 i32;

	
	
	typedef detail::int64 i64;

	
	

	
	
	typedef detail::uint8 lowp_uint8;

	
	
	typedef detail::uint16 lowp_uint16;

	
	
	typedef detail::uint32 lowp_uint32;

	
	
	typedef detail::uint64 lowp_uint64;

	
	
	typedef detail::uint8 lowp_uint8_t;

	
	
	typedef detail::uint16 lowp_uint16_t;

	
	
	typedef detail::uint32 lowp_uint32_t;

	
	
	typedef detail::uint64 lowp_uint64_t;

	
	
	typedef detail::uint8 lowp_u8;

	
	
	typedef detail::uint16 lowp_u16;

	
	
	typedef detail::uint32 lowp_u32;

	
	
	typedef detail::uint64 lowp_u64;

	
	
	typedef detail::uint8 mediump_uint8;

	
	
	typedef detail::uint16 mediump_uint16;

	
	
	typedef detail::uint32 mediump_uint32;

	
	
	typedef detail::uint64 mediump_uint64;

	
	
	typedef detail::uint8 mediump_uint8_t;

	
	
	typedef detail::uint16 mediump_uint16_t;

	
	
	typedef detail::uint32 mediump_uint32_t;

	
	
	typedef detail::uint64 mediump_uint64_t;

	
	
	typedef detail::uint8 mediump_u8;

	
	
	typedef detail::uint16 mediump_u16;

	
	
	typedef detail::uint32 mediump_u32;

	
	
	typedef detail::uint64 mediump_u64;

	
	
	typedef detail::uint8 highp_uint8;

	
	
	typedef detail::uint16 highp_uint16;

	
	
	typedef detail::uint32 highp_uint32;

	
	
	typedef detail::uint64 highp_uint64;

	
	
	typedef detail::uint8 highp_uint8_t;

	
	
	typedef detail::uint16 highp_uint16_t;

	
	
	typedef detail::uint32 highp_uint32_t;

	
	
	typedef detail::uint64 highp_uint64_t;

	
	
	typedef detail::uint8 highp_u8;

	
	
	typedef detail::uint16 highp_u16;

	
	
	typedef detail::uint32 highp_u32;

	
	
	typedef detail::uint64 highp_u64;


	using std::uint8_t;
	using std::uint16_t;
	using std::uint32_t;
	using std::uint64_t;
















#line 407 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\type_precision.hpp"

	
	
	typedef detail::uint8 u8;

	
	
	typedef detail::uint16 u16;

	
	
	typedef detail::uint32 u32;

	
	
	typedef detail::uint64 u64;





	
	

	
	
	typedef float float32;

	
	
	typedef double float64;

	
	
	typedef float32 lowp_float32;

	
	
	typedef float64 lowp_float64;

	
	
	typedef float32 lowp_float32_t;

	
	
	typedef float64 lowp_float64_t;

	
	
	typedef float32 lowp_f32;

	
	
	typedef float64 lowp_f64;

	
	
	typedef float32 lowp_float32;

	
	
	typedef float64 lowp_float64;

	
	
	typedef float32 lowp_float32_t;

	
	
	typedef float64 lowp_float64_t;

	
	
	typedef float32 lowp_f32;

	
	
	typedef float64 lowp_f64;


	
	
	typedef float32 lowp_float32;

	
	
	typedef float64 lowp_float64;

	
	
	typedef float32 lowp_float32_t;

	
	
	typedef float64 lowp_float64_t;

	
	
	typedef float32 lowp_f32;

	
	
	typedef float64 lowp_f64;


	
	
	typedef float32 mediump_float32;

	
	
	typedef float64 mediump_float64;

	
	
	typedef float32 mediump_float32_t;

	
	
	typedef float64 mediump_float64_t;

	
	
	typedef float32 mediump_f32;

	
	
	typedef float64 mediump_f64;


	
	
	typedef float32 highp_float32;

	
	
	typedef float64 highp_float64;

	
	
	typedef float32 highp_float32_t;

	
	
	typedef float64 highp_float64_t;

	
	
	typedef float32 highp_f32;

	
	
	typedef float64 highp_f64;



















#line 581 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\type_precision.hpp"
















#line 598 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\type_precision.hpp"

	
	
	typedef highp_float32_t float32_t;

	
	
	typedef highp_float64_t float64_t;

	
	
	typedef highp_float32_t f32;

	
	
	typedef highp_float64_t f64;
#line 615 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\type_precision.hpp"


	
	
	typedef vec<1, float, lowp> lowp_fvec1;

	
	
	typedef vec<2, float, lowp> lowp_fvec2;

	
	
	typedef vec<3, float, lowp> lowp_fvec3;

	
	
	typedef vec<4, float, lowp> lowp_fvec4;


	
	
	typedef vec<1, float, mediump> mediump_fvec1;

	
	
	typedef vec<2, float, mediump> mediump_fvec2;

	
	
	typedef vec<3, float, mediump> mediump_fvec3;

	
	
	typedef vec<4, float, mediump> mediump_fvec4;


	
	
	typedef vec<1, float, highp> highp_fvec1;

	
	
	typedef vec<2, float, highp> highp_fvec2;

	
	
	typedef vec<3, float, highp> highp_fvec3;

	
	
	typedef vec<4, float, highp> highp_fvec4;


	
	
	typedef vec<1, f32, lowp> lowp_f32vec1;

	
	
	typedef vec<2, f32, lowp> lowp_f32vec2;

	
	
	typedef vec<3, f32, lowp> lowp_f32vec3;

	
	
	typedef vec<4, f32, lowp> lowp_f32vec4;

	
	
	typedef vec<1, f32, mediump> mediump_f32vec1;

	
	
	typedef vec<2, f32, mediump> mediump_f32vec2;

	
	
	typedef vec<3, f32, mediump> mediump_f32vec3;

	
	
	typedef vec<4, f32, mediump> mediump_f32vec4;

	
	
	typedef vec<1, f32, highp> highp_f32vec1;

	
	
	typedef vec<2, f32, highp> highp_f32vec2;

	
	
	typedef vec<3, f32, highp> highp_f32vec3;

	
	
	typedef vec<4, f32, highp> highp_f32vec4;


	
	
	typedef vec<1, f64, lowp> lowp_f64vec1;

	
	
	typedef vec<2, f64, lowp> lowp_f64vec2;

	
	
	typedef vec<3, f64, lowp> lowp_f64vec3;

	
	
	typedef vec<4, f64, lowp> lowp_f64vec4;

	
	
	typedef vec<1, f64, mediump> mediump_f64vec1;

	
	
	typedef vec<2, f64, mediump> mediump_f64vec2;

	
	
	typedef vec<3, f64, mediump> mediump_f64vec3;

	
	
	typedef vec<4, f64, mediump> mediump_f64vec4;

	
	
	typedef vec<1, f64, highp> highp_f64vec1;

	
	
	typedef vec<2, f64, highp> highp_f64vec2;

	
	
	typedef vec<3, f64, highp> highp_f64vec3;

	
	
	typedef vec<4, f64, highp> highp_f64vec4;



	
	

	
	
	

	
	
	typedef mat<2, 2, f32, lowp> lowp_fmat2x2;

	
	
	typedef mat<2, 3, f32, lowp> lowp_fmat2x3;

	
	
	typedef mat<2, 4, f32, lowp> lowp_fmat2x4;

	
	
	typedef mat<3, 2, f32, lowp> lowp_fmat3x2;

	
	
	typedef mat<3, 3, f32, lowp> lowp_fmat3x3;

	
	
	typedef mat<3, 4, f32, lowp> lowp_fmat3x4;

	
	
	typedef mat<4, 2, f32, lowp> lowp_fmat4x2;

	
	
	typedef mat<4, 3, f32, lowp> lowp_fmat4x3;

	
	
	typedef mat<4, 4, f32, lowp> lowp_fmat4x4;

	
	
	

	
	
	typedef lowp_fmat2x2 lowp_fmat2;

	
	
	typedef lowp_fmat3x3 lowp_fmat3;

	
	
	typedef lowp_fmat4x4 lowp_fmat4;


	
	
	

	
	
	typedef mat<2, 2, f32, mediump> mediump_fmat2x2;

	
	
	typedef mat<2, 3, f32, mediump> mediump_fmat2x3;

	
	
	typedef mat<2, 4, f32, mediump> mediump_fmat2x4;

	
	
	typedef mat<3, 2, f32, mediump> mediump_fmat3x2;

	
	
	typedef mat<3, 3, f32, mediump> mediump_fmat3x3;

	
	
	typedef mat<3, 4, f32, mediump> mediump_fmat3x4;

	
	
	typedef mat<4, 2, f32, mediump> mediump_fmat4x2;

	
	
	typedef mat<4, 3, f32, mediump> mediump_fmat4x3;

	
	
	typedef mat<4, 4, f32, mediump> mediump_fmat4x4;

	
	
	

	
	
	typedef mediump_fmat2x2 mediump_fmat2;

	
	
	typedef mediump_fmat3x3 mediump_fmat3;

	
	
	typedef mediump_fmat4x4 mediump_fmat4;


	
	
	

	
	
	typedef mat<2, 2, f32, highp> highp_fmat2x2;

	
	
	typedef mat<2, 3, f32, highp> highp_fmat2x3;

	
	
	typedef mat<2, 4, f32, highp> highp_fmat2x4;

	
	
	typedef mat<3, 2, f32, highp> highp_fmat3x2;

	
	
	typedef mat<3, 3, f32, highp> highp_fmat3x3;

	
	
	typedef mat<3, 4, f32, highp> highp_fmat3x4;

	
	
	typedef mat<4, 2, f32, highp> highp_fmat4x2;

	
	
	typedef mat<4, 3, f32, highp> highp_fmat4x3;

	
	
	typedef mat<4, 4, f32, highp> highp_fmat4x4;

	
	
	

	
	
	typedef highp_fmat2x2 highp_fmat2;

	
	
	typedef highp_fmat3x3 highp_fmat3;

	
	
	typedef highp_fmat4x4 highp_fmat4;


	
	
	

	
	
	typedef mat<2, 2, f32, lowp> lowp_f32mat2x2;

	
	
	typedef mat<2, 3, f32, lowp> lowp_f32mat2x3;

	
	
	typedef mat<2, 4, f32, lowp> lowp_f32mat2x4;

	
	
	typedef mat<3, 2, f32, lowp> lowp_f32mat3x2;

	
	
	typedef mat<3, 3, f32, lowp> lowp_f32mat3x3;

	
	
	typedef mat<3, 4, f32, lowp> lowp_f32mat3x4;

	
	
	typedef mat<4, 2, f32, lowp> lowp_f32mat4x2;

	
	
	typedef mat<4, 3, f32, lowp> lowp_f32mat4x3;

	
	
	typedef mat<4, 4, f32, lowp> lowp_f32mat4x4;

	
	
	

	
	
	typedef lowp_f32mat2x2 lowp_f32mat2;

	
	
	typedef lowp_f32mat3x3 lowp_f32mat3;

	
	
	typedef lowp_f32mat4x4 lowp_f32mat4;


	
	
	

	
	
	typedef mat<2, 2, f32, mediump> mediump_f32mat2x2;

	
	
	typedef mat<2, 3, f32, mediump> mediump_f32mat2x3;

	
	
	typedef mat<2, 4, f32, mediump> mediump_f32mat2x4;

	
	
	typedef mat<3, 2, f32, mediump> mediump_f32mat3x2;

	
	
	typedef mat<3, 3, f32, mediump> mediump_f32mat3x3;

	
	
	typedef mat<3, 4, f32, mediump> mediump_f32mat3x4;

	
	
	typedef mat<4, 2, f32, mediump> mediump_f32mat4x2;

	
	
	typedef mat<4, 3, f32, mediump> mediump_f32mat4x3;

	
	
	typedef mat<4, 4, f32, mediump> mediump_f32mat4x4;

	
	
	

	
	
	typedef mediump_f32mat2x2 mediump_f32mat2;

	
	
	typedef mediump_f32mat3x3 mediump_f32mat3;

	
	
	typedef mediump_f32mat4x4 mediump_f32mat4;


	
	
	

	
	
	typedef mat<2, 2, f32, highp> highp_f32mat2x2;

	
	
	typedef mat<2, 3, f32, highp> highp_f32mat2x3;

	
	
	typedef mat<2, 4, f32, highp> highp_f32mat2x4;

	
	
	typedef mat<3, 2, f32, highp> highp_f32mat3x2;

	
	
	typedef mat<3, 3, f32, highp> highp_f32mat3x3;

	
	
	typedef mat<3, 4, f32, highp> highp_f32mat3x4;

	
	
	typedef mat<4, 2, f32, highp> highp_f32mat4x2;

	
	
	typedef mat<4, 3, f32, highp> highp_f32mat4x3;

	
	
	typedef mat<4, 4, f32, highp> highp_f32mat4x4;

	
	
	

	
	
	typedef highp_f32mat2x2 highp_f32mat2;

	
	
	typedef highp_f32mat3x3 highp_f32mat3;

	
	
	typedef highp_f32mat4x4 highp_f32mat4;


	
	
	

	
	
	typedef mat<2, 2, f64, lowp> lowp_f64mat2x2;

	
	
	typedef mat<2, 3, f64, lowp> lowp_f64mat2x3;

	
	
	typedef mat<2, 4, f64, lowp> lowp_f64mat2x4;

	
	
	typedef mat<3, 2, f64, lowp> lowp_f64mat3x2;

	
	
	typedef mat<3, 3, f64, lowp> lowp_f64mat3x3;

	
	
	typedef mat<3, 4, f64, lowp> lowp_f64mat3x4;

	
	
	typedef mat<4, 2, f64, lowp> lowp_f64mat4x2;

	
	
	typedef mat<4, 3, f64, lowp> lowp_f64mat4x3;

	
	
	typedef mat<4, 4, f64, lowp> lowp_f64mat4x4;

	
	
	

	
	
	typedef lowp_f64mat2x2 lowp_f64mat2;

	
	
	typedef lowp_f64mat3x3 lowp_f64mat3;

	
	
	typedef lowp_f64mat4x4 lowp_f64mat4;


	
	
	

	
	
	typedef mat<2, 2, f64, mediump> mediump_f64mat2x2;

	
	
	typedef mat<2, 3, f64, mediump> mediump_f64mat2x3;

	
	
	typedef mat<2, 4, f64, mediump> mediump_f64mat2x4;

	
	
	typedef mat<3, 2, f64, mediump> mediump_f64mat3x2;

	
	
	typedef mat<3, 3, f64, mediump> mediump_f64mat3x3;

	
	
	typedef mat<3, 4, f64, mediump> mediump_f64mat3x4;

	
	
	typedef mat<4, 2, f64, mediump> mediump_f64mat4x2;

	
	
	typedef mat<4, 3, f64, mediump> mediump_f64mat4x3;

	
	
	typedef mat<4, 4, f64, mediump> mediump_f64mat4x4;

	
	
	

	
	
	typedef mediump_f64mat2x2 mediump_f64mat2;

	
	
	typedef mediump_f64mat3x3 mediump_f64mat3;

	
	
	typedef mediump_f64mat4x4 mediump_f64mat4;

	
	
	

	
	
	typedef mat<2, 2, f64, highp> highp_f64mat2x2;

	
	
	typedef mat<2, 3, f64, highp> highp_f64mat2x3;

	
	
	typedef mat<2, 4, f64, highp> highp_f64mat2x4;

	
	
	typedef mat<3, 2, f64, highp> highp_f64mat3x2;

	
	
	typedef mat<3, 3, f64, highp> highp_f64mat3x3;

	
	
	typedef mat<3, 4, f64, highp> highp_f64mat3x4;

	
	
	typedef mat<4, 2, f64, highp> highp_f64mat4x2;

	
	
	typedef mat<4, 3, f64, highp> highp_f64mat4x3;

	
	
	typedef mat<4, 4, f64, highp> highp_f64mat4x4;

	
	
	

	
	
	typedef highp_f64mat2x2 highp_f64mat2;

	
	
	typedef highp_f64mat3x3 highp_f64mat3;

	
	
	typedef highp_f64mat4x4 highp_f64mat4;


	
	

	
	
	typedef vec<1, int, lowp>		lowp_ivec1;

	
	
	typedef vec<2, int, lowp>		lowp_ivec2;

	
	
	typedef vec<3, int, lowp>		lowp_ivec3;

	
	
	typedef vec<4, int, lowp>		lowp_ivec4;


	
	
	typedef vec<1, int, mediump>	mediump_ivec1;

	
	
	typedef vec<2, int, mediump>	mediump_ivec2;

	
	
	typedef vec<3, int, mediump>	mediump_ivec3;

	
	
	typedef vec<4, int, mediump>	mediump_ivec4;


	
	
	typedef vec<1, int, highp>		highp_ivec1;

	
	
	typedef vec<2, int, highp>		highp_ivec2;

	
	
	typedef vec<3, int, highp>		highp_ivec3;

	
	
	typedef vec<4, int, highp>		highp_ivec4;


	
	
	typedef vec<1, i8, lowp>		lowp_i8vec1;

	
	
	typedef vec<2, i8, lowp>		lowp_i8vec2;

	
	
	typedef vec<3, i8, lowp>		lowp_i8vec3;

	
	
	typedef vec<4, i8, lowp>		lowp_i8vec4;


	
	
	typedef vec<1, i8, mediump>		mediump_i8vec1;

	
	
	typedef vec<2, i8, mediump>		mediump_i8vec2;

	
	
	typedef vec<3, i8, mediump>		mediump_i8vec3;

	
	
	typedef vec<4, i8, mediump>		mediump_i8vec4;


	
	
	typedef vec<1, i8, highp>		highp_i8vec1;

	
	
	typedef vec<2, i8, highp>		highp_i8vec2;

	
	
	typedef vec<3, i8, highp>		highp_i8vec3;

	
	
	typedef vec<4, i8, highp>		highp_i8vec4;


	
	
	typedef vec<1, i16, lowp>		lowp_i16vec1;

	
	
	typedef vec<2, i16, lowp>		lowp_i16vec2;

	
	
	typedef vec<3, i16, lowp>		lowp_i16vec3;

	
	
	typedef vec<4, i16, lowp>		lowp_i16vec4;


	
	
	typedef vec<1, i16, mediump>	mediump_i16vec1;

	
	
	typedef vec<2, i16, mediump>	mediump_i16vec2;

	
	
	typedef vec<3, i16, mediump>	mediump_i16vec3;

	
	
	typedef vec<4, i16, mediump>	mediump_i16vec4;


	
	
	typedef vec<1, i16, highp>		highp_i16vec1;

	
	
	typedef vec<2, i16, highp>		highp_i16vec2;

	
	
	typedef vec<3, i16, highp>		highp_i16vec3;

	
	
	typedef vec<4, i16, highp>		highp_i16vec4;


	
	
	typedef vec<1, i32, lowp>		lowp_i32vec1;

	
	
	typedef vec<2, i32, lowp>		lowp_i32vec2;

	
	
	typedef vec<3, i32, lowp>		lowp_i32vec3;

	
	
	typedef vec<4, i32, lowp>		lowp_i32vec4;


	
	
	typedef vec<1, i32, mediump>	mediump_i32vec1;

	
	
	typedef vec<2, i32, mediump>	mediump_i32vec2;

	
	
	typedef vec<3, i32, mediump>	mediump_i32vec3;

	
	
	typedef vec<4, i32, mediump>	mediump_i32vec4;


	
	
	typedef vec<1, i32, highp>		highp_i32vec1;

	
	
	typedef vec<2, i32, highp>		highp_i32vec2;

	
	
	typedef vec<3, i32, highp>		highp_i32vec3;

	
	
	typedef vec<4, i32, highp>		highp_i32vec4;


	
	
	typedef vec<1, i64, lowp>		lowp_i64vec1;

	
	
	typedef vec<2, i64, lowp>		lowp_i64vec2;

	
	
	typedef vec<3, i64, lowp>		lowp_i64vec3;

	
	
	typedef vec<4, i64, lowp>		lowp_i64vec4;


	
	
	typedef vec<1, i64, mediump>	mediump_i64vec1;

	
	
	typedef vec<2, i64, mediump>	mediump_i64vec2;

	
	
	typedef vec<3, i64, mediump>	mediump_i64vec3;

	
	
	typedef vec<4, i64, mediump>	mediump_i64vec4;


	
	
	typedef vec<1, i64, highp>		highp_i64vec1;

	
	
	typedef vec<2, i64, highp>		highp_i64vec2;

	
	
	typedef vec<3, i64, highp>		highp_i64vec3;

	
	
	typedef vec<4, i64, highp>		highp_i64vec4;


	
	

	
	
	typedef vec<1, uint, lowp>		lowp_uvec1;

	
	
	typedef vec<2, uint, lowp>		lowp_uvec2;

	
	
	typedef vec<3, uint, lowp>		lowp_uvec3;

	
	
	typedef vec<4, uint, lowp>		lowp_uvec4;


	
	
	typedef vec<1, uint, mediump>	mediump_uvec1;

	
	
	typedef vec<2, uint, mediump>	mediump_uvec2;

	
	
	typedef vec<3, uint, mediump>	mediump_uvec3;

	
	
	typedef vec<4, uint, mediump>	mediump_uvec4;


	
	
	typedef vec<1, uint, highp>		highp_uvec1;

	
	
	typedef vec<2, uint, highp>		highp_uvec2;

	
	
	typedef vec<3, uint, highp>		highp_uvec3;

	
	
	typedef vec<4, uint, highp>		highp_uvec4;


	
	
	typedef vec<1, u8, lowp>		lowp_u8vec1;

	
	
	typedef vec<2, u8, lowp>		lowp_u8vec2;

	
	
	typedef vec<3, u8, lowp>		lowp_u8vec3;

	
	
	typedef vec<4, u8, lowp>		lowp_u8vec4;


	
	
	typedef vec<1, u8, mediump>		mediump_u8vec1;

	
	
	typedef vec<2, u8, mediump>		mediump_u8vec2;

	
	
	typedef vec<3, u8, mediump>		mediump_u8vec3;

	
	
	typedef vec<4, u8, mediump>		mediump_u8vec4;


	
	
	typedef vec<1, u8, highp>		highp_u8vec1;

	
	
	typedef vec<2, u8, highp>		highp_u8vec2;

	
	
	typedef vec<3, u8, highp>		highp_u8vec3;

	
	
	typedef vec<4, u8, highp>		highp_u8vec4;


	
	
	typedef vec<1, u16, lowp>		lowp_u16vec1;

	
	
	typedef vec<2, u16, lowp>		lowp_u16vec2;

	
	
	typedef vec<3, u16, lowp>		lowp_u16vec3;

	
	
	typedef vec<4, u16, lowp>		lowp_u16vec4;


	
	
	typedef vec<1, u16, mediump>	mediump_u16vec1;

	
	
	typedef vec<2, u16, mediump>	mediump_u16vec2;

	
	
	typedef vec<3, u16, mediump>	mediump_u16vec3;

	
	
	typedef vec<4, u16, mediump>	mediump_u16vec4;


	
	
	typedef vec<1, u16, highp>		highp_u16vec1;

	
	
	typedef vec<2, u16, highp>		highp_u16vec2;

	
	
	typedef vec<3, u16, highp>		highp_u16vec3;

	
	
	typedef vec<4, u16, highp>		highp_u16vec4;


	
	
	typedef vec<1, u32, lowp>		lowp_u32vec1;

	
	
	typedef vec<2, u32, lowp>		lowp_u32vec2;

	
	
	typedef vec<3, u32, lowp>		lowp_u32vec3;

	
	
	typedef vec<4, u32, lowp>		lowp_u32vec4;


	
	
	typedef vec<1, u32, mediump>	mediump_u32vec1;

	
	
	typedef vec<2, u32, mediump>	mediump_u32vec2;

	
	
	typedef vec<3, u32, mediump>	mediump_u32vec3;

	
	
	typedef vec<4, u32, mediump>	mediump_u32vec4;


	
	
	typedef vec<1, u32, highp>		highp_u32vec1;

	
	
	typedef vec<2, u32, highp>		highp_u32vec2;

	
	
	typedef vec<3, u32, highp>		highp_u32vec3;

	
	
	typedef vec<4, u32, highp>		highp_u32vec4;


	
	
	typedef vec<1, u64, lowp>		lowp_u64vec1;

	
	
	typedef vec<2, u64, lowp>		lowp_u64vec2;

	
	
	typedef vec<3, u64, lowp>		lowp_u64vec3;

	
	
	typedef vec<4, u64, lowp>		lowp_u64vec4;


	
	
	typedef vec<1, u64, mediump>	mediump_u64vec1;

	
	
	typedef vec<2, u64, mediump>	mediump_u64vec2;

	
	
	typedef vec<3, u64, mediump>	mediump_u64vec3;

	
	
	typedef vec<4, u64, mediump>	mediump_u64vec4;


	
	
	typedef vec<1, u64, highp>		highp_u64vec1;

	
	
	typedef vec<2, u64, highp>		highp_u64vec2;

	
	
	typedef vec<3, u64, highp>		highp_u64vec3;

	
	
	typedef vec<4, u64, highp>		highp_u64vec4;


	
	

	
	
	typedef float32 float32_t;

	
	
	typedef float32 f32;



		
		
		typedef float64 float64_t;

		
		
		typedef float64 f64;
#line 1819 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\type_precision.hpp"

	
	
	typedef vec<1, float, defaultp> fvec1;

	
	
	typedef vec<2, float, defaultp> fvec2;

	
	
	typedef vec<3, float, defaultp> fvec3;

	
	
	typedef vec<4, float, defaultp> fvec4;


	
	
	typedef vec<1, f32, defaultp> f32vec1;

	
	
	typedef vec<2, f32, defaultp> f32vec2;

	
	
	typedef vec<3, f32, defaultp> f32vec3;

	
	
	typedef vec<4, f32, defaultp> f32vec4;


		
		
		typedef vec<1, f64, defaultp> f64vec1;

		
		
		typedef vec<2, f64, defaultp> f64vec2;

		
		
		typedef vec<3, f64, defaultp> f64vec3;

		
		
		typedef vec<4, f64, defaultp> f64vec4;
#line 1870 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\type_precision.hpp"


	
	

	
	
	

	
	
	typedef mat<2, 2, f32, defaultp> fmat2;

	
	
	typedef mat<3, 3, f32, defaultp> fmat3;

	
	
	typedef mat<4, 4, f32, defaultp> fmat4;


	
	
	

	
	
	typedef mat<2, 2, f32, defaultp> fmat2x2;

	
	
	typedef mat<2, 3, f32, defaultp> fmat2x3;

	
	
	typedef mat<2, 4, f32, defaultp> fmat2x4;

	
	
	typedef mat<3, 2, f32, defaultp> fmat3x2;

	
	
	typedef mat<3, 3, f32, defaultp> fmat3x3;

	
	
	typedef mat<3, 4, f32, defaultp> fmat3x4;

	
	
	typedef mat<4, 2, f32, defaultp> fmat4x2;

	
	
	typedef mat<4, 3, f32, defaultp> fmat4x3;

	
	
	typedef mat<4, 4, f32, defaultp> fmat4x4;


	
	
	

	
	
	typedef mat<2, 2, f32, defaultp> f32mat2;

	
	
	typedef mat<3, 3, f32, defaultp> f32mat3;

	
	
	typedef mat<4, 4, f32, defaultp> f32mat4;


	
	
	

	
	
	typedef mat<2, 2, f32, defaultp> f32mat2x2;

	
	
	typedef mat<2, 3, f32, defaultp> f32mat2x3;

	
	
	typedef mat<2, 4, f32, defaultp> f32mat2x4;

	
	
	typedef mat<3, 2, f32, defaultp> f32mat3x2;

	
	
	typedef mat<3, 3, f32, defaultp> f32mat3x3;

	
	
	typedef mat<3, 4, f32, defaultp> f32mat3x4;

	
	
	typedef mat<4, 2, f32, defaultp> f32mat4x2;

	
	
	typedef mat<4, 3, f32, defaultp> f32mat4x3;

	
	
	typedef mat<4, 4, f32, defaultp> f32mat4x4;




	
	
	

	
	
	typedef mat<2, 2, f64, defaultp> f64mat2;

	
	
	typedef mat<3, 3, f64, defaultp> f64mat3;

	
	
	typedef mat<4, 4, f64, defaultp> f64mat4;


	
	
	

	
	
	typedef mat<2, 2, f64, defaultp> f64mat2x2;

	
	
	typedef mat<2, 3, f64, defaultp> f64mat2x3;

	
	
	typedef mat<2, 4, f64, defaultp> f64mat2x4;

	
	
	typedef mat<3, 2, f64, defaultp> f64mat3x2;

	
	
	typedef mat<3, 3, f64, defaultp> f64mat3x3;

	
	
	typedef mat<3, 4, f64, defaultp> f64mat3x4;

	
	
	typedef mat<4, 2, f64, defaultp> f64mat4x2;

	
	
	typedef mat<4, 3, f64, defaultp> f64mat4x3;

	
	
	typedef mat<4, 4, f64, defaultp> f64mat4x4;

#line 2051 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\type_precision.hpp"

	
	

	
	
	typedef qua<f32, defaultp> f32quat;

	
	
	typedef qua<f32, lowp> lowp_f32quat;

	
	
	typedef qua<f64, lowp> lowp_f64quat;

	
	
	typedef qua<f32, mediump> mediump_f32quat;



	
	
	typedef qua<f64, mediump> mediump_f64quat;

	
	
	typedef qua<f32, highp> highp_f32quat;

	
	
	typedef qua<f64, highp> highp_f64quat;

	
	
	typedef qua<f64, defaultp> f64quat;

#line 2090 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\type_precision.hpp"

	
}

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\type_precision.inl"


namespace glm
{

}
#line 2095 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\type_precision.hpp"
#line 24 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\bitfield.hpp"




#line 29 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\bitfield.hpp"

namespace glm
{
	
	

	
	
	
	template<typename genIUType>
	[[nodiscard]] genIUType mask(genIUType Bits);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> mask(vec<L, T, Q> const& v);

	
	
	
	template<typename genIUType>
	[[nodiscard]] genIUType bitfieldRotateRight(genIUType In, int Shift);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> bitfieldRotateRight(vec<L, T, Q> const& In, int Shift);

	
	
	
	template<typename genIUType>
	[[nodiscard]] genIUType bitfieldRotateLeft(genIUType In, int Shift);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> bitfieldRotateLeft(vec<L, T, Q> const& In, int Shift);

	
	
	
	template<typename genIUType>
	[[nodiscard]] genIUType bitfieldFillOne(genIUType Value, int FirstBit, int BitCount);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> bitfieldFillOne(vec<L, T, Q> const& Value, int FirstBit, int BitCount);

	
	
	
	template<typename genIUType>
	[[nodiscard]] genIUType bitfieldFillZero(genIUType Value, int FirstBit, int BitCount);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> bitfieldFillZero(vec<L, T, Q> const& Value, int FirstBit, int BitCount);

	
	
	
	
	
	[[nodiscard]] int16 bitfieldInterleave(int8 x, int8 y);

	
	
	
	
	
	[[nodiscard]] uint16 bitfieldInterleave(uint8 x, uint8 y);

	
	
	
	
	
	[[nodiscard]] uint16 bitfieldInterleave(u8vec2 const& v);

	
	
	
	[[nodiscard]] glm::u8vec2 bitfieldDeinterleave(glm::uint16 x);

	
	
	
	
	
	[[nodiscard]] int32 bitfieldInterleave(int16 x, int16 y);

	
	
	
	
	
	[[nodiscard]] uint32 bitfieldInterleave(uint16 x, uint16 y);

	
	
	
	
	
	[[nodiscard]] uint32 bitfieldInterleave(u16vec2 const& v);

	
	
	
	[[nodiscard]] glm::u16vec2 bitfieldDeinterleave(glm::uint32 x);

	
	
	
	
	
	[[nodiscard]] int64 bitfieldInterleave(int32 x, int32 y);

	
	
	
	
	
	[[nodiscard]] uint64 bitfieldInterleave(uint32 x, uint32 y);

	
	
	
	
	
	[[nodiscard]] uint64 bitfieldInterleave(u32vec2 const& v);

	
	
	
	[[nodiscard]] glm::u32vec2 bitfieldDeinterleave(glm::uint64 x);

	
	
	
	
	
	[[nodiscard]] int32 bitfieldInterleave(int8 x, int8 y, int8 z);

	
	
	
	
	
	[[nodiscard]] uint32 bitfieldInterleave(uint8 x, uint8 y, uint8 z);

	
	
	
	
	
	[[nodiscard]] int64 bitfieldInterleave(int16 x, int16 y, int16 z);

	
	
	
	
	
	[[nodiscard]] uint64 bitfieldInterleave(uint16 x, uint16 y, uint16 z);

	
	
	
	
	
	[[nodiscard]] int64 bitfieldInterleave(int32 x, int32 y, int32 z);

	
	
	
	
	
	[[nodiscard]] uint64 bitfieldInterleave(uint32 x, uint32 y, uint32 z);

	
	
	
	
	
	[[nodiscard]] int32 bitfieldInterleave(int8 x, int8 y, int8 z, int8 w);

	
	
	
	
	
	[[nodiscard]] uint32 bitfieldInterleave(uint8 x, uint8 y, uint8 z, uint8 w);

	
	
	
	
	
	[[nodiscard]] int64 bitfieldInterleave(int16 x, int16 y, int16 z, int16 w);

	
	
	
	
	
	[[nodiscard]] uint64 bitfieldInterleave(uint16 x, uint16 y, uint16 z, uint16 w);

	
} 

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\bitfield.inl"


#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\simd\\integer.h"



#pragma once














































































































#line 116 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\simd\\integer.h"
#line 4 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\bitfield.inl"

namespace glm{
namespace detail
{
	template<typename PARAM, typename RET>
	[[nodiscard]] RET bitfieldInterleave(PARAM x, PARAM y);

	template<typename PARAM, typename RET>
	[[nodiscard]] RET bitfieldInterleave(PARAM x, PARAM y, PARAM z);

	template<typename PARAM, typename RET>
	[[nodiscard]] RET bitfieldInterleave(PARAM x, PARAM y, PARAM z, PARAM w);

	template<>
	inline glm::uint16 bitfieldInterleave(glm::uint8 x, glm::uint8 y)
	{
		glm::uint16 REG1(x);
		glm::uint16 REG2(y);

		REG1 = ((REG1 <<  4) | REG1) & static_cast<glm::uint16>(0x0F0F);
		REG2 = ((REG2 <<  4) | REG2) & static_cast<glm::uint16>(0x0F0F);

		REG1 = ((REG1 <<  2) | REG1) & static_cast<glm::uint16>(0x3333);
		REG2 = ((REG2 <<  2) | REG2) & static_cast<glm::uint16>(0x3333);

		REG1 = ((REG1 <<  1) | REG1) & static_cast<glm::uint16>(0x5555);
		REG2 = ((REG2 <<  1) | REG2) & static_cast<glm::uint16>(0x5555);

		return REG1 | static_cast<glm::uint16>(REG2 << 1);
	}

	template<>
	inline glm::uint32 bitfieldInterleave(glm::uint16 x, glm::uint16 y)
	{
		glm::uint32 REG1(x);
		glm::uint32 REG2(y);

		REG1 = ((REG1 <<  8) | REG1) & static_cast<glm::uint32>(0x00FF00FF);
		REG2 = ((REG2 <<  8) | REG2) & static_cast<glm::uint32>(0x00FF00FF);

		REG1 = ((REG1 <<  4) | REG1) & static_cast<glm::uint32>(0x0F0F0F0F);
		REG2 = ((REG2 <<  4) | REG2) & static_cast<glm::uint32>(0x0F0F0F0F);

		REG1 = ((REG1 <<  2) | REG1) & static_cast<glm::uint32>(0x33333333);
		REG2 = ((REG2 <<  2) | REG2) & static_cast<glm::uint32>(0x33333333);

		REG1 = ((REG1 <<  1) | REG1) & static_cast<glm::uint32>(0x55555555);
		REG2 = ((REG2 <<  1) | REG2) & static_cast<glm::uint32>(0x55555555);

		return REG1 | (REG2 << 1);
	}

	template<>
	inline glm::uint64 bitfieldInterleave(glm::uint32 x, glm::uint32 y)
	{
		glm::uint64 REG1(x);
		glm::uint64 REG2(y);

		REG1 = ((REG1 << 16) | REG1) & static_cast<glm::uint64>(0x0000FFFF0000FFFFull);
		REG2 = ((REG2 << 16) | REG2) & static_cast<glm::uint64>(0x0000FFFF0000FFFFull);

		REG1 = ((REG1 <<  8) | REG1) & static_cast<glm::uint64>(0x00FF00FF00FF00FFull);
		REG2 = ((REG2 <<  8) | REG2) & static_cast<glm::uint64>(0x00FF00FF00FF00FFull);

		REG1 = ((REG1 <<  4) | REG1) & static_cast<glm::uint64>(0x0F0F0F0F0F0F0F0Full);
		REG2 = ((REG2 <<  4) | REG2) & static_cast<glm::uint64>(0x0F0F0F0F0F0F0F0Full);

		REG1 = ((REG1 <<  2) | REG1) & static_cast<glm::uint64>(0x3333333333333333ull);
		REG2 = ((REG2 <<  2) | REG2) & static_cast<glm::uint64>(0x3333333333333333ull);

		REG1 = ((REG1 <<  1) | REG1) & static_cast<glm::uint64>(0x5555555555555555ull);
		REG2 = ((REG2 <<  1) | REG2) & static_cast<glm::uint64>(0x5555555555555555ull);

		return REG1 | (REG2 << 1);
	}

	template<>
	inline glm::uint32 bitfieldInterleave(glm::uint8 x, glm::uint8 y, glm::uint8 z)
	{
		glm::uint32 REG1(x);
		glm::uint32 REG2(y);
		glm::uint32 REG3(z);

		REG1 = ((REG1 << 16) | REG1) & static_cast<glm::uint32>(0xFF0000FFu);
		REG2 = ((REG2 << 16) | REG2) & static_cast<glm::uint32>(0xFF0000FFu);
		REG3 = ((REG3 << 16) | REG3) & static_cast<glm::uint32>(0xFF0000FFu);

		REG1 = ((REG1 <<  8) | REG1) & static_cast<glm::uint32>(0x0F00F00Fu);
		REG2 = ((REG2 <<  8) | REG2) & static_cast<glm::uint32>(0x0F00F00Fu);
		REG3 = ((REG3 <<  8) | REG3) & static_cast<glm::uint32>(0x0F00F00Fu);

		REG1 = ((REG1 <<  4) | REG1) & static_cast<glm::uint32>(0xC30C30C3u);
		REG2 = ((REG2 <<  4) | REG2) & static_cast<glm::uint32>(0xC30C30C3u);
		REG3 = ((REG3 <<  4) | REG3) & static_cast<glm::uint32>(0xC30C30C3u);

		REG1 = ((REG1 <<  2) | REG1) & static_cast<glm::uint32>(0x49249249u);
		REG2 = ((REG2 <<  2) | REG2) & static_cast<glm::uint32>(0x49249249u);
		REG3 = ((REG3 <<  2) | REG3) & static_cast<glm::uint32>(0x49249249u);

		return REG1 | (REG2 << 1) | (REG3 << 2);
	}

	template<>
	inline glm::uint64 bitfieldInterleave(glm::uint16 x, glm::uint16 y, glm::uint16 z)
	{
		glm::uint64 REG1(x);
		glm::uint64 REG2(y);
		glm::uint64 REG3(z);

		REG1 = ((REG1 << 32) | REG1) & static_cast<glm::uint64>(0xFFFF00000000FFFFull);
		REG2 = ((REG2 << 32) | REG2) & static_cast<glm::uint64>(0xFFFF00000000FFFFull);
		REG3 = ((REG3 << 32) | REG3) & static_cast<glm::uint64>(0xFFFF00000000FFFFull);

		REG1 = ((REG1 << 16) | REG1) & static_cast<glm::uint64>(0x00FF0000FF0000FFull);
		REG2 = ((REG2 << 16) | REG2) & static_cast<glm::uint64>(0x00FF0000FF0000FFull);
		REG3 = ((REG3 << 16) | REG3) & static_cast<glm::uint64>(0x00FF0000FF0000FFull);

		REG1 = ((REG1 <<  8) | REG1) & static_cast<glm::uint64>(0xF00F00F00F00F00Full);
		REG2 = ((REG2 <<  8) | REG2) & static_cast<glm::uint64>(0xF00F00F00F00F00Full);
		REG3 = ((REG3 <<  8) | REG3) & static_cast<glm::uint64>(0xF00F00F00F00F00Full);

		REG1 = ((REG1 <<  4) | REG1) & static_cast<glm::uint64>(0x30C30C30C30C30C3ull);
		REG2 = ((REG2 <<  4) | REG2) & static_cast<glm::uint64>(0x30C30C30C30C30C3ull);
		REG3 = ((REG3 <<  4) | REG3) & static_cast<glm::uint64>(0x30C30C30C30C30C3ull);

		REG1 = ((REG1 <<  2) | REG1) & static_cast<glm::uint64>(0x9249249249249249ull);
		REG2 = ((REG2 <<  2) | REG2) & static_cast<glm::uint64>(0x9249249249249249ull);
		REG3 = ((REG3 <<  2) | REG3) & static_cast<glm::uint64>(0x9249249249249249ull);

		return REG1 | (REG2 << 1) | (REG3 << 2);
	}

	template<>
	inline glm::uint64 bitfieldInterleave(glm::uint32 x, glm::uint32 y, glm::uint32 z)
	{
		glm::uint64 REG1(x);
		glm::uint64 REG2(y);
		glm::uint64 REG3(z);

		REG1 = ((REG1 << 32) | REG1) & static_cast<glm::uint64>(0xFFFF00000000FFFFull);
		REG2 = ((REG2 << 32) | REG2) & static_cast<glm::uint64>(0xFFFF00000000FFFFull);
		REG3 = ((REG3 << 32) | REG3) & static_cast<glm::uint64>(0xFFFF00000000FFFFull);

		REG1 = ((REG1 << 16) | REG1) & static_cast<glm::uint64>(0x00FF0000FF0000FFull);
		REG2 = ((REG2 << 16) | REG2) & static_cast<glm::uint64>(0x00FF0000FF0000FFull);
		REG3 = ((REG3 << 16) | REG3) & static_cast<glm::uint64>(0x00FF0000FF0000FFull);

		REG1 = ((REG1 <<  8) | REG1) & static_cast<glm::uint64>(0xF00F00F00F00F00Full);
		REG2 = ((REG2 <<  8) | REG2) & static_cast<glm::uint64>(0xF00F00F00F00F00Full);
		REG3 = ((REG3 <<  8) | REG3) & static_cast<glm::uint64>(0xF00F00F00F00F00Full);

		REG1 = ((REG1 <<  4) | REG1) & static_cast<glm::uint64>(0x30C30C30C30C30C3ull);
		REG2 = ((REG2 <<  4) | REG2) & static_cast<glm::uint64>(0x30C30C30C30C30C3ull);
		REG3 = ((REG3 <<  4) | REG3) & static_cast<glm::uint64>(0x30C30C30C30C30C3ull);

		REG1 = ((REG1 <<  2) | REG1) & static_cast<glm::uint64>(0x9249249249249249ull);
		REG2 = ((REG2 <<  2) | REG2) & static_cast<glm::uint64>(0x9249249249249249ull);
		REG3 = ((REG3 <<  2) | REG3) & static_cast<glm::uint64>(0x9249249249249249ull);

		return REG1 | (REG2 << 1) | (REG3 << 2);
	}

	template<>
	inline glm::uint32 bitfieldInterleave(glm::uint8 x, glm::uint8 y, glm::uint8 z, glm::uint8 w)
	{
		glm::uint32 REG1(x);
		glm::uint32 REG2(y);
		glm::uint32 REG3(z);
		glm::uint32 REG4(w);

		REG1 = ((REG1 << 12) | REG1) & static_cast<glm::uint32>(0x000F000Fu);
		REG2 = ((REG2 << 12) | REG2) & static_cast<glm::uint32>(0x000F000Fu);
		REG3 = ((REG3 << 12) | REG3) & static_cast<glm::uint32>(0x000F000Fu);
		REG4 = ((REG4 << 12) | REG4) & static_cast<glm::uint32>(0x000F000Fu);

		REG1 = ((REG1 <<  6) | REG1) & static_cast<glm::uint32>(0x03030303u);
		REG2 = ((REG2 <<  6) | REG2) & static_cast<glm::uint32>(0x03030303u);
		REG3 = ((REG3 <<  6) | REG3) & static_cast<glm::uint32>(0x03030303u);
		REG4 = ((REG4 <<  6) | REG4) & static_cast<glm::uint32>(0x03030303u);

		REG1 = ((REG1 <<  3) | REG1) & static_cast<glm::uint32>(0x11111111u);
		REG2 = ((REG2 <<  3) | REG2) & static_cast<glm::uint32>(0x11111111u);
		REG3 = ((REG3 <<  3) | REG3) & static_cast<glm::uint32>(0x11111111u);
		REG4 = ((REG4 <<  3) | REG4) & static_cast<glm::uint32>(0x11111111u);

		return REG1 | (REG2 << 1) | (REG3 << 2) | (REG4 << 3);
	}

	template<>
	inline glm::uint64 bitfieldInterleave(glm::uint16 x, glm::uint16 y, glm::uint16 z, glm::uint16 w)
	{
		glm::uint64 REG1(x);
		glm::uint64 REG2(y);
		glm::uint64 REG3(z);
		glm::uint64 REG4(w);

		REG1 = ((REG1 << 24) | REG1) & static_cast<glm::uint64>(0x000000FF000000FFull);
		REG2 = ((REG2 << 24) | REG2) & static_cast<glm::uint64>(0x000000FF000000FFull);
		REG3 = ((REG3 << 24) | REG3) & static_cast<glm::uint64>(0x000000FF000000FFull);
		REG4 = ((REG4 << 24) | REG4) & static_cast<glm::uint64>(0x000000FF000000FFull);

		REG1 = ((REG1 << 12) | REG1) & static_cast<glm::uint64>(0x000F000F000F000Full);
		REG2 = ((REG2 << 12) | REG2) & static_cast<glm::uint64>(0x000F000F000F000Full);
		REG3 = ((REG3 << 12) | REG3) & static_cast<glm::uint64>(0x000F000F000F000Full);
		REG4 = ((REG4 << 12) | REG4) & static_cast<glm::uint64>(0x000F000F000F000Full);

		REG1 = ((REG1 <<  6) | REG1) & static_cast<glm::uint64>(0x0303030303030303ull);
		REG2 = ((REG2 <<  6) | REG2) & static_cast<glm::uint64>(0x0303030303030303ull);
		REG3 = ((REG3 <<  6) | REG3) & static_cast<glm::uint64>(0x0303030303030303ull);
		REG4 = ((REG4 <<  6) | REG4) & static_cast<glm::uint64>(0x0303030303030303ull);

		REG1 = ((REG1 <<  3) | REG1) & static_cast<glm::uint64>(0x1111111111111111ull);
		REG2 = ((REG2 <<  3) | REG2) & static_cast<glm::uint64>(0x1111111111111111ull);
		REG3 = ((REG3 <<  3) | REG3) & static_cast<glm::uint64>(0x1111111111111111ull);
		REG4 = ((REG4 <<  3) | REG4) & static_cast<glm::uint64>(0x1111111111111111ull);

		return REG1 | (REG2 << 1) | (REG3 << 2) | (REG4 << 3);
	}
}




#line 228 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\bitfield.inl"

	template<typename genIUType>
	inline genIUType mask(genIUType Bits)
	{
		static_assert(std::numeric_limits<genIUType>::is_integer, "'mask' accepts only integer values") ;

		return Bits >= sizeof(genIUType) * 8 ? ~static_cast<genIUType>(0) : (static_cast<genIUType>(1) << Bits) - static_cast<genIUType>(1);
	}



#line 240 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\bitfield.inl"

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> mask(vec<L, T, Q> const& v)
	{
		static_assert(std::numeric_limits<T>::is_integer, "'mask' accepts only integer values") ;

		return detail::functor1<vec, L, T, T, Q>::call(mask, v);
	}

	template<typename genIType>
	inline genIType bitfieldRotateRight(genIType In, int Shift)
	{
		static_assert(std::numeric_limits<genIType>::is_integer, "'bitfieldRotateRight' accepts only integer values") ;

		int const BitSize = static_cast<genIType>(sizeof(genIType) * 8);
		return (In << static_cast<genIType>(Shift)) | (In >> static_cast<genIType>(BitSize - Shift));
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> bitfieldRotateRight(vec<L, T, Q> const& In, int Shift)
	{
		static_assert(std::numeric_limits<T>::is_integer, "'bitfieldRotateRight' accepts only integer values") ;

		int const BitSize = static_cast<int>(sizeof(T) * 8);
		return (In << static_cast<T>(Shift)) | (In >> static_cast<T>(BitSize - Shift));
	}

	template<typename genIType>
	inline genIType bitfieldRotateLeft(genIType In, int Shift)
	{
		static_assert(std::numeric_limits<genIType>::is_integer, "'bitfieldRotateLeft' accepts only integer values") ;

		int const BitSize = static_cast<genIType>(sizeof(genIType) * 8);
		return (In >> static_cast<genIType>(Shift)) | (In << static_cast<genIType>(BitSize - Shift));
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> bitfieldRotateLeft(vec<L, T, Q> const& In, int Shift)
	{
		static_assert(std::numeric_limits<T>::is_integer, "'bitfieldRotateLeft' accepts only integer values") ;

		int const BitSize = static_cast<int>(sizeof(T) * 8);
		return (In >> static_cast<T>(Shift)) | (In << static_cast<T>(BitSize - Shift));
	}

	template<typename genIUType>
	inline genIUType bitfieldFillOne(genIUType Value, int FirstBit, int BitCount)
	{
		return Value | static_cast<genIUType>(mask(BitCount) << FirstBit);
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> bitfieldFillOne(vec<L, T, Q> const& Value, int FirstBit, int BitCount)
	{
		return Value | static_cast<T>(mask(BitCount) << FirstBit);
	}

	template<typename genIUType>
	inline genIUType bitfieldFillZero(genIUType Value, int FirstBit, int BitCount)
	{
		return Value & static_cast<genIUType>(~(mask(BitCount) << FirstBit));
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> bitfieldFillZero(vec<L, T, Q> const& Value, int FirstBit, int BitCount)
	{
		return Value & static_cast<T>(~(mask(BitCount) << FirstBit));
	}

	inline int16 bitfieldInterleave(int8 x, int8 y)
	{
		union sign8
		{
			int8 i;
			uint8 u;
		} sign_x, sign_y;

		union sign16
		{
			int16 i;
			uint16 u;
		} result;

		sign_x.i = x;
		sign_y.i = y;
		result.u = bitfieldInterleave(sign_x.u, sign_y.u);

		return result.i;
	}

	inline uint16 bitfieldInterleave(uint8 x, uint8 y)
	{
		return detail::bitfieldInterleave<uint8, uint16>(x, y);
	}

	inline uint16 bitfieldInterleave(u8vec2 const& v)
	{
		return detail::bitfieldInterleave<uint8, uint16>(v.x, v.y);
	}

	inline u8vec2 bitfieldDeinterleave(glm::uint16 x)
	{
		uint16 REG1(x);
		uint16 REG2(x >>= 1);

		REG1 = REG1 & static_cast<uint16>(0x5555);
		REG2 = REG2 & static_cast<uint16>(0x5555);

		REG1 = ((REG1 >> 1) | REG1) & static_cast<uint16>(0x3333);
		REG2 = ((REG2 >> 1) | REG2) & static_cast<uint16>(0x3333);

		REG1 = ((REG1 >> 2) | REG1) & static_cast<uint16>(0x0F0F);
		REG2 = ((REG2 >> 2) | REG2) & static_cast<uint16>(0x0F0F);

		REG1 = ((REG1 >> 4) | REG1) & static_cast<uint16>(0x00FF);
		REG2 = ((REG2 >> 4) | REG2) & static_cast<uint16>(0x00FF);

		REG1 = ((REG1 >> 8) | REG1) & static_cast<uint16>(0xFFFF);
		REG2 = ((REG2 >> 8) | REG2) & static_cast<uint16>(0xFFFF);

		return glm::u8vec2(REG1, REG2);
	}

	inline int32 bitfieldInterleave(int16 x, int16 y)
	{
		union sign16
		{
			int16 i;
			uint16 u;
		} sign_x, sign_y;

		union sign32
		{
			int32 i;
			uint32 u;
		} result;

		sign_x.i = x;
		sign_y.i = y;
		result.u = bitfieldInterleave(sign_x.u, sign_y.u);

		return result.i;
	}

	inline uint32 bitfieldInterleave(uint16 x, uint16 y)
	{
		return detail::bitfieldInterleave<uint16, uint32>(x, y);
	}

	inline glm::uint32 bitfieldInterleave(u16vec2 const& v)
	{
		return detail::bitfieldInterleave<uint16, uint32>(v.x, v.y);
	}

	inline glm::u16vec2 bitfieldDeinterleave(glm::uint32 x)
	{
		glm::uint32 REG1(x);
		glm::uint32 REG2(x >>= 1);

		REG1 = REG1 & static_cast<glm::uint32>(0x55555555);
		REG2 = REG2 & static_cast<glm::uint32>(0x55555555);

		REG1 = ((REG1 >> 1) | REG1) & static_cast<glm::uint32>(0x33333333);
		REG2 = ((REG2 >> 1) | REG2) & static_cast<glm::uint32>(0x33333333);

		REG1 = ((REG1 >> 2) | REG1) & static_cast<glm::uint32>(0x0F0F0F0F);
		REG2 = ((REG2 >> 2) | REG2) & static_cast<glm::uint32>(0x0F0F0F0F);

		REG1 = ((REG1 >> 4) | REG1) & static_cast<glm::uint32>(0x00FF00FF);
		REG2 = ((REG2 >> 4) | REG2) & static_cast<glm::uint32>(0x00FF00FF);

		REG1 = ((REG1 >> 8) | REG1) & static_cast<glm::uint32>(0x0000FFFF);
		REG2 = ((REG2 >> 8) | REG2) & static_cast<glm::uint32>(0x0000FFFF);

		return glm::u16vec2(REG1, REG2);
	}

	inline int64 bitfieldInterleave(int32 x, int32 y)
	{
		union sign32
		{
			int32 i;
			uint32 u;
		} sign_x, sign_y;

		union sign64
		{
			int64 i;
			uint64 u;
		} result;

		sign_x.i = x;
		sign_y.i = y;
		result.u = bitfieldInterleave(sign_x.u, sign_y.u);

		return result.i;
	}

	inline uint64 bitfieldInterleave(uint32 x, uint32 y)
	{
		return detail::bitfieldInterleave<uint32, uint64>(x, y);
	}

	inline glm::uint64 bitfieldInterleave(u32vec2 const& v)
	{
		return detail::bitfieldInterleave<uint32, uint64>(v.x, v.y);
	}

	inline glm::u32vec2 bitfieldDeinterleave(glm::uint64 x)
	{
		glm::uint64 REG1(x);
		glm::uint64 REG2(x >>= 1);

		REG1 = REG1 & static_cast<glm::uint64>(0x5555555555555555ull);
		REG2 = REG2 & static_cast<glm::uint64>(0x5555555555555555ull);

		REG1 = ((REG1 >> 1) | REG1) & static_cast<glm::uint64>(0x3333333333333333ull);
		REG2 = ((REG2 >> 1) | REG2) & static_cast<glm::uint64>(0x3333333333333333ull);

		REG1 = ((REG1 >> 2) | REG1) & static_cast<glm::uint64>(0x0F0F0F0F0F0F0F0Full);
		REG2 = ((REG2 >> 2) | REG2) & static_cast<glm::uint64>(0x0F0F0F0F0F0F0F0Full);

		REG1 = ((REG1 >> 4) | REG1) & static_cast<glm::uint64>(0x00FF00FF00FF00FFull);
		REG2 = ((REG2 >> 4) | REG2) & static_cast<glm::uint64>(0x00FF00FF00FF00FFull);

		REG1 = ((REG1 >> 8) | REG1) & static_cast<glm::uint64>(0x0000FFFF0000FFFFull);
		REG2 = ((REG2 >> 8) | REG2) & static_cast<glm::uint64>(0x0000FFFF0000FFFFull);

		REG1 = ((REG1 >> 16) | REG1) & static_cast<glm::uint64>(0x00000000FFFFFFFFull);
		REG2 = ((REG2 >> 16) | REG2) & static_cast<glm::uint64>(0x00000000FFFFFFFFull);

		return glm::u32vec2(REG1, REG2);
	}

	inline int32 bitfieldInterleave(int8 x, int8 y, int8 z)
	{
		union sign8
		{
			int8 i;
			uint8 u;
		} sign_x, sign_y, sign_z;

		union sign32
		{
			int32 i;
			uint32 u;
		} result;

		sign_x.i = x;
		sign_y.i = y;
		sign_z.i = z;
		result.u = bitfieldInterleave(sign_x.u, sign_y.u, sign_z.u);

		return result.i;
	}

	inline uint32 bitfieldInterleave(uint8 x, uint8 y, uint8 z)
	{
		return detail::bitfieldInterleave<uint8, uint32>(x, y, z);
	}

	inline uint32 bitfieldInterleave(u8vec3 const& v)
	{
		return detail::bitfieldInterleave<uint8, uint32>(v.x, v.y, v.z);
	}

	inline int64 bitfieldInterleave(int16 x, int16 y, int16 z)
	{
		union sign16
		{
			int16 i;
			uint16 u;
		} sign_x, sign_y, sign_z;

		union sign64
		{
			int64 i;
			uint64 u;
		} result;

		sign_x.i = x;
		sign_y.i = y;
		sign_z.i = z;
		result.u = bitfieldInterleave(sign_x.u, sign_y.u, sign_z.u);

		return result.i;
	}

	inline uint64 bitfieldInterleave(uint16 x, uint16 y, uint16 z)
	{
		return detail::bitfieldInterleave<uint32, uint64>(x, y, z);
	}

	inline uint64 bitfieldInterleave(u16vec3 const& v)
	{
		return detail::bitfieldInterleave<uint32, uint64>(v.x, v.y, v.z);
	}

	inline int64 bitfieldInterleave(int32 x, int32 y, int32 z)
	{
		union sign16
		{
			int32 i;
			uint32 u;
		} sign_x, sign_y, sign_z;

		union sign64
		{
			int64 i;
			uint64 u;
		} result;

		sign_x.i = x;
		sign_y.i = y;
		sign_z.i = z;
		result.u = bitfieldInterleave(sign_x.u, sign_y.u, sign_z.u);

		return result.i;
	}

	inline uint64 bitfieldInterleave(uint32 x, uint32 y, uint32 z)
	{
		return detail::bitfieldInterleave<uint32, uint64>(x, y, z);
	}

	inline uint64 bitfieldInterleave(u32vec3 const& v)
	{
		return detail::bitfieldInterleave<uint32, uint64>(v.x, v.y, v.z);
	}

	inline int32 bitfieldInterleave(int8 x, int8 y, int8 z, int8 w)
	{
		union sign8
		{
			int8 i;
			uint8 u;
		} sign_x, sign_y, sign_z, sign_w;

		union sign32
		{
			int32 i;
			uint32 u;
		} result;

		sign_x.i = x;
		sign_y.i = y;
		sign_z.i = z;
		sign_w.i = w;
		result.u = bitfieldInterleave(sign_x.u, sign_y.u, sign_z.u, sign_w.u);

		return result.i;
	}

	inline uint32 bitfieldInterleave(uint8 x, uint8 y, uint8 z, uint8 w)
	{
		return detail::bitfieldInterleave<uint8, uint32>(x, y, z, w);
	}

	inline uint32 bitfieldInterleave(u8vec4 const& v)
	{
		return detail::bitfieldInterleave<uint8, uint32>(v.x, v.y, v.z, v.w);
	}

	inline int64 bitfieldInterleave(int16 x, int16 y, int16 z, int16 w)
	{
		union sign16
		{
			int16 i;
			uint16 u;
		} sign_x, sign_y, sign_z, sign_w;

		union sign64
		{
			int64 i;
			uint64 u;
		} result;

		sign_x.i = x;
		sign_y.i = y;
		sign_z.i = z;
		sign_w.i = w;
		result.u = bitfieldInterleave(sign_x.u, sign_y.u, sign_z.u, sign_w.u);

		return result.i;
	}

	inline uint64 bitfieldInterleave(uint16 x, uint16 y, uint16 z, uint16 w)
	{
		return detail::bitfieldInterleave<uint16, uint64>(x, y, z, w);
	}

	inline uint64 bitfieldInterleave(u16vec4 const& v)
	{
		return detail::bitfieldInterleave<uint16, uint64>(v.x, v.y, v.z, v.w);
	}
}
#line 267 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\bitfield.hpp"
#line 174 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\color_space.hpp"













#pragma once


#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 970 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
























































































































































































































#line 1187 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 1189 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
#line 18 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\color_space.hpp"








#line 27 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\color_space.hpp"

namespace glm
{
	
	

	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> convertLinearToSRGB(vec<L, T, Q> const& ColorLinear);

	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> convertLinearToSRGB(vec<L, T, Q> const& ColorLinear, T Gamma);

	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> convertSRGBToLinear(vec<L, T, Q> const& ColorSRGB);

	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> convertSRGBToLinear(vec<L, T, Q> const& ColorSRGB, T Gamma);

	
} 

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\color_space.inl"


namespace glm{
namespace detail
{
	template<length_t L, typename T, qualifier Q>
	struct compute_rgbToSrgb
	{
		inline static vec<L, T, Q> call(vec<L, T, Q> const& ColorRGB, T GammaCorrection)
		{
			vec<L, T, Q> const ClampedColor(clamp(ColorRGB, static_cast<T>(0), static_cast<T>(1)));

			return mix(
				pow(ClampedColor, vec<L, T, Q>(GammaCorrection)) * static_cast<T>(1.055) - static_cast<T>(0.055),
				ClampedColor * static_cast<T>(12.92),
				lessThan(ClampedColor, vec<L, T, Q>(static_cast<T>(0.0031308))));
		}
	};

	template<typename T, qualifier Q>
	struct compute_rgbToSrgb<4, T, Q>
	{
		inline static vec<4, T, Q> call(vec<4, T, Q> const& ColorRGB, T GammaCorrection)
		{
			return vec<4, T, Q>(compute_rgbToSrgb<3, T, Q>::call(vec<3, T, Q>(ColorRGB), GammaCorrection), ColorRGB.w);
		}
	};

	template<length_t L, typename T, qualifier Q>
	struct compute_srgbToRgb
	{
		inline static vec<L, T, Q> call(vec<L, T, Q> const& ColorSRGB, T Gamma)
		{
			return mix(
				pow((ColorSRGB + static_cast<T>(0.055)) * static_cast<T>(0.94786729857819905213270142180095), vec<L, T, Q>(Gamma)),
				ColorSRGB * static_cast<T>(0.07739938080495356037151702786378),
				lessThanEqual(ColorSRGB, vec<L, T, Q>(static_cast<T>(0.04045))));
		}
	};

	template<typename T, qualifier Q>
	struct compute_srgbToRgb<4, T, Q>
	{
		inline static vec<4, T, Q> call(vec<4, T, Q> const& ColorSRGB, T Gamma)
		{
			return vec<4, T, Q>(compute_srgbToRgb<3, T, Q>::call(vec<3, T, Q>(ColorSRGB), Gamma), ColorSRGB.w);
		}
	};
}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> convertLinearToSRGB(vec<L, T, Q> const& ColorLinear)
	{
		return detail::compute_rgbToSrgb<L, T, Q>::call(ColorLinear, static_cast<T>(0.41666));
	}

	
	template<>
	inline vec<3, float, lowp> convertLinearToSRGB(vec<3, float, lowp> const& ColorLinear)
	{
		vec<3, float, lowp> S1 = sqrt(ColorLinear);
		vec<3, float, lowp> S2 = sqrt(S1);
		vec<3, float, lowp> S3 = sqrt(S2);
		return 0.662002687f * S1 + 0.684122060f * S2 - 0.323583601f * S3 - 0.0225411470f * ColorLinear;
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> convertLinearToSRGB(vec<L, T, Q> const& ColorLinear, T Gamma)
	{
		return detail::compute_rgbToSrgb<L, T, Q>::call(ColorLinear, static_cast<T>(1) / Gamma);
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> convertSRGBToLinear(vec<L, T, Q> const& ColorSRGB)
	{
		return detail::compute_srgbToRgb<L, T, Q>::call(ColorSRGB, static_cast<T>(2.4));
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> convertSRGBToLinear(vec<L, T, Q> const& ColorSRGB, T Gamma)
	{
		return detail::compute_srgbToRgb<L, T, Q>::call(ColorSRGB, Gamma);
	}
}
#line 57 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\color_space.hpp"
#line 175 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"


#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\integer.hpp"













#pragma once


#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 970 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
























































































































































































































#line 1187 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 1189 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
#line 18 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\integer.hpp"










#line 29 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\integer.hpp"

namespace glm
{
	
	

	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> log2(vec<L, T, Q> const& v);

	
} 

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\integer.inl"


namespace glm{
namespace detail
{
	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_log2<L, T, Q, false, Aligned>
	{
		inline static vec<L, T, Q> call(vec<L, T, Q> const& v)
		{
			
			
			return vec<L, T, Q>(detail::compute_findMSB_vec<L, T, Q, sizeof(T) * 8>::call(v));
		}
	};















#line 32 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\integer.inl"
}
}
#line 44 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\integer.hpp"
#line 178 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\matrix_access.hpp"












#pragma once


#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 970 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
























































































































































































































#line 1187 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 1189 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
#line 17 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\matrix_access.hpp"



#line 21 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\matrix_access.hpp"

namespace glm
{
	
	

	
	
	template<typename genType>
	[[nodiscard]] typename genType::row_type row(
		genType const& m,
		length_t index);

	
	
	template<typename genType>
	[[nodiscard]] genType row(
		genType const& m,
		length_t index,
		typename genType::row_type const& x);

	
	
	template<typename genType>
	[[nodiscard]] typename genType::col_type column(
		genType const& m,
		length_t index);

	
	
	template<typename genType>
	[[nodiscard]] genType column(
		genType const& m,
		length_t index,
		typename genType::col_type const& x);

	
}

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\matrix_access.inl"


namespace glm
{
	template<typename genType>
	inline genType row
	(
		genType const& m,
		length_t index,
		typename genType::row_type const& x
	)
	{
		(void)( (!!(index >= 0 && index < m[0].length())) || (_wassert(L"index >= 0 && index < m[0].length()", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\matrix_access.inl", (unsigned)(13)), 0) ) ;

		genType Result = m;
		for(length_t i = 0; i < m.length(); ++i)
			Result[i][index] = x[i];
		return Result;
	}

	template<typename genType>
	inline typename genType::row_type row
	(
		genType const& m,
		length_t index
	)
	{
		(void)( (!!(index >= 0 && index < m[0].length())) || (_wassert(L"index >= 0 && index < m[0].length()", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\matrix_access.inl", (unsigned)(28)), 0) ) ;

		typename genType::row_type Result(0);
		for(length_t i = 0; i < m.length(); ++i)
			Result[i] = m[i][index];
		return Result;
	}

	template<typename genType>
	inline genType column
	(
		genType const& m,
		length_t index,
		typename genType::col_type const& x
	)
	{
		(void)( (!!(index >= 0 && index < m.length())) || (_wassert(L"index >= 0 && index < m.length()", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\matrix_access.inl", (unsigned)(44)), 0) ) ;

		genType Result = m;
		Result[index] = x;
		return Result;
	}

	template<typename genType>
	inline typename genType::col_type column
	(
		genType const& m,
		length_t index
	)
	{
		(void)( (!!(index >= 0 && index < m.length())) || (_wassert(L"index >= 0 && index < m.length()", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\matrix_access.inl", (unsigned)(58)), 0) ) ;

		return m[index];
	}
}
#line 61 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\matrix_access.hpp"
#line 179 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\matrix_integer.hpp"












#pragma once














#line 29 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\matrix_integer.hpp"

namespace glm
{
	
	

	
	
	typedef mat<2, 2, int, highp>				highp_imat2;

	
	
	typedef mat<3, 3, int, highp>				highp_imat3;

	
	
	typedef mat<4, 4, int, highp>				highp_imat4;

	
	
	typedef mat<2, 2, int, highp>				highp_imat2x2;

	
	
	typedef mat<2, 3, int, highp>				highp_imat2x3;

	
	
	typedef mat<2, 4, int, highp>				highp_imat2x4;

	
	
	typedef mat<3, 2, int, highp>				highp_imat3x2;

	
	
	typedef mat<3, 3, int, highp>				highp_imat3x3;

	
	
	typedef mat<3, 4, int, highp>				highp_imat3x4;

	
	
	typedef mat<4, 2, int, highp>				highp_imat4x2;

	
	
	typedef mat<4, 3, int, highp>				highp_imat4x3;

	
	
	typedef mat<4, 4, int, highp>				highp_imat4x4;


	
	
	typedef mat<2, 2, int, mediump>			mediump_imat2;

	
	
	typedef mat<3, 3, int, mediump>			mediump_imat3;

	
	
	typedef mat<4, 4, int, mediump>			mediump_imat4;


	
	
	typedef mat<2, 2, int, mediump>			mediump_imat2x2;

	
	
	typedef mat<2, 3, int, mediump>			mediump_imat2x3;

	
	
	typedef mat<2, 4, int, mediump>			mediump_imat2x4;

	
	
	typedef mat<3, 2, int, mediump>			mediump_imat3x2;

	
	
	typedef mat<3, 3, int, mediump>			mediump_imat3x3;

	
	
	typedef mat<3, 4, int, mediump>			mediump_imat3x4;

	
	
	typedef mat<4, 2, int, mediump>			mediump_imat4x2;

	
	
	typedef mat<4, 3, int, mediump>			mediump_imat4x3;

	
	
	typedef mat<4, 4, int, mediump>			mediump_imat4x4;


	
	
	typedef mat<2, 2, int, lowp>				lowp_imat2;

	
	
	typedef mat<3, 3, int, lowp>				lowp_imat3;

	
	
	typedef mat<4, 4, int, lowp>				lowp_imat4;


	
	
	typedef mat<2, 2, int, lowp>				lowp_imat2x2;

	
	
	typedef mat<2, 3, int, lowp>				lowp_imat2x3;

	
	
	typedef mat<2, 4, int, lowp>				lowp_imat2x4;

	
	
	typedef mat<3, 2, int, lowp>				lowp_imat3x2;

	
	
	typedef mat<3, 3, int, lowp>				lowp_imat3x3;

	
	
	typedef mat<3, 4, int, lowp>				lowp_imat3x4;

	
	
	typedef mat<4, 2, int, lowp>				lowp_imat4x2;

	
	
	typedef mat<4, 3, int, lowp>				lowp_imat4x3;

	
	
	typedef mat<4, 4, int, lowp>				lowp_imat4x4;


	
	
	typedef mat<2, 2, uint, highp>				highp_umat2;

	
	
	typedef mat<3, 3, uint, highp>				highp_umat3;

	
	
	typedef mat<4, 4, uint, highp>				highp_umat4;

	
	
	typedef mat<2, 2, uint, highp>				highp_umat2x2;

	
	
	typedef mat<2, 3, uint, highp>				highp_umat2x3;

	
	
	typedef mat<2, 4, uint, highp>				highp_umat2x4;

	
	
	typedef mat<3, 2, uint, highp>				highp_umat3x2;

	
	
	typedef mat<3, 3, uint, highp>				highp_umat3x3;

	
	
	typedef mat<3, 4, uint, highp>				highp_umat3x4;

	
	
	typedef mat<4, 2, uint, highp>				highp_umat4x2;

	
	
	typedef mat<4, 3, uint, highp>				highp_umat4x3;

	
	
	typedef mat<4, 4, uint, highp>				highp_umat4x4;


	
	
	typedef mat<2, 2, uint, mediump>			mediump_umat2;

	
	
	typedef mat<3, 3, uint, mediump>			mediump_umat3;

	
	
	typedef mat<4, 4, uint, mediump>			mediump_umat4;


	
	
	typedef mat<2, 2, uint, mediump>			mediump_umat2x2;

	
	
	typedef mat<2, 3, uint, mediump>			mediump_umat2x3;

	
	
	typedef mat<2, 4, uint, mediump>			mediump_umat2x4;

	
	
	typedef mat<3, 2, uint, mediump>			mediump_umat3x2;

	
	
	typedef mat<3, 3, uint, mediump>			mediump_umat3x3;

	
	
	typedef mat<3, 4, uint, mediump>			mediump_umat3x4;

	
	
	typedef mat<4, 2, uint, mediump>			mediump_umat4x2;

	
	
	typedef mat<4, 3, uint, mediump>			mediump_umat4x3;

	
	
	typedef mat<4, 4, uint, mediump>			mediump_umat4x4;


	
	
	typedef mat<2, 2, uint, lowp>				lowp_umat2;

	
	
	typedef mat<3, 3, uint, lowp>				lowp_umat3;

	
	
	typedef mat<4, 4, uint, lowp>				lowp_umat4;


	
	
	typedef mat<2, 2, uint, lowp>				lowp_umat2x2;

	
	
	typedef mat<2, 3, uint, lowp>				lowp_umat2x3;

	
	
	typedef mat<2, 4, uint, lowp>				lowp_umat2x4;

	
	
	typedef mat<3, 2, uint, lowp>				lowp_umat3x2;

	
	
	typedef mat<3, 3, uint, lowp>				lowp_umat3x3;

	
	
	typedef mat<3, 4, uint, lowp>				lowp_umat3x4;

	
	
	typedef mat<4, 2, uint, lowp>				lowp_umat4x2;

	
	
	typedef mat<4, 3, uint, lowp>				lowp_umat4x3;

	
	
	typedef mat<4, 4, uint, lowp>				lowp_umat4x4;



	
	
	typedef mat<2, 2, int, defaultp>				imat2;

	
	
	typedef mat<3, 3, int, defaultp>				imat3;

	
	
	typedef mat<4, 4, int, defaultp>				imat4;

	
	
	typedef mat<2, 2, int, defaultp>				imat2x2;

	
	
	typedef mat<2, 3, int, defaultp>				imat2x3;

	
	
	typedef mat<2, 4, int, defaultp>				imat2x4;

	
	
	typedef mat<3, 2, int, defaultp>				imat3x2;

	
	
	typedef mat<3, 3, int, defaultp>				imat3x3;

	
	
	typedef mat<3, 4, int, defaultp>				imat3x4;

	
	
	typedef mat<4, 2, int, defaultp>				imat4x2;

	
	
	typedef mat<4, 3, int, defaultp>				imat4x3;

	
	
	typedef mat<4, 4, int, defaultp>				imat4x4;



	
	
	typedef mat<2, 2, uint, defaultp>				umat2;

	
	
	typedef mat<3, 3, uint, defaultp>				umat3;

	
	
	typedef mat<4, 4, uint, defaultp>				umat4;

	
	
	typedef mat<2, 2, uint, defaultp>				umat2x2;

	
	
	typedef mat<2, 3, uint, defaultp>				umat2x3;

	
	
	typedef mat<2, 4, uint, defaultp>				umat2x4;

	
	
	typedef mat<3, 2, uint, defaultp>				umat3x2;

	
	
	typedef mat<3, 3, uint, defaultp>				umat3x3;

	
	
	typedef mat<3, 4, uint, defaultp>				umat3x4;

	
	
	typedef mat<4, 2, uint, defaultp>				umat4x2;

	
	
	typedef mat<4, 3, uint, defaultp>				umat4x3;

	
	
	typedef mat<4, 4, uint, defaultp>				umat4x4;

	
}
#line 180 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\matrix_inverse.hpp"












#pragma once


#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 970 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
























































































































































































































#line 1187 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 1189 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
#line 17 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\matrix_inverse.hpp"







#line 25 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\matrix_inverse.hpp"

namespace glm
{
	
	

	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType affineInverse(genType const& m);

	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType inverseTranspose(genType const& m);

	
}

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\matrix_inverse.inl"


namespace glm
{
	template<typename T, qualifier Q>
	inline mat<3, 3, T, Q> affineInverse(mat<3, 3, T, Q> const& m)
	{
		mat<2, 2, T, Q> const Inv(inverse(mat<2, 2, T, Q>(m)));

		return mat<3, 3, T, Q>(
			vec<3, T, Q>(Inv[0], static_cast<T>(0)),
			vec<3, T, Q>(Inv[1], static_cast<T>(0)),
			vec<3, T, Q>(-Inv * vec<2, T, Q>(m[2]), static_cast<T>(1)));
	}

	template<typename T, qualifier Q>
	inline mat<4, 4, T, Q> affineInverse(mat<4, 4, T, Q> const& m)
	{
		mat<3, 3, T, Q> const Inv(inverse(mat<3, 3, T, Q>(m)));

		return mat<4, 4, T, Q>(
			vec<4, T, Q>(Inv[0], static_cast<T>(0)),
			vec<4, T, Q>(Inv[1], static_cast<T>(0)),
			vec<4, T, Q>(Inv[2], static_cast<T>(0)),
			vec<4, T, Q>(-Inv * vec<3, T, Q>(m[3]), static_cast<T>(1)));
	}

	template<typename T, qualifier Q>
	inline mat<2, 2, T, Q> inverseTranspose(mat<2, 2, T, Q> const& m)
	{
		T Determinant = m[0][0] * m[1][1] - m[1][0] * m[0][1];

		mat<2, 2, T, Q> Inverse(
			+ m[1][1] / Determinant,
			- m[0][1] / Determinant,
			- m[1][0] / Determinant,
			+ m[0][0] / Determinant);

		return Inverse;
	}

	template<typename T, qualifier Q>
	inline mat<3, 3, T, Q> inverseTranspose(mat<3, 3, T, Q> const& m)
	{
		T Determinant =
			+ m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1])
			- m[0][1] * (m[1][0] * m[2][2] - m[1][2] * m[2][0])
			+ m[0][2] * (m[1][0] * m[2][1] - m[1][1] * m[2][0]);

		mat<3, 3, T, Q> Inverse;
		Inverse[0][0] = + (m[1][1] * m[2][2] - m[2][1] * m[1][2]);
		Inverse[0][1] = - (m[1][0] * m[2][2] - m[2][0] * m[1][2]);
		Inverse[0][2] = + (m[1][0] * m[2][1] - m[2][0] * m[1][1]);
		Inverse[1][0] = - (m[0][1] * m[2][2] - m[2][1] * m[0][2]);
		Inverse[1][1] = + (m[0][0] * m[2][2] - m[2][0] * m[0][2]);
		Inverse[1][2] = - (m[0][0] * m[2][1] - m[2][0] * m[0][1]);
		Inverse[2][0] = + (m[0][1] * m[1][2] - m[1][1] * m[0][2]);
		Inverse[2][1] = - (m[0][0] * m[1][2] - m[1][0] * m[0][2]);
		Inverse[2][2] = + (m[0][0] * m[1][1] - m[1][0] * m[0][1]);
		Inverse /= Determinant;

		return Inverse;
	}

	template<typename T, qualifier Q>
	inline mat<4, 4, T, Q> inverseTranspose(mat<4, 4, T, Q> const& m)
	{
		T SubFactor00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
		T SubFactor01 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
		T SubFactor02 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
		T SubFactor03 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
		T SubFactor04 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
		T SubFactor05 = m[2][0] * m[3][1] - m[3][0] * m[2][1];
		T SubFactor06 = m[1][2] * m[3][3] - m[3][2] * m[1][3];
		T SubFactor07 = m[1][1] * m[3][3] - m[3][1] * m[1][3];
		T SubFactor08 = m[1][1] * m[3][2] - m[3][1] * m[1][2];
		T SubFactor09 = m[1][0] * m[3][3] - m[3][0] * m[1][3];
		T SubFactor10 = m[1][0] * m[3][2] - m[3][0] * m[1][2];
		T SubFactor11 = m[1][0] * m[3][1] - m[3][0] * m[1][1];
		T SubFactor12 = m[1][2] * m[2][3] - m[2][2] * m[1][3];
		T SubFactor13 = m[1][1] * m[2][3] - m[2][1] * m[1][3];
		T SubFactor14 = m[1][1] * m[2][2] - m[2][1] * m[1][2];
		T SubFactor15 = m[1][0] * m[2][3] - m[2][0] * m[1][3];
		T SubFactor16 = m[1][0] * m[2][2] - m[2][0] * m[1][2];
		T SubFactor17 = m[1][0] * m[2][1] - m[2][0] * m[1][1];

		mat<4, 4, T, Q> Inverse;
		Inverse[0][0] = + (m[1][1] * SubFactor00 - m[1][2] * SubFactor01 + m[1][3] * SubFactor02);
		Inverse[0][1] = - (m[1][0] * SubFactor00 - m[1][2] * SubFactor03 + m[1][3] * SubFactor04);
		Inverse[0][2] = + (m[1][0] * SubFactor01 - m[1][1] * SubFactor03 + m[1][3] * SubFactor05);
		Inverse[0][3] = - (m[1][0] * SubFactor02 - m[1][1] * SubFactor04 + m[1][2] * SubFactor05);

		Inverse[1][0] = - (m[0][1] * SubFactor00 - m[0][2] * SubFactor01 + m[0][3] * SubFactor02);
		Inverse[1][1] = + (m[0][0] * SubFactor00 - m[0][2] * SubFactor03 + m[0][3] * SubFactor04);
		Inverse[1][2] = - (m[0][0] * SubFactor01 - m[0][1] * SubFactor03 + m[0][3] * SubFactor05);
		Inverse[1][3] = + (m[0][0] * SubFactor02 - m[0][1] * SubFactor04 + m[0][2] * SubFactor05);

		Inverse[2][0] = + (m[0][1] * SubFactor06 - m[0][2] * SubFactor07 + m[0][3] * SubFactor08);
		Inverse[2][1] = - (m[0][0] * SubFactor06 - m[0][2] * SubFactor09 + m[0][3] * SubFactor10);
		Inverse[2][2] = + (m[0][0] * SubFactor07 - m[0][1] * SubFactor09 + m[0][3] * SubFactor11);
		Inverse[2][3] = - (m[0][0] * SubFactor08 - m[0][1] * SubFactor10 + m[0][2] * SubFactor11);

		Inverse[3][0] = - (m[0][1] * SubFactor12 - m[0][2] * SubFactor13 + m[0][3] * SubFactor14);
		Inverse[3][1] = + (m[0][0] * SubFactor12 - m[0][2] * SubFactor15 + m[0][3] * SubFactor16);
		Inverse[3][2] = - (m[0][0] * SubFactor13 - m[0][1] * SubFactor15 + m[0][3] * SubFactor17);
		Inverse[3][3] = + (m[0][0] * SubFactor14 - m[0][1] * SubFactor16 + m[0][2] * SubFactor17);

		T Determinant =
			+ m[0][0] * Inverse[0][0]
			+ m[0][1] * Inverse[0][1]
			+ m[0][2] * Inverse[0][2]
			+ m[0][3] * Inverse[0][3];

		Inverse /= Determinant;

		return Inverse;
	}
}
#line 51 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\matrix_inverse.hpp"
#line 181 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\noise.hpp"
















#pragma once


#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 970 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
























































































































































































































#line 1187 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 1189 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
#line 21 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\noise.hpp"

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\_noise.hpp"
#pragma once



namespace glm{
namespace detail
{
	template<typename T>
	inline T mod289(T const& x)
	{
		return x - floor(x * (static_cast<T>(1.0) / static_cast<T>(289.0))) * static_cast<T>(289.0);
	}

	template<typename T>
	inline T permute(T const& x)
	{
		return mod289(((x * static_cast<T>(34)) + static_cast<T>(1)) * x);
	}

	template<typename T, qualifier Q>
	inline vec<2, T, Q> permute(vec<2, T, Q> const& x)
	{
		return mod289(((x * static_cast<T>(34)) + static_cast<T>(1)) * x);
	}

	template<typename T, qualifier Q>
	inline vec<3, T, Q> permute(vec<3, T, Q> const& x)
	{
		return mod289(((x * static_cast<T>(34)) + static_cast<T>(1)) * x);
	}

	template<typename T, qualifier Q>
	inline vec<4, T, Q> permute(vec<4, T, Q> const& x)
	{
		return mod289(((x * static_cast<T>(34)) + static_cast<T>(1)) * x);
	}

	template<typename T>
	inline T taylorInvSqrt(T const& r)
	{
		return static_cast<T>(1.79284291400159) - static_cast<T>(0.85373472095314) * r;
	}

	template<typename T, qualifier Q>
	inline vec<2, T, Q> taylorInvSqrt(vec<2, T, Q> const& r)
	{
		return static_cast<T>(1.79284291400159) - static_cast<T>(0.85373472095314) * r;
	}

	template<typename T, qualifier Q>
	inline vec<3, T, Q> taylorInvSqrt(vec<3, T, Q> const& r)
	{
		return static_cast<T>(1.79284291400159) - static_cast<T>(0.85373472095314) * r;
	}

	template<typename T, qualifier Q>
	inline vec<4, T, Q> taylorInvSqrt(vec<4, T, Q> const& r)
	{
		return static_cast<T>(1.79284291400159) - static_cast<T>(0.85373472095314) * r;
	}

	template<typename T, qualifier Q>
	inline vec<2, T, Q> fade(vec<2, T, Q> const& t)
	{
		return (t * t * t) * (t * (t * static_cast<T>(6) - static_cast<T>(15)) + static_cast<T>(10));
	}

	template<typename T, qualifier Q>
	inline vec<3, T, Q> fade(vec<3, T, Q> const& t)
	{
		return (t * t * t) * (t * (t * static_cast<T>(6) - static_cast<T>(15)) + static_cast<T>(10));
	}

	template<typename T, qualifier Q>
	inline vec<4, T, Q> fade(vec<4, T, Q> const& t)
	{
		return (t * t * t) * (t * (t * static_cast<T>(6) - static_cast<T>(15)) + static_cast<T>(10));
	}
}
}

#line 23 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\noise.hpp"









#line 33 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\noise.hpp"

namespace glm
{
	
	

	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] T perlin(
		vec<L, T, Q> const& p);

	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] T perlin(
		vec<L, T, Q> const& p,
		vec<L, T, Q> const& rep);

	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] T simplex(
		vec<L, T, Q> const& p);

	
}

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\noise.inl"







namespace glm{
namespace detail
{
	template<typename T, qualifier Q>
	inline vec<4, T, Q> grad4(T const& j, vec<4, T, Q> const& ip)
	{
		vec<3, T, Q> pXYZ = floor(fract(vec<3, T, Q>(j) * vec<3, T, Q>(ip)) * T(7)) * ip[2] - T(1);
		T pW = static_cast<T>(1.5) - dot(abs(pXYZ), vec<3, T, Q>(1));
		vec<4, T, Q> s = vec<4, T, Q>(lessThan(vec<4, T, Q>(pXYZ, pW), vec<4, T, Q>(0.0)));
		pXYZ = pXYZ + (vec<3, T, Q>(s) * T(2) - T(1)) * s.w;
		return vec<4, T, Q>(pXYZ, pW);
	}
}

	
	template<typename T, qualifier Q>
	inline T perlin(vec<2, T, Q> const& Position)
	{
		vec<4, T, Q> Pi = glm::floor(vec<4, T, Q>(Position.x, Position.y, Position.x, Position.y)) + vec<4, T, Q>(0.0, 0.0, 1.0, 1.0);
		vec<4, T, Q> Pf = glm::fract(vec<4, T, Q>(Position.x, Position.y, Position.x, Position.y)) - vec<4, T, Q>(0.0, 0.0, 1.0, 1.0);
		Pi = mod(Pi, vec<4, T, Q>(289)); 
		vec<4, T, Q> ix(Pi.x, Pi.z, Pi.x, Pi.z);
		vec<4, T, Q> iy(Pi.y, Pi.y, Pi.w, Pi.w);
		vec<4, T, Q> fx(Pf.x, Pf.z, Pf.x, Pf.z);
		vec<4, T, Q> fy(Pf.y, Pf.y, Pf.w, Pf.w);

		vec<4, T, Q> i = detail::permute(detail::permute(ix) + iy);

		vec<4, T, Q> gx = static_cast<T>(2) * glm::fract(i / T(41)) - T(1);
		vec<4, T, Q> gy = glm::abs(gx) - T(0.5);
		vec<4, T, Q> tx = glm::floor(gx + T(0.5));
		gx = gx - tx;

		vec<2, T, Q> g00(gx.x, gy.x);
		vec<2, T, Q> g10(gx.y, gy.y);
		vec<2, T, Q> g01(gx.z, gy.z);
		vec<2, T, Q> g11(gx.w, gy.w);

		vec<4, T, Q> norm = detail::taylorInvSqrt(vec<4, T, Q>(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));
		g00 *= norm.x;
		g01 *= norm.y;
		g10 *= norm.z;
		g11 *= norm.w;

		T n00 = dot(g00, vec<2, T, Q>(fx.x, fy.x));
		T n10 = dot(g10, vec<2, T, Q>(fx.y, fy.y));
		T n01 = dot(g01, vec<2, T, Q>(fx.z, fy.z));
		T n11 = dot(g11, vec<2, T, Q>(fx.w, fy.w));

		vec<2, T, Q> fade_xy = detail::fade(vec<2, T, Q>(Pf.x, Pf.y));
		vec<2, T, Q> n_x = mix(vec<2, T, Q>(n00, n01), vec<2, T, Q>(n10, n11), fade_xy.x);
		T n_xy = mix(n_x.x, n_x.y, fade_xy.y);
		return T(2.3) * n_xy;
	}

	
	template<typename T, qualifier Q>
	inline T perlin(vec<3, T, Q> const& Position)
	{
		vec<3, T, Q> Pi0 = floor(Position); 
		vec<3, T, Q> Pi1 = Pi0 + T(1); 
		Pi0 = detail::mod289(Pi0);
		Pi1 = detail::mod289(Pi1);
		vec<3, T, Q> Pf0 = fract(Position); 
		vec<3, T, Q> Pf1 = Pf0 - T(1); 
		vec<4, T, Q> ix(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
		vec<4, T, Q> iy = vec<4, T, Q>(vec<2, T, Q>(Pi0.y), vec<2, T, Q>(Pi1.y));
		vec<4, T, Q> iz0(Pi0.z);
		vec<4, T, Q> iz1(Pi1.z);

		vec<4, T, Q> ixy = detail::permute(detail::permute(ix) + iy);
		vec<4, T, Q> ixy0 = detail::permute(ixy + iz0);
		vec<4, T, Q> ixy1 = detail::permute(ixy + iz1);

		vec<4, T, Q> gx0 = ixy0 * T(1.0 / 7.0);
		vec<4, T, Q> gy0 = fract(floor(gx0) * T(1.0 / 7.0)) - T(0.5);
		gx0 = fract(gx0);
		vec<4, T, Q> gz0 = vec<4, T, Q>(0.5) - abs(gx0) - abs(gy0);
		vec<4, T, Q> sz0 = step(gz0, vec<4, T, Q>(0.0));
		gx0 -= sz0 * (step(T(0), gx0) - T(0.5));
		gy0 -= sz0 * (step(T(0), gy0) - T(0.5));

		vec<4, T, Q> gx1 = ixy1 * T(1.0 / 7.0);
		vec<4, T, Q> gy1 = fract(floor(gx1) * T(1.0 / 7.0)) - T(0.5);
		gx1 = fract(gx1);
		vec<4, T, Q> gz1 = vec<4, T, Q>(0.5) - abs(gx1) - abs(gy1);
		vec<4, T, Q> sz1 = step(gz1, vec<4, T, Q>(0.0));
		gx1 -= sz1 * (step(T(0), gx1) - T(0.5));
		gy1 -= sz1 * (step(T(0), gy1) - T(0.5));

		vec<3, T, Q> g000(gx0.x, gy0.x, gz0.x);
		vec<3, T, Q> g100(gx0.y, gy0.y, gz0.y);
		vec<3, T, Q> g010(gx0.z, gy0.z, gz0.z);
		vec<3, T, Q> g110(gx0.w, gy0.w, gz0.w);
		vec<3, T, Q> g001(gx1.x, gy1.x, gz1.x);
		vec<3, T, Q> g101(gx1.y, gy1.y, gz1.y);
		vec<3, T, Q> g011(gx1.z, gy1.z, gz1.z);
		vec<3, T, Q> g111(gx1.w, gy1.w, gz1.w);

		vec<4, T, Q> norm0 = detail::taylorInvSqrt(vec<4, T, Q>(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
		g000 *= norm0.x;
		g010 *= norm0.y;
		g100 *= norm0.z;
		g110 *= norm0.w;
		vec<4, T, Q> norm1 = detail::taylorInvSqrt(vec<4, T, Q>(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
		g001 *= norm1.x;
		g011 *= norm1.y;
		g101 *= norm1.z;
		g111 *= norm1.w;

		T n000 = dot(g000, Pf0);
		T n100 = dot(g100, vec<3, T, Q>(Pf1.x, Pf0.y, Pf0.z));
		T n010 = dot(g010, vec<3, T, Q>(Pf0.x, Pf1.y, Pf0.z));
		T n110 = dot(g110, vec<3, T, Q>(Pf1.x, Pf1.y, Pf0.z));
		T n001 = dot(g001, vec<3, T, Q>(Pf0.x, Pf0.y, Pf1.z));
		T n101 = dot(g101, vec<3, T, Q>(Pf1.x, Pf0.y, Pf1.z));
		T n011 = dot(g011, vec<3, T, Q>(Pf0.x, Pf1.y, Pf1.z));
		T n111 = dot(g111, Pf1);

		vec<3, T, Q> fade_xyz = detail::fade(Pf0);
		vec<4, T, Q> n_z = mix(vec<4, T, Q>(n000, n100, n010, n110), vec<4, T, Q>(n001, n101, n011, n111), fade_xyz.z);
		vec<2, T, Q> n_yz = mix(vec<2, T, Q>(n_z.x, n_z.y), vec<2, T, Q>(n_z.z, n_z.w), fade_xyz.y);
		T n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
		return T(2.2) * n_xyz;
	}
	









































































	
	template<typename T, qualifier Q>
	inline T perlin(vec<4, T, Q> const& Position)
	{
		vec<4, T, Q> Pi0 = floor(Position);	
		vec<4, T, Q> Pi1 = Pi0 + T(1);		
		Pi0 = mod(Pi0, vec<4, T, Q>(289));
		Pi1 = mod(Pi1, vec<4, T, Q>(289));
		vec<4, T, Q> Pf0 = fract(Position);	
		vec<4, T, Q> Pf1 = Pf0 - T(1);		
		vec<4, T, Q> ix(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
		vec<4, T, Q> iy(Pi0.y, Pi0.y, Pi1.y, Pi1.y);
		vec<4, T, Q> iz0(Pi0.z);
		vec<4, T, Q> iz1(Pi1.z);
		vec<4, T, Q> iw0(Pi0.w);
		vec<4, T, Q> iw1(Pi1.w);

		vec<4, T, Q> ixy = detail::permute(detail::permute(ix) + iy);
		vec<4, T, Q> ixy0 = detail::permute(ixy + iz0);
		vec<4, T, Q> ixy1 = detail::permute(ixy + iz1);
		vec<4, T, Q> ixy00 = detail::permute(ixy0 + iw0);
		vec<4, T, Q> ixy01 = detail::permute(ixy0 + iw1);
		vec<4, T, Q> ixy10 = detail::permute(ixy1 + iw0);
		vec<4, T, Q> ixy11 = detail::permute(ixy1 + iw1);

		vec<4, T, Q> gx00 = ixy00 / T(7);
		vec<4, T, Q> gy00 = floor(gx00) / T(7);
		vec<4, T, Q> gz00 = floor(gy00) / T(6);
		gx00 = fract(gx00) - T(0.5);
		gy00 = fract(gy00) - T(0.5);
		gz00 = fract(gz00) - T(0.5);
		vec<4, T, Q> gw00 = vec<4, T, Q>(0.75) - abs(gx00) - abs(gy00) - abs(gz00);
		vec<4, T, Q> sw00 = step(gw00, vec<4, T, Q>(0.0));
		gx00 -= sw00 * (step(T(0), gx00) - T(0.5));
		gy00 -= sw00 * (step(T(0), gy00) - T(0.5));

		vec<4, T, Q> gx01 = ixy01 / T(7);
		vec<4, T, Q> gy01 = floor(gx01) / T(7);
		vec<4, T, Q> gz01 = floor(gy01) / T(6);
		gx01 = fract(gx01) - T(0.5);
		gy01 = fract(gy01) - T(0.5);
		gz01 = fract(gz01) - T(0.5);
		vec<4, T, Q> gw01 = vec<4, T, Q>(0.75) - abs(gx01) - abs(gy01) - abs(gz01);
		vec<4, T, Q> sw01 = step(gw01, vec<4, T, Q>(0.0));
		gx01 -= sw01 * (step(T(0), gx01) - T(0.5));
		gy01 -= sw01 * (step(T(0), gy01) - T(0.5));

		vec<4, T, Q> gx10 = ixy10 / T(7);
		vec<4, T, Q> gy10 = floor(gx10) / T(7);
		vec<4, T, Q> gz10 = floor(gy10) / T(6);
		gx10 = fract(gx10) - T(0.5);
		gy10 = fract(gy10) - T(0.5);
		gz10 = fract(gz10) - T(0.5);
		vec<4, T, Q> gw10 = vec<4, T, Q>(0.75) - abs(gx10) - abs(gy10) - abs(gz10);
		vec<4, T, Q> sw10 = step(gw10, vec<4, T, Q>(0));
		gx10 -= sw10 * (step(T(0), gx10) - T(0.5));
		gy10 -= sw10 * (step(T(0), gy10) - T(0.5));

		vec<4, T, Q> gx11 = ixy11 / T(7);
		vec<4, T, Q> gy11 = floor(gx11) / T(7);
		vec<4, T, Q> gz11 = floor(gy11) / T(6);
		gx11 = fract(gx11) - T(0.5);
		gy11 = fract(gy11) - T(0.5);
		gz11 = fract(gz11) - T(0.5);
		vec<4, T, Q> gw11 = vec<4, T, Q>(0.75) - abs(gx11) - abs(gy11) - abs(gz11);
		vec<4, T, Q> sw11 = step(gw11, vec<4, T, Q>(0.0));
		gx11 -= sw11 * (step(T(0), gx11) - T(0.5));
		gy11 -= sw11 * (step(T(0), gy11) - T(0.5));

		vec<4, T, Q> g0000(gx00.x, gy00.x, gz00.x, gw00.x);
		vec<4, T, Q> g1000(gx00.y, gy00.y, gz00.y, gw00.y);
		vec<4, T, Q> g0100(gx00.z, gy00.z, gz00.z, gw00.z);
		vec<4, T, Q> g1100(gx00.w, gy00.w, gz00.w, gw00.w);
		vec<4, T, Q> g0010(gx10.x, gy10.x, gz10.x, gw10.x);
		vec<4, T, Q> g1010(gx10.y, gy10.y, gz10.y, gw10.y);
		vec<4, T, Q> g0110(gx10.z, gy10.z, gz10.z, gw10.z);
		vec<4, T, Q> g1110(gx10.w, gy10.w, gz10.w, gw10.w);
		vec<4, T, Q> g0001(gx01.x, gy01.x, gz01.x, gw01.x);
		vec<4, T, Q> g1001(gx01.y, gy01.y, gz01.y, gw01.y);
		vec<4, T, Q> g0101(gx01.z, gy01.z, gz01.z, gw01.z);
		vec<4, T, Q> g1101(gx01.w, gy01.w, gz01.w, gw01.w);
		vec<4, T, Q> g0011(gx11.x, gy11.x, gz11.x, gw11.x);
		vec<4, T, Q> g1011(gx11.y, gy11.y, gz11.y, gw11.y);
		vec<4, T, Q> g0111(gx11.z, gy11.z, gz11.z, gw11.z);
		vec<4, T, Q> g1111(gx11.w, gy11.w, gz11.w, gw11.w);

		vec<4, T, Q> norm00 = detail::taylorInvSqrt(vec<4, T, Q>(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));
		g0000 *= norm00.x;
		g0100 *= norm00.y;
		g1000 *= norm00.z;
		g1100 *= norm00.w;

		vec<4, T, Q> norm01 = detail::taylorInvSqrt(vec<4, T, Q>(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));
		g0001 *= norm01.x;
		g0101 *= norm01.y;
		g1001 *= norm01.z;
		g1101 *= norm01.w;

		vec<4, T, Q> norm10 = detail::taylorInvSqrt(vec<4, T, Q>(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));
		g0010 *= norm10.x;
		g0110 *= norm10.y;
		g1010 *= norm10.z;
		g1110 *= norm10.w;

		vec<4, T, Q> norm11 = detail::taylorInvSqrt(vec<4, T, Q>(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));
		g0011 *= norm11.x;
		g0111 *= norm11.y;
		g1011 *= norm11.z;
		g1111 *= norm11.w;

		T n0000 = dot(g0000, Pf0);
		T n1000 = dot(g1000, vec<4, T, Q>(Pf1.x, Pf0.y, Pf0.z, Pf0.w));
		T n0100 = dot(g0100, vec<4, T, Q>(Pf0.x, Pf1.y, Pf0.z, Pf0.w));
		T n1100 = dot(g1100, vec<4, T, Q>(Pf1.x, Pf1.y, Pf0.z, Pf0.w));
		T n0010 = dot(g0010, vec<4, T, Q>(Pf0.x, Pf0.y, Pf1.z, Pf0.w));
		T n1010 = dot(g1010, vec<4, T, Q>(Pf1.x, Pf0.y, Pf1.z, Pf0.w));
		T n0110 = dot(g0110, vec<4, T, Q>(Pf0.x, Pf1.y, Pf1.z, Pf0.w));
		T n1110 = dot(g1110, vec<4, T, Q>(Pf1.x, Pf1.y, Pf1.z, Pf0.w));
		T n0001 = dot(g0001, vec<4, T, Q>(Pf0.x, Pf0.y, Pf0.z, Pf1.w));
		T n1001 = dot(g1001, vec<4, T, Q>(Pf1.x, Pf0.y, Pf0.z, Pf1.w));
		T n0101 = dot(g0101, vec<4, T, Q>(Pf0.x, Pf1.y, Pf0.z, Pf1.w));
		T n1101 = dot(g1101, vec<4, T, Q>(Pf1.x, Pf1.y, Pf0.z, Pf1.w));
		T n0011 = dot(g0011, vec<4, T, Q>(Pf0.x, Pf0.y, Pf1.z, Pf1.w));
		T n1011 = dot(g1011, vec<4, T, Q>(Pf1.x, Pf0.y, Pf1.z, Pf1.w));
		T n0111 = dot(g0111, vec<4, T, Q>(Pf0.x, Pf1.y, Pf1.z, Pf1.w));
		T n1111 = dot(g1111, Pf1);

		vec<4, T, Q> fade_xyzw = detail::fade(Pf0);
		vec<4, T, Q> n_0w = mix(vec<4, T, Q>(n0000, n1000, n0100, n1100), vec<4, T, Q>(n0001, n1001, n0101, n1101), fade_xyzw.w);
		vec<4, T, Q> n_1w = mix(vec<4, T, Q>(n0010, n1010, n0110, n1110), vec<4, T, Q>(n0011, n1011, n0111, n1111), fade_xyzw.w);
		vec<4, T, Q> n_zw = mix(n_0w, n_1w, fade_xyzw.z);
		vec<2, T, Q> n_yzw = mix(vec<2, T, Q>(n_zw.x, n_zw.y), vec<2, T, Q>(n_zw.z, n_zw.w), fade_xyzw.y);
		T n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);
		return T(2.2) * n_xyzw;
	}

	
	template<typename T, qualifier Q>
	inline T perlin(vec<2, T, Q> const& Position, vec<2, T, Q> const& rep)
	{
		vec<4, T, Q> Pi = floor(vec<4, T, Q>(Position.x, Position.y, Position.x, Position.y)) + vec<4, T, Q>(0.0, 0.0, 1.0, 1.0);
		vec<4, T, Q> Pf = fract(vec<4, T, Q>(Position.x, Position.y, Position.x, Position.y)) - vec<4, T, Q>(0.0, 0.0, 1.0, 1.0);
		Pi = mod(Pi, vec<4, T, Q>(rep.x, rep.y, rep.x, rep.y)); 
		Pi = mod(Pi, vec<4, T, Q>(289)); 
		vec<4, T, Q> ix(Pi.x, Pi.z, Pi.x, Pi.z);
		vec<4, T, Q> iy(Pi.y, Pi.y, Pi.w, Pi.w);
		vec<4, T, Q> fx(Pf.x, Pf.z, Pf.x, Pf.z);
		vec<4, T, Q> fy(Pf.y, Pf.y, Pf.w, Pf.w);

		vec<4, T, Q> i = detail::permute(detail::permute(ix) + iy);

		vec<4, T, Q> gx = static_cast<T>(2) * fract(i / T(41)) - T(1);
		vec<4, T, Q> gy = abs(gx) - T(0.5);
		vec<4, T, Q> tx = floor(gx + T(0.5));
		gx = gx - tx;

		vec<2, T, Q> g00(gx.x, gy.x);
		vec<2, T, Q> g10(gx.y, gy.y);
		vec<2, T, Q> g01(gx.z, gy.z);
		vec<2, T, Q> g11(gx.w, gy.w);

		vec<4, T, Q> norm = detail::taylorInvSqrt(vec<4, T, Q>(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));
		g00 *= norm.x;
		g01 *= norm.y;
		g10 *= norm.z;
		g11 *= norm.w;

		T n00 = dot(g00, vec<2, T, Q>(fx.x, fy.x));
		T n10 = dot(g10, vec<2, T, Q>(fx.y, fy.y));
		T n01 = dot(g01, vec<2, T, Q>(fx.z, fy.z));
		T n11 = dot(g11, vec<2, T, Q>(fx.w, fy.w));

		vec<2, T, Q> fade_xy = detail::fade(vec<2, T, Q>(Pf.x, Pf.y));
		vec<2, T, Q> n_x = mix(vec<2, T, Q>(n00, n01), vec<2, T, Q>(n10, n11), fade_xy.x);
		T n_xy = mix(n_x.x, n_x.y, fade_xy.y);
		return T(2.3) * n_xy;
	}

	
	template<typename T, qualifier Q>
	inline T perlin(vec<3, T, Q> const& Position, vec<3, T, Q> const& rep)
	{
		vec<3, T, Q> Pi0 = mod(floor(Position), rep); 
		vec<3, T, Q> Pi1 = mod(Pi0 + vec<3, T, Q>(T(1)), rep); 
		Pi0 = mod(Pi0, vec<3, T, Q>(289));
		Pi1 = mod(Pi1, vec<3, T, Q>(289));
		vec<3, T, Q> Pf0 = fract(Position); 
		vec<3, T, Q> Pf1 = Pf0 - vec<3, T, Q>(T(1)); 
		vec<4, T, Q> ix = vec<4, T, Q>(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
		vec<4, T, Q> iy = vec<4, T, Q>(Pi0.y, Pi0.y, Pi1.y, Pi1.y);
		vec<4, T, Q> iz0(Pi0.z);
		vec<4, T, Q> iz1(Pi1.z);

		vec<4, T, Q> ixy = detail::permute(detail::permute(ix) + iy);
		vec<4, T, Q> ixy0 = detail::permute(ixy + iz0);
		vec<4, T, Q> ixy1 = detail::permute(ixy + iz1);

		vec<4, T, Q> gx0 = ixy0 / T(7);
		vec<4, T, Q> gy0 = fract(floor(gx0) / T(7)) - T(0.5);
		gx0 = fract(gx0);
		vec<4, T, Q> gz0 = vec<4, T, Q>(0.5) - abs(gx0) - abs(gy0);
		vec<4, T, Q> sz0 = step(gz0, vec<4, T, Q>(0));
		gx0 -= sz0 * (step(T(0), gx0) - T(0.5));
		gy0 -= sz0 * (step(T(0), gy0) - T(0.5));

		vec<4, T, Q> gx1 = ixy1 / T(7);
		vec<4, T, Q> gy1 = fract(floor(gx1) / T(7)) - T(0.5);
		gx1 = fract(gx1);
		vec<4, T, Q> gz1 = vec<4, T, Q>(0.5) - abs(gx1) - abs(gy1);
		vec<4, T, Q> sz1 = step(gz1, vec<4, T, Q>(T(0)));
		gx1 -= sz1 * (step(T(0), gx1) - T(0.5));
		gy1 -= sz1 * (step(T(0), gy1) - T(0.5));

		vec<3, T, Q> g000 = vec<3, T, Q>(gx0.x, gy0.x, gz0.x);
		vec<3, T, Q> g100 = vec<3, T, Q>(gx0.y, gy0.y, gz0.y);
		vec<3, T, Q> g010 = vec<3, T, Q>(gx0.z, gy0.z, gz0.z);
		vec<3, T, Q> g110 = vec<3, T, Q>(gx0.w, gy0.w, gz0.w);
		vec<3, T, Q> g001 = vec<3, T, Q>(gx1.x, gy1.x, gz1.x);
		vec<3, T, Q> g101 = vec<3, T, Q>(gx1.y, gy1.y, gz1.y);
		vec<3, T, Q> g011 = vec<3, T, Q>(gx1.z, gy1.z, gz1.z);
		vec<3, T, Q> g111 = vec<3, T, Q>(gx1.w, gy1.w, gz1.w);

		vec<4, T, Q> norm0 = detail::taylorInvSqrt(vec<4, T, Q>(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
		g000 *= norm0.x;
		g010 *= norm0.y;
		g100 *= norm0.z;
		g110 *= norm0.w;
		vec<4, T, Q> norm1 = detail::taylorInvSqrt(vec<4, T, Q>(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
		g001 *= norm1.x;
		g011 *= norm1.y;
		g101 *= norm1.z;
		g111 *= norm1.w;

		T n000 = dot(g000, Pf0);
		T n100 = dot(g100, vec<3, T, Q>(Pf1.x, Pf0.y, Pf0.z));
		T n010 = dot(g010, vec<3, T, Q>(Pf0.x, Pf1.y, Pf0.z));
		T n110 = dot(g110, vec<3, T, Q>(Pf1.x, Pf1.y, Pf0.z));
		T n001 = dot(g001, vec<3, T, Q>(Pf0.x, Pf0.y, Pf1.z));
		T n101 = dot(g101, vec<3, T, Q>(Pf1.x, Pf0.y, Pf1.z));
		T n011 = dot(g011, vec<3, T, Q>(Pf0.x, Pf1.y, Pf1.z));
		T n111 = dot(g111, Pf1);

		vec<3, T, Q> fade_xyz = detail::fade(Pf0);
		vec<4, T, Q> n_z = mix(vec<4, T, Q>(n000, n100, n010, n110), vec<4, T, Q>(n001, n101, n011, n111), fade_xyz.z);
		vec<2, T, Q> n_yz = mix(vec<2, T, Q>(n_z.x, n_z.y), vec<2, T, Q>(n_z.z, n_z.w), fade_xyz.y);
		T n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
		return T(2.2) * n_xyz;
	}

	
	template<typename T, qualifier Q>
	inline T perlin(vec<4, T, Q> const& Position, vec<4, T, Q> const& rep)
	{
		vec<4, T, Q> Pi0 = mod(floor(Position), rep); 
		vec<4, T, Q> Pi1 = mod(Pi0 + T(1), rep); 
		vec<4, T, Q> Pf0 = fract(Position); 
		vec<4, T, Q> Pf1 = Pf0 - T(1); 
		vec<4, T, Q> ix = vec<4, T, Q>(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
		vec<4, T, Q> iy = vec<4, T, Q>(Pi0.y, Pi0.y, Pi1.y, Pi1.y);
		vec<4, T, Q> iz0(Pi0.z);
		vec<4, T, Q> iz1(Pi1.z);
		vec<4, T, Q> iw0(Pi0.w);
		vec<4, T, Q> iw1(Pi1.w);

		vec<4, T, Q> ixy = detail::permute(detail::permute(ix) + iy);
		vec<4, T, Q> ixy0 = detail::permute(ixy + iz0);
		vec<4, T, Q> ixy1 = detail::permute(ixy + iz1);
		vec<4, T, Q> ixy00 = detail::permute(ixy0 + iw0);
		vec<4, T, Q> ixy01 = detail::permute(ixy0 + iw1);
		vec<4, T, Q> ixy10 = detail::permute(ixy1 + iw0);
		vec<4, T, Q> ixy11 = detail::permute(ixy1 + iw1);

		vec<4, T, Q> gx00 = ixy00 / T(7);
		vec<4, T, Q> gy00 = floor(gx00) / T(7);
		vec<4, T, Q> gz00 = floor(gy00) / T(6);
		gx00 = fract(gx00) - T(0.5);
		gy00 = fract(gy00) - T(0.5);
		gz00 = fract(gz00) - T(0.5);
		vec<4, T, Q> gw00 = vec<4, T, Q>(0.75) - abs(gx00) - abs(gy00) - abs(gz00);
		vec<4, T, Q> sw00 = step(gw00, vec<4, T, Q>(0));
		gx00 -= sw00 * (step(T(0), gx00) - T(0.5));
		gy00 -= sw00 * (step(T(0), gy00) - T(0.5));

		vec<4, T, Q> gx01 = ixy01 / T(7);
		vec<4, T, Q> gy01 = floor(gx01) / T(7);
		vec<4, T, Q> gz01 = floor(gy01) / T(6);
		gx01 = fract(gx01) - T(0.5);
		gy01 = fract(gy01) - T(0.5);
		gz01 = fract(gz01) - T(0.5);
		vec<4, T, Q> gw01 = vec<4, T, Q>(0.75) - abs(gx01) - abs(gy01) - abs(gz01);
		vec<4, T, Q> sw01 = step(gw01, vec<4, T, Q>(0.0));
		gx01 -= sw01 * (step(T(0), gx01) - T(0.5));
		gy01 -= sw01 * (step(T(0), gy01) - T(0.5));

		vec<4, T, Q> gx10 = ixy10 / T(7);
		vec<4, T, Q> gy10 = floor(gx10) / T(7);
		vec<4, T, Q> gz10 = floor(gy10) / T(6);
		gx10 = fract(gx10) - T(0.5);
		gy10 = fract(gy10) - T(0.5);
		gz10 = fract(gz10) - T(0.5);
		vec<4, T, Q> gw10 = vec<4, T, Q>(0.75) - abs(gx10) - abs(gy10) - abs(gz10);
		vec<4, T, Q> sw10 = step(gw10, vec<4, T, Q>(0.0));
		gx10 -= sw10 * (step(T(0), gx10) - T(0.5));
		gy10 -= sw10 * (step(T(0), gy10) - T(0.5));

		vec<4, T, Q> gx11 = ixy11 / T(7);
		vec<4, T, Q> gy11 = floor(gx11) / T(7);
		vec<4, T, Q> gz11 = floor(gy11) / T(6);
		gx11 = fract(gx11) - T(0.5);
		gy11 = fract(gy11) - T(0.5);
		gz11 = fract(gz11) - T(0.5);
		vec<4, T, Q> gw11 = vec<4, T, Q>(0.75) - abs(gx11) - abs(gy11) - abs(gz11);
		vec<4, T, Q> sw11 = step(gw11, vec<4, T, Q>(T(0)));
		gx11 -= sw11 * (step(T(0), gx11) - T(0.5));
		gy11 -= sw11 * (step(T(0), gy11) - T(0.5));

		vec<4, T, Q> g0000(gx00.x, gy00.x, gz00.x, gw00.x);
		vec<4, T, Q> g1000(gx00.y, gy00.y, gz00.y, gw00.y);
		vec<4, T, Q> g0100(gx00.z, gy00.z, gz00.z, gw00.z);
		vec<4, T, Q> g1100(gx00.w, gy00.w, gz00.w, gw00.w);
		vec<4, T, Q> g0010(gx10.x, gy10.x, gz10.x, gw10.x);
		vec<4, T, Q> g1010(gx10.y, gy10.y, gz10.y, gw10.y);
		vec<4, T, Q> g0110(gx10.z, gy10.z, gz10.z, gw10.z);
		vec<4, T, Q> g1110(gx10.w, gy10.w, gz10.w, gw10.w);
		vec<4, T, Q> g0001(gx01.x, gy01.x, gz01.x, gw01.x);
		vec<4, T, Q> g1001(gx01.y, gy01.y, gz01.y, gw01.y);
		vec<4, T, Q> g0101(gx01.z, gy01.z, gz01.z, gw01.z);
		vec<4, T, Q> g1101(gx01.w, gy01.w, gz01.w, gw01.w);
		vec<4, T, Q> g0011(gx11.x, gy11.x, gz11.x, gw11.x);
		vec<4, T, Q> g1011(gx11.y, gy11.y, gz11.y, gw11.y);
		vec<4, T, Q> g0111(gx11.z, gy11.z, gz11.z, gw11.z);
		vec<4, T, Q> g1111(gx11.w, gy11.w, gz11.w, gw11.w);

		vec<4, T, Q> norm00 = detail::taylorInvSqrt(vec<4, T, Q>(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));
		g0000 *= norm00.x;
		g0100 *= norm00.y;
		g1000 *= norm00.z;
		g1100 *= norm00.w;

		vec<4, T, Q> norm01 = detail::taylorInvSqrt(vec<4, T, Q>(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));
		g0001 *= norm01.x;
		g0101 *= norm01.y;
		g1001 *= norm01.z;
		g1101 *= norm01.w;

		vec<4, T, Q> norm10 = detail::taylorInvSqrt(vec<4, T, Q>(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));
		g0010 *= norm10.x;
		g0110 *= norm10.y;
		g1010 *= norm10.z;
		g1110 *= norm10.w;

		vec<4, T, Q> norm11 = detail::taylorInvSqrt(vec<4, T, Q>(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));
		g0011 *= norm11.x;
		g0111 *= norm11.y;
		g1011 *= norm11.z;
		g1111 *= norm11.w;

		T n0000 = dot(g0000, Pf0);
		T n1000 = dot(g1000, vec<4, T, Q>(Pf1.x, Pf0.y, Pf0.z, Pf0.w));
		T n0100 = dot(g0100, vec<4, T, Q>(Pf0.x, Pf1.y, Pf0.z, Pf0.w));
		T n1100 = dot(g1100, vec<4, T, Q>(Pf1.x, Pf1.y, Pf0.z, Pf0.w));
		T n0010 = dot(g0010, vec<4, T, Q>(Pf0.x, Pf0.y, Pf1.z, Pf0.w));
		T n1010 = dot(g1010, vec<4, T, Q>(Pf1.x, Pf0.y, Pf1.z, Pf0.w));
		T n0110 = dot(g0110, vec<4, T, Q>(Pf0.x, Pf1.y, Pf1.z, Pf0.w));
		T n1110 = dot(g1110, vec<4, T, Q>(Pf1.x, Pf1.y, Pf1.z, Pf0.w));
		T n0001 = dot(g0001, vec<4, T, Q>(Pf0.x, Pf0.y, Pf0.z, Pf1.w));
		T n1001 = dot(g1001, vec<4, T, Q>(Pf1.x, Pf0.y, Pf0.z, Pf1.w));
		T n0101 = dot(g0101, vec<4, T, Q>(Pf0.x, Pf1.y, Pf0.z, Pf1.w));
		T n1101 = dot(g1101, vec<4, T, Q>(Pf1.x, Pf1.y, Pf0.z, Pf1.w));
		T n0011 = dot(g0011, vec<4, T, Q>(Pf0.x, Pf0.y, Pf1.z, Pf1.w));
		T n1011 = dot(g1011, vec<4, T, Q>(Pf1.x, Pf0.y, Pf1.z, Pf1.w));
		T n0111 = dot(g0111, vec<4, T, Q>(Pf0.x, Pf1.y, Pf1.z, Pf1.w));
		T n1111 = dot(g1111, Pf1);

		vec<4, T, Q> fade_xyzw = detail::fade(Pf0);
		vec<4, T, Q> n_0w = mix(vec<4, T, Q>(n0000, n1000, n0100, n1100), vec<4, T, Q>(n0001, n1001, n0101, n1101), fade_xyzw.w);
		vec<4, T, Q> n_1w = mix(vec<4, T, Q>(n0010, n1010, n0110, n1110), vec<4, T, Q>(n0011, n1011, n0111, n1111), fade_xyzw.w);
		vec<4, T, Q> n_zw = mix(n_0w, n_1w, fade_xyzw.z);
		vec<2, T, Q> n_yzw = mix(vec<2, T, Q>(n_zw.x, n_zw.y), vec<2, T, Q>(n_zw.z, n_zw.w), fade_xyzw.y);
		T n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);
		return T(2.2) * n_xyzw;
	}

	template<typename T, qualifier Q>
	inline T simplex(glm::vec<2, T, Q> const& v)
	{
		vec<4, T, Q> const C = vec<4, T, Q>(
			T( 0.211324865405187),  
			T( 0.366025403784439),  
			T(-0.577350269189626),	
			T( 0.024390243902439)); 

		
		vec<2, T, Q> i  = floor(v + dot(v, vec<2, T, Q>(C[1])));
		vec<2, T, Q> x0 = v -   i + dot(i, vec<2, T, Q>(C[0]));

		
		
		
		vec<2, T, Q> i1 = (x0.x > x0.y) ? vec<2, T, Q>(1, 0) : vec<2, T, Q>(0, 1);
		
		
		
		vec<4, T, Q> x12 = vec<4, T, Q>(x0.x, x0.y, x0.x, x0.y) + vec<4, T, Q>(C.x, C.x, C.z, C.z);
		x12 = vec<4, T, Q>(vec<2, T, Q>(x12) - i1, x12.z, x12.w);

		
		i = mod(i, vec<2, T, Q>(289)); 
		vec<3, T, Q> p = detail::permute(
			detail::permute(i.y + vec<3, T, Q>(T(0), i1.y, T(1)))
			+ i.x + vec<3, T, Q>(T(0), i1.x, T(1)));

		vec<3, T, Q> m = max(vec<3, T, Q>(0.5) - vec<3, T, Q>(
			dot(x0, x0),
			dot(vec<2, T, Q>(x12.x, x12.y), vec<2, T, Q>(x12.x, x12.y)),
			dot(vec<2, T, Q>(x12.z, x12.w), vec<2, T, Q>(x12.z, x12.w))), vec<3, T, Q>(0));
		m = m * m ;
		m = m * m ;

		
		

		vec<3, T, Q> x = static_cast<T>(2) * fract(p * C.w) - T(1);
		vec<3, T, Q> h = abs(x) - T(0.5);
		vec<3, T, Q> ox = floor(x + T(0.5));
		vec<3, T, Q> a0 = x - ox;

		
		
		m *= static_cast<T>(1.79284291400159) - T(0.85373472095314) * (a0 * a0 + h * h);

		
		vec<3, T, Q> g;
		g.x  = a0.x  * x0.x  + h.x  * x0.y;
		
		g.y = a0.y * x12.x + h.y * x12.y;
		g.z = a0.z * x12.z + h.z * x12.w;
		return T(130) * dot(m, g);
	}

	template<typename T, qualifier Q>
	inline T simplex(vec<3, T, Q> const& v)
	{
		vec<2, T, Q> const C(1.0 / 6.0, 1.0 / 3.0);
		vec<4, T, Q> const D(0.0, 0.5, 1.0, 2.0);

		
		vec<3, T, Q> i(floor(v + dot(v, vec<3, T, Q>(C.y))));
		vec<3, T, Q> x0(v - i + dot(i, vec<3, T, Q>(C.x)));

		
		vec<3, T, Q> g(step(vec<3, T, Q>(x0.y, x0.z, x0.x), x0));
		vec<3, T, Q> l(T(1) - g);
		vec<3, T, Q> i1(min(g, vec<3, T, Q>(l.z, l.x, l.y)));
		vec<3, T, Q> i2(max(g, vec<3, T, Q>(l.z, l.x, l.y)));

		
		
		
		
		vec<3, T, Q> x1(x0 - i1 + C.x);
		vec<3, T, Q> x2(x0 - i2 + C.y); 
		vec<3, T, Q> x3(x0 - D.y);      

		
		i = detail::mod289(i);
		vec<4, T, Q> p(detail::permute(detail::permute(detail::permute(
			i.z + vec<4, T, Q>(T(0), i1.z, i2.z, T(1))) +
			i.y + vec<4, T, Q>(T(0), i1.y, i2.y, T(1))) +
			i.x + vec<4, T, Q>(T(0), i1.x, i2.x, T(1))));

		
		
		T n_ = static_cast<T>(0.142857142857); 
		vec<3, T, Q> ns(n_ * vec<3, T, Q>(D.w, D.y, D.z) - vec<3, T, Q>(D.x, D.z, D.x));

		vec<4, T, Q> j(p - T(49) * floor(p * ns.z * ns.z));  

		vec<4, T, Q> x_(floor(j * ns.z));
		vec<4, T, Q> y_(floor(j - T(7) * x_));    

		vec<4, T, Q> x(x_ * ns.x + ns.y);
		vec<4, T, Q> y(y_ * ns.x + ns.y);
		vec<4, T, Q> h(T(1) - abs(x) - abs(y));

		vec<4, T, Q> b0(x.x, x.y, y.x, y.y);
		vec<4, T, Q> b1(x.z, x.w, y.z, y.w);

		
		
		vec<4, T, Q> s0(floor(b0) * T(2) + T(1));
		vec<4, T, Q> s1(floor(b1) * T(2) + T(1));
		vec<4, T, Q> sh(-step(h, vec<4, T, Q>(0.0)));

		vec<4, T, Q> a0 = vec<4, T, Q>(b0.x, b0.z, b0.y, b0.w) + vec<4, T, Q>(s0.x, s0.z, s0.y, s0.w) * vec<4, T, Q>(sh.x, sh.x, sh.y, sh.y);
		vec<4, T, Q> a1 = vec<4, T, Q>(b1.x, b1.z, b1.y, b1.w) + vec<4, T, Q>(s1.x, s1.z, s1.y, s1.w) * vec<4, T, Q>(sh.z, sh.z, sh.w, sh.w);

		vec<3, T, Q> p0(a0.x, a0.y, h.x);
		vec<3, T, Q> p1(a0.z, a0.w, h.y);
		vec<3, T, Q> p2(a1.x, a1.y, h.z);
		vec<3, T, Q> p3(a1.z, a1.w, h.w);

		
		vec<4, T, Q> norm = detail::taylorInvSqrt(vec<4, T, Q>(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
		p0 *= norm.x;
		p1 *= norm.y;
		p2 *= norm.z;
		p3 *= norm.w;

		
		vec<4, T, Q> m = max(T(0.6) - vec<4, T, Q>(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), vec<4, T, Q>(0));
		m = m * m;
		return T(42) * dot(m * m, vec<4, T, Q>(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));
	}

	template<typename T, qualifier Q>
	inline T simplex(vec<4, T, Q> const& v)
	{
		vec<4, T, Q> const C(
			0.138196601125011,  
			0.276393202250021,  
			0.414589803375032,  
			-0.447213595499958); 

		
		T const F4 = static_cast<T>(0.309016994374947451);

		
		vec<4, T, Q> i  = floor(v + dot(v, vec<4, T, Q>(F4)));
		vec<4, T, Q> x0 = v -   i + dot(i, vec<4, T, Q>(C.x));

		

		
		vec<4, T, Q> i0;
		vec<3, T, Q> isX = step(vec<3, T, Q>(x0.y, x0.z, x0.w), vec<3, T, Q>(x0.x));
		vec<3, T, Q> isYZ = step(vec<3, T, Q>(x0.z, x0.w, x0.w), vec<3, T, Q>(x0.y, x0.y, x0.z));
		
		
		
		i0 = vec<4, T, Q>(isX.x + isX.y + isX.z, T(1) - isX);
		
		i0.y += isYZ.x + isYZ.y;
		
		i0.z += static_cast<T>(1) - isYZ.x;
		i0.w += static_cast<T>(1) - isYZ.y;
		i0.z += isYZ.z;
		i0.w += static_cast<T>(1) - isYZ.z;

		
		vec<4, T, Q> i3 = clamp(i0, T(0), T(1));
		vec<4, T, Q> i2 = clamp(i0 - T(1), T(0), T(1));
		vec<4, T, Q> i1 = clamp(i0 - T(2), T(0), T(1));

		
		
		
		
		
		vec<4, T, Q> x1 = x0 - i1 + C.x;
		vec<4, T, Q> x2 = x0 - i2 + C.y;
		vec<4, T, Q> x3 = x0 - i3 + C.z;
		vec<4, T, Q> x4 = x0 + C.w;

		
		i = mod(i, vec<4, T, Q>(289));
		T j0 = detail::permute(detail::permute(detail::permute(detail::permute(i.w) + i.z) + i.y) + i.x);
		vec<4, T, Q> j1 = detail::permute(detail::permute(detail::permute(detail::permute(
			i.w + vec<4, T, Q>(i1.w, i2.w, i3.w, T(1))) +
			i.z + vec<4, T, Q>(i1.z, i2.z, i3.z, T(1))) +
			i.y + vec<4, T, Q>(i1.y, i2.y, i3.y, T(1))) +
			i.x + vec<4, T, Q>(i1.x, i2.x, i3.x, T(1)));

		
		
		vec<4, T, Q> ip = vec<4, T, Q>(T(1) / T(294), T(1) / T(49), T(1) / T(7), T(0));

		vec<4, T, Q> p0 = detail::grad4(j0,   ip);
		vec<4, T, Q> p1 = detail::grad4(j1.x, ip);
		vec<4, T, Q> p2 = detail::grad4(j1.y, ip);
		vec<4, T, Q> p3 = detail::grad4(j1.z, ip);
		vec<4, T, Q> p4 = detail::grad4(j1.w, ip);

		
		vec<4, T, Q> norm = detail::taylorInvSqrt(vec<4, T, Q>(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
		p0 *= norm.x;
		p1 *= norm.y;
		p2 *= norm.z;
		p3 *= norm.w;
		p4 *= detail::taylorInvSqrt(dot(p4, p4));

		
		vec<3, T, Q> m0 = max(T(0.6) - vec<3, T, Q>(dot(x0, x0), dot(x1, x1), dot(x2, x2)), vec<3, T, Q>(0));
		vec<2, T, Q> m1 = max(T(0.6) - vec<2, T, Q>(dot(x3, x3), dot(x4, x4)             ), vec<2, T, Q>(0));
		m0 = m0 * m0;
		m1 = m1 * m1;
		return T(49) *
			(dot(m0 * m0, vec<3, T, Q>(dot(p0, x0), dot(p1, x1), dot(p2, x2))) +
			dot(m1 * m1, vec<2, T, Q>(dot(p3, x3), dot(p4, x4))));
	}
}
#line 62 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\noise.hpp"
#line 183 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\packing.hpp"













#pragma once







#line 23 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\packing.hpp"

namespace glm
{
	
	

	
	
	
	
	
	
	
	
	
	
	
	[[nodiscard]] uint8 packUnorm1x8(float v);

	
	
	
	
	
	
	
	
	
	
	[[nodiscard]] float unpackUnorm1x8(uint8 p);

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	[[nodiscard]] uint16 packUnorm2x8(vec2 const& v);

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	[[nodiscard]] vec2 unpackUnorm2x8(uint16 p);

	
	
	
	
	
	
	
	
	
	
	
	[[nodiscard]] uint8 packSnorm1x8(float s);

	
	
	
	
	
	
	
	
	
	
	
	[[nodiscard]] float unpackSnorm1x8(uint8 p);

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	[[nodiscard]] uint16 packSnorm2x8(vec2 const& v);

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	[[nodiscard]] vec2 unpackSnorm2x8(uint16 p);

	
	
	
	
	
	
	
	
	
	
	
	[[nodiscard]] uint16 packUnorm1x16(float v);

	
	
	
	
	
	
	
	
	
	
	
	[[nodiscard]] float unpackUnorm1x16(uint16 p);

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	[[nodiscard]] uint64 packUnorm4x16(vec4 const& v);

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	[[nodiscard]] vec4 unpackUnorm4x16(uint64 p);

	
	
	
	
	
	
	
	
	
	
	
	[[nodiscard]] uint16 packSnorm1x16(float v);

	
	
	
	
	
	
	
	
	
	
	
	[[nodiscard]] float unpackSnorm1x16(uint16 p);

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	[[nodiscard]] uint64 packSnorm4x16(vec4 const& v);

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	[[nodiscard]] vec4 unpackSnorm4x16(uint64 p);

	
	
	
	
	
	
	
	
	
	[[nodiscard]] uint16 packHalf1x16(float v);

	
	
	
	
	
	
	
	
	
	[[nodiscard]] float unpackHalf1x16(uint16 v);

	
	
	
	
	
	
	
	
	
	
	
	[[nodiscard]] uint64 packHalf4x16(vec4 const& v);

	
	
	
	
	
	
	
	
	
	
	
	[[nodiscard]] vec4 unpackHalf4x16(uint64 p);

	
	
	
	
	
	
	
	
	
	
	
	[[nodiscard]] uint32 packI3x10_1x2(ivec4 const& v);

	
	
	
	
	
	
	
	
	
	[[nodiscard]] ivec4 unpackI3x10_1x2(uint32 p);

	
	
	
	
	
	
	
	
	
	
	
	[[nodiscard]] uint32 packU3x10_1x2(uvec4 const& v);

	
	
	
	
	
	
	
	
	
	[[nodiscard]] uvec4 unpackU3x10_1x2(uint32 p);

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	[[nodiscard]] uint32 packSnorm3x10_1x2(vec4 const& v);

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	[[nodiscard]] vec4 unpackSnorm3x10_1x2(uint32 p);

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	[[nodiscard]] uint32 packUnorm3x10_1x2(vec4 const& v);

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	[[nodiscard]] vec4 unpackUnorm3x10_1x2(uint32 p);

	
	
	
	
	
	
	
	
	
	[[nodiscard]] uint32 packF2x11_1x10(vec3 const& v);

	
	
	
	
	
	
	
	
	[[nodiscard]] vec3 unpackF2x11_1x10(uint32 p);


	
	
	
	
	
	
	
	
	
	
	
	[[nodiscard]] uint32 packF3x9_E1x5(vec3 const& v);

	
	
	
	
	
	
	
	
	
	
	[[nodiscard]] vec3 unpackF3x9_E1x5(uint32 p);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<4, T, Q> packRGBM(vec<3, T, Q> const& rgb);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<3, T, Q> unpackRGBM(vec<4, T, Q> const& rgbm);

	
	
	
	
	
	
	
	
	template<length_t L, qualifier Q>
	[[nodiscard]] vec<L, uint16, Q> packHalf(vec<L, float, Q> const& v);

	
	
	
	
	
	
	
	template<length_t L, qualifier Q>
	[[nodiscard]] vec<L, float, Q> unpackHalf(vec<L, uint16, Q> const& p);

	
	
	
	
	template<typename uintType, length_t L, typename floatType, qualifier Q>
	[[nodiscard]] vec<L, uintType, Q> packUnorm(vec<L, floatType, Q> const& v);

	
	
	
	
	template<typename floatType, length_t L, typename uintType, qualifier Q>
	[[nodiscard]] vec<L, floatType, Q> unpackUnorm(vec<L, uintType, Q> const& v);

	
	
	
	
	template<typename intType, length_t L, typename floatType, qualifier Q>
	[[nodiscard]] vec<L, intType, Q> packSnorm(vec<L, floatType, Q> const& v);

	
	
	
	
	template<typename floatType, length_t L, typename intType, qualifier Q>
	[[nodiscard]] vec<L, floatType, Q> unpackSnorm(vec<L, intType, Q> const& v);

	
	
	
	
	[[nodiscard]] uint8 packUnorm2x4(vec2 const& v);

	
	
	
	
	[[nodiscard]] vec2 unpackUnorm2x4(uint8 p);

	
	
	
	
	[[nodiscard]] uint16 packUnorm4x4(vec4 const& v);

	
	
	
	
	[[nodiscard]] vec4 unpackUnorm4x4(uint16 p);

	
	
	
	
	[[nodiscard]] uint16 packUnorm1x5_1x6_1x5(vec3 const& v);

	
	
	
	
	[[nodiscard]] vec3 unpackUnorm1x5_1x6_1x5(uint16 p);

	
	
	
	
	[[nodiscard]] uint16 packUnorm3x5_1x1(vec4 const& v);

	
	
	
	
	[[nodiscard]] vec4 unpackUnorm3x5_1x1(uint16 p);

	
	
	
	
	[[nodiscard]] uint8 packUnorm2x3_1x2(vec3 const& v);

	
	
	
	
	[[nodiscard]] vec3 unpackUnorm2x3_1x2(uint8 p);



	
	
	
	
	[[nodiscard]] int16 packInt2x8(i8vec2 const& v);

	
	
	
	
	[[nodiscard]] i8vec2 unpackInt2x8(int16 p);

	
	
	
	
	[[nodiscard]] uint16 packUint2x8(u8vec2 const& v);

	
	
	
	
	[[nodiscard]] u8vec2 unpackUint2x8(uint16 p);

	
	
	
	
	[[nodiscard]] int32 packInt4x8(i8vec4 const& v);

	
	
	
	
	[[nodiscard]] i8vec4 unpackInt4x8(int32 p);

	
	
	
	
	[[nodiscard]] uint32 packUint4x8(u8vec4 const& v);

	
	
	
	
	[[nodiscard]] u8vec4 unpackUint4x8(uint32 p);

	
	
	
	
	[[nodiscard]] int packInt2x16(i16vec2 const& v);

	
	
	
	
	[[nodiscard]] i16vec2 unpackInt2x16(int p);

	
	
	
	
	[[nodiscard]] int64 packInt4x16(i16vec4 const& v);

	
	
	
	
	[[nodiscard]] i16vec4 unpackInt4x16(int64 p);

	
	
	
	
	[[nodiscard]] uint packUint2x16(u16vec2 const& v);

	
	
	
	
	[[nodiscard]] u16vec2 unpackUint2x16(uint p);

	
	
	
	
	[[nodiscard]] uint64 packUint4x16(u16vec4 const& v);

	
	
	
	
	[[nodiscard]] u16vec4 unpackUint4x16(uint64 p);

	
	
	
	
	[[nodiscard]] int64 packInt2x32(i32vec2 const& v);

	
	
	
	
	[[nodiscard]] i32vec2 unpackInt2x32(int64 p);

	
	
	
	
	[[nodiscard]] uint64 packUint2x32(u32vec2 const& v);

	
	
	
	
	[[nodiscard]] u32vec2 unpackUint2x32(uint64 p);

	
}

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\packing.inl"












namespace glm{
namespace detail
{
	inline glm::uint16 float2half(glm::uint32 f)
	{
		
		
		
		

		
		
		
		
		
		return
			((f >> 16) & 0x8000) | 
			((((f & 0x7f800000) - 0x38000000) >> 13) & 0x7c00) | 
			((f >> 13) & 0x03ff); 
	}

	inline glm::uint32 float2packed11(glm::uint32 f)
	{
		
		
		
		

		
		
		
		
		
		
		return
			((((f & 0x7f800000) - 0x38000000) >> 17) & 0x07c0) | 
			((f >> 17) & 0x003f); 
	}

	inline glm::uint32 packed11ToFloat(glm::uint32 p)
	{
		
		
		
		

		
		
		
		
		
		
		return
			((((p & 0x07c0) << 17) + 0x38000000) & 0x7f800000) | 
			((p & 0x003f) << 17); 
	}

	inline glm::uint32 float2packed10(glm::uint32 f)
	{
		
		
		
		

		
		
		
		
		
		
		
		
		
		return
			((((f & 0x7f800000) - 0x38000000) >> 18) & 0x03E0) | 
			((f >> 18) & 0x001f); 
	}

	inline glm::uint32 packed10ToFloat(glm::uint32 p)
	{
		
		
		
		

		
		
		
		
		
		
		
		
		
		return
			((((p & 0x03E0) << 18) + 0x38000000) & 0x7f800000) | 
			((p & 0x001f) << 18); 
	}

	inline glm::uint half2float(glm::uint h)
	{
		return ((h & 0x8000) << 16) | ((( h & 0x7c00) + 0x1C000) << 13) | ((h & 0x03FF) << 13);
	}

	inline glm::uint floatTo11bit(float x)
	{
		if(x == 0.0f)
			return 0u;
		else if(glm::isnan(x))
			return ~0u;
		else if(glm::isinf(x))
			return 0x1Fu << 6u;

		uint Pack = 0u;
		memcpy(&Pack, &x, sizeof(Pack));
		return float2packed11(Pack);
	}

	inline float packed11bitToFloat(glm::uint x)
	{
		if(x == 0)
			return 0.0f;
		else if(x == ((1 << 11) - 1))
			return ~0;
		else if(x == (0x1f << 6))
			return ~0;

		uint Result = packed11ToFloat(x);

		float Temp = 0;
		memcpy(&Temp, &Result, sizeof(Temp));
		return Temp;
	}

	inline glm::uint floatTo10bit(float x)
	{
		if(x == 0.0f)
			return 0u;
		else if(glm::isnan(x))
			return ~0u;
		else if(glm::isinf(x))
			return 0x1Fu << 5u;

		uint Pack = 0;
		memcpy(&Pack, &x, sizeof(Pack));
		return float2packed10(Pack);
	}

	inline float packed10bitToFloat(glm::uint x)
	{
		if(x == 0)
			return 0.0f;
		else if(x == ((1 << 10) - 1))
			return ~0;
		else if(x == (0x1f << 5))
			return ~0;

		uint Result = packed10ToFloat(x);

		float Temp = 0;
		memcpy(&Temp, &Result, sizeof(Temp));
		return Temp;
	}










#line 187 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\packing.inl"
#line 188 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\packing.inl"

	union u3u3u2
	{
		struct Data
		{
			uint x : 3;
			uint y : 3;
			uint z : 2;
		} data;
		uint8 pack;
	};

	union u4u4
	{
		struct Data
		{
			uint x : 4;
			uint y : 4;
		} data;
		uint8 pack;
	};

	union u4u4u4u4
	{
		struct Data
		{
			uint x : 4;
			uint y : 4;
			uint z : 4;
			uint w : 4;
		} data;
		uint16 pack;
	};

	union u5u6u5
	{
		struct Data
		{
			uint x : 5;
			uint y : 6;
			uint z : 5;
		} data;
		uint16 pack;
	};

	union u5u5u5u1
	{
		struct Data
		{
			uint x : 5;
			uint y : 5;
			uint z : 5;
			uint w : 1;
		} data;
		uint16 pack;
	};




#line 249 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\packing.inl"
#line 250 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\packing.inl"

	union u10u10u10u2
	{
		struct Data
		{
			uint x : 10;
			uint y : 10;
			uint z : 10;
			uint w : 2;
		} data;
		uint32 pack;
	};

	union i10i10i10i2
	{
		struct Data
		{
			int x : 10;
			int y : 10;
			int z : 10;
			int w : 2;
		} data;
		uint32 pack;
	};

	union u9u9u9e5
	{
		struct Data
		{
			uint x : 9;
			uint y : 9;
			uint z : 9;
			uint w : 5;
		} data;
		uint32 pack;
	};

	template<length_t L, qualifier Q>
	struct compute_half
	{};

	template<qualifier Q>
	struct compute_half<1, Q>
	{
		inline static vec<1, uint16, Q> pack(vec<1, float, Q> const& v)
		{
			int16 const Unpack(detail::toFloat16(v.x));
			u16vec1 Packed;
			memcpy(&Packed, &Unpack, sizeof(Packed));
			return Packed;
		}

		inline static vec<1, float, Q> unpack(vec<1, uint16, Q> const& v)
		{
			i16vec1 Unpack;
			memcpy(&Unpack, &v, sizeof(Unpack));
			return vec<1, float, Q>(detail::toFloat32(v.x));
		}
	};

	template<qualifier Q>
	struct compute_half<2, Q>
	{
		inline static vec<2, uint16, Q> pack(vec<2, float, Q> const& v)
		{
			vec<2, int16, Q> const Unpack(detail::toFloat16(v.x), detail::toFloat16(v.y));
			u16vec2 Packed;
			memcpy(&Packed, &Unpack, sizeof(Packed));
			return Packed;
		}

		inline static vec<2, float, Q> unpack(vec<2, uint16, Q> const& v)
		{
			i16vec2 Unpack;
			memcpy(&Unpack, &v, sizeof(Unpack));
			return vec<2, float, Q>(detail::toFloat32(v.x), detail::toFloat32(v.y));
		}
	};

	template<qualifier Q>
	struct compute_half<3, Q>
	{
		inline static vec<3, uint16, Q> pack(vec<3, float, Q> const& v)
		{
			vec<3, int16, Q> const Unpack(detail::toFloat16(v.x), detail::toFloat16(v.y), detail::toFloat16(v.z));
			u16vec3 Packed;
			memcpy(&Packed, &Unpack, sizeof(Packed));
			return Packed;
		}

		inline static vec<3, float, Q> unpack(vec<3, uint16, Q> const& v)
		{
			i16vec3 Unpack;
			memcpy(&Unpack, &v, sizeof(Unpack));
			return vec<3, float, Q>(detail::toFloat32(v.x), detail::toFloat32(v.y), detail::toFloat32(v.z));
		}
	};

	template<qualifier Q>
	struct compute_half<4, Q>
	{
		inline static vec<4, uint16, Q> pack(vec<4, float, Q> const& v)
		{
			vec<4, int16, Q> const Unpack(detail::toFloat16(v.x), detail::toFloat16(v.y), detail::toFloat16(v.z), detail::toFloat16(v.w));
			u16vec4 Packed;
			memcpy(&Packed, &Unpack, sizeof(Packed));
			return Packed;
		}

		inline static vec<4, float, Q> unpack(vec<4, uint16, Q> const& v)
		{
			i16vec4 Unpack;
			memcpy(&Unpack, &v, sizeof(Unpack));
			return vec<4, float, Q>(detail::toFloat32(Unpack.x), detail::toFloat32(Unpack.y), detail::toFloat32(Unpack.z), detail::toFloat32(Unpack.w));
		}
	};
}

	inline uint8 packUnorm1x8(float v)
	{
		return static_cast<uint8>(round(clamp(v, 0.0f, 1.0f) * 255.0f));
	}

	inline float unpackUnorm1x8(uint8 p)
	{
		float const Unpack(p);
		return Unpack * static_cast<float>(0.0039215686274509803921568627451); 
	}

	inline uint16 packUnorm2x8(vec2 const& v)
	{
		u8vec2 const Topack(round(clamp(v, 0.0f, 1.0f) * 255.0f));

		uint16 Unpack = 0;
		memcpy(&Unpack, &Topack, sizeof(Unpack));
		return Unpack;
	}

	inline vec2 unpackUnorm2x8(uint16 p)
	{
		u8vec2 Unpack;
		memcpy(&Unpack, &p, sizeof(Unpack));
		return vec2(Unpack) * float(0.0039215686274509803921568627451); 
	}

	inline uint8 packSnorm1x8(float v)
	{
		int8 const Topack(static_cast<int8>(round(clamp(v ,-1.0f, 1.0f) * 127.0f)));
		uint8 Packed = 0;
		memcpy(&Packed, &Topack, sizeof(Packed));
		return Packed;
	}

	inline float unpackSnorm1x8(uint8 p)
	{
		int8 Unpack = 0;
		memcpy(&Unpack, &p, sizeof(Unpack));
		return clamp(
			static_cast<float>(Unpack) * 0.00787401574803149606299212598425f, 
			-1.0f, 1.0f);
	}

	inline uint16 packSnorm2x8(vec2 const& v)
	{
		i8vec2 const Topack(round(clamp(v, -1.0f, 1.0f) * 127.0f));
		uint16 Packed = 0;
		memcpy(&Packed, &Topack, sizeof(Packed));
		return Packed;
	}

	inline vec2 unpackSnorm2x8(uint16 p)
	{
		i8vec2 Unpack;
		memcpy(&Unpack, &p, sizeof(Unpack));
		return clamp(
			vec2(Unpack) * 0.00787401574803149606299212598425f, 
			-1.0f, 1.0f);
	}

	inline uint16 packUnorm1x16(float s)
	{
		return static_cast<uint16>(round(clamp(s, 0.0f, 1.0f) * 65535.0f));
	}

	inline float unpackUnorm1x16(uint16 p)
	{
		float const Unpack(p);
		return Unpack * 1.5259021896696421759365224689097e-5f; 
	}

	inline uint64 packUnorm4x16(vec4 const& v)
	{
		u16vec4 const Topack(round(clamp(v , 0.0f, 1.0f) * 65535.0f));
		uint64 Packed = 0;
		memcpy(&Packed, &Topack, sizeof(Packed));
		return Packed;
	}

	inline vec4 unpackUnorm4x16(uint64 p)
	{
		u16vec4 Unpack;
		memcpy(&Unpack, &p, sizeof(Unpack));
		return vec4(Unpack) * 1.5259021896696421759365224689097e-5f; 
	}

	inline uint16 packSnorm1x16(float v)
	{
		int16 const Topack = static_cast<int16>(round(clamp(v ,-1.0f, 1.0f) * 32767.0f));
		uint16 Packed = 0;
		memcpy(&Packed, &Topack, sizeof(Packed));
		return Packed;
	}

	inline float unpackSnorm1x16(uint16 p)
	{
		int16 Unpack = 0;
		memcpy(&Unpack, &p, sizeof(Unpack));
		return clamp(
			static_cast<float>(Unpack) * 3.0518509475997192297128208258309e-5f, 
			-1.0f, 1.0f);
	}

	inline uint64 packSnorm4x16(vec4 const& v)
	{
		i16vec4 const Topack(round(clamp(v ,-1.0f, 1.0f) * 32767.0f));
		uint64 Packed = 0;
		memcpy(&Packed, &Topack, sizeof(Packed));
		return Packed;
	}

	inline vec4 unpackSnorm4x16(uint64 p)
	{
		i16vec4 Unpack;
		memcpy(&Unpack, &p, sizeof(Unpack));
		return clamp(
			vec4(Unpack) * 3.0518509475997192297128208258309e-5f, 
			-1.0f, 1.0f);
	}

	inline uint16 packHalf1x16(float v)
	{
		int16 const Topack(detail::toFloat16(v));
		uint16 Packed = 0;
		memcpy(&Packed, &Topack, sizeof(Packed));
		return Packed;
	}

	inline float unpackHalf1x16(uint16 v)
	{
		int16 Unpack = 0;
		memcpy(&Unpack, &v, sizeof(Unpack));
		return detail::toFloat32(Unpack);
	}

	inline uint64 packHalf4x16(glm::vec4 const& v)
	{
		i16vec4 const Unpack(
			detail::toFloat16(v.x),
			detail::toFloat16(v.y),
			detail::toFloat16(v.z),
			detail::toFloat16(v.w));
		uint64 Packed = 0;
		memcpy(&Packed, &Unpack, sizeof(Packed));
		return Packed;
	}

	inline glm::vec4 unpackHalf4x16(uint64 v)
	{
		i16vec4 Unpack;
		memcpy(&Unpack, &v, sizeof(Unpack));
		return vec4(
			detail::toFloat32(Unpack.x),
			detail::toFloat32(Unpack.y),
			detail::toFloat32(Unpack.z),
			detail::toFloat32(Unpack.w));
	}

	inline uint32 packI3x10_1x2(ivec4 const& v)
	{
		detail::i10i10i10i2 Result;
		Result.data.x = v.x;
		Result.data.y = v.y;
		Result.data.z = v.z;
		Result.data.w = v.w;
		return Result.pack;
	}

	inline ivec4 unpackI3x10_1x2(uint32 v)
	{
		detail::i10i10i10i2 Unpack;
		Unpack.pack = v;
		return ivec4(
			Unpack.data.x,
			Unpack.data.y,
			Unpack.data.z,
			Unpack.data.w);
	}

	inline uint32 packU3x10_1x2(uvec4 const& v)
	{
		detail::u10u10u10u2 Result;
		Result.data.x = v.x;
		Result.data.y = v.y;
		Result.data.z = v.z;
		Result.data.w = v.w;
		return Result.pack;
	}

	inline uvec4 unpackU3x10_1x2(uint32 v)
	{
		detail::u10u10u10u2 Unpack;
		Unpack.pack = v;
		return uvec4(
			Unpack.data.x,
			Unpack.data.y,
			Unpack.data.z,
			Unpack.data.w);
	}

	inline uint32 packSnorm3x10_1x2(vec4 const& v)
	{
		ivec4 const Pack(round(clamp(v,-1.0f, 1.0f) * vec4(511.f, 511.f, 511.f, 1.f)));

		detail::i10i10i10i2 Result;
		Result.data.x = Pack.x;
		Result.data.y = Pack.y;
		Result.data.z = Pack.z;
		Result.data.w = Pack.w;
		return Result.pack;
	}

	inline vec4 unpackSnorm3x10_1x2(uint32 v)
	{
		detail::i10i10i10i2 Unpack;
		Unpack.pack = v;

		vec4 const Result(Unpack.data.x, Unpack.data.y, Unpack.data.z, Unpack.data.w);

		return clamp(Result * vec4(1.f / 511.f, 1.f / 511.f, 1.f / 511.f, 1.f), -1.0f, 1.0f);
	}

	inline uint32 packUnorm3x10_1x2(vec4 const& v)
	{
		uvec4 const Unpack(round(clamp(v, 0.0f, 1.0f) * vec4(1023.f, 1023.f, 1023.f, 3.f)));

		detail::u10u10u10u2 Result;
		Result.data.x = Unpack.x;
		Result.data.y = Unpack.y;
		Result.data.z = Unpack.z;
		Result.data.w = Unpack.w;
		return Result.pack;
	}

	inline vec4 unpackUnorm3x10_1x2(uint32 v)
	{
		vec4 const ScaleFactors(1.0f / 1023.f, 1.0f / 1023.f, 1.0f / 1023.f, 1.0f / 3.f);

		detail::u10u10u10u2 Unpack;
		Unpack.pack = v;
		return vec4(Unpack.data.x, Unpack.data.y, Unpack.data.z, Unpack.data.w) * ScaleFactors;
	}

	inline uint32 packF2x11_1x10(vec3 const& v)
	{
		return
			((detail::floatTo11bit(v.x) & ((1 << 11) - 1)) <<  0) |
			((detail::floatTo11bit(v.y) & ((1 << 11) - 1)) << 11) |
			((detail::floatTo10bit(v.z) & ((1 << 10) - 1)) << 22);
	}

	inline vec3 unpackF2x11_1x10(uint32 v)
	{
		return vec3(
			detail::packed11bitToFloat(v >> 0),
			detail::packed11bitToFloat(v >> 11),
			detail::packed10bitToFloat(v >> 22));
	}

	inline uint32 packF3x9_E1x5(vec3 const& v)
	{
		float const SharedExpMax = (pow(2.0f, 9.0f - 1.0f) / pow(2.0f, 9.0f)) * pow(2.0f, 31.f - 15.f);
		vec3 const Color = clamp(v, 0.0f, SharedExpMax);
		float const MaxColor = max(Color.x, max(Color.y, Color.z));

		float const ExpSharedP = max(-15.f - 1.f, floor(log2(MaxColor))) + 1.0f + 15.f;
		float const MaxShared = floor(MaxColor / pow(2.0f, (ExpSharedP - 15.f - 9.f)) + 0.5f);
		float const ExpShared = equal(MaxShared, pow(2.0f, 9.0f), epsilon<float>()) ? ExpSharedP + 1.0f : ExpSharedP;

		uvec3 const ColorComp(floor(Color / pow(2.f, (ExpShared - 15.f - 9.f)) + 0.5f));

		detail::u9u9u9e5 Unpack;
		Unpack.data.x = ColorComp.x;
		Unpack.data.y = ColorComp.y;
		Unpack.data.z = ColorComp.z;
		Unpack.data.w = uint(ExpShared);
		return Unpack.pack;
	}

	inline vec3 unpackF3x9_E1x5(uint32 v)
	{
		detail::u9u9u9e5 Unpack;
		Unpack.pack = v;

		return vec3(Unpack.data.x, Unpack.data.y, Unpack.data.z) * pow(2.0f, static_cast<float>(Unpack.data.w) - 15.f - 9.f);
	}

	
	template<typename T, qualifier Q>
	inline vec<4, T, Q> packRGBM(vec<3, T, Q> const& rgb)
	{
		vec<3, T, Q> const Color(rgb * static_cast<T>(1.0 / 6.0));
		T Alpha = clamp(max(max(Color.x, Color.y), max(Color.z, static_cast<T>(1e-6))), static_cast<T>(0), static_cast<T>(1));
		Alpha = ceil(Alpha * static_cast<T>(255.0)) / static_cast<T>(255.0);
		return vec<4, T, Q>(Color / Alpha, Alpha);
	}

	template<typename T, qualifier Q>
	inline vec<3, T, Q> unpackRGBM(vec<4, T, Q> const& rgbm)
	{
		return vec<3, T, Q>(rgbm.x, rgbm.y, rgbm.z) * rgbm.w * static_cast<T>(6);
	}

	template<length_t L, qualifier Q>
	inline vec<L, uint16, Q> packHalf(vec<L, float, Q> const& v)
	{
		return detail::compute_half<L, Q>::pack(v);
	}

	template<length_t L, qualifier Q>
	inline vec<L, float, Q> unpackHalf(vec<L, uint16, Q> const& v)
	{
		return detail::compute_half<L, Q>::unpack(v);
	}

	template<typename uintType, length_t L, typename floatType, qualifier Q>
	inline vec<L, uintType, Q> packUnorm(vec<L, floatType, Q> const& v)
	{
		static_assert(std::numeric_limits<uintType>::is_integer, "uintType must be an integer type") ;
		static_assert(std::numeric_limits<floatType>::is_iec559, "floatType must be a floating point type") ;

		return vec<L, uintType, Q>(round(clamp(v, static_cast<floatType>(0), static_cast<floatType>(1)) * static_cast<floatType>(std::numeric_limits<uintType>::max())));
	}

	template<typename floatType, length_t L, typename uintType, qualifier Q>
	inline vec<L, floatType, Q> unpackUnorm(vec<L, uintType, Q> const& v)
	{
		static_assert(std::numeric_limits<uintType>::is_integer, "uintType must be an integer type") ;
		static_assert(std::numeric_limits<floatType>::is_iec559, "floatType must be a floating point type") ;

		return vec<L, floatType, Q>(v) * (static_cast<floatType>(1) / static_cast<floatType>(std::numeric_limits<uintType>::max()));
	}

	template<typename intType, length_t L, typename floatType, qualifier Q>
	inline vec<L, intType, Q> packSnorm(vec<L, floatType, Q> const& v)
	{
		static_assert(std::numeric_limits<intType>::is_integer, "uintType must be an integer type") ;
		static_assert(std::numeric_limits<floatType>::is_iec559, "floatType must be a floating point type") ;

		return vec<L, intType, Q>(round(clamp(v , static_cast<floatType>(-1), static_cast<floatType>(1)) * static_cast<floatType>(std::numeric_limits<intType>::max())));
	}

	template<typename floatType, length_t L, typename intType, qualifier Q>
	inline vec<L, floatType, Q> unpackSnorm(vec<L, intType, Q> const& v)
	{
		static_assert(std::numeric_limits<intType>::is_integer, "uintType must be an integer type") ;
		static_assert(std::numeric_limits<floatType>::is_iec559, "floatType must be a floating point type") ;

		return clamp(vec<L, floatType, Q>(v) * (static_cast<floatType>(1) / static_cast<floatType>(std::numeric_limits<intType>::max())), static_cast<floatType>(-1), static_cast<floatType>(1));
	}

	inline uint8 packUnorm2x4(vec2 const& v)
	{
		u32vec2 const Unpack(round(clamp(v, 0.0f, 1.0f) * 15.0f));
		detail::u4u4 Result;
		Result.data.x = Unpack.x;
		Result.data.y = Unpack.y;
		return Result.pack;
	}

	inline vec2 unpackUnorm2x4(uint8 v)
	{
		float const ScaleFactor(1.f / 15.f);
		detail::u4u4 Unpack;
		Unpack.pack = v;
		return vec2(Unpack.data.x, Unpack.data.y) * ScaleFactor;
	}

	inline uint16 packUnorm4x4(vec4 const& v)
	{
		u32vec4 const Unpack(round(clamp(v, 0.0f, 1.0f) * 15.0f));
		detail::u4u4u4u4 Result;
		Result.data.x = Unpack.x;
		Result.data.y = Unpack.y;
		Result.data.z = Unpack.z;
		Result.data.w = Unpack.w;
		return Result.pack;
	}

	inline vec4 unpackUnorm4x4(uint16 v)
	{
		float const ScaleFactor(1.f / 15.f);
		detail::u4u4u4u4 Unpack;
		Unpack.pack = v;
		return vec4(Unpack.data.x, Unpack.data.y, Unpack.data.z, Unpack.data.w) * ScaleFactor;
	}

	inline uint16 packUnorm1x5_1x6_1x5(vec3 const& v)
	{
		u32vec3 const Unpack(round(clamp(v, 0.0f, 1.0f) * vec3(31.f, 63.f, 31.f)));
		detail::u5u6u5 Result;
		Result.data.x = Unpack.x;
		Result.data.y = Unpack.y;
		Result.data.z = Unpack.z;
		return Result.pack;
	}

	inline vec3 unpackUnorm1x5_1x6_1x5(uint16 v)
	{
		vec3 const ScaleFactor(1.f / 31.f, 1.f / 63.f, 1.f / 31.f);
		detail::u5u6u5 Unpack;
		Unpack.pack = v;
		return vec3(Unpack.data.x, Unpack.data.y, Unpack.data.z) * ScaleFactor;
	}

	inline uint16 packUnorm3x5_1x1(vec4 const& v)
	{
		u32vec4 const Unpack(round(clamp(v, 0.0f, 1.0f) * vec4(31.f, 31.f, 31.f, 1.f)));
		detail::u5u5u5u1 Result;
		Result.data.x = Unpack.x;
		Result.data.y = Unpack.y;
		Result.data.z = Unpack.z;
		Result.data.w = Unpack.w;
		return Result.pack;
	}

	inline vec4 unpackUnorm3x5_1x1(uint16 v)
	{
		vec4 const ScaleFactor(1.f / 31.f, 1.f / 31.f, 1.f / 31.f, 1.f);
		detail::u5u5u5u1 Unpack;
		Unpack.pack = v;
		return vec4(Unpack.data.x, Unpack.data.y, Unpack.data.z, Unpack.data.w) * ScaleFactor;
	}

	inline uint8 packUnorm2x3_1x2(vec3 const& v)
	{
		u32vec3 const Unpack(round(clamp(v, 0.0f, 1.0f) * vec3(7.f, 7.f, 3.f)));
		detail::u3u3u2 Result;
		Result.data.x = Unpack.x;
		Result.data.y = Unpack.y;
		Result.data.z = Unpack.z;
		return Result.pack;
	}

	inline vec3 unpackUnorm2x3_1x2(uint8 v)
	{
		vec3 const ScaleFactor(1.f / 7.f, 1.f / 7.f, 1.f / 3.f);
		detail::u3u3u2 Unpack;
		Unpack.pack = v;
		return vec3(Unpack.data.x, Unpack.data.y, Unpack.data.z) * ScaleFactor;
	}

	inline int16 packInt2x8(i8vec2 const& v)
	{
		int16 Pack = 0;
		memcpy(&Pack, &v, sizeof(Pack));
		return Pack;
	}

	inline i8vec2 unpackInt2x8(int16 p)
	{
		i8vec2 Unpack;
		memcpy(&Unpack, &p, sizeof(Unpack));
		return Unpack;
	}

	inline uint16 packUint2x8(u8vec2 const& v)
	{
		uint16 Pack = 0;
		memcpy(&Pack, &v, sizeof(Pack));
		return Pack;
	}

	inline u8vec2 unpackUint2x8(uint16 p)
	{
		u8vec2 Unpack;
		memcpy(&Unpack, &p, sizeof(Unpack));
		return Unpack;
	}

	inline int32 packInt4x8(i8vec4 const& v)
	{
		int32 Pack = 0;
		memcpy(&Pack, &v, sizeof(Pack));
		return Pack;
	}

	inline i8vec4 unpackInt4x8(int32 p)
	{
		i8vec4 Unpack;
		memcpy(&Unpack, &p, sizeof(Unpack));
		return Unpack;
	}

	inline uint32 packUint4x8(u8vec4 const& v)
	{
		uint32 Pack = 0;
		memcpy(&Pack, &v, sizeof(Pack));
		return Pack;
	}

	inline u8vec4 unpackUint4x8(uint32 p)
	{
		u8vec4 Unpack;
		memcpy(&Unpack, &p, sizeof(Unpack));
		return Unpack;
	}

	inline int packInt2x16(i16vec2 const& v)
	{
		int Pack = 0;
		memcpy(&Pack, &v, sizeof(Pack));
		return Pack;
	}

	inline i16vec2 unpackInt2x16(int p)
	{
		i16vec2 Unpack;
		memcpy(&Unpack, &p, sizeof(Unpack));
		return Unpack;
	}

	inline int64 packInt4x16(i16vec4 const& v)
	{
		int64 Pack = 0;
		memcpy(&Pack, &v, sizeof(Pack));
		return Pack;
	}

	inline i16vec4 unpackInt4x16(int64 p)
	{
		i16vec4 Unpack;
		memcpy(&Unpack, &p, sizeof(Unpack));
		return Unpack;
	}

	inline uint packUint2x16(u16vec2 const& v)
	{
		uint Pack = 0;
		memcpy(&Pack, &v, sizeof(Pack));
		return Pack;
	}

	inline u16vec2 unpackUint2x16(uint p)
	{
		u16vec2 Unpack;
		memcpy(&Unpack, &p, sizeof(Unpack));
		return Unpack;
	}

	inline uint64 packUint4x16(u16vec4 const& v)
	{
		uint64 Pack = 0;
		memcpy(&Pack, &v, sizeof(Pack));
		return Pack;
	}

	inline u16vec4 unpackUint4x16(uint64 p)
	{
		u16vec4 Unpack;
		memcpy(&Unpack, &p, sizeof(Unpack));
		return Unpack;
	}

	inline int64 packInt2x32(i32vec2 const& v)
	{
		int64 Pack = 0;
		memcpy(&Pack, &v, sizeof(Pack));
		return Pack;
	}

	inline i32vec2 unpackInt2x32(int64 p)
	{
		i32vec2 Unpack;
		memcpy(&Unpack, &p, sizeof(Unpack));
		return Unpack;
	}

	inline uint64 packUint2x32(u32vec2 const& v)
	{
		uint64 Pack = 0;
		memcpy(&Pack, &v, sizeof(Pack));
		return Pack;
	}

	inline u32vec2 unpackUint2x32(uint64 p)
	{
		u32vec2 Unpack;
		memcpy(&Unpack, &p, sizeof(Unpack));
		return Unpack;
	}
}

#line 729 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\packing.hpp"
#line 184 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\random.hpp"













#pragma once








#line 24 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\random.hpp"

namespace glm
{
	
	

	
	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType linearRand(genType Min, genType Max);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> linearRand(vec<L, T, Q> const& Min, vec<L, T, Q> const& Max);

	
	
	
	template<typename genType>
	[[nodiscard]] genType gaussRand(genType Mean, genType Deviation);

	
	
	
	template<typename T>
	[[nodiscard]] vec<2, T, defaultp> circularRand(T Radius);

	
	
	
	template<typename T>
	[[nodiscard]] vec<3, T, defaultp> sphericalRand(T Radius);

	
	
	
	template<typename T>
	[[nodiscard]] vec<2, T, defaultp> diskRand(T Radius);

	
	
	
	template<typename T>
	[[nodiscard]] vec<3, T, defaultp> ballRand(T Radius);

	
}

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\random.inl"





#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ctime"





#pragma once





#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\time.h"







#pragma once






#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {








typedef long clock_t;

struct _timespec32
{
    __time32_t tv_sec;
    long       tv_nsec;
};

struct _timespec64
{
    __time64_t tv_sec;
    long       tv_nsec;
};


    struct timespec
    {
        time_t tv_sec;  
        long   tv_nsec; 
    };
#line 49 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\time.h"
















 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_daylight" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) int* __cdecl __daylight(void);




 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_dstbias" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) long* __cdecl __dstbias(void);




 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_timezone" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) long* __cdecl __timezone(void);




  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_tzname" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char** __cdecl __tzname(void);



 
__declspec(dllimport) errno_t __cdecl _get_daylight(
     int* _Daylight
    );


__declspec(dllimport) errno_t __cdecl _get_dstbias(
     long* _DaylightSavingsBias
    );

 
__declspec(dllimport) errno_t __cdecl _get_timezone(
     long* _TimeZone
    );


__declspec(dllimport) errno_t __cdecl _get_tzname(
                            size_t* _ReturnValue,
     char*   _Buffer,
                             size_t  _SizeInBytes,
                             int     _Index
    );










 __declspec(deprecated("This function or variable may be unsafe. Consider using " "asctime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl asctime(
     struct tm const* _Tm
    );


    
    
    __declspec(dllimport) errno_t __cdecl asctime_s(
          char*            _Buffer,
                                           size_t           _SizeInBytes,
                                                        struct tm const* _Tm
        );
#line 134 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\time.h"

extern "C++" { template <size_t _Size> inline errno_t __cdecl asctime_s(char (&_Buffer)[_Size], struct tm const* _Time) throw() { return asctime_s(_Buffer, _Size, _Time); } }






__declspec(dllimport) clock_t __cdecl clock(void);



 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ctime32_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _ctime32(
     __time32_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _ctime32_s(
      char*             _Buffer,
                                       size_t            _SizeInBytes,
                                                    __time32_t const* _Time
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ctime32_s(char (&_Buffer)[_Size], __time32_t const* _Time) throw() { return _ctime32_s(_Buffer, _Size, _Time); } }







 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ctime64_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _ctime64(
     __time64_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _ctime64_s(
      char*             _Buffer,
                                         size_t            _SizeInBytes,
                                                      __time64_t const* _Time
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ctime64_s(char (&_Buffer)[_Size], __time64_t const* _Time) throw() { return _ctime64_s(_Buffer, _Size, _Time); } }






__declspec(dllimport) double __cdecl _difftime32(
     __time32_t _Time1,
     __time32_t _Time2
    );


__declspec(dllimport) double __cdecl _difftime64(
     __time64_t _Time1,
     __time64_t _Time2
    );


 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_gmtime32_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) struct tm* __cdecl _gmtime32(
     __time32_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _gmtime32_s(
     struct tm*        _Tm,
      __time32_t const* _Time
    );


 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_gmtime64_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) struct tm* __cdecl _gmtime64(
     __time64_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _gmtime64_s(
     struct tm*        _Tm,
      __time64_t const* _Time
    );


 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_localtime32_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) struct tm* __cdecl _localtime32(
     __time32_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _localtime32_s(
     struct tm*        _Tm,
      __time32_t const* _Time
    );


 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_localtime64_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) struct tm* __cdecl _localtime64(
     __time64_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _localtime64_s(
     struct tm*        _Tm,
      __time64_t const* _Time
    );


__declspec(dllimport) __time32_t __cdecl _mkgmtime32(
     struct tm* _Tm
    );


__declspec(dllimport) __time64_t __cdecl _mkgmtime64(
     struct tm* _Tm
    );


__declspec(dllimport) __time32_t __cdecl _mktime32(
     struct tm* _Tm
    );


__declspec(dllimport) __time64_t __cdecl _mktime64(
     struct tm* _Tm
    );



__declspec(dllimport) size_t __cdecl strftime(
      char*            _Buffer,
                              size_t           _SizeInBytes,
      char const*      _Format,
                              struct tm const* _Tm
    );



__declspec(dllimport) size_t __cdecl _strftime_l(
          char*            _Buffer,
                              size_t           _MaxSize,
      char const*      _Format,
                              struct tm const* _Tm,
                          _locale_t        _Locale
    );


__declspec(dllimport) errno_t __cdecl _strdate_s(
      char*  _Buffer,
                                                                             size_t _SizeInBytes
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strdate_s(char (&_Buffer)[_Size]) throw() { return _strdate_s(_Buffer, _Size); } }




__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strdate_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strdate( char *_Buffer);





__declspec(dllimport) errno_t __cdecl _strtime_s(
      char*  _Buffer,
                                                                             size_t _SizeInBytes
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strtime_s(char (&_Buffer)[_Size]) throw() { return _strtime_s(_Buffer, _Size); } }




__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strtime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strtime( char *_Buffer);




__declspec(dllimport) __time32_t __cdecl _time32(
     __time32_t* _Time
    );

__declspec(dllimport) __time64_t __cdecl _time64(
     __time64_t* _Time
    );



__declspec(dllimport) int __cdecl _timespec32_get(
     struct _timespec32* _Ts,
      int                 _Base
    );



__declspec(dllimport) int __cdecl _timespec64_get(
     struct _timespec64* _Ts,
      int                 _Base
    );










    __declspec(dllimport) void __cdecl _tzset(void);

    
    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "GetLocalTime" " " "instead. See online help for details."))
    __declspec(dllimport) unsigned __cdecl _getsystime(
         struct tm* _Tm
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "SetLocalTime" " " "instead. See online help for details."))
    __declspec(dllimport) unsigned __cdecl _setsystime(
         struct tm* _Tm,
         unsigned   _Milliseconds
        );

#line 361 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\time.h"










    


































































































         __declspec(deprecated("This function or variable may be unsafe. Consider using " "ctime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        static __inline char* __cdecl ctime(
             time_t const* const _Time
            )
        {
            return _ctime64(_Time);
        }

        
        static __inline double __cdecl difftime(
             time_t const _Time1,
             time_t const _Time2
            )
        {
            return _difftime64(_Time1, _Time2);
        }

         __declspec(deprecated("This function or variable may be unsafe. Consider using " "gmtime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        static __inline struct tm* __cdecl gmtime(
             time_t const* const _Time)
        {
            return _gmtime64(_Time);
        }

        __declspec(deprecated("This function or variable may be unsafe. Consider using " "localtime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        static __inline struct tm* __cdecl localtime(
             time_t const* const _Time
            )
        {
            return _localtime64(_Time);
        }

        
        static __inline time_t __cdecl _mkgmtime(
             struct tm* const _Tm
            )
        {
            return _mkgmtime64(_Tm);
        }

        
        static __inline time_t __cdecl mktime(
             struct tm* const _Tm
            )
        {
            return _mktime64(_Tm);
        }

        static __inline time_t __cdecl time(
             time_t* const _Time
            )
        {
            return _time64(_Time);
        }

        
        static __inline int __cdecl timespec_get(
             struct timespec* const _Ts,
              int              const _Base
            )
        {
            return _timespec64_get((struct _timespec64*)_Ts, _Base);
        }

        
            
            static __inline errno_t __cdecl ctime_s(
                  char*         const _Buffer,
                                                   size_t        const _SizeInBytes,
                                                                time_t const* const _Time
                )
            {
                return _ctime64_s(_Buffer, _SizeInBytes, _Time);
            }

            
            static __inline errno_t __cdecl gmtime_s(
                 struct tm*    const _Tm,
                  time_t const* const _Time
                )
            {
                return _gmtime64_s(_Tm, _Time);
            }

            
            static __inline errno_t __cdecl localtime_s(
                 struct tm*    const _Tm,
                  time_t const* const _Time
                )
            {
                return _localtime64_s(_Tm, _Time);
            }
        #line 563 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\time.h"

    #line 565 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\time.h"

#line 567 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\time.h"










    

    
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_tzset" ". See online help for details.")) __declspec(dllimport) void __cdecl tzset(void);
    #line 582 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\time.h"

#line 584 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\time.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#line 591 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\time.h"
#pragma external_header(pop)
#line 13 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ctime"

#pragma pack(push, 8 )
#pragma warning(push, 3 )
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 )




namespace std {
 using :: clock_t;
 using :: size_t;
 using :: time_t;
 using :: tm;
 using :: asctime;
 using :: clock;
 using :: strftime;

 using :: timespec;
#line 32 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ctime"













































#line 78 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ctime"


 using :: ctime;
 using :: difftime;
 using :: gmtime;
 using :: localtime;
 using :: mktime;
 using :: time;

 using :: timespec_get;
#line 89 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ctime"

#line 91 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ctime"
}



#pragma warning(pop)
#pragma pack(pop)

#line 99 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ctime"
#line 100 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\ctime"
#pragma external_header(pop)
#line 7 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\random.inl"
#pragma external_header(push)
#line 1 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cassert"








#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\assert.h"









#line 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\assert.h"



#pragma warning(push)
#pragma warning(disable: 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )

__pragma(pack(push, 8)) extern "C" {





#line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\assert.h"









    __declspec(dllimport) void __cdecl _wassert(
         wchar_t const* _Message,
         wchar_t const* _File,
           unsigned       _Line
        );

    




#line 45 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\assert.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 10 "D:\\Program Files\\MS Visual Studio\\Visual Studio Community 2022\\VC\\Tools\\MSVC\\14.36.32532\\include\\cassert"
#pragma external_header(pop)
#line 8 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\random.inl"


namespace glm{
namespace detail
{
	template <length_t L, typename T, qualifier Q>
	struct compute_rand
	{
		inline static vec<L, T, Q> call();
	};

	template <qualifier P>
	struct compute_rand<1, uint8, P>
	{
		inline static vec<1, uint8, P> call()
		{
			return vec<1, uint8, P>(
				static_cast<uint8>(std::rand() % std::numeric_limits<uint8>::max()));
		}
	};

	template <qualifier P>
	struct compute_rand<2, uint8, P>
	{
		inline static vec<2, uint8, P> call()
		{
			return vec<2, uint8, P>(
				std::rand() % std::numeric_limits<uint8>::max(),
				std::rand() % std::numeric_limits<uint8>::max());
		}
	};

	template <qualifier P>
	struct compute_rand<3, uint8, P>
	{
		inline static vec<3, uint8, P> call()
		{
			return vec<3, uint8, P>(
				std::rand() % std::numeric_limits<uint8>::max(),
				std::rand() % std::numeric_limits<uint8>::max(),
				std::rand() % std::numeric_limits<uint8>::max());
		}
	};

	template <qualifier P>
	struct compute_rand<4, uint8, P>
	{
		inline static vec<4, uint8, P> call()
		{
			return vec<4, uint8, P>(
				std::rand() % std::numeric_limits<uint8>::max(),
				std::rand() % std::numeric_limits<uint8>::max(),
				std::rand() % std::numeric_limits<uint8>::max(),
				std::rand() % std::numeric_limits<uint8>::max());
		}
	};

	template <length_t L, qualifier Q>
	struct compute_rand<L, uint16, Q>
	{
		inline static vec<L, uint16, Q> call()
		{
			return
				(vec<L, uint16, Q>(compute_rand<L, uint8, Q>::call()) << static_cast<uint16>(8)) |
				(vec<L, uint16, Q>(compute_rand<L, uint8, Q>::call()) << static_cast<uint16>(0));
		}
	};

	template <length_t L, qualifier Q>
	struct compute_rand<L, uint32, Q>
	{
		inline static vec<L, uint32, Q> call()
		{
			return
				(vec<L, uint32, Q>(compute_rand<L, uint16, Q>::call()) << static_cast<uint32>(16)) |
				(vec<L, uint32, Q>(compute_rand<L, uint16, Q>::call()) << static_cast<uint32>(0));
		}
	};

	template <length_t L, qualifier Q>
	struct compute_rand<L, uint64, Q>
	{
		inline static vec<L, uint64, Q> call()
		{
			return
				(vec<L, uint64, Q>(compute_rand<L, uint32, Q>::call()) << static_cast<uint64>(32)) |
				(vec<L, uint64, Q>(compute_rand<L, uint32, Q>::call()) << static_cast<uint64>(0));
		}
	};

	template <length_t L, typename T, qualifier Q>
	struct compute_linearRand
	{
		inline static vec<L, T, Q> call(vec<L, T, Q> const& Min, vec<L, T, Q> const& Max);
	};

	template<length_t L, qualifier Q>
	struct compute_linearRand<L, int8, Q>
	{
		inline static vec<L, int8, Q> call(vec<L, int8, Q> const& Min, vec<L, int8, Q> const& Max)
		{
			return (vec<L, int8, Q>(compute_rand<L, uint8, Q>::call() % vec<L, uint8, Q>(Max + static_cast<int8>(1) - Min))) + Min;
		}
	};

	template<length_t L, qualifier Q>
	struct compute_linearRand<L, uint8, Q>
	{
		inline static vec<L, uint8, Q> call(vec<L, uint8, Q> const& Min, vec<L, uint8, Q> const& Max)
		{
			return (compute_rand<L, uint8, Q>::call() % (Max + static_cast<uint8>(1) - Min)) + Min;
		}
	};

	template<length_t L, qualifier Q>
	struct compute_linearRand<L, int16, Q>
	{
		inline static vec<L, int16, Q> call(vec<L, int16, Q> const& Min, vec<L, int16, Q> const& Max)
		{
			return (vec<L, int16, Q>(compute_rand<L, uint16, Q>::call() % vec<L, uint16, Q>(Max + static_cast<int16>(1) - Min))) + Min;
		}
	};

	template<length_t L, qualifier Q>
	struct compute_linearRand<L, uint16, Q>
	{
		inline static vec<L, uint16, Q> call(vec<L, uint16, Q> const& Min, vec<L, uint16, Q> const& Max)
		{
			return (compute_rand<L, uint16, Q>::call() % (Max + static_cast<uint16>(1) - Min)) + Min;
		}
	};

	template<length_t L, qualifier Q>
	struct compute_linearRand<L, int32, Q>
	{
		inline static vec<L, int32, Q> call(vec<L, int32, Q> const& Min, vec<L, int32, Q> const& Max)
		{
			return (vec<L, int32, Q>(compute_rand<L, uint32, Q>::call() % vec<L, uint32, Q>(Max + static_cast<int32>(1) - Min))) + Min;
		}
	};

	template<length_t L, qualifier Q>
	struct compute_linearRand<L, uint32, Q>
	{
		inline static vec<L, uint32, Q> call(vec<L, uint32, Q> const& Min, vec<L, uint32, Q> const& Max)
		{
			return (compute_rand<L, uint32, Q>::call() % (Max + static_cast<uint32>(1) - Min)) + Min;
		}
	};

	template<length_t L, qualifier Q>
	struct compute_linearRand<L, int64, Q>
	{
		inline static vec<L, int64, Q> call(vec<L, int64, Q> const& Min, vec<L, int64, Q> const& Max)
		{
			return (vec<L, int64, Q>(compute_rand<L, uint64, Q>::call() % vec<L, uint64, Q>(Max + static_cast<int64>(1) - Min))) + Min;
		}
	};

	template<length_t L, qualifier Q>
	struct compute_linearRand<L, uint64, Q>
	{
		inline static vec<L, uint64, Q> call(vec<L, uint64, Q> const& Min, vec<L, uint64, Q> const& Max)
		{
			return (compute_rand<L, uint64, Q>::call() % (Max + static_cast<uint64>(1) - Min)) + Min;
		}
	};

	template<length_t L, qualifier Q>
	struct compute_linearRand<L, float, Q>
	{
		inline static vec<L, float, Q> call(vec<L, float, Q> const& Min, vec<L, float, Q> const& Max)
		{
			return vec<L, float, Q>(compute_rand<L, uint32, Q>::call()) / static_cast<float>(std::numeric_limits<uint32>::max()) * (Max - Min) + Min;
		}
	};

	template<length_t L, qualifier Q>
	struct compute_linearRand<L, double, Q>
	{
		inline static vec<L, double, Q> call(vec<L, double, Q> const& Min, vec<L, double, Q> const& Max)
		{
			return vec<L, double, Q>(compute_rand<L, uint64, Q>::call()) / static_cast<double>(std::numeric_limits<uint64>::max()) * (Max - Min) + Min;
		}
	};

	template<length_t L, qualifier Q>
	struct compute_linearRand<L, long double, Q>
	{
		inline static vec<L, long double, Q> call(vec<L, long double, Q> const& Min, vec<L, long double, Q> const& Max)
		{
			return vec<L, long double, Q>(compute_rand<L, uint64, Q>::call()) / static_cast<long double>(std::numeric_limits<uint64>::max()) * (Max - Min) + Min;
		}
	};
}

	template<typename genType>
	inline genType linearRand(genType Min, genType Max)
	{
		return detail::compute_linearRand<1, genType, highp>::call(
			vec<1, genType, highp>(Min),
			vec<1, genType, highp>(Max)).x;
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> linearRand(vec<L, T, Q> const& Min, vec<L, T, Q> const& Max)
	{
		return detail::compute_linearRand<L, T, Q>::call(Min, Max);
	}

	template<typename genType>
	inline genType gaussRand(genType Mean, genType Deviation)
	{
		genType w, x1, x2;

		do
		{
			x1 = linearRand(genType(-1), genType(1));
			x2 = linearRand(genType(-1), genType(1));

			w = x1 * x1 + x2 * x2;
		} while(w > genType(1));

		return static_cast<genType>(x2 * Deviation * Deviation * sqrt((genType(-2) * log(w)) / w) + Mean);
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> gaussRand(vec<L, T, Q> const& Mean, vec<L, T, Q> const& Deviation)
	{
		return detail::functor2<vec, L, T, Q>::call(gaussRand, Mean, Deviation);
	}

	template<typename T>
	inline vec<2, T, defaultp> diskRand(T Radius)
	{
		(void)( (!!(Radius > static_cast<T>(0))) || (_wassert(L"Radius > static_cast<T>(0)", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\random.inl", (unsigned)(243)), 0) ) ;

		vec<2, T, defaultp> Result(T(0));
		T LenRadius(T(0));

		do
		{
			Result = linearRand(
				vec<2, T, defaultp>(-Radius),
				vec<2, T, defaultp>(Radius));
			LenRadius = length(Result);
		}
		while(LenRadius > Radius);

		return Result;
	}

	template<typename T>
	inline vec<3, T, defaultp> ballRand(T Radius)
	{
		(void)( (!!(Radius > static_cast<T>(0))) || (_wassert(L"Radius > static_cast<T>(0)", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\random.inl", (unsigned)(263)), 0) ) ;

		vec<3, T, defaultp> Result(T(0));
		T LenRadius(T(0));

		do
		{
			Result = linearRand(
				vec<3, T, defaultp>(-Radius),
				vec<3, T, defaultp>(Radius));
			LenRadius = length(Result);
		}
		while(LenRadius > Radius);

		return Result;
	}

	template<typename T>
	inline vec<2, T, defaultp> circularRand(T Radius)
	{
		(void)( (!!(Radius > static_cast<T>(0))) || (_wassert(L"Radius > static_cast<T>(0)", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\random.inl", (unsigned)(283)), 0) ) ;

		T a = linearRand(T(0), static_cast<T>(6.283185307179586476925286766559));
		return vec<2, T, defaultp>(glm::cos(a), glm::sin(a)) * Radius;
	}

	template<typename T>
	inline vec<3, T, defaultp> sphericalRand(T Radius)
	{
		(void)( (!!(Radius > static_cast<T>(0))) || (_wassert(L"Radius > static_cast<T>(0)", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\random.inl", (unsigned)(292)), 0) ) ;

		T theta = linearRand(T(0), T(6.283185307179586476925286766559f));
		T phi = std::acos(linearRand(T(-1.0f), T(1.0f)));

		T x = std::sin(phi) * std::cos(theta);
		T y = std::sin(phi) * std::sin(theta);
		T z = std::cos(phi);

		return vec<3, T, defaultp>(x, y, z) * Radius;
	}
}
#line 83 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\random.hpp"
#line 186 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\reciprocal.hpp"












#pragma once


#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 970 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
























































































































































































































#line 1187 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 1189 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
#line 17 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\reciprocal.hpp"



#line 21 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\reciprocal.hpp"




#line 187 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\round.hpp"













#pragma once


#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 970 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
























































































































































































































#line 1187 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 1189 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
#line 18 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\round.hpp"








#line 27 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\round.hpp"

namespace glm
{
	
	

	
	
	
	
	template<typename genIUType>
	[[nodiscard]] genIUType ceilPowerOfTwo(genIUType v);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> ceilPowerOfTwo(vec<L, T, Q> const& v);

	
	
	
	
	template<typename genIUType>
	[[nodiscard]] genIUType floorPowerOfTwo(genIUType v);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> floorPowerOfTwo(vec<L, T, Q> const& v);

	
	
	
	template<typename genIUType>
	[[nodiscard]] genIUType roundPowerOfTwo(genIUType v);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> roundPowerOfTwo(vec<L, T, Q> const& v);

	
	
	
	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType ceilMultiple(genType v, genType Multiple);

	
	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> ceilMultiple(vec<L, T, Q> const& v, vec<L, T, Q> const& Multiple);

	
	
	
	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType floorMultiple(genType v, genType Multiple);

	
	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> floorMultiple(vec<L, T, Q> const& v, vec<L, T, Q> const& Multiple);

	
	
	
	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType roundMultiple(genType v, genType Multiple);

	
	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> roundMultiple(vec<L, T, Q> const& v, vec<L, T, Q> const& Multiple);

	
} 

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\round.inl"





namespace glm{
namespace detail
{
	template<bool is_float, bool is_signed>
	struct compute_roundMultiple {};

	template<>
	struct compute_roundMultiple<true, true>
	{
		template<typename genType>
		inline static genType call(genType Source, genType Multiple)
		{
			if (Source >= genType(0))
				return Source - std::fmod(Source, Multiple);
			else
			{
				genType Tmp = Source + genType(1);
				return Tmp - std::fmod(Tmp, Multiple) - Multiple;
			}
		}
	};

	template<>
	struct compute_roundMultiple<false, false>
	{
		template<typename genType>
		inline static genType call(genType Source, genType Multiple)
		{
			if (Source >= genType(0))
				return Source - Source % Multiple;
			else
			{
				genType Tmp = Source + genType(1);
				return Tmp - Tmp % Multiple - Multiple;
			}
		}
	};

	template<>
	struct compute_roundMultiple<false, true>
	{
		template<typename genType>
		inline static genType call(genType Source, genType Multiple)
		{
			if (Source >= genType(0))
				return Source - Source % Multiple;
			else
			{
				genType Tmp = Source + genType(1);
				return Tmp - Tmp % Multiple - Multiple;
			}
		}
	};
}

	
	

	template<typename genType>
	inline genType ceilPowerOfTwo(genType value)
	{
		return detail::compute_ceilPowerOfTwo<1, genType, defaultp, std::numeric_limits<genType>::is_signed>::call(vec<1, genType, defaultp>(value)).x;
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> ceilPowerOfTwo(vec<L, T, Q> const& v)
	{
		return detail::compute_ceilPowerOfTwo<L, T, Q, std::numeric_limits<T>::is_signed>::call(v);
	}

	
	

	template<typename genType>
	inline genType floorPowerOfTwo(genType value)
	{
		return isPowerOfTwo(value) ? value : static_cast<genType>(1) << findMSB(value);
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> floorPowerOfTwo(vec<L, T, Q> const& v)
	{
		return detail::functor1<vec, L, T, T, Q>::call(floorPowerOfTwo, v);
	}

	
	

	template<typename genIUType>
	inline genIUType roundPowerOfTwo(genIUType value)
	{
		if(isPowerOfTwo(value))
			return value;

		genIUType const prev = static_cast<genIUType>(1) << findMSB(value);
		genIUType const next = prev << static_cast<genIUType>(1);
		return (next - value) < (value - prev) ? next : prev;
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> roundPowerOfTwo(vec<L, T, Q> const& v)
	{
		return detail::functor1<vec, L, T, T, Q>::call(roundPowerOfTwo, v);
	}

	
	

	template<typename genType>
	inline genType ceilMultiple(genType Source, genType Multiple)
	{
		return detail::compute_ceilMultiple<std::numeric_limits<genType>::is_iec559, std::numeric_limits<genType>::is_signed>::call(Source, Multiple);
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> ceilMultiple(vec<L, T, Q> const& Source, vec<L, T, Q> const& Multiple)
	{
		return detail::functor2<vec, L, T, Q>::call(ceilMultiple, Source, Multiple);
	}

	
	

	template<typename genType>
	inline genType floorMultiple(genType Source, genType Multiple)
	{
		return detail::compute_floorMultiple<std::numeric_limits<genType>::is_iec559, std::numeric_limits<genType>::is_signed>::call(Source, Multiple);
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> floorMultiple(vec<L, T, Q> const& Source, vec<L, T, Q> const& Multiple)
	{
		return detail::functor2<vec, L, T, Q>::call(floorMultiple, Source, Multiple);
	}

	
	

	template<typename genType>
	inline genType roundMultiple(genType Source, genType Multiple)
	{
		return detail::compute_roundMultiple<std::numeric_limits<genType>::is_iec559, std::numeric_limits<genType>::is_signed>::call(Source, Multiple);
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> roundMultiple(vec<L, T, Q> const& Source, vec<L, T, Q> const& Multiple)
	{
		return detail::functor2<vec, L, T, Q>::call(roundMultiple, Source, Multiple);
	}
}
#line 161 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\round.hpp"
#line 188 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\type_ptr.hpp"

































#pragma once




















#line 56 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\type_ptr.hpp"

namespace glm
{
	
	

	
	
	template<typename genType>
	[[nodiscard]] typename genType::value_type const * value_ptr(genType const& v);

	
	
	template <typename T, qualifier Q>
	[[nodiscard]] vec<1, T, Q> make_vec1(vec<1, T, Q> const& v);

	
	
	template <typename T, qualifier Q>
	[[nodiscard]] vec<1, T, Q> make_vec1(vec<2, T, Q> const& v);

	
	
	template <typename T, qualifier Q>
	[[nodiscard]] vec<1, T, Q> make_vec1(vec<3, T, Q> const& v);

	
	
	template <typename T, qualifier Q>
	[[nodiscard]] vec<1, T, Q> make_vec1(vec<4, T, Q> const& v);

	
	
	template <typename T, qualifier Q>
	[[nodiscard]] vec<2, T, Q> make_vec2(vec<1, T, Q> const& v);

	
	
	template <typename T, qualifier Q>
	[[nodiscard]] vec<2, T, Q> make_vec2(vec<2, T, Q> const& v);

	
	
	template <typename T, qualifier Q>
	[[nodiscard]] vec<2, T, Q> make_vec2(vec<3, T, Q> const& v);

	
	
	template <typename T, qualifier Q>
	[[nodiscard]] vec<2, T, Q> make_vec2(vec<4, T, Q> const& v);

	
	
	template <typename T, qualifier Q>
	[[nodiscard]] vec<3, T, Q> make_vec3(vec<1, T, Q> const& v);

	
	
	template <typename T, qualifier Q>
	[[nodiscard]] vec<3, T, Q> make_vec3(vec<2, T, Q> const& v);

	
	
	template <typename T, qualifier Q>
	[[nodiscard]] vec<3, T, Q> make_vec3(vec<3, T, Q> const& v);

	
	
	template <typename T, qualifier Q>
	[[nodiscard]] vec<3, T, Q> make_vec3(vec<4, T, Q> const& v);

	
	
	template <typename T, qualifier Q>
	[[nodiscard]] vec<4, T, Q> make_vec4(vec<1, T, Q> const& v);

	
	
	template <typename T, qualifier Q>
	[[nodiscard]] vec<4, T, Q> make_vec4(vec<2, T, Q> const& v);

	
	
	template <typename T, qualifier Q>
	[[nodiscard]] vec<4, T, Q> make_vec4(vec<3, T, Q> const& v);

	
	
	template <typename T, qualifier Q>
	[[nodiscard]] vec<4, T, Q> make_vec4(vec<4, T, Q> const& v);

	
	
	template<typename T>
	[[nodiscard]] vec<2, T, defaultp> make_vec2(T const * const ptr);

	
	
	template<typename T>
	[[nodiscard]] vec<3, T, defaultp> make_vec3(T const * const ptr);

	
	
	template<typename T>
	[[nodiscard]] vec<4, T, defaultp> make_vec4(T const * const ptr);

	
	
	template<typename T>
	[[nodiscard]] mat<2, 2, T, defaultp> make_mat2x2(T const * const ptr);

	
	
	template<typename T>
	[[nodiscard]] mat<2, 3, T, defaultp> make_mat2x3(T const * const ptr);

	
	
	template<typename T>
	[[nodiscard]] mat<2, 4, T, defaultp> make_mat2x4(T const * const ptr);

	
	
	template<typename T>
	[[nodiscard]] mat<3, 2, T, defaultp> make_mat3x2(T const * const ptr);

	
	
	template<typename T>
	[[nodiscard]] mat<3, 3, T, defaultp> make_mat3x3(T const * const ptr);

	
	
	template<typename T>
	[[nodiscard]] mat<3, 4, T, defaultp> make_mat3x4(T const * const ptr);

	
	
	template<typename T>
	[[nodiscard]] mat<4, 2, T, defaultp> make_mat4x2(T const * const ptr);

	
	
	template<typename T>
	[[nodiscard]] mat<4, 3, T, defaultp> make_mat4x3(T const * const ptr);

	
	
	template<typename T>
	[[nodiscard]] mat<4, 4, T, defaultp> make_mat4x4(T const * const ptr);

	
	
	template<typename T>
	[[nodiscard]] mat<2, 2, T, defaultp> make_mat2(T const * const ptr);

	
	
	template<typename T>
	[[nodiscard]] mat<3, 3, T, defaultp> make_mat3(T const * const ptr);

	
	
	template<typename T>
	[[nodiscard]] mat<4, 4, T, defaultp> make_mat4(T const * const ptr);

	
	
	template<typename T>
	[[nodiscard]] qua<T, defaultp> make_quat(T const * const ptr);

	
}

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\type_ptr.inl"




namespace glm
{
	
	

	template<typename T, qualifier Q>
	inline T const* value_ptr(vec<2, T, Q> const& v)
	{
		return &(v.x);
	}

	template<typename T, qualifier Q>
	inline T* value_ptr(vec<2, T, Q>& v)
	{
		return &(v.x);
	}

	template<typename T, qualifier Q>
	inline T const * value_ptr(vec<3, T, Q> const& v)
	{
		return &(v.x);
	}

	template<typename T, qualifier Q>
	inline T* value_ptr(vec<3, T, Q>& v)
	{
		return &(v.x);
	}

	template<typename T, qualifier Q>
	inline T const* value_ptr(vec<4, T, Q> const& v)
	{
		return &(v.x);
	}

	template<typename T, qualifier Q>
	inline T* value_ptr(vec<4, T, Q>& v)
	{
		return &(v.x);
	}

	template<typename T, qualifier Q>
	inline T const* value_ptr(mat<2, 2, T, Q> const& m)
	{
		return &(m[0].x);
	}

	template<typename T, qualifier Q>
	inline T* value_ptr(mat<2, 2, T, Q>& m)
	{
		return &(m[0].x);
	}

	template<typename T, qualifier Q>
	inline T const* value_ptr(mat<3, 3, T, Q> const& m)
	{
		return &(m[0].x);
	}

	template<typename T, qualifier Q>
	inline T* value_ptr(mat<3, 3, T, Q>& m)
	{
		return &(m[0].x);
	}

	template<typename T, qualifier Q>
	inline T const* value_ptr(mat<4, 4, T, Q> const& m)
	{
		return &(m[0].x);
	}

	template<typename T, qualifier Q>
	inline T* value_ptr(mat<4, 4, T, Q>& m)
	{
		return &(m[0].x);
	}

	template<typename T, qualifier Q>
	inline T const* value_ptr(mat<2, 3, T, Q> const& m)
	{
		return &(m[0].x);
	}

	template<typename T, qualifier Q>
	inline T* value_ptr(mat<2, 3, T, Q>& m)
	{
		return &(m[0].x);
	}

	template<typename T, qualifier Q>
	inline T const* value_ptr(mat<3, 2, T, Q> const& m)
	{
		return &(m[0].x);
	}

	template<typename T, qualifier Q>
	inline T* value_ptr(mat<3, 2, T, Q>& m)
	{
		return &(m[0].x);
	}

	template<typename T, qualifier Q>
	inline T const* value_ptr(mat<2, 4, T, Q> const& m)
	{
		return &(m[0].x);
	}

	template<typename T, qualifier Q>
	inline T* value_ptr(mat<2, 4, T, Q>& m)
	{
		return &(m[0].x);
	}

	template<typename T, qualifier Q>
	inline T const* value_ptr(mat<4, 2, T, Q> const& m)
	{
		return &(m[0].x);
	}

	template<typename T, qualifier Q>
	inline T* value_ptr(mat<4, 2, T, Q>& m)
	{
		return &(m[0].x);
	}

	template<typename T, qualifier Q>
	inline T const* value_ptr(mat<3, 4, T, Q> const& m)
	{
		return &(m[0].x);
	}

	template<typename T, qualifier Q>
	inline T* value_ptr(mat<3, 4, T, Q>& m)
	{
		return &(m[0].x);
	}

	template<typename T, qualifier Q>
	inline T const* value_ptr(mat<4, 3, T, Q> const& m)
	{
		return &(m[0].x);
	}

	template<typename T, qualifier Q>
	inline T * value_ptr(mat<4, 3, T, Q>& m)
	{
		return &(m[0].x);
	}

	template<typename T, qualifier Q>
	inline T const * value_ptr(qua<T, Q> const& q)
	{
		return &(q[0]);
	}

	template<typename T, qualifier Q>
	inline T* value_ptr(qua<T, Q>& q)
	{
		return &(q[0]);
	}

	template <typename T, qualifier Q>
	[[nodiscard]] vec<1, T, Q> make_vec1(vec<1, T, Q> const& v)
	{
		return v;
	}

	template <typename T, qualifier Q>
	[[nodiscard]] vec<1, T, Q> make_vec1(vec<2, T, Q> const& v)
	{
		return vec<1, T, Q>(v);
	}

	template <typename T, qualifier Q>
	[[nodiscard]] vec<1, T, Q> make_vec1(vec<3, T, Q> const& v)
	{
		return vec<1, T, Q>(v);
	}

	template <typename T, qualifier Q>
	[[nodiscard]] vec<1, T, Q> make_vec1(vec<4, T, Q> const& v)
	{
		return vec<1, T, Q>(v);
	}

	template <typename T, qualifier Q>
	[[nodiscard]] vec<2, T, Q> make_vec2(vec<1, T, Q> const& v)
	{
		return vec<2, T, Q>(v.x, static_cast<T>(0));
	}

	template <typename T, qualifier Q>
	[[nodiscard]] vec<2, T, Q> make_vec2(vec<2, T, Q> const& v)
	{
		return v;
	}

	template <typename T, qualifier Q>
	[[nodiscard]] vec<2, T, Q> make_vec2(vec<3, T, Q> const& v)
	{
		return vec<2, T, Q>(v);
	}

	template <typename T, qualifier Q>
	[[nodiscard]] vec<2, T, Q> make_vec2(vec<4, T, Q> const& v)
	{
		return vec<2, T, Q>(v);
	}

	template <typename T, qualifier Q>
	[[nodiscard]] vec<3, T, Q> make_vec3(vec<1, T, Q> const& v)
	{
		return vec<3, T, Q>(v.x, static_cast<T>(0), static_cast<T>(0));
	}

	template <typename T, qualifier Q>
	[[nodiscard]] vec<3, T, Q> make_vec3(vec<2, T, Q> const& v)
	{
		return vec<3, T, Q>(v.x, v.y, static_cast<T>(0));
	}

	template <typename T, qualifier Q>
	[[nodiscard]] vec<3, T, Q> make_vec3(vec<3, T, Q> const& v)
	{
		return v;
	}

	template <typename T, qualifier Q>
	[[nodiscard]] vec<3, T, Q> make_vec3(vec<4, T, Q> const& v)
	{
		return vec<3, T, Q>(v);
	}

	template <typename T, qualifier Q>
	[[nodiscard]] vec<4, T, Q> make_vec4(vec<1, T, Q> const& v)
	{
		return vec<4, T, Q>(v.x, static_cast<T>(0), static_cast<T>(0), static_cast<T>(1));
	}

	template <typename T, qualifier Q>
	[[nodiscard]] vec<4, T, Q> make_vec4(vec<2, T, Q> const& v)
	{
		return vec<4, T, Q>(v.x, v.y, static_cast<T>(0), static_cast<T>(1));
	}

	template <typename T, qualifier Q>
	[[nodiscard]] vec<4, T, Q> make_vec4(vec<3, T, Q> const& v)
	{
		return vec<4, T, Q>(v.x, v.y, v.z, static_cast<T>(1));
	}

	template <typename T, qualifier Q>
	[[nodiscard]] vec<4, T, Q> make_vec4(vec<4, T, Q> const& v)
	{
		return v;
	}

	template<typename T>
	inline vec<2, T, defaultp> make_vec2(T const *const ptr)
	{
		vec<2, T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(vec<2, T, defaultp>));
		return Result;
	}

	template<typename T>
	inline vec<3, T, defaultp> make_vec3(T const *const ptr)
	{
		vec<3, T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(vec<3, T, defaultp>));
		return Result;
	}

	template<typename T>
	inline vec<4, T, defaultp> make_vec4(T const *const ptr)
	{
		vec<4, T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(vec<4, T, defaultp>));
		return Result;
	}

	template<typename T>
	inline mat<2, 2, T, defaultp> make_mat2x2(T const *const ptr)
	{
		mat<2, 2, T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(mat<2, 2, T, defaultp>));
		return Result;
	}

	template<typename T>
	inline mat<2, 3, T, defaultp> make_mat2x3(T const *const ptr)
	{
		mat<2, 3, T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(mat<2, 3, T, defaultp>));
		return Result;
	}

	template<typename T>
	inline mat<2, 4, T, defaultp> make_mat2x4(T const *const ptr)
	{
		mat<2, 4, T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(mat<2, 4, T, defaultp>));
		return Result;
	}

	template<typename T>
	inline mat<3, 2, T, defaultp> make_mat3x2(T const *const ptr)
	{
		mat<3, 2, T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(mat<3, 2, T, defaultp>));
		return Result;
	}

	template<typename T>
	inline mat<3, 3, T, defaultp> make_mat3x3(T const *const ptr)
	{
		mat<3, 3, T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(mat<3, 3, T, defaultp>));
		return Result;
	}

	template<typename T>
	inline mat<3, 4, T, defaultp> make_mat3x4(T const *const ptr)
	{
		mat<3, 4, T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(mat<3, 4, T, defaultp>));
		return Result;
	}

	template<typename T>
	inline mat<4, 2, T, defaultp> make_mat4x2(T const *const ptr)
	{
		mat<4, 2, T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(mat<4, 2, T, defaultp>));
		return Result;
	}

	template<typename T>
	inline mat<4, 3, T, defaultp> make_mat4x3(T const *const ptr)
	{
		mat<4, 3, T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(mat<4, 3, T, defaultp>));
		return Result;
	}

	template<typename T>
	inline mat<4, 4, T, defaultp> make_mat4x4(T const *const ptr)
	{
		mat<4, 4, T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(mat<4, 4, T, defaultp>));
		return Result;
	}

	template<typename T>
	inline mat<2, 2, T, defaultp> make_mat2(T const *const ptr)
	{
		return make_mat2x2(ptr);
	}

	template<typename T>
	inline mat<3, 3, T, defaultp> make_mat3(T const *const ptr)
	{
		return make_mat3x3(ptr);
	}

	template<typename T>
	inline mat<4, 4, T, defaultp> make_mat4(T const *const ptr)
	{
		return make_mat4x4(ptr);
	}

	template<typename T>
	inline qua<T, defaultp> make_quat(T const *const ptr)
	{
		qua<T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(qua<T, defaultp>));
		return Result;
	}

	
}

#line 231 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\type_ptr.hpp"
#line 190 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\ulp.hpp"














#pragma once


#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 970 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
























































































































































































































#line 1187 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"

#line 1189 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\detail\\setup.hpp"
#line 19 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\ulp.hpp"






#line 26 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\ulp.hpp"

namespace glm
{
	
	

	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType next_float(genType x);

	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType prev_float(genType x);

	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType next_float(genType x, int ULPs);

	
	
	
	
	
	template<typename genType>
	[[nodiscard]] genType prev_float(genType x, int ULPs);

	
	
	
	[[nodiscard]] int float_distance(float x, float y);

	
	
	
	[[nodiscard]] int64 float_distance(double x, double y);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> next_float(vec<L, T, Q> const& x);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> next_float(vec<L, T, Q> const& x, int ULPs);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> next_float(vec<L, T, Q> const& x, vec<L, int, Q> const& ULPs);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> prev_float(vec<L, T, Q> const& x);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> prev_float(vec<L, T, Q> const& x, int ULPs);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, T, Q> prev_float(vec<L, T, Q> const& x, vec<L, int, Q> const& ULPs);

	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, int, Q> float_distance(vec<L, float, Q> const& x, vec<L, float, Q> const& y);

	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	[[nodiscard]] vec<L, int64, Q> float_distance(vec<L, double, Q> const& x, vec<L, double, Q> const& y);

	
}

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\ulp.inl"




namespace glm
{
	template<>
	inline float next_float(float x)
	{

		return std::nextafter(x, std::numeric_limits<float>::max());






#line 19 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\ulp.inl"
	}

	template<>
	inline double next_float(double x)
	{

		return std::nextafter(x, std::numeric_limits<double>::max());






#line 33 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\ulp.inl"
	}

	template<typename T>
	inline T next_float(T x, int ULPs)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'next_float' only accept floating-point input") ;
		(void)( (!!(ULPs >= 0)) || (_wassert(L"ULPs >= 0", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\ulp.inl", (unsigned)(39)), 0) ) ;

		T temp = x;
		for (int i = 0; i < ULPs; ++i)
			temp = next_float(temp);
		return temp;
	}

	inline float prev_float(float x)
	{

		return std::nextafter(x, std::numeric_limits<float>::min());






#line 58 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\ulp.inl"
	}

	inline double prev_float(double x)
	{

		return std::nextafter(x, std::numeric_limits<double>::min());






#line 71 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\ulp.inl"
	}

	template<typename T>
	inline T prev_float(T x, int ULPs)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'prev_float' only accept floating-point input") ;
		(void)( (!!(ULPs >= 0)) || (_wassert(L"ULPs >= 0", L"D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\ulp.inl", (unsigned)(77)), 0) ) ;

		T temp = x;
		for (int i = 0; i < ULPs; ++i)
			temp = prev_float(temp);
		return temp;
	}

	inline int float_distance(float x, float y)
	{
		detail::float_t<float> const a(x);
		detail::float_t<float> const b(y);

		return abs(a.i - b.i);
	}

	inline int64 float_distance(double x, double y)
	{
		detail::float_t<double> const a(x);
		detail::float_t<double> const b(y);

		return abs(a.i - b.i);
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> next_float(vec<L, T, Q> const& x)
	{
		vec<L, T, Q> Result;
		for (length_t i = 0, n = Result.length(); i < n; ++i)
			Result[i] = next_float(x[i]);
		return Result;
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> next_float(vec<L, T, Q> const& x, int ULPs)
	{
		vec<L, T, Q> Result;
		for (length_t i = 0, n = Result.length(); i < n; ++i)
			Result[i] = next_float(x[i], ULPs);
		return Result;
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> next_float(vec<L, T, Q> const& x, vec<L, int, Q> const& ULPs)
	{
		vec<L, T, Q> Result;
		for (length_t i = 0, n = Result.length(); i < n; ++i)
			Result[i] = next_float(x[i], ULPs[i]);
		return Result;
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> prev_float(vec<L, T, Q> const& x)
	{
		vec<L, T, Q> Result;
		for (length_t i = 0, n = Result.length(); i < n; ++i)
			Result[i] = prev_float(x[i]);
		return Result;
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> prev_float(vec<L, T, Q> const& x, int ULPs)
	{
		vec<L, T, Q> Result;
		for (length_t i = 0, n = Result.length(); i < n; ++i)
			Result[i] = prev_float(x[i], ULPs);
		return Result;
	}

	template<length_t L, typename T, qualifier Q>
	inline vec<L, T, Q> prev_float(vec<L, T, Q> const& x, vec<L, int, Q> const& ULPs)
	{
		vec<L, T, Q> Result;
		for (length_t i = 0, n = Result.length(); i < n; ++i)
			Result[i] = prev_float(x[i], ULPs[i]);
		return Result;
	}

	template<length_t L, qualifier Q>
	inline vec<L, int, Q> float_distance(vec<L, float, Q> const& x, vec<L, float, Q> const& y)
	{
		vec<L, int, Q> Result;
		for (length_t i = 0, n = Result.length(); i < n; ++i)
			Result[i] = float_distance(x[i], y[i]);
		return Result;
	}

	template<length_t L, qualifier Q>
	inline vec<L, int64, Q> float_distance(vec<L, double, Q> const& x, vec<L, double, Q> const& y)
	{
		vec<L, int64, Q> Result;
		for (length_t i = 0, n = Result.length(); i < n; ++i)
			Result[i] = float_distance(x[i], y[i]);
		return Result;
	}
}

#line 156 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\gtc\\ulp.hpp"
#line 191 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"



#line 195 "D:\\dev\\DaisyEngine\\DaisyEngine\\vendor\\glm\\ext.hpp"









































































#line 4 "D:\\dev\\DaisyEngine\\DaisyEngine\\src\\Camera.h"

#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\src\\Window.h"
#pragma once
#line 1 "D:\\dev\\DaisyEngine\\DaisyEngine\\glew\\include\\GL\\glew.h"




















































































